package processing.app.contrib;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.LayoutStyle;

public class UpdateStatusPanel extends StatusPanel {
  public UpdateStatusPanel(int width, final ContributionTab contributionTab) {
    super();
    updateButton = new JButton("Update All");
    updateButton.setContentAreaFilled(false);
    updateButton.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.BLACK, 1),BorderFactory.createEmptyBorder(3, 0, 3, 0)));
    updateButton.addActionListener(new ActionListener() {
      
      @Override
      public void actionPerformed(ActionEvent e) {

        for(ContributionPanel contributionPanel : contributionTab.contributionListPanel.panelByContribution.values()){
          contributionPanel.update();
        }
      }
    });
    this.setBackground(Color.WHITE);
    this.setBorder(BorderFactory.createMatteBorder(2, 0, 0, 0, Color.BLACK));
    layout = new GroupLayout(this);
    this.setLayout(layout);
    
    layout.setAutoCreateContainerGaps(true);
    layout.setAutoCreateGaps(true);

    layout.setHorizontalGroup(layout
      .createSequentialGroup()
      .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                       GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
      .addComponent(updateButton, BUTTON_WIDTH, BUTTON_WIDTH, BUTTON_WIDTH));
    layout.setVerticalGroup(layout.createParallelGroup()
      .addComponent(updateButton));
    updateButton.setVisible(true);
  }
  @Override
  public void update(ContributionPanel panel) {
    
  }
}

<code block>



package processing.app.contrib;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;

import java.awt.*;

import javax.swing.border.*;

import processing.app.*;
import processing.app.ui.Editor;
import processing.app.ui.Toolkit;


public class ContributionTab {
  static final String ANY_CATEGORY = Language.text("contrib.all");

  ContributionType contributionType;
  ContributionManagerDialog contributionManagerDialog;
  JPanel panel;
  String title;
  ContributionFilter filter;
  JComboBox<String> categoryChooser;
  JScrollPane scrollPane;
  ContributionListPanel contributionListPanel;
  StatusPanel statusPanel;
  FilterField filterField;
  JLabel filterLabel;
  JButton restartButton;
  JLabel categoryLabel;
  JLabel loaderLabel;

  JPanel errorPanel;
  JTextPane errorMessage;
  JButton tryAgainButton;
  JButton closeButton;


  Editor editor;
  String category;
  ContributionListing contribListing;

  JProgressBar progressBar;


  public ContributionTab(ContributionType type,ContributionManagerDialog contributionManagerDialog) {
    if (type == null) {
      title = Language.text("contrib.manager_title.update");
      filter = ContributionType.createUpdateFilter();
    } else {
      if (type == ContributionType.MODE) {
        title = Language.text("contrib.manager_title.mode");
      }
      else if (type == ContributionType.TOOL) {
        title = Language.text("contrib.manager_title.tool");
      }
      else if (type == ContributionType.LIBRARY) {
        title = Language.text("contrib.manager_title.library");
      }
      else if (type == ContributionType.EXAMPLES) {
        title = Language.text("contrib.manager_title.examples");
      }

      filter = type.createFilter();
    }
    this.contributionType = type;
    this.contributionManagerDialog = contributionManagerDialog;
    contribListing = ContributionListing.getInstance();
    if (contributionType == null) {
      contributionListPanel = new UpdateContribListingPanel(this, filter);
      statusPanel = new UpdateStatusPanel(650, this);
    } else {
      statusPanel = new StatusPanel(650,this);
      contributionListPanel = new ContributionListPanel(this, filter);
    }
    contribListing.addContributionListener(contributionListPanel);
  }


  public boolean hasUpdates() {
    return contribListing.hasUpdates();
  }


  public boolean hasUpdates(Base base) {
    return contribListing.hasUpdates(base);
  }













  public void showFrame(final Editor editor, boolean activateErrorPanel,
                        final boolean isLoading) {
    this.editor = editor;
    if (panel == null) {
      setLayout(editor, activateErrorPanel, isLoading);
    }
    contributionListPanel.setVisible(!isLoading);
    loaderLabel.setVisible(isLoading);
    errorPanel.setVisible(activateErrorPanel);
    panel.validate();
    panel.repaint();
  }


  public void setLayout(final Editor editor, boolean activateErrorPanel, boolean isLoading) {
    if(panel == null){
      progressBar = new JProgressBar();
      progressBar.setVisible(false);
      createComponents();
      panel = new JPanel(false);
      loaderLabel = new JLabel(Toolkit.getLibIcon("icons/loader.gif"));
      loaderLabel.setOpaque(false);
      loaderLabel.setBackground(Color.WHITE);
      filterLabel = new JLabel("Filter");
      filterLabel.setOpaque(false);
    }




    GroupLayout layout = new GroupLayout(panel);
    panel.setLayout(layout);


    layout.setHorizontalGroup(layout
      .createParallelGroup(GroupLayout.Alignment.CENTER)
      .addGroup(layout
                  .createSequentialGroup()
                  .addContainerGap()
                  .addComponent(filterLabel)
                  .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                  .addComponent(filterField)
                  .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                  .addComponent(categoryChooser,
                                categoryChooser.getPreferredSize().width + 20,
                                categoryChooser.getPreferredSize().width + 20,
                                categoryChooser.getPreferredSize().width + 20)
                  .addContainerGap()).addComponent(loaderLabel)
      .addComponent(contributionListPanel).addComponent(errorPanel)
      .addComponent(statusPanel));

    layout.setVerticalGroup(layout
      .createSequentialGroup()
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(filterLabel).addComponent(categoryChooser)
                  .addComponent(filterField))
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(loaderLabel)
                  .addComponent(contributionListPanel))
      .addComponent(errorPanel)
      .addComponent(statusPanel, GroupLayout.PREFERRED_SIZE,
                    GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE));
    layout.linkSize(SwingConstants.VERTICAL, categoryChooser, filterField);
    layout.setHonorsVisibility(contributionListPanel, false);

    panel.setBackground(Color.WHITE);
    panel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
 }



  private void createComponents() {

      categoryLabel = new JLabel(Language.text("contrib.category"));

      categoryChooser = new JComboBox<String>();
      categoryChooser.setMaximumRowCount(20);

      updateCategoryChooser();

      categoryChooser.addItemListener(new ItemListener() {
        public void itemStateChanged(ItemEvent e) {
          category = (String) categoryChooser.getSelectedItem();
          if (ContributionManagerDialog.ANY_CATEGORY.equals(category)) {
            category = null;
          }
          filterLibraries(category, filterField.filters);
          contributionListPanel.updateColors();
        }
      });

      filterField = new FilterField();

      buildErrorPanel();

  }
  private void buildErrorPanel(){
    errorPanel = new JPanel();
    GroupLayout layout = new GroupLayout(errorPanel);
    layout.setAutoCreateGaps(true);
    layout.setAutoCreateContainerGaps(true);
    errorPanel.setLayout(layout);
    errorMessage = new JTextPane();
    errorMessage.setEditable(false);
    errorMessage.setText("Could not connect to the Processing server. "
      + "Contributions cannot be installed or updated without an Internet connection. "
      + "Please verify your network connection again, then try connecting again.");
    errorMessage.setMaximumSize(new Dimension(450, 50));
    errorMessage.setOpaque(false);

    StyledDocument doc = errorMessage.getStyledDocument();
    SimpleAttributeSet center = new SimpleAttributeSet();
    StyleConstants.setAlignment(center, StyleConstants.ALIGN_CENTER);
    doc.setParagraphAttributes(0, doc.getLength(), center, false);


    closeButton = new JButton("X");
    closeButton.setContentAreaFilled(false);
    closeButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent e) {
        contributionManagerDialog.makeAndShowTab(false, false);
      }
    });
    tryAgainButton = new JButton("Try Again");
    tryAgainButton.setContentAreaFilled(false);
    tryAgainButton.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.BLACK, 1),BorderFactory.createEmptyBorder(3, 0, 3, 0)));
    tryAgainButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent e) {
        contributionManagerDialog.makeAndShowTab(false, true);
        contributionManagerDialog.downloadAndUpdateContributionListing(editor.getBase());
      }
    });
    layout.setHorizontalGroup(layout
      .createSequentialGroup()
      .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                       GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
      .addGroup(layout
                  .createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(errorMessage)
                  .addComponent(tryAgainButton, statusPanel.BUTTON_WIDTH,
                                statusPanel.BUTTON_WIDTH,
                                statusPanel.BUTTON_WIDTH))
      .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                       GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
      .addComponent(closeButton));
    layout.setVerticalGroup(layout
      .createSequentialGroup()
      .addGroup(layout.createParallelGroup().addComponent(errorMessage)
                  .addComponent(closeButton)).addComponent(tryAgainButton));
    errorPanel.setBackground(Color.PINK);
    errorPanel.validate();
  }



  protected void updateCategoryChooser() {
    if (categoryChooser != null) {
      ArrayList<String> categories;
      categoryChooser.removeAllItems();
      categories = new ArrayList<String>(contribListing.getCategories(filter));



      Collections.sort(categories);

      @SuppressWarnings("unused")
      boolean categoriesFound = false;
      categoryChooser.addItem(ContributionManagerDialog.ANY_CATEGORY);
      for (String s : categories) {
        categoryChooser.addItem(s);
        if (!s.equals(Contribution.UNKNOWN_CATEGORY)) {
          categoriesFound = true;
        }
      }
      categoryChooser.setEnabled(categoriesFound);
    }
  }


  protected void filterLibraries(String category, List<String> filters) {
    List<Contribution> filteredLibraries =
      contribListing.getFilteredLibraryList(category, filters);
    contributionListPanel.filterLibraries(filteredLibraries);
  }




  protected void updateContributionListing() {
    if (editor != null) {
      List<Contribution> contributions = new ArrayList<Contribution>();

      List<Library> libraries =
        new ArrayList<Library>(editor.getMode().contribLibraries);
      contributions.addAll(libraries);


      List<ToolContribution> tools = editor.getToolContribs();
      contributions.addAll(tools);

      List<ModeContribution> modes = editor.getBase().getModeContribs();
      contributions.addAll(modes);

      List<ExamplesContribution> examples = editor.getBase().getExampleContribs();
      contributions.addAll(examples);














      contribListing.updateInstalledList(contributions);
    }
  }

  protected void setFilterText(String filter) {
    if (filter == null || filter.isEmpty()) {
      filterField.setText("");
    } else {
      filterField.setText(filter);
    }
    filterField.applyFilter();
  }







  class FilterField extends JTextField {
    Icon searchIcon;
    List<String> filters;

    public FilterField () {

      super("");
      searchIcon = Toolkit.getLibIcon("icons/searchIcon.png");
      setOpaque(false);

      filters = new ArrayList<String>();

      addFocusListener(new FocusListener() {
        public void focusLost(FocusEvent focusEvent) {
          if (getText().isEmpty()) {
            setBorder(BorderFactory.createMatteBorder(0, 33, 0, 0, searchIcon));
          }
        }

        public void focusGained(FocusEvent focusEvent) {
          setBorder(BorderFactory.createEmptyBorder(0, 3, 0, 0));
        }
      });

      getDocument().addDocumentListener(new DocumentListener() {
        public void removeUpdate(DocumentEvent e) {
          applyFilter();
        }

        public void insertUpdate(DocumentEvent e) {
          applyFilter();
        }

        public void changedUpdate(DocumentEvent e) {
          applyFilter();
        }
      });
    }
    
    public void applyFilter() {
      String filter = getText();
      filter = filter.toLowerCase();


      filter = filter.replaceAll("[^\\x30-\\x39^\\x61-\\x7a^\\x3a]", " ");
      filters = Arrays.asList(filter.split(" "));
      filterLibraries(category, filters);

      contributionListPanel.updateColors();
    }

  }


  public boolean hasAlreadyBeenOpened() {
    return panel != null;
  }

  public void updateStatusPanel(ContributionPanel contributionPanel) {
    statusPanel.update(contributionPanel);
  }
}

<code block>



package processing.app.contrib;

import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.SocketTimeoutException;
import java.util.*;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicTabbedPaneUI;

import processing.app.*;
import processing.app.ui.Editor;
import processing.app.ui.Toolkit;


public class ContributionManagerDialog {
  static final String ANY_CATEGORY = Language.text("contrib.all");

  JFrame dialog;
  JTabbedPane tabbedPane;
  String title;
  JButton restartButton;

  

  Editor editor;
  

  ContributionTab toolsContributionTab;
  ContributionTab librariesContributionTab;
  ContributionTab examplesContributionTab;
  ContributionTab modesContributionTab;
  ContributionTab updatesContributionTab;
  
  JLabel numberLabel;
  
  ContributionListing contributionListing = ContributionListing.getInstance(); 

  public ContributionManagerDialog() {
    numberLabel = new JLabel();
    toolsContributionTab = new ContributionTab(ContributionType.TOOL, this);
    librariesContributionTab = new ContributionTab(ContributionType.LIBRARY, this);
    modesContributionTab = new ContributionTab(ContributionType.MODE, this);
    examplesContributionTab = new ContributionTab(ContributionType.EXAMPLES, this);
    updatesContributionTab = new ContributionTab(null, this);
  }

  public boolean hasUpdates() {
    return toolsContributionTab.hasUpdates()
      || librariesContributionTab.hasUpdates()
      || examplesContributionTab.hasUpdates()
      || modesContributionTab.hasUpdates();
  }

  public boolean hasUpdates(Base base) {
    return toolsContributionTab.hasUpdates(base)
      || modesContributionTab.hasUpdates(base)
      || librariesContributionTab.hasUpdates(base)
      || examplesContributionTab.hasUpdates(base);
  }

  public void showFrame(final Editor editor, ContributionType contributionType) {
    this.editor = editor;


    int index;
    if (contributionType == ContributionType.TOOL) {
      index = 0;
    } else if (contributionType == ContributionType.LIBRARY) {
      index = 1;
    } else if (contributionType == ContributionType.MODE) {
      index = 2;
    } else if (contributionType == ContributionType.EXAMPLES) {
      index = 3;
    } else {
      index = 4;
    }
    if (dialog == null) {
      makeFrame(editor);
      tabbedPane.setSelectedIndex(index); 
      downloadAndUpdateContributionListing(editor.getBase());
    }
    tabbedPane.setSelectedIndex(index); 
    dialog.setVisible(true);
  }

  public void makeFrame(final Editor editor) {
    dialog = new JFrame(title);
    String[] tabTitles = { "Tools","Libraries","Modes","Examples","Updates"};
    tabbedPane = new JTabbedPane();

    makeAndShowTab(false, true);

    tabbedPane.addTab("Tools", null, toolsContributionTab.panel, "Tools");
    tabbedPane.setMnemonicAt(0, KeyEvent.VK_1);

    tabbedPane.addTab("Libraries", null, librariesContributionTab.panel,
                      "Libraries");
    tabbedPane.setMnemonicAt(1, KeyEvent.VK_2);

    tabbedPane.addTab("Modes", null, modesContributionTab.panel, "Modes");
    tabbedPane.setMnemonicAt(2, KeyEvent.VK_3);

    tabbedPane.addTab("Examples", null, examplesContributionTab.panel,
                      "Examples");
    tabbedPane.setMnemonicAt(3, KeyEvent.VK_4);

    tabbedPane.addTab("Updates", null, updatesContributionTab.panel, "Updates");
    tabbedPane.setMnemonicAt(3, KeyEvent.VK_5);
    tabbedPane.setUI(new SpacedTabbedPaneUI());
    tabbedPane.setBackground(Color.WHITE);
    tabbedPane.setOpaque(true);
    tabbedPane.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
    
    
    JPanel updateTabPanel = new JPanel(true);
    numberLabel.setOpaque(false);
    numberLabel.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
    JLabel numberBackground = new JLabel(Toolkit.getLibIcon("icons/notification.png"));
    JLabel updateTabLabel = new JLabel("Update");
    updateTabPanel.setOpaque(false);
    updateTabPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory
      .createMatteBorder(0, 2, 0, 0, Color.BLACK), BorderFactory
      .createEmptyBorder(4, 4, 4, 4)));
    tabbedPane.setTabComponentAt(4, updateTabPanel);
    
    JLabel tabLabels[] = new JLabel[4];
    for(int i = 0 ; i < tabLabels.length;i++){
      tabLabels[i] = new JLabel(tabTitles[i]);
      tabLabels[i]
        .setBorder(BorderFactory.createCompoundBorder(BorderFactory
          .createMatteBorder(0, (i == 0 ? 0 : 2), 0, (i == 3 ? 2 : 0),
                             Color.BLACK), BorderFactory
          .createEmptyBorder(4, 4, 4, 4)));
      tabbedPane.setTabComponentAt(i, tabLabels[i]);
    }
    
    GroupLayout tabLayout = new GroupLayout(updateTabPanel);
    tabLayout.setAutoCreateGaps(true);
    updateTabPanel.setLayout(tabLayout);
    tabLayout.setHorizontalGroup(tabLayout
      .createSequentialGroup()
      .addGroup(tabLayout.createParallelGroup().addComponent(numberLabel)
                  .addComponent(numberBackground)).addComponent(updateTabLabel));
    tabLayout.setVerticalGroup(tabLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
      .addComponent(numberBackground).addComponent(numberLabel)
      .addComponent(updateTabLabel));
    
    tabbedPane.addChangeListener(new ChangeListener() {
      
      @Override
      public void stateChanged(ChangeEvent e) {






      }
    });
    
    

    setLayout();
    
    restartButton = new JButton(Language.text("contrib.restart"));
    restartButton.setVisible(false);
    restartButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent arg0) {

        Iterator<Editor> iter = editor.getBase().getEditors().iterator();
        while (iter.hasNext()) {
          Editor ed = iter.next();
          if (ed.getSketch().isModified()) {
            int option = Base.showYesNoQuestion(editor, title, Language
              .text("contrib.unsaved_changes"), Language
              .text("contrib.unsaved_changes.prompt"));

            if (option == JOptionPane.NO_OPTION)
              return;
            else
              break;
          }
        }


        StringBuilder cmd = new StringBuilder();
        cmd.append(System.getProperty("java.home") + File.separator + "bin"
          + File.separator + "java ");
        for (String jvmArg : ManagementFactory.getRuntimeMXBean()
          .getInputArguments()) {
          cmd.append(jvmArg + " ");
        }
        cmd.append("-cp ")
          .append(ManagementFactory.getRuntimeMXBean().getClassPath())
          .append(" ");
        cmd.append(Base.class.getName());

        try {
          Runtime.getRuntime().exec(cmd.toString());
          System.exit(0);
        } catch (IOException e) {
          e.printStackTrace();
        }

      }

    });

    Toolkit.setIcon(dialog);
    registerDisposeListeners();

    dialog.pack();
    dialog.setLocationRelativeTo(null);
  }

  public class SpacedTabbedPaneUI extends BasicTabbedPaneUI {
    
    
    @Override
    protected void installDefaults() {
      UIManager.put("TabbedPane.selected", Color.WHITE);
      super.installDefaults();
      highlight = Color.WHITE;
      lightHighlight = Color.WHITE;
      shadow = Color.WHITE;
      darkShadow = Color.WHITE;
      focus = Color.LIGHT_GRAY;
      tabInsets = new Insets(0, 0, 0, 0);
      contentBorderInsets = new Insets(0, 0, 0, 0);
      tabAreaInsets = new Insets(0, 0, 0, 0);
      selectedTabPadInsets = new Insets(0, 0, 0, 0);
    }
    
    @Override
    protected LayoutManager createLayoutManager() {
      return new BasicTabbedPaneUI.TabbedPaneLayout() {
        
        @Override
        public void addLayoutComponent(String name, Component comp) {

          super.addLayoutComponent(name, comp);
        }
        @Override
        protected void calculateTabRects(int tabPlacement, int tabCount) {
          super.calculateTabRects(tabPlacement, tabCount);
          for (int i = 0; i < rects.length; i++) {
            rects[i].y -= 10;
            rects[i].height += 15;
            if (i == 4) {
              rects[i].x = tabbedPane.getWidth() - rects[i].width - 2;
            }
          }
        }
      };
    }
  }
  
  private void setLayout() {
    GroupLayout layout = new GroupLayout(dialog.getContentPane());
    dialog.getContentPane().setLayout(layout);
    dialog.setResizable(true);
    layout.setAutoCreateContainerGaps(true);
    layout.setHorizontalGroup(layout.createParallelGroup()
                              .addComponent(tabbedPane));
    layout.setVerticalGroup(layout
      .createParallelGroup()
      .addComponent(tabbedPane));
    layout.setHonorsVisibility(tabbedPane, true);
    dialog.getContentPane().setBackground(Color.WHITE);
    dialog.validate();
    dialog.repaint();
  }
  
  
  


  protected void disposeFrame() {
    dialog.dispose();
    editor = null;
  }


  private void registerDisposeListeners() {
    dialog.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        disposeFrame();
      }
    });

    Toolkit.registerWindowCloseKeys(dialog.getRootPane(), new ActionListener() {
      public void actionPerformed(ActionEvent actionEvent) {
        disposeFrame();
      }
    });

    dialog.getContentPane().addKeyListener(new KeyAdapter() {
      public void keyPressed(KeyEvent e) {

        KeyStroke wc = Toolkit.WINDOW_CLOSE_KEYSTROKE;
        if ((e.getKeyCode() == KeyEvent.VK_ESCAPE)
          || (KeyStroke.getKeyStrokeForEvent(e).equals(wc))) {
          disposeFrame();
        }
      }
    });
  }



  protected void downloadAndUpdateContributionListing(Base base) {
    


    final ContributionTab activeTab = getActiveTab();
    activeTab.statusPanel.setMessage(Language
      .text("contrib.status.downloading_list"));
    activeTab.contribListing.downloadAvailableList(base, new ContribProgressBar(
      activeTab.progressBar) {

      @Override
      public void startTask(String name, int maxValue) {
        super.startTask(name, maxValue);
        progressBar.setVisible(true);
        progressBar.setString(null);
      }

      @Override
      public void setProgress(int value) {
        super.setProgress(value);

        progressBar.setValue(value);
        progressBar.setStringPainted(true);
        activeTab.statusPanel.setMessage(Language
          .text("contrib.status.downloading_list"));
      }

      @Override
      public void finishedAction() {
        progressBar.setVisible(false);
        activeTab.updateContributionListing();
        activeTab.updateCategoryChooser();


        if (error) {
          if (exception instanceof SocketTimeoutException) {
            activeTab.statusPanel.setErrorMessage(Language
              .text("contrib.errors.list_download.timeout"));
          } else {
            activeTab.statusPanel.setErrorMessage(Language
              .text("contrib.errors.list_download"));
          }
          exception.printStackTrace();
          makeAndShowTab(true,false);
        } else {
          makeAndShowTab(false, false);
          activeTab.statusPanel.setMessage(Language.text("contrib.status.done"));
        }
      }

   

    });
  }

  void makeAndShowTab(boolean activateErrorPanel, boolean isLoading) {
    toolsContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    librariesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    modesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    examplesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    updatesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
  }
  

  public ContributionTab getActiveTab() {
    
    switch (tabbedPane.getSelectedIndex()) {
    case 0:
      return toolsContributionTab;
    case 1:
      return librariesContributionTab;
    case 2:
      return modesContributionTab;
    case 3:
      return examplesContributionTab;
    default:
      return updatesContributionTab;
    }
    
  }



  public boolean hasAlreadyBeenOpened() {
    return dialog != null;
  }
}

<code block>
package processing.app.contrib;

import java.awt.Color;
import java.awt.Component;
import java.util.Comparator;
import java.util.Set;
import java.util.TreeMap;

import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;

import processing.app.Base;
import processing.app.contrib.ContributionListPanel.MyColumnHeaderRenderer;
import processing.app.ui.Toolkit;

public class UpdateContribListingPanel extends ContributionListPanel {

  public UpdateContribListingPanel(ContributionTab contributionTab,
                                   ContributionFilter filter) {
    super.contributionTab = contributionTab;
    super.filter = filter;
    setOpaque(true);

    if (Base.isLinux()) {



      setBackground(Color.white);
    } else {
      setBackground(UIManager.getColor("List.background"));
    }




    
    String[] colName = { "", "Name", "Author", "Installed", "Update To" };
    dtm = new MyTableModel();
    dtm.setColumnIdentifiers(colName);
    table = new JTable(dtm){
      @Override
      public Component prepareRenderer(
              TableCellRenderer renderer, int row, int column) {
        Component c = super.prepareRenderer(renderer, row, column);
        String title = (String) getValueAt(row, 1);
        if (title.equals("<html><i>Library</i></html>") || title.equals("Tools")
          || title.equals("Modes") || title.equals("Examples")) {
          ((JComponent) c).setBorder(BorderFactory
            .createMatteBorder(row == 0 ? 0 : 2, 0, 2, 0, Color.BLACK));
        }
        return c;
      }
      @Override
      public void changeSelection(int rowIndex, int columnIndex,
                                  boolean toggle, boolean extend) {
        String title = (String) getValueAt(rowIndex, 1);
        if(title.equals("<html><i>Library</i></html>")){
          return;
        }
        super.changeSelection(rowIndex, columnIndex, toggle, extend);
      }







    };
    JScrollPane scrollPane = new JScrollPane(table);
    table.setFillsViewportHeight(true);
    table.setRowHeight(30);
    table.setRowMargin(6);
    table.getColumnModel().setColumnMargin(-1);
    table.getColumnModel().getColumn(0).setMaxWidth(60);
    table.setShowGrid(false);
    table.setCellSelectionEnabled(false);
    table.setRowSelectionAllowed(true);
    table.setAutoCreateColumnsFromModel(true);
    table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    table.getTableHeader().setDefaultRenderer(new MyColumnHeaderRenderer() {
      @Override
      public Component getTableCellRendererComponent(JTable table,
                                                     Object value,
                                                     boolean isSelected,
                                                     boolean hasFocus, int row,
                                                     int column) {
        super.getTableCellRendererComponent(table, value, isSelected, hasFocus,
                                            row, column);
        JTableHeader tableHeader = table.getTableHeader();
        if (tableHeader != null) {
          setForeground(tableHeader.getForeground());
        }
        setIcon(getIcon(table, column));
        setBackground(Color.WHITE);
        setBorder(BorderFactory.createMatteBorder(2, 0, 2, 0, Color.BLACK));
        return this;
      }
    });

    GroupLayout layout = new GroupLayout(this);
    layout.setHorizontalGroup(layout.createParallelGroup().addComponent(scrollPane));
    layout.setVerticalGroup(layout.createSequentialGroup().addComponent(scrollPane));

    this.setLayout(layout);
    table.setVisible(true);
    
    panelByContribution = new TreeMap<Contribution, ContributionPanel>(new Comparator<Contribution>() {

      @Override
      public int compare(Contribution o1, Contribution o2) {
        int val1 = 0;
        int val2 = 0;
        switch(o1.getType()){
        case LIBRARY: val1 = 1;
        break;
        case TOOL: val1 = 2;
        break;
        case MODE: val1 = 3;
        break;
        case EXAMPLES: val1 = 4;
        break;
        }
        switch(o2.getType()){
        case LIBRARY: val2 = 1;
        break;
        case TOOL: val2 = 2;
        break;
        case MODE: val2 = 3;
        break;
        case EXAMPLES: val2 = 4;
        break;
        }
        if(val1 == val2){
          return o1.getName().toLowerCase().compareTo(o2.getName().toLowerCase());
        }
        return val1 - val2;
      }
    });
    
  }








  @Override
  void updatePanelOrdering(Set<Contribution> contributionsSet) {
    contributionTab.contributionManagerDialog.numberLabel.setText(Integer
      .toString(panelByContribution.size()));
    dtm.getDataVector().removeAllElements();
    dtm.fireTableDataChanged();
    ContributionType temp = null;
    for (Contribution entry : contributionsSet) {
      if(entry.getType() != temp){
        temp = entry.getType();
        dtm.addRow(new Object[] { null, "<html><i>" + temp.getTitle() + "</i></html>", null, null, null });
      }

      StringBuilder name = new StringBuilder("");
      String authorList = entry.getAuthorList();
      if (authorList != null) {
        for (int i = 0; i < authorList.length(); i++) {

          if (authorList.charAt(i) == '[' || authorList.charAt(i) == ']') {
            continue;
          }
          if (authorList.charAt(i) == '(') {
            i++;
            while (authorList.charAt(i) != ')') {
              i++;
            }
          } else {
            name.append(authorList.charAt(i));
          }
        }
      }
      Icon icon = null;
      if (entry.isInstalled()) {
        icon = Toolkit.getLibIcon("icons/installedAndUptodate.png");
        if (contribListing.hasUpdates(entry)) {
          icon = Toolkit.getLibIcon("icons/installedNeedsUpdate.png");
        }
        if (!entry.isCompatible(Base.getRevision())) {
          icon = Toolkit.getLibIcon("icons/installedIncompatible.png");
        }
      }
      dtm
        .addRow(new Object[] {
          icon, "<html><b>" + entry.getName() + "</b></html>", name, entry.getPrettyVersion(),
          contributionTab.contribListing.getLatestVersion(entry) });
    }
  }
  private class MyTableModel extends DefaultTableModel{
    MyTableModel() {
      super(0,0);
    }
    @Override
    public boolean isCellEditable(int row, int column) {
      return false;
    }
    @Override
    public Class<?> getColumnClass(int columnIndex) {
      if(columnIndex == 0){
        return Icon.class;
      }
      return super.getColumnClass(columnIndex);
    }
  }
}

<code block>



package processing.app.contrib;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;

import java.awt.*;

import javax.swing.border.*;

import processing.app.*;
import processing.app.ui.Editor;
import processing.app.ui.Toolkit;


public class ContributionTab {
  static final String ANY_CATEGORY = Language.text("contrib.all");

  ContributionType contributionType;
  ContributionManagerDialog contributionManagerDialog;
  JPanel panel;
  String title;
  ContributionFilter filter;
  JComboBox<String> categoryChooser;
  JScrollPane scrollPane;
  ContributionListPanel contributionListPanel;
  StatusPanel statusPanel;
  FilterField filterField;
  JLabel filterLabel;
  JButton restartButton;
  JLabel categoryLabel;
  JLabel loaderLabel;

  JPanel errorPanel;
  JTextPane errorMessage;
  JButton tryAgainButton;
  JButton closeButton;


  Editor editor;
  String category;
  ContributionListing contribListing;

  JProgressBar progressBar;


  public ContributionTab(ContributionType type,ContributionManagerDialog contributionManagerDialog) {
    if (type == ContributionType.MODE) {
      title = Language.text("contrib.manager_title.mode");
    } else if (type == ContributionType.TOOL) {
      title = Language.text("contrib.manager_title.tool");
    } else if (type == ContributionType.LIBRARY) {
      title = Language.text("contrib.manager_title.library");
    } else if (type == ContributionType.EXAMPLES) {
      title = Language.text("contrib.manager_title.examples");
    }

    filter = type.createFilter();
    this.contributionType = type;
    this.contributionManagerDialog = contributionManagerDialog;
    contribListing = ContributionListing.getInstance();
      statusPanel = new StatusPanel(650,this);
      contributionListPanel = new ContributionListPanel(this, filter);
    contribListing.addContributionListener(contributionListPanel);
  }


  public ContributionTab() {

  }


  public boolean hasUpdates() {
    return contribListing.hasUpdates();
  }


  public boolean hasUpdates(Base base) {
    return contribListing.hasUpdates(base);
  }













  public void showFrame(final Editor editor, boolean activateErrorPanel,
                        final boolean isLoading) {
    this.editor = editor;
    if (panel == null) {
      setLayout(editor, activateErrorPanel, isLoading);
    }
    contributionListPanel.setVisible(!isLoading);
    loaderLabel.setVisible(isLoading);
    errorPanel.setVisible(activateErrorPanel);
    panel.validate();
    panel.repaint();
  }


  public void setLayout(final Editor editor, boolean activateErrorPanel, boolean isLoading) {
    if(panel == null){
      progressBar = new JProgressBar();
      progressBar.setVisible(false);
      createComponents();
      panel = new JPanel(false);
      loaderLabel = new JLabel(Toolkit.getLibIcon("icons/loader.gif"));
      loaderLabel.setOpaque(false);
      loaderLabel.setBackground(Color.WHITE);
      filterLabel = new JLabel("Filter");
      filterLabel.setOpaque(false);
    }




    GroupLayout layout = new GroupLayout(panel);
    panel.setLayout(layout);


    layout.setHorizontalGroup(layout
      .createParallelGroup(GroupLayout.Alignment.CENTER)
      .addGroup(layout
                  .createSequentialGroup()
                  .addContainerGap()
                  .addComponent(filterLabel)
                  .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                  .addComponent(filterField)
                  .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                  .addComponent(categoryChooser,
                                categoryChooser.getPreferredSize().width + 20,
                                categoryChooser.getPreferredSize().width + 20,
                                categoryChooser.getPreferredSize().width + 20)
                  .addContainerGap()).addComponent(loaderLabel)
      .addComponent(contributionListPanel).addComponent(errorPanel)
      .addComponent(statusPanel));

    layout.setVerticalGroup(layout
      .createSequentialGroup()
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(filterLabel).addComponent(categoryChooser)
                  .addComponent(filterField))
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(loaderLabel)
                  .addComponent(contributionListPanel))
      .addComponent(errorPanel)
      .addComponent(statusPanel, GroupLayout.PREFERRED_SIZE,
                    GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE));
    layout.linkSize(SwingConstants.VERTICAL, categoryChooser, filterField);
    layout.setHonorsVisibility(contributionListPanel, false);

    panel.setBackground(Color.WHITE);
    panel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
 }



  private void createComponents() {

      categoryLabel = new JLabel(Language.text("contrib.category"));

      categoryChooser = new JComboBox<String>();
      categoryChooser.setMaximumRowCount(20);

      updateCategoryChooser();

      categoryChooser.addItemListener(new ItemListener() {
        public void itemStateChanged(ItemEvent e) {
          category = (String) categoryChooser.getSelectedItem();
          if (ContributionManagerDialog.ANY_CATEGORY.equals(category)) {
            category = null;
          }
          filterLibraries(category, filterField.filters);
          contributionListPanel.updateColors();
        }
      });

      filterField = new FilterField();

      buildErrorPanel();

  }
  void buildErrorPanel(){
    errorPanel = new JPanel();
    GroupLayout layout = new GroupLayout(errorPanel);
    layout.setAutoCreateGaps(true);
    layout.setAutoCreateContainerGaps(true);
    errorPanel.setLayout(layout);
    errorMessage = new JTextPane();
    errorMessage.setEditable(false);
    errorMessage.setText("Could not connect to the Processing server. "
      + "Contributions cannot be installed or updated without an Internet connection. "
      + "Please verify your network connection again, then try connecting again.");
    errorMessage.setMaximumSize(new Dimension(450, 50));
    errorMessage.setOpaque(false);

    StyledDocument doc = errorMessage.getStyledDocument();
    SimpleAttributeSet center = new SimpleAttributeSet();
    StyleConstants.setAlignment(center, StyleConstants.ALIGN_CENTER);
    doc.setParagraphAttributes(0, doc.getLength(), center, false);


    closeButton = new JButton("X");
    closeButton.setContentAreaFilled(false);
    closeButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent e) {
        contributionManagerDialog.makeAndShowTab(false, false);
      }
    });
    tryAgainButton = new JButton("Try Again");
    tryAgainButton.setContentAreaFilled(false);
    tryAgainButton.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.BLACK, 1),BorderFactory.createEmptyBorder(3, 0, 3, 0)));
    tryAgainButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent e) {
        contributionManagerDialog.makeAndShowTab(false, true);
        contributionManagerDialog.downloadAndUpdateContributionListing(editor.getBase());
      }
    });
    layout.setHorizontalGroup(layout
      .createSequentialGroup()
      .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                       GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
      .addGroup(layout
                  .createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(errorMessage)
                  .addComponent(tryAgainButton, statusPanel.BUTTON_WIDTH,
                                statusPanel.BUTTON_WIDTH,
                                statusPanel.BUTTON_WIDTH))
      .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                       GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
      .addComponent(closeButton));
    layout.setVerticalGroup(layout
      .createSequentialGroup()
      .addGroup(layout.createParallelGroup().addComponent(errorMessage)
                  .addComponent(closeButton)).addComponent(tryAgainButton));
    errorPanel.setBackground(Color.PINK);
    errorPanel.validate();
  }



  protected void updateCategoryChooser() {
    if (categoryChooser != null) {
      ArrayList<String> categories;
      categoryChooser.removeAllItems();
      categories = new ArrayList<String>(contribListing.getCategories(filter));



      Collections.sort(categories);

      @SuppressWarnings("unused")
      boolean categoriesFound = false;
      categoryChooser.addItem(ContributionManagerDialog.ANY_CATEGORY);
      for (String s : categories) {
        categoryChooser.addItem(s);
        if (!s.equals(Contribution.UNKNOWN_CATEGORY)) {
          categoriesFound = true;
        }
      }
      categoryChooser.setEnabled(categoriesFound);
    }
  }


  protected void filterLibraries(String category, List<String> filters) {
    List<Contribution> filteredLibraries =
      contribListing.getFilteredLibraryList(category, filters);
    contributionListPanel.filterLibraries(filteredLibraries);
  }




  protected void updateContributionListing() {
    if (editor != null) {
      List<Contribution> contributions = new ArrayList<Contribution>();

      List<Library> libraries =
        new ArrayList<Library>(editor.getMode().contribLibraries);
      contributions.addAll(libraries);


      List<ToolContribution> tools = editor.getToolContribs();
      contributions.addAll(tools);

      List<ModeContribution> modes = editor.getBase().getModeContribs();
      contributions.addAll(modes);

      List<ExamplesContribution> examples = editor.getBase().getExampleContribs();
      contributions.addAll(examples);














      contribListing.updateInstalledList(contributions);
    }
  }

  protected void setFilterText(String filter) {
    if (filter == null || filter.isEmpty()) {
      filterField.setText("");
    } else {
      filterField.setText(filter);
    }
    filterField.applyFilter();
  }







  class FilterField extends JTextField {
    Icon searchIcon;
    List<String> filters;

    public FilterField () {

      super("");
      searchIcon = Toolkit.getLibIcon("icons/searchIcon.png");
      setOpaque(false);

      filters = new ArrayList<String>();

      addFocusListener(new FocusListener() {
        public void focusLost(FocusEvent focusEvent) {
          if (getText().isEmpty()) {
            setBorder(BorderFactory.createMatteBorder(0, 33, 0, 0, searchIcon));
          }
        }

        public void focusGained(FocusEvent focusEvent) {
          setBorder(BorderFactory.createEmptyBorder(0, 3, 0, 0));
        }
      });

      getDocument().addDocumentListener(new DocumentListener() {
        public void removeUpdate(DocumentEvent e) {
          applyFilter();
        }

        public void insertUpdate(DocumentEvent e) {
          applyFilter();
        }

        public void changedUpdate(DocumentEvent e) {
          applyFilter();
        }
      });
    }
    
    public void applyFilter() {
      String filter = getText();
      filter = filter.toLowerCase();


      filter = filter.replaceAll("[^\\x30-\\x39^\\x61-\\x7a^\\x3a]", " ");
      filters = Arrays.asList(filter.split(" "));
      filterLibraries(category, filters);

      contributionListPanel.updateColors();
    }

  }


  public boolean hasAlreadyBeenOpened() {
    return panel != null;
  }

  public void updateStatusPanel(ContributionPanel contributionPanel) {
    statusPanel.update(contributionPanel);
  }
}

<code block>



package processing.app.contrib;

import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.SocketTimeoutException;
import java.util.*;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicTabbedPaneUI;

import processing.app.*;
import processing.app.ui.Editor;
import processing.app.ui.Toolkit;


public class ContributionManagerDialog {
  static final String ANY_CATEGORY = Language.text("contrib.all");

  JFrame dialog;
  JTabbedPane tabbedPane;
  String title;
  JButton restartButton;

  

  Editor editor;
  

  ContributionTab toolsContributionTab;
  ContributionTab librariesContributionTab;
  ContributionTab examplesContributionTab;
  ContributionTab modesContributionTab;
  UpdateContributionTab updatesContributionTab;
  
  JLabel numberLabel;
  
  ContributionListing contributionListing = ContributionListing.getInstance(); 

  public ContributionManagerDialog() {
    numberLabel = new JLabel();
    toolsContributionTab = new ContributionTab(ContributionType.TOOL, this);
    librariesContributionTab = new ContributionTab(ContributionType.LIBRARY, this);
    modesContributionTab = new ContributionTab(ContributionType.MODE, this);
    examplesContributionTab = new ContributionTab(ContributionType.EXAMPLES, this);
    updatesContributionTab = new UpdateContributionTab(null, this);
  }

  public boolean hasUpdates() {
    return toolsContributionTab.hasUpdates()
      || librariesContributionTab.hasUpdates()
      || examplesContributionTab.hasUpdates()
      || modesContributionTab.hasUpdates();
  }

  public boolean hasUpdates(Base base) {
    return toolsContributionTab.hasUpdates(base)
      || modesContributionTab.hasUpdates(base)
      || librariesContributionTab.hasUpdates(base)
      || examplesContributionTab.hasUpdates(base);
  }

  public void showFrame(final Editor editor, ContributionType contributionType) {
    this.editor = editor;


    int index;
    if (contributionType == ContributionType.TOOL) {
      index = 0;
    } else if (contributionType == ContributionType.LIBRARY) {
      index = 1;
    } else if (contributionType == ContributionType.MODE) {
      index = 2;
    } else if (contributionType == ContributionType.EXAMPLES) {
      index = 3;
    } else {
      index = 4;
    }
    if (dialog == null) {
      makeFrame(editor);
      tabbedPane.setSelectedIndex(index); 
      downloadAndUpdateContributionListing(editor.getBase());
    }
    tabbedPane.setSelectedIndex(index); 
    dialog.setVisible(true);
  }

  public void makeFrame(final Editor editor) {
    dialog = new JFrame(title);
    String[] tabTitles = { "Tools","Libraries","Modes","Examples","Updates"};
    tabbedPane = new JTabbedPane();

    makeAndShowTab(false, true);

    tabbedPane.addTab("Tools", null, toolsContributionTab.panel, "Tools");
    tabbedPane.setMnemonicAt(0, KeyEvent.VK_1);

    tabbedPane.addTab("Libraries", null, librariesContributionTab.panel,
                      "Libraries");
    tabbedPane.setMnemonicAt(1, KeyEvent.VK_2);

    tabbedPane.addTab("Modes", null, modesContributionTab.panel, "Modes");
    tabbedPane.setMnemonicAt(2, KeyEvent.VK_3);

    tabbedPane.addTab("Examples", null, examplesContributionTab.panel,
                      "Examples");
    tabbedPane.setMnemonicAt(3, KeyEvent.VK_4);

    tabbedPane.addTab("Updates", null, updatesContributionTab.panel, "Updates");
    tabbedPane.setMnemonicAt(3, KeyEvent.VK_5);
    tabbedPane.setUI(new SpacedTabbedPaneUI());
    tabbedPane.setBackground(Color.WHITE);
    tabbedPane.setOpaque(true);
    tabbedPane.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
    
    
    JPanel updateTabPanel = new JPanel(true);
    numberLabel.setOpaque(false);
    numberLabel.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
    JLabel numberBackground = new JLabel(Toolkit.getLibIcon("icons/notification.png"));
    JLabel updateTabLabel = new JLabel("Update");
    updateTabPanel.setOpaque(false);
    updateTabPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory
      .createMatteBorder(0, 2, 0, 0, Color.BLACK), BorderFactory
      .createEmptyBorder(4, 4, 4, 4)));
    tabbedPane.setTabComponentAt(4, updateTabPanel);
    
    JLabel tabLabels[] = new JLabel[4];
    for(int i = 0 ; i < tabLabels.length;i++){
      tabLabels[i] = new JLabel(tabTitles[i]);
      tabLabels[i]
        .setBorder(BorderFactory.createCompoundBorder(BorderFactory
          .createMatteBorder(0, (i == 0 ? 0 : 2), 0, (i == 3 ? 2 : 0),
                             Color.BLACK), BorderFactory
          .createEmptyBorder(4, 4, 4, 4)));
      tabbedPane.setTabComponentAt(i, tabLabels[i]);
    }
    
    GroupLayout tabLayout = new GroupLayout(updateTabPanel);
    tabLayout.setAutoCreateGaps(true);
    updateTabPanel.setLayout(tabLayout);
    tabLayout.setHorizontalGroup(tabLayout
      .createSequentialGroup()
      .addGroup(tabLayout.createParallelGroup().addComponent(numberLabel)
                  .addComponent(numberBackground)).addComponent(updateTabLabel));
    tabLayout.setVerticalGroup(tabLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
      .addComponent(numberBackground).addComponent(numberLabel)
      .addComponent(updateTabLabel));
    
    tabbedPane.addChangeListener(new ChangeListener() {
      
      @Override
      public void stateChanged(ChangeEvent e) {






      }
    });
    
    

    setLayout();
    
    restartButton = new JButton(Language.text("contrib.restart"));
    restartButton.setVisible(false);
    restartButton.addActionListener(new ActionListener() {

      @Override
      public void actionPerformed(ActionEvent arg0) {

        Iterator<Editor> iter = editor.getBase().getEditors().iterator();
        while (iter.hasNext()) {
          Editor ed = iter.next();
          if (ed.getSketch().isModified()) {
            int option = Base.showYesNoQuestion(editor, title, Language
              .text("contrib.unsaved_changes"), Language
              .text("contrib.unsaved_changes.prompt"));

            if (option == JOptionPane.NO_OPTION)
              return;
            else
              break;
          }
        }


        StringBuilder cmd = new StringBuilder();
        cmd.append(System.getProperty("java.home") + File.separator + "bin"
          + File.separator + "java ");
        for (String jvmArg : ManagementFactory.getRuntimeMXBean()
          .getInputArguments()) {
          cmd.append(jvmArg + " ");
        }
        cmd.append("-cp ")
          .append(ManagementFactory.getRuntimeMXBean().getClassPath())
          .append(" ");
        cmd.append(Base.class.getName());

        try {
          Runtime.getRuntime().exec(cmd.toString());
          System.exit(0);
        } catch (IOException e) {
          e.printStackTrace();
        }

      }

    });

    Toolkit.setIcon(dialog);
    registerDisposeListeners();

    dialog.pack();
    dialog.setLocationRelativeTo(null);
  }

  public class SpacedTabbedPaneUI extends BasicTabbedPaneUI {
    
    
    @Override
    protected void installDefaults() {
      UIManager.put("TabbedPane.selected", Color.WHITE);
      super.installDefaults();
      highlight = Color.WHITE;
      lightHighlight = Color.WHITE;
      shadow = Color.WHITE;
      darkShadow = Color.WHITE;
      focus = Color.LIGHT_GRAY;
      tabInsets = new Insets(0, 0, 0, 0);
      contentBorderInsets = new Insets(0, 0, 0, 0);
      tabAreaInsets = new Insets(0, 0, 0, 0);
      selectedTabPadInsets = new Insets(0, 0, 0, 0);
    }
    
    @Override
    protected LayoutManager createLayoutManager() {
      return new BasicTabbedPaneUI.TabbedPaneLayout() {
        
        @Override
        public void addLayoutComponent(String name, Component comp) {

          super.addLayoutComponent(name, comp);
        }
        @Override
        protected void calculateTabRects(int tabPlacement, int tabCount) {
          super.calculateTabRects(tabPlacement, tabCount);
          for (int i = 0; i < rects.length; i++) {
            rects[i].y -= 10;
            rects[i].height += 15;
            if (i == 4) {
              rects[i].x = tabbedPane.getWidth() - rects[i].width - 2;
            }
          }
        }
      };
    }
  }
  
  private void setLayout() {
    GroupLayout layout = new GroupLayout(dialog.getContentPane());
    dialog.getContentPane().setLayout(layout);
    dialog.setResizable(true);
    layout.setAutoCreateContainerGaps(true);
    layout.setHorizontalGroup(layout.createParallelGroup()
                              .addComponent(tabbedPane));
    layout.setVerticalGroup(layout
      .createParallelGroup()
      .addComponent(tabbedPane));
    layout.setHonorsVisibility(tabbedPane, true);
    dialog.getContentPane().setBackground(Color.WHITE);
    dialog.validate();
    dialog.repaint();
  }
  
  
  


  protected void disposeFrame() {
    dialog.dispose();
    editor = null;
  }


  private void registerDisposeListeners() {
    dialog.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        disposeFrame();
      }
    });

    Toolkit.registerWindowCloseKeys(dialog.getRootPane(), new ActionListener() {
      public void actionPerformed(ActionEvent actionEvent) {
        disposeFrame();
      }
    });

    dialog.getContentPane().addKeyListener(new KeyAdapter() {
      public void keyPressed(KeyEvent e) {

        KeyStroke wc = Toolkit.WINDOW_CLOSE_KEYSTROKE;
        if ((e.getKeyCode() == KeyEvent.VK_ESCAPE)
          || (KeyStroke.getKeyStrokeForEvent(e).equals(wc))) {
          disposeFrame();
        }
      }
    });
  }



  protected void downloadAndUpdateContributionListing(Base base) {
    


    final ContributionTab activeTab = getActiveTab();
    activeTab.statusPanel.setMessage(Language
      .text("contrib.status.downloading_list"));
    activeTab.contribListing.downloadAvailableList(base, new ContribProgressBar(
      activeTab.progressBar) {

      @Override
      public void startTask(String name, int maxValue) {
        super.startTask(name, maxValue);
        progressBar.setVisible(true);
        progressBar.setString(null);
      }

      @Override
      public void setProgress(int value) {
        super.setProgress(value);

        progressBar.setValue(value);
        progressBar.setStringPainted(true);
        activeTab.statusPanel.setMessage(Language
          .text("contrib.status.downloading_list"));
      }

      @Override
      public void finishedAction() {
        progressBar.setVisible(false);
        activeTab.updateContributionListing();
        activeTab.updateCategoryChooser();


        if (error) {
          if (exception instanceof SocketTimeoutException) {
            activeTab.statusPanel.setErrorMessage(Language
              .text("contrib.errors.list_download.timeout"));
          } else {
            activeTab.statusPanel.setErrorMessage(Language
              .text("contrib.errors.list_download"));
          }
          exception.printStackTrace();
          makeAndShowTab(true,false);
        } else {
          makeAndShowTab(false, false);
          activeTab.statusPanel.setMessage(Language.text("contrib.status.done"));
        }
      }

   

    });
  }

  void makeAndShowTab(boolean activateErrorPanel, boolean isLoading) {
    toolsContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    librariesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    modesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    examplesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
    updatesContributionTab.showFrame(editor, activateErrorPanel, isLoading);
  }
  

  public ContributionTab getActiveTab() {
    
    switch (tabbedPane.getSelectedIndex()) {
    case 0:
      return toolsContributionTab;
    case 1:
      return librariesContributionTab;
    case 2:
      return modesContributionTab;
    case 3:
      return examplesContributionTab;
    default:
      return updatesContributionTab;
    }
    
  }



  public boolean hasAlreadyBeenOpened() {
    return dialog != null;
  }
}

<code block>
package processing.app.contrib;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Comparator;
import java.util.Set;
import java.util.TreeMap;

import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.LayoutStyle;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;

import processing.app.Base;
import processing.app.ui.Editor;
import processing.app.ui.Toolkit;

public class UpdateContributionTab extends ContributionTab {
  
  public UpdateContributionTab(ContributionType type,ContributionManagerDialog contributionManagerDialog) {
    super();
    filter = ContributionType.createUpdateFilter();
    contributionListPanel = new UpdateContribListingPanel(this, filter);
    statusPanel = new UpdateStatusPanel(650, this);
    this.contributionType = type;
    this.contributionManagerDialog = contributionManagerDialog;
    contribListing = ContributionListing.getInstance();
    contribListing.addContributionListener(contributionListPanel);
  }

  @Override
  public void setLayout(Editor editor, boolean activateErrorPanel,
                        boolean isLoading) {
    if (panel == null) {
      progressBar = new JProgressBar();
      progressBar.setVisible(false);
      buildErrorPanel();
      panel = new JPanel(false);
      loaderLabel = new JLabel(Toolkit.getLibIcon("icons/loader.gif"));
      loaderLabel.setOpaque(false);
      loaderLabel.setBackground(Color.WHITE);
    }

    GroupLayout layout = new GroupLayout(panel);
    panel.setLayout(layout);
    layout.setHorizontalGroup(layout
      .createParallelGroup(GroupLayout.Alignment.CENTER)
      .addComponent(loaderLabel)
      .addComponent(contributionListPanel).addComponent(errorPanel)
      .addComponent(statusPanel));

    layout.setVerticalGroup(layout
      .createSequentialGroup()
      .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                  .addComponent(loaderLabel)
                  .addComponent(contributionListPanel))
      .addComponent(errorPanel)
      .addComponent(statusPanel, GroupLayout.PREFERRED_SIZE,
                    GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE));
    layout.setHonorsVisibility(contributionListPanel, false);

    panel.setBackground(Color.WHITE);
    panel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));

  }

  public class UpdateContribListingPanel extends ContributionListPanel {

    public UpdateContribListingPanel(ContributionTab contributionTab,
                                     ContributionFilter filter) {
      super.contributionTab = contributionTab;
      super.filter = filter;
      setOpaque(true);

      if (Base.isLinux()) {



        setBackground(Color.white);
      } else {
        setBackground(UIManager.getColor("List.background"));
      }




      
      String[] colName = { "", "Name", "Author", "Installed", "Update To" };
      dtm = new MyTableModel();
      dtm.setColumnIdentifiers(colName);
      table = new JTable(dtm){
        @Override
        public Component prepareRenderer(
                TableCellRenderer renderer, int row, int column) {
          Component c = super.prepareRenderer(renderer, row, column);
          String title = (String) getValueAt(row, 1);
          if (title.equals("<html><i>Library</i></html>") || title.equals("Tools")
            || title.equals("Modes") || title.equals("Examples")) {
            ((JComponent) c).setBorder(BorderFactory
              .createMatteBorder(row == 0 ? 0 : 2, 0, 2, 0, Color.BLACK));
          }
          return c;
        }
        @Override
        public void changeSelection(int rowIndex, int columnIndex,
                                    boolean toggle, boolean extend) {
          String title = (String) getValueAt(rowIndex, 1);
          if(title.equals("<html><i>Library</i></html>")){
            return;
          }
          super.changeSelection(rowIndex, columnIndex, toggle, extend);
        }







      };
      JScrollPane scrollPane = new JScrollPane(table);
      table.setFillsViewportHeight(true);
      table.setRowHeight(30);
      table.setRowMargin(6);
      table.getColumnModel().setColumnMargin(-1);
      table.getColumnModel().getColumn(0).setMaxWidth(60);
      table.setShowGrid(false);
      table.setCellSelectionEnabled(false);
      table.setRowSelectionAllowed(true);
      table.setAutoCreateColumnsFromModel(true);
      table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
      table.getTableHeader().setDefaultRenderer(new MyColumnHeaderRenderer() {
        @Override
        public Component getTableCellRendererComponent(JTable table,
                                                       Object value,
                                                       boolean isSelected,
                                                       boolean hasFocus, int row,
                                                       int column) {
          super.getTableCellRendererComponent(table, value, isSelected, hasFocus,
                                              row, column);
          JTableHeader tableHeader = table.getTableHeader();
          if (tableHeader != null) {
            setForeground(tableHeader.getForeground());
          }
          setIcon(getIcon(table, column));
          setBackground(Color.WHITE);
          setBorder(BorderFactory.createMatteBorder(2, 0, 2, 0, Color.BLACK));
          return this;
        }
      });

      GroupLayout layout = new GroupLayout(this);
      layout.setHorizontalGroup(layout.createParallelGroup().addComponent(scrollPane));
      layout.setVerticalGroup(layout.createSequentialGroup().addComponent(scrollPane));

      this.setLayout(layout);
      table.setVisible(true);
      
      panelByContribution = new TreeMap<Contribution, ContributionPanel>(new Comparator<Contribution>() {

        @Override
        public int compare(Contribution o1, Contribution o2) {
          int val1 = 0;
          int val2 = 0;
          switch(o1.getType()){
          case LIBRARY: val1 = 1;
          break;
          case TOOL: val1 = 2;
          break;
          case MODE: val1 = 3;
          break;
          case EXAMPLES: val1 = 4;
          break;
          }
          switch(o2.getType()){
          case LIBRARY: val2 = 1;
          break;
          case TOOL: val2 = 2;
          break;
          case MODE: val2 = 3;
          break;
          case EXAMPLES: val2 = 4;
          break;
          }
          if(val1 == val2){
            return o1.getName().toLowerCase().compareTo(o2.getName().toLowerCase());
          }
          return val1 - val2;
        }
      });
      
    }








    @Override
    void updatePanelOrdering(Set<Contribution> contributionsSet) {
      contributionTab.contributionManagerDialog.numberLabel.setText(Integer
        .toString(panelByContribution.size()));
      dtm.getDataVector().removeAllElements();
      dtm.fireTableDataChanged();
      ContributionType temp = null;
      for (Contribution entry : contributionsSet) {
        if(entry.getType() != temp){
          temp = entry.getType();
          dtm.addRow(new Object[] { null, "<html><i>" + temp.getTitle() + "</i></html>", null, null, null });
        }

        StringBuilder name = new StringBuilder("");
        String authorList = entry.getAuthorList();
        if (authorList != null) {
          for (int i = 0; i < authorList.length(); i++) {

            if (authorList.charAt(i) == '[' || authorList.charAt(i) == ']') {
              continue;
            }
            if (authorList.charAt(i) == '(') {
              i++;
              while (authorList.charAt(i) != ')') {
                i++;
              }
            } else {
              name.append(authorList.charAt(i));
            }
          }
        }
        Icon icon = null;
        if (entry.isInstalled()) {
          icon = Toolkit.getLibIcon("icons/installedAndUptodate.png");
          if (contribListing.hasUpdates(entry)) {
            icon = Toolkit.getLibIcon("icons/installedNeedsUpdate.png");
          }
          if (!entry.isCompatible(Base.getRevision())) {
            icon = Toolkit.getLibIcon("icons/installedIncompatible.png");
          }
        }
        dtm
          .addRow(new Object[] {
            icon, "<html><b>" + entry.getName() + "</b></html>", name, entry.getPrettyVersion(),
            contributionTab.contribListing.getLatestVersion(entry) });
      }
    }
    private class MyTableModel extends DefaultTableModel{
      MyTableModel() {
        super(0,0);
      }
      @Override
      public boolean isCellEditable(int row, int column) {
        return false;
      }
      @Override
      public Class<?> getColumnClass(int columnIndex) {
        if(columnIndex == 0){
          return Icon.class;
        }
        return super.getColumnClass(columnIndex);
      }
    }
  }
  public class UpdateStatusPanel extends StatusPanel {
    public UpdateStatusPanel(int width, final ContributionTab contributionTab) {
      super();
      updateButton = new JButton("Update All");
      updateButton.setContentAreaFilled(false);
      updateButton.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.BLACK, 1),BorderFactory.createEmptyBorder(3, 0, 3, 0)));
      updateButton.addActionListener(new ActionListener() {
        
        @Override
        public void actionPerformed(ActionEvent e) {

          for(ContributionPanel contributionPanel : contributionTab.contributionListPanel.panelByContribution.values()){
            contributionPanel.update();
          }
        }
      });
      this.setBackground(Color.WHITE);
      this.setBorder(BorderFactory.createMatteBorder(2, 0, 0, 0, Color.BLACK));
      layout = new GroupLayout(this);
      this.setLayout(layout);
      
      layout.setAutoCreateContainerGaps(true);
      layout.setAutoCreateGaps(true);

      layout.setHorizontalGroup(layout
        .createSequentialGroup()
        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                         GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
        .addComponent(updateButton, BUTTON_WIDTH, BUTTON_WIDTH, BUTTON_WIDTH));
      layout.setVerticalGroup(layout.createParallelGroup()
        .addComponent(updateButton));
      updateButton.setVisible(true);
    }
    @Override
    public void update(ContributionPanel panel) {
      
    }
  }
}

<code block>




package processing.core;

import java.awt.Cursor;
import java.awt.event.KeyEvent;



public interface PConstants {

  static public final int X = 0;
  static public final int Y = 1;
  static public final int Z = 2;






  static final String JAVA2D = "processing.core.PGraphicsJava2D";

  static final String P2D = "processing.opengl.PGraphics2D";
  static final String P3D = "processing.opengl.PGraphics3D";


  @Deprecated
  static final String OPENGL = P3D;


  static final String E2D = PGraphicsDanger2D.class.getName();


  static final String FX2D = PGraphicsFX2D.class.getName();

  static final String PDF = "processing.pdf.PGraphicsPDF";
  static final String SVG = "processing.svg.PGraphicsSVG";
  static final String DXF = "processing.dxf.RawDXF";



  static final int OTHER   = 0;
  static final int WINDOWS = 1;
  static final int MACOSX  = 2;
  static final int LINUX   = 3;

  static final String[] platformNames = {
    "other", "windows", "macosx", "linux"
  };


  static final float EPSILON = 0.0001f;





  static final float MAX_FLOAT = Float.MAX_VALUE;

  static final float MIN_FLOAT = -Float.MAX_VALUE;

  static final int MAX_INT = Integer.MAX_VALUE;

  static final int MIN_INT = Integer.MIN_VALUE;



  static public final int VERTEX = 0;
  static public final int BEZIER_VERTEX = 1;
  static public final int QUADRATIC_VERTEX = 2;
  static public final int CURVE_VERTEX = 3;
  static public final int BREAK = 4;

  @Deprecated
  static public final int QUAD_BEZIER_VERTEX = 2;  




  static final float PI = (float) Math.PI;

  static final float HALF_PI = (float) (Math.PI / 2.0);
  static final float THIRD_PI = (float) (Math.PI / 3.0);

  static final float QUARTER_PI = (float) (Math.PI / 4.0);

  static final float TWO_PI = (float) (2.0 * Math.PI);

  static final float TAU = (float) (2.0 * Math.PI);

  static final float DEG_TO_RAD = PI/180.0f;
  static final float RAD_TO_DEG = 180.0f/PI;











  static final String WHITESPACE = " \t\n\r\f\u00A0";




  static final int RGB   = 1;  
  static final int ARGB  = 2;  
  static final int HSB   = 3;  
  static final int ALPHA = 4;  





  static final int TIFF  = 0;
  static final int TARGA = 1;
  static final int JPEG  = 2;
  static final int GIF   = 3;




  static final int BLUR      = 11;
  static final int GRAY      = 12;
  static final int INVERT    = 13;
  static final int OPAQUE    = 14;
  static final int POSTERIZE = 15;
  static final int THRESHOLD = 16;
  static final int ERODE     = 17;
  static final int DILATE    = 18;





  public final static int REPLACE    = 0;
  public final static int BLEND      = 1 << 0;
  public final static int ADD        = 1 << 1;
  public final static int SUBTRACT   = 1 << 2;
  public final static int LIGHTEST   = 1 << 3;
  public final static int DARKEST    = 1 << 4;
  public final static int DIFFERENCE = 1 << 5;
  public final static int EXCLUSION  = 1 << 6;
  public final static int MULTIPLY   = 1 << 7;
  public final static int SCREEN     = 1 << 8;
  public final static int OVERLAY    = 1 << 9;
  public final static int HARD_LIGHT = 1 << 10;
  public final static int SOFT_LIGHT = 1 << 11;
  public final static int DODGE      = 1 << 12;
  public final static int BURN       = 1 << 13;



  static final int CHATTER   = 0;
  static final int COMPLAINT = 1;
  static final int PROBLEM   = 2;




  static final int PROJECTION = 0;
  static final int MODELVIEW  = 1;



  static final int CUSTOM       = 0; 
  static final int ORTHOGRAPHIC = 2; 
  static final int PERSPECTIVE  = 3; 







  static final int GROUP           = 0;   

  static final int POINT           = 2;   
  static final int POINTS          = 3;   

  static final int LINE            = 4;   
  static final int LINES           = 5;   
  static final int LINE_STRIP      = 50;  
  static final int LINE_LOOP       = 51;

  static final int TRIANGLE        = 8;   
  static final int TRIANGLES       = 9;   
  static final int TRIANGLE_STRIP  = 10;  
  static final int TRIANGLE_FAN    = 11;  

  static final int QUAD            = 16;  
  static final int QUADS           = 17;  
  static final int QUAD_STRIP      = 18;  

  static final int POLYGON         = 20;  
  static final int PATH            = 21;  

  static final int RECT            = 30;  
  static final int ELLIPSE         = 31;  
  static final int ARC             = 32;  

  static final int SPHERE          = 40;  
  static final int BOX             = 41;  








  static final int OPEN = 1;
  static final int CLOSE = 2;





  static final int CORNER   = 0;

  static final int CORNERS  = 1;

  static final int RADIUS   = 2;

  static final int CENTER   = 3;

  static final int DIAMETER = 3;





  static final int CHORD  = 2;
  static final int PIE    = 3;





  static final int BASELINE = 0;

  static final int TOP = 101;

  static final int BOTTOM = 102;





  static final int NORMAL     = 1;

  static final int IMAGE      = 2;





  public static final int CLAMP = 0;

  public static final int REPEAT = 1;





  static final int MODEL = 4;


  static final int SHAPE = 5;







  static final int SQUARE   = 1 << 0;  
  static final int ROUND    = 1 << 1;
  static final int PROJECT  = 1 << 2;  
  static final int MITER    = 1 << 3;
  static final int BEVEL    = 1 << 5;




  static final int AMBIENT = 0;
  static final int DIRECTIONAL  = 1;

  static final int SPOT = 3;












  static final char BACKSPACE = 8;
  static final char TAB       = 9;
  static final char ENTER     = 10;
  static final char RETURN    = 13;
  static final char ESC       = 27;
  static final char DELETE    = 127;


  static final int CODED     = 0xffff;


  static final int UP        = KeyEvent.VK_UP;
  static final int DOWN      = KeyEvent.VK_DOWN;
  static final int LEFT      = KeyEvent.VK_LEFT;
  static final int RIGHT     = KeyEvent.VK_RIGHT;


  static final int ALT       = KeyEvent.VK_ALT;
  static final int CONTROL   = KeyEvent.VK_CONTROL;
  static final int SHIFT     = KeyEvent.VK_SHIFT;





  static final int PORTRAIT = 1;

  static final int LANDSCAPE = 2;


  static final int SPAN = 0;



  static final int ARROW = Cursor.DEFAULT_CURSOR;
  static final int CROSS = Cursor.CROSSHAIR_CURSOR;
  static final int HAND  = Cursor.HAND_CURSOR;
  static final int MOVE  = Cursor.MOVE_CURSOR;
  static final int TEXT  = Cursor.TEXT_CURSOR;
  static final int WAIT  = Cursor.WAIT_CURSOR;





  @Deprecated
  static final int ENABLE_NATIVE_FONTS        =  1;
  @Deprecated
  static final int DISABLE_NATIVE_FONTS       = -1;

  static final int DISABLE_DEPTH_TEST         =  2;
  static final int ENABLE_DEPTH_TEST          = -2;

  static final int ENABLE_DEPTH_SORT          =  3;
  static final int DISABLE_DEPTH_SORT         = -3;

  static final int DISABLE_OPENGL_ERRORS      =  4;
  static final int ENABLE_OPENGL_ERRORS       = -4;

  static final int DISABLE_DEPTH_MASK         =  5;
  static final int ENABLE_DEPTH_MASK          = -5;

  static final int DISABLE_OPTIMIZED_STROKE   =  6;
  static final int ENABLE_OPTIMIZED_STROKE    = -6;

  static final int ENABLE_STROKE_PERSPECTIVE  =  7;
  static final int DISABLE_STROKE_PERSPECTIVE = -7;

  static final int DISABLE_TEXTURE_MIPMAPS    =  8;
  static final int ENABLE_TEXTURE_MIPMAPS     = -8;

  static final int ENABLE_STROKE_PURE         =  9;
  static final int DISABLE_STROKE_PURE        = -9;

  static final int HINT_COUNT                 = 10;



  static final String ERROR_BACKGROUND_IMAGE_SIZE =
    "background image must be the same size as your application";
  static final String ERROR_BACKGROUND_IMAGE_FORMAT =
    "background images should be RGB or ARGB";

  static final String ERROR_TEXTFONT_NULL_PFONT =
    "A null PFont was passed to textFont()";

  static final String ERROR_PUSHMATRIX_OVERFLOW =
    "Too many calls to pushMatrix().";
  static final String ERROR_PUSHMATRIX_UNDERFLOW =
    "Too many calls to popMatrix(), and not enough to pushMatrix().";
}

<code block>




package processing.core;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Frame;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.font.FontRenderContext;
import java.util.HashMap;
import java.util.WeakHashMap;

import processing.opengl.PGL;
import processing.opengl.PShader;


public class PGraphics extends PImage implements PConstants {
















  public int pixelCount;





  public int smooth;





  protected boolean settingsInited;


  protected boolean reapplySettings;


  protected PGraphics raw;




  protected String path;


  protected boolean primaryGraphics;








  protected boolean[] hints = new boolean[HINT_COUNT];




  protected WeakHashMap<PImage, Object> cacheMap =
    new WeakHashMap<PImage, Object>();










  static public final int R = 3;  
  static public final int G = 4;  
  static public final int B = 5;  
  static public final int A = 6;

  static public final int U = 7; 
  static public final int V = 8;

  static public final int NX = 9; 
  static public final int NY = 10;
  static public final int NZ = 11;

  static public final int EDGE = 12;




  static public final int SR = 13;
  static public final int SG = 14;
  static public final int SB = 15;
  static public final int SA = 16;


  static public final int SW = 17;



  static public final int TX = 18; 
  static public final int TY = 19;
  static public final int TZ = 20;

  static public final int VX = 21; 
  static public final int VY = 22;
  static public final int VZ = 23;
  static public final int VW = 24;






  static public final int AR = 25;
  static public final int AG = 26;
  static public final int AB = 27;


  static public final int DR = 3;  
  static public final int DG = 4;
  static public final int DB = 5;
  static public final int DA = 6;


  static public final int SPR = 28;
  static public final int SPG = 29;
  static public final int SPB = 30;

  static public final int SHINE = 31;


  static public final int ER = 32;
  static public final int EG = 33;
  static public final int EB = 34;


  static public final int BEEN_LIT = 35;


  static public final int HAS_NORMAL = 36;

  static public final int VERTEX_FIELD_COUNT = 37;









  public int colorMode; 


  public float colorModeX; 


  public float colorModeY; 


  public float colorModeZ; 


  public float colorModeA; 


  boolean colorModeScale; 


  boolean colorModeDefault; 






  public boolean tint;


  public int tintColor;

  protected boolean tintAlpha;
  protected float tintR, tintG, tintB, tintA;
  protected int tintRi, tintGi, tintBi, tintAi;






  public boolean fill;


  public int fillColor = 0xffFFFFFF;

  protected boolean fillAlpha;
  protected float fillR, fillG, fillB, fillA;
  protected int fillRi, fillGi, fillBi, fillAi;






  public boolean stroke;


  public int strokeColor = 0xff000000;

  protected boolean strokeAlpha;
  protected float strokeR, strokeG, strokeB, strokeA;
  protected int strokeRi, strokeGi, strokeBi, strokeAi;





  static protected final float DEFAULT_STROKE_WEIGHT = 1;
  static protected final int DEFAULT_STROKE_JOIN = MITER;
  static protected final int DEFAULT_STROKE_CAP = ROUND;


  public float strokeWeight = DEFAULT_STROKE_WEIGHT;


  public int strokeJoin = DEFAULT_STROKE_JOIN;


  public int strokeCap = DEFAULT_STROKE_CAP;








  public int rectMode;


  public int ellipseMode;


  public int shapeMode;


  public int imageMode = CORNER;






  public PFont textFont;


  public int textAlign = LEFT;


  public int textAlignY = BASELINE;


  public int textMode = MODEL;


  public float textSize;


  public float textLeading;









  public int ambientColor;
  public float ambientR, ambientG, ambientB;
  public boolean setAmbient;

  public int specularColor;
  public float specularR, specularG, specularB;

  public int emissiveColor;
  public float emissiveR, emissiveG, emissiveB;

  public float shininess;




  static final int STYLE_STACK_DEPTH = 64;
  PStyle[] styleStack = new PStyle[STYLE_STACK_DEPTH];
  int styleStackDepth;






  public int backgroundColor = 0xffCCCCCC;

  protected boolean backgroundAlpha;
  protected float backgroundR, backgroundG, backgroundB, backgroundA;
  protected int backgroundRi, backgroundGi, backgroundBi, backgroundAi;



  protected int blendMode;
















  static final int MATRIX_STACK_DEPTH = 32;




  public Image image;


  protected PSurface surface;




  protected float calcR, calcG, calcB, calcA;
  protected int calcRi, calcGi, calcBi, calcAi;
  protected int calcColor;
  protected boolean calcAlpha;


  int cacheHsbKey;

  float[] cacheHsbValue = new float[3];




  protected int shape;


  public static final int DEFAULT_VERTICES = 512;
  protected float vertices[][] =
    new float[DEFAULT_VERTICES][VERTEX_FIELD_COUNT];
  protected int vertexCount; 



  protected boolean bezierInited = false;
  public int bezierDetail = 20;


  protected PMatrix3D bezierBasisMatrix =
    new PMatrix3D(-1,  3, -3,  1,
                   3, -6,  3,  0,
                  -3,  3,  0,  0,
                   1,  0,  0,  0);


  protected PMatrix3D bezierDrawMatrix;



  protected boolean curveInited = false;
  public int curveDetail = 20;
  public float curveTightness = 0;

  protected PMatrix3D curveBasisMatrix;
  protected PMatrix3D curveDrawMatrix;

  protected PMatrix3D bezierBasisInverse;
  protected PMatrix3D curveToBezierMatrix;





  protected float curveVertices[][];
  protected int curveVertexCount;











  static final protected float sinLUT[];
  static final protected float cosLUT[];
  static final protected float SINCOS_PRECISION = 0.5f;
  static final protected int SINCOS_LENGTH = (int) (360f / SINCOS_PRECISION);
  static {
    sinLUT = new float[SINCOS_LENGTH];
    cosLUT = new float[SINCOS_LENGTH];
    for (int i = 0; i < SINCOS_LENGTH; i++) {
      sinLUT[i] = (float) Math.sin(i * DEG_TO_RAD * SINCOS_PRECISION);
      cosLUT[i] = (float) Math.cos(i * DEG_TO_RAD * SINCOS_PRECISION);
    }
  }













  protected char[] textBuffer = new char[8 * 1024];
  protected char[] textWidthBuffer = new char[8 * 1024];

  protected int textBreakCount;
  protected int[] textBreakStart;
  protected int[] textBreakStop;



  public boolean edge = true;




  static protected final int NORMAL_MODE_AUTO = 0;

  static protected final int NORMAL_MODE_SHAPE = 1;

  static protected final int NORMAL_MODE_VERTEX = 2;


  protected int normalMode;




  protected boolean autoNormal;


  public float normalX, normalY, normalZ;




  public int textureMode = IMAGE;


  public float textureU;


  public float textureV;


  public PImage textureImage;





  protected float sphereX[], sphereY[], sphereZ[];


  public int sphereDetailU = 0;

  public int sphereDetailV = 0;












  public PGraphics() {

  }


  public void setParent(PApplet parent) {  
    this.parent = parent;



    smooth = parent.sketchSmooth();
    pixelDensity = parent.sketchPixelDensity();
  }



  public void setPrimary(boolean primary) {  
    this.primaryGraphics = primary;




    if (primaryGraphics) {
      format = RGB;
    }
  }


  public void setPath(String path) {  
    this.path = path;
  }








  public void setSize(int w, int h) {  
    width = w;
    height = h;


    pixelWidth = width * pixelDensity;
    pixelHeight = height * pixelDensity;





    reapplySettings = true;
  }














  public void dispose() {  
  }


  public PSurface createSurface() {  
    return surface = new PSurfaceAWT(this);
  }








  public void setCache(PImage image, Object storage) {  
    cacheMap.put(image, storage);
  }



  public Object getCache(PImage image) {  
    return cacheMap.get(image);
  }



  public void removeCache(PImage image) {  
    cacheMap.remove(image);
  }









  public boolean canDraw() {  
    return true;
  }













  public void beginDraw() {  
  }



  public void endDraw() {  
  }


  public PGL beginPGL() {
    showMethodWarning("beginGL");
    return null;
  }


  public void endPGL() {
    showMethodWarning("endGL");
  }


  public void flush() {

  }


  protected void checkSettings() {
    if (!settingsInited) defaultSettings();
    if (reapplySettings) reapplySettings();
  }



  protected void defaultSettings() {  









    colorMode(RGB, 255);
    fill(255);
    stroke(0);



    strokeWeight(DEFAULT_STROKE_WEIGHT);
    strokeJoin(DEFAULT_STROKE_JOIN);
    strokeCap(DEFAULT_STROKE_CAP);


    shape = 0;

    rectMode(CORNER);
    ellipseMode(DIAMETER);

    autoNormal = true;


    textFont = null;
    textSize = 12;
    textLeading = 14;
    textAlign = LEFT;
    textMode = MODEL;







    if (primaryGraphics) {

      background(backgroundColor);
    }

    blendMode(BLEND);

    settingsInited = true;

    reapplySettings = false;
  }



  protected void reapplySettings() {



    if (!settingsInited) return;  

    colorMode(colorMode, colorModeX, colorModeY, colorModeZ);
    if (fill) {

      fill(fillColor);
    } else {
      noFill();
    }
    if (stroke) {
      stroke(strokeColor);




      strokeWeight(strokeWeight);


      strokeCap(strokeCap);


      strokeJoin(strokeJoin);

    } else {
      noStroke();
    }
    if (tint) {
      tint(tintColor);
    } else {
      noTint();
    }






    if (textFont != null) {


      float saveLeading = textLeading;
      textFont(textFont, textSize);
      textLeading(saveLeading);
    }
    textMode(textMode);
    textAlign(textAlign, textAlignY);
    background(backgroundColor);

    blendMode(blendMode);

    reapplySettings = false;
  }









  @SuppressWarnings("deprecation")
  public void hint(int which) {
    if (which == ENABLE_NATIVE_FONTS ||
        which == DISABLE_NATIVE_FONTS) {
      showWarning("hint(ENABLE_NATIVE_FONTS) no longer supported. " +
                  "Use createFont() instead.");
    }
    if (which > 0) {
      hints[which] = true;
    } else {
      hints[-which] = false;
    }
  }







  public void beginShape() {
    beginShape(POLYGON);
  }



  public void beginShape(int kind) {
    shape = kind;
  }



  public void edge(boolean edge) {
   this.edge = edge;
  }



  public void normal(float nx, float ny, float nz) {
    normalX = nx;
    normalY = ny;
    normalZ = nz;



    if (shape != 0) {
      if (normalMode == NORMAL_MODE_AUTO) {

        normalMode = NORMAL_MODE_SHAPE;
      } else if (normalMode == NORMAL_MODE_SHAPE) {

        normalMode = NORMAL_MODE_VERTEX;
      }
    }
  }


  public void attrib(String name, float... values) {
    showMissingWarning("attrib");
  }


  public void attrib(String name, int... values) {
    showMissingWarning("attrib");
  }


  public void attrib(String name, boolean... values) {
    showMissingWarning("attrib");
  }



  public void textureMode(int mode) {
    if (mode != IMAGE && mode != NORMAL) {
      throw new RuntimeException("textureMode() only supports IMAGE and NORMAL");
    }
    this.textureMode = mode;
  }


  public void textureWrap(int wrap) {
    showMissingWarning("textureWrap");
  }



  public void texture(PImage image) {
    textureImage = image;
  }



  public void noTexture() {
    textureImage = null;
  }


  protected void vertexCheck() {
    if (vertexCount == vertices.length) {
      float temp[][] = new float[vertexCount << 1][VERTEX_FIELD_COUNT];
      System.arraycopy(vertices, 0, temp, 0, vertexCount);
      vertices = temp;
    }
  }


  public void vertex(float x, float y) {
    vertexCheck();
    float[] vertex = vertices[vertexCount];

    curveVertexCount = 0;

    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = 0;

    vertex[EDGE] = edge ? 1 : 0;







    boolean textured = textureImage != null;
    if (fill || textured) {
      if (!textured) {
        vertex[R] = fillR;
        vertex[G] = fillG;
        vertex[B] = fillB;
        vertex[A] = fillA;
      } else {
        if (tint) {
          vertex[R] = tintR;
          vertex[G] = tintG;
          vertex[B] = tintB;
          vertex[A] = tintA;
        } else {
          vertex[R] = 1;
          vertex[G] = 1;
          vertex[B] = 1;
          vertex[A] = 1;
        }
      }
    }

    if (stroke) {
      vertex[SR] = strokeR;
      vertex[SG] = strokeG;
      vertex[SB] = strokeB;
      vertex[SA] = strokeA;
      vertex[SW] = strokeWeight;
    }

    if (textured) {
      vertex[U] = textureU;
      vertex[V] = textureV;
    }

    if (autoNormal) {
      float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ;
      if (norm2 < EPSILON) {
        vertex[HAS_NORMAL] = 0;
      } else {
        if (Math.abs(norm2 - 1) > EPSILON) {

          float norm = PApplet.sqrt(norm2);
          normalX /= norm;
          normalY /= norm;
          normalZ /= norm;
        }
        vertex[HAS_NORMAL] = 1;
      }
    } else {
      vertex[HAS_NORMAL] = 1;
    }

    vertexCount++;
  }


  public void vertex(float x, float y, float z) {
    vertexCheck();
    float[] vertex = vertices[vertexCount];





    if (shape == POLYGON) {
      if (vertexCount > 0) {
        float pvertex[] = vertices[vertexCount-1];
        if ((Math.abs(pvertex[X] - x) < EPSILON) &&
            (Math.abs(pvertex[Y] - y) < EPSILON) &&
            (Math.abs(pvertex[Z] - z) < EPSILON)) {


          return;
        }
      }
    }




    curveVertexCount = 0;

    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = z;

    vertex[EDGE] = edge ? 1 : 0;

    boolean textured = textureImage != null;
    if (fill || textured) {
      if (!textured) {
        vertex[R] = fillR;
        vertex[G] = fillG;
        vertex[B] = fillB;
        vertex[A] = fillA;
      } else {
        if (tint) {
          vertex[R] = tintR;
          vertex[G] = tintG;
          vertex[B] = tintB;
          vertex[A] = tintA;
        } else {
          vertex[R] = 1;
          vertex[G] = 1;
          vertex[B] = 1;
          vertex[A] = 1;
        }
      }

      vertex[AR] = ambientR;
      vertex[AG] = ambientG;
      vertex[AB] = ambientB;

      vertex[SPR] = specularR;
      vertex[SPG] = specularG;
      vertex[SPB] = specularB;


      vertex[SHINE] = shininess;

      vertex[ER] = emissiveR;
      vertex[EG] = emissiveG;
      vertex[EB] = emissiveB;
    }

    if (stroke) {
      vertex[SR] = strokeR;
      vertex[SG] = strokeG;
      vertex[SB] = strokeB;
      vertex[SA] = strokeA;
      vertex[SW] = strokeWeight;
    }

    if (textured) {
      vertex[U] = textureU;
      vertex[V] = textureV;
    }

    if (autoNormal) {
      float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ;
      if (norm2 < EPSILON) {
        vertex[HAS_NORMAL] = 0;
      } else {
        if (Math.abs(norm2 - 1) > EPSILON) {

          float norm = PApplet.sqrt(norm2);
          normalX /= norm;
          normalY /= norm;
          normalZ /= norm;
        }
        vertex[HAS_NORMAL] = 1;
      }
    } else {
      vertex[HAS_NORMAL] = 1;
    }

    vertex[NX] = normalX;
    vertex[NY] = normalY;
    vertex[NZ] = normalZ;

    vertex[BEEN_LIT] = 0;

    vertexCount++;
  }



  public void vertex(float[] v) {
    vertexCheck();
    curveVertexCount = 0;
    float[] vertex = vertices[vertexCount];
    System.arraycopy(v, 0, vertex, 0, VERTEX_FIELD_COUNT);
    vertexCount++;
  }


  public void vertex(float x, float y, float u, float v) {
    vertexTexture(u, v);
    vertex(x, y);
  }


  public void vertex(float x, float y, float z, float u, float v) {
    vertexTexture(u, v);
    vertex(x, y, z);
  }








  protected void vertexTexture(float u, float v) {
    if (textureImage == null) {
      throw new RuntimeException("You must first call texture() before " +
                                 "using u and v coordinates with vertex()");
    }
    if (textureMode == IMAGE) {
      u /= textureImage.width;
      v /= textureImage.height;
    }

    textureU = u;
    textureV = v;

    if (textureU < 0) textureU = 0;
    else if (textureU > 1) textureU = 1;

    if (textureV < 0) textureV = 0;
    else if (textureV > 1) textureV = 1;
  }









  public void beginContour() {
    showMissingWarning("beginContour");
  }



  public void endContour() {
    showMissingWarning("endContour");
  }


  public void endShape() {
    endShape(OPEN);
  }



  public void endShape(int mode) {
  }









  public PShape loadShape(String filename) {
    return loadShape(filename, null);
  }



  public PShape loadShape(String filename, String options) {
    showMissingWarning("loadShape");
    return null;
  }









  public PShape createShape() {


    return createShape(PShape.GEOMETRY);
  }



  public PShape createShape(int type) {

    if (type == PConstants.GROUP ||
        type == PShape.PATH ||
        type == PShape.GEOMETRY) {
      return createShapeFamily(type);
    }
    final String msg =
      "Only GROUP, PShape.PATH, and PShape.GEOMETRY work with createShape()";
    throw new IllegalArgumentException(msg);
  }



  protected PShape createShapeFamily(int type) {
    return new PShape(this, type);


  }



  public PShape createShape(int kind, float... p) {
    int len = p.length;

    if (kind == POINT) {
      if (is3D() && len != 2 && len != 3) {
        throw new IllegalArgumentException("Use createShape(POINT, x, y) or createShape(POINT, x, y, z)");
      } else if (len != 2) {
        throw new IllegalArgumentException("Use createShape(POINT, x, y)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == LINE) {
      if (is3D() && len != 4 && len != 6) {
        throw new IllegalArgumentException("Use createShape(LINE, x1, y1, x2, y2) or createShape(LINE, x1, y1, z1, x2, y2, z1)");
      } else if (len != 4) {
        throw new IllegalArgumentException("Use createShape(LINE, x1, y1, x2, y2)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == TRIANGLE) {
      if (len != 6) {
        throw new IllegalArgumentException("Use createShape(TRIANGLE, x1, y1, x2, y2, x3, y3)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == QUAD) {
      if (len != 8) {
        throw new IllegalArgumentException("Use createShape(QUAD, x1, y1, x2, y2, x3, y3, x4, y4)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == RECT) {
      if (len != 4 && len != 5 && len != 8 && len != 9) {
        throw new IllegalArgumentException("Wrong number of parameters for createShape(RECT), see the reference");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == ELLIPSE) {
      if (len != 4 && len != 5) {
        throw new IllegalArgumentException("Use createShape(ELLIPSE, x, y, w, h) or createShape(ELLIPSE, x, y, w, h, mode)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == ARC) {
      if (len != 6 && len != 7) {
        throw new IllegalArgumentException("Use createShape(ARC, x, y, w, h, start, stop)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == BOX) {
      if (!is3D()) {
        throw new IllegalArgumentException("createShape(BOX) is not supported in 2D");
      } else if (len != 1 && len != 3) {
        throw new IllegalArgumentException("Use createShape(BOX, size) or createShape(BOX, width, height, depth)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == SPHERE) {
      if (!is3D()) {
        throw new IllegalArgumentException("createShape(SPHERE) is not supported in 2D");
      } else if (len != 1) {
        throw new IllegalArgumentException("Use createShape(SPHERE, radius)");
      }
      return createShapePrimitive(kind, p);
    }
    throw new IllegalArgumentException("Unknown shape type passed to createShape()");
  }



  protected PShape createShapePrimitive(int kind, float... p) {


    return new PShape(this, kind, p);
  }








  public PShader loadShader(String fragFilename) {
    showMissingWarning("loadShader");
    return null;
  }



  public PShader loadShader(String fragFilename, String vertFilename) {
    showMissingWarning("loadShader");
    return null;
  }



  public void shader(PShader shader) {
    showMissingWarning("shader");
  }



  public void shader(PShader shader, int kind) {
    showMissingWarning("shader");
  }



  public void resetShader() {
    showMissingWarning("resetShader");
  }



  public void resetShader(int kind) {
    showMissingWarning("resetShader");
  }



  public void filter(PShader shader) {
    showMissingWarning("filter");
  }








  public void clip(float a, float b, float c, float d) {
    if (imageMode == CORNER) {
      if (c < 0) {  
        a += c; c = -c;
      }
      if (d < 0) {  
        b += d; d = -d;
      }

      clipImpl(a, b, a + c, b + d);

    } else if (imageMode == CORNERS) {
      if (c < a) {  
        float temp = a; a = c; c = temp;
      }
      if (d < b) {  
        float temp = b; b = d; d = temp;
      }

      clipImpl(a, b, c, d);

    } else if (imageMode == CENTER) {

      if (c < 0) c = -c;
      if (d < 0) d = -d;
      float x1 = a - c/2;
      float y1 = b - d/2;

      clipImpl(x1, y1, x1 + c, y1 + d);
    }
  }


  protected void clipImpl(float x1, float y1, float x2, float y2) {
    showMissingWarning("clip");
  }


  public void noClip() {
    showMissingWarning("noClip");
  }








  public void blendMode(int mode) {
    this.blendMode = mode;
    blendModeImpl();
  }


  protected void blendModeImpl() {
    if (blendMode != BLEND) {
      showMissingWarning("blendMode");
    }
  }








  protected void bezierVertexCheck() {
    bezierVertexCheck(shape, vertexCount);
  }


  protected void bezierVertexCheck(int shape, int vertexCount) {
    if (shape == 0 || shape != POLYGON) {
      throw new RuntimeException("beginShape() or beginShape(POLYGON) " +
                                 "must be used before bezierVertex() or quadraticVertex()");
    }
    if (vertexCount == 0) {
      throw new RuntimeException("vertex() must be used at least once " +
                                 "before bezierVertex() or quadraticVertex()");
    }
  }


  public void bezierVertex(float x2, float y2,
                           float x3, float y3,
                           float x4, float y4) {
    bezierInitCheck();
    bezierVertexCheck();
    PMatrix3D draw = bezierDrawMatrix;

    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;

    for (int j = 0; j < bezierDetail; j++) {
      x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      vertex(x1, y1);
    }
  }


  public void bezierVertex(float x2, float y2, float z2,
                           float x3, float y3, float z3,
                           float x4, float y4, float z4) {
    bezierInitCheck();
    bezierVertexCheck();
    PMatrix3D draw = bezierDrawMatrix;

    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];
    float z1 = prev[Z];

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;

    float zplot1 = draw.m10*z1 + draw.m11*z2 + draw.m12*z3 + draw.m13*z4;
    float zplot2 = draw.m20*z1 + draw.m21*z2 + draw.m22*z3 + draw.m23*z4;
    float zplot3 = draw.m30*z1 + draw.m31*z2 + draw.m32*z3 + draw.m33*z4;

    for (int j = 0; j < bezierDetail; j++) {
      x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      z1 += zplot1; zplot1 += zplot2; zplot2 += zplot3;
      vertex(x1, y1, z1);
    }
  }


  public void quadraticVertex(float cx, float cy,
                              float x3, float y3) {
    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];

    bezierVertex(x1 + ((cx-x1)*2/3.0f), y1 + ((cy-y1)*2/3.0f),
                 x3 + ((cx-x3)*2/3.0f), y3 + ((cy-y3)*2/3.0f),
                 x3, y3);
  }


  public void quadraticVertex(float cx, float cy, float cz,
                              float x3, float y3, float z3) {
    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];
    float z1 = prev[Z];

    bezierVertex(x1 + ((cx-x1)*2/3.0f), y1 + ((cy-y1)*2/3.0f), z1 + ((cz-z1)*2/3.0f),
                 x3 + ((cx-x3)*2/3.0f), y3 + ((cy-y3)*2/3.0f), z3 + ((cz-z3)*2/3.0f),
                 x3, y3, z3);
  }

  protected void curveVertexCheck() {
    curveVertexCheck(shape);
  }


  protected void curveVertexCheck(int shape) {
    if (shape != POLYGON) {
      throw new RuntimeException("You must use beginShape() or " +
                                 "beginShape(POLYGON) before curveVertex()");
    }

    if (curveVertices == null) {
      curveVertices = new float[128][3];
    }

    if (curveVertexCount == curveVertices.length) {

      float[][] temp = new float[curveVertexCount << 1][3];
      System.arraycopy(curveVertices, 0, temp, 0, curveVertexCount);
      curveVertices = temp;
    }
    curveInitCheck();
  }


  public void curveVertex(float x, float y) {
    curveVertexCheck();
    float[] vertex = curveVertices[curveVertexCount];
    vertex[X] = x;
    vertex[Y] = y;
    curveVertexCount++;


    if (curveVertexCount > 3) {
      curveVertexSegment(curveVertices[curveVertexCount-4][X],
                         curveVertices[curveVertexCount-4][Y],
                         curveVertices[curveVertexCount-3][X],
                         curveVertices[curveVertexCount-3][Y],
                         curveVertices[curveVertexCount-2][X],
                         curveVertices[curveVertexCount-2][Y],
                         curveVertices[curveVertexCount-1][X],
                         curveVertices[curveVertexCount-1][Y]);
    }
  }


  public void curveVertex(float x, float y, float z) {
    curveVertexCheck();
    float[] vertex = curveVertices[curveVertexCount];
    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = z;
    curveVertexCount++;


    if (curveVertexCount > 3) {
      curveVertexSegment(curveVertices[curveVertexCount-4][X],
                         curveVertices[curveVertexCount-4][Y],
                         curveVertices[curveVertexCount-4][Z],
                         curveVertices[curveVertexCount-3][X],
                         curveVertices[curveVertexCount-3][Y],
                         curveVertices[curveVertexCount-3][Z],
                         curveVertices[curveVertexCount-2][X],
                         curveVertices[curveVertexCount-2][Y],
                         curveVertices[curveVertexCount-2][Z],
                         curveVertices[curveVertexCount-1][X],
                         curveVertices[curveVertexCount-1][Y],
                         curveVertices[curveVertexCount-1][Z]);
    }
  }



  protected void curveVertexSegment(float x1, float y1,
                                    float x2, float y2,
                                    float x3, float y3,
                                    float x4, float y4) {
    float x0 = x2;
    float y0 = y2;

    PMatrix3D draw = curveDrawMatrix;

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;


    int savedCount = curveVertexCount;

    vertex(x0, y0);
    for (int j = 0; j < curveDetail; j++) {
      x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      vertex(x0, y0);
    }
    curveVertexCount = savedCount;
  }



  protected void curveVertexSegment(float x1, float y1, float z1,
                                    float x2, float y2, float z2,
                                    float x3, float y3, float z3,
                                    float x4, float y4, float z4) {
    float x0 = x2;
    float y0 = y2;
    float z0 = z2;

    PMatrix3D draw = curveDrawMatrix;

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;


    int savedCount = curveVertexCount;

    float zplot1 = draw.m10*z1 + draw.m11*z2 + draw.m12*z3 + draw.m13*z4;
    float zplot2 = draw.m20*z1 + draw.m21*z2 + draw.m22*z3 + draw.m23*z4;
    float zplot3 = draw.m30*z1 + draw.m31*z2 + draw.m32*z3 + draw.m33*z4;

    vertex(x0, y0, z0);
    for (int j = 0; j < curveDetail; j++) {
      x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      z0 += zplot1; zplot1 += zplot2; zplot2 += zplot3;
      vertex(x0, y0, z0);
    }
    curveVertexCount = savedCount;
  }









  public void point(float x, float y) {
    beginShape(POINTS);
    vertex(x, y);
    endShape();
  }


  public void point(float x, float y, float z) {
    beginShape(POINTS);
    vertex(x, y, z);
    endShape();
  }


  public void line(float x1, float y1, float x2, float y2) {
    beginShape(LINES);
    vertex(x1, y1);
    vertex(x2, y2);
    endShape();
  }


  public void line(float x1, float y1, float z1,
                   float x2, float y2, float z2) {
    beginShape(LINES);
    vertex(x1, y1, z1);
    vertex(x2, y2, z2);
    endShape();
  }


  public void triangle(float x1, float y1, float x2, float y2,
                       float x3, float y3) {
    beginShape(TRIANGLES);
    vertex(x1, y1);
    vertex(x2, y2);
    vertex(x3, y3);
    endShape();
  }



  public void quad(float x1, float y1, float x2, float y2,
                   float x3, float y3, float x4, float y4) {
    beginShape(QUADS);
    vertex(x1, y1);
    vertex(x2, y2);
    vertex(x3, y3);
    vertex(x4, y4);
    endShape();
  }








  public void rectMode(int mode) {
    rectMode = mode;
  }



  public void rect(float a, float b, float c, float d) {
    float hradius, vradius;
    switch (rectMode) {
    case CORNERS:
      break;
    case CORNER:
      c += a; d += b;
      break;
    case RADIUS:
      hradius = c;
      vradius = d;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
      break;
    case CENTER:
      hradius = c / 2.0f;
      vradius = d / 2.0f;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
    }

    if (a > c) {
      float temp = a; a = c; c = temp;
    }

    if (b > d) {
      float temp = b; b = d; d = temp;
    }

    rectImpl(a, b, c, d);
  }


  protected void rectImpl(float x1, float y1, float x2, float y2) {
    quad(x1, y1,  x2, y1,  x2, y2,  x1, y2);
  }


















  public void rect(float a, float b, float c, float d, float r) {
    rect(a, b, c, d, r, r, r, r);
  }


  public void rect(float a, float b, float c, float d,
                   float tl, float tr, float br, float bl) {
    float hradius, vradius;
    switch (rectMode) {
    case CORNERS:
      break;
    case CORNER:
      c += a; d += b;
      break;
    case RADIUS:
      hradius = c;
      vradius = d;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
      break;
    case CENTER:
      hradius = c / 2.0f;
      vradius = d / 2.0f;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
    }

    if (a > c) {
      float temp = a; a = c; c = temp;
    }

    if (b > d) {
      float temp = b; b = d; d = temp;
    }

    float maxRounding = PApplet.min((c - a) / 2, (d - b) / 2);
    if (tl > maxRounding) tl = maxRounding;
    if (tr > maxRounding) tr = maxRounding;
    if (br > maxRounding) br = maxRounding;
    if (bl > maxRounding) bl = maxRounding;

    rectImpl(a, b, c, d, tl, tr, br, bl);
  }


  protected void rectImpl(float x1, float y1, float x2, float y2,
                          float tl, float tr, float br, float bl) {
    beginShape();

    if (tr != 0) {
      vertex(x2-tr, y1);
      quadraticVertex(x2, y1, x2, y1+tr);
    } else {
      vertex(x2, y1);
    }
    if (br != 0) {
      vertex(x2, y2-br);
      quadraticVertex(x2, y2, x2-br, y2);
    } else {
      vertex(x2, y2);
    }
    if (bl != 0) {
      vertex(x1+bl, y2);
      quadraticVertex(x1, y2, x1, y2-bl);
    } else {
      vertex(x1, y2);
    }
    if (tl != 0) {
      vertex(x1, y1+tl);
      quadraticVertex(x1, y1, x1+tl, y1);
    } else {
      vertex(x1, y1);
    }

    endShape(CLOSE);
  }









  public void ellipseMode(int mode) {
    ellipseMode = mode;
  }



  public void ellipse(float a, float b, float c, float d) {
    float x = a;
    float y = b;
    float w = c;
    float h = d;

    if (ellipseMode == CORNERS) {
      w = c - a;
      h = d - b;

    } else if (ellipseMode == RADIUS) {
      x = a - c;
      y = b - d;
      w = c * 2;
      h = d * 2;

    } else if (ellipseMode == DIAMETER) {
      x = a - c/2f;
      y = b - d/2f;
    }

    if (w < 0) {  
      x += w;
      w = -w;
    }

    if (h < 0) {  
      y += h;
      h = -h;
    }

    ellipseImpl(x, y, w, h);
  }


  protected void ellipseImpl(float x, float y, float w, float h) {
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop) {
    arc(a, b, c, d, start, stop, 0);
  }


  public void arc(float a, float b, float c, float d,
                  float start, float stop, int mode) {
    float x = a;
    float y = b;
    float w = c;
    float h = d;

    if (ellipseMode == CORNERS) {
      w = c - a;
      h = d - b;

    } else if (ellipseMode == RADIUS) {
      x = a - c;
      y = b - d;
      w = c * 2;
      h = d * 2;

    } else if (ellipseMode == CENTER) {
      x = a - c/2f;
      y = b - d/2f;
    }


    if (!Float.isInfinite(start) && !Float.isInfinite(stop)) {

      if (stop > start) {

        while (start < 0) {
          start += TWO_PI;
          stop += TWO_PI;
        }

        if (stop - start > TWO_PI) {

          stop = start + TWO_PI;
        }
        arcImpl(x, y, w, h, start, stop, mode);
      }
    }
  }








  protected void arcImpl(float x, float y, float w, float h,
                         float start, float stop, int mode) {
    showMissingWarning("arc");
  }







  public void box(float size) {
    box(size, size, size);
  }



  public void box(float w, float h, float d) {
    float x1 = -w/2f; float x2 = w/2f;
    float y1 = -h/2f; float y2 = h/2f;
    float z1 = -d/2f; float z2 = d/2f;




    beginShape(QUADS);


    normal(0, 0, 1);
    vertex(x1, y1, z1);
    vertex(x2, y1, z1);
    vertex(x2, y2, z1);
    vertex(x1, y2, z1);


    normal(1, 0, 0);
    vertex(x2, y1, z1);
    vertex(x2, y1, z2);
    vertex(x2, y2, z2);
    vertex(x2, y2, z1);


    normal(0, 0, -1);
    vertex(x2, y1, z2);
    vertex(x1, y1, z2);
    vertex(x1, y2, z2);
    vertex(x2, y2, z2);


    normal(-1, 0, 0);
    vertex(x1, y1, z2);
    vertex(x1, y1, z1);
    vertex(x1, y2, z1);
    vertex(x1, y2, z2);


    normal(0, 1, 0);
    vertex(x1, y1, z2);
    vertex(x2, y1, z2);
    vertex(x2, y1, z1);
    vertex(x1, y1, z1);


    normal(0, -1, 0);
    vertex(x1, y2, z1);
    vertex(x2, y2, z1);
    vertex(x2, y2, z2);
    vertex(x1, y2, z2);

    endShape();
  }








  public void sphereDetail(int res) {
    sphereDetail(res, res);
  }



  public void sphereDetail(int ures, int vres) {
    if (ures < 3) ures = 3; 
    if (vres < 2) vres = 2; 
    if ((ures == sphereDetailU) && (vres == sphereDetailV)) return;

    float delta = (float)SINCOS_LENGTH/ures;
    float[] cx = new float[ures];
    float[] cz = new float[ures];

    for (int i = 0; i < ures; i++) {
      cx[i] = cosLUT[(int) (i*delta) % SINCOS_LENGTH];
      cz[i] = sinLUT[(int) (i*delta) % SINCOS_LENGTH];
    }


    int vertCount = ures * (vres-1) + 2;
    int currVert = 0;


    sphereX = new float[vertCount];
    sphereY = new float[vertCount];
    sphereZ = new float[vertCount];

    float angle_step = (SINCOS_LENGTH*0.5f)/vres;
    float angle = angle_step;


    for (int i = 1; i < vres; i++) {
      float curradius = sinLUT[(int) angle % SINCOS_LENGTH];
      float currY = cosLUT[(int) angle % SINCOS_LENGTH];
      for (int j = 0; j < ures; j++) {
        sphereX[currVert] = cx[j] * curradius;
        sphereY[currVert] = currY;
        sphereZ[currVert++] = cz[j] * curradius;
      }
      angle += angle_step;
    }
    sphereDetailU = ures;
    sphereDetailV = vres;
  }



  public void sphere(float r) {
    if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
      sphereDetail(30);
    }

    edge(false);



    beginShape(TRIANGLE_STRIP);
    for (int i = 0; i < sphereDetailU; i++) {
      normal(0, -1, 0);
      vertex(0, -r, 0);
      normal(sphereX[i], sphereY[i], sphereZ[i]);
      vertex(r * sphereX[i], r * sphereY[i], r * sphereZ[i]);
    }
    normal(0, -r, 0);
    vertex(0, -r, 0);
    normal(sphereX[0], sphereY[0], sphereZ[0]);
    vertex(r * sphereX[0], r * sphereY[0], r * sphereZ[0]);
    endShape();

    int v1,v11,v2;


    int voff = 0;
    for (int i = 2; i < sphereDetailV; i++) {
      v1 = v11 = voff;
      voff += sphereDetailU;
      v2 = voff;
      beginShape(TRIANGLE_STRIP);
      for (int j = 0; j < sphereDetailU; j++) {
        normal(sphereX[v1], sphereY[v1], sphereZ[v1]);
        vertex(r * sphereX[v1], r * sphereY[v1], r * sphereZ[v1++]);
        normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
        vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2++]);
      }

      v1 = v11;
      v2 = voff;
      normal(sphereX[v1], sphereY[v1], sphereZ[v1]);
      vertex(r * sphereX[v1], r * sphereY[v1], r * sphereZ[v1]);
      normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
      vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2]);
      endShape();
    }


    beginShape(TRIANGLE_STRIP);
    for (int i = 0; i < sphereDetailU; i++) {
      v2 = voff + i;
      normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
      vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2]);
      normal(0, 1, 0);
      vertex(0, r, 0);
    }
    normal(sphereX[voff], sphereY[voff], sphereZ[voff]);
    vertex(r * sphereX[voff], r * sphereY[voff], r * sphereZ[voff]);
    normal(0, 1, 0);
    vertex(0, r, 0);
    endShape();

    edge(true);
  }








  public float bezierPoint(float a, float b, float c, float d, float t) {
    float t1 = 1.0f - t;
    return a*t1*t1*t1 + 3*b*t*t1*t1 + 3*c*t*t*t1 + d*t*t*t;
  }



  public float bezierTangent(float a, float b, float c, float d, float t) {
    return (3*t*t * (-a+3*b-3*c+d) +
            6*t * (a-2*b+c) +
            3 * (-a+b));
  }


  protected void bezierInitCheck() {
    if (!bezierInited) {
      bezierInit();
    }
  }


  protected void bezierInit() {

    bezierDetail(bezierDetail);
    bezierInited = true;
  }



  public void bezierDetail(int detail) {
    bezierDetail = detail;

    if (bezierDrawMatrix == null) {
      bezierDrawMatrix = new PMatrix3D();
    }


    splineForward(detail, bezierDrawMatrix);





    bezierDrawMatrix.apply(bezierBasisMatrix);
  }



  public void bezier(float x1, float y1,
                     float x2, float y2,
                     float x3, float y3,
                     float x4, float y4) {
    beginShape();
    vertex(x1, y1);
    bezierVertex(x2, y2, x3, y3, x4, y4);
    endShape();
  }


  public void bezier(float x1, float y1, float z1,
                     float x2, float y2, float z2,
                     float x3, float y3, float z3,
                     float x4, float y4, float z4) {
    beginShape();
    vertex(x1, y1, z1);
    bezierVertex(x2, y2, z2,
                 x3, y3, z3,
                 x4, y4, z4);
    endShape();
  }








  public float curvePoint(float a, float b, float c, float d, float t) {
    curveInitCheck();

    float tt = t * t;
    float ttt = t * tt;
    PMatrix3D cb = curveBasisMatrix;


    return (a * (ttt*cb.m00 + tt*cb.m10 + t*cb.m20 + cb.m30) +
            b * (ttt*cb.m01 + tt*cb.m11 + t*cb.m21 + cb.m31) +
            c * (ttt*cb.m02 + tt*cb.m12 + t*cb.m22 + cb.m32) +
            d * (ttt*cb.m03 + tt*cb.m13 + t*cb.m23 + cb.m33));
  }



  public float curveTangent(float a, float b, float c, float d, float t) {
    curveInitCheck();

    float tt3 = t * t * 3;
    float t2 = t * 2;
    PMatrix3D cb = curveBasisMatrix;


    return (a * (tt3*cb.m00 + t2*cb.m10 + cb.m20) +
            b * (tt3*cb.m01 + t2*cb.m11 + cb.m21) +
            c * (tt3*cb.m02 + t2*cb.m12 + cb.m22) +
            d * (tt3*cb.m03 + t2*cb.m13 + cb.m23) );
  }



  public void curveDetail(int detail) {
    curveDetail = detail;
    curveInit();
  }



  public void curveTightness(float tightness) {
    curveTightness = tightness;
    curveInit();
  }


  protected void curveInitCheck() {
    if (!curveInited) {
      curveInit();
    }
  }



  protected void curveInit() {

    if (curveDrawMatrix == null) {
      curveBasisMatrix = new PMatrix3D();
      curveDrawMatrix = new PMatrix3D();
      curveInited = true;
    }

    float s = curveTightness;
    curveBasisMatrix.set((s-1)/2f, (s+3)/2f,  (-3-s)/2f, (1-s)/2f,
                         (1-s),    (-5-s)/2f, (s+2),     (s-1)/2f,
                         (s-1)/2f, 0,         (1-s)/2f,  0,
                         0,        1,         0,         0);


    splineForward(curveDetail, curveDrawMatrix);

    if (bezierBasisInverse == null) {
      bezierBasisInverse = bezierBasisMatrix.get();
      bezierBasisInverse.invert();
      curveToBezierMatrix = new PMatrix3D();
    }




    curveToBezierMatrix.set(curveBasisMatrix);
    curveToBezierMatrix.preApply(bezierBasisInverse);



    curveDrawMatrix.apply(curveBasisMatrix);
  }



  public void curve(float x1, float y1,
                    float x2, float y2,
                    float x3, float y3,
                    float x4, float y4) {
    beginShape();
    curveVertex(x1, y1);
    curveVertex(x2, y2);
    curveVertex(x3, y3);
    curveVertex(x4, y4);
    endShape();
  }


  public void curve(float x1, float y1, float z1,
                    float x2, float y2, float z2,
                    float x3, float y3, float z3,
                    float x4, float y4, float z4) {
    beginShape();
    curveVertex(x1, y1, z1);
    curveVertex(x2, y2, z2);
    curveVertex(x3, y3, z3);
    curveVertex(x4, y4, z4);
    endShape();
  }









  protected void splineForward(int segments, PMatrix3D matrix) {
    float f  = 1.0f / segments;
    float ff = f * f;
    float fff = ff * f;

    matrix.set(0,     0,    0, 1,
               fff,   ff,   f, 0,
               6*fff, 2*ff, 0, 0,
               6*fff, 0,    0, 0);
  }








  public void smooth() {  
    smooth(1);
  }


  public void smooth(int quality) {  
    if (primaryGraphics) {
      parent.smooth(quality);
    } else {

      if (settingsInited) {

        if (this.smooth != quality) {
          smoothWarning("smooth");
        }
      } else {
        this.smooth = quality;
      }
    }
  }


  public void noSmooth() {  
    smooth(0);
  }


  private void smoothWarning(String method) {
    PGraphics.showWarning("%s() can only be used before beginDraw()", method);
  }









  public void imageMode(int mode) {
    if ((mode == CORNER) || (mode == CORNERS) || (mode == CENTER)) {
      imageMode = mode;
    } else {
      String msg =
        "imageMode() only works with CORNER, CORNERS, or CENTER";
      throw new RuntimeException(msg);
    }
  }



  public void image(PImage img, float a, float b) {


    if (img.width == -1 || img.height == -1) return;

    if (imageMode == CORNER || imageMode == CORNERS) {
      imageImpl(img,
                a, b, a+img.width, b+img.height,
                0, 0, img.width, img.height);

    } else if (imageMode == CENTER) {
      float x1 = a - img.width/2;
      float y1 = b - img.height/2;
      imageImpl(img,
                x1, y1, x1+img.width, y1+img.height,
                0, 0, img.width, img.height);
    }
  }


  public void image(PImage img, float a, float b, float c, float d) {
    image(img, a, b, c, d, 0, 0, img.width, img.height);
  }



  public void image(PImage img,
                    float a, float b, float c, float d,
                    int u1, int v1, int u2, int v2) {


    if (img.width == -1 || img.height == -1) return;

    if (imageMode == CORNER) {
      if (c < 0) {  
        a += c; c = -c;
      }
      if (d < 0) {  
        b += d; d = -d;
      }

      imageImpl(img,
                a, b, a + c, b + d,
                u1, v1, u2, v2);

    } else if (imageMode == CORNERS) {
      if (c < a) {  
        float temp = a; a = c; c = temp;
      }
      if (d < b) {  
        float temp = b; b = d; d = temp;
      }

      imageImpl(img,
                a, b, c, d,
                u1, v1, u2, v2);

    } else if (imageMode == CENTER) {

      if (c < 0) c = -c;
      if (d < 0) d = -d;
      float x1 = a - c/2;
      float y1 = b - d/2;

      imageImpl(img,
                x1, y1, x1 + c, y1 + d,
                u1, v1, u2, v2);
    }
  }



  protected void imageImpl(PImage img,
                           float x1, float y1, float x2, float y2,
                           int u1, int v1, int u2, int v2) {
    boolean savedStroke = stroke;

    int savedTextureMode = textureMode;

    stroke = false;

    textureMode = IMAGE;



















    beginShape(QUADS);
    texture(img);
    vertex(x1, y1, u1, v1);
    vertex(x1, y2, u1, v2);
    vertex(x2, y2, u2, v2);
    vertex(x2, y1, u2, v1);
    endShape();

    stroke = savedStroke;

    textureMode = savedTextureMode;





  }








  public void shapeMode(int mode) {
    this.shapeMode = mode;
  }


  public void shape(PShape shape) {
    if (shape.isVisible()) {  


      flush();

      if (shapeMode == CENTER) {
        pushMatrix();
        translate(-shape.getWidth()/2, -shape.getHeight()/2);
      }

      shape.draw(this); 

      if (shapeMode == CENTER) {
        popMatrix();
      }
    }
  }




  public void shape(PShape shape, float x, float y) {
    if (shape.isVisible()) {  
      flush();

      pushMatrix();

      if (shapeMode == CENTER) {
        translate(x - shape.getWidth()/2, y - shape.getHeight()/2);

      } else if ((shapeMode == CORNER) || (shapeMode == CORNERS)) {
        translate(x, y);
      }
      shape.draw(this);

      popMatrix();
    }
  }



  protected void shape(PShape shape, float x, float y, float z) {
    showMissingWarning("shape");
  }



  public void shape(PShape shape, float a, float b, float c, float d) {
    if (shape.isVisible()) {  
      flush();

      pushMatrix();

      if (shapeMode == CENTER) {

        translate(a - c/2f, b - d/2f);
        scale(c / shape.getWidth(), d / shape.getHeight());

      } else if (shapeMode == CORNER) {
        translate(a, b);
        scale(c / shape.getWidth(), d / shape.getHeight());

      } else if (shapeMode == CORNERS) {

        c -= a;
        d -= b;

        translate(a, b);
        scale(c / shape.getWidth(), d / shape.getHeight());
      }
      shape.draw(this);

      popMatrix();
    }
  }



  protected void shape(PShape shape, float x, float y, float z, float c, float d, float e) {
    showMissingWarning("shape");
  }







  public void textAlign(int alignX) {
    textAlign(alignX, BASELINE);
  }



  public void textAlign(int alignX, int alignY) {
    textAlign = alignX;
    textAlignY = alignY;
  }



  public float textAscent() {
    if (textFont == null) {
      defaultFontOrDeath("textAscent");
    }
    return textFont.ascent() * textSize;
  }



  public float textDescent() {
    if (textFont == null) {
      defaultFontOrDeath("textDescent");
    }
    return textFont.descent() * textSize;
  }



  public void textFont(PFont which) {
    if (which != null) {
      textFont = which;






      textSize(which.getDefaultSize());

    } else {
      throw new RuntimeException(ERROR_TEXTFONT_NULL_PFONT);
    }
  }



  public void textFont(PFont which, float size) {
    textFont(which);
    textSize(size);
  }



  public void textLeading(float leading) {
    textLeading = leading;
  }



  public void textMode(int mode) {

    if ((mode == LEFT) || (mode == RIGHT)) {
      showWarning("Since Processing 1.0 beta, textMode() is now textAlign().");
      return;
    }
    if (mode == SCREEN) {
      showWarning("textMode(SCREEN) has been removed from Processing 2.0.");
      return;
    }

    if (textModeCheck(mode)) {
      textMode = mode;
    } else {
      String modeStr = String.valueOf(mode);
      switch (mode) {
        case MODEL: modeStr = "MODEL"; break;
        case SHAPE: modeStr = "SHAPE"; break;
      }
      showWarning("textMode(" + modeStr + ") is not supported by this renderer.");
    }
  }


  protected boolean textModeCheck(int mode) {
    return true;
  }



  public void textSize(float size) {

    if (size <= 0) {



      System.err.println("textSize(" + size + ") ignored: " +
                         "the text size must be larger than zero");
      return;
    }
    if (textFont == null) {
      defaultFontOrDeath("textSize", size);
    }
    textSize = size;
    textLeading = (textAscent() + textDescent()) * 1.275f;
  }






  public float textWidth(char c) {
    textWidthBuffer[0] = c;
    return textWidthImpl(textWidthBuffer, 0, 1);
  }



  public float textWidth(String str) {
    if (textFont == null) {
      defaultFontOrDeath("textWidth");
    }

    int length = str.length();
    if (length > textWidthBuffer.length) {
      textWidthBuffer = new char[length + 10];
    }
    str.getChars(0, length, textWidthBuffer, 0);

    float wide = 0;
    int index = 0;
    int start = 0;

    while (index < length) {
      if (textWidthBuffer[index] == '\n') {
        wide = Math.max(wide, textWidthImpl(textWidthBuffer, start, index));
        start = index+1;
      }
      index++;
    }
    if (start < length) {
      wide = Math.max(wide, textWidthImpl(textWidthBuffer, start, index));
    }
    return wide;
  }



  public float textWidth(char[] chars, int start, int length) {
    return textWidthImpl(chars, start, start + length);
  }



  protected float textWidthImpl(char buffer[], int start, int stop) {
    float wide = 0;
    for (int i = start; i < stop; i++) {

      wide += textFont.width(buffer[i]) * textSize;
    }
    return wide;
  }






  public void text(char c, float x, float y) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    if (textAlignY == CENTER) {
      y += textAscent() / 2;
    } else if (textAlignY == TOP) {
      y += textAscent();
    } else if (textAlignY == BOTTOM) {
      y -= textDescent();


    }

    textBuffer[0] = c;
    textLineAlignImpl(textBuffer, 0, 1, x, y);
  }



  public void text(char c, float x, float y, float z) {





    if (z != 0) translate(0, 0, z);  

    text(c, x, y);


    if (z != 0) translate(0, 0, -z);
  }









  public void text(String str, float x, float y) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    int length = str.length();
    if (length > textBuffer.length) {
      textBuffer = new char[length + 10];
    }
    str.getChars(0, length, textBuffer, 0);
    text(textBuffer, 0, length, x, y);
  }



  public void text(char[] chars, int start, int stop, float x, float y) {

    float high = 0; 
    for (int i = start; i < stop; i++) {
      if (chars[i] == '\n') {
        high += textLeading;
      }
    }
    if (textAlignY == CENTER) {



      y += (textAscent() - high)/2;
    } else if (textAlignY == TOP) {


      y += textAscent();
    } else if (textAlignY == BOTTOM) {


      y -= textDescent() + high;


    }


    int index = 0;
    while (index < stop) { 
      if (chars[index] == '\n') {
        textLineAlignImpl(chars, start, index, x, y);
        start = index + 1;
        y += textLeading;
      }
      index++;
    }
    if (start < stop) {  
      textLineAlignImpl(chars, start, index, x, y);
    }
  }



  public void text(String str, float x, float y, float z) {
    if (z != 0) translate(0, 0, z);  

    text(str, x, y);


    if (z != 0) translate(0, 0, -z);  
  }


  public void text(char[] chars, int start, int stop,
                   float x, float y, float z) {
    if (z != 0) translate(0, 0, z);  

    text(chars, start, stop, x, y);


    if (z != 0) translate(0, 0, -z);  
  }



  public void text(String str, float x1, float y1, float x2, float y2) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    float hradius, vradius;
    switch (rectMode) {
    case CORNER:
      x2 += x1; y2 += y1;
      break;
    case RADIUS:
      hradius = x2;
      vradius = y2;
      x2 = x1 + hradius;
      y2 = y1 + vradius;
      x1 -= hradius;
      y1 -= vradius;
      break;
    case CENTER:
      hradius = x2 / 2.0f;
      vradius = y2 / 2.0f;
      x2 = x1 + hradius;
      y2 = y1 + vradius;
      x1 -= hradius;
      y1 -= vradius;
    }
    if (x2 < x1) {
      float temp = x1; x1 = x2; x2 = temp;
    }
    if (y2 < y1) {
      float temp = y1; y1 = y2; y2 = temp;
    }


    float boxWidth = x2 - x1;






    float spaceWidth = textWidth(' ');

    if (textBreakStart == null) {
      textBreakStart = new int[20];
      textBreakStop = new int[20];
    }
    textBreakCount = 0;

    int length = str.length();
    if (length + 1 > textBuffer.length) {
      textBuffer = new char[length + 1];
    }
    str.getChars(0, length, textBuffer, 0);

    textBuffer[length++] = '\n';

    int sentenceStart = 0;
    for (int i = 0; i < length; i++) {
      if (textBuffer[i] == '\n') {


        boolean legit =
          textSentence(textBuffer, sentenceStart, i, boxWidth, spaceWidth);
        if (!legit) break;


        sentenceStart = i + 1;
      }
    }



    float lineX = x1; 
    if (textAlign == CENTER) {
      lineX = lineX + boxWidth/2f;
    } else if (textAlign == RIGHT) {
      lineX = x2; 
    }

    float boxHeight = y2 - y1;




    float topAndBottom = textAscent() + textDescent();
    int lineFitCount = 1 + PApplet.floor((boxHeight - topAndBottom) / textLeading);
    int lineCount = Math.min(textBreakCount, lineFitCount);

    if (textAlignY == CENTER) {
      float lineHigh = textAscent() + textLeading * (lineCount - 1);
      float y = y1 + textAscent() + (boxHeight - lineHigh) / 2;
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }

    } else if (textAlignY == BOTTOM) {
      float y = y2 - textDescent() - textLeading * (lineCount - 1);
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }

    } else {  
      float y = y1 + textAscent();
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }
    }
  }



  protected boolean textSentence(char[] buffer, int start, int stop,
                                 float boxWidth, float spaceWidth) {
    float runningX = 0;



    int lineStart = start;
    int wordStart = start;
    int index = start;
    while (index <= stop) {

      if ((buffer[index] == ' ') || (index == stop)) {
        float wordWidth = textWidthImpl(buffer, wordStart, index);

        if (runningX + wordWidth >= boxWidth) {
          if (runningX != 0) {

            index = wordStart;
            textSentenceBreak(lineStart, index);

            while ((index < stop) && (buffer[index] == ' ')) {
              index++;
            }
          } else {  



            do {
              index--;
              if (index == wordStart) {


                return false; 
              }
              wordWidth = textWidthImpl(buffer, wordStart, index);
            } while (wordWidth > boxWidth);


            textSentenceBreak(lineStart, index);
          }
          lineStart = index;
          wordStart = index;
          runningX = 0;

        } else if (index == stop) {


          textSentenceBreak(lineStart, index);

          index++;

        } else {  
          runningX += wordWidth;
          wordStart = index ;  
          index++;
        }
      } else {  
        index++;  
      }
    }

    return true;
  }


  protected void textSentenceBreak(int start, int stop) {
    if (textBreakCount == textBreakStart.length) {
      textBreakStart = PApplet.expand(textBreakStart);
      textBreakStop = PApplet.expand(textBreakStop);
    }
    textBreakStart[textBreakCount] = start;
    textBreakStop[textBreakCount] = stop;
    textBreakCount++;
  }












  public void text(int num, float x, float y) {
    text(String.valueOf(num), x, y);
  }


  public void text(int num, float x, float y, float z) {
    text(String.valueOf(num), x, y, z);
  }



  public void text(float num, float x, float y) {
    text(PApplet.nfs(num, 0, 3), x, y);
  }


  public void text(float num, float x, float y, float z) {
    text(PApplet.nfs(num, 0, 3), x, y, z);
  }











  protected void textLineAlignImpl(char buffer[], int start, int stop,
                                   float x, float y) {
    if (textAlign == CENTER) {
      x -= textWidthImpl(buffer, start, stop) / 2f;

    } else if (textAlign == RIGHT) {
      x -= textWidthImpl(buffer, start, stop);
    }

    textLineImpl(buffer, start, stop, x, y);
  }



  protected void textLineImpl(char buffer[], int start, int stop,
                              float x, float y) {
    for (int index = start; index < stop; index++) {
      textCharImpl(buffer[index], x, y);


      x += textWidth(buffer[index]);
    }



  }


  protected void textCharImpl(char ch, float x, float y) { 
    PFont.Glyph glyph = textFont.getGlyph(ch);
    if (glyph != null) {
      if (textMode == MODEL) {
        float high    = glyph.height     / (float) textFont.getSize();
        float bwidth  = glyph.width      / (float) textFont.getSize();
        float lextent = glyph.leftExtent / (float) textFont.getSize();
        float textent = glyph.topExtent  / (float) textFont.getSize();

        float x1 = x + lextent * textSize;
        float y1 = y - textent * textSize;
        float x2 = x1 + bwidth * textSize;
        float y2 = y1 + high * textSize;

        textCharModelImpl(glyph.image,
                          x1, y1, x2, y2,
                          glyph.width, glyph.height);
      }
    } else if (ch != ' ' && ch != 127) {
      showWarning("No glyph found for the " + ch + " (\\u" + PApplet.hex(ch, 4) + ") character");
    }
  }


  protected void textCharModelImpl(PImage glyph,
                                   float x1, float y1, 
                                   float x2, float y2, 
                                   int u2, int v2) {
    boolean savedTint = tint;
    int savedTintColor = tintColor;
    float savedTintR = tintR;
    float savedTintG = tintG;
    float savedTintB = tintB;
    float savedTintA = tintA;
    boolean savedTintAlpha = tintAlpha;

    tint = true;
    tintColor = fillColor;
    tintR = fillR;
    tintG = fillG;
    tintB = fillB;
    tintA = fillA;
    tintAlpha = fillAlpha;

    imageImpl(glyph, x1, y1, x2, y2, 0, 0, u2, v2);

    tint = savedTint;
    tintColor = savedTintColor;
    tintR = savedTintR;
    tintG = savedTintG;
    tintB = savedTintB;
    tintA = savedTintA;
    tintAlpha = savedTintAlpha;
  }






  @SuppressWarnings("deprecation")
  public FontMetrics getFontMetrics(Font font) {  
    Frame frame = parent.getFrame();
    if (frame != null) {
      return frame.getToolkit().getFontMetrics(font);
    }
    return Toolkit.getDefaultToolkit().getFontMetrics(font);
  }



  public FontRenderContext getFontRenderContext(Font font) {  
    return getFontMetrics(font).getFontRenderContext();
  }









  public void pushMatrix() {
    showMethodWarning("pushMatrix");
  }



  public void popMatrix() {
    showMethodWarning("popMatrix");
  }









  public void translate(float x, float y) {
    showMissingWarning("translate");
  }



  public void translate(float x, float y, float z) {
    showMissingWarning("translate");
  }



  public void rotate(float angle) {
    showMissingWarning("rotate");
  }



  public void rotateX(float angle) {
    showMethodWarning("rotateX");
  }



  public void rotateY(float angle) {
    showMethodWarning("rotateY");
  }



  public void rotateZ(float angle) {
    showMethodWarning("rotateZ");
  }



  public void rotate(float angle, float x, float y, float z) {
    showMissingWarning("rotate");
  }



  public void scale(float s) {
    showMissingWarning("scale");
  }



  public void scale(float x, float y) {
    showMissingWarning("scale");
  }



  public void scale(float x, float y, float z) {
    showMissingWarning("scale");
  }



  public void shearX(float angle) {
    showMissingWarning("shearX");
  }



  public void shearY(float angle) {
    showMissingWarning("shearY");
  }








  public void resetMatrix() {
    showMethodWarning("resetMatrix");
  }


  public void applyMatrix(PMatrix source) {
    if (source instanceof PMatrix2D) {
      applyMatrix((PMatrix2D) source);
    } else if (source instanceof PMatrix3D) {
      applyMatrix((PMatrix3D) source);
    }
  }


  public void applyMatrix(PMatrix2D source) {
    applyMatrix(source.m00, source.m01, source.m02,
                source.m10, source.m11, source.m12);
  }



  public void applyMatrix(float n00, float n01, float n02,
                          float n10, float n11, float n12) {
    showMissingWarning("applyMatrix");
  }

  public void applyMatrix(PMatrix3D source) {
    applyMatrix(source.m00, source.m01, source.m02, source.m03,
                source.m10, source.m11, source.m12, source.m13,
                source.m20, source.m21, source.m22, source.m23,
                source.m30, source.m31, source.m32, source.m33);
  }



  public void applyMatrix(float n00, float n01, float n02, float n03,
                          float n10, float n11, float n12, float n13,
                          float n20, float n21, float n22, float n23,
                          float n30, float n31, float n32, float n33) {
    showMissingWarning("applyMatrix");
  }








  public PMatrix getMatrix() {
    showMissingWarning("getMatrix");
    return null;
  }



  public PMatrix2D getMatrix(PMatrix2D target) {
    showMissingWarning("getMatrix");
    return null;
  }



  public PMatrix3D getMatrix(PMatrix3D target) {
    showMissingWarning("getMatrix");
    return null;
  }



  public void setMatrix(PMatrix source) {
    if (source instanceof PMatrix2D) {
      setMatrix((PMatrix2D) source);
    } else if (source instanceof PMatrix3D) {
      setMatrix((PMatrix3D) source);
    }
  }



  public void setMatrix(PMatrix2D source) {
    showMissingWarning("setMatrix");
  }



  public void setMatrix(PMatrix3D source) {
    showMissingWarning("setMatrix");
  }



  public void printMatrix() {
    showMethodWarning("printMatrix");
  }







  public void beginCamera() {
    showMethodWarning("beginCamera");
  }


  public void endCamera() {
    showMethodWarning("endCamera");
  }


  public void camera() {
    showMissingWarning("camera");
  }


  public void camera(float eyeX, float eyeY, float eyeZ,
                     float centerX, float centerY, float centerZ,
                     float upX, float upY, float upZ) {
    showMissingWarning("camera");
  }


  public void printCamera() {
    showMethodWarning("printCamera");
  }








  public void ortho() {
    showMissingWarning("ortho");
  }


  public void ortho(float left, float right,
                    float bottom, float top) {
    showMissingWarning("ortho");
  }


  public void ortho(float left, float right,
                    float bottom, float top,
                    float near, float far) {
    showMissingWarning("ortho");
  }


  public void perspective() {
    showMissingWarning("perspective");
  }


  public void perspective(float fovy, float aspect, float zNear, float zFar) {
    showMissingWarning("perspective");
  }


  public void frustum(float left, float right,
                      float bottom, float top,
                      float near, float far) {
    showMethodWarning("frustum");
  }


  public void printProjection() {
    showMethodWarning("printProjection");
  }









  public float screenX(float x, float y) {
    showMissingWarning("screenX");
    return 0;
  }



  public float screenY(float x, float y) {
    showMissingWarning("screenY");
    return 0;
  }



  public float screenX(float x, float y, float z) {
    showMissingWarning("screenX");
    return 0;
  }



  public float screenY(float x, float y, float z) {
    showMissingWarning("screenY");
    return 0;
  }




  public float screenZ(float x, float y, float z) {
    showMissingWarning("screenZ");
    return 0;
  }



  public float modelX(float x, float y, float z) {
    showMissingWarning("modelX");
    return 0;
  }



  public float modelY(float x, float y, float z) {
    showMissingWarning("modelY");
    return 0;
  }



  public float modelZ(float x, float y, float z) {
    showMissingWarning("modelZ");
    return 0;
  }








  public void pushStyle() {
    if (styleStackDepth == styleStack.length) {
      styleStack = (PStyle[]) PApplet.expand(styleStack);
    }
    if (styleStack[styleStackDepth] == null) {
      styleStack[styleStackDepth] = new PStyle();
    }
    PStyle s = styleStack[styleStackDepth++];
    getStyle(s);
  }


  public void popStyle() {
    if (styleStackDepth == 0) {
      throw new RuntimeException("Too many popStyle() without enough pushStyle()");
    }
    styleStackDepth--;
    style(styleStack[styleStackDepth]);
  }


  public void style(PStyle s) {






    imageMode(s.imageMode);
    rectMode(s.rectMode);
    ellipseMode(s.ellipseMode);
    shapeMode(s.shapeMode);

    blendMode(s.blendMode);

    if (s.tint) {
      tint(s.tintColor);
    } else {
      noTint();
    }
    if (s.fill) {
      fill(s.fillColor);
    } else {
      noFill();
    }
    if (s.stroke) {
      stroke(s.strokeColor);
    } else {
      noStroke();
    }
    strokeWeight(s.strokeWeight);
    strokeCap(s.strokeCap);
    strokeJoin(s.strokeJoin);




    colorMode(RGB, 1);
    ambient(s.ambientR, s.ambientG, s.ambientB);
    emissive(s.emissiveR, s.emissiveG, s.emissiveB);
    specular(s.specularR, s.specularG, s.specularB);
    shininess(s.shininess);








    colorMode(s.colorMode,
              s.colorModeX, s.colorModeY, s.colorModeZ, s.colorModeA);





    if (s.textFont != null) {
      textFont(s.textFont, s.textSize);
      textLeading(s.textLeading);
    }

    textAlign(s.textAlign, s.textAlignY);
    textMode(s.textMode);
  }


  public PStyle getStyle() {  
    return getStyle(null);
  }


  public PStyle getStyle(PStyle s) {  
    if (s == null) {
      s = new PStyle();
    }

    s.imageMode = imageMode;
    s.rectMode = rectMode;
    s.ellipseMode = ellipseMode;
    s.shapeMode = shapeMode;

    s.blendMode = blendMode;

    s.colorMode = colorMode;
    s.colorModeX = colorModeX;
    s.colorModeY = colorModeY;
    s.colorModeZ = colorModeZ;
    s.colorModeA = colorModeA;

    s.tint = tint;
    s.tintColor = tintColor;
    s.fill = fill;
    s.fillColor = fillColor;
    s.stroke = stroke;
    s.strokeColor = strokeColor;
    s.strokeWeight = strokeWeight;
    s.strokeCap = strokeCap;
    s.strokeJoin = strokeJoin;

    s.ambientR = ambientR;
    s.ambientG = ambientG;
    s.ambientB = ambientB;
    s.specularR = specularR;
    s.specularG = specularG;
    s.specularB = specularB;
    s.emissiveR = emissiveR;
    s.emissiveG = emissiveG;
    s.emissiveB = emissiveB;
    s.shininess = shininess;

    s.textFont = textFont;
    s.textAlign = textAlign;
    s.textAlignY = textAlignY;
    s.textMode = textMode;
    s.textSize = textSize;
    s.textLeading = textLeading;

    return s;
  }








  public void strokeWeight(float weight) {
    strokeWeight = weight;
  }


  public void strokeJoin(int join) {
    strokeJoin = join;
  }


  public void strokeCap(int cap) {
    strokeCap = cap;
  }









  public void noStroke() {
    stroke = false;
  }



  public void stroke(int rgb) {
    colorCalc(rgb);
    strokeFromCalc();
  }



  public void stroke(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    strokeFromCalc();
  }



  public void stroke(float gray) {
    colorCalc(gray);
    strokeFromCalc();
  }


  public void stroke(float gray, float alpha) {
    colorCalc(gray, alpha);
    strokeFromCalc();
  }



  public void stroke(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    strokeFromCalc();
  }


  public void stroke(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    strokeFromCalc();
  }


  protected void strokeFromCalc() {
    stroke = true;
    strokeR = calcR;
    strokeG = calcG;
    strokeB = calcB;
    strokeA = calcA;
    strokeRi = calcRi;
    strokeGi = calcGi;
    strokeBi = calcBi;
    strokeAi = calcAi;
    strokeColor = calcColor;
    strokeAlpha = calcAlpha;
  }









  public void noTint() {
    tint = false;
  }



  public void tint(int rgb) {
    colorCalc(rgb);
    tintFromCalc();
  }



  public void tint(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    tintFromCalc();
  }



  public void tint(float gray) {
    colorCalc(gray);
    tintFromCalc();
  }


  public void tint(float gray, float alpha) {
    colorCalc(gray, alpha);
    tintFromCalc();
  }


  public void tint(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    tintFromCalc();
  }


  public void tint(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    tintFromCalc();
  }


  protected void tintFromCalc() {
    tint = true;
    tintR = calcR;
    tintG = calcG;
    tintB = calcB;
    tintA = calcA;
    tintRi = calcRi;
    tintGi = calcGi;
    tintBi = calcBi;
    tintAi = calcAi;
    tintColor = calcColor;
    tintAlpha = calcAlpha;
  }









  public void noFill() {
    fill = false;
  }



  public void fill(int rgb) {
    colorCalc(rgb);
    fillFromCalc();
  }


  public void fill(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    fillFromCalc();
  }



  public void fill(float gray) {
    colorCalc(gray);
    fillFromCalc();
  }


  public void fill(float gray, float alpha) {
    colorCalc(gray, alpha);
    fillFromCalc();
  }



  public void fill(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    fillFromCalc();
  }


  public void fill(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    fillFromCalc();
  }


  protected void fillFromCalc() {
    fill = true;
    fillR = calcR;
    fillG = calcG;
    fillB = calcB;
    fillA = calcA;
    fillRi = calcRi;
    fillGi = calcGi;
    fillBi = calcBi;
    fillAi = calcAi;
    fillColor = calcColor;
    fillAlpha = calcAlpha;
  }








  public void ambient(int rgb) {







    colorCalc(rgb);
    ambientFromCalc();
  }


  public void ambient(float gray) {
    colorCalc(gray);
    ambientFromCalc();
  }


  public void ambient(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    ambientFromCalc();
  }


  protected void ambientFromCalc() {
    ambientColor = calcColor;
    ambientR = calcR;
    ambientG = calcG;
    ambientB = calcB;
    setAmbient = true;
  }


  public void specular(int rgb) {







    colorCalc(rgb);
    specularFromCalc();
  }



  public void specular(float gray) {
    colorCalc(gray);
    specularFromCalc();
  }



  public void specular(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    specularFromCalc();
  }


  protected void specularFromCalc() {
    specularColor = calcColor;
    specularR = calcR;
    specularG = calcG;
    specularB = calcB;
  }



  public void shininess(float shine) {
    shininess = shine;
  }


  public void emissive(int rgb) {







    colorCalc(rgb);
    emissiveFromCalc();
  }


  public void emissive(float gray) {
    colorCalc(gray);
    emissiveFromCalc();
  }


  public void emissive(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    emissiveFromCalc();
  }


  protected void emissiveFromCalc() {
    emissiveColor = calcColor;
    emissiveR = calcR;
    emissiveG = calcG;
    emissiveB = calcB;
  }












  public void lights() {
    showMethodWarning("lights");
  }


  public void noLights() {
    showMethodWarning("noLights");
  }


  public void ambientLight(float v1, float v2, float v3) {
    showMethodWarning("ambientLight");
  }


  public void ambientLight(float v1, float v2, float v3,
                           float x, float y, float z) {
    showMethodWarning("ambientLight");
  }


  public void directionalLight(float v1, float v2, float v3,
                               float nx, float ny, float nz) {
    showMethodWarning("directionalLight");
  }


  public void pointLight(float v1, float v2, float v3,
                         float x, float y, float z) {
    showMethodWarning("pointLight");
  }


  public void spotLight(float v1, float v2, float v3,
                        float x, float y, float z,
                        float nx, float ny, float nz,
                        float angle, float concentration) {
    showMethodWarning("spotLight");
  }


  public void lightFalloff(float constant, float linear, float quadratic) {
    showMethodWarning("lightFalloff");
  }


  public void lightSpecular(float v1, float v2, float v3) {
    showMethodWarning("lightSpecular");
  }









  public void background(int rgb) {











    colorCalc(rgb);
    backgroundFromCalc();
  }



  public void background(int rgb, float alpha) {













    colorCalc(rgb, alpha);
    backgroundFromCalc();
  }



  public void background(float gray) {
    colorCalc(gray);
    backgroundFromCalc();

  }


  public void background(float gray, float alpha) {
    if (format == RGB) {
      background(gray);  

    } else {
      colorCalc(gray, alpha);
      backgroundFromCalc();

    }
  }



  public void background(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    backgroundFromCalc();

  }


  public void background(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    backgroundFromCalc();
  }


  public void clear() {
    background(0, 0, 0, 0);
  }


  protected void backgroundFromCalc() {
    backgroundR = calcR;
    backgroundG = calcG;
    backgroundB = calcB;


    backgroundA = (format == RGB) ? 1 : calcA;
    backgroundRi = calcRi;
    backgroundGi = calcGi;
    backgroundBi = calcBi;
    backgroundAi = (format == RGB) ? 255 : calcAi;
    backgroundAlpha = (format == RGB) ? false : calcAlpha;
    backgroundColor = calcColor;

    backgroundImpl();
  }



  public void background(PImage image) {
    if ((image.width != width) || (image.height != height)) {
      throw new RuntimeException(ERROR_BACKGROUND_IMAGE_SIZE);
    }
    if ((image.format != RGB) && (image.format != ARGB)) {
      throw new RuntimeException(ERROR_BACKGROUND_IMAGE_FORMAT);
    }
    backgroundColor = 0;  
    backgroundImpl(image);
  }



  protected void backgroundImpl(PImage image) {

    set(0, 0, image);
  }



  protected void backgroundImpl() {
    pushStyle();
    pushMatrix();
    resetMatrix();
    fill(backgroundColor);
    rect(0, 0, width, height);
    popMatrix();
    popStyle();
  }





























  public void colorMode(int mode) {
    colorMode(mode, colorModeX, colorModeY, colorModeZ, colorModeA);
  }



  public void colorMode(int mode, float max) {
    colorMode(mode, max, max, max, max);
  }



  public void colorMode(int mode, float max1, float max2, float max3) {
    colorMode(mode, max1, max2, max3, colorModeA);
  }



  public void colorMode(int mode,
                        float max1, float max2, float max3, float maxA) {
    colorMode = mode;

    colorModeX = max1;  
    colorModeY = max2;
    colorModeZ = max3;
    colorModeA = maxA;


    colorModeScale =
      ((maxA != 1) || (max1 != max2) || (max2 != max3) || (max3 != maxA));



    colorModeDefault = (colorMode == RGB) &&
      (colorModeA == 255) && (colorModeX == 255) &&
      (colorModeY == 255) && (colorModeZ == 255);
  }



















  protected void colorCalc(int rgb) {
    if (((rgb & 0xff000000) == 0) && (rgb <= colorModeX)) {
      colorCalc((float) rgb);

    } else {
      colorCalcARGB(rgb, colorModeA);
    }
  }


  protected void colorCalc(int rgb, float alpha) {
    if (((rgb & 0xff000000) == 0) && (rgb <= colorModeX)) {  
      colorCalc((float) rgb, alpha);

    } else {
      colorCalcARGB(rgb, alpha);
    }
  }


  protected void colorCalc(float gray) {
    colorCalc(gray, colorModeA);
  }


  protected void colorCalc(float gray, float alpha) {
    if (gray > colorModeX) gray = colorModeX;
    if (alpha > colorModeA) alpha = colorModeA;

    if (gray < 0) gray = 0;
    if (alpha < 0) alpha = 0;

    calcR = colorModeScale ? (gray / colorModeX) : gray;
    calcG = calcR;
    calcB = calcR;
    calcA = colorModeScale ? (alpha / colorModeA) : alpha;

    calcRi = (int)(calcR*255); calcGi = (int)(calcG*255);
    calcBi = (int)(calcB*255); calcAi = (int)(calcA*255);
    calcColor = (calcAi << 24) | (calcRi << 16) | (calcGi << 8) | calcBi;
    calcAlpha = (calcAi != 255);
  }


  protected void colorCalc(float x, float y, float z) {
    colorCalc(x, y, z, colorModeA);
  }


  protected void colorCalc(float x, float y, float z, float a) {
    if (x > colorModeX) x = colorModeX;
    if (y > colorModeY) y = colorModeY;
    if (z > colorModeZ) z = colorModeZ;
    if (a > colorModeA) a = colorModeA;

    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (z < 0) z = 0;
    if (a < 0) a = 0;

    switch (colorMode) {
    case RGB:
      if (colorModeScale) {
        calcR = x / colorModeX;
        calcG = y / colorModeY;
        calcB = z / colorModeZ;
        calcA = a / colorModeA;
      } else {
        calcR = x; calcG = y; calcB = z; calcA = a;
      }
      break;

    case HSB:
      x /= colorModeX; 
      y /= colorModeY; 
      z /= colorModeZ; 

      calcA = colorModeScale ? (a/colorModeA) : a;

      if (y == 0) {  
        calcR = calcG = calcB = z;

      } else {
        float which = (x - (int)x) * 6.0f;
        float f = which - (int)which;
        float p = z * (1.0f - y);
        float q = z * (1.0f - y * f);
        float t = z * (1.0f - (y * (1.0f - f)));

        switch ((int)which) {
        case 0: calcR = z; calcG = t; calcB = p; break;
        case 1: calcR = q; calcG = z; calcB = p; break;
        case 2: calcR = p; calcG = z; calcB = t; break;
        case 3: calcR = p; calcG = q; calcB = z; break;
        case 4: calcR = t; calcG = p; calcB = z; break;
        case 5: calcR = z; calcG = p; calcB = q; break;
        }
      }
      break;
    }
    calcRi = (int)(255*calcR); calcGi = (int)(255*calcG);
    calcBi = (int)(255*calcB); calcAi = (int)(255*calcA);
    calcColor = (calcAi << 24) | (calcRi << 16) | (calcGi << 8) | calcBi;
    calcAlpha = (calcAi != 255);
  }



  protected void colorCalcARGB(int argb, float alpha) {
    if (alpha == colorModeA) {
      calcAi = (argb >> 24) & 0xff;
      calcColor = argb;
    } else {
      calcAi = (int) (((argb >> 24) & 0xff) * PApplet.constrain((alpha / colorModeA), 0, 1));
      calcColor = (calcAi << 24) | (argb & 0xFFFFFF);
    }
    calcRi = (argb >> 16) & 0xff;
    calcGi = (argb >> 8) & 0xff;
    calcBi = argb & 0xff;
    calcA = calcAi / 255.0f;
    calcR = calcRi / 255.0f;
    calcG = calcGi / 255.0f;
    calcB = calcBi / 255.0f;
    calcAlpha = (calcAi != 255);
  }
















  public final int color(int c) {  











    colorCalc(c);
    return calcColor;
  }


  public final int color(float gray) {  
    colorCalc(gray);
    return calcColor;
  }



  public final int color(int c, int alpha) {  







    colorCalc(c, alpha);
    return calcColor;
  }



  public final int color(int c, float alpha) {  

    colorCalc(c, alpha);



    return calcColor;
  }


  public final int color(float gray, float alpha) {  
    colorCalc(gray, alpha);
    return calcColor;
  }


  public final int color(int v1, int v2, int v3) {  
    colorCalc(v1, v2, v3);
    return calcColor;
  }


  public final int color(float v1, float v2, float v3) {  
    colorCalc(v1, v2, v3);
    return calcColor;
  }


  public final int color(int v1, int v2, int v3, int a) {  
    colorCalc(v1, v2, v3, a);
    return calcColor;
  }


  public final int color(float v1, float v2, float v3, float a) {  
    colorCalc(v1, v2, v3, a);
    return calcColor;
  }










  public final float alpha(int rgb) {
    float outgoing = (rgb >> 24) & 0xff;
    if (colorModeA == 255) return outgoing;
    return (outgoing / 255.0f) * colorModeA;
  }



  public final float red(int rgb) {
    float c = (rgb >> 16) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeX;
  }



  public final float green(int rgb) {
    float c = (rgb >> 8) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeY;
  }



  public final float blue(int rgb) {
    float c = (rgb) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeZ;
  }



  public final float hue(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[0] * colorModeX;
  }



  public final float saturation(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[1] * colorModeY;
  }



  public final float brightness(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[2] * colorModeZ;
  }











  public int lerpColor(int c1, int c2, float amt) {  
    return lerpColor(c1, c2, amt, colorMode);
  }

  static float[] lerpColorHSB1;
  static float[] lerpColorHSB2;


  static public int lerpColor(int c1, int c2, float amt, int mode) {
    if (amt < 0) amt = 0;
    if (amt > 1) amt = 1;

    if (mode == RGB) {
      float a1 = ((c1 >> 24) & 0xff);
      float r1 = (c1 >> 16) & 0xff;
      float g1 = (c1 >> 8) & 0xff;
      float b1 = c1 & 0xff;
      float a2 = (c2 >> 24) & 0xff;
      float r2 = (c2 >> 16) & 0xff;
      float g2 = (c2 >> 8) & 0xff;
      float b2 = c2 & 0xff;

      return ((PApplet.round(a1 + (a2-a1)*amt) << 24) |
              (PApplet.round(r1 + (r2-r1)*amt) << 16) |
              (PApplet.round(g1 + (g2-g1)*amt) << 8) |
              (PApplet.round(b1 + (b2-b1)*amt)));

    } else if (mode == HSB) {
      if (lerpColorHSB1 == null) {
        lerpColorHSB1 = new float[3];
        lerpColorHSB2 = new float[3];
      }

      float a1 = (c1 >> 24) & 0xff;
      float a2 = (c2 >> 24) & 0xff;
      int alfa = (PApplet.round(a1 + (a2-a1)*amt)) << 24;

      Color.RGBtoHSB((c1 >> 16) & 0xff, (c1 >> 8) & 0xff, c1 & 0xff,
                     lerpColorHSB1);
      Color.RGBtoHSB((c2 >> 16) & 0xff, (c2 >> 8) & 0xff, c2 & 0xff,
                     lerpColorHSB2);









      float ho = PApplet.lerp(lerpColorHSB1[0], lerpColorHSB2[0], amt);
      float so = PApplet.lerp(lerpColorHSB1[1], lerpColorHSB2[1], amt);
      float bo = PApplet.lerp(lerpColorHSB1[2], lerpColorHSB2[2], amt);

      return alfa | (Color.HSBtoRGB(ho, so, bo) & 0xFFFFFF);
    }
    return 0;
  }








  public void beginRaw(PGraphics rawGraphics) {  
    this.raw = rawGraphics;
    rawGraphics.beginDraw();
  }


  public void endRaw() {  
    if (raw != null) {


      flush();



      raw.endDraw();
      raw.dispose();
      raw = null;
    }
  }


  public boolean haveRaw() { 
    return raw != null;
  }


  public PGraphics getRaw() { 
    return raw;
  }







  static protected HashMap<String, Object> warnings;



  static public void showWarning(String msg) {  
    if (warnings == null) {
      warnings = new HashMap<String, Object>();
    }
    if (!warnings.containsKey(msg)) {
      System.err.println(msg);
      warnings.put(msg, new Object());
    }
  }



  static public void showWarning(String msg, Object... args) {  
    showWarning(String.format(msg, args));
  }



  static public void showDepthWarning(String method) {
    showWarning(method + "() can only be used with a renderer that " +
                "supports 3D, such as P3D.");
  }



  static public void showDepthWarningXYZ(String method) {
    showWarning(method + "() with x, y, and z coordinates " +
                "can only be used with a renderer that " +
                "supports 3D, such as P3D. " +
                "Use a version without a z-coordinate instead.");
  }



  static public void showMethodWarning(String method) {
    showWarning(method + "() is not available with this renderer.");
  }



  static public void showVariationWarning(String str) {
    showWarning(str + " is not available with this renderer.");
  }



  static public void showMissingWarning(String method) {
    showWarning(method + "(), or this particular variation of it, " +
                "is not available with this renderer.");
  }



  static public void showException(String msg) {  
    throw new RuntimeException(msg);
  }



  protected void defaultFontOrDeath(String method) {
    defaultFontOrDeath(method, 12);
  }



  protected void defaultFontOrDeath(String method, float size) {
    if (parent != null) {
      textFont = parent.createDefaultFont(size);
    } else {
      throw new RuntimeException("Use textFont() before " + method + "()");
    }
  }









  public boolean displayable() {  
    return true;
  }



  public boolean is2D() {  
    return true;
  }



  public boolean is3D() {  
    return false;
  }



  public boolean isGL() {  
    return false;
  }


  public boolean is2X() {
    return pixelDensity == 2;
  }
}

<code block>




package processing.core;

import java.awt.Cursor;
import java.awt.event.KeyEvent;



public interface PConstants {

  static public final int X = 0;
  static public final int Y = 1;
  static public final int Z = 2;






  static final String JAVA2D = "processing.core.PGraphicsJava2D";

  static final String P2D = "processing.opengl.PGraphics2D";
  static final String P3D = "processing.opengl.PGraphics3D";


  @Deprecated
  static final String OPENGL = P3D;


  static final String E2D = PGraphicsDanger2D.class.getName();


  static final String FX2D = PGraphicsFX2D.class.getName();

  static final String PDF = "processing.pdf.PGraphicsPDF";
  static final String SVG = "processing.svg.PGraphicsSVG";
  static final String DXF = "processing.dxf.RawDXF";



  static final int OTHER   = 0;
  static final int WINDOWS = 1;
  static final int MACOSX  = 2;
  static final int LINUX   = 3;

  static final String[] platformNames = {
    "other", "windows", "macosx", "linux"
  };


  static final float EPSILON = 0.0001f;





  static final float MAX_FLOAT = Float.MAX_VALUE;

  static final float MIN_FLOAT = -Float.MAX_VALUE;

  static final int MAX_INT = Integer.MAX_VALUE;

  static final int MIN_INT = Integer.MIN_VALUE;



  static public final int VERTEX = 0;
  static public final int BEZIER_VERTEX = 1;
  static public final int QUADRATIC_VERTEX = 2;
  static public final int CURVE_VERTEX = 3;
  static public final int BREAK = 4;

  @Deprecated
  static public final int QUAD_BEZIER_VERTEX = 2;  




  static final float PI = (float) Math.PI;

  static final float HALF_PI = (float) (Math.PI / 2.0);
  static final float THIRD_PI = (float) (Math.PI / 3.0);

  static final float QUARTER_PI = (float) (Math.PI / 4.0);

  static final float TWO_PI = (float) (2.0 * Math.PI);

  static final float TAU = (float) (2.0 * Math.PI);

  static final float DEG_TO_RAD = PI/180.0f;
  static final float RAD_TO_DEG = 180.0f/PI;











  static final String WHITESPACE = " \t\n\r\f\u00A0";




  static final int RGB   = 1;  
  static final int ARGB  = 2;  
  static final int HSB   = 3;  
  static final int ALPHA = 4;  





  static final int TIFF  = 0;
  static final int TARGA = 1;
  static final int JPEG  = 2;
  static final int GIF   = 3;




  static final int BLUR      = 11;
  static final int GRAY      = 12;
  static final int INVERT    = 13;
  static final int OPAQUE    = 14;
  static final int POSTERIZE = 15;
  static final int THRESHOLD = 16;
  static final int ERODE     = 17;
  static final int DILATE    = 18;





  public final static int REPLACE    = 0;
  public final static int BLEND      = 1 << 0;
  public final static int ADD        = 1 << 1;
  public final static int SUBTRACT   = 1 << 2;
  public final static int LIGHTEST   = 1 << 3;
  public final static int DARKEST    = 1 << 4;
  public final static int DIFFERENCE = 1 << 5;
  public final static int EXCLUSION  = 1 << 6;
  public final static int MULTIPLY   = 1 << 7;
  public final static int SCREEN     = 1 << 8;
  public final static int OVERLAY    = 1 << 9;
  public final static int HARD_LIGHT = 1 << 10;
  public final static int SOFT_LIGHT = 1 << 11;
  public final static int DODGE      = 1 << 12;
  public final static int BURN       = 1 << 13;



  static final int CHATTER   = 0;
  static final int COMPLAINT = 1;
  static final int PROBLEM   = 2;




  static final int PROJECTION = 0;
  static final int MODELVIEW  = 1;



  static final int CUSTOM       = 0; 
  static final int ORTHOGRAPHIC = 2; 
  static final int PERSPECTIVE  = 3; 







  static final int GROUP           = 0;   

  static final int POINT           = 2;   
  static final int POINTS          = 3;   

  static final int LINE            = 4;   
  static final int LINES           = 5;   
  static final int LINE_STRIP      = 50;  
  static final int LINE_LOOP       = 51;

  static final int TRIANGLE        = 8;   
  static final int TRIANGLES       = 9;   
  static final int TRIANGLE_STRIP  = 10;  
  static final int TRIANGLE_FAN    = 11;  

  static final int QUAD            = 16;  
  static final int QUADS           = 17;  
  static final int QUAD_STRIP      = 18;  

  static final int POLYGON         = 20;  
  static final int PATH            = 21;  

  static final int RECT            = 30;  
  static final int ELLIPSE         = 31;  
  static final int ARC             = 32;  

  static final int SPHERE          = 40;  
  static final int BOX             = 41;  








  static final int OPEN = 1;
  static final int CLOSE = 2;





  static final int CORNER   = 0;

  static final int CORNERS  = 1;

  static final int RADIUS   = 2;

  static final int CENTER   = 3;

  static final int DIAMETER = 3;





  static final int CHORD  = 2;
  static final int PIE    = 3;





  static final int BASELINE = 0;

  static final int TOP = 101;

  static final int BOTTOM = 102;





  static final int NORMAL     = 1;

  static final int IMAGE      = 2;





  public static final int CLAMP = 0;

  public static final int REPEAT = 1;





  static final int MODEL = 4;


  static final int SHAPE = 5;







  static final int SQUARE   = 1 << 0;  
  static final int ROUND    = 1 << 1;
  static final int PROJECT  = 1 << 2;  
  static final int MITER    = 1 << 3;
  static final int BEVEL    = 1 << 5;




  static final int AMBIENT = 0;
  static final int DIRECTIONAL  = 1;

  static final int SPOT = 3;












  static final char BACKSPACE = 8;
  static final char TAB       = 9;
  static final char ENTER     = 10;
  static final char RETURN    = 13;
  static final char ESC       = 27;
  static final char DELETE    = 127;


  static final int CODED     = 0xffff;


  static final int UP        = KeyEvent.VK_UP;
  static final int DOWN      = KeyEvent.VK_DOWN;
  static final int LEFT      = KeyEvent.VK_LEFT;
  static final int RIGHT     = KeyEvent.VK_RIGHT;


  static final int ALT       = KeyEvent.VK_ALT;
  static final int CONTROL   = KeyEvent.VK_CONTROL;
  static final int SHIFT     = KeyEvent.VK_SHIFT;





  static final int PORTRAIT = 1;

  static final int LANDSCAPE = 2;


  static final int SPAN = 0;



  static final int ARROW = Cursor.DEFAULT_CURSOR;
  static final int CROSS = Cursor.CROSSHAIR_CURSOR;
  static final int HAND  = Cursor.HAND_CURSOR;
  static final int MOVE  = Cursor.MOVE_CURSOR;
  static final int TEXT  = Cursor.TEXT_CURSOR;
  static final int WAIT  = Cursor.WAIT_CURSOR;





  @Deprecated
  static final int ENABLE_NATIVE_FONTS        =  1;
  @Deprecated
  static final int DISABLE_NATIVE_FONTS       = -1;

  static final int DISABLE_DEPTH_TEST         =  2;
  static final int ENABLE_DEPTH_TEST          = -2;

  static final int ENABLE_DEPTH_SORT          =  3;
  static final int DISABLE_DEPTH_SORT         = -3;

  static final int DISABLE_OPENGL_ERRORS      =  4;
  static final int ENABLE_OPENGL_ERRORS       = -4;

  static final int DISABLE_DEPTH_MASK         =  5;
  static final int ENABLE_DEPTH_MASK          = -5;

  static final int DISABLE_OPTIMIZED_STROKE   =  6;
  static final int ENABLE_OPTIMIZED_STROKE    = -6;

  static final int ENABLE_STROKE_PERSPECTIVE  =  7;
  static final int DISABLE_STROKE_PERSPECTIVE = -7;

  static final int DISABLE_TEXTURE_MIPMAPS    =  8;
  static final int ENABLE_TEXTURE_MIPMAPS     = -8;

  static final int ENABLE_STROKE_PURE         =  9;
  static final int DISABLE_STROKE_PURE        = -9;

  static final int HINT_COUNT                 = 10;
}

<code block>




package processing.core;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Frame;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.font.FontRenderContext;
import java.util.HashMap;
import java.util.WeakHashMap;

import processing.opengl.PGL;
import processing.opengl.PShader;


public class PGraphics extends PImage implements PConstants {
















  public int pixelCount;





  public int smooth;





  protected boolean settingsInited;


  protected boolean reapplySettings;


  protected PGraphics raw;




  protected String path;


  protected boolean primaryGraphics;








  protected boolean[] hints = new boolean[HINT_COUNT];




  protected WeakHashMap<PImage, Object> cacheMap =
    new WeakHashMap<PImage, Object>();










  static public final int R = 3;  
  static public final int G = 4;  
  static public final int B = 5;  
  static public final int A = 6;

  static public final int U = 7; 
  static public final int V = 8;

  static public final int NX = 9; 
  static public final int NY = 10;
  static public final int NZ = 11;

  static public final int EDGE = 12;




  static public final int SR = 13;
  static public final int SG = 14;
  static public final int SB = 15;
  static public final int SA = 16;


  static public final int SW = 17;



  static public final int TX = 18; 
  static public final int TY = 19;
  static public final int TZ = 20;

  static public final int VX = 21; 
  static public final int VY = 22;
  static public final int VZ = 23;
  static public final int VW = 24;






  static public final int AR = 25;
  static public final int AG = 26;
  static public final int AB = 27;


  static public final int DR = 3;  
  static public final int DG = 4;
  static public final int DB = 5;
  static public final int DA = 6;


  static public final int SPR = 28;
  static public final int SPG = 29;
  static public final int SPB = 30;

  static public final int SHINE = 31;


  static public final int ER = 32;
  static public final int EG = 33;
  static public final int EB = 34;


  static public final int BEEN_LIT = 35;


  static public final int HAS_NORMAL = 36;

  static public final int VERTEX_FIELD_COUNT = 37;









  public int colorMode; 


  public float colorModeX; 


  public float colorModeY; 


  public float colorModeZ; 


  public float colorModeA; 


  boolean colorModeScale; 


  boolean colorModeDefault; 






  public boolean tint;


  public int tintColor;

  protected boolean tintAlpha;
  protected float tintR, tintG, tintB, tintA;
  protected int tintRi, tintGi, tintBi, tintAi;






  public boolean fill;


  public int fillColor = 0xffFFFFFF;

  protected boolean fillAlpha;
  protected float fillR, fillG, fillB, fillA;
  protected int fillRi, fillGi, fillBi, fillAi;






  public boolean stroke;


  public int strokeColor = 0xff000000;

  protected boolean strokeAlpha;
  protected float strokeR, strokeG, strokeB, strokeA;
  protected int strokeRi, strokeGi, strokeBi, strokeAi;





  static protected final float DEFAULT_STROKE_WEIGHT = 1;
  static protected final int DEFAULT_STROKE_JOIN = MITER;
  static protected final int DEFAULT_STROKE_CAP = ROUND;


  public float strokeWeight = DEFAULT_STROKE_WEIGHT;


  public int strokeJoin = DEFAULT_STROKE_JOIN;


  public int strokeCap = DEFAULT_STROKE_CAP;








  public int rectMode;


  public int ellipseMode;


  public int shapeMode;


  public int imageMode = CORNER;






  public PFont textFont;


  public int textAlign = LEFT;


  public int textAlignY = BASELINE;


  public int textMode = MODEL;


  public float textSize;


  public float textLeading;

  static final protected String ERROR_TEXTFONT_NULL_PFONT =
    "A null PFont was passed to textFont()";









  public int ambientColor;
  public float ambientR, ambientG, ambientB;
  public boolean setAmbient;

  public int specularColor;
  public float specularR, specularG, specularB;

  public int emissiveColor;
  public float emissiveR, emissiveG, emissiveB;

  public float shininess;




  static final int STYLE_STACK_DEPTH = 64;
  PStyle[] styleStack = new PStyle[STYLE_STACK_DEPTH];
  int styleStackDepth;






  public int backgroundColor = 0xffCCCCCC;

  protected boolean backgroundAlpha;
  protected float backgroundR, backgroundG, backgroundB, backgroundA;
  protected int backgroundRi, backgroundGi, backgroundBi, backgroundAi;

  static final protected String ERROR_BACKGROUND_IMAGE_SIZE =
    "background image must be the same size as your application";
  static final protected String ERROR_BACKGROUND_IMAGE_FORMAT =
    "background images should be RGB or ARGB";



  protected int blendMode;
















  static final int MATRIX_STACK_DEPTH = 32;

  static final protected String ERROR_PUSHMATRIX_OVERFLOW =
    "Too many calls to pushMatrix().";
  static final protected String ERROR_PUSHMATRIX_UNDERFLOW =
    "Too many calls to popMatrix(), and not enough to pushMatrix().";





  public Image image;


  protected PSurface surface;




  protected float calcR, calcG, calcB, calcA;
  protected int calcRi, calcGi, calcBi, calcAi;
  protected int calcColor;
  protected boolean calcAlpha;


  int cacheHsbKey;

  float[] cacheHsbValue = new float[3];




  protected int shape;


  public static final int DEFAULT_VERTICES = 512;
  protected float vertices[][] =
    new float[DEFAULT_VERTICES][VERTEX_FIELD_COUNT];
  protected int vertexCount; 



  protected boolean bezierInited = false;
  public int bezierDetail = 20;


  protected PMatrix3D bezierBasisMatrix =
    new PMatrix3D(-1,  3, -3,  1,
                   3, -6,  3,  0,
                  -3,  3,  0,  0,
                   1,  0,  0,  0);


  protected PMatrix3D bezierDrawMatrix;



  protected boolean curveInited = false;
  public int curveDetail = 20;
  public float curveTightness = 0;

  protected PMatrix3D curveBasisMatrix;
  protected PMatrix3D curveDrawMatrix;

  protected PMatrix3D bezierBasisInverse;
  protected PMatrix3D curveToBezierMatrix;





  protected float curveVertices[][];
  protected int curveVertexCount;











  static final protected float sinLUT[];
  static final protected float cosLUT[];
  static final protected float SINCOS_PRECISION = 0.5f;
  static final protected int SINCOS_LENGTH = (int) (360f / SINCOS_PRECISION);
  static {
    sinLUT = new float[SINCOS_LENGTH];
    cosLUT = new float[SINCOS_LENGTH];
    for (int i = 0; i < SINCOS_LENGTH; i++) {
      sinLUT[i] = (float) Math.sin(i * DEG_TO_RAD * SINCOS_PRECISION);
      cosLUT[i] = (float) Math.cos(i * DEG_TO_RAD * SINCOS_PRECISION);
    }
  }













  protected char[] textBuffer = new char[8 * 1024];
  protected char[] textWidthBuffer = new char[8 * 1024];

  protected int textBreakCount;
  protected int[] textBreakStart;
  protected int[] textBreakStop;



  public boolean edge = true;




  static protected final int NORMAL_MODE_AUTO = 0;

  static protected final int NORMAL_MODE_SHAPE = 1;

  static protected final int NORMAL_MODE_VERTEX = 2;


  protected int normalMode;




  protected boolean autoNormal;


  public float normalX, normalY, normalZ;




  public int textureMode = IMAGE;


  public float textureU;


  public float textureV;


  public PImage textureImage;





  protected float sphereX[], sphereY[], sphereZ[];


  public int sphereDetailU = 0;

  public int sphereDetailV = 0;












  public PGraphics() {

  }


  public void setParent(PApplet parent) {  
    this.parent = parent;



    smooth = parent.sketchSmooth();
    pixelDensity = parent.sketchPixelDensity();
  }



  public void setPrimary(boolean primary) {  
    this.primaryGraphics = primary;




    if (primaryGraphics) {
      format = RGB;
    }
  }


  public void setPath(String path) {  
    this.path = path;
  }








  public void setSize(int w, int h) {  
    width = w;
    height = h;


    pixelWidth = width * pixelDensity;
    pixelHeight = height * pixelDensity;





    reapplySettings = true;
  }














  public void dispose() {  
  }


  public PSurface createSurface() {  
    return surface = new PSurfaceAWT(this);
  }








  public void setCache(PImage image, Object storage) {  
    cacheMap.put(image, storage);
  }



  public Object getCache(PImage image) {  
    return cacheMap.get(image);
  }



  public void removeCache(PImage image) {  
    cacheMap.remove(image);
  }









  public boolean canDraw() {  
    return true;
  }













  public void beginDraw() {  
  }



  public void endDraw() {  
  }


  public PGL beginPGL() {
    showMethodWarning("beginGL");
    return null;
  }


  public void endPGL() {
    showMethodWarning("endGL");
  }


  public void flush() {

  }


  protected void checkSettings() {
    if (!settingsInited) defaultSettings();
    if (reapplySettings) reapplySettings();
  }



  protected void defaultSettings() {  









    colorMode(RGB, 255);
    fill(255);
    stroke(0);



    strokeWeight(DEFAULT_STROKE_WEIGHT);
    strokeJoin(DEFAULT_STROKE_JOIN);
    strokeCap(DEFAULT_STROKE_CAP);


    shape = 0;

    rectMode(CORNER);
    ellipseMode(DIAMETER);

    autoNormal = true;


    textFont = null;
    textSize = 12;
    textLeading = 14;
    textAlign = LEFT;
    textMode = MODEL;







    if (primaryGraphics) {

      background(backgroundColor);
    }

    blendMode(BLEND);

    settingsInited = true;

    reapplySettings = false;
  }



  protected void reapplySettings() {



    if (!settingsInited) return;  

    colorMode(colorMode, colorModeX, colorModeY, colorModeZ);
    if (fill) {

      fill(fillColor);
    } else {
      noFill();
    }
    if (stroke) {
      stroke(strokeColor);




      strokeWeight(strokeWeight);


      strokeCap(strokeCap);


      strokeJoin(strokeJoin);

    } else {
      noStroke();
    }
    if (tint) {
      tint(tintColor);
    } else {
      noTint();
    }






    if (textFont != null) {


      float saveLeading = textLeading;
      textFont(textFont, textSize);
      textLeading(saveLeading);
    }
    textMode(textMode);
    textAlign(textAlign, textAlignY);
    background(backgroundColor);

    blendMode(blendMode);

    reapplySettings = false;
  }









  @SuppressWarnings("deprecation")
  public void hint(int which) {
    if (which == ENABLE_NATIVE_FONTS ||
        which == DISABLE_NATIVE_FONTS) {
      showWarning("hint(ENABLE_NATIVE_FONTS) no longer supported. " +
                  "Use createFont() instead.");
    }
    if (which > 0) {
      hints[which] = true;
    } else {
      hints[-which] = false;
    }
  }







  public void beginShape() {
    beginShape(POLYGON);
  }



  public void beginShape(int kind) {
    shape = kind;
  }



  public void edge(boolean edge) {
   this.edge = edge;
  }



  public void normal(float nx, float ny, float nz) {
    normalX = nx;
    normalY = ny;
    normalZ = nz;



    if (shape != 0) {
      if (normalMode == NORMAL_MODE_AUTO) {

        normalMode = NORMAL_MODE_SHAPE;
      } else if (normalMode == NORMAL_MODE_SHAPE) {

        normalMode = NORMAL_MODE_VERTEX;
      }
    }
  }


  public void attrib(String name, float... values) {
    showMissingWarning("attrib");
  }


  public void attrib(String name, int... values) {
    showMissingWarning("attrib");
  }


  public void attrib(String name, boolean... values) {
    showMissingWarning("attrib");
  }



  public void textureMode(int mode) {
    if (mode != IMAGE && mode != NORMAL) {
      throw new RuntimeException("textureMode() only supports IMAGE and NORMAL");
    }
    this.textureMode = mode;
  }


  public void textureWrap(int wrap) {
    showMissingWarning("textureWrap");
  }



  public void texture(PImage image) {
    textureImage = image;
  }



  public void noTexture() {
    textureImage = null;
  }


  protected void vertexCheck() {
    if (vertexCount == vertices.length) {
      float temp[][] = new float[vertexCount << 1][VERTEX_FIELD_COUNT];
      System.arraycopy(vertices, 0, temp, 0, vertexCount);
      vertices = temp;
    }
  }


  public void vertex(float x, float y) {
    vertexCheck();
    float[] vertex = vertices[vertexCount];

    curveVertexCount = 0;

    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = 0;

    vertex[EDGE] = edge ? 1 : 0;







    boolean textured = textureImage != null;
    if (fill || textured) {
      if (!textured) {
        vertex[R] = fillR;
        vertex[G] = fillG;
        vertex[B] = fillB;
        vertex[A] = fillA;
      } else {
        if (tint) {
          vertex[R] = tintR;
          vertex[G] = tintG;
          vertex[B] = tintB;
          vertex[A] = tintA;
        } else {
          vertex[R] = 1;
          vertex[G] = 1;
          vertex[B] = 1;
          vertex[A] = 1;
        }
      }
    }

    if (stroke) {
      vertex[SR] = strokeR;
      vertex[SG] = strokeG;
      vertex[SB] = strokeB;
      vertex[SA] = strokeA;
      vertex[SW] = strokeWeight;
    }

    if (textured) {
      vertex[U] = textureU;
      vertex[V] = textureV;
    }

    if (autoNormal) {
      float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ;
      if (norm2 < EPSILON) {
        vertex[HAS_NORMAL] = 0;
      } else {
        if (Math.abs(norm2 - 1) > EPSILON) {

          float norm = PApplet.sqrt(norm2);
          normalX /= norm;
          normalY /= norm;
          normalZ /= norm;
        }
        vertex[HAS_NORMAL] = 1;
      }
    } else {
      vertex[HAS_NORMAL] = 1;
    }

    vertexCount++;
  }


  public void vertex(float x, float y, float z) {
    vertexCheck();
    float[] vertex = vertices[vertexCount];





    if (shape == POLYGON) {
      if (vertexCount > 0) {
        float pvertex[] = vertices[vertexCount-1];
        if ((Math.abs(pvertex[X] - x) < EPSILON) &&
            (Math.abs(pvertex[Y] - y) < EPSILON) &&
            (Math.abs(pvertex[Z] - z) < EPSILON)) {


          return;
        }
      }
    }




    curveVertexCount = 0;

    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = z;

    vertex[EDGE] = edge ? 1 : 0;

    boolean textured = textureImage != null;
    if (fill || textured) {
      if (!textured) {
        vertex[R] = fillR;
        vertex[G] = fillG;
        vertex[B] = fillB;
        vertex[A] = fillA;
      } else {
        if (tint) {
          vertex[R] = tintR;
          vertex[G] = tintG;
          vertex[B] = tintB;
          vertex[A] = tintA;
        } else {
          vertex[R] = 1;
          vertex[G] = 1;
          vertex[B] = 1;
          vertex[A] = 1;
        }
      }

      vertex[AR] = ambientR;
      vertex[AG] = ambientG;
      vertex[AB] = ambientB;

      vertex[SPR] = specularR;
      vertex[SPG] = specularG;
      vertex[SPB] = specularB;


      vertex[SHINE] = shininess;

      vertex[ER] = emissiveR;
      vertex[EG] = emissiveG;
      vertex[EB] = emissiveB;
    }

    if (stroke) {
      vertex[SR] = strokeR;
      vertex[SG] = strokeG;
      vertex[SB] = strokeB;
      vertex[SA] = strokeA;
      vertex[SW] = strokeWeight;
    }

    if (textured) {
      vertex[U] = textureU;
      vertex[V] = textureV;
    }

    if (autoNormal) {
      float norm2 = normalX * normalX + normalY * normalY + normalZ * normalZ;
      if (norm2 < EPSILON) {
        vertex[HAS_NORMAL] = 0;
      } else {
        if (Math.abs(norm2 - 1) > EPSILON) {

          float norm = PApplet.sqrt(norm2);
          normalX /= norm;
          normalY /= norm;
          normalZ /= norm;
        }
        vertex[HAS_NORMAL] = 1;
      }
    } else {
      vertex[HAS_NORMAL] = 1;
    }

    vertex[NX] = normalX;
    vertex[NY] = normalY;
    vertex[NZ] = normalZ;

    vertex[BEEN_LIT] = 0;

    vertexCount++;
  }



  public void vertex(float[] v) {
    vertexCheck();
    curveVertexCount = 0;
    float[] vertex = vertices[vertexCount];
    System.arraycopy(v, 0, vertex, 0, VERTEX_FIELD_COUNT);
    vertexCount++;
  }


  public void vertex(float x, float y, float u, float v) {
    vertexTexture(u, v);
    vertex(x, y);
  }


  public void vertex(float x, float y, float z, float u, float v) {
    vertexTexture(u, v);
    vertex(x, y, z);
  }








  protected void vertexTexture(float u, float v) {
    if (textureImage == null) {
      throw new RuntimeException("You must first call texture() before " +
                                 "using u and v coordinates with vertex()");
    }
    if (textureMode == IMAGE) {
      u /= textureImage.width;
      v /= textureImage.height;
    }

    textureU = u;
    textureV = v;

    if (textureU < 0) textureU = 0;
    else if (textureU > 1) textureU = 1;

    if (textureV < 0) textureV = 0;
    else if (textureV > 1) textureV = 1;
  }









  public void beginContour() {
    showMissingWarning("beginContour");
  }



  public void endContour() {
    showMissingWarning("endContour");
  }


  public void endShape() {
    endShape(OPEN);
  }



  public void endShape(int mode) {
  }









  public PShape loadShape(String filename) {
    return loadShape(filename, null);
  }



  public PShape loadShape(String filename, String options) {
    showMissingWarning("loadShape");
    return null;
  }









  public PShape createShape() {


    return createShape(PShape.GEOMETRY);
  }



  public PShape createShape(int type) {

    if (type == PConstants.GROUP ||
        type == PShape.PATH ||
        type == PShape.GEOMETRY) {
      return createShapeFamily(type);
    }
    final String msg =
      "Only GROUP, PShape.PATH, and PShape.GEOMETRY work with createShape()";
    throw new IllegalArgumentException(msg);
  }



  protected PShape createShapeFamily(int type) {
    return new PShape(this, type);


  }



  public PShape createShape(int kind, float... p) {
    int len = p.length;

    if (kind == POINT) {
      if (is3D() && len != 2 && len != 3) {
        throw new IllegalArgumentException("Use createShape(POINT, x, y) or createShape(POINT, x, y, z)");
      } else if (len != 2) {
        throw new IllegalArgumentException("Use createShape(POINT, x, y)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == LINE) {
      if (is3D() && len != 4 && len != 6) {
        throw new IllegalArgumentException("Use createShape(LINE, x1, y1, x2, y2) or createShape(LINE, x1, y1, z1, x2, y2, z1)");
      } else if (len != 4) {
        throw new IllegalArgumentException("Use createShape(LINE, x1, y1, x2, y2)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == TRIANGLE) {
      if (len != 6) {
        throw new IllegalArgumentException("Use createShape(TRIANGLE, x1, y1, x2, y2, x3, y3)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == QUAD) {
      if (len != 8) {
        throw new IllegalArgumentException("Use createShape(QUAD, x1, y1, x2, y2, x3, y3, x4, y4)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == RECT) {
      if (len != 4 && len != 5 && len != 8 && len != 9) {
        throw new IllegalArgumentException("Wrong number of parameters for createShape(RECT), see the reference");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == ELLIPSE) {
      if (len != 4 && len != 5) {
        throw new IllegalArgumentException("Use createShape(ELLIPSE, x, y, w, h) or createShape(ELLIPSE, x, y, w, h, mode)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == ARC) {
      if (len != 6 && len != 7) {
        throw new IllegalArgumentException("Use createShape(ARC, x, y, w, h, start, stop)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == BOX) {
      if (!is3D()) {
        throw new IllegalArgumentException("createShape(BOX) is not supported in 2D");
      } else if (len != 1 && len != 3) {
        throw new IllegalArgumentException("Use createShape(BOX, size) or createShape(BOX, width, height, depth)");
      }
      return createShapePrimitive(kind, p);

    } else if (kind == SPHERE) {
      if (!is3D()) {
        throw new IllegalArgumentException("createShape(SPHERE) is not supported in 2D");
      } else if (len != 1) {
        throw new IllegalArgumentException("Use createShape(SPHERE, radius)");
      }
      return createShapePrimitive(kind, p);
    }
    throw new IllegalArgumentException("Unknown shape type passed to createShape()");
  }



  protected PShape createShapePrimitive(int kind, float... p) {


    return new PShape(this, kind, p);
  }








  public PShader loadShader(String fragFilename) {
    showMissingWarning("loadShader");
    return null;
  }



  public PShader loadShader(String fragFilename, String vertFilename) {
    showMissingWarning("loadShader");
    return null;
  }



  public void shader(PShader shader) {
    showMissingWarning("shader");
  }



  public void shader(PShader shader, int kind) {
    showMissingWarning("shader");
  }



  public void resetShader() {
    showMissingWarning("resetShader");
  }



  public void resetShader(int kind) {
    showMissingWarning("resetShader");
  }



  public void filter(PShader shader) {
    showMissingWarning("filter");
  }








  public void clip(float a, float b, float c, float d) {
    if (imageMode == CORNER) {
      if (c < 0) {  
        a += c; c = -c;
      }
      if (d < 0) {  
        b += d; d = -d;
      }

      clipImpl(a, b, a + c, b + d);

    } else if (imageMode == CORNERS) {
      if (c < a) {  
        float temp = a; a = c; c = temp;
      }
      if (d < b) {  
        float temp = b; b = d; d = temp;
      }

      clipImpl(a, b, c, d);

    } else if (imageMode == CENTER) {

      if (c < 0) c = -c;
      if (d < 0) d = -d;
      float x1 = a - c/2;
      float y1 = b - d/2;

      clipImpl(x1, y1, x1 + c, y1 + d);
    }
  }


  protected void clipImpl(float x1, float y1, float x2, float y2) {
    showMissingWarning("clip");
  }


  public void noClip() {
    showMissingWarning("noClip");
  }








  public void blendMode(int mode) {
    this.blendMode = mode;
    blendModeImpl();
  }


  protected void blendModeImpl() {
    if (blendMode != BLEND) {
      showMissingWarning("blendMode");
    }
  }








  protected void bezierVertexCheck() {
    bezierVertexCheck(shape, vertexCount);
  }


  protected void bezierVertexCheck(int shape, int vertexCount) {
    if (shape == 0 || shape != POLYGON) {
      throw new RuntimeException("beginShape() or beginShape(POLYGON) " +
                                 "must be used before bezierVertex() or quadraticVertex()");
    }
    if (vertexCount == 0) {
      throw new RuntimeException("vertex() must be used at least once " +
                                 "before bezierVertex() or quadraticVertex()");
    }
  }


  public void bezierVertex(float x2, float y2,
                           float x3, float y3,
                           float x4, float y4) {
    bezierInitCheck();
    bezierVertexCheck();
    PMatrix3D draw = bezierDrawMatrix;

    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;

    for (int j = 0; j < bezierDetail; j++) {
      x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      vertex(x1, y1);
    }
  }


  public void bezierVertex(float x2, float y2, float z2,
                           float x3, float y3, float z3,
                           float x4, float y4, float z4) {
    bezierInitCheck();
    bezierVertexCheck();
    PMatrix3D draw = bezierDrawMatrix;

    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];
    float z1 = prev[Z];

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;

    float zplot1 = draw.m10*z1 + draw.m11*z2 + draw.m12*z3 + draw.m13*z4;
    float zplot2 = draw.m20*z1 + draw.m21*z2 + draw.m22*z3 + draw.m23*z4;
    float zplot3 = draw.m30*z1 + draw.m31*z2 + draw.m32*z3 + draw.m33*z4;

    for (int j = 0; j < bezierDetail; j++) {
      x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      z1 += zplot1; zplot1 += zplot2; zplot2 += zplot3;
      vertex(x1, y1, z1);
    }
  }


  public void quadraticVertex(float cx, float cy,
                              float x3, float y3) {
    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];

    bezierVertex(x1 + ((cx-x1)*2/3.0f), y1 + ((cy-y1)*2/3.0f),
                 x3 + ((cx-x3)*2/3.0f), y3 + ((cy-y3)*2/3.0f),
                 x3, y3);
  }


  public void quadraticVertex(float cx, float cy, float cz,
                              float x3, float y3, float z3) {
    float[] prev = vertices[vertexCount-1];
    float x1 = prev[X];
    float y1 = prev[Y];
    float z1 = prev[Z];

    bezierVertex(x1 + ((cx-x1)*2/3.0f), y1 + ((cy-y1)*2/3.0f), z1 + ((cz-z1)*2/3.0f),
                 x3 + ((cx-x3)*2/3.0f), y3 + ((cy-y3)*2/3.0f), z3 + ((cz-z3)*2/3.0f),
                 x3, y3, z3);
  }

  protected void curveVertexCheck() {
    curveVertexCheck(shape);
  }


  protected void curveVertexCheck(int shape) {
    if (shape != POLYGON) {
      throw new RuntimeException("You must use beginShape() or " +
                                 "beginShape(POLYGON) before curveVertex()");
    }

    if (curveVertices == null) {
      curveVertices = new float[128][3];
    }

    if (curveVertexCount == curveVertices.length) {

      float[][] temp = new float[curveVertexCount << 1][3];
      System.arraycopy(curveVertices, 0, temp, 0, curveVertexCount);
      curveVertices = temp;
    }
    curveInitCheck();
  }


  public void curveVertex(float x, float y) {
    curveVertexCheck();
    float[] vertex = curveVertices[curveVertexCount];
    vertex[X] = x;
    vertex[Y] = y;
    curveVertexCount++;


    if (curveVertexCount > 3) {
      curveVertexSegment(curveVertices[curveVertexCount-4][X],
                         curveVertices[curveVertexCount-4][Y],
                         curveVertices[curveVertexCount-3][X],
                         curveVertices[curveVertexCount-3][Y],
                         curveVertices[curveVertexCount-2][X],
                         curveVertices[curveVertexCount-2][Y],
                         curveVertices[curveVertexCount-1][X],
                         curveVertices[curveVertexCount-1][Y]);
    }
  }


  public void curveVertex(float x, float y, float z) {
    curveVertexCheck();
    float[] vertex = curveVertices[curveVertexCount];
    vertex[X] = x;
    vertex[Y] = y;
    vertex[Z] = z;
    curveVertexCount++;


    if (curveVertexCount > 3) {
      curveVertexSegment(curveVertices[curveVertexCount-4][X],
                         curveVertices[curveVertexCount-4][Y],
                         curveVertices[curveVertexCount-4][Z],
                         curveVertices[curveVertexCount-3][X],
                         curveVertices[curveVertexCount-3][Y],
                         curveVertices[curveVertexCount-3][Z],
                         curveVertices[curveVertexCount-2][X],
                         curveVertices[curveVertexCount-2][Y],
                         curveVertices[curveVertexCount-2][Z],
                         curveVertices[curveVertexCount-1][X],
                         curveVertices[curveVertexCount-1][Y],
                         curveVertices[curveVertexCount-1][Z]);
    }
  }



  protected void curveVertexSegment(float x1, float y1,
                                    float x2, float y2,
                                    float x3, float y3,
                                    float x4, float y4) {
    float x0 = x2;
    float y0 = y2;

    PMatrix3D draw = curveDrawMatrix;

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;


    int savedCount = curveVertexCount;

    vertex(x0, y0);
    for (int j = 0; j < curveDetail; j++) {
      x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      vertex(x0, y0);
    }
    curveVertexCount = savedCount;
  }



  protected void curveVertexSegment(float x1, float y1, float z1,
                                    float x2, float y2, float z2,
                                    float x3, float y3, float z3,
                                    float x4, float y4, float z4) {
    float x0 = x2;
    float y0 = y2;
    float z0 = z2;

    PMatrix3D draw = curveDrawMatrix;

    float xplot1 = draw.m10*x1 + draw.m11*x2 + draw.m12*x3 + draw.m13*x4;
    float xplot2 = draw.m20*x1 + draw.m21*x2 + draw.m22*x3 + draw.m23*x4;
    float xplot3 = draw.m30*x1 + draw.m31*x2 + draw.m32*x3 + draw.m33*x4;

    float yplot1 = draw.m10*y1 + draw.m11*y2 + draw.m12*y3 + draw.m13*y4;
    float yplot2 = draw.m20*y1 + draw.m21*y2 + draw.m22*y3 + draw.m23*y4;
    float yplot3 = draw.m30*y1 + draw.m31*y2 + draw.m32*y3 + draw.m33*y4;


    int savedCount = curveVertexCount;

    float zplot1 = draw.m10*z1 + draw.m11*z2 + draw.m12*z3 + draw.m13*z4;
    float zplot2 = draw.m20*z1 + draw.m21*z2 + draw.m22*z3 + draw.m23*z4;
    float zplot3 = draw.m30*z1 + draw.m31*z2 + draw.m32*z3 + draw.m33*z4;

    vertex(x0, y0, z0);
    for (int j = 0; j < curveDetail; j++) {
      x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;
      y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;
      z0 += zplot1; zplot1 += zplot2; zplot2 += zplot3;
      vertex(x0, y0, z0);
    }
    curveVertexCount = savedCount;
  }









  public void point(float x, float y) {
    beginShape(POINTS);
    vertex(x, y);
    endShape();
  }


  public void point(float x, float y, float z) {
    beginShape(POINTS);
    vertex(x, y, z);
    endShape();
  }


  public void line(float x1, float y1, float x2, float y2) {
    beginShape(LINES);
    vertex(x1, y1);
    vertex(x2, y2);
    endShape();
  }


  public void line(float x1, float y1, float z1,
                   float x2, float y2, float z2) {
    beginShape(LINES);
    vertex(x1, y1, z1);
    vertex(x2, y2, z2);
    endShape();
  }


  public void triangle(float x1, float y1, float x2, float y2,
                       float x3, float y3) {
    beginShape(TRIANGLES);
    vertex(x1, y1);
    vertex(x2, y2);
    vertex(x3, y3);
    endShape();
  }



  public void quad(float x1, float y1, float x2, float y2,
                   float x3, float y3, float x4, float y4) {
    beginShape(QUADS);
    vertex(x1, y1);
    vertex(x2, y2);
    vertex(x3, y3);
    vertex(x4, y4);
    endShape();
  }








  public void rectMode(int mode) {
    rectMode = mode;
  }



  public void rect(float a, float b, float c, float d) {
    float hradius, vradius;
    switch (rectMode) {
    case CORNERS:
      break;
    case CORNER:
      c += a; d += b;
      break;
    case RADIUS:
      hradius = c;
      vradius = d;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
      break;
    case CENTER:
      hradius = c / 2.0f;
      vradius = d / 2.0f;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
    }

    if (a > c) {
      float temp = a; a = c; c = temp;
    }

    if (b > d) {
      float temp = b; b = d; d = temp;
    }

    rectImpl(a, b, c, d);
  }


  protected void rectImpl(float x1, float y1, float x2, float y2) {
    quad(x1, y1,  x2, y1,  x2, y2,  x1, y2);
  }


















  public void rect(float a, float b, float c, float d, float r) {
    rect(a, b, c, d, r, r, r, r);
  }


  public void rect(float a, float b, float c, float d,
                   float tl, float tr, float br, float bl) {
    float hradius, vradius;
    switch (rectMode) {
    case CORNERS:
      break;
    case CORNER:
      c += a; d += b;
      break;
    case RADIUS:
      hradius = c;
      vradius = d;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
      break;
    case CENTER:
      hradius = c / 2.0f;
      vradius = d / 2.0f;
      c = a + hradius;
      d = b + vradius;
      a -= hradius;
      b -= vradius;
    }

    if (a > c) {
      float temp = a; a = c; c = temp;
    }

    if (b > d) {
      float temp = b; b = d; d = temp;
    }

    float maxRounding = PApplet.min((c - a) / 2, (d - b) / 2);
    if (tl > maxRounding) tl = maxRounding;
    if (tr > maxRounding) tr = maxRounding;
    if (br > maxRounding) br = maxRounding;
    if (bl > maxRounding) bl = maxRounding;

    rectImpl(a, b, c, d, tl, tr, br, bl);
  }


  protected void rectImpl(float x1, float y1, float x2, float y2,
                          float tl, float tr, float br, float bl) {
    beginShape();

    if (tr != 0) {
      vertex(x2-tr, y1);
      quadraticVertex(x2, y1, x2, y1+tr);
    } else {
      vertex(x2, y1);
    }
    if (br != 0) {
      vertex(x2, y2-br);
      quadraticVertex(x2, y2, x2-br, y2);
    } else {
      vertex(x2, y2);
    }
    if (bl != 0) {
      vertex(x1+bl, y2);
      quadraticVertex(x1, y2, x1, y2-bl);
    } else {
      vertex(x1, y2);
    }
    if (tl != 0) {
      vertex(x1, y1+tl);
      quadraticVertex(x1, y1, x1+tl, y1);
    } else {
      vertex(x1, y1);
    }

    endShape(CLOSE);
  }









  public void ellipseMode(int mode) {
    ellipseMode = mode;
  }



  public void ellipse(float a, float b, float c, float d) {
    float x = a;
    float y = b;
    float w = c;
    float h = d;

    if (ellipseMode == CORNERS) {
      w = c - a;
      h = d - b;

    } else if (ellipseMode == RADIUS) {
      x = a - c;
      y = b - d;
      w = c * 2;
      h = d * 2;

    } else if (ellipseMode == DIAMETER) {
      x = a - c/2f;
      y = b - d/2f;
    }

    if (w < 0) {  
      x += w;
      w = -w;
    }

    if (h < 0) {  
      y += h;
      h = -h;
    }

    ellipseImpl(x, y, w, h);
  }


  protected void ellipseImpl(float x, float y, float w, float h) {
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop) {
    arc(a, b, c, d, start, stop, 0);
  }


  public void arc(float a, float b, float c, float d,
                  float start, float stop, int mode) {
    float x = a;
    float y = b;
    float w = c;
    float h = d;

    if (ellipseMode == CORNERS) {
      w = c - a;
      h = d - b;

    } else if (ellipseMode == RADIUS) {
      x = a - c;
      y = b - d;
      w = c * 2;
      h = d * 2;

    } else if (ellipseMode == CENTER) {
      x = a - c/2f;
      y = b - d/2f;
    }


    if (!Float.isInfinite(start) && !Float.isInfinite(stop)) {

      if (stop > start) {

        while (start < 0) {
          start += TWO_PI;
          stop += TWO_PI;
        }

        if (stop - start > TWO_PI) {

          stop = start + TWO_PI;
        }
        arcImpl(x, y, w, h, start, stop, mode);
      }
    }
  }








  protected void arcImpl(float x, float y, float w, float h,
                         float start, float stop, int mode) {
    showMissingWarning("arc");
  }







  public void box(float size) {
    box(size, size, size);
  }



  public void box(float w, float h, float d) {
    float x1 = -w/2f; float x2 = w/2f;
    float y1 = -h/2f; float y2 = h/2f;
    float z1 = -d/2f; float z2 = d/2f;




    beginShape(QUADS);


    normal(0, 0, 1);
    vertex(x1, y1, z1);
    vertex(x2, y1, z1);
    vertex(x2, y2, z1);
    vertex(x1, y2, z1);


    normal(1, 0, 0);
    vertex(x2, y1, z1);
    vertex(x2, y1, z2);
    vertex(x2, y2, z2);
    vertex(x2, y2, z1);


    normal(0, 0, -1);
    vertex(x2, y1, z2);
    vertex(x1, y1, z2);
    vertex(x1, y2, z2);
    vertex(x2, y2, z2);


    normal(-1, 0, 0);
    vertex(x1, y1, z2);
    vertex(x1, y1, z1);
    vertex(x1, y2, z1);
    vertex(x1, y2, z2);


    normal(0, 1, 0);
    vertex(x1, y1, z2);
    vertex(x2, y1, z2);
    vertex(x2, y1, z1);
    vertex(x1, y1, z1);


    normal(0, -1, 0);
    vertex(x1, y2, z1);
    vertex(x2, y2, z1);
    vertex(x2, y2, z2);
    vertex(x1, y2, z2);

    endShape();
  }








  public void sphereDetail(int res) {
    sphereDetail(res, res);
  }



  public void sphereDetail(int ures, int vres) {
    if (ures < 3) ures = 3; 
    if (vres < 2) vres = 2; 
    if ((ures == sphereDetailU) && (vres == sphereDetailV)) return;

    float delta = (float)SINCOS_LENGTH/ures;
    float[] cx = new float[ures];
    float[] cz = new float[ures];

    for (int i = 0; i < ures; i++) {
      cx[i] = cosLUT[(int) (i*delta) % SINCOS_LENGTH];
      cz[i] = sinLUT[(int) (i*delta) % SINCOS_LENGTH];
    }


    int vertCount = ures * (vres-1) + 2;
    int currVert = 0;


    sphereX = new float[vertCount];
    sphereY = new float[vertCount];
    sphereZ = new float[vertCount];

    float angle_step = (SINCOS_LENGTH*0.5f)/vres;
    float angle = angle_step;


    for (int i = 1; i < vres; i++) {
      float curradius = sinLUT[(int) angle % SINCOS_LENGTH];
      float currY = cosLUT[(int) angle % SINCOS_LENGTH];
      for (int j = 0; j < ures; j++) {
        sphereX[currVert] = cx[j] * curradius;
        sphereY[currVert] = currY;
        sphereZ[currVert++] = cz[j] * curradius;
      }
      angle += angle_step;
    }
    sphereDetailU = ures;
    sphereDetailV = vres;
  }



  public void sphere(float r) {
    if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
      sphereDetail(30);
    }

    edge(false);



    beginShape(TRIANGLE_STRIP);
    for (int i = 0; i < sphereDetailU; i++) {
      normal(0, -1, 0);
      vertex(0, -r, 0);
      normal(sphereX[i], sphereY[i], sphereZ[i]);
      vertex(r * sphereX[i], r * sphereY[i], r * sphereZ[i]);
    }
    normal(0, -r, 0);
    vertex(0, -r, 0);
    normal(sphereX[0], sphereY[0], sphereZ[0]);
    vertex(r * sphereX[0], r * sphereY[0], r * sphereZ[0]);
    endShape();

    int v1,v11,v2;


    int voff = 0;
    for (int i = 2; i < sphereDetailV; i++) {
      v1 = v11 = voff;
      voff += sphereDetailU;
      v2 = voff;
      beginShape(TRIANGLE_STRIP);
      for (int j = 0; j < sphereDetailU; j++) {
        normal(sphereX[v1], sphereY[v1], sphereZ[v1]);
        vertex(r * sphereX[v1], r * sphereY[v1], r * sphereZ[v1++]);
        normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
        vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2++]);
      }

      v1 = v11;
      v2 = voff;
      normal(sphereX[v1], sphereY[v1], sphereZ[v1]);
      vertex(r * sphereX[v1], r * sphereY[v1], r * sphereZ[v1]);
      normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
      vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2]);
      endShape();
    }


    beginShape(TRIANGLE_STRIP);
    for (int i = 0; i < sphereDetailU; i++) {
      v2 = voff + i;
      normal(sphereX[v2], sphereY[v2], sphereZ[v2]);
      vertex(r * sphereX[v2], r * sphereY[v2], r * sphereZ[v2]);
      normal(0, 1, 0);
      vertex(0, r, 0);
    }
    normal(sphereX[voff], sphereY[voff], sphereZ[voff]);
    vertex(r * sphereX[voff], r * sphereY[voff], r * sphereZ[voff]);
    normal(0, 1, 0);
    vertex(0, r, 0);
    endShape();

    edge(true);
  }








  public float bezierPoint(float a, float b, float c, float d, float t) {
    float t1 = 1.0f - t;
    return a*t1*t1*t1 + 3*b*t*t1*t1 + 3*c*t*t*t1 + d*t*t*t;
  }



  public float bezierTangent(float a, float b, float c, float d, float t) {
    return (3*t*t * (-a+3*b-3*c+d) +
            6*t * (a-2*b+c) +
            3 * (-a+b));
  }


  protected void bezierInitCheck() {
    if (!bezierInited) {
      bezierInit();
    }
  }


  protected void bezierInit() {

    bezierDetail(bezierDetail);
    bezierInited = true;
  }



  public void bezierDetail(int detail) {
    bezierDetail = detail;

    if (bezierDrawMatrix == null) {
      bezierDrawMatrix = new PMatrix3D();
    }


    splineForward(detail, bezierDrawMatrix);





    bezierDrawMatrix.apply(bezierBasisMatrix);
  }



  public void bezier(float x1, float y1,
                     float x2, float y2,
                     float x3, float y3,
                     float x4, float y4) {
    beginShape();
    vertex(x1, y1);
    bezierVertex(x2, y2, x3, y3, x4, y4);
    endShape();
  }


  public void bezier(float x1, float y1, float z1,
                     float x2, float y2, float z2,
                     float x3, float y3, float z3,
                     float x4, float y4, float z4) {
    beginShape();
    vertex(x1, y1, z1);
    bezierVertex(x2, y2, z2,
                 x3, y3, z3,
                 x4, y4, z4);
    endShape();
  }








  public float curvePoint(float a, float b, float c, float d, float t) {
    curveInitCheck();

    float tt = t * t;
    float ttt = t * tt;
    PMatrix3D cb = curveBasisMatrix;


    return (a * (ttt*cb.m00 + tt*cb.m10 + t*cb.m20 + cb.m30) +
            b * (ttt*cb.m01 + tt*cb.m11 + t*cb.m21 + cb.m31) +
            c * (ttt*cb.m02 + tt*cb.m12 + t*cb.m22 + cb.m32) +
            d * (ttt*cb.m03 + tt*cb.m13 + t*cb.m23 + cb.m33));
  }



  public float curveTangent(float a, float b, float c, float d, float t) {
    curveInitCheck();

    float tt3 = t * t * 3;
    float t2 = t * 2;
    PMatrix3D cb = curveBasisMatrix;


    return (a * (tt3*cb.m00 + t2*cb.m10 + cb.m20) +
            b * (tt3*cb.m01 + t2*cb.m11 + cb.m21) +
            c * (tt3*cb.m02 + t2*cb.m12 + cb.m22) +
            d * (tt3*cb.m03 + t2*cb.m13 + cb.m23) );
  }



  public void curveDetail(int detail) {
    curveDetail = detail;
    curveInit();
  }



  public void curveTightness(float tightness) {
    curveTightness = tightness;
    curveInit();
  }


  protected void curveInitCheck() {
    if (!curveInited) {
      curveInit();
    }
  }



  protected void curveInit() {

    if (curveDrawMatrix == null) {
      curveBasisMatrix = new PMatrix3D();
      curveDrawMatrix = new PMatrix3D();
      curveInited = true;
    }

    float s = curveTightness;
    curveBasisMatrix.set((s-1)/2f, (s+3)/2f,  (-3-s)/2f, (1-s)/2f,
                         (1-s),    (-5-s)/2f, (s+2),     (s-1)/2f,
                         (s-1)/2f, 0,         (1-s)/2f,  0,
                         0,        1,         0,         0);


    splineForward(curveDetail, curveDrawMatrix);

    if (bezierBasisInverse == null) {
      bezierBasisInverse = bezierBasisMatrix.get();
      bezierBasisInverse.invert();
      curveToBezierMatrix = new PMatrix3D();
    }




    curveToBezierMatrix.set(curveBasisMatrix);
    curveToBezierMatrix.preApply(bezierBasisInverse);



    curveDrawMatrix.apply(curveBasisMatrix);
  }



  public void curve(float x1, float y1,
                    float x2, float y2,
                    float x3, float y3,
                    float x4, float y4) {
    beginShape();
    curveVertex(x1, y1);
    curveVertex(x2, y2);
    curveVertex(x3, y3);
    curveVertex(x4, y4);
    endShape();
  }


  public void curve(float x1, float y1, float z1,
                    float x2, float y2, float z2,
                    float x3, float y3, float z3,
                    float x4, float y4, float z4) {
    beginShape();
    curveVertex(x1, y1, z1);
    curveVertex(x2, y2, z2);
    curveVertex(x3, y3, z3);
    curveVertex(x4, y4, z4);
    endShape();
  }









  protected void splineForward(int segments, PMatrix3D matrix) {
    float f  = 1.0f / segments;
    float ff = f * f;
    float fff = ff * f;

    matrix.set(0,     0,    0, 1,
               fff,   ff,   f, 0,
               6*fff, 2*ff, 0, 0,
               6*fff, 0,    0, 0);
  }








  public void smooth() {  
    smooth(1);
  }


  public void smooth(int quality) {  
    if (primaryGraphics) {
      parent.smooth(quality);
    } else {

      if (settingsInited) {

        if (this.smooth != quality) {
          smoothWarning("smooth");
        }
      } else {
        this.smooth = quality;
      }
    }
  }


  public void noSmooth() {  
    smooth(0);
  }


  private void smoothWarning(String method) {
    PGraphics.showWarning("%s() can only be used before beginDraw()", method);
  }









  public void imageMode(int mode) {
    if ((mode == CORNER) || (mode == CORNERS) || (mode == CENTER)) {
      imageMode = mode;
    } else {
      String msg =
        "imageMode() only works with CORNER, CORNERS, or CENTER";
      throw new RuntimeException(msg);
    }
  }



  public void image(PImage img, float a, float b) {


    if (img.width == -1 || img.height == -1) return;

    if (imageMode == CORNER || imageMode == CORNERS) {
      imageImpl(img,
                a, b, a+img.width, b+img.height,
                0, 0, img.width, img.height);

    } else if (imageMode == CENTER) {
      float x1 = a - img.width/2;
      float y1 = b - img.height/2;
      imageImpl(img,
                x1, y1, x1+img.width, y1+img.height,
                0, 0, img.width, img.height);
    }
  }


  public void image(PImage img, float a, float b, float c, float d) {
    image(img, a, b, c, d, 0, 0, img.width, img.height);
  }



  public void image(PImage img,
                    float a, float b, float c, float d,
                    int u1, int v1, int u2, int v2) {


    if (img.width == -1 || img.height == -1) return;

    if (imageMode == CORNER) {
      if (c < 0) {  
        a += c; c = -c;
      }
      if (d < 0) {  
        b += d; d = -d;
      }

      imageImpl(img,
                a, b, a + c, b + d,
                u1, v1, u2, v2);

    } else if (imageMode == CORNERS) {
      if (c < a) {  
        float temp = a; a = c; c = temp;
      }
      if (d < b) {  
        float temp = b; b = d; d = temp;
      }

      imageImpl(img,
                a, b, c, d,
                u1, v1, u2, v2);

    } else if (imageMode == CENTER) {

      if (c < 0) c = -c;
      if (d < 0) d = -d;
      float x1 = a - c/2;
      float y1 = b - d/2;

      imageImpl(img,
                x1, y1, x1 + c, y1 + d,
                u1, v1, u2, v2);
    }
  }



  protected void imageImpl(PImage img,
                           float x1, float y1, float x2, float y2,
                           int u1, int v1, int u2, int v2) {
    boolean savedStroke = stroke;

    int savedTextureMode = textureMode;

    stroke = false;

    textureMode = IMAGE;



















    beginShape(QUADS);
    texture(img);
    vertex(x1, y1, u1, v1);
    vertex(x1, y2, u1, v2);
    vertex(x2, y2, u2, v2);
    vertex(x2, y1, u2, v1);
    endShape();

    stroke = savedStroke;

    textureMode = savedTextureMode;





  }








  public void shapeMode(int mode) {
    this.shapeMode = mode;
  }


  public void shape(PShape shape) {
    if (shape.isVisible()) {  


      flush();

      if (shapeMode == CENTER) {
        pushMatrix();
        translate(-shape.getWidth()/2, -shape.getHeight()/2);
      }

      shape.draw(this); 

      if (shapeMode == CENTER) {
        popMatrix();
      }
    }
  }




  public void shape(PShape shape, float x, float y) {
    if (shape.isVisible()) {  
      flush();

      pushMatrix();

      if (shapeMode == CENTER) {
        translate(x - shape.getWidth()/2, y - shape.getHeight()/2);

      } else if ((shapeMode == CORNER) || (shapeMode == CORNERS)) {
        translate(x, y);
      }
      shape.draw(this);

      popMatrix();
    }
  }



  protected void shape(PShape shape, float x, float y, float z) {
    showMissingWarning("shape");
  }



  public void shape(PShape shape, float a, float b, float c, float d) {
    if (shape.isVisible()) {  
      flush();

      pushMatrix();

      if (shapeMode == CENTER) {

        translate(a - c/2f, b - d/2f);
        scale(c / shape.getWidth(), d / shape.getHeight());

      } else if (shapeMode == CORNER) {
        translate(a, b);
        scale(c / shape.getWidth(), d / shape.getHeight());

      } else if (shapeMode == CORNERS) {

        c -= a;
        d -= b;

        translate(a, b);
        scale(c / shape.getWidth(), d / shape.getHeight());
      }
      shape.draw(this);

      popMatrix();
    }
  }



  protected void shape(PShape shape, float x, float y, float z, float c, float d, float e) {
    showMissingWarning("shape");
  }







  public void textAlign(int alignX) {
    textAlign(alignX, BASELINE);
  }



  public void textAlign(int alignX, int alignY) {
    textAlign = alignX;
    textAlignY = alignY;
  }



  public float textAscent() {
    if (textFont == null) {
      defaultFontOrDeath("textAscent");
    }
    return textFont.ascent() * textSize;
  }



  public float textDescent() {
    if (textFont == null) {
      defaultFontOrDeath("textDescent");
    }
    return textFont.descent() * textSize;
  }



  public void textFont(PFont which) {
    if (which != null) {
      textFont = which;






      textSize(which.getDefaultSize());

    } else {
      throw new RuntimeException(ERROR_TEXTFONT_NULL_PFONT);
    }
  }



  public void textFont(PFont which, float size) {
    textFont(which);
    textSize(size);
  }



  public void textLeading(float leading) {
    textLeading = leading;
  }



  public void textMode(int mode) {

    if ((mode == LEFT) || (mode == RIGHT)) {
      showWarning("Since Processing 1.0 beta, textMode() is now textAlign().");
      return;
    }
    if (mode == SCREEN) {
      showWarning("textMode(SCREEN) has been removed from Processing 2.0.");
      return;
    }

    if (textModeCheck(mode)) {
      textMode = mode;
    } else {
      String modeStr = String.valueOf(mode);
      switch (mode) {
        case MODEL: modeStr = "MODEL"; break;
        case SHAPE: modeStr = "SHAPE"; break;
      }
      showWarning("textMode(" + modeStr + ") is not supported by this renderer.");
    }
  }


  protected boolean textModeCheck(int mode) {
    return true;
  }



  public void textSize(float size) {

    if (size <= 0) {



      System.err.println("textSize(" + size + ") ignored: " +
                         "the text size must be larger than zero");
      return;
    }
    if (textFont == null) {
      defaultFontOrDeath("textSize", size);
    }
    textSize = size;
    textLeading = (textAscent() + textDescent()) * 1.275f;
  }






  public float textWidth(char c) {
    textWidthBuffer[0] = c;
    return textWidthImpl(textWidthBuffer, 0, 1);
  }



  public float textWidth(String str) {
    if (textFont == null) {
      defaultFontOrDeath("textWidth");
    }

    int length = str.length();
    if (length > textWidthBuffer.length) {
      textWidthBuffer = new char[length + 10];
    }
    str.getChars(0, length, textWidthBuffer, 0);

    float wide = 0;
    int index = 0;
    int start = 0;

    while (index < length) {
      if (textWidthBuffer[index] == '\n') {
        wide = Math.max(wide, textWidthImpl(textWidthBuffer, start, index));
        start = index+1;
      }
      index++;
    }
    if (start < length) {
      wide = Math.max(wide, textWidthImpl(textWidthBuffer, start, index));
    }
    return wide;
  }



  public float textWidth(char[] chars, int start, int length) {
    return textWidthImpl(chars, start, start + length);
  }



  protected float textWidthImpl(char buffer[], int start, int stop) {
    float wide = 0;
    for (int i = start; i < stop; i++) {

      wide += textFont.width(buffer[i]) * textSize;
    }
    return wide;
  }






  public void text(char c, float x, float y) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    if (textAlignY == CENTER) {
      y += textAscent() / 2;
    } else if (textAlignY == TOP) {
      y += textAscent();
    } else if (textAlignY == BOTTOM) {
      y -= textDescent();


    }

    textBuffer[0] = c;
    textLineAlignImpl(textBuffer, 0, 1, x, y);
  }



  public void text(char c, float x, float y, float z) {





    if (z != 0) translate(0, 0, z);  

    text(c, x, y);


    if (z != 0) translate(0, 0, -z);
  }









  public void text(String str, float x, float y) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    int length = str.length();
    if (length > textBuffer.length) {
      textBuffer = new char[length + 10];
    }
    str.getChars(0, length, textBuffer, 0);
    text(textBuffer, 0, length, x, y);
  }



  public void text(char[] chars, int start, int stop, float x, float y) {

    float high = 0; 
    for (int i = start; i < stop; i++) {
      if (chars[i] == '\n') {
        high += textLeading;
      }
    }
    if (textAlignY == CENTER) {



      y += (textAscent() - high)/2;
    } else if (textAlignY == TOP) {


      y += textAscent();
    } else if (textAlignY == BOTTOM) {


      y -= textDescent() + high;


    }


    int index = 0;
    while (index < stop) { 
      if (chars[index] == '\n') {
        textLineAlignImpl(chars, start, index, x, y);
        start = index + 1;
        y += textLeading;
      }
      index++;
    }
    if (start < stop) {  
      textLineAlignImpl(chars, start, index, x, y);
    }
  }



  public void text(String str, float x, float y, float z) {
    if (z != 0) translate(0, 0, z);  

    text(str, x, y);


    if (z != 0) translate(0, 0, -z);  
  }


  public void text(char[] chars, int start, int stop,
                   float x, float y, float z) {
    if (z != 0) translate(0, 0, z);  

    text(chars, start, stop, x, y);


    if (z != 0) translate(0, 0, -z);  
  }



  public void text(String str, float x1, float y1, float x2, float y2) {
    if (textFont == null) {
      defaultFontOrDeath("text");
    }

    float hradius, vradius;
    switch (rectMode) {
    case CORNER:
      x2 += x1; y2 += y1;
      break;
    case RADIUS:
      hradius = x2;
      vradius = y2;
      x2 = x1 + hradius;
      y2 = y1 + vradius;
      x1 -= hradius;
      y1 -= vradius;
      break;
    case CENTER:
      hradius = x2 / 2.0f;
      vradius = y2 / 2.0f;
      x2 = x1 + hradius;
      y2 = y1 + vradius;
      x1 -= hradius;
      y1 -= vradius;
    }
    if (x2 < x1) {
      float temp = x1; x1 = x2; x2 = temp;
    }
    if (y2 < y1) {
      float temp = y1; y1 = y2; y2 = temp;
    }


    float boxWidth = x2 - x1;






    float spaceWidth = textWidth(' ');

    if (textBreakStart == null) {
      textBreakStart = new int[20];
      textBreakStop = new int[20];
    }
    textBreakCount = 0;

    int length = str.length();
    if (length + 1 > textBuffer.length) {
      textBuffer = new char[length + 1];
    }
    str.getChars(0, length, textBuffer, 0);

    textBuffer[length++] = '\n';

    int sentenceStart = 0;
    for (int i = 0; i < length; i++) {
      if (textBuffer[i] == '\n') {


        boolean legit =
          textSentence(textBuffer, sentenceStart, i, boxWidth, spaceWidth);
        if (!legit) break;


        sentenceStart = i + 1;
      }
    }



    float lineX = x1; 
    if (textAlign == CENTER) {
      lineX = lineX + boxWidth/2f;
    } else if (textAlign == RIGHT) {
      lineX = x2; 
    }

    float boxHeight = y2 - y1;




    float topAndBottom = textAscent() + textDescent();
    int lineFitCount = 1 + PApplet.floor((boxHeight - topAndBottom) / textLeading);
    int lineCount = Math.min(textBreakCount, lineFitCount);

    if (textAlignY == CENTER) {
      float lineHigh = textAscent() + textLeading * (lineCount - 1);
      float y = y1 + textAscent() + (boxHeight - lineHigh) / 2;
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }

    } else if (textAlignY == BOTTOM) {
      float y = y2 - textDescent() - textLeading * (lineCount - 1);
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }

    } else {  
      float y = y1 + textAscent();
      for (int i = 0; i < lineCount; i++) {
        textLineAlignImpl(textBuffer, textBreakStart[i], textBreakStop[i], lineX, y);
        y += textLeading;
      }
    }
  }



  protected boolean textSentence(char[] buffer, int start, int stop,
                                 float boxWidth, float spaceWidth) {
    float runningX = 0;



    int lineStart = start;
    int wordStart = start;
    int index = start;
    while (index <= stop) {

      if ((buffer[index] == ' ') || (index == stop)) {
        float wordWidth = textWidthImpl(buffer, wordStart, index);

        if (runningX + wordWidth >= boxWidth) {
          if (runningX != 0) {

            index = wordStart;
            textSentenceBreak(lineStart, index);

            while ((index < stop) && (buffer[index] == ' ')) {
              index++;
            }
          } else {  



            do {
              index--;
              if (index == wordStart) {


                return false; 
              }
              wordWidth = textWidthImpl(buffer, wordStart, index);
            } while (wordWidth > boxWidth);


            textSentenceBreak(lineStart, index);
          }
          lineStart = index;
          wordStart = index;
          runningX = 0;

        } else if (index == stop) {


          textSentenceBreak(lineStart, index);

          index++;

        } else {  
          runningX += wordWidth;
          wordStart = index ;  
          index++;
        }
      } else {  
        index++;  
      }
    }

    return true;
  }


  protected void textSentenceBreak(int start, int stop) {
    if (textBreakCount == textBreakStart.length) {
      textBreakStart = PApplet.expand(textBreakStart);
      textBreakStop = PApplet.expand(textBreakStop);
    }
    textBreakStart[textBreakCount] = start;
    textBreakStop[textBreakCount] = stop;
    textBreakCount++;
  }












  public void text(int num, float x, float y) {
    text(String.valueOf(num), x, y);
  }


  public void text(int num, float x, float y, float z) {
    text(String.valueOf(num), x, y, z);
  }



  public void text(float num, float x, float y) {
    text(PApplet.nfs(num, 0, 3), x, y);
  }


  public void text(float num, float x, float y, float z) {
    text(PApplet.nfs(num, 0, 3), x, y, z);
  }











  protected void textLineAlignImpl(char buffer[], int start, int stop,
                                   float x, float y) {
    if (textAlign == CENTER) {
      x -= textWidthImpl(buffer, start, stop) / 2f;

    } else if (textAlign == RIGHT) {
      x -= textWidthImpl(buffer, start, stop);
    }

    textLineImpl(buffer, start, stop, x, y);
  }



  protected void textLineImpl(char buffer[], int start, int stop,
                              float x, float y) {
    for (int index = start; index < stop; index++) {
      textCharImpl(buffer[index], x, y);


      x += textWidth(buffer[index]);
    }



  }


  protected void textCharImpl(char ch, float x, float y) { 
    PFont.Glyph glyph = textFont.getGlyph(ch);
    if (glyph != null) {
      if (textMode == MODEL) {
        float high    = glyph.height     / (float) textFont.getSize();
        float bwidth  = glyph.width      / (float) textFont.getSize();
        float lextent = glyph.leftExtent / (float) textFont.getSize();
        float textent = glyph.topExtent  / (float) textFont.getSize();

        float x1 = x + lextent * textSize;
        float y1 = y - textent * textSize;
        float x2 = x1 + bwidth * textSize;
        float y2 = y1 + high * textSize;

        textCharModelImpl(glyph.image,
                          x1, y1, x2, y2,
                          glyph.width, glyph.height);
      }
    } else if (ch != ' ' && ch != 127) {
      showWarning("No glyph found for the " + ch + " (\\u" + PApplet.hex(ch, 4) + ") character");
    }
  }


  protected void textCharModelImpl(PImage glyph,
                                   float x1, float y1, 
                                   float x2, float y2, 
                                   int u2, int v2) {
    boolean savedTint = tint;
    int savedTintColor = tintColor;
    float savedTintR = tintR;
    float savedTintG = tintG;
    float savedTintB = tintB;
    float savedTintA = tintA;
    boolean savedTintAlpha = tintAlpha;

    tint = true;
    tintColor = fillColor;
    tintR = fillR;
    tintG = fillG;
    tintB = fillB;
    tintA = fillA;
    tintAlpha = fillAlpha;

    imageImpl(glyph, x1, y1, x2, y2, 0, 0, u2, v2);

    tint = savedTint;
    tintColor = savedTintColor;
    tintR = savedTintR;
    tintG = savedTintG;
    tintB = savedTintB;
    tintA = savedTintA;
    tintAlpha = savedTintAlpha;
  }






  @SuppressWarnings("deprecation")
  public FontMetrics getFontMetrics(Font font) {  
    Frame frame = parent.getFrame();
    if (frame != null) {
      return frame.getToolkit().getFontMetrics(font);
    }
    return Toolkit.getDefaultToolkit().getFontMetrics(font);
  }



  public FontRenderContext getFontRenderContext(Font font) {  
    return getFontMetrics(font).getFontRenderContext();
  }









  public void pushMatrix() {
    showMethodWarning("pushMatrix");
  }



  public void popMatrix() {
    showMethodWarning("popMatrix");
  }









  public void translate(float x, float y) {
    showMissingWarning("translate");
  }



  public void translate(float x, float y, float z) {
    showMissingWarning("translate");
  }



  public void rotate(float angle) {
    showMissingWarning("rotate");
  }



  public void rotateX(float angle) {
    showMethodWarning("rotateX");
  }



  public void rotateY(float angle) {
    showMethodWarning("rotateY");
  }



  public void rotateZ(float angle) {
    showMethodWarning("rotateZ");
  }



  public void rotate(float angle, float x, float y, float z) {
    showMissingWarning("rotate");
  }



  public void scale(float s) {
    showMissingWarning("scale");
  }



  public void scale(float x, float y) {
    showMissingWarning("scale");
  }



  public void scale(float x, float y, float z) {
    showMissingWarning("scale");
  }



  public void shearX(float angle) {
    showMissingWarning("shearX");
  }



  public void shearY(float angle) {
    showMissingWarning("shearY");
  }








  public void resetMatrix() {
    showMethodWarning("resetMatrix");
  }


  public void applyMatrix(PMatrix source) {
    if (source instanceof PMatrix2D) {
      applyMatrix((PMatrix2D) source);
    } else if (source instanceof PMatrix3D) {
      applyMatrix((PMatrix3D) source);
    }
  }


  public void applyMatrix(PMatrix2D source) {
    applyMatrix(source.m00, source.m01, source.m02,
                source.m10, source.m11, source.m12);
  }



  public void applyMatrix(float n00, float n01, float n02,
                          float n10, float n11, float n12) {
    showMissingWarning("applyMatrix");
  }

  public void applyMatrix(PMatrix3D source) {
    applyMatrix(source.m00, source.m01, source.m02, source.m03,
                source.m10, source.m11, source.m12, source.m13,
                source.m20, source.m21, source.m22, source.m23,
                source.m30, source.m31, source.m32, source.m33);
  }



  public void applyMatrix(float n00, float n01, float n02, float n03,
                          float n10, float n11, float n12, float n13,
                          float n20, float n21, float n22, float n23,
                          float n30, float n31, float n32, float n33) {
    showMissingWarning("applyMatrix");
  }








  public PMatrix getMatrix() {
    showMissingWarning("getMatrix");
    return null;
  }



  public PMatrix2D getMatrix(PMatrix2D target) {
    showMissingWarning("getMatrix");
    return null;
  }



  public PMatrix3D getMatrix(PMatrix3D target) {
    showMissingWarning("getMatrix");
    return null;
  }



  public void setMatrix(PMatrix source) {
    if (source instanceof PMatrix2D) {
      setMatrix((PMatrix2D) source);
    } else if (source instanceof PMatrix3D) {
      setMatrix((PMatrix3D) source);
    }
  }



  public void setMatrix(PMatrix2D source) {
    showMissingWarning("setMatrix");
  }



  public void setMatrix(PMatrix3D source) {
    showMissingWarning("setMatrix");
  }



  public void printMatrix() {
    showMethodWarning("printMatrix");
  }







  public void beginCamera() {
    showMethodWarning("beginCamera");
  }


  public void endCamera() {
    showMethodWarning("endCamera");
  }


  public void camera() {
    showMissingWarning("camera");
  }


  public void camera(float eyeX, float eyeY, float eyeZ,
                     float centerX, float centerY, float centerZ,
                     float upX, float upY, float upZ) {
    showMissingWarning("camera");
  }


  public void printCamera() {
    showMethodWarning("printCamera");
  }








  public void ortho() {
    showMissingWarning("ortho");
  }


  public void ortho(float left, float right,
                    float bottom, float top) {
    showMissingWarning("ortho");
  }


  public void ortho(float left, float right,
                    float bottom, float top,
                    float near, float far) {
    showMissingWarning("ortho");
  }


  public void perspective() {
    showMissingWarning("perspective");
  }


  public void perspective(float fovy, float aspect, float zNear, float zFar) {
    showMissingWarning("perspective");
  }


  public void frustum(float left, float right,
                      float bottom, float top,
                      float near, float far) {
    showMethodWarning("frustum");
  }


  public void printProjection() {
    showMethodWarning("printProjection");
  }









  public float screenX(float x, float y) {
    showMissingWarning("screenX");
    return 0;
  }



  public float screenY(float x, float y) {
    showMissingWarning("screenY");
    return 0;
  }



  public float screenX(float x, float y, float z) {
    showMissingWarning("screenX");
    return 0;
  }



  public float screenY(float x, float y, float z) {
    showMissingWarning("screenY");
    return 0;
  }




  public float screenZ(float x, float y, float z) {
    showMissingWarning("screenZ");
    return 0;
  }



  public float modelX(float x, float y, float z) {
    showMissingWarning("modelX");
    return 0;
  }



  public float modelY(float x, float y, float z) {
    showMissingWarning("modelY");
    return 0;
  }



  public float modelZ(float x, float y, float z) {
    showMissingWarning("modelZ");
    return 0;
  }








  public void pushStyle() {
    if (styleStackDepth == styleStack.length) {
      styleStack = (PStyle[]) PApplet.expand(styleStack);
    }
    if (styleStack[styleStackDepth] == null) {
      styleStack[styleStackDepth] = new PStyle();
    }
    PStyle s = styleStack[styleStackDepth++];
    getStyle(s);
  }


  public void popStyle() {
    if (styleStackDepth == 0) {
      throw new RuntimeException("Too many popStyle() without enough pushStyle()");
    }
    styleStackDepth--;
    style(styleStack[styleStackDepth]);
  }


  public void style(PStyle s) {






    imageMode(s.imageMode);
    rectMode(s.rectMode);
    ellipseMode(s.ellipseMode);
    shapeMode(s.shapeMode);

    blendMode(s.blendMode);

    if (s.tint) {
      tint(s.tintColor);
    } else {
      noTint();
    }
    if (s.fill) {
      fill(s.fillColor);
    } else {
      noFill();
    }
    if (s.stroke) {
      stroke(s.strokeColor);
    } else {
      noStroke();
    }
    strokeWeight(s.strokeWeight);
    strokeCap(s.strokeCap);
    strokeJoin(s.strokeJoin);




    colorMode(RGB, 1);
    ambient(s.ambientR, s.ambientG, s.ambientB);
    emissive(s.emissiveR, s.emissiveG, s.emissiveB);
    specular(s.specularR, s.specularG, s.specularB);
    shininess(s.shininess);








    colorMode(s.colorMode,
              s.colorModeX, s.colorModeY, s.colorModeZ, s.colorModeA);





    if (s.textFont != null) {
      textFont(s.textFont, s.textSize);
      textLeading(s.textLeading);
    }

    textAlign(s.textAlign, s.textAlignY);
    textMode(s.textMode);
  }


  public PStyle getStyle() {  
    return getStyle(null);
  }


  public PStyle getStyle(PStyle s) {  
    if (s == null) {
      s = new PStyle();
    }

    s.imageMode = imageMode;
    s.rectMode = rectMode;
    s.ellipseMode = ellipseMode;
    s.shapeMode = shapeMode;

    s.blendMode = blendMode;

    s.colorMode = colorMode;
    s.colorModeX = colorModeX;
    s.colorModeY = colorModeY;
    s.colorModeZ = colorModeZ;
    s.colorModeA = colorModeA;

    s.tint = tint;
    s.tintColor = tintColor;
    s.fill = fill;
    s.fillColor = fillColor;
    s.stroke = stroke;
    s.strokeColor = strokeColor;
    s.strokeWeight = strokeWeight;
    s.strokeCap = strokeCap;
    s.strokeJoin = strokeJoin;

    s.ambientR = ambientR;
    s.ambientG = ambientG;
    s.ambientB = ambientB;
    s.specularR = specularR;
    s.specularG = specularG;
    s.specularB = specularB;
    s.emissiveR = emissiveR;
    s.emissiveG = emissiveG;
    s.emissiveB = emissiveB;
    s.shininess = shininess;

    s.textFont = textFont;
    s.textAlign = textAlign;
    s.textAlignY = textAlignY;
    s.textMode = textMode;
    s.textSize = textSize;
    s.textLeading = textLeading;

    return s;
  }








  public void strokeWeight(float weight) {
    strokeWeight = weight;
  }


  public void strokeJoin(int join) {
    strokeJoin = join;
  }


  public void strokeCap(int cap) {
    strokeCap = cap;
  }









  public void noStroke() {
    stroke = false;
  }



  public void stroke(int rgb) {
    colorCalc(rgb);
    strokeFromCalc();
  }



  public void stroke(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    strokeFromCalc();
  }



  public void stroke(float gray) {
    colorCalc(gray);
    strokeFromCalc();
  }


  public void stroke(float gray, float alpha) {
    colorCalc(gray, alpha);
    strokeFromCalc();
  }



  public void stroke(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    strokeFromCalc();
  }


  public void stroke(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    strokeFromCalc();
  }


  protected void strokeFromCalc() {
    stroke = true;
    strokeR = calcR;
    strokeG = calcG;
    strokeB = calcB;
    strokeA = calcA;
    strokeRi = calcRi;
    strokeGi = calcGi;
    strokeBi = calcBi;
    strokeAi = calcAi;
    strokeColor = calcColor;
    strokeAlpha = calcAlpha;
  }









  public void noTint() {
    tint = false;
  }



  public void tint(int rgb) {
    colorCalc(rgb);
    tintFromCalc();
  }



  public void tint(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    tintFromCalc();
  }



  public void tint(float gray) {
    colorCalc(gray);
    tintFromCalc();
  }


  public void tint(float gray, float alpha) {
    colorCalc(gray, alpha);
    tintFromCalc();
  }


  public void tint(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    tintFromCalc();
  }


  public void tint(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    tintFromCalc();
  }


  protected void tintFromCalc() {
    tint = true;
    tintR = calcR;
    tintG = calcG;
    tintB = calcB;
    tintA = calcA;
    tintRi = calcRi;
    tintGi = calcGi;
    tintBi = calcBi;
    tintAi = calcAi;
    tintColor = calcColor;
    tintAlpha = calcAlpha;
  }









  public void noFill() {
    fill = false;
  }



  public void fill(int rgb) {
    colorCalc(rgb);
    fillFromCalc();
  }


  public void fill(int rgb, float alpha) {
    colorCalc(rgb, alpha);
    fillFromCalc();
  }



  public void fill(float gray) {
    colorCalc(gray);
    fillFromCalc();
  }


  public void fill(float gray, float alpha) {
    colorCalc(gray, alpha);
    fillFromCalc();
  }



  public void fill(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    fillFromCalc();
  }


  public void fill(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    fillFromCalc();
  }


  protected void fillFromCalc() {
    fill = true;
    fillR = calcR;
    fillG = calcG;
    fillB = calcB;
    fillA = calcA;
    fillRi = calcRi;
    fillGi = calcGi;
    fillBi = calcBi;
    fillAi = calcAi;
    fillColor = calcColor;
    fillAlpha = calcAlpha;
  }








  public void ambient(int rgb) {







    colorCalc(rgb);
    ambientFromCalc();
  }


  public void ambient(float gray) {
    colorCalc(gray);
    ambientFromCalc();
  }


  public void ambient(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    ambientFromCalc();
  }


  protected void ambientFromCalc() {
    ambientColor = calcColor;
    ambientR = calcR;
    ambientG = calcG;
    ambientB = calcB;
    setAmbient = true;
  }


  public void specular(int rgb) {







    colorCalc(rgb);
    specularFromCalc();
  }



  public void specular(float gray) {
    colorCalc(gray);
    specularFromCalc();
  }



  public void specular(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    specularFromCalc();
  }


  protected void specularFromCalc() {
    specularColor = calcColor;
    specularR = calcR;
    specularG = calcG;
    specularB = calcB;
  }



  public void shininess(float shine) {
    shininess = shine;
  }


  public void emissive(int rgb) {







    colorCalc(rgb);
    emissiveFromCalc();
  }


  public void emissive(float gray) {
    colorCalc(gray);
    emissiveFromCalc();
  }


  public void emissive(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    emissiveFromCalc();
  }


  protected void emissiveFromCalc() {
    emissiveColor = calcColor;
    emissiveR = calcR;
    emissiveG = calcG;
    emissiveB = calcB;
  }












  public void lights() {
    showMethodWarning("lights");
  }


  public void noLights() {
    showMethodWarning("noLights");
  }


  public void ambientLight(float v1, float v2, float v3) {
    showMethodWarning("ambientLight");
  }


  public void ambientLight(float v1, float v2, float v3,
                           float x, float y, float z) {
    showMethodWarning("ambientLight");
  }


  public void directionalLight(float v1, float v2, float v3,
                               float nx, float ny, float nz) {
    showMethodWarning("directionalLight");
  }


  public void pointLight(float v1, float v2, float v3,
                         float x, float y, float z) {
    showMethodWarning("pointLight");
  }


  public void spotLight(float v1, float v2, float v3,
                        float x, float y, float z,
                        float nx, float ny, float nz,
                        float angle, float concentration) {
    showMethodWarning("spotLight");
  }


  public void lightFalloff(float constant, float linear, float quadratic) {
    showMethodWarning("lightFalloff");
  }


  public void lightSpecular(float v1, float v2, float v3) {
    showMethodWarning("lightSpecular");
  }









  public void background(int rgb) {











    colorCalc(rgb);
    backgroundFromCalc();
  }



  public void background(int rgb, float alpha) {













    colorCalc(rgb, alpha);
    backgroundFromCalc();
  }



  public void background(float gray) {
    colorCalc(gray);
    backgroundFromCalc();

  }


  public void background(float gray, float alpha) {
    if (format == RGB) {
      background(gray);  

    } else {
      colorCalc(gray, alpha);
      backgroundFromCalc();

    }
  }



  public void background(float v1, float v2, float v3) {
    colorCalc(v1, v2, v3);
    backgroundFromCalc();

  }


  public void background(float v1, float v2, float v3, float alpha) {
    colorCalc(v1, v2, v3, alpha);
    backgroundFromCalc();
  }


  public void clear() {
    background(0, 0, 0, 0);
  }


  protected void backgroundFromCalc() {
    backgroundR = calcR;
    backgroundG = calcG;
    backgroundB = calcB;


    backgroundA = (format == RGB) ? 1 : calcA;
    backgroundRi = calcRi;
    backgroundGi = calcGi;
    backgroundBi = calcBi;
    backgroundAi = (format == RGB) ? 255 : calcAi;
    backgroundAlpha = (format == RGB) ? false : calcAlpha;
    backgroundColor = calcColor;

    backgroundImpl();
  }



  public void background(PImage image) {
    if ((image.width != width) || (image.height != height)) {
      throw new RuntimeException(ERROR_BACKGROUND_IMAGE_SIZE);
    }
    if ((image.format != RGB) && (image.format != ARGB)) {
      throw new RuntimeException(ERROR_BACKGROUND_IMAGE_FORMAT);
    }
    backgroundColor = 0;  
    backgroundImpl(image);
  }



  protected void backgroundImpl(PImage image) {

    set(0, 0, image);
  }



  protected void backgroundImpl() {
    pushStyle();
    pushMatrix();
    resetMatrix();
    fill(backgroundColor);
    rect(0, 0, width, height);
    popMatrix();
    popStyle();
  }





























  public void colorMode(int mode) {
    colorMode(mode, colorModeX, colorModeY, colorModeZ, colorModeA);
  }



  public void colorMode(int mode, float max) {
    colorMode(mode, max, max, max, max);
  }



  public void colorMode(int mode, float max1, float max2, float max3) {
    colorMode(mode, max1, max2, max3, colorModeA);
  }



  public void colorMode(int mode,
                        float max1, float max2, float max3, float maxA) {
    colorMode = mode;

    colorModeX = max1;  
    colorModeY = max2;
    colorModeZ = max3;
    colorModeA = maxA;


    colorModeScale =
      ((maxA != 1) || (max1 != max2) || (max2 != max3) || (max3 != maxA));



    colorModeDefault = (colorMode == RGB) &&
      (colorModeA == 255) && (colorModeX == 255) &&
      (colorModeY == 255) && (colorModeZ == 255);
  }



















  protected void colorCalc(int rgb) {
    if (((rgb & 0xff000000) == 0) && (rgb <= colorModeX)) {
      colorCalc((float) rgb);

    } else {
      colorCalcARGB(rgb, colorModeA);
    }
  }


  protected void colorCalc(int rgb, float alpha) {
    if (((rgb & 0xff000000) == 0) && (rgb <= colorModeX)) {  
      colorCalc((float) rgb, alpha);

    } else {
      colorCalcARGB(rgb, alpha);
    }
  }


  protected void colorCalc(float gray) {
    colorCalc(gray, colorModeA);
  }


  protected void colorCalc(float gray, float alpha) {
    if (gray > colorModeX) gray = colorModeX;
    if (alpha > colorModeA) alpha = colorModeA;

    if (gray < 0) gray = 0;
    if (alpha < 0) alpha = 0;

    calcR = colorModeScale ? (gray / colorModeX) : gray;
    calcG = calcR;
    calcB = calcR;
    calcA = colorModeScale ? (alpha / colorModeA) : alpha;

    calcRi = (int)(calcR*255); calcGi = (int)(calcG*255);
    calcBi = (int)(calcB*255); calcAi = (int)(calcA*255);
    calcColor = (calcAi << 24) | (calcRi << 16) | (calcGi << 8) | calcBi;
    calcAlpha = (calcAi != 255);
  }


  protected void colorCalc(float x, float y, float z) {
    colorCalc(x, y, z, colorModeA);
  }


  protected void colorCalc(float x, float y, float z, float a) {
    if (x > colorModeX) x = colorModeX;
    if (y > colorModeY) y = colorModeY;
    if (z > colorModeZ) z = colorModeZ;
    if (a > colorModeA) a = colorModeA;

    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (z < 0) z = 0;
    if (a < 0) a = 0;

    switch (colorMode) {
    case RGB:
      if (colorModeScale) {
        calcR = x / colorModeX;
        calcG = y / colorModeY;
        calcB = z / colorModeZ;
        calcA = a / colorModeA;
      } else {
        calcR = x; calcG = y; calcB = z; calcA = a;
      }
      break;

    case HSB:
      x /= colorModeX; 
      y /= colorModeY; 
      z /= colorModeZ; 

      calcA = colorModeScale ? (a/colorModeA) : a;

      if (y == 0) {  
        calcR = calcG = calcB = z;

      } else {
        float which = (x - (int)x) * 6.0f;
        float f = which - (int)which;
        float p = z * (1.0f - y);
        float q = z * (1.0f - y * f);
        float t = z * (1.0f - (y * (1.0f - f)));

        switch ((int)which) {
        case 0: calcR = z; calcG = t; calcB = p; break;
        case 1: calcR = q; calcG = z; calcB = p; break;
        case 2: calcR = p; calcG = z; calcB = t; break;
        case 3: calcR = p; calcG = q; calcB = z; break;
        case 4: calcR = t; calcG = p; calcB = z; break;
        case 5: calcR = z; calcG = p; calcB = q; break;
        }
      }
      break;
    }
    calcRi = (int)(255*calcR); calcGi = (int)(255*calcG);
    calcBi = (int)(255*calcB); calcAi = (int)(255*calcA);
    calcColor = (calcAi << 24) | (calcRi << 16) | (calcGi << 8) | calcBi;
    calcAlpha = (calcAi != 255);
  }



  protected void colorCalcARGB(int argb, float alpha) {
    if (alpha == colorModeA) {
      calcAi = (argb >> 24) & 0xff;
      calcColor = argb;
    } else {
      calcAi = (int) (((argb >> 24) & 0xff) * PApplet.constrain((alpha / colorModeA), 0, 1));
      calcColor = (calcAi << 24) | (argb & 0xFFFFFF);
    }
    calcRi = (argb >> 16) & 0xff;
    calcGi = (argb >> 8) & 0xff;
    calcBi = argb & 0xff;
    calcA = calcAi / 255.0f;
    calcR = calcRi / 255.0f;
    calcG = calcGi / 255.0f;
    calcB = calcBi / 255.0f;
    calcAlpha = (calcAi != 255);
  }
















  public final int color(int c) {  











    colorCalc(c);
    return calcColor;
  }


  public final int color(float gray) {  
    colorCalc(gray);
    return calcColor;
  }



  public final int color(int c, int alpha) {  







    colorCalc(c, alpha);
    return calcColor;
  }



  public final int color(int c, float alpha) {  

    colorCalc(c, alpha);



    return calcColor;
  }


  public final int color(float gray, float alpha) {  
    colorCalc(gray, alpha);
    return calcColor;
  }


  public final int color(int v1, int v2, int v3) {  
    colorCalc(v1, v2, v3);
    return calcColor;
  }


  public final int color(float v1, float v2, float v3) {  
    colorCalc(v1, v2, v3);
    return calcColor;
  }


  public final int color(int v1, int v2, int v3, int a) {  
    colorCalc(v1, v2, v3, a);
    return calcColor;
  }


  public final int color(float v1, float v2, float v3, float a) {  
    colorCalc(v1, v2, v3, a);
    return calcColor;
  }










  public final float alpha(int rgb) {
    float outgoing = (rgb >> 24) & 0xff;
    if (colorModeA == 255) return outgoing;
    return (outgoing / 255.0f) * colorModeA;
  }



  public final float red(int rgb) {
    float c = (rgb >> 16) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeX;
  }



  public final float green(int rgb) {
    float c = (rgb >> 8) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeY;
  }



  public final float blue(int rgb) {
    float c = (rgb) & 0xff;
    if (colorModeDefault) return c;
    return (c / 255.0f) * colorModeZ;
  }



  public final float hue(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[0] * colorModeX;
  }



  public final float saturation(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[1] * colorModeY;
  }



  public final float brightness(int rgb) {
    if (rgb != cacheHsbKey) {
      Color.RGBtoHSB((rgb >> 16) & 0xff, (rgb >> 8) & 0xff,
                     rgb & 0xff, cacheHsbValue);
      cacheHsbKey = rgb;
    }
    return cacheHsbValue[2] * colorModeZ;
  }











  public int lerpColor(int c1, int c2, float amt) {  
    return lerpColor(c1, c2, amt, colorMode);
  }

  static float[] lerpColorHSB1;
  static float[] lerpColorHSB2;


  static public int lerpColor(int c1, int c2, float amt, int mode) {
    if (amt < 0) amt = 0;
    if (amt > 1) amt = 1;

    if (mode == RGB) {
      float a1 = ((c1 >> 24) & 0xff);
      float r1 = (c1 >> 16) & 0xff;
      float g1 = (c1 >> 8) & 0xff;
      float b1 = c1 & 0xff;
      float a2 = (c2 >> 24) & 0xff;
      float r2 = (c2 >> 16) & 0xff;
      float g2 = (c2 >> 8) & 0xff;
      float b2 = c2 & 0xff;

      return ((PApplet.round(a1 + (a2-a1)*amt) << 24) |
              (PApplet.round(r1 + (r2-r1)*amt) << 16) |
              (PApplet.round(g1 + (g2-g1)*amt) << 8) |
              (PApplet.round(b1 + (b2-b1)*amt)));

    } else if (mode == HSB) {
      if (lerpColorHSB1 == null) {
        lerpColorHSB1 = new float[3];
        lerpColorHSB2 = new float[3];
      }

      float a1 = (c1 >> 24) & 0xff;
      float a2 = (c2 >> 24) & 0xff;
      int alfa = (PApplet.round(a1 + (a2-a1)*amt)) << 24;

      Color.RGBtoHSB((c1 >> 16) & 0xff, (c1 >> 8) & 0xff, c1 & 0xff,
                     lerpColorHSB1);
      Color.RGBtoHSB((c2 >> 16) & 0xff, (c2 >> 8) & 0xff, c2 & 0xff,
                     lerpColorHSB2);









      float ho = PApplet.lerp(lerpColorHSB1[0], lerpColorHSB2[0], amt);
      float so = PApplet.lerp(lerpColorHSB1[1], lerpColorHSB2[1], amt);
      float bo = PApplet.lerp(lerpColorHSB1[2], lerpColorHSB2[2], amt);

      return alfa | (Color.HSBtoRGB(ho, so, bo) & 0xFFFFFF);
    }
    return 0;
  }








  public void beginRaw(PGraphics rawGraphics) {  
    this.raw = rawGraphics;
    rawGraphics.beginDraw();
  }


  public void endRaw() {  
    if (raw != null) {


      flush();



      raw.endDraw();
      raw.dispose();
      raw = null;
    }
  }


  public boolean haveRaw() { 
    return raw != null;
  }


  public PGraphics getRaw() { 
    return raw;
  }







  static protected HashMap<String, Object> warnings;



  static public void showWarning(String msg) {  
    if (warnings == null) {
      warnings = new HashMap<String, Object>();
    }
    if (!warnings.containsKey(msg)) {
      System.err.println(msg);
      warnings.put(msg, new Object());
    }
  }



  static public void showWarning(String msg, Object... args) {  
    showWarning(String.format(msg, args));
  }



  static public void showDepthWarning(String method) {
    showWarning(method + "() can only be used with a renderer that " +
                "supports 3D, such as P3D.");
  }



  static public void showDepthWarningXYZ(String method) {
    showWarning(method + "() with x, y, and z coordinates " +
                "can only be used with a renderer that " +
                "supports 3D, such as P3D. " +
                "Use a version without a z-coordinate instead.");
  }



  static public void showMethodWarning(String method) {
    showWarning(method + "() is not available with this renderer.");
  }



  static public void showVariationWarning(String str) {
    showWarning(str + " is not available with this renderer.");
  }



  static public void showMissingWarning(String method) {
    showWarning(method + "(), or this particular variation of it, " +
                "is not available with this renderer.");
  }



  static public void showException(String msg) {  
    throw new RuntimeException(msg);
  }



  protected void defaultFontOrDeath(String method) {
    defaultFontOrDeath(method, 12);
  }



  protected void defaultFontOrDeath(String method, float size) {
    if (parent != null) {
      textFont = parent.createDefaultFont(size);
    } else {
      throw new RuntimeException("Use textFont() before " + method + "()");
    }
  }









  public boolean displayable() {  
    return true;
  }



  public boolean is2D() {  
    return true;
  }



  public boolean is3D() {  
    return false;
  }



  public boolean isGL() {  
    return false;
  }


  public boolean is2X() {
    return pixelDensity == 2;
  }
}

<code block>




package processing.opengl;

import java.io.IOException;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.util.Arrays;

import processing.core.PApplet;
import processing.core.PGraphics;



public abstract class PGL {





  protected PGraphicsOpenGL pg;


  protected Thread glThread;


  protected int glContext;


  public boolean primaryPGL;





  protected static boolean USE_FBOLAYER_BY_DEFAULT = false;
  public static int REQUESTED_DEPTH_BITS   = 24;
  public static int REQUESTED_STENCIL_BITS = 8;
  public static int REQUESTED_ALPHA_BITS   = 8;


  protected static boolean USE_DIRECT_BUFFERS = true;
  protected static int MIN_DIRECT_BUFFER_SIZE = 1;


  protected static boolean SAVE_SURFACE_TO_PIXELS_HACK = false;


  protected static boolean MIPMAPS_ENABLED = true;


  protected static int DEFAULT_IN_VERTICES   = 64;
  protected static int DEFAULT_IN_EDGES      = 128;
  protected static int DEFAULT_IN_TEXTURES   = 64;
  protected static int DEFAULT_TESS_VERTICES = 64;
  protected static int DEFAULT_TESS_INDICES  = 128;


  protected static int MAX_LIGHTS = 8;


  protected static int MAX_VERTEX_INDEX  = 32767;
  protected static int MAX_VERTEX_INDEX1 = MAX_VERTEX_INDEX + 1;


  protected static int FLUSH_VERTEX_COUNT = MAX_VERTEX_INDEX1;


  protected static int MIN_FONT_TEX_SIZE = 256;
  protected static int MAX_FONT_TEX_SIZE = 1024;


  protected static float MIN_CAPS_JOINS_WEIGHT = 2f;


  protected static int MAX_CAPS_JOINS_LENGTH = 5000;


  protected static int MIN_ARRAYCOPY_SIZE = 2;


  protected static float STROKE_DISPLACEMENT = 0.999f;






  protected boolean fboLayerRequested = false;
  protected boolean fboLayerCreated = false;
  protected boolean fboLayerInUse = false;
  protected boolean firstFrame = true;
  public int reqNumSamples;
  protected int numSamples;
  protected IntBuffer glColorFbo;
  protected IntBuffer glMultiFbo;
  protected IntBuffer glColorBuf;
  protected IntBuffer glColorTex;
  protected IntBuffer glDepthStencil;
  protected IntBuffer glDepth;
  protected IntBuffer glStencil;
  protected int fboWidth, fboHeight;
  protected int backTex, frontTex;


  protected boolean usingFrontTex = false;
  protected boolean needSepFrontTex = false;





  protected boolean loadedTex2DShader = false;
  protected int tex2DShaderProgram;
  protected int tex2DVertShader;
  protected int tex2DFragShader;
  protected int tex2DShaderContext;
  protected int tex2DVertLoc;
  protected int tex2DTCoordLoc;
  protected int tex2DSamplerLoc;
  protected int tex2DGeoVBO;

  protected boolean loadedTexRectShader = false;
  protected int texRectShaderProgram;
  protected int texRectVertShader;
  protected int texRectFragShader;
  protected int texRectShaderContext;
  protected int texRectVertLoc;
  protected int texRectTCoordLoc;
  protected int texRectSamplerLoc;
  protected int texRectGeoVBO;

  protected float[] texCoords = {

    -1.0f, -1.0f, 0.0f, 0.0f,
    +1.0f, -1.0f, 1.0f, 0.0f,
    -1.0f, +1.0f, 0.0f, 1.0f,
    +1.0f, +1.0f, 1.0f, 1.0f
  };
  protected FloatBuffer texData;

  protected static final String SHADER_PREPROCESSOR_DIRECTIVE =
    "#ifdef GL_ES\n" +
    "precision mediump float;\n" +
    "precision mediump int;\n" +
    "#endif\n";

  protected static String[] texVertShaderSource = {
    "attribute vec2 position;",
    "attribute vec2 texCoord;",
    "varying vec2 vertTexCoord;",
    "void main() {",
    "  gl_Position = vec4(position, 0, 1);",
    "  vertTexCoord = texCoord;",
    "}"
  };

  protected static String[] tex2DFragShaderSource = {
    SHADER_PREPROCESSOR_DIRECTIVE,
    "uniform sampler2D texMap;",
    "varying vec2 vertTexCoord;",
    "void main() {",
   "  gl_FragColor = texture2D(texMap, vertTexCoord.st);",
    "}"
  };

  protected static String[] texRectFragShaderSource = {
    SHADER_PREPROCESSOR_DIRECTIVE,
    "uniform sampler2DRect texMap;",
    "varying vec2 vertTexCoord;",
    "void main() {",
    "  gl_FragColor = texture2DRect(texMap, vertTexCoord.st);",
    "}"
  };


  protected boolean[] texturingTargets = { false, false };


  protected int maxTexUnits;
  protected int activeTexUnit = 0;
  protected int[][] boundTextures;





  protected float targetFps = 60;
  protected float currentFps = 60;
  protected boolean setFps = false;





  protected ByteBuffer byteBuffer;
  protected IntBuffer intBuffer;
  protected IntBuffer viewBuffer;

  protected IntBuffer colorBuffer;
  protected FloatBuffer depthBuffer;
  protected ByteBuffer stencilBuffer;





  public static final String WIKI =
    " Read http://wiki.processing.org/w/OpenGL_Issues for help.";

  public static final String FRAMEBUFFER_ERROR =
    "Framebuffer error (%1$s), rendering will probably not work as expected" + WIKI;

  public static final String MISSING_FBO_ERROR =
    "Framebuffer objects are not supported by this hardware (or driver)" + WIKI;

  public static final String MISSING_GLSL_ERROR =
    "GLSL shaders are not supported by this hardware (or driver)" + WIKI;

  public static final String MISSING_GLFUNC_ERROR =
    "GL function %1$s is not available on this hardware (or driver)" + WIKI;

  public static final String UNSUPPORTED_GLPROF_ERROR =
    "Unsupported OpenGL profile.";

  public static final String TEXUNIT_ERROR =
    "Number of texture units not supported by this hardware (or driver)" + WIKI;

  public static final String NONPRIMARY_ERROR =
    "The renderer is trying to call a PGL function that can only be called on a primary PGL. " +
    "This is most likely due to a bug in the renderer's code, please report it with an " +
    "issue on Processing's github page https://github.com/processing/processing/issues?state=open " +
    "if using any of the built-in OpenGL renderers. If you are using a contributed " +
    "library, contact the library's developers.";






  protected static int SIZEOF_SHORT = Short.SIZE / 8;
  protected static int SIZEOF_INT   = Integer.SIZE / 8;
  protected static int SIZEOF_FLOAT = Float.SIZE / 8;
  protected static int SIZEOF_BYTE  = Byte.SIZE / 8;
  protected static int SIZEOF_INDEX = SIZEOF_SHORT;
  protected static int INDEX_TYPE   = 0x1403; 


  protected static float FLOAT_EPS = Float.MIN_VALUE;


  static {
    float eps = 1.0f;

    do {
      eps /= 2.0f;
    } while ((float)(1.0 + (eps / 2.0)) != 1.0);

    FLOAT_EPS = eps;
  }


  protected static boolean BIG_ENDIAN =
    ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;



  public boolean presentMode = false;
  public float offsetX;
  public float offsetY;






  public PGL() { }


  public PGL(PGraphicsOpenGL pg) {
    this.pg = pg;
    if (glColorTex == null) {
      glColorTex = allocateIntBuffer(2);
      glColorFbo = allocateIntBuffer(1);
      glMultiFbo = allocateIntBuffer(1);
      glColorBuf = allocateIntBuffer(1);
      glDepthStencil = allocateIntBuffer(1);
      glDepth = allocateIntBuffer(1);
      glStencil = allocateIntBuffer(1);

      fboLayerCreated = false;
      fboLayerInUse = false;
      firstFrame = false;
    }

    byteBuffer = allocateByteBuffer(1);
    intBuffer = allocateIntBuffer(1);
    viewBuffer = allocateIntBuffer(4);
  }


  public void setPrimary(boolean primary) {
    primaryPGL = primary;
  }


  static protected int smoothToSamples(int smooth) {
    if (smooth == 0) {

      return 1;
    } else if (smooth == 1) {

      return 2;
    } else {

      return smooth;
    }
  }
















  protected void deleteSurface() {
    if (threadIsCurrent() && fboLayerCreated) {
      deleteTextures(2, glColorTex);
      deleteFramebuffers(1, glColorFbo);
      deleteFramebuffers(1, glMultiFbo);
      deleteRenderbuffers(1, glColorBuf);
      deleteRenderbuffers(1, glDepthStencil);
      deleteRenderbuffers(1, glDepth);
      deleteRenderbuffers(1, glStencil);
    }

    fboLayerCreated = false;
    fboLayerInUse = false;
    firstFrame = false;
  }


  protected int getReadFramebuffer()  {
    return fboLayerInUse ? glColorFbo.get(0) : 0;
  }


  protected int getDrawFramebuffer()  {
    if (fboLayerInUse) return 1 < numSamples ? glMultiFbo.get(0) :
                                               glColorFbo.get(0);
    else return 0;
  }


  protected int getDefaultDrawBuffer()  {
    return fboLayerInUse ? COLOR_ATTACHMENT0 : BACK;
  }


  protected int getDefaultReadBuffer()  {
    return fboLayerInUse ? COLOR_ATTACHMENT0 : FRONT;
  }


  protected boolean isFBOBacked() {;
    return fboLayerInUse;
  }


  public void requestFBOLayer() {
    fboLayerRequested = true;
  }


  protected boolean isMultisampled() {
    return 1 < numSamples;
  }


  protected int getDepthBits()  {
    intBuffer.rewind();
    getIntegerv(DEPTH_BITS, intBuffer);
    return intBuffer.get(0);
  }


  protected int getStencilBits()  {
    intBuffer.rewind();
    getIntegerv(STENCIL_BITS, intBuffer);
    return intBuffer.get(0);
  }


  protected boolean getDepthTest() {
    intBuffer.rewind();
    getBooleanv(DEPTH_TEST, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean getDepthWriteMask() {
    intBuffer.rewind();
    getBooleanv(DEPTH_WRITEMASK, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected Texture wrapBackTexture(Texture texture) {
    if (texture == null) {
      texture = new Texture(pg);
      texture.init(pg.width, pg.height,
                   glColorTex.get(backTex), TEXTURE_2D, RGBA,
                   fboWidth, fboHeight, NEAREST, NEAREST,
                   CLAMP_TO_EDGE, CLAMP_TO_EDGE);
      texture.invertedY(true);
      texture.colorBuffer(true);
      pg.setCache(pg, texture);
    } else {
      texture.glName = glColorTex.get(backTex);
    }
    return texture;
  }


  protected Texture wrapFrontTexture(Texture texture)  {
    if (texture == null) {
      texture = new Texture(pg);
      texture.init(pg.width, pg.height,
                   glColorTex.get(frontTex), TEXTURE_2D, RGBA,
                   fboWidth, fboHeight, NEAREST, NEAREST,
                   CLAMP_TO_EDGE, CLAMP_TO_EDGE);
      texture.invertedY(true);
      texture.colorBuffer(true);
    } else {
      texture.glName = glColorTex.get(frontTex);
    }
    return texture;
  }


  protected void bindFrontTexture() {
    usingFrontTex = true;
    if (!texturingIsEnabled(TEXTURE_2D)) {
      enableTexturing(TEXTURE_2D);
    }
    bindTexture(TEXTURE_2D, glColorTex.get(frontTex));
  }


  protected void unbindFrontTexture() {
    if (textureIsBound(TEXTURE_2D, glColorTex.get(frontTex))) {


      if (!texturingIsEnabled(TEXTURE_2D)) {
        enableTexturing(TEXTURE_2D);
        bindTexture(TEXTURE_2D, 0);
        disableTexturing(TEXTURE_2D);
      } else {
        bindTexture(TEXTURE_2D, 0);
      }
    }
  }


  protected void syncBackTexture() {
    if (usingFrontTex) needSepFrontTex = true;
    if (1 < numSamples) {
      bindFramebufferImpl(READ_FRAMEBUFFER, glMultiFbo.get(0));
      bindFramebufferImpl(DRAW_FRAMEBUFFER, glColorFbo.get(0));
      blitFramebuffer(0, 0, fboWidth, fboHeight,
                      0, 0, fboWidth, fboHeight,
                      COLOR_BUFFER_BIT, NEAREST);
    }
  }







  protected void beginDraw(boolean clear0) {
    if (needFBOLayer(clear0)) {
      if (!fboLayerCreated) createFBOLayer();



      bindFramebufferImpl(FRAMEBUFFER, glColorFbo.get(0));
      framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0,
                           TEXTURE_2D, glColorTex.get(backTex), 0);

      if (1 < numSamples) {
        bindFramebufferImpl(FRAMEBUFFER, glMultiFbo.get(0));
      }

      if (firstFrame) {

        int argb = pg.backgroundColor;
        float a = ((argb >> 24) & 0xff) / 255.0f;
        float r = ((argb >> 16) & 0xff) / 255.0f;
        float g = ((argb >> 8) & 0xff) / 255.0f;
        float b = ((argb) & 0xff) / 255.0f;
        clearColor(r, g, b, a);
        clear(COLOR_BUFFER_BIT);
      } else if (!clear0) {


        int x = 0;
        int y = 0;
        if (presentMode) {
          x = (int)offsetX;
          y = (int)offsetY;
        }
        float scale = pg.getPixelScale();
        drawTexture(TEXTURE_2D, glColorTex.get(frontTex), fboWidth, fboHeight,
                    x, y, pg.width, pg.height,
                    0, 0, (int)(scale * pg.width), (int)(scale * pg.height),
                    0, 0, pg.width, pg.height);
      }

      fboLayerInUse = true;
    } else {
      fboLayerInUse = false;
    }

    if (firstFrame) {
      firstFrame = false;
    }









  }


  IntBuffer labelTex;
  protected void endDraw(boolean clear0, int windowColor) {
    if (fboLayerInUse) {
      syncBackTexture();


      bindFramebufferImpl(FRAMEBUFFER, 0);

      if (presentMode) {
        int argb = windowColor;
        float a = ((argb >> 24) & 0xff)  / 255.0f;
        float r = ((argb >> 16) & 0xff) / 255.0f;
        float g = ((argb >> 8) & 0xff) / 255.0f;
        float b = (argb & 0xff) / 255.0f;
        clearDepth(1);
        clearColor(r, g, b, a);
        clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);

        if (labelTex == null) {
          labelTex = allocateIntBuffer(1);
          genTextures(1, labelTex);
          bindTexture(TEXTURE_2D, labelTex.get(0));
          texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
          texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
          texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
          texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
          texImage2D(TEXTURE_2D, 0, RGBA, 100, 50, 0, RGBA, UNSIGNED_BYTE, null);








          IntBuffer buf = allocateIntBuffer(labelPix);
          copyToTexture(TEXTURE_2D, RGBA, labelTex.get(0), 0, 0, 100, 50, buf);
          bindTexture(TEXTURE_2D, 0);
        }
        drawTexture(TEXTURE_2D, labelTex.get(0), 100, 50,
                    0, 0, 20 + 100, 20 + 50,
                    0, 50, 100, 0,
                    20, 20, 20 + 100, 20 + 50);



      } else {
        clearDepth(1);
        clearColor(0, 0, 0, 0);
        clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      }


      disable(BLEND);
      int x = 0;
      int y = 0;
      if (presentMode) {
        x = (int)offsetX;
        y = (int)offsetY;
      }
      float scale = pg.getPixelScale();
      drawTexture(TEXTURE_2D, glColorTex.get(backTex),
                  fboWidth, fboHeight,
                  x, y, pg.width, pg.height,
                  0, 0, (int)(scale * pg.width), (int)(scale * pg.height),
                  0, 0, pg.width, pg.height);


      int temp = frontTex;
      frontTex = backTex;
      backTex = temp;
    }
  }


  protected abstract void getGL(PGL pgl);














  public boolean threadIsCurrent()  {
    return Thread.currentThread() == glThread;
  }


  public void setThread(Thread thread) {
    glThread = thread;
  }


  protected void beginGL() { }


  protected void endGL() { }


  private boolean needFBOLayer(boolean clear0) {





    return fboLayerRequested;
  }


  private void createFBOLayer() {
    String ext = getString(EXTENSIONS);
    float scale = pg.getPixelScale();

    if (-1 < ext.indexOf("texture_non_power_of_two")) {
      fboWidth = (int)(scale * pg.width);
      fboHeight = (int)(scale * pg.height);
    } else {
      fboWidth = nextPowerOfTwo((int)(scale * pg.width));
      fboHeight = nextPowerOfTwo((int)(scale * pg.height));
    }

    int maxs = maxSamples();
    if (-1 < ext.indexOf("_framebuffer_multisample") && 1 < maxs) {
      numSamples = PApplet.min(reqNumSamples, maxs);
    } else {
      numSamples = 1;
    }
    boolean multisample = 1 < numSamples;

    boolean packed = ext.indexOf("packed_depth_stencil") != -1;
    int depthBits = PApplet.min(REQUESTED_DEPTH_BITS, getDepthBits());
    int stencilBits = PApplet.min(REQUESTED_STENCIL_BITS, getStencilBits());

    genTextures(2, glColorTex);
    for (int i = 0; i < 2; i++) {
      bindTexture(TEXTURE_2D, glColorTex.get(i));
      texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
      texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
      texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
      texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
      texImage2D(TEXTURE_2D, 0, RGBA, fboWidth, fboHeight, 0,
                 RGBA, UNSIGNED_BYTE, null);
      initTexture(TEXTURE_2D, RGBA, fboWidth, fboHeight, pg.backgroundColor);
    }
    bindTexture(TEXTURE_2D, 0);

    backTex = 0;
    frontTex = 1;

    genFramebuffers(1, glColorFbo);
    bindFramebufferImpl(FRAMEBUFFER, glColorFbo.get(0));
    framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0, TEXTURE_2D,
                         glColorTex.get(backTex), 0);

    if (multisample) {

      genFramebuffers(1, glMultiFbo);
      bindFramebufferImpl(FRAMEBUFFER, glMultiFbo.get(0));


      genRenderbuffers(1, glColorBuf);
      bindRenderbuffer(RENDERBUFFER, glColorBuf.get(0));
      renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                     RGBA8, fboWidth, fboHeight);
      framebufferRenderbuffer(FRAMEBUFFER, COLOR_ATTACHMENT0,
                              RENDERBUFFER, glColorBuf.get(0));
    }


    if (packed && depthBits == 24 && stencilBits == 8) {

      genRenderbuffers(1, glDepthStencil);
      bindRenderbuffer(RENDERBUFFER, glDepthStencil.get(0));
      if (multisample) {
        renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                       DEPTH24_STENCIL8, fboWidth, fboHeight);
      } else {
        renderbufferStorage(RENDERBUFFER, DEPTH24_STENCIL8,
                            fboWidth, fboHeight);
      }
      framebufferRenderbuffer(FRAMEBUFFER, DEPTH_ATTACHMENT, RENDERBUFFER,
                              glDepthStencil.get(0));
      framebufferRenderbuffer(FRAMEBUFFER, STENCIL_ATTACHMENT, RENDERBUFFER,
                              glDepthStencil.get(0));
    } else {

      if (0 < depthBits) {
        int depthComponent = DEPTH_COMPONENT16;
        if (depthBits == 32) {
          depthComponent = DEPTH_COMPONENT32;
        } else if (depthBits == 24) {
          depthComponent = DEPTH_COMPONENT24;
        } else if (depthBits == 16) {
          depthComponent = DEPTH_COMPONENT16;
        }

        genRenderbuffers(1, glDepth);
        bindRenderbuffer(RENDERBUFFER, glDepth.get(0));
        if (multisample) {
          renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                         depthComponent, fboWidth, fboHeight);
        } else {
          renderbufferStorage(RENDERBUFFER, depthComponent,
                              fboWidth, fboHeight);
        }
        framebufferRenderbuffer(FRAMEBUFFER, DEPTH_ATTACHMENT,
                                RENDERBUFFER, glDepth.get(0));
      }

      if (0 < stencilBits) {
        int stencilIndex = STENCIL_INDEX1;
        if (stencilBits == 8) {
          stencilIndex = STENCIL_INDEX8;
        } else if (stencilBits == 4) {
          stencilIndex = STENCIL_INDEX4;
        } else if (stencilBits == 1) {
          stencilIndex = STENCIL_INDEX1;
        }

        genRenderbuffers(1, glStencil);
        bindRenderbuffer(RENDERBUFFER, glStencil.get(0));
        if (multisample) {
          renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                         stencilIndex, fboWidth, fboHeight);
        } else {
          renderbufferStorage(RENDERBUFFER, stencilIndex,
                              fboWidth, fboHeight);
        }
        framebufferRenderbuffer(FRAMEBUFFER, STENCIL_ATTACHMENT,
                                RENDERBUFFER, glStencil.get(0));
      }
    }

    validateFramebuffer();


    clearDepth(1);
    clearStencil(0);
    int argb = pg.backgroundColor;
    float a = ((argb >> 24) & 0xff) / 255.0f;
    float r = ((argb >> 16) & 0xff) / 255.0f;
    float g = ((argb >> 8) & 0xff) / 255.0f;
    float b = ((argb) & 0xff) / 255.0f;
    clearColor(r, g, b, a);
    clear(DEPTH_BUFFER_BIT | STENCIL_BUFFER_BIT | COLOR_BUFFER_BIT);

    bindFramebufferImpl(FRAMEBUFFER, 0);

    fboLayerCreated = true;
  }







  protected int createEmptyContext() {
    return -1;
  }


  protected int getCurrentContext() {
    return glContext;
  }







  protected boolean contextIsCurrent(int other) {
    return other == -1 || other == glContext;
  }


  protected void enableTexturing(int target) {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = true;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = true;
    }
  }


  protected void disableTexturing(int target) {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = false;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = false;
    }
  }


  protected boolean texturingIsEnabled(int target) {
    if (target == TEXTURE_2D) {
      return texturingTargets[0];
    } else if (target == TEXTURE_RECTANGLE) {
      return texturingTargets[1];
    } else {
      return false;
    }
  }


  protected boolean textureIsBound(int target, int id) {
    if (boundTextures == null) return false;

    if (target == TEXTURE_2D) {
      return boundTextures[activeTexUnit][0] == id;
    } else if (target == TEXTURE_RECTANGLE) {
      return boundTextures[activeTexUnit][1] == id;
    } else {
      return false;
    }
  }


  protected void initTexture(int target, int format, int width, int height) {
    initTexture(target, format, width, height, 0);
  }


  protected void initTexture(int target, int format, int width, int height,
                            int initColor) {
    int[] glcolor = new int[16 * 16];
    Arrays.fill(glcolor, javaToNativeARGB(initColor));
    IntBuffer texels = allocateDirectIntBuffer(16 * 16);
    texels.put(glcolor);
    texels.rewind();
    for (int y = 0; y < height; y += 16) {
      int h = PApplet.min(16, height - y);
      for (int x = 0; x < width; x += 16) {
        int w = PApplet.min(16, width - x);
        texSubImage2D(target, 0, x, y, w, h, format, UNSIGNED_BYTE, texels);
      }
    }
  }


  protected void copyToTexture(int target, int format, int id, int x, int y,
                               int w, int h, int[] buffer) {
    copyToTexture(target, format, id, x, y, w, h, IntBuffer.wrap(buffer));

  }

  protected void copyToTexture(int target, int format, int id, int x, int y,
                               int w, int h, IntBuffer buffer) {
    activeTexture(TEXTURE0);
    boolean enabledTex = false;
    if (!texturingIsEnabled(target)) {
      enableTexturing(target);
      enabledTex = true;
    }
    bindTexture(target, id);
    texSubImage2D(target, 0, x, y, w, h, format, UNSIGNED_BYTE, buffer);
    bindTexture(target, 0);
    if (enabledTex) {
      disableTexturing(target);
    }
  }



  public void drawTexture(int target, int id, int width, int height,
                          int X0, int Y0, int X1, int Y1) {
    drawTexture(target, id, width, height,
                0, 0, width, height,
                X0, Y0, X1, Y1,
                X0, Y0, X1, Y1);
  }



  public void drawTexture(int target, int id,int texW, int texH,
                          int viewX, int viewY, int scrW, int scrH,
                          int texX0, int texY0, int texX1, int texY1,
                          int scrX0, int scrY0, int scrX1, int scrY1) {
    if (target == TEXTURE_2D) {
      drawTexture2D(id, texW, texH,
                    viewX, viewY, scrW, scrH,
                    texX0, texY0, texX1, texY1,
                    scrX0, scrY0, scrX1, scrY1);
    } else if (target == TEXTURE_RECTANGLE) {
      drawTextureRect(id, texW, texH,
                      viewX, viewY, scrW, scrH,
                      texX0, texY0, texX1, texY1,
                      scrX0, scrY0, scrX1, scrY1);
    }
  }


  protected PGL initTex2DShader() {
    PGL ppgl = primaryPGL ? this : pg.getPrimaryPGL();

    if (!ppgl.loadedTex2DShader || ppgl.tex2DShaderContext != ppgl.glContext) {
      String vertSource = PApplet.join(texVertShaderSource, "\n");
      String fragSource = PApplet.join(tex2DFragShaderSource, "\n");
      ppgl.tex2DVertShader = createShader(VERTEX_SHADER, vertSource);
      ppgl.tex2DFragShader = createShader(FRAGMENT_SHADER, fragSource);
      if (0 < ppgl.tex2DVertShader && 0 < ppgl.tex2DFragShader) {
        ppgl.tex2DShaderProgram = createProgram(ppgl.tex2DVertShader, ppgl.tex2DFragShader);
      }
      if (0 < ppgl.tex2DShaderProgram) {
        ppgl.tex2DVertLoc = getAttribLocation(ppgl.tex2DShaderProgram, "position");
        ppgl.tex2DTCoordLoc = getAttribLocation(ppgl.tex2DShaderProgram, "texCoord");
        ppgl.tex2DSamplerLoc = getUniformLocation(ppgl.tex2DShaderProgram, "texMap");
      }
      ppgl.loadedTex2DShader = true;
      ppgl.tex2DShaderContext = ppgl.glContext;

      genBuffers(1, intBuffer);
      ppgl.tex2DGeoVBO = intBuffer.get(0);
      bindBuffer(ARRAY_BUFFER, ppgl.tex2DGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, null, STATIC_DRAW);
    }

    if (texData == null) {
      texData = allocateDirectFloatBuffer(texCoords.length);
    }

    return ppgl;
  }


  protected void drawTexture2D(int id, int texW, int texH,
                               int viewX, int viewY, int scrW, int scrH,
                               int texX0, int texY0, int texX1, int texY1,
                               int scrX0, int scrY0, int scrX1, int scrY1) {
    PGL ppgl = initTex2DShader();

    if (0 < ppgl.tex2DShaderProgram) {

      boolean depthTest = getDepthTest();
      disable(DEPTH_TEST);





      boolean depthMask = getDepthWriteMask();
      depthMask(false);


      viewBuffer.rewind();
      getIntegerv(VIEWPORT, viewBuffer);
      viewport(viewX, viewY, scrW, scrH);

      useProgram(ppgl.tex2DShaderProgram);

      enableVertexAttribArray(ppgl.tex2DVertLoc);
      enableVertexAttribArray(ppgl.tex2DTCoordLoc);




      texCoords[ 0] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 1] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 2] = (float)texX0 / texW;
      texCoords[ 3] = (float)texY0 / texH;

      texCoords[ 4] = 2 * (float)scrX1 / scrW - 1;
      texCoords[ 5] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 6] = (float)texX1 / texW;
      texCoords[ 7] = (float)texY0 / texH;

      texCoords[ 8] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 9] = 2 * (float)scrY1 / scrH - 1;
      texCoords[10] = (float)texX0 / texW;
      texCoords[11] = (float)texY1 / texH;

      texCoords[12] = 2 * (float)scrX1 / scrW - 1;
      texCoords[13] = 2 * (float)scrY1 / scrH - 1;
      texCoords[14] = (float)texX1 / texW;
      texCoords[15] = (float)texY1 / texH;

      texData.rewind();
      texData.put(texCoords);

      activeTexture(TEXTURE0);
      boolean enabledTex = false;
      if (!texturingIsEnabled(TEXTURE_2D)) {
        enableTexturing(TEXTURE_2D);
        enabledTex = true;
      }
      bindTexture(TEXTURE_2D, id);
      uniform1i(ppgl.tex2DSamplerLoc, 0);

      texData.position(0);
      bindBuffer(ARRAY_BUFFER, ppgl.tex2DGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, texData, STATIC_DRAW);

      vertexAttribPointer(ppgl.tex2DVertLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 0);
      vertexAttribPointer(ppgl.tex2DTCoordLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 2 * SIZEOF_FLOAT);

      drawArrays(TRIANGLE_STRIP, 0, 4);

      bindBuffer(ARRAY_BUFFER, 0); 

      bindTexture(TEXTURE_2D, 0);
      if (enabledTex) {
        disableTexturing(TEXTURE_2D);
      }

      disableVertexAttribArray(ppgl.tex2DVertLoc);
      disableVertexAttribArray(ppgl.tex2DTCoordLoc);

      useProgram(0);

      if (depthTest) {
        enable(DEPTH_TEST);
      } else {
        disable(DEPTH_TEST);
      }
      depthMask(depthMask);

      viewport(viewBuffer.get(0), viewBuffer.get(1),
               viewBuffer.get(2), viewBuffer.get(3));
    }
  }


  protected PGL initTexRectShader() {
    PGL ppgl = primaryPGL ? this : pg.getPrimaryPGL();

    if (!ppgl.loadedTexRectShader || ppgl.texRectShaderContext != ppgl.glContext) {
      String vertSource = PApplet.join(texVertShaderSource, "\n");
      String fragSource = PApplet.join(texRectFragShaderSource, "\n");
      ppgl.texRectVertShader = createShader(VERTEX_SHADER, vertSource);
      ppgl.texRectFragShader = createShader(FRAGMENT_SHADER, fragSource);
      if (0 < ppgl.texRectVertShader && 0 < ppgl.texRectFragShader) {
        ppgl.texRectShaderProgram = createProgram(ppgl.texRectVertShader,
                                                  ppgl.texRectFragShader);
      }
      if (0 < ppgl.texRectShaderProgram) {
        ppgl.texRectVertLoc = getAttribLocation(ppgl.texRectShaderProgram, "position");
        ppgl.texRectTCoordLoc = getAttribLocation(ppgl.texRectShaderProgram, "texCoord");
        ppgl.texRectSamplerLoc = getUniformLocation(ppgl.texRectShaderProgram, "texMap");
      }
      ppgl.loadedTexRectShader = true;
      ppgl.texRectShaderContext = ppgl.glContext;

      genBuffers(1, intBuffer);
      ppgl.texRectGeoVBO = intBuffer.get(0);
      bindBuffer(ARRAY_BUFFER, ppgl.texRectGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, null, STATIC_DRAW);
    }

    return ppgl;
  }


  protected void drawTextureRect(int id, int texW, int texH,
                                 int viewX, int viewY, int scrW, int scrH,
                                 int texX0, int texY0, int texX1, int texY1,
                                 int scrX0, int scrY0, int scrX1, int scrY1) {
    PGL ppgl = initTexRectShader();

    if (texData == null) {
      texData = allocateDirectFloatBuffer(texCoords.length);
    }

    if (0 < ppgl.texRectShaderProgram) {

      boolean depthTest = getDepthTest();
      disable(DEPTH_TEST);





      boolean depthMask = getDepthWriteMask();
      depthMask(false);


      viewBuffer.rewind();
      getIntegerv(VIEWPORT, viewBuffer);
      viewport(viewX, viewY, scrW, scrH);

      useProgram(ppgl.texRectShaderProgram);

      enableVertexAttribArray(ppgl.texRectVertLoc);
      enableVertexAttribArray(ppgl.texRectTCoordLoc);




      texCoords[ 0] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 1] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 2] = texX0;
      texCoords[ 3] = texY0;

      texCoords[ 4] = 2 * (float)scrX1 / scrW - 1;
      texCoords[ 5] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 6] = texX1;
      texCoords[ 7] = texY0;

      texCoords[ 8] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 9] = 2 * (float)scrY1 / scrH - 1;
      texCoords[10] = texX0;
      texCoords[11] = texY1;

      texCoords[12] = 2 * (float)scrX1 / scrW - 1;
      texCoords[13] = 2 * (float)scrY1 / scrH - 1;
      texCoords[14] = texX1;
      texCoords[15] = texY1;

      texData.rewind();
      texData.put(texCoords);

      activeTexture(TEXTURE0);
      boolean enabledTex = false;
      if (!texturingIsEnabled(TEXTURE_RECTANGLE)) {
        enableTexturing(TEXTURE_RECTANGLE);
        enabledTex = true;
      }
      bindTexture(TEXTURE_RECTANGLE, id);
      uniform1i(ppgl.texRectSamplerLoc, 0);

      texData.position(0);
      bindBuffer(ARRAY_BUFFER, ppgl.texRectGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, texData, STATIC_DRAW);

      vertexAttribPointer(ppgl.texRectVertLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 0);
      vertexAttribPointer(ppgl.texRectTCoordLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 2 * SIZEOF_FLOAT);

      drawArrays(TRIANGLE_STRIP, 0, 4);

      bindBuffer(ARRAY_BUFFER, 0); 

      bindTexture(TEXTURE_RECTANGLE, 0);
      if (enabledTex) {
        disableTexturing(TEXTURE_RECTANGLE);
      }

      disableVertexAttribArray(ppgl.texRectVertLoc);
      disableVertexAttribArray(ppgl.texRectTCoordLoc);

      useProgram(0);

      if (depthTest) {
        enable(DEPTH_TEST);
      } else {
        disable(DEPTH_TEST);
      }
      depthMask(depthMask);

      viewport(viewBuffer.get(0), viewBuffer.get(1),
               viewBuffer.get(2), viewBuffer.get(3));
    }
  }


  protected int getColorValue(int scrX, int scrY) {
    if (colorBuffer == null) {
      colorBuffer = IntBuffer.allocate(1);
    }
    colorBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, RGBA, UNSIGNED_BYTE,
               colorBuffer);
    return colorBuffer.get();
  }


  protected float getDepthValue(int scrX, int scrY) {
    if (depthBuffer == null) {
      depthBuffer = FloatBuffer.allocate(1);
    }
    depthBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, DEPTH_COMPONENT, FLOAT,
               depthBuffer);
    return depthBuffer.get(0);
  }


  protected byte getStencilValue(int scrX, int scrY) {
    if (stencilBuffer == null) {
      stencilBuffer = ByteBuffer.allocate(1);
    }
    stencilBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, STENCIL_INDEX,
               UNSIGNED_BYTE, stencilBuffer);
    return stencilBuffer.get(0);
  }


  protected static boolean isPowerOfTwo(int val) {
    return (val & (val - 1)) == 0;
  }



  protected static int nextPowerOfTwo(int val) {
    int ret = 1;
    while (ret < val) ret <<= 1;
    return ret;
  }



  protected static int nativeToJavaARGB(int color) {
    if (BIG_ENDIAN) { 
      return (color >>> 8) | ((color << 24) & 0xFF000000);


    } else { 
      return ((color & 0xFF) << 16) | ((color & 0xFF0000) >> 16) |
             (color & 0xFF00FF00);
    }
  }



  protected static void nativeToJavaARGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixy >>> 8) | ((pixy << 24) & 0xFF000000);
          pixels[yindex] = (pixi >>> 8) | ((pixi << 24) & 0xFF000000);
        } else { 
          pixels[index] = ((pixy & 0xFF) << 16) | ((pixy & 0xFF0000) >> 16) |
                          (pixy & 0xFF00FF00);
          pixels[yindex] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                           (pixi & 0xFF00FF00);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixi >>> 8) | ((pixi << 24) & 0xFF000000);
        } else { 
          pixels[index] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                          (pixi & 0xFF00FF00);
        }
        index++;
      }
    }
  }



  protected static int nativeToJavaRGB(int color) {
    if (BIG_ENDIAN) { 
      return (color >>> 8) | 0xFF000000;
    } else { 
      return ((color & 0xFF) << 16) | ((color & 0xFF0000) >> 16) |
             (color & 0xFF00FF00) | 0xFF000000;
    }
  }



  protected static void nativeToJavaRGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixy >>> 8) | 0xFF000000;
          pixels[yindex] = (pixi >>> 8) | 0xFF000000;
        } else { 
          pixels[index] = ((pixy & 0xFF) << 16) | ((pixy & 0xFF0000) >> 16) |
                          (pixy & 0xFF00FF00) | 0xFF000000;
          pixels[yindex] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                           (pixi & 0xFF00FF00) | 0xFF000000;
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixi >>> 8) | 0xFF000000;
        } else { 
          pixels[index] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                          (pixi & 0xFF00FF00) | 0xFF000000;
        }
        index++;
      }
    }
  }



  protected static int javaToNativeARGB(int color) {
    if (BIG_ENDIAN) { 
      return ((color >> 24) & 0xFF) | ((color << 8) & 0xFFFFFF00);
    } else { 
      return (color & 0xFF000000) | ((color << 16) & 0xFF0000) |
             (color & 0xFF00) | ((color >> 16) & 0xFF);
    }
  }



  protected static void javaToNativeARGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = ((pixy >> 24) & 0xFF) | ((pixy << 8) & 0xFFFFFF00);
          pixels[yindex] = ((pixi >> 24) & 0xFF) | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = (pixy & 0xFF000000) | ((pixy << 16) & 0xFF0000) |
                          (pixy & 0xFF00) | ((pixy >> 16) & 0xFF);
          pixels[yindex] = (pixi & 0xFF000000) | ((pixi << 16) & 0xFF0000) |
                           (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = ((pixi >> 24) & 0xFF) | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = (pixi & 0xFF000000) | ((pixi << 16) & 0xFF0000) |
                          (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
      }
    }
  }



  protected static int javaToNativeRGB(int color) {
    if (BIG_ENDIAN) { 
      return 0xFF | ((color << 8) & 0xFFFFFF00);
    } else { 
      return 0xFF000000 | ((color << 16) & 0xFF0000) |
             (color & 0xFF00) | ((color >> 16) & 0xFF);
    }
  }



  protected static void javaToNativeRGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = 0xFF | ((pixy << 8) & 0xFFFFFF00);
          pixels[yindex] = 0xFF | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = 0xFF000000 | ((pixy << 16) & 0xFF0000) |
                          (pixy & 0xFF00) | ((pixy >> 16) & 0xFF);
          pixels[yindex] = 0xFF000000 | ((pixi << 16) & 0xFF0000) |
                           (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = 0xFF | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = 0xFF000000 | ((pixi << 16) & 0xFF0000) |
                          (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
      }
    }
  }


  protected static int qualityToSamples(int quality) {
    if (quality <= 1) {
      return 1;
    } else {

      int n = 2 * (quality / 2);
      return n;
    }
  }


  protected String[] loadVertexShader(String filename) {
    return pg.parent.loadStrings(filename);
  }


  protected String[] loadFragmentShader(String filename) {
    return pg.parent.loadStrings(filename);
  }


  protected String[] loadFragmentShader(URL url) {
    try {
      return PApplet.loadStrings(url.openStream());
    } catch (IOException e) {
      PGraphics.showException("Cannot load fragment shader " + url.getFile());
    }
    return null;
  }


  protected String[] loadVertexShader(URL url) {
    try {
      return PApplet.loadStrings(url.openStream());
    } catch (IOException e) {
      PGraphics.showException("Cannot load vertex shader " + url.getFile());
    }
    return null;
  }


  protected String[] loadVertexShader(String filename, int version) {
    return loadVertexShader(filename);
  }


  protected String[] loadFragmentShader(String filename, int version) {
    return loadFragmentShader(filename);
  }


  protected String[] loadFragmentShader(URL url, int version) {
    return loadFragmentShader(url);
  }


  protected String[] loadVertexShader(URL url, int version) {
    return loadVertexShader(url);
  }


  protected static String[] convertFragmentSource(String[] fragSrc0,
                                                  int version0, int version1) {
    if (version0 == 120 && version1 == 150) {
      String[] fragSrc = new String[fragSrc0.length + 2];
      fragSrc[0] = "#version 150";
      fragSrc[1] = "out vec4 fragColor;";
      for (int i = 0; i < fragSrc0.length; i++) {
        String line = fragSrc0[i];
        line = line.replace("varying", "in");
        line = line.replace("attribute", "in");
        line = line.replace("gl_FragColor", "fragColor");
        line = line.replace("texture", "texMap");
        line = line.replace("texMap2D(", "texture(");
        line = line.replace("texMap2DRect(", "texture(");
        fragSrc[i + 2] = line;
      }
      return fragSrc;
    }
    return fragSrc0;
  }



  protected static String[] convertVertexSource(String[] vertSrc0,
                                                int version0, int version1) {
    if (version0 == 120 && version1 == 150) {
      String[] vertSrc = new String[vertSrc0.length + 1];
      vertSrc[0] = "#version 150";
      for (int i = 0; i < vertSrc0.length; i++) {
        String line = vertSrc0[i];
        line = line.replace("attribute", "in");
        line = line.replace("varying", "out");
        vertSrc[i + 1] = line;
      }
      return vertSrc;
    }
    return vertSrc0;
  }

  protected int createShader(int shaderType, String source) {
    int shader = createShader(shaderType);
    if (shader != 0) {
      shaderSource(shader, source);
      compileShader(shader);
      if (!compiled(shader)) {
        System.err.println("Could not compile shader " + shaderType + ":");
        System.err.println(getShaderInfoLog(shader));
        deleteShader(shader);
        shader = 0;
      }
    }
    return shader;
  }


  protected int createProgram(int vertexShader, int fragmentShader) {
    int program = createProgram();
    if (program != 0) {
      attachShader(program, vertexShader);
      attachShader(program, fragmentShader);
      linkProgram(program);
      if (!linked(program)) {
        System.err.println("Could not link program: ");
        System.err.println(getProgramInfoLog(program));
        deleteProgram(program);
        program = 0;
      }
    }
    return program;
  }


  protected boolean compiled(int shader) {
    intBuffer.rewind();
    getShaderiv(shader, COMPILE_STATUS, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean linked(int program) {
    intBuffer.rewind();
    getProgramiv(program, LINK_STATUS, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean validateFramebuffer() {
    int status = checkFramebufferStatus(FRAMEBUFFER);
    if (status == FRAMEBUFFER_COMPLETE) {
      return true;
    } else if (status == FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete attachment"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete missing attachment"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete dimensions"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_FORMATS) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete formats"));
    } else if (status == FRAMEBUFFER_UNSUPPORTED) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "framebuffer unsupported"));
    } else {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "unknown error"));
    }
    return false;
  }


  protected int[] getGLVersion() {
    String version = getString(VERSION).trim();
    int[] res = {0, 0, 0};
    String[] parts = version.split(" ");
    for (int i = 0; i < parts.length; i++) {
      if (0 < parts[i].indexOf(".")) {
        String nums[] = parts[i].split("\\.");
        try {
          res[0] = Integer.parseInt(nums[0]);
        } catch (NumberFormatException e) { }
        if (1 < nums.length) {
          try {
            res[1] = Integer.parseInt(nums[1]);
          } catch (NumberFormatException e) { }
        }
        if (2 < nums.length) {
          try {
            res[2] = Integer.parseInt(nums[2]);
          } catch (NumberFormatException e) { }
        }
        break;
      }
    }
    return res;
  }


  protected boolean hasFBOs() {

    int major = getGLVersion()[0];
    if (major < 2) {
      String ext = getString(EXTENSIONS);
      return ext.indexOf("_framebuffer_object") != -1 &&
             ext.indexOf("_vertex_shader")      != -1 &&
             ext.indexOf("_shader_objects")     != -1 &&
             ext.indexOf("_shading_language")   != -1;
    } else {
      return true;
    }
  }


  protected boolean hasShaders() {



    int major = getGLVersion()[0];
    if (major < 2) {
      String ext = getString(EXTENSIONS);
      return ext.indexOf("_fragment_shader")  != -1 &&
             ext.indexOf("_vertex_shader")    != -1 &&
             ext.indexOf("_shader_objects")   != -1 &&
             ext.indexOf("_shading_language") != -1;
    } else {
      return true;
    }
  }


  protected boolean hasNpotTexSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_texture_non_power_of_two");
    } else {
      return true;
    }
  }


  protected boolean hasAutoMipmapGenSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_generate_mipmap");
    } else {
      return true;
    }
  }


  protected boolean hasFboMultisampleSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_framebuffer_multisample");
    } else {
      return true;
    }
  }


  protected boolean hasPackedDepthStencilSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_packed_depth_stencil");
    } else {
      return true;
    }
  }


  protected boolean hasAnisoSamplingSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_texture_filter_anisotropic");
    } else {
      return true;
    }
  }


  protected int maxSamples() {
    intBuffer.rewind();
    getIntegerv(MAX_SAMPLES, intBuffer);
    return intBuffer.get(0);
  }


  protected int getMaxTexUnits() {
    intBuffer.rewind();
    getIntegerv(MAX_TEXTURE_IMAGE_UNITS, intBuffer);
    return intBuffer.get(0);
  }


  protected static ByteBuffer allocateDirectByteBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_BYTE;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder());
  }


  protected static ByteBuffer allocateByteBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectByteBuffer(size);
    } else {
      return ByteBuffer.allocate(size);
    }
  }


  protected static ByteBuffer allocateByteBuffer(byte[] arr) {
    if (USE_DIRECT_BUFFERS) {
      ByteBuffer buf = allocateDirectByteBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return ByteBuffer.wrap(arr);
    }
  }


  protected static ByteBuffer updateByteBuffer(ByteBuffer buf, byte[] arr,
                                               boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectByteBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = ByteBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = ByteBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateByteBuffer(ByteBuffer buf, byte[] arr,
                                         int offset, int size) {
    if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
      buf.position(offset);
      buf.put(arr, offset, size);
      buf.rewind();
    }
  }


  protected static void getByteArray(ByteBuffer buf, byte[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putByteArray(ByteBuffer buf, byte[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillByteBuffer(ByteBuffer buf, int i0, int i1,
                                       byte val) {
    int n = i1 - i0;
    byte[] temp = new byte[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static ShortBuffer allocateDirectShortBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_SHORT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asShortBuffer();
  }


  protected static ShortBuffer allocateShortBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectShortBuffer(size);
    } else {
      return ShortBuffer.allocate(size);
    }
  }


  protected static ShortBuffer allocateShortBuffer(short[] arr) {
    if (USE_DIRECT_BUFFERS) {
      ShortBuffer buf = allocateDirectShortBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return ShortBuffer.wrap(arr);
    }
  }


  protected static ShortBuffer updateShortBuffer(ShortBuffer buf, short[] arr,
                                                 boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectShortBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = ShortBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = ShortBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateShortBuffer(ShortBuffer buf, short[] arr,
                                          int offset, int size) {
    if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
      buf.position(offset);
      buf.put(arr, offset, size);
      buf.rewind();
    }
  }


  protected static void getShortArray(ShortBuffer buf, short[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putShortArray(ShortBuffer buf, short[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillShortBuffer(ShortBuffer buf, int i0, int i1,
                                        short val) {
    int n = i1 - i0;
    short[] temp = new short[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static IntBuffer allocateDirectIntBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_INT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asIntBuffer();
  }


  protected static IntBuffer allocateIntBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectIntBuffer(size);
    } else {
      return IntBuffer.allocate(size);
    }
  }


  protected static IntBuffer allocateIntBuffer(int[] arr) {
    if (USE_DIRECT_BUFFERS) {
      IntBuffer buf = allocateDirectIntBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return IntBuffer.wrap(arr);
    }
  }


  protected static IntBuffer updateIntBuffer(IntBuffer buf, int[] arr,
                                             boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectIntBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = IntBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = IntBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateIntBuffer(IntBuffer buf, int[] arr,
                                        int offset, int size) {
     if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
       buf.position(offset);
       buf.put(arr, offset, size);
       buf.rewind();
     }
   }


  protected static void getIntArray(IntBuffer buf, int[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putIntArray(IntBuffer buf, int[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillIntBuffer(IntBuffer buf, int i0, int i1, int val) {
    int n = i1 - i0;
    int[] temp = new int[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static FloatBuffer allocateDirectFloatBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_FLOAT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asFloatBuffer();
  }


  protected static FloatBuffer allocateFloatBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectFloatBuffer(size);
    } else {
      return FloatBuffer.allocate(size);
    }
  }


  protected static FloatBuffer allocateFloatBuffer(float[] arr) {
    if (USE_DIRECT_BUFFERS) {
      FloatBuffer buf = allocateDirectFloatBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return FloatBuffer.wrap(arr);
    }
  }


  protected static FloatBuffer updateFloatBuffer(FloatBuffer buf, float[] arr,
                                                 boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectFloatBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = FloatBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = FloatBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateFloatBuffer(FloatBuffer buf, float[] arr,
                                        int offset, int size) {
     if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
       buf.position(offset);
       buf.put(arr, offset, size);
       buf.rewind();
     }
   }


  protected static void getFloatArray(FloatBuffer buf, float[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putFloatArray(FloatBuffer buf, float[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillFloatBuffer(FloatBuffer buf, int i0, int i1,
                                        float val) {
    int n = i1 - i0;
    float[] temp = new float[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }





  abstract protected int getFontAscent(Object font);


  abstract protected int getFontDescent(Object font);


  abstract protected int getTextWidth(Object font, char[] buffer, int start, int stop);


  abstract protected Object getDerivedFont(Object font, float size);







  protected abstract Tessellator createTessellator(TessellatorCallback callback);


  protected interface Tessellator {
    public void beginPolygon();
    public void endPolygon();
    public void setWindingRule(int rule);
    public void beginContour();
    public void endContour();
    public void addVertex(double[] v);
  }


  protected interface TessellatorCallback  {
    public void begin(int type);
    public void end();
    public void vertex(Object data);
    public void combine(double[] coords, Object[] data,
                        float[] weight, Object[] outData);
    public void error(int errnum);
  }


  protected String tessError(int err) {
    return "";
  }







  protected static boolean SHAPE_TEXT_SUPPORTED;
  protected static int SEG_MOVETO;
  protected static int SEG_LINETO;
  protected static int SEG_QUADTO;
  protected static int SEG_CUBICTO;
  protected static int SEG_CLOSE;


  protected abstract FontOutline createFontOutline(char ch, Object font);


  protected interface FontOutline {
    public boolean isDone();
    public int currentSegment(float coords[]);
    public void next();
  }





































  public static int FALSE;
  public static int TRUE;

  public static int INT;
  public static int BYTE;
  public static int SHORT;
  public static int FLOAT;
  public static int BOOL;
  public static int UNSIGNED_INT;
  public static int UNSIGNED_BYTE;
  public static int UNSIGNED_SHORT;

  public static int RGB;
  public static int RGBA;
  public static int ALPHA;
  public static int LUMINANCE;
  public static int LUMINANCE_ALPHA;

  public static int UNSIGNED_SHORT_5_6_5;
  public static int UNSIGNED_SHORT_4_4_4_4;
  public static int UNSIGNED_SHORT_5_5_5_1;

  public static int RGBA4;
  public static int RGB5_A1;
  public static int RGB565;
  public static int RGB8;
  public static int RGBA8;
  public static int ALPHA8;

  public static int READ_ONLY;
  public static int WRITE_ONLY;
  public static int READ_WRITE;

  public static int TESS_WINDING_NONZERO;
  public static int TESS_WINDING_ODD;

  public static int GENERATE_MIPMAP_HINT;
  public static int FASTEST;
  public static int NICEST;
  public static int DONT_CARE;

  public static int VENDOR;
  public static int RENDERER;
  public static int VERSION;
  public static int EXTENSIONS;
  public static int SHADING_LANGUAGE_VERSION;

  public static int MAX_SAMPLES;
  public static int SAMPLES;

  public static int ALIASED_LINE_WIDTH_RANGE;
  public static int ALIASED_POINT_SIZE_RANGE;

  public static int DEPTH_BITS;
  public static int STENCIL_BITS;

  public static int CCW;
  public static int CW;

  public static int VIEWPORT;

  public static int ARRAY_BUFFER;
  public static int ELEMENT_ARRAY_BUFFER;

  public static int MAX_VERTEX_ATTRIBS;

  public static int STATIC_DRAW;
  public static int DYNAMIC_DRAW;
  public static int STREAM_DRAW;

  public static int BUFFER_SIZE;
  public static int BUFFER_USAGE;

  public static int POINTS;
  public static int LINE_STRIP;
  public static int LINE_LOOP;
  public static int LINES;
  public static int TRIANGLE_FAN;
  public static int TRIANGLE_STRIP;
  public static int TRIANGLES;

  public static int CULL_FACE;
  public static int FRONT;
  public static int BACK;
  public static int FRONT_AND_BACK;

  public static int POLYGON_OFFSET_FILL;

  public static int UNPACK_ALIGNMENT;
  public static int PACK_ALIGNMENT;

  public static int TEXTURE_2D;
  public static int TEXTURE_RECTANGLE;

  public static int TEXTURE_BINDING_2D;
  public static int TEXTURE_BINDING_RECTANGLE;

  public static int MAX_TEXTURE_SIZE;
  public static int TEXTURE_MAX_ANISOTROPY;
  public static int MAX_TEXTURE_MAX_ANISOTROPY;

  public static int MAX_VERTEX_TEXTURE_IMAGE_UNITS;
  public static int MAX_TEXTURE_IMAGE_UNITS;
  public static int MAX_COMBINED_TEXTURE_IMAGE_UNITS;

  public static int NUM_COMPRESSED_TEXTURE_FORMATS;
  public static int COMPRESSED_TEXTURE_FORMATS;

  public static int NEAREST;
  public static int LINEAR;
  public static int LINEAR_MIPMAP_NEAREST;
  public static int LINEAR_MIPMAP_LINEAR;

  public static int CLAMP_TO_EDGE;
  public static int REPEAT;

  public static int TEXTURE0;
  public static int TEXTURE1;
  public static int TEXTURE2;
  public static int TEXTURE3;
  public static int TEXTURE_MIN_FILTER;
  public static int TEXTURE_MAG_FILTER;
  public static int TEXTURE_WRAP_S;
  public static int TEXTURE_WRAP_T;
  public static int TEXTURE_WRAP_R;

  public static int TEXTURE_CUBE_MAP;
  public static int TEXTURE_CUBE_MAP_POSITIVE_X;
  public static int TEXTURE_CUBE_MAP_POSITIVE_Y;
  public static int TEXTURE_CUBE_MAP_POSITIVE_Z;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_X;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_Y;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_Z;

  public static int VERTEX_SHADER;
  public static int FRAGMENT_SHADER;
  public static int INFO_LOG_LENGTH;
  public static int SHADER_SOURCE_LENGTH;
  public static int COMPILE_STATUS;
  public static int LINK_STATUS;
  public static int VALIDATE_STATUS;
  public static int SHADER_TYPE;
  public static int DELETE_STATUS;

  public static int FLOAT_VEC2;
  public static int FLOAT_VEC3;
  public static int FLOAT_VEC4;
  public static int FLOAT_MAT2;
  public static int FLOAT_MAT3;
  public static int FLOAT_MAT4;
  public static int INT_VEC2;
  public static int INT_VEC3;
  public static int INT_VEC4;
  public static int BOOL_VEC2;
  public static int BOOL_VEC3;
  public static int BOOL_VEC4;
  public static int SAMPLER_2D;
  public static int SAMPLER_CUBE;

  public static int LOW_FLOAT;
  public static int MEDIUM_FLOAT;
  public static int HIGH_FLOAT;
  public static int LOW_INT;
  public static int MEDIUM_INT;
  public static int HIGH_INT;

  public static int CURRENT_VERTEX_ATTRIB;

  public static int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
  public static int VERTEX_ATTRIB_ARRAY_ENABLED;
  public static int VERTEX_ATTRIB_ARRAY_SIZE;
  public static int VERTEX_ATTRIB_ARRAY_STRIDE;
  public static int VERTEX_ATTRIB_ARRAY_TYPE;
  public static int VERTEX_ATTRIB_ARRAY_NORMALIZED;
  public static int VERTEX_ATTRIB_ARRAY_POINTER;

  public static int BLEND;
  public static int ONE;
  public static int ZERO;
  public static int SRC_ALPHA;
  public static int DST_ALPHA;
  public static int ONE_MINUS_SRC_ALPHA;
  public static int ONE_MINUS_DST_COLOR;
  public static int ONE_MINUS_SRC_COLOR;
  public static int DST_COLOR;
  public static int SRC_COLOR;

  public static int SAMPLE_ALPHA_TO_COVERAGE;
  public static int SAMPLE_COVERAGE;

  public static int KEEP;
  public static int REPLACE;
  public static int INCR;
  public static int DECR;
  public static int INVERT;
  public static int INCR_WRAP;
  public static int DECR_WRAP;
  public static int NEVER;
  public static int ALWAYS;

  public static int EQUAL;
  public static int LESS;
  public static int LEQUAL;
  public static int GREATER;
  public static int GEQUAL;
  public static int NOTEQUAL;

  public static int FUNC_ADD;
  public static int FUNC_MIN;
  public static int FUNC_MAX;
  public static int FUNC_REVERSE_SUBTRACT;
  public static int FUNC_SUBTRACT;

  public static int DITHER;

  public static int CONSTANT_COLOR;
  public static int CONSTANT_ALPHA;
  public static int ONE_MINUS_CONSTANT_COLOR;
  public static int ONE_MINUS_CONSTANT_ALPHA;
  public static int SRC_ALPHA_SATURATE;

  public static int SCISSOR_TEST;
  public static int STENCIL_TEST;
  public static int DEPTH_TEST;
  public static int DEPTH_WRITEMASK;
  public static int ALPHA_TEST;

  public static int COLOR_BUFFER_BIT;
  public static int DEPTH_BUFFER_BIT;
  public static int STENCIL_BUFFER_BIT;

  public static int FRAMEBUFFER;
  public static int COLOR_ATTACHMENT0;
  public static int COLOR_ATTACHMENT1;
  public static int COLOR_ATTACHMENT2;
  public static int COLOR_ATTACHMENT3;
  public static int RENDERBUFFER;
  public static int DEPTH_ATTACHMENT;
  public static int STENCIL_ATTACHMENT;
  public static int READ_FRAMEBUFFER;
  public static int DRAW_FRAMEBUFFER;

  public static int DEPTH24_STENCIL8;

  public static int DEPTH_COMPONENT;
  public static int DEPTH_COMPONENT16;
  public static int DEPTH_COMPONENT24;
  public static int DEPTH_COMPONENT32;

  public static int STENCIL_INDEX;
  public static int STENCIL_INDEX1;
  public static int STENCIL_INDEX4;
  public static int STENCIL_INDEX8;

  public static int DEPTH_STENCIL;

  public static int FRAMEBUFFER_COMPLETE;
  public static int FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
  public static int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
  public static int FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
  public static int FRAMEBUFFER_INCOMPLETE_FORMATS;
  public static int FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER;
  public static int FRAMEBUFFER_INCOMPLETE_READ_BUFFER;
  public static int FRAMEBUFFER_UNSUPPORTED;

  public static int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
  public static int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
  public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
  public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;

  public static int RENDERBUFFER_WIDTH;
  public static int RENDERBUFFER_HEIGHT;
  public static int RENDERBUFFER_RED_SIZE;
  public static int RENDERBUFFER_GREEN_SIZE;
  public static int RENDERBUFFER_BLUE_SIZE;
  public static int RENDERBUFFER_ALPHA_SIZE;
  public static int RENDERBUFFER_DEPTH_SIZE;
  public static int RENDERBUFFER_STENCIL_SIZE;
  public static int RENDERBUFFER_INTERNAL_FORMAT;

  public static int MULTISAMPLE;
  public static int POINT_SMOOTH;
  public static int LINE_SMOOTH;
  public static int POLYGON_SMOOTH;





  public abstract void flush();
  public abstract void finish();
  public abstract void hint(int target, int hint);





  public abstract void enable(int value);
  public abstract void disable(int value);
  public abstract void getBooleanv(int value, IntBuffer data);
  public abstract void getIntegerv(int value, IntBuffer data);
  public abstract void getFloatv(int value, FloatBuffer data);
  public abstract boolean isEnabled(int value);
  public abstract String getString(int name);





  public abstract int getError();
  public abstract String errorString(int err);





  public abstract void genBuffers(int n, IntBuffer buffers);
  public abstract void deleteBuffers(int n, IntBuffer buffers);
  public abstract void bindBuffer(int target, int buffer);
  public abstract void bufferData(int target, int size, Buffer data, int usage);
  public abstract void bufferSubData(int target, int offset, int size, Buffer data);
  public abstract void isBuffer(int buffer);
  public abstract void getBufferParameteriv(int target, int value, IntBuffer data);
  public abstract ByteBuffer mapBuffer(int target, int access);
  public abstract ByteBuffer mapBufferRange(int target, int offset, int length, int access);
  public abstract void unmapBuffer(int target);





  public abstract void depthRangef(float n, float f);
  public abstract void viewport(int x, int y, int w, int h);









  public void readPixels(int x, int y, int width, int height, int format, int type, Buffer buffer){
    boolean pgCall = format != STENCIL_INDEX &&
                     format != DEPTH_COMPONENT && format != DEPTH_STENCIL;
    if (pgCall) pg.beginReadPixels();
    readPixelsImpl(x, y, width, height, format, type, buffer);
    if (pgCall) pg.endReadPixels();
  }

  protected abstract void readPixelsImpl(int x, int y, int width, int height, int format, int type, Buffer buffer);





  public abstract void vertexAttrib1f(int index, float value);
  public abstract void vertexAttrib2f(int index, float value0, float value1);
  public abstract void vertexAttrib3f(int index, float value0, float value1, float value2);
  public abstract void vertexAttrib4f(int index, float value0, float value1, float value2, float value3);
  public abstract void vertexAttrib1fv(int index, FloatBuffer values);
  public abstract void vertexAttrib2fv(int index, FloatBuffer values);
  public abstract void vertexAttrib3fv(int index, FloatBuffer values);
  public abstract void vertexAttri4fv(int index, FloatBuffer values);
  public abstract void vertexAttribPointer(int index, int size, int type, boolean normalized, int stride, int offset);
  public abstract void vertexAttribPointer(int index, int size, int type, boolean normalized, int stride, Buffer data);
  public abstract void enableVertexAttribArray(int index);
  public abstract void disableVertexAttribArray(int index);
  public abstract void drawArrays(int mode, int first, int count);
  public abstract void drawElements(int mode, int count, int type, int offset);
  public abstract void drawElements(int mode, int count, int type, Buffer indices);





  public abstract void lineWidth(float width);
  public abstract void frontFace(int dir);
  public abstract void cullFace(int mode);
  public abstract void polygonOffset(float factor, float units);





  public abstract void pixelStorei(int pname, int param);





  public abstract void texImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Buffer data);
  public abstract void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border);
  public abstract void texSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, Buffer data);
  public abstract void copyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height);
  public abstract void compressedTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int imageSize, Buffer data);
  public abstract void compressedTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int imageSize, Buffer data);
  public abstract void texParameteri(int target, int pname, int param);
  public abstract void texParameterf(int target, int pname, float param);
  public abstract void texParameteriv(int target, int pname, IntBuffer params);
  public abstract void texParameterfv(int target, int pname, FloatBuffer params);
  public abstract void generateMipmap(int target);
  public abstract void genTextures(int n, IntBuffer textures);
  public abstract void deleteTextures(int n, IntBuffer textures);
  public abstract void getTexParameteriv(int target, int pname, IntBuffer params);
  public abstract void getTexParameterfv(int target, int pname, FloatBuffer params);
  public abstract boolean isTexture(int texture);




  public void activeTexture(int texture) {
    activeTexUnit = texture - TEXTURE0;
    activeTextureImpl(texture);
  }

  protected abstract void activeTextureImpl(int texture);

  public void bindTexture(int target, int texture) {
    bindTextureImpl(target, texture);

    if (boundTextures == null) {
      maxTexUnits = getMaxTexUnits();
      boundTextures = new int[maxTexUnits][2];
    }

    if (maxTexUnits <= activeTexUnit) {
      throw new RuntimeException(TEXUNIT_ERROR);
    }

    if (target == TEXTURE_2D) {
      boundTextures[activeTexUnit][0] = texture;
    } else if (target == TEXTURE_RECTANGLE) {
      boundTextures[activeTexUnit][1] = texture;
    }
  }
  protected abstract void bindTextureImpl(int target, int texture);





  public abstract int createShader(int type);
  public abstract void shaderSource(int shader, String source);
  public abstract void compileShader(int shader);
  public abstract void releaseShaderCompiler();
  public abstract void deleteShader(int shader);
  public abstract void shaderBinary(int count, IntBuffer shaders, int binaryFormat, Buffer binary, int length);
  public abstract int createProgram();
  public abstract void attachShader(int program, int shader);
  public abstract void detachShader(int program, int shader);
  public abstract void linkProgram(int program);
  public abstract void useProgram(int program);
  public abstract void deleteProgram(int program);
  public abstract String getActiveAttrib(int program, int index, IntBuffer size, IntBuffer type);
  public abstract int getAttribLocation(int program, String name);
  public abstract void bindAttribLocation(int program, int index, String name);
  public abstract int getUniformLocation(int program, String name);
  public abstract String getActiveUniform(int program, int index, IntBuffer size, IntBuffer type);
  public abstract void uniform1i(int location, int value);
  public abstract void uniform2i(int location, int value0, int value1);
  public abstract void uniform3i(int location, int value0, int value1, int value2);
  public abstract void uniform4i(int location, int value0, int value1, int value2, int value3);
  public abstract void uniform1f(int location, float value);
  public abstract void uniform2f(int location, float value0, float value1);
  public abstract void uniform3f(int location, float value0, float value1, float value2);
  public abstract void uniform4f(int location, float value0, float value1, float value2, float value3);
  public abstract void uniform1iv(int location, int count, IntBuffer v);
  public abstract void uniform2iv(int location, int count, IntBuffer v);
  public abstract void uniform3iv(int location, int count, IntBuffer v);
  public abstract void uniform4iv(int location, int count, IntBuffer v);
  public abstract void uniform1fv(int location, int count, FloatBuffer v);
  public abstract void uniform2fv(int location, int count, FloatBuffer v);
  public abstract void uniform3fv(int location, int count, FloatBuffer v);
  public abstract void uniform4fv(int location, int count, FloatBuffer v);
  public abstract void uniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void uniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void uniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void validateProgram(int program);
  public abstract boolean isShader(int shader);
  public abstract void getShaderiv(int shader, int pname, IntBuffer params);
  public abstract void getAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders);
  public abstract String getShaderInfoLog(int shader);
  public abstract String getShaderSource(int shader);
  public abstract void getShaderPrecisionFormat(int shaderType, int precisionType, IntBuffer range, IntBuffer precision);
  public abstract void getVertexAttribfv(int index, int pname, FloatBuffer params);
  public abstract void getVertexAttribiv(int index, int pname, IntBuffer params);
  public abstract void getVertexAttribPointerv(int index, int pname, ByteBuffer data);
  public abstract void getUniformfv(int program, int location, FloatBuffer params);
  public abstract void getUniformiv(int program, int location, IntBuffer params);
  public abstract boolean isProgram(int program);
  public abstract void getProgramiv(int program, int pname, IntBuffer params);
  public abstract String getProgramInfoLog(int program);





  public abstract void scissor(int x, int y, int w, int h);
  public abstract void sampleCoverage(float value, boolean invert);
  public abstract void stencilFunc(int func, int ref, int mask);
  public abstract void stencilFuncSeparate(int face, int func, int ref, int mask);
  public abstract void stencilOp(int sfail, int dpfail, int dppass);
  public abstract void stencilOpSeparate(int face, int sfail, int dpfail, int dppass);
  public abstract void depthFunc(int func);
  public abstract void blendEquation(int mode);
  public abstract void blendEquationSeparate(int modeRGB, int modeAlpha);
  public abstract void blendFunc(int src, int dst);
  public abstract void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);
  public abstract void blendColor(float red, float green, float blue, float alpha);
  public abstract void alphaFunc(int func, float ref);





  public abstract void colorMask(boolean r, boolean g, boolean b, boolean a);
  public abstract void depthMask(boolean mask);
  public abstract void stencilMask(int mask);
  public abstract void stencilMaskSeparate(int face, int mask);
  public abstract void clear(int buf);
  public abstract void clearColor(float r, float g, float b, float a);
  public abstract void clearDepth(float d);
  public abstract void clearStencil(int s);





  public void bindFramebuffer(int target, int framebuffer) {
    pg.beginBindFramebuffer(target, framebuffer);
    bindFramebufferImpl(target, framebuffer);
    pg.endBindFramebuffer(target, framebuffer);
  }
  protected abstract void bindFramebufferImpl(int target, int framebuffer);

  public abstract void deleteFramebuffers(int n, IntBuffer framebuffers);
  public abstract void genFramebuffers(int n, IntBuffer framebuffers);
  public abstract void bindRenderbuffer(int target, int renderbuffer);
  public abstract void deleteRenderbuffers(int n, IntBuffer renderbuffers);
  public abstract void genRenderbuffers(int n, IntBuffer renderbuffers);
  public abstract void renderbufferStorage(int target, int internalFormat, int width, int height);
  public abstract void framebufferRenderbuffer(int target, int attachment, int rendbuferfTarget, int renderbuffer);
  public abstract void framebufferTexture2D(int target, int attachment, int texTarget, int texture, int level);
  public abstract int checkFramebufferStatus(int target);
  public abstract boolean isFramebuffer(int framebuffer);
  public abstract void getFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params);
  public abstract boolean isRenderbuffer(int renderbuffer);
  public abstract void getRenderbufferParameteriv(int target, int pname, IntBuffer params);
  public abstract void blitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter);
  public abstract void renderbufferStorageMultisample(int target, int samples, int format, int width, int height);
  public abstract void readBuffer(int buf);
  public abstract void drawBuffer(int buf);



  int[] labelPix = {-2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1315861, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1118482, -1, -2105377, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -855310, -263173, -131587, -460552, -1315861, -2236963, -2236963, -1052689, -263173, -1, -460552, -1118482, -2236963, -2236963, -1776412, -657931, -197380, -197380, -723724,
-1907998, -2236963, -2236963, -2236963, -789517, -1118482, -1447447, -460552, -197380, -789517, -1710619, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-526345, -131587, -921103, -1250068, -592138, -1, -1184275, -2236963, -1447447, -526345, -1, -1052689, -1513240, -2236963, -1710619, -1, -328966, -1184275, -1118482, -263173, -65794, -1776412, -2236963, -2236963, -394759, -263173, -65794, -1118482, -1381654, -394759, -131587, -1907998, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -1, -1184275, -2236963, -2236963, -2236963, -460552, -723724, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -2171170, -328966, -263173, -2105377, -2236963, -2236963, -2039584, -197380, -460552, -2236963, -2236963, -394759, -1, -1513240, -2236963, -2236963, -2105377, -197380, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2171170, -65794, -394759, -1710619, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1907998, -1, -1184275, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -1973791, -2236963, -394759, -328966, -2236963, -2236963, -2236963, -2236963, -1052689, -65794, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1250068, -1, -1, -197380, -855310, -1579033, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1579033, -1, -1579033, -2236963, -2236963, -2236963, -2236963,
-1447447, -1, -1644826, -2236963, -394759, -657931, -2236963, -2236963, -2236963, -2236963, -1381654, -1, -1842205, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -1776412, -986896, -328966, -1, -1, -855310, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1447447, -1, -1644826, -2236963, -2236963, -2236963, -2236963, -1513240, -1, -1579033, -2236963, -394759, -789517, -2236963, -2236963, -2236963, -2236963, -1381654, -1, -1776412, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2105377, -2171170, -2236963, -2236963, -1907998, -460552, -1, -1973791, -2236963, -1052689, -1, -2105377, -2236963, -1776412, -1, -1381654, -2236963, -2236963, -2236963, -2236963, -1184275, -1, -1776412, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -1118482, -65794, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1776412, -1, -1250068, -2236963, -2236963, -2236963, -1250068, -1, -1776412, -2236963, -1118482, -1, -2039584, -2236963, -2105377, -131587, -460552, -2236963, -2236963, -2236963, -2236963, -328966, -131587, -2171170, -2236963, -394759, -1, -1907998, -2236963, -2236963, -2236963, -328966, -394759, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -592138, -197380, -1250068, -1842205, -1381654, -263173, -263173, -2236963, -2236963, -1250068, -1, -921103, -1579033, -2236963, -1250068, -1, -789517, -1776412, -1776412, -657931,
-1, -1513240, -2236963, -2236963, -394759, -1, -394759, -1644826, -1776412, -723724, -65794, -1776412, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-1842205, -460552, -1, -1, -1, -526345, -1973791, -2236963, -2236963, -2039584, -394759, -1, -460552, -2236963, -2236963, -1315861, -131587, -1, -1, -394759, -1447447, -2236963, -2236963, -2236963, -394759, -460552, -855310, -1, -1, -394759, -1513240, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -1842205, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2105377, -2171170, -2236963, -2236963, -2236963, -2236963, -1973791, -2039584, -2236963, -2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2105377, -1973791, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1184275, -1250068, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963
 };

}

<code block>




package processing.opengl;

import java.io.IOException;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.util.Arrays;

import processing.core.PApplet;
import processing.core.PGraphics;



public abstract class PGL {





  protected PGraphicsOpenGL pg;


  protected Thread glThread;


  protected int glContext;


  public boolean primaryPGL;





  protected static boolean USE_FBOLAYER_BY_DEFAULT = false;
  public static int REQUESTED_DEPTH_BITS   = 24;
  public static int REQUESTED_STENCIL_BITS = 8;
  public static int REQUESTED_ALPHA_BITS   = 8;


  protected static boolean USE_DIRECT_BUFFERS = true;
  protected static int MIN_DIRECT_BUFFER_SIZE = 1;


  protected static boolean SAVE_SURFACE_TO_PIXELS_HACK = false;


  protected static boolean MIPMAPS_ENABLED = true;


  protected static int DEFAULT_IN_VERTICES   = 64;
  protected static int DEFAULT_IN_EDGES      = 128;
  protected static int DEFAULT_IN_TEXTURES   = 64;
  protected static int DEFAULT_TESS_VERTICES = 64;
  protected static int DEFAULT_TESS_INDICES  = 128;


  protected static int MAX_LIGHTS = 8;


  protected static int MAX_VERTEX_INDEX  = 32767;
  protected static int MAX_VERTEX_INDEX1 = MAX_VERTEX_INDEX + 1;


  protected static int FLUSH_VERTEX_COUNT = MAX_VERTEX_INDEX1;


  protected static int MIN_FONT_TEX_SIZE = 256;
  protected static int MAX_FONT_TEX_SIZE = 1024;


  protected static float MIN_CAPS_JOINS_WEIGHT = 2f;


  protected static int MAX_CAPS_JOINS_LENGTH = 5000;


  protected static int MIN_ARRAYCOPY_SIZE = 2;


  protected static float STROKE_DISPLACEMENT = 0.999f;






  protected boolean fboLayerRequested = false;
  protected boolean fboLayerCreated = false;
  protected boolean fboLayerInUse = false;
  protected boolean firstFrame = true;
  public int reqNumSamples;
  protected int numSamples;
  protected IntBuffer glColorFbo;
  protected IntBuffer glMultiFbo;
  protected IntBuffer glColorBuf;
  protected IntBuffer glColorTex;
  protected IntBuffer glDepthStencil;
  protected IntBuffer glDepth;
  protected IntBuffer glStencil;
  protected int fboWidth, fboHeight;
  protected int backTex, frontTex;


  protected boolean usingFrontTex = false;
  protected boolean needSepFrontTex = false;





  protected boolean loadedTex2DShader = false;
  protected int tex2DShaderProgram;
  protected int tex2DVertShader;
  protected int tex2DFragShader;
  protected int tex2DShaderContext;
  protected int tex2DVertLoc;
  protected int tex2DTCoordLoc;
  protected int tex2DSamplerLoc;
  protected int tex2DGeoVBO;

  protected boolean loadedTexRectShader = false;
  protected int texRectShaderProgram;
  protected int texRectVertShader;
  protected int texRectFragShader;
  protected int texRectShaderContext;
  protected int texRectVertLoc;
  protected int texRectTCoordLoc;
  protected int texRectSamplerLoc;
  protected int texRectGeoVBO;

  protected float[] texCoords = {

    -1.0f, -1.0f, 0.0f, 0.0f,
    +1.0f, -1.0f, 1.0f, 0.0f,
    -1.0f, +1.0f, 0.0f, 1.0f,
    +1.0f, +1.0f, 1.0f, 1.0f
  };
  protected FloatBuffer texData;

  protected static final String SHADER_PREPROCESSOR_DIRECTIVE =
    "#ifdef GL_ES\n" +
    "precision mediump float;\n" +
    "precision mediump int;\n" +
    "#endif\n";

  protected static String[] texVertShaderSource = {
    "attribute vec2 position;",
    "attribute vec2 texCoord;",
    "varying vec2 vertTexCoord;",
    "void main() {",
    "  gl_Position = vec4(position, 0, 1);",
    "  vertTexCoord = texCoord;",
    "}"
  };

  protected static String[] tex2DFragShaderSource = {
    SHADER_PREPROCESSOR_DIRECTIVE,
    "uniform sampler2D texMap;",
    "varying vec2 vertTexCoord;",
    "void main() {",
   "  gl_FragColor = texture2D(texMap, vertTexCoord.st);",
    "}"
  };

  protected static String[] texRectFragShaderSource = {
    SHADER_PREPROCESSOR_DIRECTIVE,
    "uniform sampler2DRect texMap;",
    "varying vec2 vertTexCoord;",
    "void main() {",
    "  gl_FragColor = texture2DRect(texMap, vertTexCoord.st);",
    "}"
  };


  protected boolean[] texturingTargets = { false, false };


  protected int maxTexUnits;
  protected int activeTexUnit = 0;
  protected int[][] boundTextures;





  protected float targetFps = 60;
  protected float currentFps = 60;
  protected boolean setFps = false;





  protected ByteBuffer byteBuffer;
  protected IntBuffer intBuffer;
  protected IntBuffer viewBuffer;

  protected IntBuffer colorBuffer;
  protected FloatBuffer depthBuffer;
  protected ByteBuffer stencilBuffer;





  public static final String WIKI =
    " Read http://wiki.processing.org/w/OpenGL_Issues for help.";

  public static final String FRAMEBUFFER_ERROR =
    "Framebuffer error (%1$s), rendering will probably not work as expected" + WIKI;

  public static final String MISSING_FBO_ERROR =
    "Framebuffer objects are not supported by this hardware (or driver)" + WIKI;

  public static final String MISSING_GLSL_ERROR =
    "GLSL shaders are not supported by this hardware (or driver)" + WIKI;

  public static final String MISSING_GLFUNC_ERROR =
    "GL function %1$s is not available on this hardware (or driver)" + WIKI;

  public static final String UNSUPPORTED_GLPROF_ERROR =
    "Unsupported OpenGL profile.";

  public static final String TEXUNIT_ERROR =
    "Number of texture units not supported by this hardware (or driver)" + WIKI;

  public static final String NONPRIMARY_ERROR =
    "The renderer is trying to call a PGL function that can only be called on a primary PGL. " +
    "This is most likely due to a bug in the renderer's code, please report it with an " +
    "issue on Processing's github page https://github.com/processing/processing/issues?state=open " +
    "if using any of the built-in OpenGL renderers. If you are using a contributed " +
    "library, contact the library's developers.";






  protected static int SIZEOF_SHORT = Short.SIZE / 8;
  protected static int SIZEOF_INT   = Integer.SIZE / 8;
  protected static int SIZEOF_FLOAT = Float.SIZE / 8;
  protected static int SIZEOF_BYTE  = Byte.SIZE / 8;
  protected static int SIZEOF_INDEX = SIZEOF_SHORT;
  protected static int INDEX_TYPE   = 0x1403; 


  protected static float FLOAT_EPS = Float.MIN_VALUE;


  static {
    float eps = 1.0f;

    do {
      eps /= 2.0f;
    } while ((float)(1.0 + (eps / 2.0)) != 1.0);

    FLOAT_EPS = eps;
  }


  protected static boolean BIG_ENDIAN =
    ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;



  public boolean presentMode = false;
  public float offsetX;
  public float offsetY;






  public PGL() { }


  public PGL(PGraphicsOpenGL pg) {
    this.pg = pg;
    if (glColorTex == null) {
      glColorTex = allocateIntBuffer(2);
      glColorFbo = allocateIntBuffer(1);
      glMultiFbo = allocateIntBuffer(1);
      glColorBuf = allocateIntBuffer(1);
      glDepthStencil = allocateIntBuffer(1);
      glDepth = allocateIntBuffer(1);
      glStencil = allocateIntBuffer(1);

      fboLayerCreated = false;
      fboLayerInUse = false;
      firstFrame = false;
    }

    byteBuffer = allocateByteBuffer(1);
    intBuffer = allocateIntBuffer(1);
    viewBuffer = allocateIntBuffer(4);
  }


  public void setPrimary(boolean primary) {
    primaryPGL = primary;
  }


  static protected int smoothToSamples(int smooth) {
    if (smooth == 0) {

      return 1;
    } else if (smooth == 1) {

      return 2;
    } else {

      return smooth;
    }
  }
















  protected void deleteSurface() {
    if (threadIsCurrent() && fboLayerCreated) {
      deleteTextures(2, glColorTex);
      deleteFramebuffers(1, glColorFbo);
      deleteFramebuffers(1, glMultiFbo);
      deleteRenderbuffers(1, glColorBuf);
      deleteRenderbuffers(1, glDepthStencil);
      deleteRenderbuffers(1, glDepth);
      deleteRenderbuffers(1, glStencil);
    }

    fboLayerCreated = false;
    fboLayerInUse = false;
    firstFrame = false;
  }


  protected int getReadFramebuffer()  {
    return fboLayerInUse ? glColorFbo.get(0) : 0;
  }


  protected int getDrawFramebuffer()  {
    if (fboLayerInUse) return 1 < numSamples ? glMultiFbo.get(0) :
                                               glColorFbo.get(0);
    else return 0;
  }


  protected int getDefaultDrawBuffer()  {
    return fboLayerInUse ? COLOR_ATTACHMENT0 : BACK;
  }


  protected int getDefaultReadBuffer()  {
    return fboLayerInUse ? COLOR_ATTACHMENT0 : FRONT;
  }


  protected boolean isFBOBacked() {;
    return fboLayerInUse;
  }


  public void requestFBOLayer() {
    fboLayerRequested = true;
  }


  protected boolean isMultisampled() {
    return 1 < numSamples;
  }


  protected int getDepthBits()  {
    intBuffer.rewind();
    getIntegerv(DEPTH_BITS, intBuffer);
    return intBuffer.get(0);
  }


  protected int getStencilBits()  {
    intBuffer.rewind();
    getIntegerv(STENCIL_BITS, intBuffer);
    return intBuffer.get(0);
  }


  protected boolean getDepthTest() {
    intBuffer.rewind();
    getBooleanv(DEPTH_TEST, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean getDepthWriteMask() {
    intBuffer.rewind();
    getBooleanv(DEPTH_WRITEMASK, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected Texture wrapBackTexture(Texture texture) {
    if (texture == null) {
      texture = new Texture(pg);
      texture.init(pg.width, pg.height,
                   glColorTex.get(backTex), TEXTURE_2D, RGBA,
                   fboWidth, fboHeight, NEAREST, NEAREST,
                   CLAMP_TO_EDGE, CLAMP_TO_EDGE);
      texture.invertedY(true);
      texture.colorBuffer(true);
      pg.setCache(pg, texture);
    } else {
      texture.glName = glColorTex.get(backTex);
    }
    return texture;
  }


  protected Texture wrapFrontTexture(Texture texture)  {
    if (texture == null) {
      texture = new Texture(pg);
      texture.init(pg.width, pg.height,
                   glColorTex.get(frontTex), TEXTURE_2D, RGBA,
                   fboWidth, fboHeight, NEAREST, NEAREST,
                   CLAMP_TO_EDGE, CLAMP_TO_EDGE);
      texture.invertedY(true);
      texture.colorBuffer(true);
    } else {
      texture.glName = glColorTex.get(frontTex);
    }
    return texture;
  }


  protected void bindFrontTexture() {
    usingFrontTex = true;
    if (!texturingIsEnabled(TEXTURE_2D)) {
      enableTexturing(TEXTURE_2D);
    }
    bindTexture(TEXTURE_2D, glColorTex.get(frontTex));
  }


  protected void unbindFrontTexture() {
    if (textureIsBound(TEXTURE_2D, glColorTex.get(frontTex))) {


      if (!texturingIsEnabled(TEXTURE_2D)) {
        enableTexturing(TEXTURE_2D);
        bindTexture(TEXTURE_2D, 0);
        disableTexturing(TEXTURE_2D);
      } else {
        bindTexture(TEXTURE_2D, 0);
      }
    }
  }


  protected void syncBackTexture() {
    if (usingFrontTex) needSepFrontTex = true;
    if (1 < numSamples) {
      bindFramebufferImpl(READ_FRAMEBUFFER, glMultiFbo.get(0));
      bindFramebufferImpl(DRAW_FRAMEBUFFER, glColorFbo.get(0));
      blitFramebuffer(0, 0, fboWidth, fboHeight,
                      0, 0, fboWidth, fboHeight,
                      COLOR_BUFFER_BIT, NEAREST);
    }
  }







  protected void beginDraw(boolean clear0) {
    if (needFBOLayer(clear0)) {
      if (!fboLayerCreated) createFBOLayer();



      bindFramebufferImpl(FRAMEBUFFER, glColorFbo.get(0));
      framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0,
                           TEXTURE_2D, glColorTex.get(backTex), 0);

      if (1 < numSamples) {
        bindFramebufferImpl(FRAMEBUFFER, glMultiFbo.get(0));
      }

      if (firstFrame) {

        int argb = pg.backgroundColor;
        float a = ((argb >> 24) & 0xff) / 255.0f;
        float r = ((argb >> 16) & 0xff) / 255.0f;
        float g = ((argb >> 8) & 0xff) / 255.0f;
        float b = ((argb) & 0xff) / 255.0f;
        clearColor(r, g, b, a);
        clear(COLOR_BUFFER_BIT);
      } else if (!clear0) {


        int x = 0;
        int y = 0;
        if (presentMode) {
          x = (int)offsetX;
          y = (int)offsetY;
        }
        float scale = pg.getPixelScale();
        drawTexture(TEXTURE_2D, glColorTex.get(frontTex), fboWidth, fboHeight,
                    x, y, pg.width, pg.height,
                    0, 0, (int)(scale * pg.width), (int)(scale * pg.height),
                    0, 0, pg.width, pg.height);
      }

      fboLayerInUse = true;
    } else {
      fboLayerInUse = false;
    }

    if (firstFrame) {
      firstFrame = false;
    }









  }


  IntBuffer labelTex;
  protected void endDraw(boolean clear0, int windowColor) {
    if (fboLayerInUse) {
      syncBackTexture();


      bindFramebufferImpl(FRAMEBUFFER, 0);

      if (presentMode) {
        int argb = windowColor;
        float a = ((argb >> 24) & 0xff)  / 255.0f;
        float r = ((argb >> 16) & 0xff) / 255.0f;
        float g = ((argb >> 8) & 0xff) / 255.0f;
        float b = (argb & 0xff) / 255.0f;
        clearDepth(1);
        clearColor(r, g, b, a);
        clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);

        if (labelTex == null) {
          labelTex = allocateIntBuffer(1);
          genTextures(1, labelTex);
          bindTexture(TEXTURE_2D, labelTex.get(0));
          texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
          texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
          texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
          texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
          texImage2D(TEXTURE_2D, 0, RGBA, 100, 50, 0, RGBA, UNSIGNED_BYTE, null);








          IntBuffer buf = allocateIntBuffer(labelPix);
          copyToTexture(TEXTURE_2D, RGBA, labelTex.get(0), 0, 0, 100, 50, buf);
          bindTexture(TEXTURE_2D, 0);
        }
        drawTexture(TEXTURE_2D, labelTex.get(0), 100, 50,
                    0, 0, 20 + 100, 20 + 50,
                    0, 50, 100, 0,
                    20, 20, 20 + 100, 20 + 50);



      } else {
        clearDepth(1);
        clearColor(0, 0, 0, 0);
        clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      }


      disable(BLEND);
      int x = 0;
      int y = 0;
      if (presentMode) {
        x = (int)offsetX;
        y = (int)offsetY;
      }
      float scale = pg.getPixelScale();
      drawTexture(TEXTURE_2D, glColorTex.get(backTex),
                  fboWidth, fboHeight,
                  x, y, pg.width, pg.height,
                  0, 0, (int)(scale * pg.width), (int)(scale * pg.height),
                  0, 0, pg.width, pg.height);


      int temp = frontTex;
      frontTex = backTex;
      backTex = temp;
    }
  }


  protected abstract void getGL(PGL pgl);














  public boolean threadIsCurrent()  {
    return Thread.currentThread() == glThread;
  }


  public void setThread(Thread thread) {
    glThread = thread;
  }


  protected void beginGL() { }


  protected void endGL() { }


  private boolean needFBOLayer(boolean clear0) {





    return fboLayerRequested;
  }


  private void createFBOLayer() {
    String ext = getString(EXTENSIONS);
    float scale = pg.getPixelScale();

    if (-1 < ext.indexOf("texture_non_power_of_two")) {
      fboWidth = (int)(scale * pg.width);
      fboHeight = (int)(scale * pg.height);
    } else {
      fboWidth = nextPowerOfTwo((int)(scale * pg.width));
      fboHeight = nextPowerOfTwo((int)(scale * pg.height));
    }

    int maxs = maxSamples();
    if (-1 < ext.indexOf("_framebuffer_multisample") && 1 < maxs) {
      numSamples = PApplet.min(reqNumSamples, maxs);
    } else {
      numSamples = 1;
    }
    boolean multisample = 1 < numSamples;

    boolean packed = ext.indexOf("packed_depth_stencil") != -1;
    int depthBits = PApplet.min(REQUESTED_DEPTH_BITS, getDepthBits());
    int stencilBits = PApplet.min(REQUESTED_STENCIL_BITS, getStencilBits());

    genTextures(2, glColorTex);
    for (int i = 0; i < 2; i++) {
      bindTexture(TEXTURE_2D, glColorTex.get(i));
      texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
      texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
      texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
      texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
      texImage2D(TEXTURE_2D, 0, RGBA, fboWidth, fboHeight, 0,
                 RGBA, UNSIGNED_BYTE, null);
      initTexture(TEXTURE_2D, RGBA, fboWidth, fboHeight, pg.backgroundColor);
    }
    bindTexture(TEXTURE_2D, 0);

    backTex = 0;
    frontTex = 1;

    genFramebuffers(1, glColorFbo);
    bindFramebufferImpl(FRAMEBUFFER, glColorFbo.get(0));
    framebufferTexture2D(FRAMEBUFFER, COLOR_ATTACHMENT0, TEXTURE_2D,
                         glColorTex.get(backTex), 0);

    if (multisample) {

      genFramebuffers(1, glMultiFbo);
      bindFramebufferImpl(FRAMEBUFFER, glMultiFbo.get(0));


      genRenderbuffers(1, glColorBuf);
      bindRenderbuffer(RENDERBUFFER, glColorBuf.get(0));
      renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                     RGBA8, fboWidth, fboHeight);
      framebufferRenderbuffer(FRAMEBUFFER, COLOR_ATTACHMENT0,
                              RENDERBUFFER, glColorBuf.get(0));
    }

    createDepthAndStencilBuffer(multisample, depthBits, stencilBits, packed);

    validateFramebuffer();


    clearDepth(1);
    clearStencil(0);
    int argb = pg.backgroundColor;
    float a = ((argb >> 24) & 0xff) / 255.0f;
    float r = ((argb >> 16) & 0xff) / 255.0f;
    float g = ((argb >> 8) & 0xff) / 255.0f;
    float b = ((argb) & 0xff) / 255.0f;
    clearColor(r, g, b, a);
    clear(DEPTH_BUFFER_BIT | STENCIL_BUFFER_BIT | COLOR_BUFFER_BIT);

    bindFramebufferImpl(FRAMEBUFFER, 0);

    fboLayerCreated = true;
  }

  private void createDepthAndStencilBuffer(boolean multisample, int depthBits,
                                           int stencilBits, boolean packed) {

    if (packed && depthBits == 24 && stencilBits == 8) {

      genRenderbuffers(1, glDepthStencil);
      bindRenderbuffer(RENDERBUFFER, glDepthStencil.get(0));
      if (multisample) {
        renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                       DEPTH24_STENCIL8, fboWidth, fboHeight);
      } else {
        renderbufferStorage(RENDERBUFFER, DEPTH24_STENCIL8,
                            fboWidth, fboHeight);
      }
      framebufferRenderbuffer(FRAMEBUFFER, DEPTH_ATTACHMENT, RENDERBUFFER,
                              glDepthStencil.get(0));
      framebufferRenderbuffer(FRAMEBUFFER, STENCIL_ATTACHMENT, RENDERBUFFER,
                              glDepthStencil.get(0));
    } else {

      if (0 < depthBits) {
        int depthComponent = DEPTH_COMPONENT16;
        if (depthBits == 32) {
          depthComponent = DEPTH_COMPONENT32;
        } else if (depthBits == 24) {
          depthComponent = DEPTH_COMPONENT24;
        } else if (depthBits == 16) {
          depthComponent = DEPTH_COMPONENT16;
        }

        genRenderbuffers(1, glDepth);
        bindRenderbuffer(RENDERBUFFER, glDepth.get(0));
        if (multisample) {
          renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                         depthComponent, fboWidth, fboHeight);
        } else {
          renderbufferStorage(RENDERBUFFER, depthComponent,
                              fboWidth, fboHeight);
        }
        framebufferRenderbuffer(FRAMEBUFFER, DEPTH_ATTACHMENT,
                                RENDERBUFFER, glDepth.get(0));
      }

      if (0 < stencilBits) {
        int stencilIndex = STENCIL_INDEX1;
        if (stencilBits == 8) {
          stencilIndex = STENCIL_INDEX8;
        } else if (stencilBits == 4) {
          stencilIndex = STENCIL_INDEX4;
        } else if (stencilBits == 1) {
          stencilIndex = STENCIL_INDEX1;
        }

        genRenderbuffers(1, glStencil);
        bindRenderbuffer(RENDERBUFFER, glStencil.get(0));
        if (multisample) {
          renderbufferStorageMultisample(RENDERBUFFER, numSamples,
                                         stencilIndex, fboWidth, fboHeight);
        } else {
          renderbufferStorage(RENDERBUFFER, stencilIndex,
                              fboWidth, fboHeight);
        }
        framebufferRenderbuffer(FRAMEBUFFER, STENCIL_ATTACHMENT,
                                RENDERBUFFER, glStencil.get(0));
      }
    }
  }







  protected int createEmptyContext() {
    return -1;
  }


  protected int getCurrentContext() {
    return glContext;
  }







  protected boolean contextIsCurrent(int other) {
    return other == -1 || other == glContext;
  }


  protected void enableTexturing(int target) {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = true;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = true;
    }
  }


  protected void disableTexturing(int target) {
    if (target == TEXTURE_2D) {
      texturingTargets[0] = false;
    } else if (target == TEXTURE_RECTANGLE) {
      texturingTargets[1] = false;
    }
  }


  protected boolean texturingIsEnabled(int target) {
    if (target == TEXTURE_2D) {
      return texturingTargets[0];
    } else if (target == TEXTURE_RECTANGLE) {
      return texturingTargets[1];
    } else {
      return false;
    }
  }


  protected boolean textureIsBound(int target, int id) {
    if (boundTextures == null) return false;

    if (target == TEXTURE_2D) {
      return boundTextures[activeTexUnit][0] == id;
    } else if (target == TEXTURE_RECTANGLE) {
      return boundTextures[activeTexUnit][1] == id;
    } else {
      return false;
    }
  }


  protected void initTexture(int target, int format, int width, int height) {
    initTexture(target, format, width, height, 0);
  }


  protected void initTexture(int target, int format, int width, int height,
                            int initColor) {
    int[] glcolor = new int[16 * 16];
    Arrays.fill(glcolor, javaToNativeARGB(initColor));
    IntBuffer texels = allocateDirectIntBuffer(16 * 16);
    texels.put(glcolor);
    texels.rewind();
    for (int y = 0; y < height; y += 16) {
      int h = PApplet.min(16, height - y);
      for (int x = 0; x < width; x += 16) {
        int w = PApplet.min(16, width - x);
        texSubImage2D(target, 0, x, y, w, h, format, UNSIGNED_BYTE, texels);
      }
    }
  }


  protected void copyToTexture(int target, int format, int id, int x, int y,
                               int w, int h, int[] buffer) {
    copyToTexture(target, format, id, x, y, w, h, IntBuffer.wrap(buffer));

  }

  protected void copyToTexture(int target, int format, int id, int x, int y,
                               int w, int h, IntBuffer buffer) {
    activeTexture(TEXTURE0);
    boolean enabledTex = false;
    if (!texturingIsEnabled(target)) {
      enableTexturing(target);
      enabledTex = true;
    }
    bindTexture(target, id);
    texSubImage2D(target, 0, x, y, w, h, format, UNSIGNED_BYTE, buffer);
    bindTexture(target, 0);
    if (enabledTex) {
      disableTexturing(target);
    }
  }



  public void drawTexture(int target, int id, int width, int height,
                          int X0, int Y0, int X1, int Y1) {
    drawTexture(target, id, width, height,
                0, 0, width, height,
                X0, Y0, X1, Y1,
                X0, Y0, X1, Y1);
  }



  public void drawTexture(int target, int id,int texW, int texH,
                          int viewX, int viewY, int scrW, int scrH,
                          int texX0, int texY0, int texX1, int texY1,
                          int scrX0, int scrY0, int scrX1, int scrY1) {
    if (target == TEXTURE_2D) {
      drawTexture2D(id, texW, texH,
                    viewX, viewY, scrW, scrH,
                    texX0, texY0, texX1, texY1,
                    scrX0, scrY0, scrX1, scrY1);
    } else if (target == TEXTURE_RECTANGLE) {
      drawTextureRect(id, texW, texH,
                      viewX, viewY, scrW, scrH,
                      texX0, texY0, texX1, texY1,
                      scrX0, scrY0, scrX1, scrY1);
    }
  }


  protected PGL initTex2DShader() {
    PGL ppgl = primaryPGL ? this : pg.getPrimaryPGL();

    if (!ppgl.loadedTex2DShader || ppgl.tex2DShaderContext != ppgl.glContext) {
      String vertSource = PApplet.join(texVertShaderSource, "\n");
      String fragSource = PApplet.join(tex2DFragShaderSource, "\n");
      ppgl.tex2DVertShader = createShader(VERTEX_SHADER, vertSource);
      ppgl.tex2DFragShader = createShader(FRAGMENT_SHADER, fragSource);
      if (0 < ppgl.tex2DVertShader && 0 < ppgl.tex2DFragShader) {
        ppgl.tex2DShaderProgram = createProgram(ppgl.tex2DVertShader, ppgl.tex2DFragShader);
      }
      if (0 < ppgl.tex2DShaderProgram) {
        ppgl.tex2DVertLoc = getAttribLocation(ppgl.tex2DShaderProgram, "position");
        ppgl.tex2DTCoordLoc = getAttribLocation(ppgl.tex2DShaderProgram, "texCoord");
        ppgl.tex2DSamplerLoc = getUniformLocation(ppgl.tex2DShaderProgram, "texMap");
      }
      ppgl.loadedTex2DShader = true;
      ppgl.tex2DShaderContext = ppgl.glContext;

      genBuffers(1, intBuffer);
      ppgl.tex2DGeoVBO = intBuffer.get(0);
      bindBuffer(ARRAY_BUFFER, ppgl.tex2DGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, null, STATIC_DRAW);
    }

    if (texData == null) {
      texData = allocateDirectFloatBuffer(texCoords.length);
    }

    return ppgl;
  }


  protected void drawTexture2D(int id, int texW, int texH,
                               int viewX, int viewY, int scrW, int scrH,
                               int texX0, int texY0, int texX1, int texY1,
                               int scrX0, int scrY0, int scrX1, int scrY1) {
    PGL ppgl = initTex2DShader();

    if (0 < ppgl.tex2DShaderProgram) {

      boolean depthTest = getDepthTest();
      disable(DEPTH_TEST);





      boolean depthMask = getDepthWriteMask();
      depthMask(false);


      viewBuffer.rewind();
      getIntegerv(VIEWPORT, viewBuffer);
      viewport(viewX, viewY, scrW, scrH);

      useProgram(ppgl.tex2DShaderProgram);

      enableVertexAttribArray(ppgl.tex2DVertLoc);
      enableVertexAttribArray(ppgl.tex2DTCoordLoc);




      texCoords[ 0] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 1] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 2] = (float)texX0 / texW;
      texCoords[ 3] = (float)texY0 / texH;

      texCoords[ 4] = 2 * (float)scrX1 / scrW - 1;
      texCoords[ 5] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 6] = (float)texX1 / texW;
      texCoords[ 7] = (float)texY0 / texH;

      texCoords[ 8] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 9] = 2 * (float)scrY1 / scrH - 1;
      texCoords[10] = (float)texX0 / texW;
      texCoords[11] = (float)texY1 / texH;

      texCoords[12] = 2 * (float)scrX1 / scrW - 1;
      texCoords[13] = 2 * (float)scrY1 / scrH - 1;
      texCoords[14] = (float)texX1 / texW;
      texCoords[15] = (float)texY1 / texH;

      texData.rewind();
      texData.put(texCoords);

      activeTexture(TEXTURE0);
      boolean enabledTex = false;
      if (!texturingIsEnabled(TEXTURE_2D)) {
        enableTexturing(TEXTURE_2D);
        enabledTex = true;
      }
      bindTexture(TEXTURE_2D, id);
      uniform1i(ppgl.tex2DSamplerLoc, 0);

      texData.position(0);
      bindBuffer(ARRAY_BUFFER, ppgl.tex2DGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, texData, STATIC_DRAW);

      vertexAttribPointer(ppgl.tex2DVertLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 0);
      vertexAttribPointer(ppgl.tex2DTCoordLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 2 * SIZEOF_FLOAT);

      drawArrays(TRIANGLE_STRIP, 0, 4);

      bindBuffer(ARRAY_BUFFER, 0); 

      bindTexture(TEXTURE_2D, 0);
      if (enabledTex) {
        disableTexturing(TEXTURE_2D);
      }

      disableVertexAttribArray(ppgl.tex2DVertLoc);
      disableVertexAttribArray(ppgl.tex2DTCoordLoc);

      useProgram(0);

      if (depthTest) {
        enable(DEPTH_TEST);
      } else {
        disable(DEPTH_TEST);
      }
      depthMask(depthMask);

      viewport(viewBuffer.get(0), viewBuffer.get(1),
               viewBuffer.get(2), viewBuffer.get(3));
    }
  }


  protected PGL initTexRectShader() {
    PGL ppgl = primaryPGL ? this : pg.getPrimaryPGL();

    if (!ppgl.loadedTexRectShader || ppgl.texRectShaderContext != ppgl.glContext) {
      String vertSource = PApplet.join(texVertShaderSource, "\n");
      String fragSource = PApplet.join(texRectFragShaderSource, "\n");
      ppgl.texRectVertShader = createShader(VERTEX_SHADER, vertSource);
      ppgl.texRectFragShader = createShader(FRAGMENT_SHADER, fragSource);
      if (0 < ppgl.texRectVertShader && 0 < ppgl.texRectFragShader) {
        ppgl.texRectShaderProgram = createProgram(ppgl.texRectVertShader,
                                                  ppgl.texRectFragShader);
      }
      if (0 < ppgl.texRectShaderProgram) {
        ppgl.texRectVertLoc = getAttribLocation(ppgl.texRectShaderProgram, "position");
        ppgl.texRectTCoordLoc = getAttribLocation(ppgl.texRectShaderProgram, "texCoord");
        ppgl.texRectSamplerLoc = getUniformLocation(ppgl.texRectShaderProgram, "texMap");
      }
      ppgl.loadedTexRectShader = true;
      ppgl.texRectShaderContext = ppgl.glContext;

      genBuffers(1, intBuffer);
      ppgl.texRectGeoVBO = intBuffer.get(0);
      bindBuffer(ARRAY_BUFFER, ppgl.texRectGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, null, STATIC_DRAW);
    }

    return ppgl;
  }


  protected void drawTextureRect(int id, int texW, int texH,
                                 int viewX, int viewY, int scrW, int scrH,
                                 int texX0, int texY0, int texX1, int texY1,
                                 int scrX0, int scrY0, int scrX1, int scrY1) {
    PGL ppgl = initTexRectShader();

    if (texData == null) {
      texData = allocateDirectFloatBuffer(texCoords.length);
    }

    if (0 < ppgl.texRectShaderProgram) {

      boolean depthTest = getDepthTest();
      disable(DEPTH_TEST);





      boolean depthMask = getDepthWriteMask();
      depthMask(false);


      viewBuffer.rewind();
      getIntegerv(VIEWPORT, viewBuffer);
      viewport(viewX, viewY, scrW, scrH);

      useProgram(ppgl.texRectShaderProgram);

      enableVertexAttribArray(ppgl.texRectVertLoc);
      enableVertexAttribArray(ppgl.texRectTCoordLoc);




      texCoords[ 0] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 1] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 2] = texX0;
      texCoords[ 3] = texY0;

      texCoords[ 4] = 2 * (float)scrX1 / scrW - 1;
      texCoords[ 5] = 2 * (float)scrY0 / scrH - 1;
      texCoords[ 6] = texX1;
      texCoords[ 7] = texY0;

      texCoords[ 8] = 2 * (float)scrX0 / scrW - 1;
      texCoords[ 9] = 2 * (float)scrY1 / scrH - 1;
      texCoords[10] = texX0;
      texCoords[11] = texY1;

      texCoords[12] = 2 * (float)scrX1 / scrW - 1;
      texCoords[13] = 2 * (float)scrY1 / scrH - 1;
      texCoords[14] = texX1;
      texCoords[15] = texY1;

      texData.rewind();
      texData.put(texCoords);

      activeTexture(TEXTURE0);
      boolean enabledTex = false;
      if (!texturingIsEnabled(TEXTURE_RECTANGLE)) {
        enableTexturing(TEXTURE_RECTANGLE);
        enabledTex = true;
      }
      bindTexture(TEXTURE_RECTANGLE, id);
      uniform1i(ppgl.texRectSamplerLoc, 0);

      texData.position(0);
      bindBuffer(ARRAY_BUFFER, ppgl.texRectGeoVBO);
      bufferData(ARRAY_BUFFER, 16 * SIZEOF_FLOAT, texData, STATIC_DRAW);

      vertexAttribPointer(ppgl.texRectVertLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 0);
      vertexAttribPointer(ppgl.texRectTCoordLoc, 2, FLOAT, false, 4 * SIZEOF_FLOAT, 2 * SIZEOF_FLOAT);

      drawArrays(TRIANGLE_STRIP, 0, 4);

      bindBuffer(ARRAY_BUFFER, 0); 

      bindTexture(TEXTURE_RECTANGLE, 0);
      if (enabledTex) {
        disableTexturing(TEXTURE_RECTANGLE);
      }

      disableVertexAttribArray(ppgl.texRectVertLoc);
      disableVertexAttribArray(ppgl.texRectTCoordLoc);

      useProgram(0);

      if (depthTest) {
        enable(DEPTH_TEST);
      } else {
        disable(DEPTH_TEST);
      }
      depthMask(depthMask);

      viewport(viewBuffer.get(0), viewBuffer.get(1),
               viewBuffer.get(2), viewBuffer.get(3));
    }
  }


  protected int getColorValue(int scrX, int scrY) {
    if (colorBuffer == null) {
      colorBuffer = IntBuffer.allocate(1);
    }
    colorBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, RGBA, UNSIGNED_BYTE,
               colorBuffer);
    return colorBuffer.get();
  }


  protected float getDepthValue(int scrX, int scrY) {
    if (depthBuffer == null) {
      depthBuffer = FloatBuffer.allocate(1);
    }
    depthBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, DEPTH_COMPONENT, FLOAT,
               depthBuffer);
    return depthBuffer.get(0);
  }


  protected byte getStencilValue(int scrX, int scrY) {
    if (stencilBuffer == null) {
      stencilBuffer = ByteBuffer.allocate(1);
    }
    stencilBuffer.rewind();
    readPixels(scrX, pg.height - scrY - 1, 1, 1, STENCIL_INDEX,
               UNSIGNED_BYTE, stencilBuffer);
    return stencilBuffer.get(0);
  }


  protected static boolean isPowerOfTwo(int val) {
    return (val & (val - 1)) == 0;
  }



  protected static int nextPowerOfTwo(int val) {
    int ret = 1;
    while (ret < val) ret <<= 1;
    return ret;
  }



  protected static int nativeToJavaARGB(int color) {
    if (BIG_ENDIAN) { 
      return (color >>> 8) | ((color << 24) & 0xFF000000);


    } else { 
      return ((color & 0xFF) << 16) | ((color & 0xFF0000) >> 16) |
             (color & 0xFF00FF00);
    }
  }



  protected static void nativeToJavaARGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixy >>> 8) | ((pixy << 24) & 0xFF000000);
          pixels[yindex] = (pixi >>> 8) | ((pixi << 24) & 0xFF000000);
        } else { 
          pixels[index] = ((pixy & 0xFF) << 16) | ((pixy & 0xFF0000) >> 16) |
                          (pixy & 0xFF00FF00);
          pixels[yindex] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                           (pixi & 0xFF00FF00);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixi >>> 8) | ((pixi << 24) & 0xFF000000);
        } else { 
          pixels[index] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                          (pixi & 0xFF00FF00);
        }
        index++;
      }
    }
  }



  protected static int nativeToJavaRGB(int color) {
    if (BIG_ENDIAN) { 
      return (color >>> 8) | 0xFF000000;
    } else { 
      return ((color & 0xFF) << 16) | ((color & 0xFF0000) >> 16) |
             (color & 0xFF00FF00) | 0xFF000000;
    }
  }



  protected static void nativeToJavaRGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixy >>> 8) | 0xFF000000;
          pixels[yindex] = (pixi >>> 8) | 0xFF000000;
        } else { 
          pixels[index] = ((pixy & 0xFF) << 16) | ((pixy & 0xFF0000) >> 16) |
                          (pixy & 0xFF00FF00) | 0xFF000000;
          pixels[yindex] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                           (pixi & 0xFF00FF00) | 0xFF000000;
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = (pixi >>> 8) | 0xFF000000;
        } else { 
          pixels[index] = ((pixi & 0xFF) << 16) | ((pixi & 0xFF0000) >> 16) |
                          (pixi & 0xFF00FF00) | 0xFF000000;
        }
        index++;
      }
    }
  }



  protected static int javaToNativeARGB(int color) {
    if (BIG_ENDIAN) { 
      return ((color >> 24) & 0xFF) | ((color << 8) & 0xFFFFFF00);
    } else { 
      return (color & 0xFF000000) | ((color << 16) & 0xFF0000) |
             (color & 0xFF00) | ((color >> 16) & 0xFF);
    }
  }



  protected static void javaToNativeARGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = ((pixy >> 24) & 0xFF) | ((pixy << 8) & 0xFFFFFF00);
          pixels[yindex] = ((pixi >> 24) & 0xFF) | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = (pixy & 0xFF000000) | ((pixy << 16) & 0xFF0000) |
                          (pixy & 0xFF00) | ((pixy >> 16) & 0xFF);
          pixels[yindex] = (pixi & 0xFF000000) | ((pixi << 16) & 0xFF0000) |
                           (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = ((pixi >> 24) & 0xFF) | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = (pixi & 0xFF000000) | ((pixi << 16) & 0xFF0000) |
                          (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
      }
    }
  }



  protected static int javaToNativeRGB(int color) {
    if (BIG_ENDIAN) { 
      return 0xFF | ((color << 8) & 0xFFFFFF00);
    } else { 
      return 0xFF000000 | ((color << 16) & 0xFF0000) |
             (color & 0xFF00) | ((color >> 16) & 0xFF);
    }
  }



  protected static void javaToNativeRGB(int[] pixels, int width, int height) {
    int index = 0;
    int yindex = (height - 1) * width;
    for (int y = 0; y < height / 2; y++) {
      for (int x = 0; x < width; x++) {
        int pixy = pixels[yindex];
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = 0xFF | ((pixy << 8) & 0xFFFFFF00);
          pixels[yindex] = 0xFF | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = 0xFF000000 | ((pixy << 16) & 0xFF0000) |
                          (pixy & 0xFF00) | ((pixy >> 16) & 0xFF);
          pixels[yindex] = 0xFF000000 | ((pixi << 16) & 0xFF0000) |
                           (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
        yindex++;
      }
      yindex -= width * 2;
    }

    if ((height % 2) == 1) { 
      index = (height / 2) * width;
      for (int x = 0; x < width; x++) {
        int pixi = pixels[index];
        if (BIG_ENDIAN) { 
          pixels[index] = 0xFF | ((pixi << 8) & 0xFFFFFF00);
        } else { 
          pixels[index] = 0xFF000000 | ((pixi << 16) & 0xFF0000) |
                          (pixi & 0xFF00) | ((pixi >> 16) & 0xFF);
        }
        index++;
      }
    }
  }


  protected static int qualityToSamples(int quality) {
    if (quality <= 1) {
      return 1;
    } else {

      int n = 2 * (quality / 2);
      return n;
    }
  }


  protected String[] loadVertexShader(String filename) {
    return pg.parent.loadStrings(filename);
  }


  protected String[] loadFragmentShader(String filename) {
    return pg.parent.loadStrings(filename);
  }


  protected String[] loadFragmentShader(URL url) {
    try {
      return PApplet.loadStrings(url.openStream());
    } catch (IOException e) {
      PGraphics.showException("Cannot load fragment shader " + url.getFile());
    }
    return null;
  }


  protected String[] loadVertexShader(URL url) {
    try {
      return PApplet.loadStrings(url.openStream());
    } catch (IOException e) {
      PGraphics.showException("Cannot load vertex shader " + url.getFile());
    }
    return null;
  }


  protected String[] loadVertexShader(String filename, int version) {
    return loadVertexShader(filename);
  }


  protected String[] loadFragmentShader(String filename, int version) {
    return loadFragmentShader(filename);
  }


  protected String[] loadFragmentShader(URL url, int version) {
    return loadFragmentShader(url);
  }


  protected String[] loadVertexShader(URL url, int version) {
    return loadVertexShader(url);
  }


  protected static String[] convertFragmentSource(String[] fragSrc0,
                                                  int version0, int version1) {
    if (version0 == 120 && version1 == 150) {
      String[] fragSrc = new String[fragSrc0.length + 2];
      fragSrc[0] = "#version 150";
      fragSrc[1] = "out vec4 fragColor;";
      for (int i = 0; i < fragSrc0.length; i++) {
        String line = fragSrc0[i];
        line = line.replace("varying", "in");
        line = line.replace("attribute", "in");
        line = line.replace("gl_FragColor", "fragColor");
        line = line.replace("texture", "texMap");
        line = line.replace("texMap2D(", "texture(");
        line = line.replace("texMap2DRect(", "texture(");
        fragSrc[i + 2] = line;
      }
      return fragSrc;
    }
    return fragSrc0;
  }



  protected static String[] convertVertexSource(String[] vertSrc0,
                                                int version0, int version1) {
    if (version0 == 120 && version1 == 150) {
      String[] vertSrc = new String[vertSrc0.length + 1];
      vertSrc[0] = "#version 150";
      for (int i = 0; i < vertSrc0.length; i++) {
        String line = vertSrc0[i];
        line = line.replace("attribute", "in");
        line = line.replace("varying", "out");
        vertSrc[i + 1] = line;
      }
      return vertSrc;
    }
    return vertSrc0;
  }

  protected int createShader(int shaderType, String source) {
    int shader = createShader(shaderType);
    if (shader != 0) {
      shaderSource(shader, source);
      compileShader(shader);
      if (!compiled(shader)) {
        System.err.println("Could not compile shader " + shaderType + ":");
        System.err.println(getShaderInfoLog(shader));
        deleteShader(shader);
        shader = 0;
      }
    }
    return shader;
  }


  protected int createProgram(int vertexShader, int fragmentShader) {
    int program = createProgram();
    if (program != 0) {
      attachShader(program, vertexShader);
      attachShader(program, fragmentShader);
      linkProgram(program);
      if (!linked(program)) {
        System.err.println("Could not link program: ");
        System.err.println(getProgramInfoLog(program));
        deleteProgram(program);
        program = 0;
      }
    }
    return program;
  }


  protected boolean compiled(int shader) {
    intBuffer.rewind();
    getShaderiv(shader, COMPILE_STATUS, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean linked(int program) {
    intBuffer.rewind();
    getProgramiv(program, LINK_STATUS, intBuffer);
    return intBuffer.get(0) == 0 ? false : true;
  }


  protected boolean validateFramebuffer() {
    int status = checkFramebufferStatus(FRAMEBUFFER);
    if (status == FRAMEBUFFER_COMPLETE) {
      return true;
    } else if (status == FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete attachment"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete missing attachment"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete dimensions"));
    } else if (status == FRAMEBUFFER_INCOMPLETE_FORMATS) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "incomplete formats"));
    } else if (status == FRAMEBUFFER_UNSUPPORTED) {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "framebuffer unsupported"));
    } else {
      System.err.println(String.format(FRAMEBUFFER_ERROR,
                                       "unknown error"));
    }
    return false;
  }


  protected int[] getGLVersion() {
    String version = getString(VERSION).trim();
    int[] res = {0, 0, 0};
    String[] parts = version.split(" ");
    for (int i = 0; i < parts.length; i++) {
      if (0 < parts[i].indexOf(".")) {
        String nums[] = parts[i].split("\\.");
        try {
          res[0] = Integer.parseInt(nums[0]);
        } catch (NumberFormatException e) { }
        if (1 < nums.length) {
          try {
            res[1] = Integer.parseInt(nums[1]);
          } catch (NumberFormatException e) { }
        }
        if (2 < nums.length) {
          try {
            res[2] = Integer.parseInt(nums[2]);
          } catch (NumberFormatException e) { }
        }
        break;
      }
    }
    return res;
  }


  protected boolean hasFBOs() {

    int major = getGLVersion()[0];
    if (major < 2) {
      String ext = getString(EXTENSIONS);
      return ext.indexOf("_framebuffer_object") != -1 &&
             ext.indexOf("_vertex_shader")      != -1 &&
             ext.indexOf("_shader_objects")     != -1 &&
             ext.indexOf("_shading_language")   != -1;
    } else {
      return true;
    }
  }


  protected boolean hasShaders() {



    int major = getGLVersion()[0];
    if (major < 2) {
      String ext = getString(EXTENSIONS);
      return ext.indexOf("_fragment_shader")  != -1 &&
             ext.indexOf("_vertex_shader")    != -1 &&
             ext.indexOf("_shader_objects")   != -1 &&
             ext.indexOf("_shading_language") != -1;
    } else {
      return true;
    }
  }


  protected boolean hasNpotTexSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_texture_non_power_of_two");
    } else {
      return true;
    }
  }


  protected boolean hasAutoMipmapGenSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_generate_mipmap");
    } else {
      return true;
    }
  }


  protected boolean hasFboMultisampleSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_framebuffer_multisample");
    } else {
      return true;
    }
  }


  protected boolean hasPackedDepthStencilSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_packed_depth_stencil");
    } else {
      return true;
    }
  }


  protected boolean hasAnisoSamplingSupport() {
    int major = getGLVersion()[0];
    if (major < 3) {
      String ext = getString(EXTENSIONS);
      return -1 < ext.indexOf("_texture_filter_anisotropic");
    } else {
      return true;
    }
  }


  protected int maxSamples() {
    intBuffer.rewind();
    getIntegerv(MAX_SAMPLES, intBuffer);
    return intBuffer.get(0);
  }


  protected int getMaxTexUnits() {
    intBuffer.rewind();
    getIntegerv(MAX_TEXTURE_IMAGE_UNITS, intBuffer);
    return intBuffer.get(0);
  }


  protected static ByteBuffer allocateDirectByteBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_BYTE;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder());
  }


  protected static ByteBuffer allocateByteBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectByteBuffer(size);
    } else {
      return ByteBuffer.allocate(size);
    }
  }


  protected static ByteBuffer allocateByteBuffer(byte[] arr) {
    if (USE_DIRECT_BUFFERS) {
      ByteBuffer buf = allocateDirectByteBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return ByteBuffer.wrap(arr);
    }
  }


  protected static ByteBuffer updateByteBuffer(ByteBuffer buf, byte[] arr,
                                               boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectByteBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = ByteBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = ByteBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateByteBuffer(ByteBuffer buf, byte[] arr,
                                         int offset, int size) {
    if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
      buf.position(offset);
      buf.put(arr, offset, size);
      buf.rewind();
    }
  }


  protected static void getByteArray(ByteBuffer buf, byte[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putByteArray(ByteBuffer buf, byte[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillByteBuffer(ByteBuffer buf, int i0, int i1,
                                       byte val) {
    int n = i1 - i0;
    byte[] temp = new byte[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static ShortBuffer allocateDirectShortBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_SHORT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asShortBuffer();
  }


  protected static ShortBuffer allocateShortBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectShortBuffer(size);
    } else {
      return ShortBuffer.allocate(size);
    }
  }


  protected static ShortBuffer allocateShortBuffer(short[] arr) {
    if (USE_DIRECT_BUFFERS) {
      ShortBuffer buf = allocateDirectShortBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return ShortBuffer.wrap(arr);
    }
  }


  protected static ShortBuffer updateShortBuffer(ShortBuffer buf, short[] arr,
                                                 boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectShortBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = ShortBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = ShortBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateShortBuffer(ShortBuffer buf, short[] arr,
                                          int offset, int size) {
    if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
      buf.position(offset);
      buf.put(arr, offset, size);
      buf.rewind();
    }
  }


  protected static void getShortArray(ShortBuffer buf, short[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putShortArray(ShortBuffer buf, short[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillShortBuffer(ShortBuffer buf, int i0, int i1,
                                        short val) {
    int n = i1 - i0;
    short[] temp = new short[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static IntBuffer allocateDirectIntBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_INT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asIntBuffer();
  }


  protected static IntBuffer allocateIntBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectIntBuffer(size);
    } else {
      return IntBuffer.allocate(size);
    }
  }


  protected static IntBuffer allocateIntBuffer(int[] arr) {
    if (USE_DIRECT_BUFFERS) {
      IntBuffer buf = allocateDirectIntBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return IntBuffer.wrap(arr);
    }
  }


  protected static IntBuffer updateIntBuffer(IntBuffer buf, int[] arr,
                                             boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectIntBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = IntBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = IntBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateIntBuffer(IntBuffer buf, int[] arr,
                                        int offset, int size) {
     if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
       buf.position(offset);
       buf.put(arr, offset, size);
       buf.rewind();
     }
   }


  protected static void getIntArray(IntBuffer buf, int[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putIntArray(IntBuffer buf, int[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillIntBuffer(IntBuffer buf, int i0, int i1, int val) {
    int n = i1 - i0;
    int[] temp = new int[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }


  protected static FloatBuffer allocateDirectFloatBuffer(int size) {
    int bytes = PApplet.max(MIN_DIRECT_BUFFER_SIZE, size) * SIZEOF_FLOAT;
    return ByteBuffer.allocateDirect(bytes).order(ByteOrder.nativeOrder()).
           asFloatBuffer();
  }


  protected static FloatBuffer allocateFloatBuffer(int size) {
    if (USE_DIRECT_BUFFERS) {
      return allocateDirectFloatBuffer(size);
    } else {
      return FloatBuffer.allocate(size);
    }
  }


  protected static FloatBuffer allocateFloatBuffer(float[] arr) {
    if (USE_DIRECT_BUFFERS) {
      FloatBuffer buf = allocateDirectFloatBuffer(arr.length);
      buf.put(arr);
      buf.position(0);
      return buf;
    } else {
      return FloatBuffer.wrap(arr);
    }
  }


  protected static FloatBuffer updateFloatBuffer(FloatBuffer buf, float[] arr,
                                                 boolean wrap) {
    if (USE_DIRECT_BUFFERS) {
      if (buf == null || buf.capacity() < arr.length) {
        buf = allocateDirectFloatBuffer(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    } else {
      if (wrap) {
        buf = FloatBuffer.wrap(arr);
      } else {
        if (buf == null || buf.capacity() < arr.length) {
          buf = FloatBuffer.allocate(arr.length);
        }
        buf.position(0);
        buf.put(arr);
        buf.rewind();
      }
    }
    return buf;
  }


  protected static void updateFloatBuffer(FloatBuffer buf, float[] arr,
                                        int offset, int size) {
     if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
       buf.position(offset);
       buf.put(arr, offset, size);
       buf.rewind();
     }
   }


  protected static void getFloatArray(FloatBuffer buf, float[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.get(arr);
      buf.rewind();
    }
  }


  protected static void putFloatArray(FloatBuffer buf, float[] arr) {
    if (!buf.hasArray() || buf.array() != arr) {
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }


  protected static void fillFloatBuffer(FloatBuffer buf, int i0, int i1,
                                        float val) {
    int n = i1 - i0;
    float[] temp = new float[n];
    Arrays.fill(temp, 0, n, val);
    buf.position(i0);
    buf.put(temp, 0, n);
    buf.rewind();
  }





  abstract protected int getFontAscent(Object font);


  abstract protected int getFontDescent(Object font);


  abstract protected int getTextWidth(Object font, char[] buffer, int start, int stop);


  abstract protected Object getDerivedFont(Object font, float size);







  protected abstract Tessellator createTessellator(TessellatorCallback callback);


  protected interface Tessellator {
    public void beginPolygon();
    public void endPolygon();
    public void setWindingRule(int rule);
    public void beginContour();
    public void endContour();
    public void addVertex(double[] v);
  }


  protected interface TessellatorCallback  {
    public void begin(int type);
    public void end();
    public void vertex(Object data);
    public void combine(double[] coords, Object[] data,
                        float[] weight, Object[] outData);
    public void error(int errnum);
  }


  protected String tessError(int err) {
    return "";
  }







  protected static boolean SHAPE_TEXT_SUPPORTED;
  protected static int SEG_MOVETO;
  protected static int SEG_LINETO;
  protected static int SEG_QUADTO;
  protected static int SEG_CUBICTO;
  protected static int SEG_CLOSE;


  protected abstract FontOutline createFontOutline(char ch, Object font);


  protected interface FontOutline {
    public boolean isDone();
    public int currentSegment(float coords[]);
    public void next();
  }





































  public static int FALSE;
  public static int TRUE;

  public static int INT;
  public static int BYTE;
  public static int SHORT;
  public static int FLOAT;
  public static int BOOL;
  public static int UNSIGNED_INT;
  public static int UNSIGNED_BYTE;
  public static int UNSIGNED_SHORT;

  public static int RGB;
  public static int RGBA;
  public static int ALPHA;
  public static int LUMINANCE;
  public static int LUMINANCE_ALPHA;

  public static int UNSIGNED_SHORT_5_6_5;
  public static int UNSIGNED_SHORT_4_4_4_4;
  public static int UNSIGNED_SHORT_5_5_5_1;

  public static int RGBA4;
  public static int RGB5_A1;
  public static int RGB565;
  public static int RGB8;
  public static int RGBA8;
  public static int ALPHA8;

  public static int READ_ONLY;
  public static int WRITE_ONLY;
  public static int READ_WRITE;

  public static int TESS_WINDING_NONZERO;
  public static int TESS_WINDING_ODD;

  public static int GENERATE_MIPMAP_HINT;
  public static int FASTEST;
  public static int NICEST;
  public static int DONT_CARE;

  public static int VENDOR;
  public static int RENDERER;
  public static int VERSION;
  public static int EXTENSIONS;
  public static int SHADING_LANGUAGE_VERSION;

  public static int MAX_SAMPLES;
  public static int SAMPLES;

  public static int ALIASED_LINE_WIDTH_RANGE;
  public static int ALIASED_POINT_SIZE_RANGE;

  public static int DEPTH_BITS;
  public static int STENCIL_BITS;

  public static int CCW;
  public static int CW;

  public static int VIEWPORT;

  public static int ARRAY_BUFFER;
  public static int ELEMENT_ARRAY_BUFFER;

  public static int MAX_VERTEX_ATTRIBS;

  public static int STATIC_DRAW;
  public static int DYNAMIC_DRAW;
  public static int STREAM_DRAW;

  public static int BUFFER_SIZE;
  public static int BUFFER_USAGE;

  public static int POINTS;
  public static int LINE_STRIP;
  public static int LINE_LOOP;
  public static int LINES;
  public static int TRIANGLE_FAN;
  public static int TRIANGLE_STRIP;
  public static int TRIANGLES;

  public static int CULL_FACE;
  public static int FRONT;
  public static int BACK;
  public static int FRONT_AND_BACK;

  public static int POLYGON_OFFSET_FILL;

  public static int UNPACK_ALIGNMENT;
  public static int PACK_ALIGNMENT;

  public static int TEXTURE_2D;
  public static int TEXTURE_RECTANGLE;

  public static int TEXTURE_BINDING_2D;
  public static int TEXTURE_BINDING_RECTANGLE;

  public static int MAX_TEXTURE_SIZE;
  public static int TEXTURE_MAX_ANISOTROPY;
  public static int MAX_TEXTURE_MAX_ANISOTROPY;

  public static int MAX_VERTEX_TEXTURE_IMAGE_UNITS;
  public static int MAX_TEXTURE_IMAGE_UNITS;
  public static int MAX_COMBINED_TEXTURE_IMAGE_UNITS;

  public static int NUM_COMPRESSED_TEXTURE_FORMATS;
  public static int COMPRESSED_TEXTURE_FORMATS;

  public static int NEAREST;
  public static int LINEAR;
  public static int LINEAR_MIPMAP_NEAREST;
  public static int LINEAR_MIPMAP_LINEAR;

  public static int CLAMP_TO_EDGE;
  public static int REPEAT;

  public static int TEXTURE0;
  public static int TEXTURE1;
  public static int TEXTURE2;
  public static int TEXTURE3;
  public static int TEXTURE_MIN_FILTER;
  public static int TEXTURE_MAG_FILTER;
  public static int TEXTURE_WRAP_S;
  public static int TEXTURE_WRAP_T;
  public static int TEXTURE_WRAP_R;

  public static int TEXTURE_CUBE_MAP;
  public static int TEXTURE_CUBE_MAP_POSITIVE_X;
  public static int TEXTURE_CUBE_MAP_POSITIVE_Y;
  public static int TEXTURE_CUBE_MAP_POSITIVE_Z;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_X;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_Y;
  public static int TEXTURE_CUBE_MAP_NEGATIVE_Z;

  public static int VERTEX_SHADER;
  public static int FRAGMENT_SHADER;
  public static int INFO_LOG_LENGTH;
  public static int SHADER_SOURCE_LENGTH;
  public static int COMPILE_STATUS;
  public static int LINK_STATUS;
  public static int VALIDATE_STATUS;
  public static int SHADER_TYPE;
  public static int DELETE_STATUS;

  public static int FLOAT_VEC2;
  public static int FLOAT_VEC3;
  public static int FLOAT_VEC4;
  public static int FLOAT_MAT2;
  public static int FLOAT_MAT3;
  public static int FLOAT_MAT4;
  public static int INT_VEC2;
  public static int INT_VEC3;
  public static int INT_VEC4;
  public static int BOOL_VEC2;
  public static int BOOL_VEC3;
  public static int BOOL_VEC4;
  public static int SAMPLER_2D;
  public static int SAMPLER_CUBE;

  public static int LOW_FLOAT;
  public static int MEDIUM_FLOAT;
  public static int HIGH_FLOAT;
  public static int LOW_INT;
  public static int MEDIUM_INT;
  public static int HIGH_INT;

  public static int CURRENT_VERTEX_ATTRIB;

  public static int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
  public static int VERTEX_ATTRIB_ARRAY_ENABLED;
  public static int VERTEX_ATTRIB_ARRAY_SIZE;
  public static int VERTEX_ATTRIB_ARRAY_STRIDE;
  public static int VERTEX_ATTRIB_ARRAY_TYPE;
  public static int VERTEX_ATTRIB_ARRAY_NORMALIZED;
  public static int VERTEX_ATTRIB_ARRAY_POINTER;

  public static int BLEND;
  public static int ONE;
  public static int ZERO;
  public static int SRC_ALPHA;
  public static int DST_ALPHA;
  public static int ONE_MINUS_SRC_ALPHA;
  public static int ONE_MINUS_DST_COLOR;
  public static int ONE_MINUS_SRC_COLOR;
  public static int DST_COLOR;
  public static int SRC_COLOR;

  public static int SAMPLE_ALPHA_TO_COVERAGE;
  public static int SAMPLE_COVERAGE;

  public static int KEEP;
  public static int REPLACE;
  public static int INCR;
  public static int DECR;
  public static int INVERT;
  public static int INCR_WRAP;
  public static int DECR_WRAP;
  public static int NEVER;
  public static int ALWAYS;

  public static int EQUAL;
  public static int LESS;
  public static int LEQUAL;
  public static int GREATER;
  public static int GEQUAL;
  public static int NOTEQUAL;

  public static int FUNC_ADD;
  public static int FUNC_MIN;
  public static int FUNC_MAX;
  public static int FUNC_REVERSE_SUBTRACT;
  public static int FUNC_SUBTRACT;

  public static int DITHER;

  public static int CONSTANT_COLOR;
  public static int CONSTANT_ALPHA;
  public static int ONE_MINUS_CONSTANT_COLOR;
  public static int ONE_MINUS_CONSTANT_ALPHA;
  public static int SRC_ALPHA_SATURATE;

  public static int SCISSOR_TEST;
  public static int STENCIL_TEST;
  public static int DEPTH_TEST;
  public static int DEPTH_WRITEMASK;
  public static int ALPHA_TEST;

  public static int COLOR_BUFFER_BIT;
  public static int DEPTH_BUFFER_BIT;
  public static int STENCIL_BUFFER_BIT;

  public static int FRAMEBUFFER;
  public static int COLOR_ATTACHMENT0;
  public static int COLOR_ATTACHMENT1;
  public static int COLOR_ATTACHMENT2;
  public static int COLOR_ATTACHMENT3;
  public static int RENDERBUFFER;
  public static int DEPTH_ATTACHMENT;
  public static int STENCIL_ATTACHMENT;
  public static int READ_FRAMEBUFFER;
  public static int DRAW_FRAMEBUFFER;

  public static int DEPTH24_STENCIL8;

  public static int DEPTH_COMPONENT;
  public static int DEPTH_COMPONENT16;
  public static int DEPTH_COMPONENT24;
  public static int DEPTH_COMPONENT32;

  public static int STENCIL_INDEX;
  public static int STENCIL_INDEX1;
  public static int STENCIL_INDEX4;
  public static int STENCIL_INDEX8;

  public static int DEPTH_STENCIL;

  public static int FRAMEBUFFER_COMPLETE;
  public static int FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
  public static int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
  public static int FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
  public static int FRAMEBUFFER_INCOMPLETE_FORMATS;
  public static int FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER;
  public static int FRAMEBUFFER_INCOMPLETE_READ_BUFFER;
  public static int FRAMEBUFFER_UNSUPPORTED;

  public static int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
  public static int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
  public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
  public static int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;

  public static int RENDERBUFFER_WIDTH;
  public static int RENDERBUFFER_HEIGHT;
  public static int RENDERBUFFER_RED_SIZE;
  public static int RENDERBUFFER_GREEN_SIZE;
  public static int RENDERBUFFER_BLUE_SIZE;
  public static int RENDERBUFFER_ALPHA_SIZE;
  public static int RENDERBUFFER_DEPTH_SIZE;
  public static int RENDERBUFFER_STENCIL_SIZE;
  public static int RENDERBUFFER_INTERNAL_FORMAT;

  public static int MULTISAMPLE;
  public static int POINT_SMOOTH;
  public static int LINE_SMOOTH;
  public static int POLYGON_SMOOTH;





  public abstract void flush();
  public abstract void finish();
  public abstract void hint(int target, int hint);





  public abstract void enable(int value);
  public abstract void disable(int value);
  public abstract void getBooleanv(int value, IntBuffer data);
  public abstract void getIntegerv(int value, IntBuffer data);
  public abstract void getFloatv(int value, FloatBuffer data);
  public abstract boolean isEnabled(int value);
  public abstract String getString(int name);





  public abstract int getError();
  public abstract String errorString(int err);





  public abstract void genBuffers(int n, IntBuffer buffers);
  public abstract void deleteBuffers(int n, IntBuffer buffers);
  public abstract void bindBuffer(int target, int buffer);
  public abstract void bufferData(int target, int size, Buffer data, int usage);
  public abstract void bufferSubData(int target, int offset, int size, Buffer data);
  public abstract void isBuffer(int buffer);
  public abstract void getBufferParameteriv(int target, int value, IntBuffer data);
  public abstract ByteBuffer mapBuffer(int target, int access);
  public abstract ByteBuffer mapBufferRange(int target, int offset, int length, int access);
  public abstract void unmapBuffer(int target);





  public abstract void depthRangef(float n, float f);
  public abstract void viewport(int x, int y, int w, int h);









  public void readPixels(int x, int y, int width, int height, int format, int type, Buffer buffer){
    boolean pgCall = format != STENCIL_INDEX &&
                     format != DEPTH_COMPONENT && format != DEPTH_STENCIL;
    if (pgCall) pg.beginReadPixels();
    readPixelsImpl(x, y, width, height, format, type, buffer);
    if (pgCall) pg.endReadPixels();
  }

  protected abstract void readPixelsImpl(int x, int y, int width, int height, int format, int type, Buffer buffer);





  public abstract void vertexAttrib1f(int index, float value);
  public abstract void vertexAttrib2f(int index, float value0, float value1);
  public abstract void vertexAttrib3f(int index, float value0, float value1, float value2);
  public abstract void vertexAttrib4f(int index, float value0, float value1, float value2, float value3);
  public abstract void vertexAttrib1fv(int index, FloatBuffer values);
  public abstract void vertexAttrib2fv(int index, FloatBuffer values);
  public abstract void vertexAttrib3fv(int index, FloatBuffer values);
  public abstract void vertexAttri4fv(int index, FloatBuffer values);
  public abstract void vertexAttribPointer(int index, int size, int type, boolean normalized, int stride, int offset);
  public abstract void vertexAttribPointer(int index, int size, int type, boolean normalized, int stride, Buffer data);
  public abstract void enableVertexAttribArray(int index);
  public abstract void disableVertexAttribArray(int index);
  public abstract void drawArrays(int mode, int first, int count);
  public abstract void drawElements(int mode, int count, int type, int offset);
  public abstract void drawElements(int mode, int count, int type, Buffer indices);





  public abstract void lineWidth(float width);
  public abstract void frontFace(int dir);
  public abstract void cullFace(int mode);
  public abstract void polygonOffset(float factor, float units);





  public abstract void pixelStorei(int pname, int param);





  public abstract void texImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Buffer data);
  public abstract void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border);
  public abstract void texSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, Buffer data);
  public abstract void copyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height);
  public abstract void compressedTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int imageSize, Buffer data);
  public abstract void compressedTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int imageSize, Buffer data);
  public abstract void texParameteri(int target, int pname, int param);
  public abstract void texParameterf(int target, int pname, float param);
  public abstract void texParameteriv(int target, int pname, IntBuffer params);
  public abstract void texParameterfv(int target, int pname, FloatBuffer params);
  public abstract void generateMipmap(int target);
  public abstract void genTextures(int n, IntBuffer textures);
  public abstract void deleteTextures(int n, IntBuffer textures);
  public abstract void getTexParameteriv(int target, int pname, IntBuffer params);
  public abstract void getTexParameterfv(int target, int pname, FloatBuffer params);
  public abstract boolean isTexture(int texture);




  public void activeTexture(int texture) {
    activeTexUnit = texture - TEXTURE0;
    activeTextureImpl(texture);
  }

  protected abstract void activeTextureImpl(int texture);

  public void bindTexture(int target, int texture) {
    bindTextureImpl(target, texture);

    if (boundTextures == null) {
      maxTexUnits = getMaxTexUnits();
      boundTextures = new int[maxTexUnits][2];
    }

    if (maxTexUnits <= activeTexUnit) {
      throw new RuntimeException(TEXUNIT_ERROR);
    }

    if (target == TEXTURE_2D) {
      boundTextures[activeTexUnit][0] = texture;
    } else if (target == TEXTURE_RECTANGLE) {
      boundTextures[activeTexUnit][1] = texture;
    }
  }
  protected abstract void bindTextureImpl(int target, int texture);





  public abstract int createShader(int type);
  public abstract void shaderSource(int shader, String source);
  public abstract void compileShader(int shader);
  public abstract void releaseShaderCompiler();
  public abstract void deleteShader(int shader);
  public abstract void shaderBinary(int count, IntBuffer shaders, int binaryFormat, Buffer binary, int length);
  public abstract int createProgram();
  public abstract void attachShader(int program, int shader);
  public abstract void detachShader(int program, int shader);
  public abstract void linkProgram(int program);
  public abstract void useProgram(int program);
  public abstract void deleteProgram(int program);
  public abstract String getActiveAttrib(int program, int index, IntBuffer size, IntBuffer type);
  public abstract int getAttribLocation(int program, String name);
  public abstract void bindAttribLocation(int program, int index, String name);
  public abstract int getUniformLocation(int program, String name);
  public abstract String getActiveUniform(int program, int index, IntBuffer size, IntBuffer type);
  public abstract void uniform1i(int location, int value);
  public abstract void uniform2i(int location, int value0, int value1);
  public abstract void uniform3i(int location, int value0, int value1, int value2);
  public abstract void uniform4i(int location, int value0, int value1, int value2, int value3);
  public abstract void uniform1f(int location, float value);
  public abstract void uniform2f(int location, float value0, float value1);
  public abstract void uniform3f(int location, float value0, float value1, float value2);
  public abstract void uniform4f(int location, float value0, float value1, float value2, float value3);
  public abstract void uniform1iv(int location, int count, IntBuffer v);
  public abstract void uniform2iv(int location, int count, IntBuffer v);
  public abstract void uniform3iv(int location, int count, IntBuffer v);
  public abstract void uniform4iv(int location, int count, IntBuffer v);
  public abstract void uniform1fv(int location, int count, FloatBuffer v);
  public abstract void uniform2fv(int location, int count, FloatBuffer v);
  public abstract void uniform3fv(int location, int count, FloatBuffer v);
  public abstract void uniform4fv(int location, int count, FloatBuffer v);
  public abstract void uniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void uniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void uniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer mat);
  public abstract void validateProgram(int program);
  public abstract boolean isShader(int shader);
  public abstract void getShaderiv(int shader, int pname, IntBuffer params);
  public abstract void getAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders);
  public abstract String getShaderInfoLog(int shader);
  public abstract String getShaderSource(int shader);
  public abstract void getShaderPrecisionFormat(int shaderType, int precisionType, IntBuffer range, IntBuffer precision);
  public abstract void getVertexAttribfv(int index, int pname, FloatBuffer params);
  public abstract void getVertexAttribiv(int index, int pname, IntBuffer params);
  public abstract void getVertexAttribPointerv(int index, int pname, ByteBuffer data);
  public abstract void getUniformfv(int program, int location, FloatBuffer params);
  public abstract void getUniformiv(int program, int location, IntBuffer params);
  public abstract boolean isProgram(int program);
  public abstract void getProgramiv(int program, int pname, IntBuffer params);
  public abstract String getProgramInfoLog(int program);





  public abstract void scissor(int x, int y, int w, int h);
  public abstract void sampleCoverage(float value, boolean invert);
  public abstract void stencilFunc(int func, int ref, int mask);
  public abstract void stencilFuncSeparate(int face, int func, int ref, int mask);
  public abstract void stencilOp(int sfail, int dpfail, int dppass);
  public abstract void stencilOpSeparate(int face, int sfail, int dpfail, int dppass);
  public abstract void depthFunc(int func);
  public abstract void blendEquation(int mode);
  public abstract void blendEquationSeparate(int modeRGB, int modeAlpha);
  public abstract void blendFunc(int src, int dst);
  public abstract void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);
  public abstract void blendColor(float red, float green, float blue, float alpha);
  public abstract void alphaFunc(int func, float ref);





  public abstract void colorMask(boolean r, boolean g, boolean b, boolean a);
  public abstract void depthMask(boolean mask);
  public abstract void stencilMask(int mask);
  public abstract void stencilMaskSeparate(int face, int mask);
  public abstract void clear(int buf);
  public abstract void clearColor(float r, float g, float b, float a);
  public abstract void clearDepth(float d);
  public abstract void clearStencil(int s);





  public void bindFramebuffer(int target, int framebuffer) {
    pg.beginBindFramebuffer(target, framebuffer);
    bindFramebufferImpl(target, framebuffer);
    pg.endBindFramebuffer(target, framebuffer);
  }
  protected abstract void bindFramebufferImpl(int target, int framebuffer);

  public abstract void deleteFramebuffers(int n, IntBuffer framebuffers);
  public abstract void genFramebuffers(int n, IntBuffer framebuffers);
  public abstract void bindRenderbuffer(int target, int renderbuffer);
  public abstract void deleteRenderbuffers(int n, IntBuffer renderbuffers);
  public abstract void genRenderbuffers(int n, IntBuffer renderbuffers);
  public abstract void renderbufferStorage(int target, int internalFormat, int width, int height);
  public abstract void framebufferRenderbuffer(int target, int attachment, int rendbuferfTarget, int renderbuffer);
  public abstract void framebufferTexture2D(int target, int attachment, int texTarget, int texture, int level);
  public abstract int checkFramebufferStatus(int target);
  public abstract boolean isFramebuffer(int framebuffer);
  public abstract void getFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params);
  public abstract boolean isRenderbuffer(int renderbuffer);
  public abstract void getRenderbufferParameteriv(int target, int pname, IntBuffer params);
  public abstract void blitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter);
  public abstract void renderbufferStorageMultisample(int target, int samples, int format, int width, int height);
  public abstract void readBuffer(int buf);
  public abstract void drawBuffer(int buf);



  int[] labelPix = {-2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1315861, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1118482, -1, -2105377, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -855310, -263173, -131587, -460552, -1315861, -2236963, -2236963, -1052689, -263173, -1, -460552, -1118482, -2236963, -2236963, -1776412, -657931, -197380, -197380, -723724,
-1907998, -2236963, -2236963, -2236963, -789517, -1118482, -1447447, -460552, -197380, -789517, -1710619, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-526345, -131587, -921103, -1250068, -592138, -1, -1184275, -2236963, -1447447, -526345, -1, -1052689, -1513240, -2236963, -1710619, -1, -328966, -1184275, -1118482, -263173, -65794, -1776412, -2236963, -2236963, -394759, -263173, -65794, -1118482, -1381654, -394759, -131587, -1907998, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -1, -1184275, -2236963, -2236963, -2236963, -460552, -723724, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -2171170, -328966, -263173, -2105377, -2236963, -2236963, -2039584, -197380, -460552, -2236963, -2236963, -394759, -1, -1513240, -2236963, -2236963, -2105377, -197380, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2171170, -65794, -394759, -1710619, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1907998, -1, -1184275, -2236963, -2236963, -2236963, -2236963, -1052689, -1, -1973791, -2236963, -394759, -328966, -2236963, -2236963, -2236963, -2236963, -1052689, -65794, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1250068, -1, -1, -197380, -855310, -1579033, -2236963, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1579033, -1, -1579033, -2236963, -2236963, -2236963, -2236963,
-1447447, -1, -1644826, -2236963, -394759, -657931, -2236963, -2236963, -2236963, -2236963, -1381654, -1, -1842205, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -1776412, -986896, -328966, -1, -1, -855310, -2236963, -2236963, -1052689, -1, -2105377, -2236963, -1447447, -1, -1644826, -2236963, -2236963, -2236963, -2236963, -1513240, -1, -1579033, -2236963, -394759, -789517, -2236963, -2236963, -2236963, -2236963, -1381654, -1, -1776412, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2105377, -2171170, -2236963, -2236963, -1907998, -460552, -1, -1973791, -2236963, -1052689, -1, -2105377, -2236963, -1776412, -1, -1381654, -2236963, -2236963, -2236963, -2236963, -1184275, -1, -1776412, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -1118482, -65794, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1776412, -1, -1250068, -2236963, -2236963, -2236963, -1250068, -1, -1776412, -2236963, -1118482, -1, -2039584, -2236963, -2105377, -131587, -460552, -2236963, -2236963, -2236963, -2236963, -328966, -131587, -2171170, -2236963, -394759, -1, -1907998, -2236963, -2236963, -2236963, -328966, -394759, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -592138, -197380, -1250068, -1842205, -1381654, -263173, -263173, -2236963, -2236963, -1250068, -1, -921103, -1579033, -2236963, -1250068, -1, -789517, -1776412, -1776412, -657931,
-1, -1513240, -2236963, -2236963, -394759, -1, -394759, -1644826, -1776412, -723724, -65794, -1776412, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-1842205, -460552, -1, -1, -1, -526345, -1973791, -2236963, -2236963, -2039584, -394759, -1, -460552, -2236963, -2236963, -1315861, -131587, -1, -1, -394759, -1447447, -2236963, -2236963, -2236963, -394759, -460552, -855310, -1, -1, -394759, -1513240, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2039584, -1842205, -2171170, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2105377, -2171170, -2236963, -2236963, -2236963, -2236963, -1973791, -2039584, -2236963, -2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2105377, -1973791, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -394759, -526345, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -1184275, -1250068, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963,
-2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963, -2236963
 };

}

<code block>
package processing.opengl;

import java.awt.Component;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;

import java.awt.Point;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;

import com.jogamp.common.util.IOUtil.ClassResources;
import com.jogamp.nativewindow.NativeSurface;
import com.jogamp.nativewindow.ScalableSurface;
import com.jogamp.opengl.GLAnimatorControl;
import com.jogamp.opengl.GLAutoDrawable;
import com.jogamp.opengl.GLCapabilities;
import com.jogamp.opengl.GLEventListener;
import com.jogamp.opengl.GLException;
import com.jogamp.opengl.GLProfile;
import com.jogamp.nativewindow.MutableGraphicsConfiguration;
import com.jogamp.newt.Display;
import com.jogamp.newt.MonitorDevice;
import com.jogamp.newt.NewtFactory;
import com.jogamp.newt.Screen;
import com.jogamp.newt.awt.NewtCanvasAWT;
import com.jogamp.newt.event.InputEvent;


import com.jogamp.newt.opengl.GLWindow;
import com.jogamp.opengl.util.FPSAnimator;

import processing.core.PApplet;
import processing.core.PConstants;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PSurface;
import processing.event.KeyEvent;
import processing.event.MouseEvent;
import processing.opengl.PGraphicsOpenGL;
import processing.opengl.PGL;

public class PSurfaceJOGL implements PSurface {

  public static GLProfile profile;

  PJOGL pgl;

  GLWindow window;
  FPSAnimator animator;
  Rectangle screenRect;

  PApplet sketch;
  PGraphics graphics;

  int sketchX;
  int sketchY;
  int sketchWidth;
  int sketchHeight;

  Display display;
  Screen screen;
  List<MonitorDevice> monitors;
  MonitorDevice displayDevice;
  Throwable drawException;
  Object waitObject = new Object();

  NewtCanvasAWT canvas;

  float[] currentPixelScale = {0, 0};

  boolean presentMode = false;
  float offsetX;
  float offsetY;


  public PSurfaceJOGL(PGraphics graphics) {
    this.graphics = graphics;
    this.pgl = (PJOGL) ((PGraphicsOpenGL)graphics).pgl;
  }


  public void initOffscreen(PApplet sketch) {
    this.sketch = sketch;

    sketchWidth = sketch.sketchWidth();
    sketchHeight = sketch.sketchHeight();

    if (window != null) {
      canvas = new NewtCanvasAWT(window);
      canvas.setBounds(0, 0, window.getWidth(), window.getHeight());

      canvas.setFocusable(true);
    }
  }


  public void initFrame(PApplet sketch) {
    this.sketch = sketch;
    initIcons();
    initScreen();
    initGL();
    initWindow();
    initListeners();
    initAnimator();
    window.setVisible(true);
  }


  protected void initScreen() {
    display = NewtFactory.createDisplay(null);
    display.addReference();
    screen = NewtFactory.createScreen(display, 0);
    screen.addReference();

    monitors = new ArrayList<MonitorDevice>();
    GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice[] devices = environment.getScreenDevices();
    for (GraphicsDevice device: devices) {
      String did = device.getIDstring();
      String[] parts = did.split("Display");
      String id1 = "";
      if (1 < parts.length) {
        id1 = parts[1].trim();
      }
      MonitorDevice monitor = null;
      for (int i = 0; i < screen.getMonitorDevices().size(); i++) {
        MonitorDevice mon = screen.getMonitorDevices().get(i);
        String mid = String.valueOf(mon.getId());
        if (id1.equals(mid)) {




          monitor = mon;
          break;
        }
      }
      if (monitor == null) {

        for (int i = 0; i < screen.getMonitorDevices().size(); i++) {
          MonitorDevice mon = screen.getMonitorDevices().get(i);
          String mid = String.valueOf(mon.getId());
          if (-1 < did.indexOf(mid)) {
            monitor = mon;
            break;
          }
        }
      }
      if (monitor != null) {
        monitors.add(monitor);
      }
    }
  }

  protected void initGL() {

    if (profile == null) {
      if (PJOGL.PROFILE == 2) {
        try {
          profile = GLProfile.getGL2ES1();
        } catch (GLException ex) {
          profile = GLProfile.getMaxFixedFunc(true);
        }
      } else if (PJOGL.PROFILE == 3) {
        try {
          profile = GLProfile.getGL2GL3();
        } catch (GLException ex) {
          profile = GLProfile.getMaxProgrammable(true);
        }
        if (!profile.isGL3()) {
          PGraphics.showWarning("Requested profile GL3 but is not available, got: " + profile);
        }
      } else if (PJOGL.PROFILE == 4) {
        try {
          profile = GLProfile.getGL4ES3();
        } catch (GLException ex) {
          profile = GLProfile.getMaxProgrammable(true);
        }
        if (!profile.isGL4()) {
          PGraphics.showWarning("Requested profile GL4 but is not available, got: " + profile);
        }
      } else throw new RuntimeException(PGL.UNSUPPORTED_GLPROF_ERROR);
    }


    GLCapabilities caps = new GLCapabilities(profile);
    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);
    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);
    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);




    pgl.reqNumSamples = PGL.smoothToSamples(graphics.smooth);
    caps.setSampleBuffers(true);
    caps.setNumSamples(pgl.reqNumSamples);
    caps.setBackgroundOpaque(true);
    caps.setOnscreen(true);
    pgl.capabilities = caps;
  }


  protected void initWindow() {
    window = GLWindow.create(screen, pgl.capabilities);
    if (displayDevice == null) {
      displayDevice = window.getMainMonitor();
    }

    int displayNum = sketch.sketchDisplay();
    if (displayNum > 0) {  
      if (displayNum <= monitors.size()) {
        displayDevice = monitors.get(displayNum - 1);
      } else {
        System.err.format("Display %d does not exist, " +
          "using the default display instead.%n", displayNum);
        for (int i = 0; i < monitors.size(); i++) {
          System.err.format("Display %d is %s%n", i+1, monitors.get(i));
        }
      }
    }

    boolean spanDisplays = sketch.sketchDisplay() == PConstants.SPAN;
    screenRect = spanDisplays ?
      new Rectangle(0, 0, screen.getWidth(), screen.getHeight()) :
      new Rectangle(0, 0,
                    displayDevice.getViewportInWindowUnits().getWidth(),
                    displayDevice.getViewportInWindowUnits().getHeight());



    sketch.displayWidth = screenRect.width;
    sketch.displayHeight = screenRect.height;

    sketchWidth = sketch.sketchWidth();
    sketchHeight = sketch.sketchHeight();

    boolean fullScreen = sketch.sketchFullScreen();


    if (screenRect.width == sketchWidth &&
        screenRect.height == sketchHeight) {
      fullScreen = true;
      sketch.fullScreen();
    }

    if (fullScreen || spanDisplays) {
      sketchWidth = screenRect.width;
      sketchHeight = screenRect.height;
    }

    float[] reqSurfacePixelScale;
    if (graphics.is2X()) {

       reqSurfacePixelScale = new float[] { ScalableSurface.AUTOMAX_PIXELSCALE,
                                            ScalableSurface.AUTOMAX_PIXELSCALE };
    } else {

      reqSurfacePixelScale = new float[] { ScalableSurface.IDENTITY_PIXELSCALE,
                                           ScalableSurface.IDENTITY_PIXELSCALE };
    }
    window.setSurfaceScale(reqSurfacePixelScale);
    window.setSize(sketchWidth, sketchHeight);
    setSize(sketchWidth, sketchHeight);
    sketchX = displayDevice.getViewportInWindowUnits().getX();
    sketchY = displayDevice.getViewportInWindowUnits().getY();
    if (fullScreen) {
      PApplet.hideMenuBar();
      window.setTopLevelPosition(sketchX, sketchY);
      if (spanDisplays) {
        window.setFullscreen(monitors);
      } else {
        window.setFullscreen(true);
      }
    }
  }


  protected void initListeners() {
    NEWTMouseListener mouseListener = new NEWTMouseListener();
    window.addMouseListener(mouseListener);
    NEWTKeyListener keyListener = new NEWTKeyListener();
    window.addKeyListener(keyListener);
    NEWTWindowListener winListener = new NEWTWindowListener();
    window.addWindowListener(winListener);

    DrawListener drawlistener = new DrawListener();
    window.addGLEventListener(drawlistener);
  }


  protected void initAnimator() {

    animator = new FPSAnimator(window, 60);
    drawException = null;
    animator.setUncaughtExceptionHandler(new GLAnimatorControl.UncaughtExceptionHandler() {
      @Override
      public void uncaughtException(final GLAnimatorControl animator,
                                    final GLAutoDrawable drawable,
                                    final Throwable cause) {
        synchronized (waitObject) {

          drawException = cause;
          waitObject.notify();
        }
      }
    });

    new Thread(new Runnable() {
      public void run() {
        synchronized (waitObject) {
          try {
            if (drawException == null) waitObject.wait();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }

          if (drawException != null) {
            Throwable cause = drawException.getCause();
            if (cause instanceof ThreadDeath) {


            } else if (cause instanceof RuntimeException) {
              throw (RuntimeException)cause;
            } else {
              throw new RuntimeException(cause);
            }
          }
        }
      }
    }).start();
  }

  @Override
  public void setTitle(String title) {
    window.setTitle(title);
  }

  @Override
  public void setVisible(boolean visible) {
    window.setVisible(visible);
  }

  @Override
  public void setResizable(boolean resizable) {


  }

  private void setFrameCentered() {


    int sketchX = displayDevice.getViewportInWindowUnits().getX();
    int sketchY = displayDevice.getViewportInWindowUnits().getY();








    int w = sketchWidth;
    int h = sketchHeight;





    window.setTopLevelPosition(sketchX + screenRect.x + (screenRect.width - w) / 2,
                               sketchY + screenRect.y + (screenRect.height - h) / 2);
  }


  @Override
  public void placeWindow(int[] location, int[] editorLocation) {




    int x = window.getX() - window.getInsets().getLeftWidth();
    int y = window.getY() - window.getInsets().getTopHeight();
    int w = window.getWidth() + window.getInsets().getTotalWidth();
    int h = window.getHeight() + window.getInsets().getTotalHeight();

    if (location != null) {

      window.setTopLevelPosition(location[0], location[1]);

    } else if (editorLocation != null) {

      int locationX = editorLocation[0] - 20;
      int locationY = editorLocation[1];

      if (locationX - w > 10) {

        window.setTopLevelPosition(locationX - w, locationY);

      } else {  



        locationX = editorLocation[0] + 66;
        locationY = editorLocation[1] + 66;

        if ((locationX + w > sketch.displayWidth - 33) ||
            (locationY + h > sketch.displayHeight - 33)) {

          locationX = (sketch.displayWidth - w) / 2;
          locationY = (sketch.displayHeight - h) / 2;
        }
        window.setTopLevelPosition(locationX, locationY);
      }
    } else {  
      setFrameCentered();
    }

    Point frameLoc = new Point(x, y);
    if (frameLoc.y < 0) {


      window.setTopLevelPosition(frameLoc.x, 30);
    }




  }


  public void placePresent(int stopColor) {



    presentMode = pgl.presentMode = true;
    offsetX = pgl.offsetX = 0.5f * (screenRect.width - sketchWidth);
    offsetY = pgl.offsetY = 0.5f * (screenRect.height - sketchHeight);
    pgl.requestFBOLayer();

    window.setSize(screenRect.width, screenRect.height);
    PApplet.hideMenuBar();
    window.setTopLevelPosition(sketchX + screenRect.x,
                               sketchY + screenRect.y);

    window.setFullscreen(true);





  }


  protected void initIcons() {
    final int[] sizes = { 16, 32, 48, 64, 128, 256, 512 };
    String[] iconImages = new String[sizes.length];
    for (int i = 0; i < sizes.length; i++) {
      iconImages[i] = "/icon/icon-" + sizes[i] + ".png";
    }
    NewtFactory.setWindowIcons(new ClassResources(PApplet.class, iconImages));
  }


  public void setupExternalMessages() {


  }


  public void startThread() {
    if (animator != null) {

      animator.start();

      if (0 < sketchX && 0 < sketchY) {

          window.setTopLevelPosition(sketchX, sketchY);
          sketchX = sketchY = 0;
      }

    }
  }

  public void pauseThread() {
    if (animator != null) {
      animator.pause();
    }
  }

  public void resumeThread() {
    if (animator != null) {
      animator.resume();
    }
  }

  public boolean stopThread() {
    if (animator != null) {
      return animator.stop();
    } else {
      return false;
    }
  }

  public boolean isStopped() {
    if (animator != null) {
      return !animator.isAnimating();
    } else {
      return true;
    }
  }

  public void setSize(int width, int height) {
    if (width == sketch.width && height == sketch.height) {
      return;
    }





      if (!presentMode) {


        sketch.setSize(width, height);
        sketchWidth = width;
        sketchHeight = height;
        graphics.setSize(width, height);
      }



  }

  public float getPixelScale() {
    if (graphics.is2X()) {


      window.getCurrentSurfaceScale(currentPixelScale);
      return currentPixelScale[0];
    } else {
      return 1;
    }
  }

  public Component getComponent() {
    return canvas;
  }

  public void setSmooth(int level) {
    pgl.reqNumSamples = level;
    GLCapabilities caps = new GLCapabilities(profile);
    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);
    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);
    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);
    caps.setSampleBuffers(true);
    caps.setNumSamples(pgl.reqNumSamples);
    caps.setBackgroundOpaque(true);
    caps.setOnscreen(true);
    NativeSurface target = window.getNativeSurface();
    MutableGraphicsConfiguration config = (MutableGraphicsConfiguration) target.getGraphicsConfiguration();
    config.setChosenCapabilities(caps);
  }

  public void setFrameRate(float fps) {
    if (animator != null) {
      animator.stop();
      animator.setFPS((int)fps);
      pgl.setFps(fps);
      animator.start();
    }
  }

  public void requestFocus() {
    window.requestFocus();
  }

  class DrawListener implements GLEventListener {
    public void display(GLAutoDrawable drawable) {
      pgl.getGL(drawable);

      sketch.handleDraw();

      if (sketch.frameCount == 1) {
        requestFocus();
      }

      if (sketch.exitCalled()) {

        animator.stop();
        sketch.dispose();
        sketch.exitActual();
      }
    }
    public void dispose(GLAutoDrawable drawable) {


      sketch.dispose();



    }
    public void init(GLAutoDrawable drawable) {

      pgl.getGL(drawable);
      pgl.init(drawable);
      sketch.start();


      int c = graphics.backgroundColor;
      pgl.clearColor(((c >> 16) & 0xff) / 255f,
                     ((c >>  8) & 0xff) / 255f,
                     ((c >>  0) & 0xff) / 255f,
                     ((c >> 24) & 0xff) / 255f);
      pgl.clear(PGL.COLOR_BUFFER_BIT);
    }

    public void reshape(GLAutoDrawable drawable, int x, int y, int w, int h) {


      window.getCurrentSurfaceScale(currentPixelScale);










      pgl.getGL(drawable);





      setSize((int)(w/currentPixelScale[0]), (int)(h/currentPixelScale[1]));
    }
  }

  protected class NEWTWindowListener implements com.jogamp.newt.event.WindowListener {
    public NEWTWindowListener() {
      super();
    }
    @Override
    public void windowGainedFocus(com.jogamp.newt.event.WindowEvent arg0) {


    }

    @Override
    public void windowLostFocus(com.jogamp.newt.event.WindowEvent arg0) {


    }

    @Override
    public void windowDestroyNotify(com.jogamp.newt.event.WindowEvent arg0) {

      PSurfaceJOGL.this.sketch.dispose();
      PSurfaceJOGL.this.sketch.exitActual();
    }

    @Override
    public void windowDestroyed(com.jogamp.newt.event.WindowEvent arg0) {
    }

    @Override
    public void windowMoved(com.jogamp.newt.event.WindowEvent arg0) {
    }

    @Override
    public void windowRepaint(com.jogamp.newt.event.WindowUpdateEvent arg0) {
    }

    @Override
    public void windowResized(com.jogamp.newt.event.WindowEvent arg0) {





    }

  }


  protected class NEWTMouseListener extends com.jogamp.newt.event.MouseAdapter {
    public NEWTMouseListener() {
      super();
    }
    @Override
    public void mousePressed(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.PRESS);
    }
    @Override
    public void mouseReleased(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.RELEASE);
    }
    @Override
    public void mouseClicked(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.CLICK);
    }
    @Override
    public void mouseDragged(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.DRAG);
    }
    @Override
    public void mouseMoved(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.MOVE);
    }
    @Override
    public void mouseWheelMoved(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.WHEEL);
    }
    @Override
    public void mouseEntered(com.jogamp.newt.event.MouseEvent e) {

      nativeMouseEvent(e, MouseEvent.ENTER);
    }
    @Override
    public void mouseExited(com.jogamp.newt.event.MouseEvent e) {

      nativeMouseEvent(e, MouseEvent.EXIT);
    }
  }


  protected class NEWTKeyListener extends com.jogamp.newt.event.KeyAdapter {
    public NEWTKeyListener() {
      super();
    }
    @Override
    public void keyPressed(com.jogamp.newt.event.KeyEvent e) {
      nativeKeyEvent(e, KeyEvent.PRESS);
    }
    @Override
    public void keyReleased(com.jogamp.newt.event.KeyEvent e) {
      nativeKeyEvent(e, KeyEvent.RELEASE);
    }
    public void keyTyped(com.jogamp.newt.event.KeyEvent e)  {
      nativeKeyEvent(e, KeyEvent.TYPE);
    }
  }

  protected void nativeMouseEvent(com.jogamp.newt.event.MouseEvent nativeEvent,
                                  int peAction) {
    int modifiers = nativeEvent.getModifiers();
    int peModifiers = modifiers &
                      (InputEvent.SHIFT_MASK |
                       InputEvent.CTRL_MASK |
                       InputEvent.META_MASK |
                       InputEvent.ALT_MASK);

    int peButton = 0;
    if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
      peButton = PConstants.LEFT;
    } else if ((modifiers & InputEvent.BUTTON2_MASK) != 0) {
      peButton = PConstants.CENTER;
    } else if ((modifiers & InputEvent.BUTTON3_MASK) != 0) {
      peButton = PConstants.RIGHT;
    }

    if (PApplet.platform == PConstants.MACOSX) {

      if ((modifiers & InputEvent.CTRL_MASK) != 0) {
        peButton = PConstants.RIGHT;
      }
    }

    int peCount = 0;
    if (peAction == MouseEvent.WHEEL) {
      peCount = nativeEvent.isShiftDown() ? (int)nativeEvent.getRotation()[0] :
                                            (int)nativeEvent.getRotation()[1];
    } else {
      peCount = nativeEvent.getClickCount();
    }

    window.getCurrentSurfaceScale(currentPixelScale);
    int sx = (int)(nativeEvent.getX()/currentPixelScale[0]);
    int sy = (int)(nativeEvent.getY()/currentPixelScale[1]);
    int mx = sx - (int)offsetX;
    int my = sy - (int)offsetY;

    if (presentMode) {
      if (peAction == KeyEvent.RELEASE &&
          20 < sx && sx < 20 + 100 &&
          screenRect.height - 70 < sy && sy < screenRect.height - 20) {






        sketch.exit();

      }

      if (mx < 0 || sketchWidth < mx || my < 0 || sketchHeight < my) {
        return;
      }
    }






    MouseEvent me = new MouseEvent(nativeEvent, nativeEvent.getWhen(),
                                   peAction, peModifiers,
                                   mx, my,
                                   peButton,
                                   peCount);

    sketch.postEvent(me);
  }

  protected void nativeKeyEvent(com.jogamp.newt.event.KeyEvent nativeEvent,
                                int peAction) {
    int peModifiers = nativeEvent.getModifiers() &
                      (InputEvent.SHIFT_MASK |
                       InputEvent.CTRL_MASK |
                       InputEvent.META_MASK |
                       InputEvent.ALT_MASK);

    short code = nativeEvent.getKeyCode();
    char keyChar;
    int keyCode;
    if (isPCodedKey(code)) {
      keyCode = mapToPConst(code);
      keyChar = PConstants.CODED;
    } else if (isHackyKey(code)) {
      keyCode = code;
      keyChar = hackToChar(code, nativeEvent.getKeyChar());
    } else {
      keyCode = code;
      keyChar = nativeEvent.getKeyChar();
    }








    KeyEvent ke = new KeyEvent(nativeEvent, nativeEvent.getWhen(),
                               peAction, peModifiers,
                               keyChar,
                               keyCode);

    sketch.postEvent(ke);
  }

  private static boolean isPCodedKey(short code) {
    return code == com.jogamp.newt.event.KeyEvent.VK_UP ||
           code == com.jogamp.newt.event.KeyEvent.VK_DOWN ||
           code == com.jogamp.newt.event.KeyEvent.VK_LEFT ||
           code == com.jogamp.newt.event.KeyEvent.VK_RIGHT ||
           code == com.jogamp.newt.event.KeyEvent.VK_ALT ||
           code == com.jogamp.newt.event.KeyEvent.VK_CONTROL ||
           code == com.jogamp.newt.event.KeyEvent.VK_SHIFT ||
           code == com.jogamp.newt.event.KeyEvent.VK_WINDOWS;
  }





  private static int mapToPConst(short code) {
    if (code == com.jogamp.newt.event.KeyEvent.VK_UP) {
      return PConstants.UP;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_DOWN) {
      return PConstants.DOWN;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_LEFT) {
      return PConstants.LEFT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_RIGHT) {
      return PConstants.RIGHT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_ALT) {
      return PConstants.ALT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_CONTROL) {
      return PConstants.CONTROL;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_SHIFT) {
      return PConstants.SHIFT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_WINDOWS) {
      return java.awt.event.KeyEvent.VK_META;
    }
    return code;
  }

  private static boolean isHackyKey(short code) {
    return code == com.jogamp.newt.event.KeyEvent.VK_BACK_SPACE ||
           code == com.jogamp.newt.event.KeyEvent.VK_TAB;
  }

  private static char hackToChar(short code, char def) {
    if (code == com.jogamp.newt.event.KeyEvent.VK_BACK_SPACE) {
      return '\b';
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_TAB) {
      return '\t';
    }
    return def;
  }




  public void setCursor(int kind) {
    System.err.println("Cursor types not supported in OpenGL, provide your cursor image");
  }


  public void setCursor(PImage image, int hotspotX, int hotspotY) {
    final Display disp = window.getScreen().getDisplay();
    disp.createNative();














  }

  public void showCursor() {
    window.setPointerVisible(true);
  }

  public void hideCursor() {
    window.setPointerVisible(false);
  }
}

<code block>
package processing.opengl;

import java.awt.Component;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;

import java.awt.Point;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;

import com.jogamp.common.util.IOUtil.ClassResources;
import com.jogamp.nativewindow.NativeSurface;
import com.jogamp.nativewindow.ScalableSurface;
import com.jogamp.opengl.GLAnimatorControl;
import com.jogamp.opengl.GLAutoDrawable;
import com.jogamp.opengl.GLCapabilities;
import com.jogamp.opengl.GLEventListener;
import com.jogamp.opengl.GLException;
import com.jogamp.opengl.GLProfile;
import com.jogamp.nativewindow.MutableGraphicsConfiguration;
import com.jogamp.newt.Display;
import com.jogamp.newt.MonitorDevice;
import com.jogamp.newt.NewtFactory;
import com.jogamp.newt.Screen;
import com.jogamp.newt.awt.NewtCanvasAWT;
import com.jogamp.newt.event.InputEvent;


import com.jogamp.newt.opengl.GLWindow;
import com.jogamp.opengl.util.FPSAnimator;

import processing.core.PApplet;
import processing.core.PConstants;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PSurface;
import processing.event.KeyEvent;
import processing.event.MouseEvent;
import processing.opengl.PGraphicsOpenGL;
import processing.opengl.PGL;

public class PSurfaceJOGL implements PSurface {

  public static GLProfile profile;

  PJOGL pgl;

  GLWindow window;
  FPSAnimator animator;
  Rectangle screenRect;

  PApplet sketch;
  PGraphics graphics;

  int sketchX;
  int sketchY;
  int sketchWidth;
  int sketchHeight;

  Display display;
  Screen screen;
  List<MonitorDevice> monitors;
  MonitorDevice displayDevice;
  Throwable drawException;
  Object waitObject = new Object();

  NewtCanvasAWT canvas;
  boolean placedWindow = false;
  boolean requestedStart = false;

  float[] currentPixelScale = {0, 0};

  boolean presentMode = false;
  float offsetX;
  float offsetY;


  public PSurfaceJOGL(PGraphics graphics) {
    this.graphics = graphics;
    this.pgl = (PJOGL) ((PGraphicsOpenGL)graphics).pgl;
  }


  public void initOffscreen(PApplet sketch) {
    this.sketch = sketch;

    sketchWidth = sketch.sketchWidth();
    sketchHeight = sketch.sketchHeight();

    if (window != null) {
      canvas = new NewtCanvasAWT(window);
      canvas.setBounds(0, 0, window.getWidth(), window.getHeight());

      canvas.setFocusable(true);
    }
  }


  public void initFrame(PApplet sketch) {
    this.sketch = sketch;
    initIcons();
    initScreen();
    initGL();
    initWindow();
    initListeners();
    initAnimator();
  }


  protected void initScreen() {
    display = NewtFactory.createDisplay(null);
    display.addReference();
    screen = NewtFactory.createScreen(display, 0);
    screen.addReference();

    monitors = new ArrayList<MonitorDevice>();
    GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice[] devices = environment.getScreenDevices();
    for (GraphicsDevice device: devices) {
      String did = device.getIDstring();
      String[] parts = did.split("Display");
      String id1 = "";
      if (1 < parts.length) {
        id1 = parts[1].trim();
      }
      MonitorDevice monitor = null;
      for (int i = 0; i < screen.getMonitorDevices().size(); i++) {
        MonitorDevice mon = screen.getMonitorDevices().get(i);
        String mid = String.valueOf(mon.getId());
        if (id1.equals(mid)) {




          monitor = mon;
          break;
        }
      }
      if (monitor == null) {

        for (int i = 0; i < screen.getMonitorDevices().size(); i++) {
          MonitorDevice mon = screen.getMonitorDevices().get(i);
          String mid = String.valueOf(mon.getId());
          if (-1 < did.indexOf(mid)) {
            monitor = mon;
            break;
          }
        }
      }
      if (monitor != null) {
        monitors.add(monitor);
      }
    }
  }

  protected void initGL() {

    if (profile == null) {
      if (PJOGL.PROFILE == 2) {
        try {
          profile = GLProfile.getGL2ES1();
        } catch (GLException ex) {
          profile = GLProfile.getMaxFixedFunc(true);
        }
      } else if (PJOGL.PROFILE == 3) {
        try {
          profile = GLProfile.getGL2GL3();
        } catch (GLException ex) {
          profile = GLProfile.getMaxProgrammable(true);
        }
        if (!profile.isGL3()) {
          PGraphics.showWarning("Requested profile GL3 but is not available, got: " + profile);
        }
      } else if (PJOGL.PROFILE == 4) {
        try {
          profile = GLProfile.getGL4ES3();
        } catch (GLException ex) {
          profile = GLProfile.getMaxProgrammable(true);
        }
        if (!profile.isGL4()) {
          PGraphics.showWarning("Requested profile GL4 but is not available, got: " + profile);
        }
      } else throw new RuntimeException(PGL.UNSUPPORTED_GLPROF_ERROR);
    }


    GLCapabilities caps = new GLCapabilities(profile);
    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);
    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);
    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);




    pgl.reqNumSamples = PGL.smoothToSamples(graphics.smooth);
    caps.setSampleBuffers(true);
    caps.setNumSamples(pgl.reqNumSamples);
    caps.setBackgroundOpaque(true);
    caps.setOnscreen(true);
    pgl.capabilities = caps;
  }


  protected void initWindow() {
    window = GLWindow.create(screen, pgl.capabilities);
    if (displayDevice == null) {
      displayDevice = window.getMainMonitor();
    }

    int displayNum = sketch.sketchDisplay();
    if (displayNum > 0) {  
      if (displayNum <= monitors.size()) {
        displayDevice = monitors.get(displayNum - 1);
      } else {
        System.err.format("Display %d does not exist, " +
          "using the default display instead.%n", displayNum);
        for (int i = 0; i < monitors.size(); i++) {
          System.err.format("Display %d is %s%n", i+1, monitors.get(i));
        }
      }
    }

    boolean spanDisplays = sketch.sketchDisplay() == PConstants.SPAN;
    screenRect = spanDisplays ?
      new Rectangle(0, 0, screen.getWidth(), screen.getHeight()) :
      new Rectangle(0, 0,
                    displayDevice.getViewportInWindowUnits().getWidth(),
                    displayDevice.getViewportInWindowUnits().getHeight());



    sketch.displayWidth = screenRect.width;
    sketch.displayHeight = screenRect.height;

    sketchWidth = sketch.sketchWidth();
    sketchHeight = sketch.sketchHeight();

    boolean fullScreen = sketch.sketchFullScreen();


    if (screenRect.width == sketchWidth &&
        screenRect.height == sketchHeight) {
      fullScreen = true;
      sketch.fullScreen();
    }

    if (fullScreen || spanDisplays) {
      sketchWidth = screenRect.width;
      sketchHeight = screenRect.height;
    }

    float[] reqSurfacePixelScale;
    if (graphics.is2X()) {

       reqSurfacePixelScale = new float[] { ScalableSurface.AUTOMAX_PIXELSCALE,
                                            ScalableSurface.AUTOMAX_PIXELSCALE };
    } else {

      reqSurfacePixelScale = new float[] { ScalableSurface.IDENTITY_PIXELSCALE,
                                           ScalableSurface.IDENTITY_PIXELSCALE };
    }
    window.setSurfaceScale(reqSurfacePixelScale);
    window.setSize(sketchWidth, sketchHeight);
    setSize(sketchWidth, sketchHeight);
    sketchX = displayDevice.getViewportInWindowUnits().getX();
    sketchY = displayDevice.getViewportInWindowUnits().getY();
    if (fullScreen) {
      PApplet.hideMenuBar();
      window.setTopLevelPosition(sketchX, sketchY);
      placedWindow = true;
      if (spanDisplays) {
        window.setFullscreen(monitors);
      } else {
        window.setFullscreen(true);
      }
    }
  }


  protected void initListeners() {
    NEWTMouseListener mouseListener = new NEWTMouseListener();
    window.addMouseListener(mouseListener);
    NEWTKeyListener keyListener = new NEWTKeyListener();
    window.addKeyListener(keyListener);
    NEWTWindowListener winListener = new NEWTWindowListener();
    window.addWindowListener(winListener);

    DrawListener drawlistener = new DrawListener();
    window.addGLEventListener(drawlistener);
  }


  protected void initAnimator() {

    animator = new FPSAnimator(window, 60);
    drawException = null;
    animator.setUncaughtExceptionHandler(new GLAnimatorControl.UncaughtExceptionHandler() {
      @Override
      public void uncaughtException(final GLAnimatorControl animator,
                                    final GLAutoDrawable drawable,
                                    final Throwable cause) {
        synchronized (waitObject) {

          drawException = cause;
          waitObject.notify();
        }
      }
    });

    new Thread(new Runnable() {
      public void run() {
        synchronized (waitObject) {
          try {
            if (drawException == null) waitObject.wait();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }

          if (drawException != null) {
            Throwable cause = drawException.getCause();
            if (cause instanceof ThreadDeath) {


            } else if (cause instanceof RuntimeException) {
              throw (RuntimeException)cause;
            } else {
              throw new RuntimeException(cause);
            }
          }
        }
      }
    }).start();
  }

  @Override
  public void setTitle(String title) {
    window.setTitle(title);
  }

  @Override
  public void setVisible(boolean visible) {
    window.setVisible(visible);
  }

  @Override
  public void setResizable(boolean resizable) {


  }





  @Override
  public void placeWindow(int[] location, int[] editorLocation) {




    int x = window.getX() - window.getInsets().getLeftWidth();
    int y = window.getY() - window.getInsets().getTopHeight();
    int w = window.getWidth() + window.getInsets().getTotalWidth();
    int h = window.getHeight() + window.getInsets().getTotalHeight();

    if (location != null) {

      window.setTopLevelPosition(location[0], location[1]);

    } else if (editorLocation != null) {

      int locationX = editorLocation[0] - 20;
      int locationY = editorLocation[1];

      if (locationX - w > 10) {

        window.setTopLevelPosition(locationX - w, locationY);

      } else {  



        locationX = editorLocation[0] + 66;
        locationY = editorLocation[1] + 66;

        if ((locationX + w > sketch.displayWidth - 33) ||
            (locationY + h > sketch.displayHeight - 33)) {

          locationX = (sketch.displayWidth - w) / 2;
          locationY = (sketch.displayHeight - h) / 2;
        }
        window.setTopLevelPosition(locationX, locationY);
      }
    } else {  


      int sketchX = displayDevice.getViewportInWindowUnits().getX();
      int sketchY = displayDevice.getViewportInWindowUnits().getY();















      window.setTopLevelPosition(sketchX + screenRect.x + (screenRect.width - sketchWidth) / 2,
                                 sketchY + screenRect.y + (screenRect.height - sketchHeight) / 2);

    }

    Point frameLoc = new Point(x, y);
    if (frameLoc.y < 0) {


      window.setTopLevelPosition(frameLoc.x, 30);
    }

    placedWindow = true;
    if (requestedStart) startThread();



  }


  public void placePresent(int stopColor) {




    presentMode = pgl.presentMode = true;
    offsetX = pgl.offsetX = 0.5f * (screenRect.width - sketchWidth);
    offsetY = pgl.offsetY = 0.5f * (screenRect.height - sketchHeight);
    pgl.requestFBOLayer();

    window.setSize(screenRect.width, screenRect.height);
    PApplet.hideMenuBar();
    window.setTopLevelPosition(sketchX + screenRect.x,
                               sketchY + screenRect.y);

    window.setFullscreen(true);


    placedWindow = true;
    if (requestedStart) startThread();


  }


  protected void initIcons() {
    final int[] sizes = { 16, 32, 48, 64, 128, 256, 512 };
    String[] iconImages = new String[sizes.length];
    for (int i = 0; i < sizes.length; i++) {
      iconImages[i] = "/icon/icon-" + sizes[i] + ".png";
    }
    NewtFactory.setWindowIcons(new ClassResources(PApplet.class, iconImages));
  }


  public void setupExternalMessages() {


  }


  public void startThread() {
    if (animator == null) return;
    if (placedWindow) {
      window.setVisible(true);
      animator.start();
      requestedStart = false;
    } else {


      requestedStart = true;





      sketch.defaultSize = false;
    }
  }

  public void pauseThread() {
    if (animator != null) {
      animator.pause();
    }
  }

  public void resumeThread() {
    if (animator != null) {
      animator.resume();
    }
  }

  public boolean stopThread() {
    if (animator != null) {
      return animator.stop();
    } else {
      return false;
    }
  }

  public boolean isStopped() {
    if (animator != null) {
      return !animator.isAnimating();
    } else {
      return true;
    }
  }

  public void setSize(int width, int height) {
    if (width == sketch.width && height == sketch.height) {
      return;
    }





      if (!presentMode) {


        sketch.setSize(width, height);
        sketchWidth = width;
        sketchHeight = height;
        graphics.setSize(width, height);
      }



  }

  public float getPixelScale() {
    if (graphics.is2X()) {


      window.getCurrentSurfaceScale(currentPixelScale);
      return currentPixelScale[0];
    } else {
      return 1;
    }
  }

  public Component getComponent() {
    return canvas;
  }

  public void setSmooth(int level) {
    pgl.reqNumSamples = level;
    GLCapabilities caps = new GLCapabilities(profile);
    caps.setAlphaBits(PGL.REQUESTED_ALPHA_BITS);
    caps.setDepthBits(PGL.REQUESTED_DEPTH_BITS);
    caps.setStencilBits(PGL.REQUESTED_STENCIL_BITS);
    caps.setSampleBuffers(true);
    caps.setNumSamples(pgl.reqNumSamples);
    caps.setBackgroundOpaque(true);
    caps.setOnscreen(true);
    NativeSurface target = window.getNativeSurface();
    MutableGraphicsConfiguration config = (MutableGraphicsConfiguration) target.getGraphicsConfiguration();
    config.setChosenCapabilities(caps);
  }

  public void setFrameRate(float fps) {
    if (animator != null) {
      animator.stop();
      animator.setFPS((int)fps);
      pgl.setFps(fps);
      animator.start();
    }
  }

  public void requestFocus() {
    window.requestFocus();
  }

  class DrawListener implements GLEventListener {
    public void display(GLAutoDrawable drawable) {
      pgl.getGL(drawable);

      sketch.handleDraw();

      if (sketch.frameCount == 1) {
        requestFocus();
      }

      if (sketch.exitCalled()) {

        animator.stop();
        sketch.dispose();
        sketch.exitActual();
      }
    }
    public void dispose(GLAutoDrawable drawable) {


      sketch.dispose();



    }
    public void init(GLAutoDrawable drawable) {

      pgl.getGL(drawable);
      pgl.init(drawable);
      sketch.start();


      int c = graphics.backgroundColor;
      pgl.clearColor(((c >> 16) & 0xff) / 255f,
                     ((c >>  8) & 0xff) / 255f,
                     ((c >>  0) & 0xff) / 255f,
                     ((c >> 24) & 0xff) / 255f);
      pgl.clear(PGL.COLOR_BUFFER_BIT);
    }

    public void reshape(GLAutoDrawable drawable, int x, int y, int w, int h) {


      window.getCurrentSurfaceScale(currentPixelScale);










      pgl.getGL(drawable);





      setSize((int)(w/currentPixelScale[0]), (int)(h/currentPixelScale[1]));
    }
  }

  protected class NEWTWindowListener implements com.jogamp.newt.event.WindowListener {
    public NEWTWindowListener() {
      super();
    }
    @Override
    public void windowGainedFocus(com.jogamp.newt.event.WindowEvent arg0) {


    }

    @Override
    public void windowLostFocus(com.jogamp.newt.event.WindowEvent arg0) {


    }

    @Override
    public void windowDestroyNotify(com.jogamp.newt.event.WindowEvent arg0) {

      PSurfaceJOGL.this.sketch.dispose();
      PSurfaceJOGL.this.sketch.exitActual();
    }

    @Override
    public void windowDestroyed(com.jogamp.newt.event.WindowEvent arg0) {
    }

    @Override
    public void windowMoved(com.jogamp.newt.event.WindowEvent arg0) {
    }

    @Override
    public void windowRepaint(com.jogamp.newt.event.WindowUpdateEvent arg0) {
    }

    @Override
    public void windowResized(com.jogamp.newt.event.WindowEvent arg0) {





    }

  }


  protected class NEWTMouseListener extends com.jogamp.newt.event.MouseAdapter {
    public NEWTMouseListener() {
      super();
    }
    @Override
    public void mousePressed(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.PRESS);
    }
    @Override
    public void mouseReleased(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.RELEASE);
    }
    @Override
    public void mouseClicked(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.CLICK);
    }
    @Override
    public void mouseDragged(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.DRAG);
    }
    @Override
    public void mouseMoved(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.MOVE);
    }
    @Override
    public void mouseWheelMoved(com.jogamp.newt.event.MouseEvent e) {
      nativeMouseEvent(e, MouseEvent.WHEEL);
    }
    @Override
    public void mouseEntered(com.jogamp.newt.event.MouseEvent e) {

      nativeMouseEvent(e, MouseEvent.ENTER);
    }
    @Override
    public void mouseExited(com.jogamp.newt.event.MouseEvent e) {

      nativeMouseEvent(e, MouseEvent.EXIT);
    }
  }


  protected class NEWTKeyListener extends com.jogamp.newt.event.KeyAdapter {
    public NEWTKeyListener() {
      super();
    }
    @Override
    public void keyPressed(com.jogamp.newt.event.KeyEvent e) {
      nativeKeyEvent(e, KeyEvent.PRESS);
    }
    @Override
    public void keyReleased(com.jogamp.newt.event.KeyEvent e) {
      nativeKeyEvent(e, KeyEvent.RELEASE);
    }
    public void keyTyped(com.jogamp.newt.event.KeyEvent e)  {
      nativeKeyEvent(e, KeyEvent.TYPE);
    }
  }

  protected void nativeMouseEvent(com.jogamp.newt.event.MouseEvent nativeEvent,
                                  int peAction) {
    int modifiers = nativeEvent.getModifiers();
    int peModifiers = modifiers &
                      (InputEvent.SHIFT_MASK |
                       InputEvent.CTRL_MASK |
                       InputEvent.META_MASK |
                       InputEvent.ALT_MASK);

    int peButton = 0;
    if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
      peButton = PConstants.LEFT;
    } else if ((modifiers & InputEvent.BUTTON2_MASK) != 0) {
      peButton = PConstants.CENTER;
    } else if ((modifiers & InputEvent.BUTTON3_MASK) != 0) {
      peButton = PConstants.RIGHT;
    }

    if (PApplet.platform == PConstants.MACOSX) {

      if ((modifiers & InputEvent.CTRL_MASK) != 0) {
        peButton = PConstants.RIGHT;
      }
    }

    int peCount = 0;
    if (peAction == MouseEvent.WHEEL) {
      peCount = nativeEvent.isShiftDown() ? (int)nativeEvent.getRotation()[0] :
                                            (int)nativeEvent.getRotation()[1];
    } else {
      peCount = nativeEvent.getClickCount();
    }

    window.getCurrentSurfaceScale(currentPixelScale);
    int sx = (int)(nativeEvent.getX()/currentPixelScale[0]);
    int sy = (int)(nativeEvent.getY()/currentPixelScale[1]);
    int mx = sx - (int)offsetX;
    int my = sy - (int)offsetY;

    if (presentMode) {
      if (peAction == KeyEvent.RELEASE &&
          20 < sx && sx < 20 + 100 &&
          screenRect.height - 70 < sy && sy < screenRect.height - 20) {






        sketch.exit();

      }

      if (mx < 0 || sketchWidth < mx || my < 0 || sketchHeight < my) {
        return;
      }
    }






    MouseEvent me = new MouseEvent(nativeEvent, nativeEvent.getWhen(),
                                   peAction, peModifiers,
                                   mx, my,
                                   peButton,
                                   peCount);

    sketch.postEvent(me);
  }

  protected void nativeKeyEvent(com.jogamp.newt.event.KeyEvent nativeEvent,
                                int peAction) {
    int peModifiers = nativeEvent.getModifiers() &
                      (InputEvent.SHIFT_MASK |
                       InputEvent.CTRL_MASK |
                       InputEvent.META_MASK |
                       InputEvent.ALT_MASK);

    short code = nativeEvent.getKeyCode();
    char keyChar;
    int keyCode;
    if (isPCodedKey(code)) {
      keyCode = mapToPConst(code);
      keyChar = PConstants.CODED;
    } else if (isHackyKey(code)) {
      keyCode = code;
      keyChar = hackToChar(code, nativeEvent.getKeyChar());
    } else {
      keyCode = code;
      keyChar = nativeEvent.getKeyChar();
    }








    KeyEvent ke = new KeyEvent(nativeEvent, nativeEvent.getWhen(),
                               peAction, peModifiers,
                               keyChar,
                               keyCode);

    sketch.postEvent(ke);
  }

  private static boolean isPCodedKey(short code) {
    return code == com.jogamp.newt.event.KeyEvent.VK_UP ||
           code == com.jogamp.newt.event.KeyEvent.VK_DOWN ||
           code == com.jogamp.newt.event.KeyEvent.VK_LEFT ||
           code == com.jogamp.newt.event.KeyEvent.VK_RIGHT ||
           code == com.jogamp.newt.event.KeyEvent.VK_ALT ||
           code == com.jogamp.newt.event.KeyEvent.VK_CONTROL ||
           code == com.jogamp.newt.event.KeyEvent.VK_SHIFT ||
           code == com.jogamp.newt.event.KeyEvent.VK_WINDOWS;
  }





  private static int mapToPConst(short code) {
    if (code == com.jogamp.newt.event.KeyEvent.VK_UP) {
      return PConstants.UP;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_DOWN) {
      return PConstants.DOWN;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_LEFT) {
      return PConstants.LEFT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_RIGHT) {
      return PConstants.RIGHT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_ALT) {
      return PConstants.ALT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_CONTROL) {
      return PConstants.CONTROL;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_SHIFT) {
      return PConstants.SHIFT;
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_WINDOWS) {
      return java.awt.event.KeyEvent.VK_META;
    }
    return code;
  }

  private static boolean isHackyKey(short code) {
    return code == com.jogamp.newt.event.KeyEvent.VK_BACK_SPACE ||
           code == com.jogamp.newt.event.KeyEvent.VK_TAB;
  }

  private static char hackToChar(short code, char def) {
    if (code == com.jogamp.newt.event.KeyEvent.VK_BACK_SPACE) {
      return '\b';
    } else if (code == com.jogamp.newt.event.KeyEvent.VK_TAB) {
      return '\t';
    }
    return def;
  }




  public void setCursor(int kind) {
    System.err.println("Cursor types not supported in OpenGL, provide your cursor image");
  }


  public void setCursor(PImage image, int hotspotX, int hotspotY) {
    final Display disp = window.getScreen().getDisplay();
    disp.createNative();














  }

  public void showCursor() {
    window.setPointerVisible(true);
  }

  public void hideCursor() {
    window.setPointerVisible(false);
  }
}

<code block>




package processing.core;



import java.awt.Desktop;
import java.awt.DisplayMode;
import java.awt.EventQueue;
import java.awt.FileDialog;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;







import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import javax.swing.filechooser.FileSystemView;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;

import java.io.*;
import java.lang.reflect.*;
import java.net.*;
import java.text.*;
import java.util.*;
import java.util.regex.*;
import java.util.zip.*;

import processing.data.*;
import processing.event.*;
import processing.opengl.*;



public class PApplet implements PConstants {

  static public final String javaVersionName =
    System.getProperty("java.version");








  static public final int javaPlatform =
    PApplet.parseInt(PApplet.split(javaVersionName, '.')[1]);









  @Deprecated
  public static final float javaVersion =
    new Float(javaVersionName.substring(0, 3));






  static public int platform;

  static {
    String osname = System.getProperty("os.name");

    if (osname.indexOf("Mac") != -1) {
      platform = MACOSX;

    } else if (osname.indexOf("Windows") != -1) {
      platform = WINDOWS;

    } else if (osname.equals("Linux")) {  
      platform = LINUX;

    } else {
      platform = OTHER;
    }
  }


  static public boolean useNativeSelect = (platform != LINUX);


  public PGraphics g;


  public int displayWidth;


  public int displayHeight;


  public PGraphics recorder;


  public String[] args;


  private String sketchPath;


  static final boolean DEBUG = false;



  static public final int DEFAULT_WIDTH = 100;
  static public final int DEFAULT_HEIGHT = 100;











  public boolean defaultSize;





  public int[] pixels;


  public int width = DEFAULT_WIDTH;


  public int height = DEFAULT_HEIGHT;


  public int pixelWidth;


  public int pixelHeight;


  public int mouseX;


  public int mouseY;


  public int pmouseX;


  public int pmouseY;


  protected int dmouseX, dmouseY;


  protected int emouseX, emouseY;


  @Deprecated
  public boolean firstMouse;


  public int mouseButton;


  public boolean mousePressed;



  @Deprecated
  public MouseEvent mouseEvent;


  public char key;


  public int keyCode;


  public boolean keyPressed;


  @Deprecated
  public KeyEvent keyEvent;


  public boolean focused = false;













  long millisOffset = System.currentTimeMillis();


  public float frameRate = 10;

  protected boolean looping;


  protected boolean redraw;


  public int frameCount;


  public volatile boolean finished;








  protected boolean exitCalled;




  static public final String ARGS_EDITOR_LOCATION = "--editor-location";

  static public final String ARGS_EXTERNAL = "--external";


  static public final String ARGS_LOCATION = "--location";


  static public final String ARGS_DISPLAY = "--display";



  static public final String ARGS_WINDOW_COLOR = "--window-color";

  static public final String ARGS_PRESENT = "--present";

  static public final String ARGS_STOP_COLOR = "--stop-color";

  static public final String ARGS_HIDE_STOP = "--hide-stop";


  static public final String ARGS_SKETCH_FOLDER = "--sketch-path";


  static public final String EXTERNAL_STOP = "__STOP__";


  static public final String EXTERNAL_MOVE = "__MOVE__";


  boolean external = false;

  static final String ERROR_MIN_MAX =
    "Cannot use min() or max() on an empty array.";





  protected PSurface surface;



  public Frame frame;
















  public void init() {






    defaultSize = true;
    finished = false; 


    looping = true;
    redraw = true;  
    firstMouse = true;





























    surface.startThread();
  }





  boolean insideSettings;

  String renderer = JAVA2D;

  int smooth = 1;  

  boolean fullScreen;
  int display = -1;  
  GraphicsDevice[] displayDevices;


  public int pixelDensity = 1;

  String outputPath;
  OutputStream outputStream;




  int windowColor = 0xffDDDDDD;



  boolean insideSettings(String method, Object... args) {
    if (insideSettings) {
      return true;
    }
    final String url = "https://processing.org/reference/" + method + "_.html";
    if (!external) {  
      StringList argList = new StringList(args);
      System.err.println("When not using the PDE, " + method + "() can only be used inside settings().");
      System.err.println("Remove the " + method + "() method from setup(), and add the following:");
      System.err.println("public void settings() {");
      System.err.println("  " + method + "(" + argList.join(", ") + ");");
      System.err.println("}");
    }
    throw new IllegalStateException(method + "() cannot be used here, see " + url);
  }


  void handleSettings() {
    insideSettings = true;







    GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice device = ge.getDefaultScreenDevice();
    displayDevices = ge.getScreenDevices();



    if (display > 0 && display <= displayDevices.length) {
      device = displayDevices[display-1];
    }

    DisplayMode displayMode = device.getDisplayMode();
    displayWidth = displayMode.getWidth();
    displayHeight = displayMode.getHeight();



    settings();

    if (display == SPAN && platform == MACOSX) {


      Process p = exec("defaults", "read", "com.apple.spaces", "spans-displays");
      BufferedReader outReader = createReader(p.getInputStream());
      BufferedReader errReader = createReader(p.getErrorStream());
      StringBuilder stdout = new StringBuilder();
      StringBuilder stderr = new StringBuilder();
      String line = null;
      try {
        while ((line = outReader.readLine()) != null) {
          stdout.append(line);
        }
        while ((line = errReader.readLine()) != null) {
          stderr.append(line);
        }
      } catch (IOException e) {
        e.printStackTrace();
      }

      int resultCode = -1;
      try {
        resultCode = p.waitFor();
      } catch (InterruptedException e) { }

      String result = trim(stdout.toString());
      if ("0".equals(result)) {
        EventQueue.invokeLater(new Runnable() {
          public void run() {
            final String msg =
              "To use fullScreen(SPAN), first turn off âDisplays have separate spacesâ?\n" +
              "in System Preferences \u2192 Mission Control. Then log out and log back in.";
            JOptionPane.showMessageDialog(null, msg, "Apple's Defaults Stink",
                                          JOptionPane.WARNING_MESSAGE);
          }
        });
      } else if (!result.equals("1")) {
        System.err.println("Could not check the status of âDisplays have separate spaces.â?");
        System.err.format("Received message '%s' and result code %d.%n", trim(stderr.toString()), resultCode);
      }
    }

    insideSettings = false;
  }



  public void settings() {


  }


  final public int sketchWidth() {
    return width;
  }


  final public int sketchHeight() {
    return height;
  }


  final public String sketchRenderer() {
    return renderer;
  }














  final public int sketchSmooth() {
    return smooth;
  }


  final public boolean sketchFullScreen() {

    return fullScreen;
  }












  final public int sketchDisplay() {
    return display;
  }


  final public String sketchOutputPath() {

    return outputPath;
  }


  final public OutputStream sketchOutputStream() {

    return outputStream;
  }


  final public int sketchWindowColor() {
    return windowColor;
  }


  final public int sketchPixelDensity() {
    return pixelDensity;
  }





  public int displayDensity() {
    if (display == SPAN) {

      for (int i = 0; i < displayDevices.length; i++) {
        if (displayDensity(i) != 2) {
          return 1;
        }
      }
      return 2;
    }
    return displayDensity(display);
  }


  static public int displayDensity(int display) {
    if (PApplet.platform == PConstants.MACOSX) {



      final String javaVendor = System.getProperty("java.vendor");
      if (javaVendor.contains("Oracle")) {
        GraphicsDevice device;
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();

        if (display == -1) {
          device = env.getDefaultScreenDevice();

        } else if (display == SPAN) {
          throw new RuntimeException("displayDensity() only works with specific display numbers");

        } else {
          GraphicsDevice[] devices = env.getScreenDevices();
          if (display > 0 && display <= devices.length) {
            device = devices[display - 1];
          } else {
            if (devices.length == 1) {
              System.err.println("Only one display is currently known, use displayDensity(1).");
            } else {
              System.err.format("Your displays are numbered %d through %d, " +
                "pass one of those numbers to displayDensity()", 1, devices.length);
            }
            throw new RuntimeException("Display " + display + " does not exist.");
          }
        }

        try {
          Field field = device.getClass().getDeclaredField("scale");
          if (field != null) {
            field.setAccessible(true);
            Object scale = field.get(device);

            if (scale instanceof Integer && ((Integer)scale).intValue() == 2) {
              return 2;
            }
          }
        } catch (Exception ignore) { }
      }
    }
    return 1;
  }



  public void pixelDensity(int density) {
    if (density != this.pixelDensity) {
      if (insideSettings("pixelDensity", density)) {
        if (density != 1 && density != 2) {
          throw new RuntimeException("pixelDensity() can only be 1 or 2");
        }
        if (density == 2 && displayDensity() == 1) {

          throw new RuntimeException("pixelDensity(2) is not available for this display");
        } else {
          this.pixelDensity = density;
        }
      }
    }
  }



  public void setSize(int width, int height) {
    this.width = width;
    this.height = height;
    pixelWidth = width * pixelDensity;
    pixelHeight = height * pixelDensity;
  }






  public void smooth() {
    smooth(1);
  }


  public void smooth(int level) {
    if (insideSettings) {
      this.smooth = level;

    } else if (this.smooth != level) {
      smoothWarning("smooth");
    }
  }


  public void noSmooth() {
    if (insideSettings) {
      this.smooth = 0;

    } else if (this.smooth != 0) {
      smoothWarning("noSmooth");
    }
  }


  private void smoothWarning(String method) {

    final String where = external ? "setup" : "settings";
    PGraphics.showWarning("%s() can only be used inside %s()", method, where);
  }





  public PGraphics getGraphics() {
    return g;
  }



  public void orientation(int which) {

  }



  public void start() {


    resume();
    handleMethods("resume");
    surface.resumeThread();
  }



  public void stop() {














    pause();
    handleMethods("pause");


    surface.pauseThread();











  }



  public void pause() { }



  public void resume() { }























  HashMap<String, RegisteredMethods> registerMap =
    new HashMap<String, PApplet.RegisteredMethods>();


  class RegisteredMethods {
    int count;
    Object[] objects;


    Method[] methods;
    Object[] emptyArgs = new Object[] { };


    void handle() {
      handle(emptyArgs);
    }


    void handle(Object[] args) {
      for (int i = 0; i < count; i++) {
        try {
          methods[i].invoke(objects[i], args);
        } catch (Exception e) {

          Throwable t;
          if (e instanceof InvocationTargetException) {
            InvocationTargetException ite = (InvocationTargetException) e;
            t = ite.getCause();
          } else {
            t = e;
          }

          if (t instanceof RuntimeException) {

            throw (RuntimeException) t;
          } else {

            t.printStackTrace();
          }
        }
      }
    }


    void add(Object object, Method method) {
      if (findIndex(object) == -1) {
        if (objects == null) {
          objects = new Object[5];
          methods = new Method[5];

        } else if (count == objects.length) {
          objects = (Object[]) PApplet.expand(objects);
          methods = (Method[]) PApplet.expand(methods);
        }
        objects[count] = object;
        methods[count] = method;
        count++;
      } else {
        die(method.getName() + "() already added for this instance of " +
            object.getClass().getName());
      }
    }





    public void remove(Object object) {
      int index = findIndex(object);
      if (index != -1) {

        count--;
        for (int i = index; i < count; i++) {
          objects[i] = objects[i+1];
          methods[i] = methods[i+1];
        }

        objects[count] = null;
        methods[count] = null;
      }
    }



    protected int findIndex(Object object) {
      for (int i = 0; i < count; i++) {
        if (objects[i] == object) {





          return i;
        }
      }
      return -1;
    }
  }



  public void registerMethod(String methodName, Object target) {
    if (methodName.equals("mouseEvent")) {
      registerWithArgs("mouseEvent", target, new Class[] { processing.event.MouseEvent.class });

    } else if (methodName.equals("keyEvent")) {
      registerWithArgs("keyEvent", target, new Class[] { processing.event.KeyEvent.class });

    } else if (methodName.equals("touchEvent")) {
      registerWithArgs("touchEvent", target, new Class[] { processing.event.TouchEvent.class });

    } else {
      registerNoArgs(methodName, target);
    }
  }


  private void registerNoArgs(String name, Object o) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      meth = new RegisteredMethods();
      registerMap.put(name, meth);
    }
    Class<?> c = o.getClass();
    try {
      Method method = c.getMethod(name, new Class[] {});
      meth.add(o, method);

    } catch (NoSuchMethodException nsme) {
      die("There is no public " + name + "() method in the class " +
          o.getClass().getName());

    } catch (Exception e) {
      die("Could not register " + name + " + () for " + o, e);
    }
  }


  private void registerWithArgs(String name, Object o, Class<?> cargs[]) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      meth = new RegisteredMethods();
      registerMap.put(name, meth);
    }
    Class<?> c = o.getClass();
    try {
      Method method = c.getMethod(name, cargs);
      meth.add(o, method);

    } catch (NoSuchMethodException nsme) {
      die("There is no public " + name + "() method in the class " +
          o.getClass().getName());

    } catch (Exception e) {
      die("Could not register " + name + " + () for " + o, e);
    }
  }







  public void unregisterMethod(String name, Object target) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      die("No registered methods with the name " + name + "() were found.");
    }
    try {


      meth.remove(target);
    } catch (Exception e) {
      die("Could not unregister " + name + "() for " + target, e);
    }
  }


  protected void handleMethods(String methodName) {
    RegisteredMethods meth = registerMap.get(methodName);
    if (meth != null) {
      meth.handle();
    }
  }


  protected void handleMethods(String methodName, Object[] args) {
    RegisteredMethods meth = registerMap.get(methodName);
    if (meth != null) {
      meth.handle(args);
    }
  }









  public void setup() {
  }


  public void draw() {


    finished = true;
  }









  public void fullScreen() {
    if (!fullScreen) {
      if (insideSettings("fullScreen")) {
        this.fullScreen = true;
      }
    }
  }


  public void fullScreen(int display) {
    if (!fullScreen || display != this.display) {
      if (insideSettings("fullScreen", display)) {
        this.fullScreen = true;
        this.display = display;
      }
    }
  }



  public void fullScreen(String renderer) {
    if (!fullScreen ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("fullScreen", renderer)) {
        this.fullScreen = true;
        this.renderer = renderer;
      }
    }
  }



  public void fullScreen(String renderer, int display) {
    if (!fullScreen ||
        !renderer.equals(this.renderer) ||
        display != this.display) {
      if (insideSettings("fullScreen", renderer, display)) {
        this.fullScreen = true;
        this.renderer = renderer;
        this.display = display;
      }
    }
  }



  public void size(int width, int height) {




    if (width != this.width ||
        height != this.height) {
      if (insideSettings("size", width, height)) {
        this.width = width;
        this.height = height;
      }
    }
  }


  public void size(int width, int height, String renderer) {
    if (width != this.width ||
        height != this.height ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("size", width, height, renderer)) {
        this.width = width;
        this.height = height;
        this.renderer = renderer;
      }
    }
  }



  public void size(int width, int height, String renderer, String path) {



    if (width != this.width ||
        height != this.height ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("size", width, height, renderer, path)) {
        this.width = width;
        this.height = height;
        this.renderer = renderer;
        this.outputPath = path;
      }
    }

















































  }


  public PGraphics createGraphics(int w, int h) {
    return createGraphics(w, h, JAVA2D);
  }



  public PGraphics createGraphics(int w, int h, String renderer) {
    return createGraphics(w, h, renderer, null);
  }



  public PGraphics createGraphics(int w, int h,
                                  String renderer, String path) {
    return makeGraphics(w, h, renderer, path, false);

  }








  protected PGraphics makeGraphics(int w, int h,
                                   String renderer, String path,
                                   boolean primary) {








    if (!primary && !g.isGL()) {
      if (renderer.equals(P2D)) {
        throw new RuntimeException("createGraphics() with P2D requires size() to use P2D or P3D");
      } else if (renderer.equals(P3D)) {
        throw new RuntimeException("createGraphics() with P3D or OPENGL requires size() to use P2D or P3D");
      }
    }

    try {
      Class<?> rendererClass =
        Thread.currentThread().getContextClassLoader().loadClass(renderer);

      Constructor<?> constructor = rendererClass.getConstructor(new Class[] { });
      PGraphics pg = (PGraphics) constructor.newInstance();

      pg.setParent(this);
      pg.setPrimary(primary);
      if (path != null) {
        pg.setPath(savePath(path));
      }




      pg.setSize(w, h);


      return pg;

    } catch (InvocationTargetException ite) {
      String msg = ite.getTargetException().getMessage();
      if ((msg != null) &&
          (msg.indexOf("no jogl in java.library.path") != -1)) {

        throw new RuntimeException("The jogl library folder needs to be " +
          "specified with -Djava.library.path=/path/to/jogl");

      } else {
        ite.getTargetException().printStackTrace();
        Throwable target = ite.getTargetException();
        if (platform == MACOSX) {
          target.printStackTrace(System.out);  
        }
        throw new RuntimeException(target.getMessage());
      }

    } catch (ClassNotFoundException cnfe) {




      if (external) {
        throw new RuntimeException("You need to use \"Import Library\" " +
                                   "to add " + renderer + " to your sketch.");
      } else {
        throw new RuntimeException("The " + renderer +
                                   " renderer is not in the class path.");
      }

    } catch (Exception e) {
      if ((e instanceof IllegalArgumentException) ||
          (e instanceof NoSuchMethodException) ||
          (e instanceof IllegalAccessException)) {
        if (e.getMessage().contains("cannot be <= 0")) {


          throw new RuntimeException(e);

        } else {
          e.printStackTrace();
          String msg = renderer + " needs to be updated " +
            "for the current release of Processing.";
          throw new RuntimeException(msg);
        }
      } else {
        if (platform == MACOSX) {
          e.printStackTrace(System.out);  
        }
        e.printStackTrace();
        throw new RuntimeException(e.getMessage());
      }
    }
  }



  protected PGraphics createPrimaryGraphics() {
    return makeGraphics(sketchWidth(), sketchHeight(),
                        sketchRenderer(), sketchOutputPath(), true);
  }



  public PImage createImage(int w, int h, int format) {
    PImage image = new PImage(w, h, format);
    image.parent = this;  
    return image;
  }





  protected boolean insideDraw;


  protected long frameRateLastNanos = 0;


  public void handleDraw() {



    if (g == null) return;
    if (!looping && !redraw) return;














    if (insideDraw) {
      System.err.println("handleDraw() called before finishing");
      System.exit(1);
    }

    insideDraw = true;
    g.beginDraw();
    if (recorder != null) {
      recorder.beginDraw();
    }

    long now = System.nanoTime();

    if (frameCount == 0) {





      setup();






      defaultSize = false;

    } else {  

      double rate = 1000000.0 / ((now - frameRateLastNanos) / 1000000.0);
      float instantaneousRate = (float) (rate / 1000.0);
      frameRate = (frameRate * 0.9f) + (instantaneousRate * 0.1f);

      if (frameCount != 0) {
        handleMethods("pre");
      }



      pmouseX = dmouseX;
      pmouseY = dmouseY;


      draw();



      dmouseX = mouseX;
      dmouseY = mouseY;





      dequeueEvents();

      handleMethods("draw");

      redraw = false;  

    }
    g.endDraw();





    if (recorder != null) {
      recorder.endDraw();
    }
    insideDraw = false;

    if (frameCount != 0) {
      handleMethods("post");
    }

    frameRateLastNanos = now;
    frameCount++;
  }












  synchronized public void redraw() {
    if (!looping) {
      redraw = true;











    }
  }


  synchronized public void loop() {
    if (!looping) {
      looping = true;
    }
  }


  synchronized public void noLoop() {
    if (looping) {
      looping = false;
    }
  }





  InternalEventQueue eventQueue = new InternalEventQueue();


  static class InternalEventQueue {
    protected Event queue[] = new Event[10];
    protected int offset;
    protected int count;

    synchronized void add(Event e) {
      if (count == queue.length) {
        queue = (Event[]) expand(queue);
      }
      queue[count++] = e;
    }

    synchronized Event remove() {
      if (offset == count) {
        throw new RuntimeException("Nothing left on the event queue.");
      }
      Event outgoing = queue[offset++];
      if (offset == count) {

        offset = 0;
        count = 0;
      }
      return outgoing;
    }

    synchronized boolean available() {
      return count != 0;
    }
  }



  public void postEvent(processing.event.Event pe) {
    eventQueue.add(pe);

    if (!looping) {
      dequeueEvents();
    }
  }


  protected void dequeueEvents() {
    while (eventQueue.available()) {
      Event e = eventQueue.remove();

      switch (e.getFlavor()) {
      case Event.MOUSE:
        handleMouseEvent((MouseEvent) e);
        break;
      case Event.KEY:
        handleKeyEvent((KeyEvent) e);
        break;
      }
    }
  }






  protected void handleMouseEvent(MouseEvent event) {








    final int action = event.getAction();
    if (action == MouseEvent.DRAG ||
        action == MouseEvent.MOVE ||
        action == MouseEvent.PRESS) {
      pmouseX = emouseX;
      pmouseY = emouseY;
      mouseX = event.getX();
      mouseY = event.getY();
    }


    mouseButton = event.getButton();





    if (firstMouse) {
      pmouseX = mouseX;
      pmouseY = mouseY;
      dmouseX = mouseX;
      dmouseY = mouseY;
      firstMouse = false;
    }

    mouseEvent = event;




    switch (action) {
    case MouseEvent.PRESS:
      mousePressed = true;
      break;
    case MouseEvent.RELEASE:
      mousePressed = false;
      break;
    }

    handleMethods("mouseEvent", new Object[] { event });

    switch (action) {
    case MouseEvent.PRESS:

      mousePressed(event);
      break;
    case MouseEvent.RELEASE:

      mouseReleased(event);
      break;
    case MouseEvent.CLICK:
      mouseClicked(event);
      break;
    case MouseEvent.DRAG:
      mouseDragged(event);
      break;
    case MouseEvent.MOVE:
      mouseMoved(event);
      break;
    case MouseEvent.ENTER:
      mouseEntered(event);
      break;
    case MouseEvent.EXIT:
      mouseExited(event);
      break;
    case MouseEvent.WHEEL:
      mouseWheel(event);
      break;
    }

    if ((action == MouseEvent.DRAG) ||
        (action == MouseEvent.MOVE)) {
      emouseX = mouseX;
      emouseY = mouseY;
    }
  }



  public void mousePressed() { }


  public void mousePressed(MouseEvent event) {
    mousePressed();
  }



  public void mouseReleased() { }


  public void mouseReleased(MouseEvent event) {
    mouseReleased();
  }



  public void mouseClicked() { }


  public void mouseClicked(MouseEvent event) {
    mouseClicked();
  }



  public void mouseDragged() { }


  public void mouseDragged(MouseEvent event) {
    mouseDragged();
  }



  public void mouseMoved() { }


  public void mouseMoved(MouseEvent event) {
    mouseMoved();
  }


  public void mouseEntered() { }


  public void mouseEntered(MouseEvent event) {
    mouseEntered();
  }


  public void mouseExited() { }


  public void mouseExited(MouseEvent event) {
    mouseExited();
  }


  public void mouseWheel() { }


  public void mouseWheel(MouseEvent event) {
    mouseWheel();
  }






  protected void handleKeyEvent(KeyEvent event) {
    keyEvent = event;
    key = event.getKey();
    keyCode = event.getKeyCode();

    switch (event.getAction()) {
    case KeyEvent.PRESS:
      keyPressed = true;
      keyPressed(keyEvent);
      break;
    case KeyEvent.RELEASE:
      keyPressed = false;
      keyReleased(keyEvent);
      break;
    case KeyEvent.TYPE:
      keyTyped(keyEvent);
      break;
    }



    handleMethods("keyEvent", new Object[] { event });



    if (event.getAction() == KeyEvent.PRESS) {

      if (key == ESC) {
        exit();
      }




      if (external &&
          event.getKeyCode() == 'W' &&
          ((event.isMetaDown() && platform == MACOSX) ||
           (event.isControlDown() && platform != MACOSX))) {





        exit();
      }
    }
  }



  public void keyPressed() { }


  public void keyPressed(KeyEvent event) {
    keyPressed();
  }



  public void keyReleased() { }


  public void keyReleased(KeyEvent event) {
    keyReleased();
  }



  public void keyTyped() { }


  public void keyTyped(KeyEvent event) {
    keyTyped();
  }










  public void focusGained() { }


  public void focusLost() { }









  public int millis() {
    return (int) (System.currentTimeMillis() - millisOffset);
  }


  static public int second() {
    return Calendar.getInstance().get(Calendar.SECOND);
  }


  static public int minute() {
    return Calendar.getInstance().get(Calendar.MINUTE);
  }


  static public int hour() {
    return Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
  }


  static public int day() {
    return Calendar.getInstance().get(Calendar.DAY_OF_MONTH);
  }


  static public int month() {

    return Calendar.getInstance().get(Calendar.MONTH) + 1;
  }


  static public int year() {
    return Calendar.getInstance().get(Calendar.YEAR);
  }








  public void delay(int napTime) {


    try {
      Thread.sleep(napTime);
    } catch (InterruptedException e) { }


  }



  public void frameRate(float fps) {
    surface.setFrameRate(fps);
  }






  public void link(String url) {
    try {
      if (Desktop.isDesktopSupported()) {
        Desktop.getDesktop().browse(new URI(url));
      } else {

        launch(url);
      }
    } catch (IOException e) {
      e.printStackTrace();
    } catch (URISyntaxException e) {
      e.printStackTrace();
    }
  }


  static String openLauncher;



  static public Process launch(String... args) {
    String[] params = null;

    if (platform == WINDOWS) {




      params = new String[] { "cmd", "/c" };

    } else if (platform == MACOSX) {
      params = new String[] { "open" };

    } else if (platform == LINUX) {
      if (openLauncher == null) {

        try {
          Process p = Runtime.getRuntime().exec(new String[] { "gnome-open" });
 p.waitFor();

          openLauncher = "gnome-open";
        } catch (Exception e) { }
      }
      if (openLauncher == null) {

        try {
          Process p = Runtime.getRuntime().exec(new String[] { "kde-open" });
 p.waitFor();
          openLauncher = "kde-open";
        } catch (Exception e) { }
      }
      if (openLauncher == null) {
        System.err.println("Could not find gnome-open or kde-open, " +
                           "the open() command may not work.");
      }
      if (openLauncher != null) {
        params = new String[] { openLauncher };
      }



    }
    if (params != null) {

      if (params[0].equals(args[0])) {

        return exec(args);
      } else {
        params = concat(params, args);
        return exec(params);
      }
    } else {
      return exec(args);
    }
  }


  static public Process exec(String... args) {
    try {
      return Runtime.getRuntime().exec(args);
    } catch (Exception e) {
      e.printStackTrace();
      throw new RuntimeException("Could not open " + join(args, ' '));
    }
  }













  public void die(String what) {
    dispose();
    throw new RuntimeException(what);
  }



  public void die(String what, Exception e) {
    if (e != null) e.printStackTrace();
    die(what);
  }



  public void exit() {
    if (surface.isStopped()) {


      exitActual();

    } else if (looping) {

      finished = true;


      exitCalled = true;

    } else if (!looping) {


      dispose();


      exitActual();
    }
  }


  public boolean exitCalled() {
    return exitCalled;
  }



  public void exitActual() {
    try {
      System.exit(0);
    } catch (SecurityException e) {

    }
  }



  public void dispose() {

    finished = true;  


    if (surface.stopThread()) {


      if (g != null) {
        g.dispose();
      }

      handleMethods("dispose");
    }
  }







  public void method(String name) {
    try {
      Method method = getClass().getMethod(name, new Class[] {});
      method.invoke(this, new Object[] { });

    } catch (IllegalArgumentException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.getTargetException().printStackTrace();
    } catch (NoSuchMethodException nsme) {
      System.err.println("There is no public " + name + "() method " +
                         "in the class " + getClass().getName());
    } catch (Exception e) {
      e.printStackTrace();
    }
  }



  public void thread(final String name) {
    Thread later = new Thread() {
      @Override
      public void run() {
        method(name);
      }
    };
    later.start();
  }









  public void save(String filename) {
    g.save(savePath(filename));
  }



  public void saveFrame() {
    try {
      g.save(savePath("screen-" + nf(frameCount, 4) + ".tif"));
    } catch (SecurityException se) {
      System.err.println("Can't use saveFrame() when running in a browser, " +
                         "unless using a signed applet.");
    }
  }



  public void saveFrame(String filename) {
    try {
      g.save(savePath(insertFrame(filename)));
    } catch (SecurityException se) {
      System.err.println("Can't use saveFrame() when running in a browser, " +
                         "unless using a signed applet.");
    }
  }



  public String insertFrame(String what) {
    int first = what.indexOf('#');
    int last = what.lastIndexOf('#');

    if ((first != -1) && (last - first > 0)) {
      String prefix = what.substring(0, first);
      int count = last - first + 1;
      String suffix = what.substring(last + 1);
      return prefix + nf(frameCount, count) + suffix;
    }
    return what;  
  }











  public void cursor(int kind) {
    surface.setCursor(kind);
  }



  public void cursor(PImage img) {
    cursor(img, img.width/2, img.height/2);
  }



  public void cursor(PImage img, int x, int y) {
    surface.setCursor(img, x, y);
  }



  public void cursor() {
    surface.showCursor();
  }



  public void noCursor() {
    surface.hideCursor();
  }





  static public void print(byte what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(boolean what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(char what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(int what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(long what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(float what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(double what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(String what) {
    System.out.print(what);
    System.out.flush();
  }


  static public void print(Object... variables) {
    StringBuilder sb = new StringBuilder();
    for (Object o : variables) {
      if (sb.length() != 0) {
        sb.append(" ");
      }
      if (o == null) {
        sb.append("null");
      } else {
        sb.append(o.toString());
      }
    }
    System.out.print(sb.toString());
  }






  static public void println() {
    System.out.println();
  }



  static public void println(byte what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(boolean what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(char what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(int what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(long what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(float what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(double what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(String what) {
    System.out.println(what);
    System.out.flush();
  }


  static public void println(Object... variables) {

    print(variables);
    println();
  }






  static public void println(Object what) {
    if (what == null) {
      System.out.println("null");
    } else if (what.getClass().isArray()) {
      printArray(what);
    } else {
      System.out.println(what.toString());
      System.out.flush();
    }
  }


  static public void printArray(Object what) {
    if (what == null) {

      System.out.println("null");

    } else {
      String name = what.getClass().getName();
      if (name.charAt(0) == '[') {
        switch (name.charAt(1)) {
        case '[':


          System.out.println(what);
          break;

        case 'L':

          Object poo[] = (Object[]) what;
          for (int i = 0; i < poo.length; i++) {
            if (poo[i] instanceof String) {
              System.out.println("[" + i + "] \"" + poo[i] + "\"");
            } else {
              System.out.println("[" + i + "] " + poo[i]);
            }
          }
          break;

        case 'Z':  
          boolean zz[] = (boolean[]) what;
          for (int i = 0; i < zz.length; i++) {
            System.out.println("[" + i + "] " + zz[i]);
          }
          break;

        case 'B':  
          byte bb[] = (byte[]) what;
          for (int i = 0; i < bb.length; i++) {
            System.out.println("[" + i + "] " + bb[i]);
          }
          break;

        case 'C':  
          char cc[] = (char[]) what;
          for (int i = 0; i < cc.length; i++) {
            System.out.println("[" + i + "] '" + cc[i] + "'");
          }
          break;

        case 'I':  
          int ii[] = (int[]) what;
          for (int i = 0; i < ii.length; i++) {
            System.out.println("[" + i + "] " + ii[i]);
          }
          break;

        case 'J':  
          long jj[] = (long[]) what;
          for (int i = 0; i < jj.length; i++) {
            System.out.println("[" + i + "] " + jj[i]);
          }
          break;

        case 'F':  
          float ff[] = (float[]) what;
          for (int i = 0; i < ff.length; i++) {
            System.out.println("[" + i + "] " + ff[i]);
          }
          break;

        case 'D':  
          double dd[] = (double[]) what;
          for (int i = 0; i < dd.length; i++) {
            System.out.println("[" + i + "] " + dd[i]);
          }
          break;

        default:
          System.out.println(what);
        }
      } else {  
        System.out.println(what);
      }
    }
    System.out.flush();
  }


  static public void debug(String msg) {
    if (DEBUG) println(msg);
  }














  static public final float abs(float n) {
    return (n < 0) ? -n : n;
  }

  static public final int abs(int n) {
    return (n < 0) ? -n : n;
  }


  static public final float sq(float n) {
    return n*n;
  }


  static public final float sqrt(float n) {
    return (float)Math.sqrt(n);
  }


  static public final float log(float n) {
    return (float)Math.log(n);
  }


  static public final float exp(float n) {
    return (float)Math.exp(n);
  }


  static public final float pow(float n, float e) {
    return (float)Math.pow(n, e);
  }


  static public final int max(int a, int b) {
    return (a > b) ? a : b;
  }

  static public final float max(float a, float b) {
    return (a > b) ? a : b;
  }




  static public final int max(int a, int b, int c) {
    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
  }


  static public final float max(float a, float b, float c) {
    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
  }



  static public final int max(int[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    int max = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] > max) max = list[i];
    }
    return max;
  }

  static public final float max(float[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    float max = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] > max) max = list[i];
    }
    return max;
  }






  static public final int min(int a, int b) {
    return (a < b) ? a : b;
  }

  static public final float min(float a, float b) {
    return (a < b) ? a : b;
  }




  static public final int min(int a, int b, int c) {
    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
  }


  static public final float min(float a, float b, float c) {
    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
  }





  static public final int min(int[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    int min = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] < min) min = list[i];
    }
    return min;
  }

  static public final float min(float[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    float min = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] < min) min = list[i];
    }
    return min;
  }






  static public final int constrain(int amt, int low, int high) {
    return (amt < low) ? low : ((amt > high) ? high : amt);
  }



  static public final float constrain(float amt, float low, float high) {
    return (amt < low) ? low : ((amt > high) ? high : amt);
  }


  static public final float sin(float angle) {
    return (float)Math.sin(angle);
  }


  static public final float cos(float angle) {
    return (float)Math.cos(angle);
  }


  static public final float tan(float angle) {
    return (float)Math.tan(angle);
  }


  static public final float asin(float value) {
    return (float)Math.asin(value);
  }


  static public final float acos(float value) {
    return (float)Math.acos(value);
  }


  static public final float atan(float value) {
    return (float)Math.atan(value);
  }


  static public final float atan2(float y, float x) {
    return (float)Math.atan2(y, x);
  }


  static public final float degrees(float radians) {
    return radians * RAD_TO_DEG;
  }


  static public final float radians(float degrees) {
    return degrees * DEG_TO_RAD;
  }


  static public final int ceil(float n) {
    return (int) Math.ceil(n);
  }


  static public final int floor(float n) {
    return (int) Math.floor(n);
  }


  static public final int round(float n) {
    return Math.round(n);
  }


  static public final float mag(float a, float b) {
    return (float)Math.sqrt(a*a + b*b);
  }


  static public final float mag(float a, float b, float c) {
    return (float)Math.sqrt(a*a + b*b + c*c);
  }


  static public final float dist(float x1, float y1, float x2, float y2) {
    return sqrt(sq(x2-x1) + sq(y2-y1));
  }


  static public final float dist(float x1, float y1, float z1,
                                 float x2, float y2, float z2) {
    return sqrt(sq(x2-x1) + sq(y2-y1) + sq(z2-z1));
  }


  static public final float lerp(float start, float stop, float amt) {
    return start + (stop-start) * amt;
  }


  static public final float norm(float value, float start, float stop) {
    return (value - start) / (stop - start);
  }


  static public final float map(float value,
                                float start1, float stop1,
                                float start2, float stop2) {
    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
  }











  Random internalRandom;


  public final float random(float high) {

    if (high == 0 || high != high) {
      return 0;
    }

    if (internalRandom == null) {
      internalRandom = new Random();
    }




    float value = 0;
    do {
      value = internalRandom.nextFloat() * high;
    } while (value == high);
    return value;
  }


  public final float randomGaussian() {
    if (internalRandom == null) {
      internalRandom = new Random();
    }
    return (float) internalRandom.nextGaussian();
  }



  public final float random(float low, float high) {
    if (low >= high) return low;
    float diff = high - low;
    return random(diff) + low;
  }



  public final void randomSeed(long seed) {
    if (internalRandom == null) {
      internalRandom = new Random();
    }
    internalRandom.setSeed(seed);
  }


















  static final int PERLIN_YWRAPB = 4;
  static final int PERLIN_YWRAP = 1<<PERLIN_YWRAPB;
  static final int PERLIN_ZWRAPB = 8;
  static final int PERLIN_ZWRAP = 1<<PERLIN_ZWRAPB;
  static final int PERLIN_SIZE = 4095;

  int perlin_octaves = 4; 
  float perlin_amp_falloff = 0.5f; 



  int perlin_TWOPI, perlin_PI;
  float[] perlin_cosTable;
  float[] perlin;

  Random perlinRandom;



  public float noise(float x) {

    return noise(x, 0f, 0f);
  }


  public float noise(float x, float y) {
    return noise(x, y, 0f);
  }


  public float noise(float x, float y, float z) {
    if (perlin == null) {
      if (perlinRandom == null) {
        perlinRandom = new Random();
      }
      perlin = new float[PERLIN_SIZE + 1];
      for (int i = 0; i < PERLIN_SIZE + 1; i++) {
        perlin[i] = perlinRandom.nextFloat(); 
      }



      perlin_cosTable = PGraphics.cosLUT;
      perlin_TWOPI = perlin_PI = PGraphics.SINCOS_LENGTH;
      perlin_PI >>= 1;
    }

    if (x<0) x=-x;
    if (y<0) y=-y;
    if (z<0) z=-z;

    int xi=(int)x, yi=(int)y, zi=(int)z;
    float xf = x - xi;
    float yf = y - yi;
    float zf = z - zi;
    float rxf, ryf;

    float r=0;
    float ampl=0.5f;

    float n1,n2,n3;

    for (int i=0; i<perlin_octaves; i++) {
      int of=xi+(yi<<PERLIN_YWRAPB)+(zi<<PERLIN_ZWRAPB);

      rxf=noise_fsc(xf);
      ryf=noise_fsc(yf);

      n1  = perlin[of&PERLIN_SIZE];
      n1 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n1);
      n2  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
      n2 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n2);
      n1 += ryf*(n2-n1);

      of += PERLIN_ZWRAP;
      n2  = perlin[of&PERLIN_SIZE];
      n2 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n2);
      n3  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
      n3 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n3);
      n2 += ryf*(n3-n2);

      n1 += noise_fsc(zf)*(n2-n1);

      r += n1*ampl;
      ampl *= perlin_amp_falloff;
      xi<<=1; xf*=2;
      yi<<=1; yf*=2;
      zi<<=1; zf*=2;

      if (xf>=1.0f) { xi++; xf--; }
      if (yf>=1.0f) { yi++; yf--; }
      if (zf>=1.0f) { zi++; zf--; }
    }
    return r;
  }




  private float noise_fsc(float i) {

    return 0.5f*(1.0f-perlin_cosTable[(int)(i*perlin_PI)%perlin_TWOPI]);
  }







  public void noiseDetail(int lod) {
    if (lod>0) perlin_octaves=lod;
  }


  public void noiseDetail(int lod, float falloff) {
    if (lod>0) perlin_octaves=lod;
    if (falloff>0) perlin_amp_falloff=falloff;
  }


  public void noiseSeed(long seed) {
    if (perlinRandom == null) perlinRandom = new Random();
    perlinRandom.setSeed(seed);

    perlin = null;
  }






  protected String[] loadImageFormats;


  public PImage loadImage(String filename) {

    return loadImage(filename, null);
  }
















  public PImage loadImage(String filename, String extension) { 
    if (extension == null) {
      String lower = filename.toLowerCase();
      int dot = filename.lastIndexOf('.');
      if (dot == -1) {
        extension = "unknown";  
      }
      extension = lower.substring(dot + 1);



      int question = extension.indexOf('?');
      if (question != -1) {
        extension = extension.substring(0, question);
      }
    }


    extension = extension.toLowerCase();

    if (extension.equals("tga")) {
      try {
        PImage image = loadImageTGA(filename);



        return image;
      } catch (IOException e) {
        e.printStackTrace();
        return null;
      }
    }

    if (extension.equals("tif") || extension.equals("tiff")) {
      byte bytes[] = loadBytes(filename);
      PImage image =  (bytes == null) ? null : PImage.loadTIFF(bytes);



      return image;
    }




    try {
      if (extension.equals("jpg") || extension.equals("jpeg") ||
          extension.equals("gif") || extension.equals("png") ||
          extension.equals("unknown")) {
        byte bytes[] = loadBytes(filename);
        if (bytes == null) {
          return null;
        } else {

          Image awtImage = new ImageIcon(bytes).getImage();

          if (awtImage instanceof BufferedImage) {
            BufferedImage buffImage = (BufferedImage) awtImage;
            int space = buffImage.getColorModel().getColorSpace().getType();
            if (space == ColorSpace.TYPE_CMYK) {
              System.err.println(filename + " is a CMYK image, " +
                                 "only RGB images are supported.");
              return null;

            }
          }

          PImage image = new PImage(awtImage);
          if (image.width == -1) {
            System.err.println("The file " + filename +
                               " contains bad image data, or may not be an image.");
          }


          if (extension.equals("gif") || extension.equals("png")) {
            image.checkAlpha();
          }




          return image;
        }
      }
    } catch (Exception e) {

      e.printStackTrace();
    }

    if (loadImageFormats == null) {
      loadImageFormats = ImageIO.getReaderFormatNames();
    }
    if (loadImageFormats != null) {
      for (int i = 0; i < loadImageFormats.length; i++) {
        if (extension.equals(loadImageFormats[i])) {
          return loadImageIO(filename);





        }
      }
    }


    System.err.println("Could not find a method to load " + filename);
    return null;
  }


  public PImage requestImage(String filename) {

    return requestImage(filename, null);
  }



  public PImage requestImage(String filename, String extension) {
    PImage vessel = createImage(0, 0, ARGB);
    AsyncImageLoader ail =
      new AsyncImageLoader(filename, extension, vessel);
    ail.start();
    return vessel;
  }















  public int requestImageMax = 4;
  volatile int requestImageCount;

  class AsyncImageLoader extends Thread {
    String filename;
    String extension;
    PImage vessel;

    public AsyncImageLoader(String filename, String extension, PImage vessel) {
      this.filename = filename;
      this.extension = extension;
      this.vessel = vessel;
    }

    @Override
    public void run() {
      while (requestImageCount == requestImageMax) {
        try {
          Thread.sleep(10);
        } catch (InterruptedException e) { }
      }
      requestImageCount++;

      PImage actual = loadImage(filename, extension);


      if (actual == null) {
        vessel.width = -1;
        vessel.height = -1;

      } else {
        vessel.width = actual.width;
        vessel.height = actual.height;
        vessel.format = actual.format;
        vessel.pixels = actual.pixels;

        vessel.pixelWidth = actual.width;
        vessel.pixelHeight = actual.height;
        vessel.pixelDensity = 1;
      }
      requestImageCount--;
    }
  }























  protected PImage loadImageIO(String filename) {
    InputStream stream = createInput(filename);
    if (stream == null) {
      System.err.println("The image " + filename + " could not be found.");
      return null;
    }

    try {
      BufferedImage bi = ImageIO.read(stream);
      PImage outgoing = new PImage(bi.getWidth(), bi.getHeight());
      outgoing.parent = this;

      bi.getRGB(0, 0, outgoing.width, outgoing.height,
                outgoing.pixels, 0, outgoing.width);








      outgoing.checkAlpha();

      stream.close();

      return outgoing;

    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }



  protected PImage loadImageTGA(String filename) throws IOException {
    InputStream is = createInput(filename);
    if (is == null) return null;

    byte header[] = new byte[18];
    int offset = 0;
    do {
      int count = is.read(header, offset, header.length - offset);
      if (count == -1) return null;
      offset += count;
    } while (offset < 18);



    int format = 0;

    if (((header[2] == 3) || (header[2] == 11)) &&  
        (header[16] == 8) &&  
        ((header[17] == 0x8) || (header[17] == 0x28))) {  
      format = ALPHA;

    } else if (((header[2] == 2) || (header[2] == 10)) &&  
               (header[16] == 24) &&  
               ((header[17] == 0x20) || (header[17] == 0))) {  
      format = RGB;

    } else if (((header[2] == 2) || (header[2] == 10)) &&
               (header[16] == 32) &&
               ((header[17] == 0x8) || (header[17] == 0x28))) {  
      format = ARGB;
    }

    if (format == 0) {
      System.err.println("Unknown .tga file format for " + filename);



      return null;
    }

    int w = ((header[13] & 0xff) << 8) + (header[12] & 0xff);
    int h = ((header[15] & 0xff) << 8) + (header[14] & 0xff);
    PImage outgoing = createImage(w, h, format);





    boolean reversed = (header[17] & 0x20) == 0;

    if ((header[2] == 2) || (header[2] == 3)) {  
      if (reversed) {
        int index = (h-1) * w;
        switch (format) {
        case ALPHA:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] = is.read();
            }
            index -= w;
          }
          break;
        case RGB:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] =
                is.read() | (is.read() << 8) | (is.read() << 16) |
                0xff000000;
            }
            index -= w;
          }
          break;
        case ARGB:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] =
                is.read() | (is.read() << 8) | (is.read() << 16) |
                (is.read() << 24);
            }
            index -= w;
          }
        }
      } else {  
        int count = w * h;
        switch (format) {
        case ALPHA:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] = is.read();
          }
          break;
        case RGB:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] =
              is.read() | (is.read() << 8) | (is.read() << 16) |
              0xff000000;
          }
          break;
        case ARGB:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] =
              is.read() | (is.read() << 8) | (is.read() << 16) |
              (is.read() << 24);
          }
          break;
        }
      }

    } else {  
      int index = 0;
      int px[] = outgoing.pixels;

      while (index < px.length) {
        int num = is.read();
        boolean isRLE = (num & 0x80) != 0;
        if (isRLE) {
          num -= 127;  
          int pixel = 0;
          switch (format) {
          case ALPHA:
            pixel = is.read();
            break;
          case RGB:
            pixel = 0xFF000000 |
              is.read() | (is.read() << 8) | (is.read() << 16);

            break;
          case ARGB:
            pixel = is.read() |
              (is.read() << 8) | (is.read() << 16) | (is.read() << 24);
            break;
          }
          for (int i = 0; i < num; i++) {
            px[index++] = pixel;
            if (index == px.length) break;
          }
        } else {  
          num += 1;
          switch (format) {
          case ALPHA:
            for (int i = 0; i < num; i++) {
              px[index++] = is.read();
            }
            break;
          case RGB:
            for (int i = 0; i < num; i++) {
              px[index++] = 0xFF000000 |
                is.read() | (is.read() << 8) | (is.read() << 16);

            }
            break;
          case ARGB:
            for (int i = 0; i < num; i++) {
              px[index++] = is.read() | 
                (is.read() << 8) | (is.read() << 16) | (is.read() << 24);

            }
            break;
          }
        }
      }

      if (!reversed) {
        int[] temp = new int[w];
        for (int y = 0; y < h/2; y++) {
          int z = (h-1) - y;
          System.arraycopy(px, y*w, temp, 0, w);
          System.arraycopy(px, z*w, px, y*w, w);
          System.arraycopy(temp, 0, px, z*w, w);
        }
      }
    }
    is.close();
    return outgoing;
  }





























  public XML loadXML(String filename) {
    return loadXML(filename, null);
  }




  public XML loadXML(String filename, String options) {
    try {
      return new XML(createReader(filename), options);



    } catch (IOException e) {
      throw new RuntimeException(e);

    } catch (ParserConfigurationException e) {
      throw new RuntimeException(e);

    } catch (SAXException e) {
      throw new RuntimeException(e);
    }
  }



  public XML parseXML(String xmlString) {
    return parseXML(xmlString, null);
  }


  public XML parseXML(String xmlString, String options) {
    try {
      return XML.parse(xmlString, options);

    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }



  public boolean saveXML(XML xml, String filename) {
    return saveXML(xml, filename, null);
  }


  public boolean saveXML(XML xml, String filename, String options) {
    return xml.save(saveFile(filename), options);
  }


  public JSONObject parseJSONObject(String input) {
    return new JSONObject(new StringReader(input));
  }



  public JSONObject loadJSONObject(String filename) {
    return new JSONObject(createReader(filename));
  }


  static public JSONObject loadJSONObject(File file) {
    return new JSONObject(createReader(file));
  }



  public boolean saveJSONObject(JSONObject json, String filename) {
    return saveJSONObject(json, filename, null);
  }


  public boolean saveJSONObject(JSONObject json, String filename, String options) {
    return json.save(saveFile(filename), options);
  }


  public JSONArray parseJSONArray(String input) {
    return new JSONArray(new StringReader(input));
  }



  public JSONArray loadJSONArray(String filename) {
    return new JSONArray(createReader(filename));
  }


  static public JSONArray loadJSONArray(File file) {
    return new JSONArray(createReader(file));
  }



  public boolean saveJSONArray(JSONArray json, String filename) {
    return saveJSONArray(json, filename, null);
  }


  public boolean saveJSONArray(JSONArray json, String filename, String options) {
    return json.save(saveFile(filename), options);
  }















  public Table loadTable(String filename) {
    return loadTable(filename, null);
  }



  public Table loadTable(String filename, String options) {
    try {
      String optionStr = Table.extensionOptions(true, filename, options);
      String[] optionList = trim(split(optionStr, ','));

      Table dictionary = null;
      for (String opt : optionList) {
        if (opt.startsWith("dictionary=")) {
          dictionary = loadTable(opt.substring(opt.indexOf('=') + 1), "tsv");
          return dictionary.typedParse(createInput(filename), optionStr);
        }
      }
      InputStream input = createInput(filename);
      if (input == null) {
        System.err.println(filename + " does not exist or could not be read");
        return null;
      }
      return new Table(input, optionStr);

    } catch (IOException e) {
      e.printStackTrace();
      return null;
    }
  }



  public boolean saveTable(Table table, String filename) {
    return saveTable(table, filename, null);
  }



  public boolean saveTable(Table table, String filename, String options) {











    try {

      File outputFile = saveFile(filename);

      return table.save(outputFile, options);

    } catch (IOException e) {
      e.printStackTrace();
      return false;
    }
  }








  public PFont loadFont(String filename) {
    if (!filename.toLowerCase().endsWith(".vlw")) {
      throw new IllegalArgumentException("loadFont() is for .vlw files, try createFont()");
    }
    try {
      InputStream input = createInput(filename);
      return new PFont(input);

    } catch (Exception e) {
      die("Could not load font " + filename + ". " +
          "Make sure that the font has been copied " +
          "to the data folder of your sketch.", e);
    }
    return null;
  }



  protected PFont createDefaultFont(float size) {




    return createFont("Lucida Sans", size, true, null);
  }


  public PFont createFont(String name, float size) {
    return createFont(name, size, true, null);
  }


  public PFont createFont(String name, float size, boolean smooth) {
    return createFont(name, size, smooth, null);
  }



  public PFont createFont(String name, float size,
                          boolean smooth, char[] charset) {
    String lowerName = name.toLowerCase();
    Font baseFont = null;

    try {
      InputStream stream = null;
      if (lowerName.endsWith(".otf") || lowerName.endsWith(".ttf")) {
        stream = createInput(name);
        if (stream == null) {
          System.err.println("The font \"" + name + "\" " +
                             "is missing or inaccessible, make sure " +
                             "the URL is valid or that the file has been " +
                             "added to your sketch and is readable.");
          return null;
        }
        baseFont = Font.createFont(Font.TRUETYPE_FONT, createInput(name));

      } else {
        baseFont = PFont.findFont(name);
      }
      return new PFont(baseFont.deriveFont(size * pixelDensity),
                       smooth, charset, stream != null,
                       pixelDensity);

    } catch (Exception e) {
      System.err.println("Problem with createFont(\"" + name + "\")");
      e.printStackTrace();
      return null;
    }
  }












  public void selectInput(String prompt, String callback) {
    selectInput(prompt, callback, null);
  }


  public void selectInput(String prompt, String callback, File file) {
    selectInput(prompt, callback, file, this);
  }


  public void selectInput(String prompt, String callback,
                          File file, Object callbackObject) {
    selectInput(prompt, callback, file, callbackObject, null);  
  }


  static public void selectInput(String prompt, String callbackMethod,
                                 File file, Object callbackObject, Frame parent) {
    selectImpl(prompt, callbackMethod, file, callbackObject, parent, FileDialog.LOAD);
  }



  public void selectOutput(String prompt, String callback) {
    selectOutput(prompt, callback, null);
  }

  public void selectOutput(String prompt, String callback, File file) {
    selectOutput(prompt, callback, file, this);
  }


  public void selectOutput(String prompt, String callback,
                           File file, Object callbackObject) {
    selectOutput(prompt, callback, file, callbackObject, null); 
  }


  static public void selectOutput(String prompt, String callbackMethod,
                                  File file, Object callbackObject, Frame parent) {
    selectImpl(prompt, callbackMethod, file, callbackObject, parent, FileDialog.SAVE);
  }


  static protected void selectImpl(final String prompt,
                                   final String callbackMethod,
                                   final File defaultSelection,
                                   final Object callbackObject,
                                   final Frame parentFrame,
                                   final int mode) {
    EventQueue.invokeLater(new Runnable() {
      public void run() {
        File selectedFile = null;

        if (useNativeSelect) {
          FileDialog dialog = new FileDialog(parentFrame, prompt, mode);
          if (defaultSelection != null) {
            dialog.setDirectory(defaultSelection.getParent());
            dialog.setFile(defaultSelection.getName());
          }
          dialog.setVisible(true);
          String directory = dialog.getDirectory();
          String filename = dialog.getFile();
          if (filename != null) {
            selectedFile = new File(directory, filename);
          }

        } else {
          JFileChooser chooser = new JFileChooser();
          chooser.setDialogTitle(prompt);
          if (defaultSelection != null) {
            chooser.setSelectedFile(defaultSelection);
          }

          int result = -1;
          if (mode == FileDialog.SAVE) {
            result = chooser.showSaveDialog(parentFrame);
          } else if (mode == FileDialog.LOAD) {
            result = chooser.showOpenDialog(parentFrame);
          }
          if (result == JFileChooser.APPROVE_OPTION) {
            selectedFile = chooser.getSelectedFile();
          }
        }
        selectCallback(selectedFile, callbackMethod, callbackObject);
      }
    });
  }



  public void selectFolder(String prompt, String callback) {
    selectFolder(prompt, callback, null);
  }


  public void selectFolder(String prompt, String callback, File file) {
    selectFolder(prompt, callback, file, this);
  }


  public void selectFolder(String prompt, String callback,
                           File file, Object callbackObject) {
    selectFolder(prompt, callback, file, callbackObject, null); 
  }


  static public void selectFolder(final String prompt,
                                  final String callbackMethod,
                                  final File defaultSelection,
                                  final Object callbackObject,
                                  final Frame parentFrame) {
    EventQueue.invokeLater(new Runnable() {
      public void run() {
        File selectedFile = null;

        if (platform == MACOSX && useNativeSelect != false) {
          FileDialog fileDialog =
            new FileDialog(parentFrame, prompt, FileDialog.LOAD);
          System.setProperty("apple.awt.fileDialogForDirectories", "true");
          fileDialog.setVisible(true);
          System.setProperty("apple.awt.fileDialogForDirectories", "false");
          String filename = fileDialog.getFile();
          if (filename != null) {
            selectedFile = new File(fileDialog.getDirectory(), fileDialog.getFile());
          }
        } else {
          JFileChooser fileChooser = new JFileChooser();
          fileChooser.setDialogTitle(prompt);
          fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
          if (defaultSelection != null) {
            fileChooser.setSelectedFile(defaultSelection);
          }

          int result = fileChooser.showOpenDialog(parentFrame);
          if (result == JFileChooser.APPROVE_OPTION) {
            selectedFile = fileChooser.getSelectedFile();
          }
        }
        selectCallback(selectedFile, callbackMethod, callbackObject);
      }
    });
  }


  static private void selectCallback(File selectedFile,
                                     String callbackMethod,
                                     Object callbackObject) {
    try {
      Class<?> callbackClass = callbackObject.getClass();
      Method selectMethod =
        callbackClass.getMethod(callbackMethod, new Class[] { File.class });
      selectMethod.invoke(callbackObject, new Object[] { selectedFile });

    } catch (IllegalAccessException iae) {
      System.err.println(callbackMethod + "() must be public");

    } catch (InvocationTargetException ite) {
      ite.printStackTrace();

    } catch (NoSuchMethodException nsme) {
      System.err.println(callbackMethod + "() could not be found");
    }
  }









  static public String checkExtension(String filename) {


    if (filename.toLowerCase().endsWith(".gz")) {
      filename = filename.substring(0, filename.length() - 3);
    }
    int dotIndex = filename.lastIndexOf('.');
    if (dotIndex != -1) {
      return filename.substring(dotIndex + 1).toLowerCase();
    }
    return null;
  }









  public BufferedReader createReader(String filename) {
    InputStream is = createInput(filename);
    if (is == null) {
      System.err.println(filename + " does not exist or could not be read");
      return null;
    }
    return createReader(is);
  }



  static public BufferedReader createReader(File file) {
    try {
      InputStream is = new FileInputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        is = new GZIPInputStream(is);
      }
      return createReader(is);

    } catch (IOException e) {

      throw new RuntimeException(e);
    }
  }



  static public BufferedReader createReader(InputStream input) {
    InputStreamReader isr = null;
    try {
      isr = new InputStreamReader(input, "UTF-8");
    } catch (UnsupportedEncodingException e) { }  
    return new BufferedReader(isr);
  }



  public PrintWriter createWriter(String filename) {
    return createWriter(saveFile(filename));
  }



  static public PrintWriter createWriter(File file) {
    if (file == null) {
      throw new RuntimeException("File passed to createWriter() was null");
    }
    try {
      createPath(file);  
      OutputStream output = new FileOutputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        output = new GZIPOutputStream(output);
      }
      return createWriter(output);

    } catch (Exception e) {
      throw new RuntimeException("Couldn't create a writer for " +
                                 file.getAbsolutePath(), e);
    }
  }


  static public PrintWriter createWriter(OutputStream output) {
    try {
      BufferedOutputStream bos = new BufferedOutputStream(output, 8192);
      OutputStreamWriter osw = new OutputStreamWriter(bos, "UTF-8");
      return new PrintWriter(osw);
    } catch (UnsupportedEncodingException e) { }  
    return null;
  }

















  public InputStream createInput(String filename) {
    InputStream input = createInputRaw(filename);
    final String lower = filename.toLowerCase();
    if ((input != null) &&
        (lower.endsWith(".gz") || lower.endsWith(".svgz"))) {
      try {
        return new GZIPInputStream(input);
      } catch (IOException e) {
        e.printStackTrace();
        return null;
      }
    }
    return input;
  }



  public InputStream createInputRaw(String filename) {
    if (filename == null) return null;

    if (filename.length() == 0) {


      return null;
    }



    if (filename.contains(":")) {  
      try {
        URL url = new URL(filename);
        URLConnection conn = url.openConnection();
        HttpURLConnection httpConn = (HttpURLConnection) conn;

        httpConn.setInstanceFollowRedirects(true);
        int response = httpConn.getResponseCode();


        if (response >= 300 && response < 400) {
          String newLocation = httpConn.getHeaderField("Location");
          return createInputRaw(newLocation);
        }
        return conn.getInputStream();

      } catch (MalformedURLException mfue) {


      } catch (FileNotFoundException fnfe) {



      } catch (IOException e) {

        e.printStackTrace();

        return null;

      }
    }

    InputStream stream = null;




    try {


      File file = new File(dataPath(filename));
      if (!file.exists()) {

        file = sketchFile(filename);
      }

      if (file.isDirectory()) {
        return null;
      }
      if (file.exists()) {
        try {

          String filePath = file.getCanonicalPath();
          String filenameActual = new File(filePath).getName();

          String filenameShort = new File(filename).getName();




          if (!filenameActual.equals(filenameShort)) {
            throw new RuntimeException("This file is named " +
                                       filenameActual + " not " +
                                       filename + ". Rename the file " +
                                       "or change your code.");
          }
        } catch (IOException e) { }
      }


      stream = new FileInputStream(file);
      if (stream != null) return stream;



    } catch (IOException ioe) {
    } catch (SecurityException se) { }





    ClassLoader cl = getClass().getClassLoader();



    stream = cl.getResourceAsStream("data/" + filename);
    if (stream != null) {
      String cn = stream.getClass().getName();




      if (!cn.equals("sun.plugin.cache.EmptyInputStream")) {
        return stream;
      }
    }




    stream = cl.getResourceAsStream(filename);
    if (stream != null) {
      String cn = stream.getClass().getName();
      if (!cn.equals("sun.plugin.cache.EmptyInputStream")) {
        return stream;
      }
    }

    try {


      try {  
        try {
          stream = new FileInputStream(dataPath(filename));
          if (stream != null) return stream;
        } catch (IOException e2) { }

        try {
          stream = new FileInputStream(sketchPath(filename));
          if (stream != null) return stream;
        } catch (Exception e) { }  

        try {
          stream = new FileInputStream(filename);
          if (stream != null) return stream;
        } catch (IOException e1) { }

      } catch (SecurityException se) { }  

    } catch (Exception e) {

      e.printStackTrace();
    }

    return null;
  }


  static public InputStream createInput(File file) {
    if (file == null) {
      throw new IllegalArgumentException("File passed to createInput() was null");
    }
    try {
      InputStream input = new FileInputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        return new GZIPInputStream(input);
      }
      return input;

    } catch (IOException e) {
      System.err.println("Could not createInput() for " + file);
      e.printStackTrace();
      return null;
    }
  }



  public byte[] loadBytes(String filename) {
    InputStream is = createInput(filename);
    if (is != null) {
      byte[] outgoing = loadBytes(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();  
      }
      return outgoing;
    }

    System.err.println("The file \"" + filename + "\" " +
                       "is missing or inaccessible, make sure " +
                       "the URL is valid or that the file has been " +
                       "added to your sketch and is readable.");
    return null;
  }


  static public byte[] loadBytes(InputStream input) {
    try {
      BufferedInputStream bis = new BufferedInputStream(input);
      ByteArrayOutputStream out = new ByteArrayOutputStream();

      int c = bis.read();
      while (c != -1) {
        out.write(c);
        c = bis.read();
      }
      return out.toByteArray();

    } catch (IOException e) {
      e.printStackTrace();

    }
    return null;
  }


  static public byte[] loadBytes(File file) {
    InputStream is = createInput(file);
    byte[] byteArr = loadBytes(is);
    try {
      is.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return byteArr;
  }


  static public String[] loadStrings(File file) {
    InputStream is = createInput(file);
    if (is != null) {
      String[] outgoing = loadStrings(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return outgoing;
    }
    return null;
  }


  public String[] loadStrings(String filename) {
    InputStream is = createInput(filename);
    if (is != null) {
      String[] strArr = loadStrings(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return strArr;
    }

    System.err.println("The file \"" + filename + "\" " +
                       "is missing or inaccessible, make sure " +
                       "the URL is valid or that the file has been " +
                       "added to your sketch and is readable.");
    return null;
  }


  static public String[] loadStrings(InputStream input) {
    try {
      BufferedReader reader =
        new BufferedReader(new InputStreamReader(input, "UTF-8"));
      return loadStrings(reader);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }


  static public String[] loadStrings(BufferedReader reader) {
    try {
      String lines[] = new String[100];
      int lineCount = 0;
      String line = null;
      while ((line = reader.readLine()) != null) {
        if (lineCount == lines.length) {
          String temp[] = new String[lineCount << 1];
          System.arraycopy(lines, 0, temp, 0, lineCount);
          lines = temp;
        }
        lines[lineCount++] = line;
      }
      reader.close();

      if (lineCount == lines.length) {
        return lines;
      }


      String output[] = new String[lineCount];
      System.arraycopy(lines, 0, output, 0, lineCount);
      return output;

    } catch (IOException e) {
      e.printStackTrace();

    }
    return null;
  }









  public OutputStream createOutput(String filename) {
    return createOutput(saveFile(filename));
  }


  static public OutputStream createOutput(File file) {
    try {
      createPath(file);  
      FileOutputStream fos = new FileOutputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        return new GZIPOutputStream(fos);
      }
      return fos;

    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }



  public boolean saveStream(String target, String source) {
    return saveStream(saveFile(target), source);
  }


  public boolean saveStream(File target, String source) {
    return saveStream(target, createInputRaw(source));
  }


  public boolean saveStream(String target, InputStream source) {
    return saveStream(saveFile(target), source);
  }


  static public boolean saveStream(File target, InputStream source) {
    File tempFile = null;
    try {
      File parentDir = target.getParentFile();

      createPath(target);
      tempFile = File.createTempFile(target.getName(), null, parentDir);
      FileOutputStream targetStream = new FileOutputStream(tempFile);

      saveStream(targetStream, source);
      targetStream.close();
      targetStream = null;

      if (target.exists()) {
        if (!target.delete()) {
          System.err.println("Could not replace " +
                             target.getAbsolutePath() + ".");
        }
      }
      if (!tempFile.renameTo(target)) {
        System.err.println("Could not rename temporary file " +
                           tempFile.getAbsolutePath());
        return false;
      }
      return true;

    } catch (IOException e) {
      if (tempFile != null) {
        tempFile.delete();
      }
      e.printStackTrace();
      return false;
    }
  }


  static public void saveStream(OutputStream target,
                                InputStream source) throws IOException {
    BufferedInputStream bis = new BufferedInputStream(source, 16384);
    BufferedOutputStream bos = new BufferedOutputStream(target);

    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = bis.read(buffer)) != -1) {
      bos.write(buffer, 0, bytesRead);
    }

    bos.flush();
  }



  public void saveBytes(String filename, byte[] data) {
    saveBytes(saveFile(filename), data);
  }



  static public void saveBytes(File file, byte[] data) {
    File tempFile = null;
    try {
      File parentDir = file.getParentFile();
      tempFile = File.createTempFile(file.getName(), null, parentDir);

      OutputStream output = createOutput(tempFile);
      saveBytes(output, data);
      output.close();
      output = null;

      if (file.exists()) {
        if (!file.delete()) {
          System.err.println("Could not replace " + file.getAbsolutePath());
        }
      }

      if (!tempFile.renameTo(file)) {
        System.err.println("Could not rename temporary file " +
                           tempFile.getAbsolutePath());
      }

    } catch (IOException e) {
      System.err.println("error saving bytes to " + file);
      if (tempFile != null) {
        tempFile.delete();
      }
      e.printStackTrace();
    }
  }



  static public void saveBytes(OutputStream output, byte[] data) {
    try {
      output.write(data);
      output.flush();

    } catch (IOException e) {
      e.printStackTrace();
    }
  }





  public void saveStrings(String filename, String data[]) {
    saveStrings(saveFile(filename), data);
  }



  static public void saveStrings(File file, String data[]) {
    saveStrings(createOutput(file), data);
  }



  static public void saveStrings(OutputStream output, String[] data) {
    PrintWriter writer = createWriter(output);
    for (int i = 0; i < data.length; i++) {
      writer.println(data[i]);
    }
    writer.flush();
    writer.close();
  }





  static protected String calcSketchPath() {



    String folder = null;
    try {
      folder = System.getProperty("user.dir");



      if (platform == MACOSX) {
        String jarPath =
          PApplet.class.getProtectionDomain().getCodeSource().getLocation().getPath();

        jarPath = urlDecode(jarPath);
        if (jarPath.contains("Contents/Java/")) {
          String appPath = jarPath.substring(0, jarPath.indexOf(".app") + 4);
          File containingFolder = new File(appPath).getParentFile();
          folder = containingFolder.getAbsolutePath();
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
    return folder;
  }


  public String sketchPath() {
    if (sketchPath == null) {
      sketchPath = calcSketchPath();
    }
    return sketchPath;
  }



  public String sketchPath(String where) {
    if (sketchPath() == null) {
      return where;
    }



    try {
      if (new File(where).isAbsolute()) return where;
    } catch (Exception e) { }

    return sketchPath() + File.separator + where;
  }


  public File sketchFile(String where) {
    return new File(sketchPath(where));
  }



  public String savePath(String where) {
    if (where == null) return null;
    String filename = sketchPath(where);
    createPath(filename);
    return filename;
  }



  public File saveFile(String where) {
    return new File(savePath(where));
  }


  static File desktopFolder;


  static public File desktopFile(String what) {
    if (desktopFolder == null) {

      desktopFolder = new File(System.getProperty("user.home"), "Desktop");
      if (!desktopFolder.exists()) {
        if (platform == WINDOWS) {
          FileSystemView filesys = FileSystemView.getFileSystemView();
          desktopFolder = filesys.getHomeDirectory();
        } else {
          throw new UnsupportedOperationException("Could not find a suitable desktop foldder");
        }
      }
    }
    return new File(desktopFolder, what);
  }



  static public String desktopPath(String what) {
    return desktopFile(what).getAbsolutePath();
  }



  public String dataPath(String where) {
    return dataFile(where).getAbsolutePath();
  }



  public File dataFile(String where) {


    File why = new File(where);
    if (why.isAbsolute()) return why;

    String jarPath =
      getClass().getProtectionDomain().getCodeSource().getLocation().getPath();
    if (jarPath.contains("Contents/Java/")) {


      File containingFolder = new File(urlDecode(jarPath)).getParentFile();
      File dataFolder = new File(containingFolder, "data");
      return new File(dataFolder, where);
    }

    return new File(sketchPath + File.separator + "data" + File.separator + where);
  }












  static public void createPath(String path) {
    createPath(new File(path));
  }


  static public void createPath(File file) {
    try {
      String parent = file.getParent();
      if (parent != null) {
        File unit = new File(parent);
        if (!unit.exists()) unit.mkdirs();
      }
    } catch (SecurityException se) {
      System.err.println("You don't have permissions to create " +
                         file.getAbsolutePath());
    }
  }


  static public String getExtension(String filename) {
    String extension;

    String lower = filename.toLowerCase();
    int dot = filename.lastIndexOf('.');
    if (dot == -1) {
      extension = "unknown";  
    }
    extension = lower.substring(dot + 1);



    int question = extension.indexOf('?');
    if (question != -1) {
      extension = extension.substring(0, question);
    }

    return extension;
  }







  static public String urlEncode(String str) {
    try {
      return URLEncoder.encode(str, "UTF-8");
    } catch (UnsupportedEncodingException e) {  
      return null;
    }
  }


  static public String urlDecode(String str) {
    try {
      return URLDecoder.decode(str, "UTF-8");
    } catch (UnsupportedEncodingException e) {  
      return null;
    }
  }









  static public byte[] sort(byte list[]) {
    return sort(list, list.length);
  }


  static public byte[] sort(byte[] list, int count) {
    byte[] outgoing = new byte[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public char[] sort(char list[]) {
    return sort(list, list.length);
  }

  static public char[] sort(char[] list, int count) {
    char[] outgoing = new char[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public int[] sort(int list[]) {
    return sort(list, list.length);
  }

  static public int[] sort(int[] list, int count) {
    int[] outgoing = new int[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public float[] sort(float list[]) {
    return sort(list, list.length);
  }

  static public float[] sort(float[] list, int count) {
    float[] outgoing = new float[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public String[] sort(String list[]) {
    return sort(list, list.length);
  }

  static public String[] sort(String[] list, int count) {
    String[] outgoing = new String[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }









  static public void arrayCopy(Object src, int srcPosition,
                               Object dst, int dstPosition,
                               int length) {
    System.arraycopy(src, srcPosition, dst, dstPosition, length);
  }


  static public void arrayCopy(Object src, Object dst, int length) {
    System.arraycopy(src, 0, dst, 0, length);
  }


  static public void arrayCopy(Object src, Object dst) {
    System.arraycopy(src, 0, dst, 0, Array.getLength(src));
  }



  static public void arraycopy(Object src, int srcPosition,
                               Object dst, int dstPosition,
                               int length) {
    System.arraycopy(src, srcPosition, dst, dstPosition, length);
  }


  static public void arraycopy(Object src, Object dst, int length) {
    System.arraycopy(src, 0, dst, 0, length);
  }


  static public void arraycopy(Object src, Object dst) {
    System.arraycopy(src, 0, dst, 0, Array.getLength(src));
  }


  static public boolean[] expand(boolean list[]) {
    return expand(list, list.length << 1);
  }


  static public boolean[] expand(boolean list[], int newSize) {
    boolean temp[] = new boolean[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public byte[] expand(byte list[]) {
    return expand(list, list.length << 1);
  }

  static public byte[] expand(byte list[], int newSize) {
    byte temp[] = new byte[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public char[] expand(char list[]) {
    return expand(list, list.length << 1);
  }

  static public char[] expand(char list[], int newSize) {
    char temp[] = new char[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public int[] expand(int list[]) {
    return expand(list, list.length << 1);
  }

  static public int[] expand(int list[], int newSize) {
    int temp[] = new int[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public long[] expand(long list[]) {
    return expand(list, list.length << 1);
  }

  static public long[] expand(long list[], int newSize) {
    long temp[] = new long[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public float[] expand(float list[]) {
    return expand(list, list.length << 1);
  }

  static public float[] expand(float list[], int newSize) {
    float temp[] = new float[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public double[] expand(double list[]) {
    return expand(list, list.length << 1);
  }

  static public double[] expand(double list[], int newSize) {
    double temp[] = new double[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public String[] expand(String list[]) {
    return expand(list, list.length << 1);
  }

  static public String[] expand(String list[], int newSize) {
    String temp[] = new String[newSize];

    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }


  static public Object expand(Object array) {
    return expand(array, Array.getLength(array) << 1);
  }

  static public Object expand(Object list, int newSize) {
    Class<?> type = list.getClass().getComponentType();
    Object temp = Array.newInstance(type, newSize);
    System.arraycopy(list, 0, temp, 0,
                     Math.min(Array.getLength(list), newSize));
    return temp;
  }





  static public byte[] append(byte array[], byte value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public char[] append(char array[], char value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public int[] append(int array[], int value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public float[] append(float array[], float value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public String[] append(String array[], String value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public Object append(Object array, Object value) {
    int length = Array.getLength(array);
    array = expand(array, length + 1);
    Array.set(array, length, value);
    return array;
  }



  static public boolean[] shorten(boolean list[]) {
    return subset(list, 0, list.length-1);
  }

  static public byte[] shorten(byte list[]) {
    return subset(list, 0, list.length-1);
  }

  static public char[] shorten(char list[]) {
    return subset(list, 0, list.length-1);
  }

  static public int[] shorten(int list[]) {
    return subset(list, 0, list.length-1);
  }

  static public float[] shorten(float list[]) {
    return subset(list, 0, list.length-1);
  }

  static public String[] shorten(String list[]) {
    return subset(list, 0, list.length-1);
  }

  static public Object shorten(Object list) {
    int length = Array.getLength(list);
    return subset(list, 0, length - 1);
  }



  static final public boolean[] splice(boolean list[],
                                       boolean value, int index) {
    boolean outgoing[] = new boolean[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public boolean[] splice(boolean list[],
                                       boolean value[], int index) {
    boolean outgoing[] = new boolean[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public byte[] splice(byte list[],
                                    byte value, int index) {
    byte outgoing[] = new byte[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public byte[] splice(byte list[],
                                    byte value[], int index) {
    byte outgoing[] = new byte[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }


  static final public char[] splice(char list[],
                                    char value, int index) {
    char outgoing[] = new char[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public char[] splice(char list[],
                                    char value[], int index) {
    char outgoing[] = new char[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public int[] splice(int list[],
                                   int value, int index) {
    int outgoing[] = new int[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public int[] splice(int list[],
                                   int value[], int index) {
    int outgoing[] = new int[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public float[] splice(float list[],
                                     float value, int index) {
    float outgoing[] = new float[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public float[] splice(float list[],
                                     float value[], int index) {
    float outgoing[] = new float[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public String[] splice(String list[],
                                      String value, int index) {
    String outgoing[] = new String[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public String[] splice(String list[],
                                      String value[], int index) {
    String outgoing[] = new String[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public Object splice(Object list, Object value, int index) {
    Class<?> type = list.getClass().getComponentType();
    Object outgoing = null;
    int length = Array.getLength(list);


    if (value.getClass().getName().charAt(0) == '[') {
      int vlength = Array.getLength(value);
      outgoing = Array.newInstance(type, length + vlength);
      System.arraycopy(list, 0, outgoing, 0, index);
      System.arraycopy(value, 0, outgoing, index, vlength);
      System.arraycopy(list, index, outgoing, index + vlength, length - index);

    } else {
      outgoing = Array.newInstance(type, length + 1);
      System.arraycopy(list, 0, outgoing, 0, index);
      Array.set(outgoing, index, value);
      System.arraycopy(list, index, outgoing, index + 1, length - index);
    }
    return outgoing;
  }

  static public boolean[] subset(boolean list[], int start) {
    return subset(list, start, list.length - start);
  }


  static public boolean[] subset(boolean list[], int start, int count) {
    boolean output[] = new boolean[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public byte[] subset(byte list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public byte[] subset(byte list[], int start, int count) {
    byte output[] = new byte[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public char[] subset(char list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public char[] subset(char list[], int start, int count) {
    char output[] = new char[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public int[] subset(int list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public int[] subset(int list[], int start, int count) {
    int output[] = new int[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public float[] subset(float list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public float[] subset(float list[], int start, int count) {
    float output[] = new float[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public String[] subset(String list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public String[] subset(String list[], int start, int count) {
    String output[] = new String[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public Object subset(Object list, int start) {
    int length = Array.getLength(list);
    return subset(list, start, length - start);
  }

  static public Object subset(Object list, int start, int count) {
    Class<?> type = list.getClass().getComponentType();
    Object outgoing = Array.newInstance(type, count);
    System.arraycopy(list, start, outgoing, 0, count);
    return outgoing;
  }



  static public boolean[] concat(boolean a[], boolean b[]) {
    boolean c[] = new boolean[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public byte[] concat(byte a[], byte b[]) {
    byte c[] = new byte[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public char[] concat(char a[], char b[]) {
    char c[] = new char[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public int[] concat(int a[], int b[]) {
    int c[] = new int[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public float[] concat(float a[], float b[]) {
    float c[] = new float[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public String[] concat(String a[], String b[]) {
    String c[] = new String[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public Object concat(Object a, Object b) {
    Class<?> type = a.getClass().getComponentType();
    int alength = Array.getLength(a);
    int blength = Array.getLength(b);
    Object outgoing = Array.newInstance(type, alength + blength);
    System.arraycopy(a, 0, outgoing, 0, alength);
    System.arraycopy(b, 0, outgoing, alength, blength);
    return outgoing;
  }





  static public boolean[] reverse(boolean list[]) {
    boolean outgoing[] = new boolean[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public byte[] reverse(byte list[]) {
    byte outgoing[] = new byte[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public char[] reverse(char list[]) {
    char outgoing[] = new char[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public int[] reverse(int list[]) {
    int outgoing[] = new int[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public float[] reverse(float list[]) {
    float outgoing[] = new float[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public String[] reverse(String list[]) {
    String outgoing[] = new String[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public Object reverse(Object list) {
    Class<?> type = list.getClass().getComponentType();
    int length = Array.getLength(list);
    Object outgoing = Array.newInstance(type, length);
    for (int i = 0; i < length; i++) {
      Array.set(outgoing, i, Array.get(list, (length - 1) - i));
    }
    return outgoing;
  }









  static public String trim(String str) {
    return str.replace('\u00A0', ' ').trim();
  }



  static public String[] trim(String[] array) {
    String[] outgoing = new String[array.length];
    for (int i = 0; i < array.length; i++) {
      if (array[i] != null) {
        outgoing[i] = array[i].replace('\u00A0', ' ').trim();
      }
    }
    return outgoing;
  }



  static public String join(String[] list, char separator) {
    return join(list, String.valueOf(separator));
  }


  static public String join(String[] list, String separator) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < list.length; i++) {
      if (i != 0) sb.append(separator);
      sb.append(list[i]);
    }
    return sb.toString();
  }


  static public String[] splitTokens(String value) {
    return splitTokens(value, WHITESPACE);
  }



  static public String[] splitTokens(String value, String delim) {
    StringTokenizer toker = new StringTokenizer(value, delim);
    String pieces[] = new String[toker.countTokens()];

    int index = 0;
    while (toker.hasMoreTokens()) {
      pieces[index++] = toker.nextToken();
    }
    return pieces;
  }



  static public String[] split(String value, char delim) {


    if (value == null) return null;


    char chars[] = value.toCharArray();
    int splitCount = 0; 
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) splitCount++;
    }






    if (splitCount == 0) {
      String splits[] = new String[1];
      splits[0] = value;
      return splits;
    }

    String splits[] = new String[splitCount + 1];
    int splitIndex = 0;
    int startIndex = 0;
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) {
        splits[splitIndex++] =
          new String(chars, startIndex, i-startIndex);
        startIndex = i + 1;
      }
    }

      splits[splitIndex] =
        new String(chars, startIndex, chars.length-startIndex);

    return splits;
  }


  static public String[] split(String value, String delim) {
    ArrayList<String> items = new ArrayList<String>();
    int index;
    int offset = 0;
    while ((index = value.indexOf(delim, offset)) != -1) {
      items.add(value.substring(offset, index));
      offset = index + delim.length();
    }
    items.add(value.substring(offset));
    String[] outgoing = new String[items.size()];
    items.toArray(outgoing);
    return outgoing;
  }


  static protected HashMap<String, Pattern> matchPatterns;

  static Pattern matchPattern(String regexp) {
    Pattern p = null;
    if (matchPatterns == null) {
      matchPatterns = new HashMap<String, Pattern>();
    } else {
      p = matchPatterns.get(regexp);
    }
    if (p == null) {
      if (matchPatterns.size() == 10) {







        matchPatterns.clear();
      }
      p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
      matchPatterns.put(regexp, p);
    }
    return p;
  }



  static public String[] match(String str, String regexp) {
    Pattern p = matchPattern(regexp);
    Matcher m = p.matcher(str);
    if (m.find()) {
      int count = m.groupCount() + 1;
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      return groups;
    }
    return null;
  }



  static public String[][] matchAll(String str, String regexp) {
    Pattern p = matchPattern(regexp);
    Matcher m = p.matcher(str);
    ArrayList<String[]> results = new ArrayList<String[]>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }
    return matches;
  }












  static final public boolean parseBoolean(int what) {
    return (what != 0);
  }




  static final public boolean parseBoolean(String what) {
    return Boolean.parseBoolean(what);
  }









  static final public boolean[] parseBoolean(int what[]) {
    boolean outgoing[] = new boolean[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (what[i] != 0);
    }
    return outgoing;
  }



  static final public boolean[] parseBoolean(String what[]) {
    boolean outgoing[] = new boolean[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = Boolean.parseBoolean(what[i]);
    }
    return outgoing;
  }



  static final public byte parseByte(boolean what) {
    return what ? (byte)1 : 0;
  }

  static final public byte parseByte(char what) {
    return (byte) what;
  }

  static final public byte parseByte(int what) {
    return (byte) what;
  }

  static final public byte parseByte(float what) {
    return (byte) what;
  }





  static final public byte[] parseByte(boolean what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = what[i] ? (byte)1 : 0;
    }
    return outgoing;
  }

  static final public byte[] parseByte(char what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }

  static final public byte[] parseByte(int what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }

  static final public byte[] parseByte(float what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }







  static final public char parseChar(byte what) {
    return (char) (what & 0xff);
  }

  static final public char parseChar(int what) {
    return (char) what;
  }







  static final public char[] parseChar(byte what[]) {
    char outgoing[] = new char[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (char) (what[i] & 0xff);
    }
    return outgoing;
  }

  static final public char[] parseChar(int what[]) {
    char outgoing[] = new char[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (char) what[i];
    }
    return outgoing;
  }





  static final public int parseInt(boolean what) {
    return what ? 1 : 0;
  }


  static final public int parseInt(byte what) {
    return what & 0xff;
  }


  static final public int parseInt(char what) {
    return what;
  }


  static final public int parseInt(float what) {
    return (int) what;
  }


  static final public int parseInt(String what) {
    return parseInt(what, 0);
  }


  static final public int parseInt(String what, int otherwise) {
    try {
      int offset = what.indexOf('.');
      if (offset == -1) {
        return Integer.parseInt(what);
      } else {
        return Integer.parseInt(what.substring(0, offset));
      }
    } catch (NumberFormatException e) { }
    return otherwise;
  }



  static final public int[] parseInt(boolean what[]) {
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = what[i] ? 1 : 0;
    }
    return list;
  }

  static final public int[] parseInt(byte what[]) {  
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = (what[i] & 0xff);
    }
    return list;
  }

  static final public int[] parseInt(char what[]) {
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = what[i];
    }
    return list;
  }

  static public int[] parseInt(float what[]) {
    int inties[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      inties[i] = (int)what[i];
    }
    return inties;
  }


  static public int[] parseInt(String what[]) {
    return parseInt(what, 0);
  }


  static public int[] parseInt(String what[], int missing) {
    int output[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      try {
        output[i] = Integer.parseInt(what[i]);
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }
    return output;
  }






  static final public float parseFloat(int what) {  
    return what;
  }

  static final public float parseFloat(String what) {
    return parseFloat(what, Float.NaN);
  }

  static final public float parseFloat(String what, float otherwise) {
    try {
      return new Float(what).floatValue();
    } catch (NumberFormatException e) { }

    return otherwise;
  }





  static final public float[] parseFloat(byte what[]) {
    float floaties[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      floaties[i] = what[i];
    }
    return floaties;
  }

  static final public float[] parseFloat(int what[]) {
    float floaties[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      floaties[i] = what[i];
    }
    return floaties;
  }

  static final public float[] parseFloat(String what[]) {
    return parseFloat(what, Float.NaN);
  }

  static final public float[] parseFloat(String what[], float missing) {
    float output[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      try {
        output[i] = new Float(what[i]).floatValue();
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }
    return output;
  }



  static final public String str(boolean x) {
    return String.valueOf(x);
  }

  static final public String str(byte x) {
    return String.valueOf(x);
  }

  static final public String str(char x) {
    return String.valueOf(x);
  }

  static final public String str(int x) {
    return String.valueOf(x);
  }

  static final public String str(float x) {
    return String.valueOf(x);
  }



  static final public String[] str(boolean x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(byte x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(char x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(int x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(float x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }








  static private NumberFormat int_nf;
  static private int int_nf_digits;
  static private boolean int_nf_commas;

  static public String[] nf(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], digits);
    }
    return formatted;
  }


  static public String nf(int num, int digits) {
    if ((int_nf != null) &&
        (int_nf_digits == digits) &&
        !int_nf_commas) {
      return int_nf.format(num);
    }

    int_nf = NumberFormat.getInstance();
    int_nf.setGroupingUsed(false); 
    int_nf_commas = false;
    int_nf.setMinimumIntegerDigits(digits);
    int_nf_digits = digits;
    return int_nf.format(num);
  }


  static public String[] nfc(int num[]) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfc(num[i]);
    }
    return formatted;
  }



  static public String nfc(int num) {
    if ((int_nf != null) &&
        (int_nf_digits == 0) &&
        int_nf_commas) {
      return int_nf.format(num);
    }

    int_nf = NumberFormat.getInstance();
    int_nf.setGroupingUsed(true);
    int_nf_commas = true;
    int_nf.setMinimumIntegerDigits(0);
    int_nf_digits = 0;
    return int_nf.format(num);
  }





  static public String nfs(int num, int digits) {
    return (num < 0) ? nf(num, digits) : (' ' + nf(num, digits));
  }

  static public String[] nfs(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfs(num[i], digits);
    }
    return formatted;
  }





  static public String nfp(int num, int digits) {
    return (num < 0) ? nf(num, digits) : ('+' + nf(num, digits));
  }

  static public String[] nfp(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfp(num[i], digits);
    }
    return formatted;
  }








  static private NumberFormat float_nf;
  static private int float_nf_left, float_nf_right;
  static private boolean float_nf_commas;

  static public String[] nf(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], left, right);
    }
    return formatted;
  }

  static public String nf(float num, int left, int right) {
    if ((float_nf != null) &&
        (float_nf_left == left) &&
        (float_nf_right == right) &&
        !float_nf_commas) {
      return float_nf.format(num);
    }

    float_nf = NumberFormat.getInstance();
    float_nf.setGroupingUsed(false);
    float_nf_commas = false;

    if (left != 0) float_nf.setMinimumIntegerDigits(left);
    if (right != 0) {
      float_nf.setMinimumFractionDigits(right);
      float_nf.setMaximumFractionDigits(right);
    }
    float_nf_left = left;
    float_nf_right = right;
    return float_nf.format(num);
  }


  static public String[] nfc(float num[], int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfc(num[i], right);
    }
    return formatted;
  }


  static public String nfc(float num, int right) {
    if ((float_nf != null) &&
        (float_nf_left == 0) &&
        (float_nf_right == right) &&
        float_nf_commas) {
      return float_nf.format(num);
    }

    float_nf = NumberFormat.getInstance();
    float_nf.setGroupingUsed(true);
    float_nf_commas = true;

    if (right != 0) {
      float_nf.setMinimumFractionDigits(right);
      float_nf.setMaximumFractionDigits(right);
    }
    float_nf_left = 0;
    float_nf_right = right;
    return float_nf.format(num);
  }



  static public String[] nfs(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfs(num[i], left, right);
    }
    return formatted;
  }

  static public String nfs(float num, int left, int right) {
    return (num < 0) ? nf(num, left, right) :  (' ' + nf(num, left, right));
  }


  static public String[] nfp(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfp(num[i], left, right);
    }
    return formatted;
  }

  static public String nfp(float num, int left, int right) {
    return (num < 0) ? nf(num, left, right) :  ('+' + nf(num, left, right));
  }









  static final public String hex(byte value) {
    return hex(value, 2);
  }

  static final public String hex(char value) {
    return hex(value, 4);
  }

  static final public String hex(int value) {
    return hex(value, 8);
  }

  static final public String hex(int value, int digits) {
    String stuff = Integer.toHexString(value).toUpperCase();
    if (digits > 8) {
      digits = 8;
    }

    int length = stuff.length();
    if (length > digits) {
      return stuff.substring(length - digits);

    } else if (length < digits) {
      return "00000000".substring(8 - (digits-length)) + stuff;
    }
    return stuff;
  }


  static final public int unhex(String value) {

    return (int) (Long.parseLong(value, 16));
  }




  static final public String binary(byte value) {
    return binary(value, 8);
  }


  static final public String binary(char value) {
    return binary(value, 16);
  }


  static final public String binary(int value) {
    return binary(value, 32);
  }




  static final public String binary(int value, int digits) {
    String stuff = Integer.toBinaryString(value);
    if (digits > 32) {
      digits = 32;
    }

    int length = stuff.length();
    if (length > digits) {
      return stuff.substring(length - digits);

    } else if (length < digits) {
      int offset = 32 - (digits-length);
      return "00000000000000000000000000000000".substring(offset) + stuff;
    }
    return stuff;
  }



  static final public int unbinary(String value) {
    return Integer.parseInt(value, 2);
  }












  public final int color(int gray) {
    if (g == null) {
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      return 0xff000000 | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(gray);
  }



  public final int color(float fgray) {
    if (g == null) {
      int gray = (int) fgray;
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      return 0xff000000 | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(fgray);
  }



  public final int color(int gray, int alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (gray > 255) {

        return (alpha << 24) | (gray & 0xFFFFFF);
      } else {

        return (alpha << 24) | (gray << 16) | (gray << 8) | gray;
      }
    }
    return g.color(gray, alpha);
  }



  public final int color(float fgray, float falpha) {
    if (g == null) {
      int gray = (int) fgray;
      int alpha = (int) falpha;
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      return (alpha << 24) | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(fgray, falpha);
  }



  public final int color(int v1, int v2, int v3) {
    if (g == null) {
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return 0xff000000 | (v1 << 16) | (v2 << 8) | v3;
    }
    return g.color(v1, v2, v3);
  }


  public final int color(int v1, int v2, int v3, int alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return (alpha << 24) | (v1 << 16) | (v2 << 8) | v3;
    }
    return g.color(v1, v2, v3, alpha);
  }


  public final int color(float v1, float v2, float v3) {
    if (g == null) {
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return 0xff000000 | ((int)v1 << 16) | ((int)v2 << 8) | (int)v3;
    }
    return g.color(v1, v2, v3);
  }


  public final int color(float v1, float v2, float v3, float alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return ((int)alpha << 24) | ((int)v1 << 16) | ((int)v2 << 8) | (int)v3;
    }
    return g.color(v1, v2, v3, alpha);
  }



  public int lerpColor(int c1, int c2, float amt) {
    if (g != null) {
      return g.lerpColor(c1, c2, amt);
    }

    return PGraphics.lerpColor(c1, c2, amt, RGB);
  }


  static public int blendColor(int c1, int c2, int mode) {
    return PImage.blendColor(c1, c2, mode);
  }






  void frameMoved(int x, int y) {
    if (!fullScreen) {
      System.err.println(EXTERNAL_MOVE + " " + x + " " + y);
      System.err.flush();  
    }
  }


  void frameResized(int w, int h) {

  }








  static public void main(final String[] args) {
    runSketch(args, null);
  }



  static public void main(final String mainClass) {
    main(mainClass, null);
  }



  static public void main(final String mainClass, final String[] sketchArgs) {
    String[] args = new String[] { mainClass };
    if (sketchArgs != null) {
      args = concat(args, sketchArgs);
    }
    runSketch(args, null);
  }






  static public void runSketch(final String[] args,
                               final PApplet constructedSketch) {
    EventQueue.invokeLater(new Runnable() {
      public void run() {
        runSketchEDT(args, constructedSketch);
      }
    });
  }



  static protected void runSketchEDT(final String[] args,
                                     final PApplet constructedSketch) {


    System.setProperty("sun.awt.noerasebackground", "true");


    try {

      Toolkit.getDefaultToolkit().setDynamicLayout(true);
    } catch (HeadlessException e) {
      System.err.println("Cannot run sketch without a display. Read this for possible solutions:");
      System.err.println("https://github.com/processing/processing/wiki/Running-without-a-Display");
      System.exit(1);
    }


    System.setProperty("java.net.useSystemProxies", "true");

    if (args.length < 1) {
      System.err.println("Usage: PApplet [options] <class name> [sketch args]");
      System.err.println("See the Javadoc for PApplet for an explanation.");
      System.exit(1);
    }

    boolean external = false;
    int[] location = null;
    int[] editorLocation = null;

    String name = null;
    int windowColor = 0;
    int stopColor = 0xff808080;
    boolean hideStop = false;

    int displayNum = -1;  

    boolean present = false;


    String param = null, value = null;
    String folder = calcSketchPath();

    int argIndex = 0;
    while (argIndex < args.length) {
      int equals = args[argIndex].indexOf('=');
      if (equals != -1) {
        param = args[argIndex].substring(0, equals);
        value = args[argIndex].substring(equals + 1);

        if (param.equals(ARGS_EDITOR_LOCATION)) {
          external = true;
          editorLocation = parseInt(split(value, ','));

        } else if (param.equals(ARGS_DISPLAY)) {
          displayNum = parseInt(value, -1);
          if (displayNum == -1) {
            System.err.println("Could not parse " + value + " for " + ARGS_DISPLAY);
          }

        } else if (param.equals(ARGS_WINDOW_COLOR)) {
          if (value.charAt(0) == '#' && value.length() == 7) {
            value = value.substring(1);
            windowColor = 0xff000000 | Integer.parseInt(value, 16);
          } else {
            System.err.println(ARGS_WINDOW_COLOR + " should be a # followed by six digits");
          }

        } else if (param.equals(ARGS_STOP_COLOR)) {
          if (value.charAt(0) == '#' && value.length() == 7) {
            value = value.substring(1);
            stopColor = 0xff000000 | Integer.parseInt(value, 16);
          } else {
            System.err.println(ARGS_STOP_COLOR + " should be a # followed by six digits");
          }

        } else if (param.equals(ARGS_SKETCH_FOLDER)) {
          folder = value;

        } else if (param.equals(ARGS_LOCATION)) {
          location = parseInt(split(value, ','));
        }

      } else {
        if (args[argIndex].equals(ARGS_PRESENT)) {
          present = true;




        } else if (args[argIndex].equals(ARGS_HIDE_STOP)) {
          hideStop = true;

        } else if (args[argIndex].equals(ARGS_EXTERNAL)) {
          external = true;

        } else {
          name = args[argIndex];
          break;  
        }
      }
      argIndex++;
    }












    final PApplet sketch;
    if (constructedSketch != null) {
      sketch = constructedSketch;
    } else {
      try {
        Class<?> c =
          Thread.currentThread().getContextClassLoader().loadClass(name);
        sketch = (PApplet) c.newInstance();
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }

    if (platform == MACOSX) {
      try {
        final String td = "processing.core.ThinkDifferent";
        Class<?> thinkDifferent =
          Thread.currentThread().getContextClassLoader().loadClass(td);
        Method method =
          thinkDifferent.getMethod("init", new Class[] { PApplet.class });
        method.invoke(null, new Object[] { sketch });
      } catch (Exception e) {
        e.printStackTrace();  
      }
    }



    sketch.display = displayNum;



    sketch.handleSettings();





    sketch.sketchPath = folder;
















    if (args.length != argIndex + 1) {


      sketch.args = PApplet.subset(args, argIndex + 1);
    }

    sketch.external = external;

    if (windowColor != 0) {
      sketch.windowColor = windowColor;
    }

    PSurface surface = sketch.initSurface();




    if (present) {
      if (hideStop) {
        stopColor = 0;  
      }
      surface.placePresent(stopColor);
    } else {
      surface.placeWindow(location, editorLocation);
    }

    if (external) {
      surface.setupExternalMessages();
    }
  }


  protected PSurface initSurface() {
    g = createPrimaryGraphics();
    surface = g.createSurface();


    if (g.displayable() && frame == null) {
      frame = new Frame() {
        @Override
        public void setResizable(boolean resizable) {
          deprecationWarning("setResizable");
          surface.setResizable(resizable);
        }

        @Override
        public void setVisible(boolean visible) {
          deprecationWarning("setVisible");
          surface.setVisible(visible);
        }

        @Override
        public void setTitle(String title) {
          deprecationWarning("setTitle");
          surface.setTitle(title);
        }

        private void deprecationWarning(String method) {
          PGraphics.showWarning("Use surface." + method + "() instead of " +
                                "frame." + method + " in Processing 3");
        }
      };

      surface.initFrame(this); 
      surface.setTitle(getClass().getName());

    } else {
      surface.initOffscreen(this);  
    }

    init();
    return surface;
  }






























  static public void hideMenuBar() {
    if (PApplet.platform == PConstants.MACOSX) {


      japplemenubar.JAppleMenuBar.hide();
    }
  }



  protected void runSketch(final String[] args) {
    final String[] argsWithSketchName = new String[args.length + 1];
    System.arraycopy(args, 0, argsWithSketchName, 0, args.length);
    final String className = this.getClass().getSimpleName();
    final String cleanedClass =
      className.replaceAll("__[^_]+__\\$", "").replaceAll("\\$\\d+", "");
    argsWithSketchName[args.length] = cleanedClass;
    runSketch(argsWithSketchName, this);
  }



  protected void runSketch() {
    runSketch(new String[0]);
  }






  public PGraphics beginRecord(String renderer, String filename) {
    filename = insertFrame(filename);
    PGraphics rec = createGraphics(width, height, renderer, filename);
    beginRecord(rec);
    return rec;
  }



  public void beginRecord(PGraphics recorder) {
    this.recorder = recorder;
    recorder.beginDraw();
  }



  public void endRecord() {
    if (recorder != null) {
      recorder.endDraw();
      recorder.dispose();
      recorder = null;
    }
  }



  public PGraphics beginRaw(String renderer, String filename) {
    filename = insertFrame(filename);
    PGraphics rec = createGraphics(width, height, renderer, filename);
    g.beginRaw(rec);
    return rec;
  }




  public void beginRaw(PGraphics rawGraphics) {
    g.beginRaw(rawGraphics);
  }



  public void endRaw() {
    g.endRaw();
  }









  public void loadPixels() {
    g.loadPixels();
    pixels = g.pixels;
  }


  public void updatePixels() {
    g.updatePixels();
  }


  public void updatePixels(int x1, int y1, int x2, int y2) {
    g.updatePixels(x1, y1, x2, y2);
  }











  public PGL beginPGL() {
    return g.beginPGL();
  }


  public void endPGL() {
    if (recorder != null) recorder.endPGL();
    g.endPGL();
  }


  public void flush() {
    if (recorder != null) recorder.flush();
    g.flush();
  }


  public void hint(int which) {
    if (recorder != null) recorder.hint(which);
    g.hint(which);
  }



  public void beginShape() {
    if (recorder != null) recorder.beginShape();
    g.beginShape();
  }



  public void beginShape(int kind) {
    if (recorder != null) recorder.beginShape(kind);
    g.beginShape(kind);
  }



  public void edge(boolean edge) {
    if (recorder != null) recorder.edge(edge);
    g.edge(edge);
  }



  public void normal(float nx, float ny, float nz) {
    if (recorder != null) recorder.normal(nx, ny, nz);
    g.normal(nx, ny, nz);
  }


  public void attrib(String name, float... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }


  public void attrib(String name, int... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }


  public void attrib(String name, boolean... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }



  public void textureMode(int mode) {
    if (recorder != null) recorder.textureMode(mode);
    g.textureMode(mode);
  }



  public void textureWrap(int wrap) {
    if (recorder != null) recorder.textureWrap(wrap);
    g.textureWrap(wrap);
  }



  public void texture(PImage image) {
    if (recorder != null) recorder.texture(image);
    g.texture(image);
  }



  public void noTexture() {
    if (recorder != null) recorder.noTexture();
    g.noTexture();
  }


  public void vertex(float x, float y) {
    if (recorder != null) recorder.vertex(x, y);
    g.vertex(x, y);
  }


  public void vertex(float x, float y, float z) {
    if (recorder != null) recorder.vertex(x, y, z);
    g.vertex(x, y, z);
  }



  public void vertex(float[] v) {
    if (recorder != null) recorder.vertex(v);
    g.vertex(v);
  }


  public void vertex(float x, float y, float u, float v) {
    if (recorder != null) recorder.vertex(x, y, u, v);
    g.vertex(x, y, u, v);
  }



  public void vertex(float x, float y, float z, float u, float v) {
    if (recorder != null) recorder.vertex(x, y, z, u, v);
    g.vertex(x, y, z, u, v);
  }



  public void beginContour() {
    if (recorder != null) recorder.beginContour();
    g.beginContour();
  }



  public void endContour() {
    if (recorder != null) recorder.endContour();
    g.endContour();
  }


  public void endShape() {
    if (recorder != null) recorder.endShape();
    g.endShape();
  }



  public void endShape(int mode) {
    if (recorder != null) recorder.endShape(mode);
    g.endShape(mode);
  }



  public PShape loadShape(String filename) {
    return g.loadShape(filename);
  }



  public PShape loadShape(String filename, String options) {
    return g.loadShape(filename, options);
  }



  public PShape createShape() {
    return g.createShape();
  }


  public PShape createShape(int type) {
    return g.createShape(type);
  }



  public PShape createShape(int kind, float... p) {
    return g.createShape(kind, p);
  }



  public PShader loadShader(String fragFilename) {
    return g.loadShader(fragFilename);
  }



  public PShader loadShader(String fragFilename, String vertFilename) {
    return g.loadShader(fragFilename, vertFilename);
  }



  public void shader(PShader shader) {
    if (recorder != null) recorder.shader(shader);
    g.shader(shader);
  }



  public void shader(PShader shader, int kind) {
    if (recorder != null) recorder.shader(shader, kind);
    g.shader(shader, kind);
  }



  public void resetShader() {
    if (recorder != null) recorder.resetShader();
    g.resetShader();
  }



  public void resetShader(int kind) {
    if (recorder != null) recorder.resetShader(kind);
    g.resetShader(kind);
  }



  public void filter(PShader shader) {
    if (recorder != null) recorder.filter(shader);
    g.filter(shader);
  }



  public void clip(float a, float b, float c, float d) {
    if (recorder != null) recorder.clip(a, b, c, d);
    g.clip(a, b, c, d);
  }



  public void noClip() {
    if (recorder != null) recorder.noClip();
    g.noClip();
  }



  public void blendMode(int mode) {
    if (recorder != null) recorder.blendMode(mode);
    g.blendMode(mode);
  }


  public void bezierVertex(float x2, float y2,
                           float x3, float y3,
                           float x4, float y4) {
    if (recorder != null) recorder.bezierVertex(x2, y2, x3, y3, x4, y4);
    g.bezierVertex(x2, y2, x3, y3, x4, y4);
  }



  public void bezierVertex(float x2, float y2, float z2,
                           float x3, float y3, float z3,
                           float x4, float y4, float z4) {
    if (recorder != null) recorder.bezierVertex(x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.bezierVertex(x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public void quadraticVertex(float cx, float cy,
                              float x3, float y3) {
    if (recorder != null) recorder.quadraticVertex(cx, cy, x3, y3);
    g.quadraticVertex(cx, cy, x3, y3);
  }



  public void quadraticVertex(float cx, float cy, float cz,
                              float x3, float y3, float z3) {
    if (recorder != null) recorder.quadraticVertex(cx, cy, cz, x3, y3, z3);
    g.quadraticVertex(cx, cy, cz, x3, y3, z3);
  }



  public void curveVertex(float x, float y) {
    if (recorder != null) recorder.curveVertex(x, y);
    g.curveVertex(x, y);
  }



  public void curveVertex(float x, float y, float z) {
    if (recorder != null) recorder.curveVertex(x, y, z);
    g.curveVertex(x, y, z);
  }



  public void point(float x, float y) {
    if (recorder != null) recorder.point(x, y);
    g.point(x, y);
  }



  public void point(float x, float y, float z) {
    if (recorder != null) recorder.point(x, y, z);
    g.point(x, y, z);
  }



  public void line(float x1, float y1, float x2, float y2) {
    if (recorder != null) recorder.line(x1, y1, x2, y2);
    g.line(x1, y1, x2, y2);
  }



  public void line(float x1, float y1, float z1,
                   float x2, float y2, float z2) {
    if (recorder != null) recorder.line(x1, y1, z1, x2, y2, z2);
    g.line(x1, y1, z1, x2, y2, z2);
  }



  public void triangle(float x1, float y1, float x2, float y2,
                       float x3, float y3) {
    if (recorder != null) recorder.triangle(x1, y1, x2, y2, x3, y3);
    g.triangle(x1, y1, x2, y2, x3, y3);
  }



  public void quad(float x1, float y1, float x2, float y2,
                   float x3, float y3, float x4, float y4) {
    if (recorder != null) recorder.quad(x1, y1, x2, y2, x3, y3, x4, y4);
    g.quad(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void rectMode(int mode) {
    if (recorder != null) recorder.rectMode(mode);
    g.rectMode(mode);
  }



  public void rect(float a, float b, float c, float d) {
    if (recorder != null) recorder.rect(a, b, c, d);
    g.rect(a, b, c, d);
  }



  public void rect(float a, float b, float c, float d, float r) {
    if (recorder != null) recorder.rect(a, b, c, d, r);
    g.rect(a, b, c, d, r);
  }



  public void rect(float a, float b, float c, float d,
                   float tl, float tr, float br, float bl) {
    if (recorder != null) recorder.rect(a, b, c, d, tl, tr, br, bl);
    g.rect(a, b, c, d, tl, tr, br, bl);
  }



  public void ellipseMode(int mode) {
    if (recorder != null) recorder.ellipseMode(mode);
    g.ellipseMode(mode);
  }



  public void ellipse(float a, float b, float c, float d) {
    if (recorder != null) recorder.ellipse(a, b, c, d);
    g.ellipse(a, b, c, d);
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop) {
    if (recorder != null) recorder.arc(a, b, c, d, start, stop);
    g.arc(a, b, c, d, start, stop);
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop, int mode) {
    if (recorder != null) recorder.arc(a, b, c, d, start, stop, mode);
    g.arc(a, b, c, d, start, stop, mode);
  }



  public void box(float size) {
    if (recorder != null) recorder.box(size);
    g.box(size);
  }



  public void box(float w, float h, float d) {
    if (recorder != null) recorder.box(w, h, d);
    g.box(w, h, d);
  }



  public void sphereDetail(int res) {
    if (recorder != null) recorder.sphereDetail(res);
    g.sphereDetail(res);
  }



  public void sphereDetail(int ures, int vres) {
    if (recorder != null) recorder.sphereDetail(ures, vres);
    g.sphereDetail(ures, vres);
  }



  public void sphere(float r) {
    if (recorder != null) recorder.sphere(r);
    g.sphere(r);
  }



  public float bezierPoint(float a, float b, float c, float d, float t) {
    return g.bezierPoint(a, b, c, d, t);
  }



  public float bezierTangent(float a, float b, float c, float d, float t) {
    return g.bezierTangent(a, b, c, d, t);
  }



  public void bezierDetail(int detail) {
    if (recorder != null) recorder.bezierDetail(detail);
    g.bezierDetail(detail);
  }


  public void bezier(float x1, float y1,
                     float x2, float y2,
                     float x3, float y3,
                     float x4, float y4) {
    if (recorder != null) recorder.bezier(x1, y1, x2, y2, x3, y3, x4, y4);
    g.bezier(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void bezier(float x1, float y1, float z1,
                     float x2, float y2, float z2,
                     float x3, float y3, float z3,
                     float x4, float y4, float z4) {
    if (recorder != null) recorder.bezier(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.bezier(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public float curvePoint(float a, float b, float c, float d, float t) {
    return g.curvePoint(a, b, c, d, t);
  }



  public float curveTangent(float a, float b, float c, float d, float t) {
    return g.curveTangent(a, b, c, d, t);
  }



  public void curveDetail(int detail) {
    if (recorder != null) recorder.curveDetail(detail);
    g.curveDetail(detail);
  }



  public void curveTightness(float tightness) {
    if (recorder != null) recorder.curveTightness(tightness);
    g.curveTightness(tightness);
  }



  public void curve(float x1, float y1,
                    float x2, float y2,
                    float x3, float y3,
                    float x4, float y4) {
    if (recorder != null) recorder.curve(x1, y1, x2, y2, x3, y3, x4, y4);
    g.curve(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void curve(float x1, float y1, float z1,
                    float x2, float y2, float z2,
                    float x3, float y3, float z3,
                    float x4, float y4, float z4) {
    if (recorder != null) recorder.curve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.curve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public void imageMode(int mode) {
    if (recorder != null) recorder.imageMode(mode);
    g.imageMode(mode);
  }



  public void image(PImage img, float a, float b) {
    if (recorder != null) recorder.image(img, a, b);
    g.image(img, a, b);
  }



  public void image(PImage img, float a, float b, float c, float d) {
    if (recorder != null) recorder.image(img, a, b, c, d);
    g.image(img, a, b, c, d);
  }



  public void image(PImage img,
                    float a, float b, float c, float d,
                    int u1, int v1, int u2, int v2) {
    if (recorder != null) recorder.image(img, a, b, c, d, u1, v1, u2, v2);
    g.image(img, a, b, c, d, u1, v1, u2, v2);
  }



  public void shapeMode(int mode) {
    if (recorder != null) recorder.shapeMode(mode);
    g.shapeMode(mode);
  }


  public void shape(PShape shape) {
    if (recorder != null) recorder.shape(shape);
    g.shape(shape);
  }



  public void shape(PShape shape, float x, float y) {
    if (recorder != null) recorder.shape(shape, x, y);
    g.shape(shape, x, y);
  }



  public void shape(PShape shape, float a, float b, float c, float d) {
    if (recorder != null) recorder.shape(shape, a, b, c, d);
    g.shape(shape, a, b, c, d);
  }


  public void textAlign(int alignX) {
    if (recorder != null) recorder.textAlign(alignX);
    g.textAlign(alignX);
  }



  public void textAlign(int alignX, int alignY) {
    if (recorder != null) recorder.textAlign(alignX, alignY);
    g.textAlign(alignX, alignY);
  }



  public float textAscent() {
    return g.textAscent();
  }



  public float textDescent() {
    return g.textDescent();
  }



  public void textFont(PFont which) {
    if (recorder != null) recorder.textFont(which);
    g.textFont(which);
  }



  public void textFont(PFont which, float size) {
    if (recorder != null) recorder.textFont(which, size);
    g.textFont(which, size);
  }



  public void textLeading(float leading) {
    if (recorder != null) recorder.textLeading(leading);
    g.textLeading(leading);
  }



  public void textMode(int mode) {
    if (recorder != null) recorder.textMode(mode);
    g.textMode(mode);
  }



  public void textSize(float size) {
    if (recorder != null) recorder.textSize(size);
    g.textSize(size);
  }



  public float textWidth(char c) {
    return g.textWidth(c);
  }



  public float textWidth(String str) {
    return g.textWidth(str);
  }



  public float textWidth(char[] chars, int start, int length) {
    return g.textWidth(chars, start, length);
  }



  public void text(char c, float x, float y) {
    if (recorder != null) recorder.text(c, x, y);
    g.text(c, x, y);
  }



  public void text(char c, float x, float y, float z) {
    if (recorder != null) recorder.text(c, x, y, z);
    g.text(c, x, y, z);
  }



  public void text(String str, float x, float y) {
    if (recorder != null) recorder.text(str, x, y);
    g.text(str, x, y);
  }



  public void text(char[] chars, int start, int stop, float x, float y) {
    if (recorder != null) recorder.text(chars, start, stop, x, y);
    g.text(chars, start, stop, x, y);
  }



  public void text(String str, float x, float y, float z) {
    if (recorder != null) recorder.text(str, x, y, z);
    g.text(str, x, y, z);
  }


  public void text(char[] chars, int start, int stop,
                   float x, float y, float z) {
    if (recorder != null) recorder.text(chars, start, stop, x, y, z);
    g.text(chars, start, stop, x, y, z);
  }



  public void text(String str, float x1, float y1, float x2, float y2) {
    if (recorder != null) recorder.text(str, x1, y1, x2, y2);
    g.text(str, x1, y1, x2, y2);
  }


  public void text(int num, float x, float y) {
    if (recorder != null) recorder.text(num, x, y);
    g.text(num, x, y);
  }


  public void text(int num, float x, float y, float z) {
    if (recorder != null) recorder.text(num, x, y, z);
    g.text(num, x, y, z);
  }



  public void text(float num, float x, float y) {
    if (recorder != null) recorder.text(num, x, y);
    g.text(num, x, y);
  }


  public void text(float num, float x, float y, float z) {
    if (recorder != null) recorder.text(num, x, y, z);
    g.text(num, x, y, z);
  }



  public void pushMatrix() {
    if (recorder != null) recorder.pushMatrix();
    g.pushMatrix();
  }



  public void popMatrix() {
    if (recorder != null) recorder.popMatrix();
    g.popMatrix();
  }



  public void translate(float x, float y) {
    if (recorder != null) recorder.translate(x, y);
    g.translate(x, y);
  }



  public void translate(float x, float y, float z) {
    if (recorder != null) recorder.translate(x, y, z);
    g.translate(x, y, z);
  }



  public void rotate(float angle) {
    if (recorder != null) recorder.rotate(angle);
    g.rotate(angle);
  }



  public void rotateX(float angle) {
    if (recorder != null) recorder.rotateX(angle);
    g.rotateX(angle);
  }



  public void rotateY(float angle) {
    if (recorder != null) recorder.rotateY(angle);
    g.rotateY(angle);
  }



  public void rotateZ(float angle) {
    if (recorder != null) recorder.rotateZ(angle);
    g.rotateZ(angle);
  }



  public void rotate(float angle, float x, float y, float z) {
    if (recorder != null) recorder.rotate(angle, x, y, z);
    g.rotate(angle, x, y, z);
  }



  public void scale(float s) {
    if (recorder != null) recorder.scale(s);
    g.scale(s);
  }



  public void scale(float x, float y) {
    if (recorder != null) recorder.scale(x, y);
    g.scale(x, y);
  }



  public void scale(float x, float y, float z) {
    if (recorder != null) recorder.scale(x, y, z);
    g.scale(x, y, z);
  }



  public void shearX(float angle) {
    if (recorder != null) recorder.shearX(angle);
    g.shearX(angle);
  }



  public void shearY(float angle) {
    if (recorder != null) recorder.shearY(angle);
    g.shearY(angle);
  }



  public void resetMatrix() {
    if (recorder != null) recorder.resetMatrix();
    g.resetMatrix();
  }



  public void applyMatrix(PMatrix source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }


  public void applyMatrix(PMatrix2D source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }



  public void applyMatrix(float n00, float n01, float n02,
                          float n10, float n11, float n12) {
    if (recorder != null) recorder.applyMatrix(n00, n01, n02, n10, n11, n12);
    g.applyMatrix(n00, n01, n02, n10, n11, n12);
  }


  public void applyMatrix(PMatrix3D source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }



  public void applyMatrix(float n00, float n01, float n02, float n03,
                          float n10, float n11, float n12, float n13,
                          float n20, float n21, float n22, float n23,
                          float n30, float n31, float n32, float n33) {
    if (recorder != null) recorder.applyMatrix(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33);
    g.applyMatrix(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33);
  }


  public PMatrix getMatrix() {
    return g.getMatrix();
  }



  public PMatrix2D getMatrix(PMatrix2D target) {
    return g.getMatrix(target);
  }



  public PMatrix3D getMatrix(PMatrix3D target) {
    return g.getMatrix(target);
  }



  public void setMatrix(PMatrix source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void setMatrix(PMatrix2D source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void setMatrix(PMatrix3D source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void printMatrix() {
    if (recorder != null) recorder.printMatrix();
    g.printMatrix();
  }



  public void beginCamera() {
    if (recorder != null) recorder.beginCamera();
    g.beginCamera();
  }



  public void endCamera() {
    if (recorder != null) recorder.endCamera();
    g.endCamera();
  }



  public void camera() {
    if (recorder != null) recorder.camera();
    g.camera();
  }



  public void camera(float eyeX, float eyeY, float eyeZ,
                     float centerX, float centerY, float centerZ,
                     float upX, float upY, float upZ) {
    if (recorder != null) recorder.camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
    g.camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
  }



  public void printCamera() {
    if (recorder != null) recorder.printCamera();
    g.printCamera();
  }



  public void ortho() {
    if (recorder != null) recorder.ortho();
    g.ortho();
  }



  public void ortho(float left, float right,
                    float bottom, float top) {
    if (recorder != null) recorder.ortho(left, right, bottom, top);
    g.ortho(left, right, bottom, top);
  }



  public void ortho(float left, float right,
                    float bottom, float top,
                    float near, float far) {
    if (recorder != null) recorder.ortho(left, right, bottom, top, near, far);
    g.ortho(left, right, bottom, top, near, far);
  }



  public void perspective() {
    if (recorder != null) recorder.perspective();
    g.perspective();
  }



  public void perspective(float fovy, float aspect, float zNear, float zFar) {
    if (recorder != null) recorder.perspective(fovy, aspect, zNear, zFar);
    g.perspective(fovy, aspect, zNear, zFar);
  }



  public void frustum(float left, float right,
                      float bottom, float top,
                      float near, float far) {
    if (recorder != null) recorder.frustum(left, right, bottom, top, near, far);
    g.frustum(left, right, bottom, top, near, far);
  }



  public void printProjection() {
    if (recorder != null) recorder.printProjection();
    g.printProjection();
  }



  public float screenX(float x, float y) {
    return g.screenX(x, y);
  }



  public float screenY(float x, float y) {
    return g.screenY(x, y);
  }



  public float screenX(float x, float y, float z) {
    return g.screenX(x, y, z);
  }



  public float screenY(float x, float y, float z) {
    return g.screenY(x, y, z);
  }



  public float screenZ(float x, float y, float z) {
    return g.screenZ(x, y, z);
  }



  public float modelX(float x, float y, float z) {
    return g.modelX(x, y, z);
  }



  public float modelY(float x, float y, float z) {
    return g.modelY(x, y, z);
  }



  public float modelZ(float x, float y, float z) {
    return g.modelZ(x, y, z);
  }



  public void pushStyle() {
    if (recorder != null) recorder.pushStyle();
    g.pushStyle();
  }



  public void popStyle() {
    if (recorder != null) recorder.popStyle();
    g.popStyle();
  }


  public void style(PStyle s) {
    if (recorder != null) recorder.style(s);
    g.style(s);
  }



  public void strokeWeight(float weight) {
    if (recorder != null) recorder.strokeWeight(weight);
    g.strokeWeight(weight);
  }



  public void strokeJoin(int join) {
    if (recorder != null) recorder.strokeJoin(join);
    g.strokeJoin(join);
  }



  public void strokeCap(int cap) {
    if (recorder != null) recorder.strokeCap(cap);
    g.strokeCap(cap);
  }



  public void noStroke() {
    if (recorder != null) recorder.noStroke();
    g.noStroke();
  }



  public void stroke(int rgb) {
    if (recorder != null) recorder.stroke(rgb);
    g.stroke(rgb);
  }



  public void stroke(int rgb, float alpha) {
    if (recorder != null) recorder.stroke(rgb, alpha);
    g.stroke(rgb, alpha);
  }



  public void stroke(float gray) {
    if (recorder != null) recorder.stroke(gray);
    g.stroke(gray);
  }


  public void stroke(float gray, float alpha) {
    if (recorder != null) recorder.stroke(gray, alpha);
    g.stroke(gray, alpha);
  }



  public void stroke(float v1, float v2, float v3) {
    if (recorder != null) recorder.stroke(v1, v2, v3);
    g.stroke(v1, v2, v3);
  }


  public void stroke(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.stroke(v1, v2, v3, alpha);
    g.stroke(v1, v2, v3, alpha);
  }



  public void noTint() {
    if (recorder != null) recorder.noTint();
    g.noTint();
  }



  public void tint(int rgb) {
    if (recorder != null) recorder.tint(rgb);
    g.tint(rgb);
  }



  public void tint(int rgb, float alpha) {
    if (recorder != null) recorder.tint(rgb, alpha);
    g.tint(rgb, alpha);
  }



  public void tint(float gray) {
    if (recorder != null) recorder.tint(gray);
    g.tint(gray);
  }


  public void tint(float gray, float alpha) {
    if (recorder != null) recorder.tint(gray, alpha);
    g.tint(gray, alpha);
  }



  public void tint(float v1, float v2, float v3) {
    if (recorder != null) recorder.tint(v1, v2, v3);
    g.tint(v1, v2, v3);
  }


  public void tint(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.tint(v1, v2, v3, alpha);
    g.tint(v1, v2, v3, alpha);
  }



  public void noFill() {
    if (recorder != null) recorder.noFill();
    g.noFill();
  }



  public void fill(int rgb) {
    if (recorder != null) recorder.fill(rgb);
    g.fill(rgb);
  }



  public void fill(int rgb, float alpha) {
    if (recorder != null) recorder.fill(rgb, alpha);
    g.fill(rgb, alpha);
  }



  public void fill(float gray) {
    if (recorder != null) recorder.fill(gray);
    g.fill(gray);
  }


  public void fill(float gray, float alpha) {
    if (recorder != null) recorder.fill(gray, alpha);
    g.fill(gray, alpha);
  }



  public void fill(float v1, float v2, float v3) {
    if (recorder != null) recorder.fill(v1, v2, v3);
    g.fill(v1, v2, v3);
  }


  public void fill(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.fill(v1, v2, v3, alpha);
    g.fill(v1, v2, v3, alpha);
  }



  public void ambient(int rgb) {
    if (recorder != null) recorder.ambient(rgb);
    g.ambient(rgb);
  }



  public void ambient(float gray) {
    if (recorder != null) recorder.ambient(gray);
    g.ambient(gray);
  }



  public void ambient(float v1, float v2, float v3) {
    if (recorder != null) recorder.ambient(v1, v2, v3);
    g.ambient(v1, v2, v3);
  }



  public void specular(int rgb) {
    if (recorder != null) recorder.specular(rgb);
    g.specular(rgb);
  }



  public void specular(float gray) {
    if (recorder != null) recorder.specular(gray);
    g.specular(gray);
  }



  public void specular(float v1, float v2, float v3) {
    if (recorder != null) recorder.specular(v1, v2, v3);
    g.specular(v1, v2, v3);
  }



  public void shininess(float shine) {
    if (recorder != null) recorder.shininess(shine);
    g.shininess(shine);
  }



  public void emissive(int rgb) {
    if (recorder != null) recorder.emissive(rgb);
    g.emissive(rgb);
  }



  public void emissive(float gray) {
    if (recorder != null) recorder.emissive(gray);
    g.emissive(gray);
  }



  public void emissive(float v1, float v2, float v3) {
    if (recorder != null) recorder.emissive(v1, v2, v3);
    g.emissive(v1, v2, v3);
  }



  public void lights() {
    if (recorder != null) recorder.lights();
    g.lights();
  }



  public void noLights() {
    if (recorder != null) recorder.noLights();
    g.noLights();
  }



  public void ambientLight(float v1, float v2, float v3) {
    if (recorder != null) recorder.ambientLight(v1, v2, v3);
    g.ambientLight(v1, v2, v3);
  }



  public void ambientLight(float v1, float v2, float v3,
                           float x, float y, float z) {
    if (recorder != null) recorder.ambientLight(v1, v2, v3, x, y, z);
    g.ambientLight(v1, v2, v3, x, y, z);
  }



  public void directionalLight(float v1, float v2, float v3,
                               float nx, float ny, float nz) {
    if (recorder != null) recorder.directionalLight(v1, v2, v3, nx, ny, nz);
    g.directionalLight(v1, v2, v3, nx, ny, nz);
  }



  public void pointLight(float v1, float v2, float v3,
                         float x, float y, float z) {
    if (recorder != null) recorder.pointLight(v1, v2, v3, x, y, z);
    g.pointLight(v1, v2, v3, x, y, z);
  }



  public void spotLight(float v1, float v2, float v3,
                        float x, float y, float z,
                        float nx, float ny, float nz,
                        float angle, float concentration) {
    if (recorder != null) recorder.spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration);
    g.spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration);
  }



  public void lightFalloff(float constant, float linear, float quadratic) {
    if (recorder != null) recorder.lightFalloff(constant, linear, quadratic);
    g.lightFalloff(constant, linear, quadratic);
  }



  public void lightSpecular(float v1, float v2, float v3) {
    if (recorder != null) recorder.lightSpecular(v1, v2, v3);
    g.lightSpecular(v1, v2, v3);
  }



  public void background(int rgb) {
    if (recorder != null) recorder.background(rgb);
    g.background(rgb);
  }



  public void background(int rgb, float alpha) {
    if (recorder != null) recorder.background(rgb, alpha);
    g.background(rgb, alpha);
  }



  public void background(float gray) {
    if (recorder != null) recorder.background(gray);
    g.background(gray);
  }


  public void background(float gray, float alpha) {
    if (recorder != null) recorder.background(gray, alpha);
    g.background(gray, alpha);
  }



  public void background(float v1, float v2, float v3) {
    if (recorder != null) recorder.background(v1, v2, v3);
    g.background(v1, v2, v3);
  }


  public void background(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.background(v1, v2, v3, alpha);
    g.background(v1, v2, v3, alpha);
  }



  public void clear() {
    if (recorder != null) recorder.clear();
    g.clear();
  }



  public void background(PImage image) {
    if (recorder != null) recorder.background(image);
    g.background(image);
  }



  public void colorMode(int mode) {
    if (recorder != null) recorder.colorMode(mode);
    g.colorMode(mode);
  }



  public void colorMode(int mode, float max) {
    if (recorder != null) recorder.colorMode(mode, max);
    g.colorMode(mode, max);
  }



  public void colorMode(int mode, float max1, float max2, float max3) {
    if (recorder != null) recorder.colorMode(mode, max1, max2, max3);
    g.colorMode(mode, max1, max2, max3);
  }



  public void colorMode(int mode,
                        float max1, float max2, float max3, float maxA) {
    if (recorder != null) recorder.colorMode(mode, max1, max2, max3, maxA);
    g.colorMode(mode, max1, max2, max3, maxA);
  }



  public final float alpha(int rgb) {
    return g.alpha(rgb);
  }



  public final float red(int rgb) {
    return g.red(rgb);
  }



  public final float green(int rgb) {
    return g.green(rgb);
  }



  public final float blue(int rgb) {
    return g.blue(rgb);
  }



  public final float hue(int rgb) {
    return g.hue(rgb);
  }



  public final float saturation(int rgb) {
    return g.saturation(rgb);
  }



  public final float brightness(int rgb) {
    return g.brightness(rgb);
  }



  static public int lerpColor(int c1, int c2, float amt, int mode) {
    return PGraphics.lerpColor(c1, c2, amt, mode);
  }



  static public void showDepthWarning(String method) {
    PGraphics.showDepthWarning(method);
  }



  static public void showDepthWarningXYZ(String method) {
    PGraphics.showDepthWarningXYZ(method);
  }



  static public void showMethodWarning(String method) {
    PGraphics.showMethodWarning(method);
  }



  static public void showVariationWarning(String str) {
    PGraphics.showVariationWarning(str);
  }



  static public void showMissingWarning(String method) {
    PGraphics.showMissingWarning(method);
  }



  public int get(int x, int y) {
    return g.get(x, y);
  }



  public PImage get(int x, int y, int w, int h) {
    return g.get(x, y, w, h);
  }



  public PImage get() {
    return g.get();
  }


  public PImage copy() {
    return g.copy();
  }



  public void set(int x, int y, int c) {
    if (recorder != null) recorder.set(x, y, c);
    g.set(x, y, c);
  }



  public void set(int x, int y, PImage img) {
    if (recorder != null) recorder.set(x, y, img);
    g.set(x, y, img);
  }



  public void mask(PImage img) {
    if (recorder != null) recorder.mask(img);
    g.mask(img);
  }


  public void filter(int kind) {
    if (recorder != null) recorder.filter(kind);
    g.filter(kind);
  }



  public void filter(int kind, float param) {
    if (recorder != null) recorder.filter(kind, param);
    g.filter(kind, param);
  }



  public void copy(int sx, int sy, int sw, int sh,
                   int dx, int dy, int dw, int dh) {
    if (recorder != null) recorder.copy(sx, sy, sw, sh, dx, dy, dw, dh);
    g.copy(sx, sy, sw, sh, dx, dy, dw, dh);
  }



  public void copy(PImage src,
                   int sx, int sy, int sw, int sh,
                   int dx, int dy, int dw, int dh) {
    if (recorder != null) recorder.copy(src, sx, sy, sw, sh, dx, dy, dw, dh);
    g.copy(src, sx, sy, sw, sh, dx, dy, dw, dh);
  }


  public void blend(int sx, int sy, int sw, int sh,
                    int dx, int dy, int dw, int dh, int mode) {
    if (recorder != null) recorder.blend(sx, sy, sw, sh, dx, dy, dw, dh, mode);
    g.blend(sx, sy, sw, sh, dx, dy, dw, dh, mode);
  }



  public void blend(PImage src,
                    int sx, int sy, int sw, int sh,
                    int dx, int dy, int dw, int dh, int mode) {
    if (recorder != null) recorder.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, mode);
    g.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, mode);
  }
}

<code block>




package processing.core;



import java.awt.Desktop;
import java.awt.DisplayMode;
import java.awt.EventQueue;
import java.awt.FileDialog;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;







import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import javax.swing.filechooser.FileSystemView;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;

import java.io.*;
import java.lang.reflect.*;
import java.net.*;
import java.text.*;
import java.util.*;
import java.util.regex.*;
import java.util.zip.*;

import processing.data.*;
import processing.event.*;
import processing.opengl.*;



public class PApplet implements PConstants {

  static public final String javaVersionName =
    System.getProperty("java.version");








  static public final int javaPlatform =
    PApplet.parseInt(PApplet.split(javaVersionName, '.')[1]);









  @Deprecated
  public static final float javaVersion =
    new Float(javaVersionName.substring(0, 3));






  static public int platform;

  static {
    String osname = System.getProperty("os.name");

    if (osname.indexOf("Mac") != -1) {
      platform = MACOSX;

    } else if (osname.indexOf("Windows") != -1) {
      platform = WINDOWS;

    } else if (osname.equals("Linux")) {  
      platform = LINUX;

    } else {
      platform = OTHER;
    }
  }


  static public boolean useNativeSelect = (platform != LINUX);


  public PGraphics g;


  public int displayWidth;


  public int displayHeight;


  public PGraphics recorder;


  public String[] args;


  private String sketchPath;


  static final boolean DEBUG = false;



  static public final int DEFAULT_WIDTH = 100;
  static public final int DEFAULT_HEIGHT = 100;











  public boolean defaultSize;





  public int[] pixels;


  public int width = DEFAULT_WIDTH;


  public int height = DEFAULT_HEIGHT;


  public int pixelWidth;


  public int pixelHeight;


  public int mouseX;


  public int mouseY;


  public int pmouseX;


  public int pmouseY;


  protected int dmouseX, dmouseY;


  protected int emouseX, emouseY;


  @Deprecated
  public boolean firstMouse;


  public int mouseButton;


  public boolean mousePressed;



  @Deprecated
  public MouseEvent mouseEvent;


  public char key;


  public int keyCode;


  public boolean keyPressed;


  @Deprecated
  public KeyEvent keyEvent;


  public boolean focused = false;













  long millisOffset = System.currentTimeMillis();


  public float frameRate = 10;

  protected boolean looping;


  protected boolean redraw;


  public int frameCount;


  public volatile boolean finished;








  protected boolean exitCalled;




  static public final String ARGS_EDITOR_LOCATION = "--editor-location";

  static public final String ARGS_EXTERNAL = "--external";


  static public final String ARGS_LOCATION = "--location";


  static public final String ARGS_DISPLAY = "--display";



  static public final String ARGS_WINDOW_COLOR = "--window-color";

  static public final String ARGS_PRESENT = "--present";

  static public final String ARGS_STOP_COLOR = "--stop-color";

  static public final String ARGS_HIDE_STOP = "--hide-stop";


  static public final String ARGS_SKETCH_FOLDER = "--sketch-path";


  static public final String EXTERNAL_STOP = "__STOP__";


  static public final String EXTERNAL_MOVE = "__MOVE__";


  boolean external = false;

  static final String ERROR_MIN_MAX =
    "Cannot use min() or max() on an empty array.";





  protected PSurface surface;



  public Frame frame;
















  public void init() {






    defaultSize = true;
    finished = false; 


    looping = true;
    redraw = true;  
    firstMouse = true;





























    surface.startThread();
  }





  boolean insideSettings;

  String renderer = JAVA2D;

  int smooth = 1;  

  boolean fullScreen;
  int display = -1;  
  GraphicsDevice[] displayDevices;


  public int pixelDensity = 1;

  String outputPath;
  OutputStream outputStream;




  int windowColor = 0xffDDDDDD;



  boolean insideSettings(String method, Object... args) {
    if (insideSettings) {
      return true;
    }
    final String url = "https://processing.org/reference/" + method + "_.html";
    if (!external) {  
      StringList argList = new StringList(args);
      System.err.println("When not using the PDE, " + method + "() can only be used inside settings().");
      System.err.println("Remove the " + method + "() method from setup(), and add the following:");
      System.err.println("public void settings() {");
      System.err.println("  " + method + "(" + argList.join(", ") + ");");
      System.err.println("}");
    }
    throw new IllegalStateException(method + "() cannot be used here, see " + url);
  }


  void handleSettings() {
    insideSettings = true;







    GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
    GraphicsDevice device = ge.getDefaultScreenDevice();
    displayDevices = ge.getScreenDevices();



    if (display > 0 && display <= displayDevices.length) {
      device = displayDevices[display-1];
    }

    DisplayMode displayMode = device.getDisplayMode();
    displayWidth = displayMode.getWidth();
    displayHeight = displayMode.getHeight();



    settings();

    if (display == SPAN && platform == MACOSX) {


      Process p = exec("defaults", "read", "com.apple.spaces", "spans-displays");
      BufferedReader outReader = createReader(p.getInputStream());
      BufferedReader errReader = createReader(p.getErrorStream());
      StringBuilder stdout = new StringBuilder();
      StringBuilder stderr = new StringBuilder();
      String line = null;
      try {
        while ((line = outReader.readLine()) != null) {
          stdout.append(line);
        }
        while ((line = errReader.readLine()) != null) {
          stderr.append(line);
        }
      } catch (IOException e) {
        e.printStackTrace();
      }

      int resultCode = -1;
      try {
        resultCode = p.waitFor();
      } catch (InterruptedException e) { }

      String result = trim(stdout.toString());
      if ("0".equals(result)) {
        EventQueue.invokeLater(new Runnable() {
          public void run() {
            final String msg =
              "To use fullScreen(SPAN), first turn off âDisplays have separate spacesâ?\n" +
              "in System Preferences \u2192 Mission Control. Then log out and log back in.";
            JOptionPane.showMessageDialog(null, msg, "Apple's Defaults Stink",
                                          JOptionPane.WARNING_MESSAGE);
          }
        });
      } else if (!result.equals("1")) {
        System.err.println("Could not check the status of âDisplays have separate spaces.â?");
        System.err.format("Received message '%s' and result code %d.%n", trim(stderr.toString()), resultCode);
      }
    }

    insideSettings = false;
  }



  public void settings() {


  }


  final public int sketchWidth() {
    return width;
  }


  final public int sketchHeight() {
    return height;
  }


  final public String sketchRenderer() {
    return renderer;
  }














  final public int sketchSmooth() {
    return smooth;
  }


  final public boolean sketchFullScreen() {

    return fullScreen;
  }












  final public int sketchDisplay() {
    return display;
  }


  final public String sketchOutputPath() {

    return outputPath;
  }


  final public OutputStream sketchOutputStream() {

    return outputStream;
  }


  final public int sketchWindowColor() {
    return windowColor;
  }


  final public int sketchPixelDensity() {
    return pixelDensity;
  }





  public int displayDensity() {
    if (display == SPAN) {

      for (int i = 0; i < displayDevices.length; i++) {
        if (displayDensity(i) != 2) {
          return 1;
        }
      }
      return 2;
    }
    return displayDensity(display);
  }


  static public int displayDensity(int display) {
    if (PApplet.platform == PConstants.MACOSX) {



      final String javaVendor = System.getProperty("java.vendor");
      if (javaVendor.contains("Oracle")) {
        GraphicsDevice device;
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();

        if (display == -1) {
          device = env.getDefaultScreenDevice();

        } else if (display == SPAN) {
          throw new RuntimeException("displayDensity() only works with specific display numbers");

        } else {
          GraphicsDevice[] devices = env.getScreenDevices();
          if (display > 0 && display <= devices.length) {
            device = devices[display - 1];
          } else {
            if (devices.length == 1) {
              System.err.println("Only one display is currently known, use displayDensity(1).");
            } else {
              System.err.format("Your displays are numbered %d through %d, " +
                "pass one of those numbers to displayDensity()", 1, devices.length);
            }
            throw new RuntimeException("Display " + display + " does not exist.");
          }
        }

        try {
          Field field = device.getClass().getDeclaredField("scale");
          if (field != null) {
            field.setAccessible(true);
            Object scale = field.get(device);

            if (scale instanceof Integer && ((Integer)scale).intValue() == 2) {
              return 2;
            }
          }
        } catch (Exception ignore) { }
      }
    }
    return 1;
  }



  public void pixelDensity(int density) {
    if (density != this.pixelDensity) {
      if (insideSettings("pixelDensity", density)) {
        if (density != 1 && density != 2) {
          throw new RuntimeException("pixelDensity() can only be 1 or 2");
        }
        if (density == 2 && displayDensity() == 1) {

          throw new RuntimeException("pixelDensity(2) is not available for this display");
        } else {
          this.pixelDensity = density;
        }
      }
    }
  }



  public void setSize(int width, int height) {
    this.width = width;
    this.height = height;
    pixelWidth = width * pixelDensity;
    pixelHeight = height * pixelDensity;
  }






  public void smooth() {
    smooth(1);
  }


  public void smooth(int level) {
    if (insideSettings) {
      this.smooth = level;

    } else if (this.smooth != level) {
      smoothWarning("smooth");
    }
  }


  public void noSmooth() {
    if (insideSettings) {
      this.smooth = 0;

    } else if (this.smooth != 0) {
      smoothWarning("noSmooth");
    }
  }


  private void smoothWarning(String method) {

    final String where = external ? "setup" : "settings";
    PGraphics.showWarning("%s() can only be used inside %s()", method, where);
  }





  public PGraphics getGraphics() {
    return g;
  }



  public void orientation(int which) {

  }



  public void start() {


    resume();
    handleMethods("resume");
    surface.resumeThread();
  }



  public void stop() {














    pause();
    handleMethods("pause");


    surface.pauseThread();











  }



  public void pause() { }



  public void resume() { }























  HashMap<String, RegisteredMethods> registerMap =
    new HashMap<String, PApplet.RegisteredMethods>();


  class RegisteredMethods {
    int count;
    Object[] objects;


    Method[] methods;
    Object[] emptyArgs = new Object[] { };


    void handle() {
      handle(emptyArgs);
    }


    void handle(Object[] args) {
      for (int i = 0; i < count; i++) {
        try {
          methods[i].invoke(objects[i], args);
        } catch (Exception e) {

          Throwable t;
          if (e instanceof InvocationTargetException) {
            InvocationTargetException ite = (InvocationTargetException) e;
            t = ite.getCause();
          } else {
            t = e;
          }

          if (t instanceof RuntimeException) {

            throw (RuntimeException) t;
          } else {

            t.printStackTrace();
          }
        }
      }
    }


    void add(Object object, Method method) {
      if (findIndex(object) == -1) {
        if (objects == null) {
          objects = new Object[5];
          methods = new Method[5];

        } else if (count == objects.length) {
          objects = (Object[]) PApplet.expand(objects);
          methods = (Method[]) PApplet.expand(methods);
        }
        objects[count] = object;
        methods[count] = method;
        count++;
      } else {
        die(method.getName() + "() already added for this instance of " +
            object.getClass().getName());
      }
    }





    public void remove(Object object) {
      int index = findIndex(object);
      if (index != -1) {

        count--;
        for (int i = index; i < count; i++) {
          objects[i] = objects[i+1];
          methods[i] = methods[i+1];
        }

        objects[count] = null;
        methods[count] = null;
      }
    }



    protected int findIndex(Object object) {
      for (int i = 0; i < count; i++) {
        if (objects[i] == object) {





          return i;
        }
      }
      return -1;
    }
  }



  public void registerMethod(String methodName, Object target) {
    if (methodName.equals("mouseEvent")) {
      registerWithArgs("mouseEvent", target, new Class[] { processing.event.MouseEvent.class });

    } else if (methodName.equals("keyEvent")) {
      registerWithArgs("keyEvent", target, new Class[] { processing.event.KeyEvent.class });

    } else if (methodName.equals("touchEvent")) {
      registerWithArgs("touchEvent", target, new Class[] { processing.event.TouchEvent.class });

    } else {
      registerNoArgs(methodName, target);
    }
  }


  private void registerNoArgs(String name, Object o) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      meth = new RegisteredMethods();
      registerMap.put(name, meth);
    }
    Class<?> c = o.getClass();
    try {
      Method method = c.getMethod(name, new Class[] {});
      meth.add(o, method);

    } catch (NoSuchMethodException nsme) {
      die("There is no public " + name + "() method in the class " +
          o.getClass().getName());

    } catch (Exception e) {
      die("Could not register " + name + " + () for " + o, e);
    }
  }


  private void registerWithArgs(String name, Object o, Class<?> cargs[]) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      meth = new RegisteredMethods();
      registerMap.put(name, meth);
    }
    Class<?> c = o.getClass();
    try {
      Method method = c.getMethod(name, cargs);
      meth.add(o, method);

    } catch (NoSuchMethodException nsme) {
      die("There is no public " + name + "() method in the class " +
          o.getClass().getName());

    } catch (Exception e) {
      die("Could not register " + name + " + () for " + o, e);
    }
  }







  public void unregisterMethod(String name, Object target) {
    RegisteredMethods meth = registerMap.get(name);
    if (meth == null) {
      die("No registered methods with the name " + name + "() were found.");
    }
    try {


      meth.remove(target);
    } catch (Exception e) {
      die("Could not unregister " + name + "() for " + target, e);
    }
  }


  protected void handleMethods(String methodName) {
    RegisteredMethods meth = registerMap.get(methodName);
    if (meth != null) {
      meth.handle();
    }
  }


  protected void handleMethods(String methodName, Object[] args) {
    RegisteredMethods meth = registerMap.get(methodName);
    if (meth != null) {
      meth.handle(args);
    }
  }









  public void setup() {
  }


  public void draw() {


    finished = true;
  }









  public void fullScreen() {
    if (!fullScreen) {
      if (insideSettings("fullScreen")) {
        this.fullScreen = true;
      }
    }
  }


  public void fullScreen(int display) {
    if (!fullScreen || display != this.display) {
      if (insideSettings("fullScreen", display)) {
        this.fullScreen = true;
        this.display = display;
      }
    }
  }



  public void fullScreen(String renderer) {
    if (!fullScreen ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("fullScreen", renderer)) {
        this.fullScreen = true;
        this.renderer = renderer;
      }
    }
  }



  public void fullScreen(String renderer, int display) {
    if (!fullScreen ||
        !renderer.equals(this.renderer) ||
        display != this.display) {
      if (insideSettings("fullScreen", renderer, display)) {
        this.fullScreen = true;
        this.renderer = renderer;
        this.display = display;
      }
    }
  }



  public void size(int width, int height) {




    if (width != this.width ||
        height != this.height) {
      if (insideSettings("size", width, height)) {
        this.width = width;
        this.height = height;
      }
    }
  }


  public void size(int width, int height, String renderer) {
    if (width != this.width ||
        height != this.height ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("size", width, height, renderer)) {
        this.width = width;
        this.height = height;
        this.renderer = renderer;
      }
    }
  }



  public void size(int width, int height, String renderer, String path) {



    if (width != this.width ||
        height != this.height ||
        !renderer.equals(this.renderer)) {
      if (insideSettings("size", width, height, renderer, path)) {
        this.width = width;
        this.height = height;
        this.renderer = renderer;
        this.outputPath = path;
      }
    }

















































  }


  public PGraphics createGraphics(int w, int h) {
    return createGraphics(w, h, JAVA2D);
  }



  public PGraphics createGraphics(int w, int h, String renderer) {
    return createGraphics(w, h, renderer, null);
  }



  public PGraphics createGraphics(int w, int h,
                                  String renderer, String path) {
    return makeGraphics(w, h, renderer, path, false);

  }








  protected PGraphics makeGraphics(int w, int h,
                                   String renderer, String path,
                                   boolean primary) {








    if (!primary && !g.isGL()) {
      if (renderer.equals(P2D)) {
        throw new RuntimeException("createGraphics() with P2D requires size() to use P2D or P3D");
      } else if (renderer.equals(P3D)) {
        throw new RuntimeException("createGraphics() with P3D or OPENGL requires size() to use P2D or P3D");
      }
    }

    try {
      Class<?> rendererClass =
        Thread.currentThread().getContextClassLoader().loadClass(renderer);

      Constructor<?> constructor = rendererClass.getConstructor(new Class[] { });
      PGraphics pg = (PGraphics) constructor.newInstance();

      pg.setParent(this);
      pg.setPrimary(primary);
      if (path != null) {
        pg.setPath(savePath(path));
      }




      pg.setSize(w, h);


      return pg;

    } catch (InvocationTargetException ite) {
      String msg = ite.getTargetException().getMessage();
      if ((msg != null) &&
          (msg.indexOf("no jogl in java.library.path") != -1)) {

        throw new RuntimeException("The jogl library folder needs to be " +
          "specified with -Djava.library.path=/path/to/jogl");

      } else {
        ite.getTargetException().printStackTrace();
        Throwable target = ite.getTargetException();
        if (platform == MACOSX) {
          target.printStackTrace(System.out);  
        }
        throw new RuntimeException(target.getMessage());
      }

    } catch (ClassNotFoundException cnfe) {




      if (external) {
        throw new RuntimeException("You need to use \"Import Library\" " +
                                   "to add " + renderer + " to your sketch.");
      } else {
        throw new RuntimeException("The " + renderer +
                                   " renderer is not in the class path.");
      }

    } catch (Exception e) {
      if ((e instanceof IllegalArgumentException) ||
          (e instanceof NoSuchMethodException) ||
          (e instanceof IllegalAccessException)) {
        if (e.getMessage().contains("cannot be <= 0")) {


          throw new RuntimeException(e);

        } else {
          e.printStackTrace();
          String msg = renderer + " needs to be updated " +
            "for the current release of Processing.";
          throw new RuntimeException(msg);
        }
      } else {
        if (platform == MACOSX) {
          e.printStackTrace(System.out);  
        }
        e.printStackTrace();
        throw new RuntimeException(e.getMessage());
      }
    }
  }



  protected PGraphics createPrimaryGraphics() {
    return makeGraphics(sketchWidth(), sketchHeight(),
                        sketchRenderer(), sketchOutputPath(), true);
  }



  public PImage createImage(int w, int h, int format) {
    PImage image = new PImage(w, h, format);
    image.parent = this;  
    return image;
  }





  protected boolean insideDraw;


  protected long frameRateLastNanos = 0;


  public void handleDraw() {



    if (g == null) return;
    if (!looping && !redraw) return;














    if (insideDraw) {
      System.err.println("handleDraw() called before finishing");
      System.exit(1);
    }

    insideDraw = true;
    g.beginDraw();
    if (recorder != null) {
      recorder.beginDraw();
    }

    long now = System.nanoTime();

    if (frameCount == 0) {





      setup();






      defaultSize = false;

    } else {  

      double rate = 1000000.0 / ((now - frameRateLastNanos) / 1000000.0);
      float instantaneousRate = (float) (rate / 1000.0);
      frameRate = (frameRate * 0.9f) + (instantaneousRate * 0.1f);

      if (frameCount != 0) {
        handleMethods("pre");
      }



      pmouseX = dmouseX;
      pmouseY = dmouseY;


      draw();



      dmouseX = mouseX;
      dmouseY = mouseY;





      dequeueEvents();

      handleMethods("draw");

      redraw = false;  

    }
    g.endDraw();





    if (recorder != null) {
      recorder.endDraw();
    }
    insideDraw = false;

    if (frameCount != 0) {
      handleMethods("post");
    }

    frameRateLastNanos = now;
    frameCount++;
  }












  synchronized public void redraw() {
    if (!looping) {
      redraw = true;











    }
  }


  synchronized public void loop() {
    if (!looping) {
      looping = true;
    }
  }


  synchronized public void noLoop() {
    if (looping) {
      looping = false;
    }
  }





  InternalEventQueue eventQueue = new InternalEventQueue();


  static class InternalEventQueue {
    protected Event queue[] = new Event[10];
    protected int offset;
    protected int count;

    synchronized void add(Event e) {
      if (count == queue.length) {
        queue = (Event[]) expand(queue);
      }
      queue[count++] = e;
    }

    synchronized Event remove() {
      if (offset == count) {
        throw new RuntimeException("Nothing left on the event queue.");
      }
      Event outgoing = queue[offset++];
      if (offset == count) {

        offset = 0;
        count = 0;
      }
      return outgoing;
    }

    synchronized boolean available() {
      return count != 0;
    }
  }



  public void postEvent(processing.event.Event pe) {
    eventQueue.add(pe);

    if (!looping) {
      dequeueEvents();
    }
  }


  protected void dequeueEvents() {
    while (eventQueue.available()) {
      Event e = eventQueue.remove();

      switch (e.getFlavor()) {
      case Event.MOUSE:
        handleMouseEvent((MouseEvent) e);
        break;
      case Event.KEY:
        handleKeyEvent((KeyEvent) e);
        break;
      }
    }
  }






  protected void handleMouseEvent(MouseEvent event) {








    final int action = event.getAction();
    if (action == MouseEvent.DRAG ||
        action == MouseEvent.MOVE ||
        action == MouseEvent.PRESS) {
      pmouseX = emouseX;
      pmouseY = emouseY;
      mouseX = event.getX();
      mouseY = event.getY();
    }


    mouseButton = event.getButton();





    if (firstMouse) {
      pmouseX = mouseX;
      pmouseY = mouseY;
      dmouseX = mouseX;
      dmouseY = mouseY;
      firstMouse = false;
    }

    mouseEvent = event;




    switch (action) {
    case MouseEvent.PRESS:
      mousePressed = true;
      break;
    case MouseEvent.RELEASE:
      mousePressed = false;
      break;
    }

    handleMethods("mouseEvent", new Object[] { event });

    switch (action) {
    case MouseEvent.PRESS:

      mousePressed(event);
      break;
    case MouseEvent.RELEASE:

      mouseReleased(event);
      break;
    case MouseEvent.CLICK:
      mouseClicked(event);
      break;
    case MouseEvent.DRAG:
      mouseDragged(event);
      break;
    case MouseEvent.MOVE:
      mouseMoved(event);
      break;
    case MouseEvent.ENTER:
      mouseEntered(event);
      break;
    case MouseEvent.EXIT:
      mouseExited(event);
      break;
    case MouseEvent.WHEEL:
      mouseWheel(event);
      break;
    }

    if ((action == MouseEvent.DRAG) ||
        (action == MouseEvent.MOVE)) {
      emouseX = mouseX;
      emouseY = mouseY;
    }
  }



  public void mousePressed() { }


  public void mousePressed(MouseEvent event) {
    mousePressed();
  }



  public void mouseReleased() { }


  public void mouseReleased(MouseEvent event) {
    mouseReleased();
  }



  public void mouseClicked() { }


  public void mouseClicked(MouseEvent event) {
    mouseClicked();
  }



  public void mouseDragged() { }


  public void mouseDragged(MouseEvent event) {
    mouseDragged();
  }



  public void mouseMoved() { }


  public void mouseMoved(MouseEvent event) {
    mouseMoved();
  }


  public void mouseEntered() { }


  public void mouseEntered(MouseEvent event) {
    mouseEntered();
  }


  public void mouseExited() { }


  public void mouseExited(MouseEvent event) {
    mouseExited();
  }


  public void mouseWheel() { }


  public void mouseWheel(MouseEvent event) {
    mouseWheel();
  }






  protected void handleKeyEvent(KeyEvent event) {
    keyEvent = event;
    key = event.getKey();
    keyCode = event.getKeyCode();

    switch (event.getAction()) {
    case KeyEvent.PRESS:
      keyPressed = true;
      keyPressed(keyEvent);
      break;
    case KeyEvent.RELEASE:
      keyPressed = false;
      keyReleased(keyEvent);
      break;
    case KeyEvent.TYPE:
      keyTyped(keyEvent);
      break;
    }



    handleMethods("keyEvent", new Object[] { event });



    if (event.getAction() == KeyEvent.PRESS) {

      if (key == ESC) {
        exit();
      }




      if (external &&
          event.getKeyCode() == 'W' &&
          ((event.isMetaDown() && platform == MACOSX) ||
           (event.isControlDown() && platform != MACOSX))) {





        exit();
      }
    }
  }



  public void keyPressed() { }


  public void keyPressed(KeyEvent event) {
    keyPressed();
  }



  public void keyReleased() { }


  public void keyReleased(KeyEvent event) {
    keyReleased();
  }



  public void keyTyped() { }


  public void keyTyped(KeyEvent event) {
    keyTyped();
  }










  public void focusGained() { }


  public void focusLost() { }









  public int millis() {
    return (int) (System.currentTimeMillis() - millisOffset);
  }


  static public int second() {
    return Calendar.getInstance().get(Calendar.SECOND);
  }


  static public int minute() {
    return Calendar.getInstance().get(Calendar.MINUTE);
  }


  static public int hour() {
    return Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
  }


  static public int day() {
    return Calendar.getInstance().get(Calendar.DAY_OF_MONTH);
  }


  static public int month() {

    return Calendar.getInstance().get(Calendar.MONTH) + 1;
  }


  static public int year() {
    return Calendar.getInstance().get(Calendar.YEAR);
  }








  public void delay(int napTime) {


    try {
      Thread.sleep(napTime);
    } catch (InterruptedException e) { }


  }



  public void frameRate(float fps) {
    surface.setFrameRate(fps);
  }






  public void link(String url) {
    try {
      if (Desktop.isDesktopSupported()) {
        Desktop.getDesktop().browse(new URI(url));
      } else {

        launch(url);
      }
    } catch (IOException e) {
      e.printStackTrace();
    } catch (URISyntaxException e) {
      e.printStackTrace();
    }
  }


  static String openLauncher;



  static public Process launch(String... args) {
    String[] params = null;

    if (platform == WINDOWS) {




      params = new String[] { "cmd", "/c" };

    } else if (platform == MACOSX) {
      params = new String[] { "open" };

    } else if (platform == LINUX) {
      if (openLauncher == null) {

        try {
          Process p = Runtime.getRuntime().exec(new String[] { "gnome-open" });
 p.waitFor();

          openLauncher = "gnome-open";
        } catch (Exception e) { }
      }
      if (openLauncher == null) {

        try {
          Process p = Runtime.getRuntime().exec(new String[] { "kde-open" });
 p.waitFor();
          openLauncher = "kde-open";
        } catch (Exception e) { }
      }
      if (openLauncher == null) {
        System.err.println("Could not find gnome-open or kde-open, " +
                           "the open() command may not work.");
      }
      if (openLauncher != null) {
        params = new String[] { openLauncher };
      }



    }
    if (params != null) {

      if (params[0].equals(args[0])) {

        return exec(args);
      } else {
        params = concat(params, args);
        return exec(params);
      }
    } else {
      return exec(args);
    }
  }


  static public Process exec(String... args) {
    try {
      return Runtime.getRuntime().exec(args);
    } catch (Exception e) {
      e.printStackTrace();
      throw new RuntimeException("Could not open " + join(args, ' '));
    }
  }













  public void die(String what) {
    dispose();
    throw new RuntimeException(what);
  }



  public void die(String what, Exception e) {
    if (e != null) e.printStackTrace();
    die(what);
  }



  public void exit() {
    if (surface.isStopped()) {


      exitActual();

    } else if (looping) {

      finished = true;


      exitCalled = true;

    } else if (!looping) {


      dispose();


      exitActual();
    }
  }


  public boolean exitCalled() {
    return exitCalled;
  }



  public void exitActual() {
    try {
      System.exit(0);
    } catch (SecurityException e) {

    }
  }



  public void dispose() {

    finished = true;  


    if (surface.stopThread()) {


      if (g != null) {
        g.dispose();
      }

      handleMethods("dispose");
    }
  }







  public void method(String name) {
    try {
      Method method = getClass().getMethod(name, new Class[] {});
      method.invoke(this, new Object[] { });

    } catch (IllegalArgumentException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.getTargetException().printStackTrace();
    } catch (NoSuchMethodException nsme) {
      System.err.println("There is no public " + name + "() method " +
                         "in the class " + getClass().getName());
    } catch (Exception e) {
      e.printStackTrace();
    }
  }



  public void thread(final String name) {
    Thread later = new Thread() {
      @Override
      public void run() {
        method(name);
      }
    };
    later.start();
  }









  public void save(String filename) {
    g.save(savePath(filename));
  }



  public void saveFrame() {
    try {
      g.save(savePath("screen-" + nf(frameCount, 4) + ".tif"));
    } catch (SecurityException se) {
      System.err.println("Can't use saveFrame() when running in a browser, " +
                         "unless using a signed applet.");
    }
  }



  public void saveFrame(String filename) {
    try {
      g.save(savePath(insertFrame(filename)));
    } catch (SecurityException se) {
      System.err.println("Can't use saveFrame() when running in a browser, " +
                         "unless using a signed applet.");
    }
  }



  public String insertFrame(String what) {
    int first = what.indexOf('#');
    int last = what.lastIndexOf('#');

    if ((first != -1) && (last - first > 0)) {
      String prefix = what.substring(0, first);
      int count = last - first + 1;
      String suffix = what.substring(last + 1);
      return prefix + nf(frameCount, count) + suffix;
    }
    return what;  
  }











  public void cursor(int kind) {
    surface.setCursor(kind);
  }



  public void cursor(PImage img) {
    cursor(img, img.width/2, img.height/2);
  }



  public void cursor(PImage img, int x, int y) {
    surface.setCursor(img, x, y);
  }



  public void cursor() {
    surface.showCursor();
  }



  public void noCursor() {
    surface.hideCursor();
  }





  static public void print(byte what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(boolean what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(char what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(int what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(long what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(float what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(double what) {
    System.out.print(what);
    System.out.flush();
  }

  static public void print(String what) {
    System.out.print(what);
    System.out.flush();
  }


  static public void print(Object... variables) {
    StringBuilder sb = new StringBuilder();
    for (Object o : variables) {
      if (sb.length() != 0) {
        sb.append(" ");
      }
      if (o == null) {
        sb.append("null");
      } else {
        sb.append(o.toString());
      }
    }
    System.out.print(sb.toString());
  }






  static public void println() {
    System.out.println();
  }



  static public void println(byte what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(boolean what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(char what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(int what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(long what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(float what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(double what) {
    System.out.println(what);
    System.out.flush();
  }

  static public void println(String what) {
    System.out.println(what);
    System.out.flush();
  }


  static public void println(Object... variables) {

    print(variables);
    println();
  }






  static public void println(Object what) {
    if (what == null) {
      System.out.println("null");
    } else if (what.getClass().isArray()) {
      printArray(what);
    } else {
      System.out.println(what.toString());
      System.out.flush();
    }
  }


  static public void printArray(Object what) {
    if (what == null) {

      System.out.println("null");

    } else {
      String name = what.getClass().getName();
      if (name.charAt(0) == '[') {
        switch (name.charAt(1)) {
        case '[':


          System.out.println(what);
          break;

        case 'L':

          Object poo[] = (Object[]) what;
          for (int i = 0; i < poo.length; i++) {
            if (poo[i] instanceof String) {
              System.out.println("[" + i + "] \"" + poo[i] + "\"");
            } else {
              System.out.println("[" + i + "] " + poo[i]);
            }
          }
          break;

        case 'Z':  
          boolean zz[] = (boolean[]) what;
          for (int i = 0; i < zz.length; i++) {
            System.out.println("[" + i + "] " + zz[i]);
          }
          break;

        case 'B':  
          byte bb[] = (byte[]) what;
          for (int i = 0; i < bb.length; i++) {
            System.out.println("[" + i + "] " + bb[i]);
          }
          break;

        case 'C':  
          char cc[] = (char[]) what;
          for (int i = 0; i < cc.length; i++) {
            System.out.println("[" + i + "] '" + cc[i] + "'");
          }
          break;

        case 'I':  
          int ii[] = (int[]) what;
          for (int i = 0; i < ii.length; i++) {
            System.out.println("[" + i + "] " + ii[i]);
          }
          break;

        case 'J':  
          long jj[] = (long[]) what;
          for (int i = 0; i < jj.length; i++) {
            System.out.println("[" + i + "] " + jj[i]);
          }
          break;

        case 'F':  
          float ff[] = (float[]) what;
          for (int i = 0; i < ff.length; i++) {
            System.out.println("[" + i + "] " + ff[i]);
          }
          break;

        case 'D':  
          double dd[] = (double[]) what;
          for (int i = 0; i < dd.length; i++) {
            System.out.println("[" + i + "] " + dd[i]);
          }
          break;

        default:
          System.out.println(what);
        }
      } else {  
        System.out.println(what);
      }
    }
    System.out.flush();
  }


  static public void debug(String msg) {
    if (DEBUG) println(msg);
  }














  static public final float abs(float n) {
    return (n < 0) ? -n : n;
  }

  static public final int abs(int n) {
    return (n < 0) ? -n : n;
  }


  static public final float sq(float n) {
    return n*n;
  }


  static public final float sqrt(float n) {
    return (float)Math.sqrt(n);
  }


  static public final float log(float n) {
    return (float)Math.log(n);
  }


  static public final float exp(float n) {
    return (float)Math.exp(n);
  }


  static public final float pow(float n, float e) {
    return (float)Math.pow(n, e);
  }


  static public final int max(int a, int b) {
    return (a > b) ? a : b;
  }

  static public final float max(float a, float b) {
    return (a > b) ? a : b;
  }




  static public final int max(int a, int b, int c) {
    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
  }


  static public final float max(float a, float b, float c) {
    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
  }



  static public final int max(int[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    int max = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] > max) max = list[i];
    }
    return max;
  }

  static public final float max(float[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    float max = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] > max) max = list[i];
    }
    return max;
  }






  static public final int min(int a, int b) {
    return (a < b) ? a : b;
  }

  static public final float min(float a, float b) {
    return (a < b) ? a : b;
  }




  static public final int min(int a, int b, int c) {
    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
  }


  static public final float min(float a, float b, float c) {
    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
  }





  static public final int min(int[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    int min = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] < min) min = list[i];
    }
    return min;
  }

  static public final float min(float[] list) {
    if (list.length == 0) {
      throw new ArrayIndexOutOfBoundsException(ERROR_MIN_MAX);
    }
    float min = list[0];
    for (int i = 1; i < list.length; i++) {
      if (list[i] < min) min = list[i];
    }
    return min;
  }






  static public final int constrain(int amt, int low, int high) {
    return (amt < low) ? low : ((amt > high) ? high : amt);
  }



  static public final float constrain(float amt, float low, float high) {
    return (amt < low) ? low : ((amt > high) ? high : amt);
  }


  static public final float sin(float angle) {
    return (float)Math.sin(angle);
  }


  static public final float cos(float angle) {
    return (float)Math.cos(angle);
  }


  static public final float tan(float angle) {
    return (float)Math.tan(angle);
  }


  static public final float asin(float value) {
    return (float)Math.asin(value);
  }


  static public final float acos(float value) {
    return (float)Math.acos(value);
  }


  static public final float atan(float value) {
    return (float)Math.atan(value);
  }


  static public final float atan2(float y, float x) {
    return (float)Math.atan2(y, x);
  }


  static public final float degrees(float radians) {
    return radians * RAD_TO_DEG;
  }


  static public final float radians(float degrees) {
    return degrees * DEG_TO_RAD;
  }


  static public final int ceil(float n) {
    return (int) Math.ceil(n);
  }


  static public final int floor(float n) {
    return (int) Math.floor(n);
  }


  static public final int round(float n) {
    return Math.round(n);
  }


  static public final float mag(float a, float b) {
    return (float)Math.sqrt(a*a + b*b);
  }


  static public final float mag(float a, float b, float c) {
    return (float)Math.sqrt(a*a + b*b + c*c);
  }


  static public final float dist(float x1, float y1, float x2, float y2) {
    return sqrt(sq(x2-x1) + sq(y2-y1));
  }


  static public final float dist(float x1, float y1, float z1,
                                 float x2, float y2, float z2) {
    return sqrt(sq(x2-x1) + sq(y2-y1) + sq(z2-z1));
  }


  static public final float lerp(float start, float stop, float amt) {
    return start + (stop-start) * amt;
  }


  static public final float norm(float value, float start, float stop) {
    return (value - start) / (stop - start);
  }


  static public final float map(float value,
                                float start1, float stop1,
                                float start2, float stop2) {
    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
  }











  Random internalRandom;


  public final float random(float high) {

    if (high == 0 || high != high) {
      return 0;
    }

    if (internalRandom == null) {
      internalRandom = new Random();
    }




    float value = 0;
    do {
      value = internalRandom.nextFloat() * high;
    } while (value == high);
    return value;
  }


  public final float randomGaussian() {
    if (internalRandom == null) {
      internalRandom = new Random();
    }
    return (float) internalRandom.nextGaussian();
  }



  public final float random(float low, float high) {
    if (low >= high) return low;
    float diff = high - low;
    return random(diff) + low;
  }



  public final void randomSeed(long seed) {
    if (internalRandom == null) {
      internalRandom = new Random();
    }
    internalRandom.setSeed(seed);
  }


















  static final int PERLIN_YWRAPB = 4;
  static final int PERLIN_YWRAP = 1<<PERLIN_YWRAPB;
  static final int PERLIN_ZWRAPB = 8;
  static final int PERLIN_ZWRAP = 1<<PERLIN_ZWRAPB;
  static final int PERLIN_SIZE = 4095;

  int perlin_octaves = 4; 
  float perlin_amp_falloff = 0.5f; 



  int perlin_TWOPI, perlin_PI;
  float[] perlin_cosTable;
  float[] perlin;

  Random perlinRandom;



  public float noise(float x) {

    return noise(x, 0f, 0f);
  }


  public float noise(float x, float y) {
    return noise(x, y, 0f);
  }


  public float noise(float x, float y, float z) {
    if (perlin == null) {
      if (perlinRandom == null) {
        perlinRandom = new Random();
      }
      perlin = new float[PERLIN_SIZE + 1];
      for (int i = 0; i < PERLIN_SIZE + 1; i++) {
        perlin[i] = perlinRandom.nextFloat(); 
      }



      perlin_cosTable = PGraphics.cosLUT;
      perlin_TWOPI = perlin_PI = PGraphics.SINCOS_LENGTH;
      perlin_PI >>= 1;
    }

    if (x<0) x=-x;
    if (y<0) y=-y;
    if (z<0) z=-z;

    int xi=(int)x, yi=(int)y, zi=(int)z;
    float xf = x - xi;
    float yf = y - yi;
    float zf = z - zi;
    float rxf, ryf;

    float r=0;
    float ampl=0.5f;

    float n1,n2,n3;

    for (int i=0; i<perlin_octaves; i++) {
      int of=xi+(yi<<PERLIN_YWRAPB)+(zi<<PERLIN_ZWRAPB);

      rxf=noise_fsc(xf);
      ryf=noise_fsc(yf);

      n1  = perlin[of&PERLIN_SIZE];
      n1 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n1);
      n2  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
      n2 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n2);
      n1 += ryf*(n2-n1);

      of += PERLIN_ZWRAP;
      n2  = perlin[of&PERLIN_SIZE];
      n2 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n2);
      n3  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
      n3 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n3);
      n2 += ryf*(n3-n2);

      n1 += noise_fsc(zf)*(n2-n1);

      r += n1*ampl;
      ampl *= perlin_amp_falloff;
      xi<<=1; xf*=2;
      yi<<=1; yf*=2;
      zi<<=1; zf*=2;

      if (xf>=1.0f) { xi++; xf--; }
      if (yf>=1.0f) { yi++; yf--; }
      if (zf>=1.0f) { zi++; zf--; }
    }
    return r;
  }




  private float noise_fsc(float i) {

    return 0.5f*(1.0f-perlin_cosTable[(int)(i*perlin_PI)%perlin_TWOPI]);
  }







  public void noiseDetail(int lod) {
    if (lod>0) perlin_octaves=lod;
  }


  public void noiseDetail(int lod, float falloff) {
    if (lod>0) perlin_octaves=lod;
    if (falloff>0) perlin_amp_falloff=falloff;
  }


  public void noiseSeed(long seed) {
    if (perlinRandom == null) perlinRandom = new Random();
    perlinRandom.setSeed(seed);

    perlin = null;
  }






  protected String[] loadImageFormats;


  public PImage loadImage(String filename) {

    return loadImage(filename, null);
  }
















  public PImage loadImage(String filename, String extension) { 
    if (extension == null) {
      String lower = filename.toLowerCase();
      int dot = filename.lastIndexOf('.');
      if (dot == -1) {
        extension = "unknown";  
      }
      extension = lower.substring(dot + 1);



      int question = extension.indexOf('?');
      if (question != -1) {
        extension = extension.substring(0, question);
      }
    }


    extension = extension.toLowerCase();

    if (extension.equals("tga")) {
      try {
        PImage image = loadImageTGA(filename);



        return image;
      } catch (IOException e) {
        e.printStackTrace();
        return null;
      }
    }

    if (extension.equals("tif") || extension.equals("tiff")) {
      byte bytes[] = loadBytes(filename);
      PImage image =  (bytes == null) ? null : PImage.loadTIFF(bytes);



      return image;
    }




    try {
      if (extension.equals("jpg") || extension.equals("jpeg") ||
          extension.equals("gif") || extension.equals("png") ||
          extension.equals("unknown")) {
        byte bytes[] = loadBytes(filename);
        if (bytes == null) {
          return null;
        } else {

          Image awtImage = new ImageIcon(bytes).getImage();

          if (awtImage instanceof BufferedImage) {
            BufferedImage buffImage = (BufferedImage) awtImage;
            int space = buffImage.getColorModel().getColorSpace().getType();
            if (space == ColorSpace.TYPE_CMYK) {
              System.err.println(filename + " is a CMYK image, " +
                                 "only RGB images are supported.");
              return null;

            }
          }

          PImage image = new PImage(awtImage);
          if (image.width == -1) {
            System.err.println("The file " + filename +
                               " contains bad image data, or may not be an image.");
          }


          if (extension.equals("gif") || extension.equals("png")) {
            image.checkAlpha();
          }




          return image;
        }
      }
    } catch (Exception e) {

      e.printStackTrace();
    }

    if (loadImageFormats == null) {
      loadImageFormats = ImageIO.getReaderFormatNames();
    }
    if (loadImageFormats != null) {
      for (int i = 0; i < loadImageFormats.length; i++) {
        if (extension.equals(loadImageFormats[i])) {
          return loadImageIO(filename);





        }
      }
    }


    System.err.println("Could not find a method to load " + filename);
    return null;
  }


  public PImage requestImage(String filename) {

    return requestImage(filename, null);
  }



  public PImage requestImage(String filename, String extension) {
    PImage vessel = createImage(0, 0, ARGB);
    AsyncImageLoader ail =
      new AsyncImageLoader(filename, extension, vessel);
    ail.start();
    return vessel;
  }















  public int requestImageMax = 4;
  volatile int requestImageCount;

  class AsyncImageLoader extends Thread {
    String filename;
    String extension;
    PImage vessel;

    public AsyncImageLoader(String filename, String extension, PImage vessel) {
      this.filename = filename;
      this.extension = extension;
      this.vessel = vessel;
    }

    @Override
    public void run() {
      while (requestImageCount == requestImageMax) {
        try {
          Thread.sleep(10);
        } catch (InterruptedException e) { }
      }
      requestImageCount++;

      PImage actual = loadImage(filename, extension);


      if (actual == null) {
        vessel.width = -1;
        vessel.height = -1;

      } else {
        vessel.width = actual.width;
        vessel.height = actual.height;
        vessel.format = actual.format;
        vessel.pixels = actual.pixels;

        vessel.pixelWidth = actual.width;
        vessel.pixelHeight = actual.height;
        vessel.pixelDensity = 1;
      }
      requestImageCount--;
    }
  }























  protected PImage loadImageIO(String filename) {
    InputStream stream = createInput(filename);
    if (stream == null) {
      System.err.println("The image " + filename + " could not be found.");
      return null;
    }

    try {
      BufferedImage bi = ImageIO.read(stream);
      PImage outgoing = new PImage(bi.getWidth(), bi.getHeight());
      outgoing.parent = this;

      bi.getRGB(0, 0, outgoing.width, outgoing.height,
                outgoing.pixels, 0, outgoing.width);








      outgoing.checkAlpha();

      stream.close();

      return outgoing;

    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }



  protected PImage loadImageTGA(String filename) throws IOException {
    InputStream is = createInput(filename);
    if (is == null) return null;

    byte header[] = new byte[18];
    int offset = 0;
    do {
      int count = is.read(header, offset, header.length - offset);
      if (count == -1) return null;
      offset += count;
    } while (offset < 18);



    int format = 0;

    if (((header[2] == 3) || (header[2] == 11)) &&  
        (header[16] == 8) &&  
        ((header[17] == 0x8) || (header[17] == 0x28))) {  
      format = ALPHA;

    } else if (((header[2] == 2) || (header[2] == 10)) &&  
               (header[16] == 24) &&  
               ((header[17] == 0x20) || (header[17] == 0))) {  
      format = RGB;

    } else if (((header[2] == 2) || (header[2] == 10)) &&
               (header[16] == 32) &&
               ((header[17] == 0x8) || (header[17] == 0x28))) {  
      format = ARGB;
    }

    if (format == 0) {
      System.err.println("Unknown .tga file format for " + filename);



      return null;
    }

    int w = ((header[13] & 0xff) << 8) + (header[12] & 0xff);
    int h = ((header[15] & 0xff) << 8) + (header[14] & 0xff);
    PImage outgoing = createImage(w, h, format);





    boolean reversed = (header[17] & 0x20) == 0;

    if ((header[2] == 2) || (header[2] == 3)) {  
      if (reversed) {
        int index = (h-1) * w;
        switch (format) {
        case ALPHA:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] = is.read();
            }
            index -= w;
          }
          break;
        case RGB:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] =
                is.read() | (is.read() << 8) | (is.read() << 16) |
                0xff000000;
            }
            index -= w;
          }
          break;
        case ARGB:
          for (int y = h-1; y >= 0; y--) {
            for (int x = 0; x < w; x++) {
              outgoing.pixels[index + x] =
                is.read() | (is.read() << 8) | (is.read() << 16) |
                (is.read() << 24);
            }
            index -= w;
          }
        }
      } else {  
        int count = w * h;
        switch (format) {
        case ALPHA:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] = is.read();
          }
          break;
        case RGB:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] =
              is.read() | (is.read() << 8) | (is.read() << 16) |
              0xff000000;
          }
          break;
        case ARGB:
          for (int i = 0; i < count; i++) {
            outgoing.pixels[i] =
              is.read() | (is.read() << 8) | (is.read() << 16) |
              (is.read() << 24);
          }
          break;
        }
      }

    } else {  
      int index = 0;
      int px[] = outgoing.pixels;

      while (index < px.length) {
        int num = is.read();
        boolean isRLE = (num & 0x80) != 0;
        if (isRLE) {
          num -= 127;  
          int pixel = 0;
          switch (format) {
          case ALPHA:
            pixel = is.read();
            break;
          case RGB:
            pixel = 0xFF000000 |
              is.read() | (is.read() << 8) | (is.read() << 16);

            break;
          case ARGB:
            pixel = is.read() |
              (is.read() << 8) | (is.read() << 16) | (is.read() << 24);
            break;
          }
          for (int i = 0; i < num; i++) {
            px[index++] = pixel;
            if (index == px.length) break;
          }
        } else {  
          num += 1;
          switch (format) {
          case ALPHA:
            for (int i = 0; i < num; i++) {
              px[index++] = is.read();
            }
            break;
          case RGB:
            for (int i = 0; i < num; i++) {
              px[index++] = 0xFF000000 |
                is.read() | (is.read() << 8) | (is.read() << 16);

            }
            break;
          case ARGB:
            for (int i = 0; i < num; i++) {
              px[index++] = is.read() | 
                (is.read() << 8) | (is.read() << 16) | (is.read() << 24);

            }
            break;
          }
        }
      }

      if (!reversed) {
        int[] temp = new int[w];
        for (int y = 0; y < h/2; y++) {
          int z = (h-1) - y;
          System.arraycopy(px, y*w, temp, 0, w);
          System.arraycopy(px, z*w, px, y*w, w);
          System.arraycopy(temp, 0, px, z*w, w);
        }
      }
    }
    is.close();
    return outgoing;
  }





























  public XML loadXML(String filename) {
    return loadXML(filename, null);
  }




  public XML loadXML(String filename, String options) {
    try {
      return new XML(createReader(filename), options);



    } catch (IOException e) {
      throw new RuntimeException(e);

    } catch (ParserConfigurationException e) {
      throw new RuntimeException(e);

    } catch (SAXException e) {
      throw new RuntimeException(e);
    }
  }



  public XML parseXML(String xmlString) {
    return parseXML(xmlString, null);
  }


  public XML parseXML(String xmlString, String options) {
    try {
      return XML.parse(xmlString, options);

    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }



  public boolean saveXML(XML xml, String filename) {
    return saveXML(xml, filename, null);
  }


  public boolean saveXML(XML xml, String filename, String options) {
    return xml.save(saveFile(filename), options);
  }


  public JSONObject parseJSONObject(String input) {
    return new JSONObject(new StringReader(input));
  }



  public JSONObject loadJSONObject(String filename) {
    return new JSONObject(createReader(filename));
  }


  static public JSONObject loadJSONObject(File file) {
    return new JSONObject(createReader(file));
  }



  public boolean saveJSONObject(JSONObject json, String filename) {
    return saveJSONObject(json, filename, null);
  }


  public boolean saveJSONObject(JSONObject json, String filename, String options) {
    return json.save(saveFile(filename), options);
  }


  public JSONArray parseJSONArray(String input) {
    return new JSONArray(new StringReader(input));
  }



  public JSONArray loadJSONArray(String filename) {
    return new JSONArray(createReader(filename));
  }


  static public JSONArray loadJSONArray(File file) {
    return new JSONArray(createReader(file));
  }



  public boolean saveJSONArray(JSONArray json, String filename) {
    return saveJSONArray(json, filename, null);
  }


  public boolean saveJSONArray(JSONArray json, String filename, String options) {
    return json.save(saveFile(filename), options);
  }















  public Table loadTable(String filename) {
    return loadTable(filename, null);
  }



  public Table loadTable(String filename, String options) {
    try {
      String optionStr = Table.extensionOptions(true, filename, options);
      String[] optionList = trim(split(optionStr, ','));

      Table dictionary = null;
      for (String opt : optionList) {
        if (opt.startsWith("dictionary=")) {
          dictionary = loadTable(opt.substring(opt.indexOf('=') + 1), "tsv");
          return dictionary.typedParse(createInput(filename), optionStr);
        }
      }
      InputStream input = createInput(filename);
      if (input == null) {
        System.err.println(filename + " does not exist or could not be read");
        return null;
      }
      return new Table(input, optionStr);

    } catch (IOException e) {
      e.printStackTrace();
      return null;
    }
  }



  public boolean saveTable(Table table, String filename) {
    return saveTable(table, filename, null);
  }



  public boolean saveTable(Table table, String filename, String options) {











    try {

      File outputFile = saveFile(filename);

      return table.save(outputFile, options);

    } catch (IOException e) {
      e.printStackTrace();
      return false;
    }
  }








  public PFont loadFont(String filename) {
    if (!filename.toLowerCase().endsWith(".vlw")) {
      throw new IllegalArgumentException("loadFont() is for .vlw files, try createFont()");
    }
    try {
      InputStream input = createInput(filename);
      return new PFont(input);

    } catch (Exception e) {
      die("Could not load font " + filename + ". " +
          "Make sure that the font has been copied " +
          "to the data folder of your sketch.", e);
    }
    return null;
  }



  protected PFont createDefaultFont(float size) {




    return createFont("Lucida Sans", size, true, null);
  }


  public PFont createFont(String name, float size) {
    return createFont(name, size, true, null);
  }


  public PFont createFont(String name, float size, boolean smooth) {
    return createFont(name, size, smooth, null);
  }



  public PFont createFont(String name, float size,
                          boolean smooth, char[] charset) {
    String lowerName = name.toLowerCase();
    Font baseFont = null;

    try {
      InputStream stream = null;
      if (lowerName.endsWith(".otf") || lowerName.endsWith(".ttf")) {
        stream = createInput(name);
        if (stream == null) {
          System.err.println("The font \"" + name + "\" " +
                             "is missing or inaccessible, make sure " +
                             "the URL is valid or that the file has been " +
                             "added to your sketch and is readable.");
          return null;
        }
        baseFont = Font.createFont(Font.TRUETYPE_FONT, createInput(name));

      } else {
        baseFont = PFont.findFont(name);
      }
      return new PFont(baseFont.deriveFont(size * pixelDensity),
                       smooth, charset, stream != null,
                       pixelDensity);

    } catch (Exception e) {
      System.err.println("Problem with createFont(\"" + name + "\")");
      e.printStackTrace();
      return null;
    }
  }












  public void selectInput(String prompt, String callback) {
    selectInput(prompt, callback, null);
  }


  public void selectInput(String prompt, String callback, File file) {
    selectInput(prompt, callback, file, this);
  }


  public void selectInput(String prompt, String callback,
                          File file, Object callbackObject) {
    selectInput(prompt, callback, file, callbackObject, null);  
  }


  static public void selectInput(String prompt, String callbackMethod,
                                 File file, Object callbackObject, Frame parent) {
    selectImpl(prompt, callbackMethod, file, callbackObject, parent, FileDialog.LOAD);
  }



  public void selectOutput(String prompt, String callback) {
    selectOutput(prompt, callback, null);
  }

  public void selectOutput(String prompt, String callback, File file) {
    selectOutput(prompt, callback, file, this);
  }


  public void selectOutput(String prompt, String callback,
                           File file, Object callbackObject) {
    selectOutput(prompt, callback, file, callbackObject, null); 
  }


  static public void selectOutput(String prompt, String callbackMethod,
                                  File file, Object callbackObject, Frame parent) {
    selectImpl(prompt, callbackMethod, file, callbackObject, parent, FileDialog.SAVE);
  }


  static protected void selectImpl(final String prompt,
                                   final String callbackMethod,
                                   final File defaultSelection,
                                   final Object callbackObject,
                                   final Frame parentFrame,
                                   final int mode) {
    EventQueue.invokeLater(new Runnable() {
      public void run() {
        File selectedFile = null;

        if (useNativeSelect) {
          FileDialog dialog = new FileDialog(parentFrame, prompt, mode);
          if (defaultSelection != null) {
            dialog.setDirectory(defaultSelection.getParent());
            dialog.setFile(defaultSelection.getName());
          }
          dialog.setVisible(true);
          String directory = dialog.getDirectory();
          String filename = dialog.getFile();
          if (filename != null) {
            selectedFile = new File(directory, filename);
          }

        } else {
          JFileChooser chooser = new JFileChooser();
          chooser.setDialogTitle(prompt);
          if (defaultSelection != null) {
            chooser.setSelectedFile(defaultSelection);
          }

          int result = -1;
          if (mode == FileDialog.SAVE) {
            result = chooser.showSaveDialog(parentFrame);
          } else if (mode == FileDialog.LOAD) {
            result = chooser.showOpenDialog(parentFrame);
          }
          if (result == JFileChooser.APPROVE_OPTION) {
            selectedFile = chooser.getSelectedFile();
          }
        }
        selectCallback(selectedFile, callbackMethod, callbackObject);
      }
    });
  }



  public void selectFolder(String prompt, String callback) {
    selectFolder(prompt, callback, null);
  }


  public void selectFolder(String prompt, String callback, File file) {
    selectFolder(prompt, callback, file, this);
  }


  public void selectFolder(String prompt, String callback,
                           File file, Object callbackObject) {
    selectFolder(prompt, callback, file, callbackObject, null); 
  }


  static public void selectFolder(final String prompt,
                                  final String callbackMethod,
                                  final File defaultSelection,
                                  final Object callbackObject,
                                  final Frame parentFrame) {
    EventQueue.invokeLater(new Runnable() {
      public void run() {
        File selectedFile = null;

        if (platform == MACOSX && useNativeSelect != false) {
          FileDialog fileDialog =
            new FileDialog(parentFrame, prompt, FileDialog.LOAD);
          System.setProperty("apple.awt.fileDialogForDirectories", "true");
          fileDialog.setVisible(true);
          System.setProperty("apple.awt.fileDialogForDirectories", "false");
          String filename = fileDialog.getFile();
          if (filename != null) {
            selectedFile = new File(fileDialog.getDirectory(), fileDialog.getFile());
          }
        } else {
          JFileChooser fileChooser = new JFileChooser();
          fileChooser.setDialogTitle(prompt);
          fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
          if (defaultSelection != null) {
            fileChooser.setSelectedFile(defaultSelection);
          }

          int result = fileChooser.showOpenDialog(parentFrame);
          if (result == JFileChooser.APPROVE_OPTION) {
            selectedFile = fileChooser.getSelectedFile();
          }
        }
        selectCallback(selectedFile, callbackMethod, callbackObject);
      }
    });
  }


  static private void selectCallback(File selectedFile,
                                     String callbackMethod,
                                     Object callbackObject) {
    try {
      Class<?> callbackClass = callbackObject.getClass();
      Method selectMethod =
        callbackClass.getMethod(callbackMethod, new Class[] { File.class });
      selectMethod.invoke(callbackObject, new Object[] { selectedFile });

    } catch (IllegalAccessException iae) {
      System.err.println(callbackMethod + "() must be public");

    } catch (InvocationTargetException ite) {
      ite.printStackTrace();

    } catch (NoSuchMethodException nsme) {
      System.err.println(callbackMethod + "() could not be found");
    }
  }









  static public String checkExtension(String filename) {


    if (filename.toLowerCase().endsWith(".gz")) {
      filename = filename.substring(0, filename.length() - 3);
    }
    int dotIndex = filename.lastIndexOf('.');
    if (dotIndex != -1) {
      return filename.substring(dotIndex + 1).toLowerCase();
    }
    return null;
  }









  public BufferedReader createReader(String filename) {
    InputStream is = createInput(filename);
    if (is == null) {
      System.err.println(filename + " does not exist or could not be read");
      return null;
    }
    return createReader(is);
  }



  static public BufferedReader createReader(File file) {
    try {
      InputStream is = new FileInputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        is = new GZIPInputStream(is);
      }
      return createReader(is);

    } catch (IOException e) {

      throw new RuntimeException(e);
    }
  }



  static public BufferedReader createReader(InputStream input) {
    InputStreamReader isr = null;
    try {
      isr = new InputStreamReader(input, "UTF-8");
    } catch (UnsupportedEncodingException e) { }  
    return new BufferedReader(isr);
  }



  public PrintWriter createWriter(String filename) {
    return createWriter(saveFile(filename));
  }



  static public PrintWriter createWriter(File file) {
    if (file == null) {
      throw new RuntimeException("File passed to createWriter() was null");
    }
    try {
      createPath(file);  
      OutputStream output = new FileOutputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        output = new GZIPOutputStream(output);
      }
      return createWriter(output);

    } catch (Exception e) {
      throw new RuntimeException("Couldn't create a writer for " +
                                 file.getAbsolutePath(), e);
    }
  }


  static public PrintWriter createWriter(OutputStream output) {
    try {
      BufferedOutputStream bos = new BufferedOutputStream(output, 8192);
      OutputStreamWriter osw = new OutputStreamWriter(bos, "UTF-8");
      return new PrintWriter(osw);
    } catch (UnsupportedEncodingException e) { }  
    return null;
  }

















  public InputStream createInput(String filename) {
    InputStream input = createInputRaw(filename);
    final String lower = filename.toLowerCase();
    if ((input != null) &&
        (lower.endsWith(".gz") || lower.endsWith(".svgz"))) {
      try {
        return new GZIPInputStream(input);
      } catch (IOException e) {
        e.printStackTrace();
        return null;
      }
    }
    return input;
  }



  public InputStream createInputRaw(String filename) {
    if (filename == null) return null;

    if (filename.length() == 0) {


      return null;
    }



    if (filename.contains(":")) {  
      try {
        URL url = new URL(filename);
        URLConnection conn = url.openConnection();
        HttpURLConnection httpConn = (HttpURLConnection) conn;

        httpConn.setInstanceFollowRedirects(true);
        int response = httpConn.getResponseCode();


        if (response >= 300 && response < 400) {
          String newLocation = httpConn.getHeaderField("Location");
          return createInputRaw(newLocation);
        }
        return conn.getInputStream();

      } catch (MalformedURLException mfue) {


      } catch (FileNotFoundException fnfe) {



      } catch (IOException e) {

        e.printStackTrace();

        return null;

      }
    }

    InputStream stream = null;




    try {


      File file = new File(dataPath(filename));
      if (!file.exists()) {

        file = sketchFile(filename);
      }

      if (file.isDirectory()) {
        return null;
      }
      if (file.exists()) {
        try {

          String filePath = file.getCanonicalPath();
          String filenameActual = new File(filePath).getName();

          String filenameShort = new File(filename).getName();




          if (!filenameActual.equals(filenameShort)) {
            throw new RuntimeException("This file is named " +
                                       filenameActual + " not " +
                                       filename + ". Rename the file " +
                                       "or change your code.");
          }
        } catch (IOException e) { }
      }


      stream = new FileInputStream(file);
      if (stream != null) return stream;



    } catch (IOException ioe) {
    } catch (SecurityException se) { }





    ClassLoader cl = getClass().getClassLoader();



    stream = cl.getResourceAsStream("data/" + filename);
    if (stream != null) {
      String cn = stream.getClass().getName();




      if (!cn.equals("sun.plugin.cache.EmptyInputStream")) {
        return stream;
      }
    }




    stream = cl.getResourceAsStream(filename);
    if (stream != null) {
      String cn = stream.getClass().getName();
      if (!cn.equals("sun.plugin.cache.EmptyInputStream")) {
        return stream;
      }
    }

    try {


      try {  
        try {
          stream = new FileInputStream(dataPath(filename));
          if (stream != null) return stream;
        } catch (IOException e2) { }

        try {
          stream = new FileInputStream(sketchPath(filename));
          if (stream != null) return stream;
        } catch (Exception e) { }  

        try {
          stream = new FileInputStream(filename);
          if (stream != null) return stream;
        } catch (IOException e1) { }

      } catch (SecurityException se) { }  

    } catch (Exception e) {

      e.printStackTrace();
    }

    return null;
  }


  static public InputStream createInput(File file) {
    if (file == null) {
      throw new IllegalArgumentException("File passed to createInput() was null");
    }
    try {
      InputStream input = new FileInputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        return new GZIPInputStream(input);
      }
      return input;

    } catch (IOException e) {
      System.err.println("Could not createInput() for " + file);
      e.printStackTrace();
      return null;
    }
  }



  public byte[] loadBytes(String filename) {
    InputStream is = createInput(filename);
    if (is != null) {
      byte[] outgoing = loadBytes(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();  
      }
      return outgoing;
    }

    System.err.println("The file \"" + filename + "\" " +
                       "is missing or inaccessible, make sure " +
                       "the URL is valid or that the file has been " +
                       "added to your sketch and is readable.");
    return null;
  }


  static public byte[] loadBytes(InputStream input) {
    try {
      BufferedInputStream bis = new BufferedInputStream(input);
      ByteArrayOutputStream out = new ByteArrayOutputStream();

      int c = bis.read();
      while (c != -1) {
        out.write(c);
        c = bis.read();
      }
      return out.toByteArray();

    } catch (IOException e) {
      e.printStackTrace();

    }
    return null;
  }


  static public byte[] loadBytes(File file) {
    InputStream is = createInput(file);
    byte[] byteArr = loadBytes(is);
    try {
      is.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return byteArr;
  }


  static public String[] loadStrings(File file) {
    InputStream is = createInput(file);
    if (is != null) {
      String[] outgoing = loadStrings(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return outgoing;
    }
    return null;
  }


  public String[] loadStrings(String filename) {
    InputStream is = createInput(filename);
    if (is != null) {
      String[] strArr = loadStrings(is);
      try {
        is.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return strArr;
    }

    System.err.println("The file \"" + filename + "\" " +
                       "is missing or inaccessible, make sure " +
                       "the URL is valid or that the file has been " +
                       "added to your sketch and is readable.");
    return null;
  }


  static public String[] loadStrings(InputStream input) {
    try {
      BufferedReader reader =
        new BufferedReader(new InputStreamReader(input, "UTF-8"));
      return loadStrings(reader);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }


  static public String[] loadStrings(BufferedReader reader) {
    try {
      String lines[] = new String[100];
      int lineCount = 0;
      String line = null;
      while ((line = reader.readLine()) != null) {
        if (lineCount == lines.length) {
          String temp[] = new String[lineCount << 1];
          System.arraycopy(lines, 0, temp, 0, lineCount);
          lines = temp;
        }
        lines[lineCount++] = line;
      }
      reader.close();

      if (lineCount == lines.length) {
        return lines;
      }


      String output[] = new String[lineCount];
      System.arraycopy(lines, 0, output, 0, lineCount);
      return output;

    } catch (IOException e) {
      e.printStackTrace();

    }
    return null;
  }









  public OutputStream createOutput(String filename) {
    return createOutput(saveFile(filename));
  }


  static public OutputStream createOutput(File file) {
    try {
      createPath(file);  
      FileOutputStream fos = new FileOutputStream(file);
      if (file.getName().toLowerCase().endsWith(".gz")) {
        return new GZIPOutputStream(fos);
      }
      return fos;

    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }



  public boolean saveStream(String target, String source) {
    return saveStream(saveFile(target), source);
  }


  public boolean saveStream(File target, String source) {
    return saveStream(target, createInputRaw(source));
  }


  public boolean saveStream(String target, InputStream source) {
    return saveStream(saveFile(target), source);
  }


  static public boolean saveStream(File target, InputStream source) {
    File tempFile = null;
    try {
      File parentDir = target.getParentFile();

      createPath(target);
      tempFile = File.createTempFile(target.getName(), null, parentDir);
      FileOutputStream targetStream = new FileOutputStream(tempFile);

      saveStream(targetStream, source);
      targetStream.close();
      targetStream = null;

      if (target.exists()) {
        if (!target.delete()) {
          System.err.println("Could not replace " +
                             target.getAbsolutePath() + ".");
        }
      }
      if (!tempFile.renameTo(target)) {
        System.err.println("Could not rename temporary file " +
                           tempFile.getAbsolutePath());
        return false;
      }
      return true;

    } catch (IOException e) {
      if (tempFile != null) {
        tempFile.delete();
      }
      e.printStackTrace();
      return false;
    }
  }


  static public void saveStream(OutputStream target,
                                InputStream source) throws IOException {
    BufferedInputStream bis = new BufferedInputStream(source, 16384);
    BufferedOutputStream bos = new BufferedOutputStream(target);

    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = bis.read(buffer)) != -1) {
      bos.write(buffer, 0, bytesRead);
    }

    bos.flush();
  }



  public void saveBytes(String filename, byte[] data) {
    saveBytes(saveFile(filename), data);
  }



  static public void saveBytes(File file, byte[] data) {
    File tempFile = null;
    try {
      File parentDir = file.getParentFile();
      tempFile = File.createTempFile(file.getName(), null, parentDir);

      OutputStream output = createOutput(tempFile);
      saveBytes(output, data);
      output.close();
      output = null;

      if (file.exists()) {
        if (!file.delete()) {
          System.err.println("Could not replace " + file.getAbsolutePath());
        }
      }

      if (!tempFile.renameTo(file)) {
        System.err.println("Could not rename temporary file " +
                           tempFile.getAbsolutePath());
      }

    } catch (IOException e) {
      System.err.println("error saving bytes to " + file);
      if (tempFile != null) {
        tempFile.delete();
      }
      e.printStackTrace();
    }
  }



  static public void saveBytes(OutputStream output, byte[] data) {
    try {
      output.write(data);
      output.flush();

    } catch (IOException e) {
      e.printStackTrace();
    }
  }





  public void saveStrings(String filename, String data[]) {
    saveStrings(saveFile(filename), data);
  }



  static public void saveStrings(File file, String data[]) {
    saveStrings(createOutput(file), data);
  }



  static public void saveStrings(OutputStream output, String[] data) {
    PrintWriter writer = createWriter(output);
    for (int i = 0; i < data.length; i++) {
      writer.println(data[i]);
    }
    writer.flush();
    writer.close();
  }





  static protected String calcSketchPath() {



    String folder = null;
    try {
      folder = System.getProperty("user.dir");



      if (platform == MACOSX) {
        String jarPath =
          PApplet.class.getProtectionDomain().getCodeSource().getLocation().getPath();

        jarPath = urlDecode(jarPath);
        if (jarPath.contains("Contents/Java/")) {
          String appPath = jarPath.substring(0, jarPath.indexOf(".app") + 4);
          File containingFolder = new File(appPath).getParentFile();
          folder = containingFolder.getAbsolutePath();
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
    return folder;
  }


  public String sketchPath() {
    if (sketchPath == null) {
      sketchPath = calcSketchPath();
    }
    return sketchPath;
  }



  public String sketchPath(String where) {
    if (sketchPath() == null) {
      return where;
    }



    try {
      if (new File(where).isAbsolute()) return where;
    } catch (Exception e) { }

    return sketchPath() + File.separator + where;
  }


  public File sketchFile(String where) {
    return new File(sketchPath(where));
  }



  public String savePath(String where) {
    if (where == null) return null;
    String filename = sketchPath(where);
    createPath(filename);
    return filename;
  }



  public File saveFile(String where) {
    return new File(savePath(where));
  }


  static File desktopFolder;


  static public File desktopFile(String what) {
    if (desktopFolder == null) {

      desktopFolder = new File(System.getProperty("user.home"), "Desktop");
      if (!desktopFolder.exists()) {
        if (platform == WINDOWS) {
          FileSystemView filesys = FileSystemView.getFileSystemView();
          desktopFolder = filesys.getHomeDirectory();
        } else {
          throw new UnsupportedOperationException("Could not find a suitable desktop foldder");
        }
      }
    }
    return new File(desktopFolder, what);
  }



  static public String desktopPath(String what) {
    return desktopFile(what).getAbsolutePath();
  }



  public String dataPath(String where) {
    return dataFile(where).getAbsolutePath();
  }



  public File dataFile(String where) {


    File why = new File(where);
    if (why.isAbsolute()) return why;

    String jarPath =
      getClass().getProtectionDomain().getCodeSource().getLocation().getPath();
    if (jarPath.contains("Contents/Java/")) {


      File containingFolder = new File(urlDecode(jarPath)).getParentFile();
      File dataFolder = new File(containingFolder, "data");
      return new File(dataFolder, where);
    }

    return new File(sketchPath + File.separator + "data" + File.separator + where);
  }












  static public void createPath(String path) {
    createPath(new File(path));
  }


  static public void createPath(File file) {
    try {
      String parent = file.getParent();
      if (parent != null) {
        File unit = new File(parent);
        if (!unit.exists()) unit.mkdirs();
      }
    } catch (SecurityException se) {
      System.err.println("You don't have permissions to create " +
                         file.getAbsolutePath());
    }
  }


  static public String getExtension(String filename) {
    String extension;

    String lower = filename.toLowerCase();
    int dot = filename.lastIndexOf('.');
    if (dot == -1) {
      extension = "unknown";  
    }
    extension = lower.substring(dot + 1);



    int question = extension.indexOf('?');
    if (question != -1) {
      extension = extension.substring(0, question);
    }

    return extension;
  }







  static public String urlEncode(String str) {
    try {
      return URLEncoder.encode(str, "UTF-8");
    } catch (UnsupportedEncodingException e) {  
      return null;
    }
  }


  static public String urlDecode(String str) {
    try {
      return URLDecoder.decode(str, "UTF-8");
    } catch (UnsupportedEncodingException e) {  
      return null;
    }
  }









  static public byte[] sort(byte list[]) {
    return sort(list, list.length);
  }


  static public byte[] sort(byte[] list, int count) {
    byte[] outgoing = new byte[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public char[] sort(char list[]) {
    return sort(list, list.length);
  }

  static public char[] sort(char[] list, int count) {
    char[] outgoing = new char[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public int[] sort(int list[]) {
    return sort(list, list.length);
  }

  static public int[] sort(int[] list, int count) {
    int[] outgoing = new int[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public float[] sort(float list[]) {
    return sort(list, list.length);
  }

  static public float[] sort(float[] list, int count) {
    float[] outgoing = new float[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }

  static public String[] sort(String list[]) {
    return sort(list, list.length);
  }

  static public String[] sort(String[] list, int count) {
    String[] outgoing = new String[list.length];
    System.arraycopy(list, 0, outgoing, 0, list.length);
    Arrays.sort(outgoing, 0, count);
    return outgoing;
  }









  static public void arrayCopy(Object src, int srcPosition,
                               Object dst, int dstPosition,
                               int length) {
    System.arraycopy(src, srcPosition, dst, dstPosition, length);
  }


  static public void arrayCopy(Object src, Object dst, int length) {
    System.arraycopy(src, 0, dst, 0, length);
  }


  static public void arrayCopy(Object src, Object dst) {
    System.arraycopy(src, 0, dst, 0, Array.getLength(src));
  }



  static public void arraycopy(Object src, int srcPosition,
                               Object dst, int dstPosition,
                               int length) {
    System.arraycopy(src, srcPosition, dst, dstPosition, length);
  }


  static public void arraycopy(Object src, Object dst, int length) {
    System.arraycopy(src, 0, dst, 0, length);
  }


  static public void arraycopy(Object src, Object dst) {
    System.arraycopy(src, 0, dst, 0, Array.getLength(src));
  }


  static public boolean[] expand(boolean list[]) {
    return expand(list, list.length << 1);
  }


  static public boolean[] expand(boolean list[], int newSize) {
    boolean temp[] = new boolean[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public byte[] expand(byte list[]) {
    return expand(list, list.length << 1);
  }

  static public byte[] expand(byte list[], int newSize) {
    byte temp[] = new byte[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public char[] expand(char list[]) {
    return expand(list, list.length << 1);
  }

  static public char[] expand(char list[], int newSize) {
    char temp[] = new char[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public int[] expand(int list[]) {
    return expand(list, list.length << 1);
  }

  static public int[] expand(int list[], int newSize) {
    int temp[] = new int[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public long[] expand(long list[]) {
    return expand(list, list.length << 1);
  }

  static public long[] expand(long list[], int newSize) {
    long temp[] = new long[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public float[] expand(float list[]) {
    return expand(list, list.length << 1);
  }

  static public float[] expand(float list[], int newSize) {
    float temp[] = new float[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public double[] expand(double list[]) {
    return expand(list, list.length << 1);
  }

  static public double[] expand(double list[], int newSize) {
    double temp[] = new double[newSize];
    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }

  static public String[] expand(String list[]) {
    return expand(list, list.length << 1);
  }

  static public String[] expand(String list[], int newSize) {
    String temp[] = new String[newSize];

    System.arraycopy(list, 0, temp, 0, Math.min(newSize, list.length));
    return temp;
  }


  static public Object expand(Object array) {
    return expand(array, Array.getLength(array) << 1);
  }

  static public Object expand(Object list, int newSize) {
    Class<?> type = list.getClass().getComponentType();
    Object temp = Array.newInstance(type, newSize);
    System.arraycopy(list, 0, temp, 0,
                     Math.min(Array.getLength(list), newSize));
    return temp;
  }





  static public byte[] append(byte array[], byte value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public char[] append(char array[], char value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public int[] append(int array[], int value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public float[] append(float array[], float value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public String[] append(String array[], String value) {
    array = expand(array, array.length + 1);
    array[array.length-1] = value;
    return array;
  }

  static public Object append(Object array, Object value) {
    int length = Array.getLength(array);
    array = expand(array, length + 1);
    Array.set(array, length, value);
    return array;
  }



  static public boolean[] shorten(boolean list[]) {
    return subset(list, 0, list.length-1);
  }

  static public byte[] shorten(byte list[]) {
    return subset(list, 0, list.length-1);
  }

  static public char[] shorten(char list[]) {
    return subset(list, 0, list.length-1);
  }

  static public int[] shorten(int list[]) {
    return subset(list, 0, list.length-1);
  }

  static public float[] shorten(float list[]) {
    return subset(list, 0, list.length-1);
  }

  static public String[] shorten(String list[]) {
    return subset(list, 0, list.length-1);
  }

  static public Object shorten(Object list) {
    int length = Array.getLength(list);
    return subset(list, 0, length - 1);
  }



  static final public boolean[] splice(boolean list[],
                                       boolean value, int index) {
    boolean outgoing[] = new boolean[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public boolean[] splice(boolean list[],
                                       boolean value[], int index) {
    boolean outgoing[] = new boolean[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public byte[] splice(byte list[],
                                    byte value, int index) {
    byte outgoing[] = new byte[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public byte[] splice(byte list[],
                                    byte value[], int index) {
    byte outgoing[] = new byte[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }


  static final public char[] splice(char list[],
                                    char value, int index) {
    char outgoing[] = new char[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public char[] splice(char list[],
                                    char value[], int index) {
    char outgoing[] = new char[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public int[] splice(int list[],
                                   int value, int index) {
    int outgoing[] = new int[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public int[] splice(int list[],
                                   int value[], int index) {
    int outgoing[] = new int[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public float[] splice(float list[],
                                     float value, int index) {
    float outgoing[] = new float[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public float[] splice(float list[],
                                     float value[], int index) {
    float outgoing[] = new float[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public String[] splice(String list[],
                                      String value, int index) {
    String outgoing[] = new String[list.length + 1];
    System.arraycopy(list, 0, outgoing, 0, index);
    outgoing[index] = value;
    System.arraycopy(list, index, outgoing, index + 1,
                     list.length - index);
    return outgoing;
  }

  static final public String[] splice(String list[],
                                      String value[], int index) {
    String outgoing[] = new String[list.length + value.length];
    System.arraycopy(list, 0, outgoing, 0, index);
    System.arraycopy(value, 0, outgoing, index, value.length);
    System.arraycopy(list, index, outgoing, index + value.length,
                     list.length - index);
    return outgoing;
  }

  static final public Object splice(Object list, Object value, int index) {
    Class<?> type = list.getClass().getComponentType();
    Object outgoing = null;
    int length = Array.getLength(list);


    if (value.getClass().getName().charAt(0) == '[') {
      int vlength = Array.getLength(value);
      outgoing = Array.newInstance(type, length + vlength);
      System.arraycopy(list, 0, outgoing, 0, index);
      System.arraycopy(value, 0, outgoing, index, vlength);
      System.arraycopy(list, index, outgoing, index + vlength, length - index);

    } else {
      outgoing = Array.newInstance(type, length + 1);
      System.arraycopy(list, 0, outgoing, 0, index);
      Array.set(outgoing, index, value);
      System.arraycopy(list, index, outgoing, index + 1, length - index);
    }
    return outgoing;
  }

  static public boolean[] subset(boolean list[], int start) {
    return subset(list, start, list.length - start);
  }


  static public boolean[] subset(boolean list[], int start, int count) {
    boolean output[] = new boolean[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public byte[] subset(byte list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public byte[] subset(byte list[], int start, int count) {
    byte output[] = new byte[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public char[] subset(char list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public char[] subset(char list[], int start, int count) {
    char output[] = new char[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public int[] subset(int list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public int[] subset(int list[], int start, int count) {
    int output[] = new int[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }

  static public float[] subset(float list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public float[] subset(float list[], int start, int count) {
    float output[] = new float[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public String[] subset(String list[], int start) {
    return subset(list, start, list.length - start);
  }

  static public String[] subset(String list[], int start, int count) {
    String output[] = new String[count];
    System.arraycopy(list, start, output, 0, count);
    return output;
  }


  static public Object subset(Object list, int start) {
    int length = Array.getLength(list);
    return subset(list, start, length - start);
  }

  static public Object subset(Object list, int start, int count) {
    Class<?> type = list.getClass().getComponentType();
    Object outgoing = Array.newInstance(type, count);
    System.arraycopy(list, start, outgoing, 0, count);
    return outgoing;
  }



  static public boolean[] concat(boolean a[], boolean b[]) {
    boolean c[] = new boolean[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public byte[] concat(byte a[], byte b[]) {
    byte c[] = new byte[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public char[] concat(char a[], char b[]) {
    char c[] = new char[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public int[] concat(int a[], int b[]) {
    int c[] = new int[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public float[] concat(float a[], float b[]) {
    float c[] = new float[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public String[] concat(String a[], String b[]) {
    String c[] = new String[a.length + b.length];
    System.arraycopy(a, 0, c, 0, a.length);
    System.arraycopy(b, 0, c, a.length, b.length);
    return c;
  }

  static public Object concat(Object a, Object b) {
    Class<?> type = a.getClass().getComponentType();
    int alength = Array.getLength(a);
    int blength = Array.getLength(b);
    Object outgoing = Array.newInstance(type, alength + blength);
    System.arraycopy(a, 0, outgoing, 0, alength);
    System.arraycopy(b, 0, outgoing, alength, blength);
    return outgoing;
  }





  static public boolean[] reverse(boolean list[]) {
    boolean outgoing[] = new boolean[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public byte[] reverse(byte list[]) {
    byte outgoing[] = new byte[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public char[] reverse(char list[]) {
    char outgoing[] = new char[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public int[] reverse(int list[]) {
    int outgoing[] = new int[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public float[] reverse(float list[]) {
    float outgoing[] = new float[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public String[] reverse(String list[]) {
    String outgoing[] = new String[list.length];
    int length1 = list.length - 1;
    for (int i = 0; i < list.length; i++) {
      outgoing[i] = list[length1 - i];
    }
    return outgoing;
  }

  static public Object reverse(Object list) {
    Class<?> type = list.getClass().getComponentType();
    int length = Array.getLength(list);
    Object outgoing = Array.newInstance(type, length);
    for (int i = 0; i < length; i++) {
      Array.set(outgoing, i, Array.get(list, (length - 1) - i));
    }
    return outgoing;
  }









  static public String trim(String str) {
    return str.replace('\u00A0', ' ').trim();
  }



  static public String[] trim(String[] array) {
    String[] outgoing = new String[array.length];
    for (int i = 0; i < array.length; i++) {
      if (array[i] != null) {
        outgoing[i] = array[i].replace('\u00A0', ' ').trim();
      }
    }
    return outgoing;
  }



  static public String join(String[] list, char separator) {
    return join(list, String.valueOf(separator));
  }


  static public String join(String[] list, String separator) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < list.length; i++) {
      if (i != 0) sb.append(separator);
      sb.append(list[i]);
    }
    return sb.toString();
  }


  static public String[] splitTokens(String value) {
    return splitTokens(value, WHITESPACE);
  }



  static public String[] splitTokens(String value, String delim) {
    StringTokenizer toker = new StringTokenizer(value, delim);
    String pieces[] = new String[toker.countTokens()];

    int index = 0;
    while (toker.hasMoreTokens()) {
      pieces[index++] = toker.nextToken();
    }
    return pieces;
  }



  static public String[] split(String value, char delim) {


    if (value == null) return null;


    char chars[] = value.toCharArray();
    int splitCount = 0; 
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) splitCount++;
    }






    if (splitCount == 0) {
      String splits[] = new String[1];
      splits[0] = value;
      return splits;
    }

    String splits[] = new String[splitCount + 1];
    int splitIndex = 0;
    int startIndex = 0;
    for (int i = 0; i < chars.length; i++) {
      if (chars[i] == delim) {
        splits[splitIndex++] =
          new String(chars, startIndex, i-startIndex);
        startIndex = i + 1;
      }
    }

      splits[splitIndex] =
        new String(chars, startIndex, chars.length-startIndex);

    return splits;
  }


  static public String[] split(String value, String delim) {
    ArrayList<String> items = new ArrayList<String>();
    int index;
    int offset = 0;
    while ((index = value.indexOf(delim, offset)) != -1) {
      items.add(value.substring(offset, index));
      offset = index + delim.length();
    }
    items.add(value.substring(offset));
    String[] outgoing = new String[items.size()];
    items.toArray(outgoing);
    return outgoing;
  }


  static protected HashMap<String, Pattern> matchPatterns;

  static Pattern matchPattern(String regexp) {
    Pattern p = null;
    if (matchPatterns == null) {
      matchPatterns = new HashMap<String, Pattern>();
    } else {
      p = matchPatterns.get(regexp);
    }
    if (p == null) {
      if (matchPatterns.size() == 10) {







        matchPatterns.clear();
      }
      p = Pattern.compile(regexp, Pattern.MULTILINE | Pattern.DOTALL);
      matchPatterns.put(regexp, p);
    }
    return p;
  }



  static public String[] match(String str, String regexp) {
    Pattern p = matchPattern(regexp);
    Matcher m = p.matcher(str);
    if (m.find()) {
      int count = m.groupCount() + 1;
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      return groups;
    }
    return null;
  }



  static public String[][] matchAll(String str, String regexp) {
    Pattern p = matchPattern(regexp);
    Matcher m = p.matcher(str);
    ArrayList<String[]> results = new ArrayList<String[]>();
    int count = m.groupCount() + 1;
    while (m.find()) {
      String[] groups = new String[count];
      for (int i = 0; i < count; i++) {
        groups[i] = m.group(i);
      }
      results.add(groups);
    }
    if (results.isEmpty()) {
      return null;
    }
    String[][] matches = new String[results.size()][count];
    for (int i = 0; i < matches.length; i++) {
      matches[i] = results.get(i);
    }
    return matches;
  }












  static final public boolean parseBoolean(int what) {
    return (what != 0);
  }




  static final public boolean parseBoolean(String what) {
    return Boolean.parseBoolean(what);
  }









  static final public boolean[] parseBoolean(int what[]) {
    boolean outgoing[] = new boolean[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (what[i] != 0);
    }
    return outgoing;
  }



  static final public boolean[] parseBoolean(String what[]) {
    boolean outgoing[] = new boolean[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = Boolean.parseBoolean(what[i]);
    }
    return outgoing;
  }



  static final public byte parseByte(boolean what) {
    return what ? (byte)1 : 0;
  }

  static final public byte parseByte(char what) {
    return (byte) what;
  }

  static final public byte parseByte(int what) {
    return (byte) what;
  }

  static final public byte parseByte(float what) {
    return (byte) what;
  }





  static final public byte[] parseByte(boolean what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = what[i] ? (byte)1 : 0;
    }
    return outgoing;
  }

  static final public byte[] parseByte(char what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }

  static final public byte[] parseByte(int what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }

  static final public byte[] parseByte(float what[]) {
    byte outgoing[] = new byte[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (byte) what[i];
    }
    return outgoing;
  }







  static final public char parseChar(byte what) {
    return (char) (what & 0xff);
  }

  static final public char parseChar(int what) {
    return (char) what;
  }







  static final public char[] parseChar(byte what[]) {
    char outgoing[] = new char[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (char) (what[i] & 0xff);
    }
    return outgoing;
  }

  static final public char[] parseChar(int what[]) {
    char outgoing[] = new char[what.length];
    for (int i = 0; i < what.length; i++) {
      outgoing[i] = (char) what[i];
    }
    return outgoing;
  }





  static final public int parseInt(boolean what) {
    return what ? 1 : 0;
  }


  static final public int parseInt(byte what) {
    return what & 0xff;
  }


  static final public int parseInt(char what) {
    return what;
  }


  static final public int parseInt(float what) {
    return (int) what;
  }


  static final public int parseInt(String what) {
    return parseInt(what, 0);
  }


  static final public int parseInt(String what, int otherwise) {
    try {
      int offset = what.indexOf('.');
      if (offset == -1) {
        return Integer.parseInt(what);
      } else {
        return Integer.parseInt(what.substring(0, offset));
      }
    } catch (NumberFormatException e) { }
    return otherwise;
  }



  static final public int[] parseInt(boolean what[]) {
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = what[i] ? 1 : 0;
    }
    return list;
  }

  static final public int[] parseInt(byte what[]) {  
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = (what[i] & 0xff);
    }
    return list;
  }

  static final public int[] parseInt(char what[]) {
    int list[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      list[i] = what[i];
    }
    return list;
  }

  static public int[] parseInt(float what[]) {
    int inties[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      inties[i] = (int)what[i];
    }
    return inties;
  }


  static public int[] parseInt(String what[]) {
    return parseInt(what, 0);
  }


  static public int[] parseInt(String what[], int missing) {
    int output[] = new int[what.length];
    for (int i = 0; i < what.length; i++) {
      try {
        output[i] = Integer.parseInt(what[i]);
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }
    return output;
  }






  static final public float parseFloat(int what) {  
    return what;
  }

  static final public float parseFloat(String what) {
    return parseFloat(what, Float.NaN);
  }

  static final public float parseFloat(String what, float otherwise) {
    try {
      return new Float(what).floatValue();
    } catch (NumberFormatException e) { }

    return otherwise;
  }





  static final public float[] parseFloat(byte what[]) {
    float floaties[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      floaties[i] = what[i];
    }
    return floaties;
  }

  static final public float[] parseFloat(int what[]) {
    float floaties[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      floaties[i] = what[i];
    }
    return floaties;
  }

  static final public float[] parseFloat(String what[]) {
    return parseFloat(what, Float.NaN);
  }

  static final public float[] parseFloat(String what[], float missing) {
    float output[] = new float[what.length];
    for (int i = 0; i < what.length; i++) {
      try {
        output[i] = new Float(what[i]).floatValue();
      } catch (NumberFormatException e) {
        output[i] = missing;
      }
    }
    return output;
  }



  static final public String str(boolean x) {
    return String.valueOf(x);
  }

  static final public String str(byte x) {
    return String.valueOf(x);
  }

  static final public String str(char x) {
    return String.valueOf(x);
  }

  static final public String str(int x) {
    return String.valueOf(x);
  }

  static final public String str(float x) {
    return String.valueOf(x);
  }



  static final public String[] str(boolean x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(byte x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(char x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(int x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }

  static final public String[] str(float x[]) {
    String s[] = new String[x.length];
    for (int i = 0; i < x.length; i++) s[i] = String.valueOf(x[i]);
    return s;
  }








  static private NumberFormat int_nf;
  static private int int_nf_digits;
  static private boolean int_nf_commas;

  static public String[] nf(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], digits);
    }
    return formatted;
  }


  static public String nf(int num, int digits) {
    if ((int_nf != null) &&
        (int_nf_digits == digits) &&
        !int_nf_commas) {
      return int_nf.format(num);
    }

    int_nf = NumberFormat.getInstance();
    int_nf.setGroupingUsed(false); 
    int_nf_commas = false;
    int_nf.setMinimumIntegerDigits(digits);
    int_nf_digits = digits;
    return int_nf.format(num);
  }


  static public String[] nfc(int num[]) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfc(num[i]);
    }
    return formatted;
  }



  static public String nfc(int num) {
    if ((int_nf != null) &&
        (int_nf_digits == 0) &&
        int_nf_commas) {
      return int_nf.format(num);
    }

    int_nf = NumberFormat.getInstance();
    int_nf.setGroupingUsed(true);
    int_nf_commas = true;
    int_nf.setMinimumIntegerDigits(0);
    int_nf_digits = 0;
    return int_nf.format(num);
  }





  static public String nfs(int num, int digits) {
    return (num < 0) ? nf(num, digits) : (' ' + nf(num, digits));
  }

  static public String[] nfs(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfs(num[i], digits);
    }
    return formatted;
  }





  static public String nfp(int num, int digits) {
    return (num < 0) ? nf(num, digits) : ('+' + nf(num, digits));
  }

  static public String[] nfp(int num[], int digits) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfp(num[i], digits);
    }
    return formatted;
  }








  static private NumberFormat float_nf;
  static private int float_nf_left, float_nf_right;
  static private boolean float_nf_commas;

  static public String[] nf(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nf(num[i], left, right);
    }
    return formatted;
  }

  static public String nf(float num, int left, int right) {
    if ((float_nf != null) &&
        (float_nf_left == left) &&
        (float_nf_right == right) &&
        !float_nf_commas) {
      return float_nf.format(num);
    }

    float_nf = NumberFormat.getInstance();
    float_nf.setGroupingUsed(false);
    float_nf_commas = false;

    if (left != 0) float_nf.setMinimumIntegerDigits(left);
    if (right != 0) {
      float_nf.setMinimumFractionDigits(right);
      float_nf.setMaximumFractionDigits(right);
    }
    float_nf_left = left;
    float_nf_right = right;
    return float_nf.format(num);
  }


  static public String[] nfc(float num[], int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfc(num[i], right);
    }
    return formatted;
  }


  static public String nfc(float num, int right) {
    if ((float_nf != null) &&
        (float_nf_left == 0) &&
        (float_nf_right == right) &&
        float_nf_commas) {
      return float_nf.format(num);
    }

    float_nf = NumberFormat.getInstance();
    float_nf.setGroupingUsed(true);
    float_nf_commas = true;

    if (right != 0) {
      float_nf.setMinimumFractionDigits(right);
      float_nf.setMaximumFractionDigits(right);
    }
    float_nf_left = 0;
    float_nf_right = right;
    return float_nf.format(num);
  }



  static public String[] nfs(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfs(num[i], left, right);
    }
    return formatted;
  }

  static public String nfs(float num, int left, int right) {
    return (num < 0) ? nf(num, left, right) :  (' ' + nf(num, left, right));
  }


  static public String[] nfp(float num[], int left, int right) {
    String formatted[] = new String[num.length];
    for (int i = 0; i < formatted.length; i++) {
      formatted[i] = nfp(num[i], left, right);
    }
    return formatted;
  }

  static public String nfp(float num, int left, int right) {
    return (num < 0) ? nf(num, left, right) :  ('+' + nf(num, left, right));
  }









  static final public String hex(byte value) {
    return hex(value, 2);
  }

  static final public String hex(char value) {
    return hex(value, 4);
  }

  static final public String hex(int value) {
    return hex(value, 8);
  }

  static final public String hex(int value, int digits) {
    String stuff = Integer.toHexString(value).toUpperCase();
    if (digits > 8) {
      digits = 8;
    }

    int length = stuff.length();
    if (length > digits) {
      return stuff.substring(length - digits);

    } else if (length < digits) {
      return "00000000".substring(8 - (digits-length)) + stuff;
    }
    return stuff;
  }


  static final public int unhex(String value) {

    return (int) (Long.parseLong(value, 16));
  }




  static final public String binary(byte value) {
    return binary(value, 8);
  }


  static final public String binary(char value) {
    return binary(value, 16);
  }


  static final public String binary(int value) {
    return binary(value, 32);
  }




  static final public String binary(int value, int digits) {
    String stuff = Integer.toBinaryString(value);
    if (digits > 32) {
      digits = 32;
    }

    int length = stuff.length();
    if (length > digits) {
      return stuff.substring(length - digits);

    } else if (length < digits) {
      int offset = 32 - (digits-length);
      return "00000000000000000000000000000000".substring(offset) + stuff;
    }
    return stuff;
  }



  static final public int unbinary(String value) {
    return Integer.parseInt(value, 2);
  }












  public final int color(int gray) {
    if (g == null) {
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      return 0xff000000 | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(gray);
  }



  public final int color(float fgray) {
    if (g == null) {
      int gray = (int) fgray;
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      return 0xff000000 | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(fgray);
  }



  public final int color(int gray, int alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (gray > 255) {

        return (alpha << 24) | (gray & 0xFFFFFF);
      } else {

        return (alpha << 24) | (gray << 16) | (gray << 8) | gray;
      }
    }
    return g.color(gray, alpha);
  }



  public final int color(float fgray, float falpha) {
    if (g == null) {
      int gray = (int) fgray;
      int alpha = (int) falpha;
      if (gray > 255) gray = 255; else if (gray < 0) gray = 0;
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      return (alpha << 24) | (gray << 16) | (gray << 8) | gray;
    }
    return g.color(fgray, falpha);
  }



  public final int color(int v1, int v2, int v3) {
    if (g == null) {
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return 0xff000000 | (v1 << 16) | (v2 << 8) | v3;
    }
    return g.color(v1, v2, v3);
  }


  public final int color(int v1, int v2, int v3, int alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return (alpha << 24) | (v1 << 16) | (v2 << 8) | v3;
    }
    return g.color(v1, v2, v3, alpha);
  }


  public final int color(float v1, float v2, float v3) {
    if (g == null) {
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return 0xff000000 | ((int)v1 << 16) | ((int)v2 << 8) | (int)v3;
    }
    return g.color(v1, v2, v3);
  }


  public final int color(float v1, float v2, float v3, float alpha) {
    if (g == null) {
      if (alpha > 255) alpha = 255; else if (alpha < 0) alpha = 0;
      if (v1 > 255) v1 = 255; else if (v1 < 0) v1 = 0;
      if (v2 > 255) v2 = 255; else if (v2 < 0) v2 = 0;
      if (v3 > 255) v3 = 255; else if (v3 < 0) v3 = 0;

      return ((int)alpha << 24) | ((int)v1 << 16) | ((int)v2 << 8) | (int)v3;
    }
    return g.color(v1, v2, v3, alpha);
  }



  public int lerpColor(int c1, int c2, float amt) {
    if (g != null) {
      return g.lerpColor(c1, c2, amt);
    }

    return PGraphics.lerpColor(c1, c2, amt, RGB);
  }


  static public int blendColor(int c1, int c2, int mode) {
    return PImage.blendColor(c1, c2, mode);
  }






  void frameMoved(int x, int y) {
    if (!fullScreen) {
      System.err.println(EXTERNAL_MOVE + " " + x + " " + y);
      System.err.flush();  
    }
  }


  void frameResized(int w, int h) {

  }








  static public void main(final String[] args) {
    runSketch(args, null);
  }



  static public void main(final String mainClass) {
    main(mainClass, null);
  }



  static public void main(final String mainClass, final String[] sketchArgs) {
    String[] args = new String[] { mainClass };
    if (sketchArgs != null) {
      args = concat(args, sketchArgs);
    }
    runSketch(args, null);
  }






  static public void runSketch(final String[] args,
                               final PApplet constructedSketch) {
















    System.setProperty("sun.awt.noerasebackground", "true");


    try {

      Toolkit.getDefaultToolkit().setDynamicLayout(true);
    } catch (HeadlessException e) {
      System.err.println("Cannot run sketch without a display. Read this for possible solutions:");
      System.err.println("https://github.com/processing/processing/wiki/Running-without-a-Display");
      System.exit(1);
    }


    System.setProperty("java.net.useSystemProxies", "true");

    if (args.length < 1) {
      System.err.println("Usage: PApplet [options] <class name> [sketch args]");
      System.err.println("See the Javadoc for PApplet for an explanation.");
      System.exit(1);
    }

    boolean external = false;
    int[] location = null;
    int[] editorLocation = null;

    String name = null;
    int windowColor = 0;
    int stopColor = 0xff808080;
    boolean hideStop = false;

    int displayNum = -1;  

    boolean present = false;


    String param = null, value = null;
    String folder = calcSketchPath();

    int argIndex = 0;
    while (argIndex < args.length) {
      int equals = args[argIndex].indexOf('=');
      if (equals != -1) {
        param = args[argIndex].substring(0, equals);
        value = args[argIndex].substring(equals + 1);

        if (param.equals(ARGS_EDITOR_LOCATION)) {
          external = true;
          editorLocation = parseInt(split(value, ','));

        } else if (param.equals(ARGS_DISPLAY)) {
          displayNum = parseInt(value, -1);
          if (displayNum == -1) {
            System.err.println("Could not parse " + value + " for " + ARGS_DISPLAY);
          }

        } else if (param.equals(ARGS_WINDOW_COLOR)) {
          if (value.charAt(0) == '#' && value.length() == 7) {
            value = value.substring(1);
            windowColor = 0xff000000 | Integer.parseInt(value, 16);
          } else {
            System.err.println(ARGS_WINDOW_COLOR + " should be a # followed by six digits");
          }

        } else if (param.equals(ARGS_STOP_COLOR)) {
          if (value.charAt(0) == '#' && value.length() == 7) {
            value = value.substring(1);
            stopColor = 0xff000000 | Integer.parseInt(value, 16);
          } else {
            System.err.println(ARGS_STOP_COLOR + " should be a # followed by six digits");
          }

        } else if (param.equals(ARGS_SKETCH_FOLDER)) {
          folder = value;

        } else if (param.equals(ARGS_LOCATION)) {
          location = parseInt(split(value, ','));
        }

      } else {
        if (args[argIndex].equals(ARGS_PRESENT)) {
          present = true;




        } else if (args[argIndex].equals(ARGS_HIDE_STOP)) {
          hideStop = true;

        } else if (args[argIndex].equals(ARGS_EXTERNAL)) {
          external = true;

        } else {
          name = args[argIndex];
          break;  
        }
      }
      argIndex++;
    }












    final PApplet sketch;
    if (constructedSketch != null) {
      sketch = constructedSketch;
    } else {
      try {
        Class<?> c =
          Thread.currentThread().getContextClassLoader().loadClass(name);
        sketch = (PApplet) c.newInstance();
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }

    if (platform == MACOSX) {
      try {
        final String td = "processing.core.ThinkDifferent";
        Class<?> thinkDifferent =
          Thread.currentThread().getContextClassLoader().loadClass(td);
        Method method =
          thinkDifferent.getMethod("init", new Class[] { PApplet.class });
        method.invoke(null, new Object[] { sketch });
      } catch (Exception e) {
        e.printStackTrace();  
      }
    }



    sketch.display = displayNum;



    sketch.handleSettings();





    sketch.sketchPath = folder;
















    if (args.length != argIndex + 1) {


      sketch.args = PApplet.subset(args, argIndex + 1);
    }

    sketch.external = external;

    if (windowColor != 0) {
      sketch.windowColor = windowColor;
    }

    PSurface surface = sketch.initSurface();




    if (present) {
      if (hideStop) {
        stopColor = 0;  
      }
      surface.placePresent(stopColor);
    } else {
      surface.placeWindow(location, editorLocation);
    }

    if (external) {
      surface.setupExternalMessages();
    }
  }


  protected PSurface initSurface() {
    g = createPrimaryGraphics();
    surface = g.createSurface();


    if (g.displayable() && frame == null) {
      frame = new Frame() {
        @Override
        public void setResizable(boolean resizable) {
          deprecationWarning("setResizable");
          surface.setResizable(resizable);
        }

        @Override
        public void setVisible(boolean visible) {
          deprecationWarning("setVisible");
          surface.setVisible(visible);
        }

        @Override
        public void setTitle(String title) {
          deprecationWarning("setTitle");
          surface.setTitle(title);
        }

        private void deprecationWarning(String method) {
          PGraphics.showWarning("Use surface." + method + "() instead of " +
                                "frame." + method + " in Processing 3");
        }
      };

      surface.initFrame(this); 
      surface.setTitle(getClass().getName());

    } else {
      surface.initOffscreen(this);  
    }

    init();
    return surface;
  }






























  static public void hideMenuBar() {
    if (PApplet.platform == PConstants.MACOSX) {


      japplemenubar.JAppleMenuBar.hide();
    }
  }



  protected void runSketch(final String[] args) {
    final String[] argsWithSketchName = new String[args.length + 1];
    System.arraycopy(args, 0, argsWithSketchName, 0, args.length);
    final String className = this.getClass().getSimpleName();
    final String cleanedClass =
      className.replaceAll("__[^_]+__\\$", "").replaceAll("\\$\\d+", "");
    argsWithSketchName[args.length] = cleanedClass;
    runSketch(argsWithSketchName, this);
  }



  protected void runSketch() {
    runSketch(new String[0]);
  }






  public PGraphics beginRecord(String renderer, String filename) {
    filename = insertFrame(filename);
    PGraphics rec = createGraphics(width, height, renderer, filename);
    beginRecord(rec);
    return rec;
  }



  public void beginRecord(PGraphics recorder) {
    this.recorder = recorder;
    recorder.beginDraw();
  }



  public void endRecord() {
    if (recorder != null) {
      recorder.endDraw();
      recorder.dispose();
      recorder = null;
    }
  }



  public PGraphics beginRaw(String renderer, String filename) {
    filename = insertFrame(filename);
    PGraphics rec = createGraphics(width, height, renderer, filename);
    g.beginRaw(rec);
    return rec;
  }




  public void beginRaw(PGraphics rawGraphics) {
    g.beginRaw(rawGraphics);
  }



  public void endRaw() {
    g.endRaw();
  }









  public void loadPixels() {
    g.loadPixels();
    pixels = g.pixels;
  }


  public void updatePixels() {
    g.updatePixels();
  }


  public void updatePixels(int x1, int y1, int x2, int y2) {
    g.updatePixels(x1, y1, x2, y2);
  }











  public PGL beginPGL() {
    return g.beginPGL();
  }


  public void endPGL() {
    if (recorder != null) recorder.endPGL();
    g.endPGL();
  }


  public void flush() {
    if (recorder != null) recorder.flush();
    g.flush();
  }


  public void hint(int which) {
    if (recorder != null) recorder.hint(which);
    g.hint(which);
  }



  public void beginShape() {
    if (recorder != null) recorder.beginShape();
    g.beginShape();
  }



  public void beginShape(int kind) {
    if (recorder != null) recorder.beginShape(kind);
    g.beginShape(kind);
  }



  public void edge(boolean edge) {
    if (recorder != null) recorder.edge(edge);
    g.edge(edge);
  }



  public void normal(float nx, float ny, float nz) {
    if (recorder != null) recorder.normal(nx, ny, nz);
    g.normal(nx, ny, nz);
  }


  public void attrib(String name, float... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }


  public void attrib(String name, int... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }


  public void attrib(String name, boolean... values) {
    if (recorder != null) recorder.attrib(name, values);
    g.attrib(name, values);
  }



  public void textureMode(int mode) {
    if (recorder != null) recorder.textureMode(mode);
    g.textureMode(mode);
  }



  public void textureWrap(int wrap) {
    if (recorder != null) recorder.textureWrap(wrap);
    g.textureWrap(wrap);
  }



  public void texture(PImage image) {
    if (recorder != null) recorder.texture(image);
    g.texture(image);
  }



  public void noTexture() {
    if (recorder != null) recorder.noTexture();
    g.noTexture();
  }


  public void vertex(float x, float y) {
    if (recorder != null) recorder.vertex(x, y);
    g.vertex(x, y);
  }


  public void vertex(float x, float y, float z) {
    if (recorder != null) recorder.vertex(x, y, z);
    g.vertex(x, y, z);
  }



  public void vertex(float[] v) {
    if (recorder != null) recorder.vertex(v);
    g.vertex(v);
  }


  public void vertex(float x, float y, float u, float v) {
    if (recorder != null) recorder.vertex(x, y, u, v);
    g.vertex(x, y, u, v);
  }



  public void vertex(float x, float y, float z, float u, float v) {
    if (recorder != null) recorder.vertex(x, y, z, u, v);
    g.vertex(x, y, z, u, v);
  }



  public void beginContour() {
    if (recorder != null) recorder.beginContour();
    g.beginContour();
  }



  public void endContour() {
    if (recorder != null) recorder.endContour();
    g.endContour();
  }


  public void endShape() {
    if (recorder != null) recorder.endShape();
    g.endShape();
  }



  public void endShape(int mode) {
    if (recorder != null) recorder.endShape(mode);
    g.endShape(mode);
  }



  public PShape loadShape(String filename) {
    return g.loadShape(filename);
  }



  public PShape loadShape(String filename, String options) {
    return g.loadShape(filename, options);
  }



  public PShape createShape() {
    return g.createShape();
  }


  public PShape createShape(int type) {
    return g.createShape(type);
  }



  public PShape createShape(int kind, float... p) {
    return g.createShape(kind, p);
  }



  public PShader loadShader(String fragFilename) {
    return g.loadShader(fragFilename);
  }



  public PShader loadShader(String fragFilename, String vertFilename) {
    return g.loadShader(fragFilename, vertFilename);
  }



  public void shader(PShader shader) {
    if (recorder != null) recorder.shader(shader);
    g.shader(shader);
  }



  public void shader(PShader shader, int kind) {
    if (recorder != null) recorder.shader(shader, kind);
    g.shader(shader, kind);
  }



  public void resetShader() {
    if (recorder != null) recorder.resetShader();
    g.resetShader();
  }



  public void resetShader(int kind) {
    if (recorder != null) recorder.resetShader(kind);
    g.resetShader(kind);
  }



  public void filter(PShader shader) {
    if (recorder != null) recorder.filter(shader);
    g.filter(shader);
  }



  public void clip(float a, float b, float c, float d) {
    if (recorder != null) recorder.clip(a, b, c, d);
    g.clip(a, b, c, d);
  }



  public void noClip() {
    if (recorder != null) recorder.noClip();
    g.noClip();
  }



  public void blendMode(int mode) {
    if (recorder != null) recorder.blendMode(mode);
    g.blendMode(mode);
  }


  public void bezierVertex(float x2, float y2,
                           float x3, float y3,
                           float x4, float y4) {
    if (recorder != null) recorder.bezierVertex(x2, y2, x3, y3, x4, y4);
    g.bezierVertex(x2, y2, x3, y3, x4, y4);
  }



  public void bezierVertex(float x2, float y2, float z2,
                           float x3, float y3, float z3,
                           float x4, float y4, float z4) {
    if (recorder != null) recorder.bezierVertex(x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.bezierVertex(x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public void quadraticVertex(float cx, float cy,
                              float x3, float y3) {
    if (recorder != null) recorder.quadraticVertex(cx, cy, x3, y3);
    g.quadraticVertex(cx, cy, x3, y3);
  }



  public void quadraticVertex(float cx, float cy, float cz,
                              float x3, float y3, float z3) {
    if (recorder != null) recorder.quadraticVertex(cx, cy, cz, x3, y3, z3);
    g.quadraticVertex(cx, cy, cz, x3, y3, z3);
  }



  public void curveVertex(float x, float y) {
    if (recorder != null) recorder.curveVertex(x, y);
    g.curveVertex(x, y);
  }



  public void curveVertex(float x, float y, float z) {
    if (recorder != null) recorder.curveVertex(x, y, z);
    g.curveVertex(x, y, z);
  }



  public void point(float x, float y) {
    if (recorder != null) recorder.point(x, y);
    g.point(x, y);
  }



  public void point(float x, float y, float z) {
    if (recorder != null) recorder.point(x, y, z);
    g.point(x, y, z);
  }



  public void line(float x1, float y1, float x2, float y2) {
    if (recorder != null) recorder.line(x1, y1, x2, y2);
    g.line(x1, y1, x2, y2);
  }



  public void line(float x1, float y1, float z1,
                   float x2, float y2, float z2) {
    if (recorder != null) recorder.line(x1, y1, z1, x2, y2, z2);
    g.line(x1, y1, z1, x2, y2, z2);
  }



  public void triangle(float x1, float y1, float x2, float y2,
                       float x3, float y3) {
    if (recorder != null) recorder.triangle(x1, y1, x2, y2, x3, y3);
    g.triangle(x1, y1, x2, y2, x3, y3);
  }



  public void quad(float x1, float y1, float x2, float y2,
                   float x3, float y3, float x4, float y4) {
    if (recorder != null) recorder.quad(x1, y1, x2, y2, x3, y3, x4, y4);
    g.quad(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void rectMode(int mode) {
    if (recorder != null) recorder.rectMode(mode);
    g.rectMode(mode);
  }



  public void rect(float a, float b, float c, float d) {
    if (recorder != null) recorder.rect(a, b, c, d);
    g.rect(a, b, c, d);
  }



  public void rect(float a, float b, float c, float d, float r) {
    if (recorder != null) recorder.rect(a, b, c, d, r);
    g.rect(a, b, c, d, r);
  }



  public void rect(float a, float b, float c, float d,
                   float tl, float tr, float br, float bl) {
    if (recorder != null) recorder.rect(a, b, c, d, tl, tr, br, bl);
    g.rect(a, b, c, d, tl, tr, br, bl);
  }



  public void ellipseMode(int mode) {
    if (recorder != null) recorder.ellipseMode(mode);
    g.ellipseMode(mode);
  }



  public void ellipse(float a, float b, float c, float d) {
    if (recorder != null) recorder.ellipse(a, b, c, d);
    g.ellipse(a, b, c, d);
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop) {
    if (recorder != null) recorder.arc(a, b, c, d, start, stop);
    g.arc(a, b, c, d, start, stop);
  }



  public void arc(float a, float b, float c, float d,
                  float start, float stop, int mode) {
    if (recorder != null) recorder.arc(a, b, c, d, start, stop, mode);
    g.arc(a, b, c, d, start, stop, mode);
  }



  public void box(float size) {
    if (recorder != null) recorder.box(size);
    g.box(size);
  }



  public void box(float w, float h, float d) {
    if (recorder != null) recorder.box(w, h, d);
    g.box(w, h, d);
  }



  public void sphereDetail(int res) {
    if (recorder != null) recorder.sphereDetail(res);
    g.sphereDetail(res);
  }



  public void sphereDetail(int ures, int vres) {
    if (recorder != null) recorder.sphereDetail(ures, vres);
    g.sphereDetail(ures, vres);
  }



  public void sphere(float r) {
    if (recorder != null) recorder.sphere(r);
    g.sphere(r);
  }



  public float bezierPoint(float a, float b, float c, float d, float t) {
    return g.bezierPoint(a, b, c, d, t);
  }



  public float bezierTangent(float a, float b, float c, float d, float t) {
    return g.bezierTangent(a, b, c, d, t);
  }



  public void bezierDetail(int detail) {
    if (recorder != null) recorder.bezierDetail(detail);
    g.bezierDetail(detail);
  }


  public void bezier(float x1, float y1,
                     float x2, float y2,
                     float x3, float y3,
                     float x4, float y4) {
    if (recorder != null) recorder.bezier(x1, y1, x2, y2, x3, y3, x4, y4);
    g.bezier(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void bezier(float x1, float y1, float z1,
                     float x2, float y2, float z2,
                     float x3, float y3, float z3,
                     float x4, float y4, float z4) {
    if (recorder != null) recorder.bezier(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.bezier(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public float curvePoint(float a, float b, float c, float d, float t) {
    return g.curvePoint(a, b, c, d, t);
  }



  public float curveTangent(float a, float b, float c, float d, float t) {
    return g.curveTangent(a, b, c, d, t);
  }



  public void curveDetail(int detail) {
    if (recorder != null) recorder.curveDetail(detail);
    g.curveDetail(detail);
  }



  public void curveTightness(float tightness) {
    if (recorder != null) recorder.curveTightness(tightness);
    g.curveTightness(tightness);
  }



  public void curve(float x1, float y1,
                    float x2, float y2,
                    float x3, float y3,
                    float x4, float y4) {
    if (recorder != null) recorder.curve(x1, y1, x2, y2, x3, y3, x4, y4);
    g.curve(x1, y1, x2, y2, x3, y3, x4, y4);
  }



  public void curve(float x1, float y1, float z1,
                    float x2, float y2, float z2,
                    float x3, float y3, float z3,
                    float x4, float y4, float z4) {
    if (recorder != null) recorder.curve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
    g.curve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);
  }



  public void imageMode(int mode) {
    if (recorder != null) recorder.imageMode(mode);
    g.imageMode(mode);
  }



  public void image(PImage img, float a, float b) {
    if (recorder != null) recorder.image(img, a, b);
    g.image(img, a, b);
  }



  public void image(PImage img, float a, float b, float c, float d) {
    if (recorder != null) recorder.image(img, a, b, c, d);
    g.image(img, a, b, c, d);
  }



  public void image(PImage img,
                    float a, float b, float c, float d,
                    int u1, int v1, int u2, int v2) {
    if (recorder != null) recorder.image(img, a, b, c, d, u1, v1, u2, v2);
    g.image(img, a, b, c, d, u1, v1, u2, v2);
  }



  public void shapeMode(int mode) {
    if (recorder != null) recorder.shapeMode(mode);
    g.shapeMode(mode);
  }


  public void shape(PShape shape) {
    if (recorder != null) recorder.shape(shape);
    g.shape(shape);
  }



  public void shape(PShape shape, float x, float y) {
    if (recorder != null) recorder.shape(shape, x, y);
    g.shape(shape, x, y);
  }



  public void shape(PShape shape, float a, float b, float c, float d) {
    if (recorder != null) recorder.shape(shape, a, b, c, d);
    g.shape(shape, a, b, c, d);
  }


  public void textAlign(int alignX) {
    if (recorder != null) recorder.textAlign(alignX);
    g.textAlign(alignX);
  }



  public void textAlign(int alignX, int alignY) {
    if (recorder != null) recorder.textAlign(alignX, alignY);
    g.textAlign(alignX, alignY);
  }



  public float textAscent() {
    return g.textAscent();
  }



  public float textDescent() {
    return g.textDescent();
  }



  public void textFont(PFont which) {
    if (recorder != null) recorder.textFont(which);
    g.textFont(which);
  }



  public void textFont(PFont which, float size) {
    if (recorder != null) recorder.textFont(which, size);
    g.textFont(which, size);
  }



  public void textLeading(float leading) {
    if (recorder != null) recorder.textLeading(leading);
    g.textLeading(leading);
  }



  public void textMode(int mode) {
    if (recorder != null) recorder.textMode(mode);
    g.textMode(mode);
  }



  public void textSize(float size) {
    if (recorder != null) recorder.textSize(size);
    g.textSize(size);
  }



  public float textWidth(char c) {
    return g.textWidth(c);
  }



  public float textWidth(String str) {
    return g.textWidth(str);
  }



  public float textWidth(char[] chars, int start, int length) {
    return g.textWidth(chars, start, length);
  }



  public void text(char c, float x, float y) {
    if (recorder != null) recorder.text(c, x, y);
    g.text(c, x, y);
  }



  public void text(char c, float x, float y, float z) {
    if (recorder != null) recorder.text(c, x, y, z);
    g.text(c, x, y, z);
  }



  public void text(String str, float x, float y) {
    if (recorder != null) recorder.text(str, x, y);
    g.text(str, x, y);
  }



  public void text(char[] chars, int start, int stop, float x, float y) {
    if (recorder != null) recorder.text(chars, start, stop, x, y);
    g.text(chars, start, stop, x, y);
  }



  public void text(String str, float x, float y, float z) {
    if (recorder != null) recorder.text(str, x, y, z);
    g.text(str, x, y, z);
  }


  public void text(char[] chars, int start, int stop,
                   float x, float y, float z) {
    if (recorder != null) recorder.text(chars, start, stop, x, y, z);
    g.text(chars, start, stop, x, y, z);
  }



  public void text(String str, float x1, float y1, float x2, float y2) {
    if (recorder != null) recorder.text(str, x1, y1, x2, y2);
    g.text(str, x1, y1, x2, y2);
  }


  public void text(int num, float x, float y) {
    if (recorder != null) recorder.text(num, x, y);
    g.text(num, x, y);
  }


  public void text(int num, float x, float y, float z) {
    if (recorder != null) recorder.text(num, x, y, z);
    g.text(num, x, y, z);
  }



  public void text(float num, float x, float y) {
    if (recorder != null) recorder.text(num, x, y);
    g.text(num, x, y);
  }


  public void text(float num, float x, float y, float z) {
    if (recorder != null) recorder.text(num, x, y, z);
    g.text(num, x, y, z);
  }



  public void pushMatrix() {
    if (recorder != null) recorder.pushMatrix();
    g.pushMatrix();
  }



  public void popMatrix() {
    if (recorder != null) recorder.popMatrix();
    g.popMatrix();
  }



  public void translate(float x, float y) {
    if (recorder != null) recorder.translate(x, y);
    g.translate(x, y);
  }



  public void translate(float x, float y, float z) {
    if (recorder != null) recorder.translate(x, y, z);
    g.translate(x, y, z);
  }



  public void rotate(float angle) {
    if (recorder != null) recorder.rotate(angle);
    g.rotate(angle);
  }



  public void rotateX(float angle) {
    if (recorder != null) recorder.rotateX(angle);
    g.rotateX(angle);
  }



  public void rotateY(float angle) {
    if (recorder != null) recorder.rotateY(angle);
    g.rotateY(angle);
  }



  public void rotateZ(float angle) {
    if (recorder != null) recorder.rotateZ(angle);
    g.rotateZ(angle);
  }



  public void rotate(float angle, float x, float y, float z) {
    if (recorder != null) recorder.rotate(angle, x, y, z);
    g.rotate(angle, x, y, z);
  }



  public void scale(float s) {
    if (recorder != null) recorder.scale(s);
    g.scale(s);
  }



  public void scale(float x, float y) {
    if (recorder != null) recorder.scale(x, y);
    g.scale(x, y);
  }



  public void scale(float x, float y, float z) {
    if (recorder != null) recorder.scale(x, y, z);
    g.scale(x, y, z);
  }



  public void shearX(float angle) {
    if (recorder != null) recorder.shearX(angle);
    g.shearX(angle);
  }



  public void shearY(float angle) {
    if (recorder != null) recorder.shearY(angle);
    g.shearY(angle);
  }



  public void resetMatrix() {
    if (recorder != null) recorder.resetMatrix();
    g.resetMatrix();
  }



  public void applyMatrix(PMatrix source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }


  public void applyMatrix(PMatrix2D source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }



  public void applyMatrix(float n00, float n01, float n02,
                          float n10, float n11, float n12) {
    if (recorder != null) recorder.applyMatrix(n00, n01, n02, n10, n11, n12);
    g.applyMatrix(n00, n01, n02, n10, n11, n12);
  }


  public void applyMatrix(PMatrix3D source) {
    if (recorder != null) recorder.applyMatrix(source);
    g.applyMatrix(source);
  }



  public void applyMatrix(float n00, float n01, float n02, float n03,
                          float n10, float n11, float n12, float n13,
                          float n20, float n21, float n22, float n23,
                          float n30, float n31, float n32, float n33) {
    if (recorder != null) recorder.applyMatrix(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33);
    g.applyMatrix(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33);
  }


  public PMatrix getMatrix() {
    return g.getMatrix();
  }



  public PMatrix2D getMatrix(PMatrix2D target) {
    return g.getMatrix(target);
  }



  public PMatrix3D getMatrix(PMatrix3D target) {
    return g.getMatrix(target);
  }



  public void setMatrix(PMatrix source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void setMatrix(PMatrix2D source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void setMatrix(PMatrix3D source) {
    if (recorder != null) recorder.setMatrix(source);
    g.setMatrix(source);
  }



  public void printMatrix() {
    if (recorder != null) recorder.printMatrix();
    g.printMatrix();
  }



  public void beginCamera() {
    if (recorder != null) recorder.beginCamera();
    g.beginCamera();
  }



  public void endCamera() {
    if (recorder != null) recorder.endCamera();
    g.endCamera();
  }



  public void camera() {
    if (recorder != null) recorder.camera();
    g.camera();
  }



  public void camera(float eyeX, float eyeY, float eyeZ,
                     float centerX, float centerY, float centerZ,
                     float upX, float upY, float upZ) {
    if (recorder != null) recorder.camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
    g.camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
  }



  public void printCamera() {
    if (recorder != null) recorder.printCamera();
    g.printCamera();
  }



  public void ortho() {
    if (recorder != null) recorder.ortho();
    g.ortho();
  }



  public void ortho(float left, float right,
                    float bottom, float top) {
    if (recorder != null) recorder.ortho(left, right, bottom, top);
    g.ortho(left, right, bottom, top);
  }



  public void ortho(float left, float right,
                    float bottom, float top,
                    float near, float far) {
    if (recorder != null) recorder.ortho(left, right, bottom, top, near, far);
    g.ortho(left, right, bottom, top, near, far);
  }



  public void perspective() {
    if (recorder != null) recorder.perspective();
    g.perspective();
  }



  public void perspective(float fovy, float aspect, float zNear, float zFar) {
    if (recorder != null) recorder.perspective(fovy, aspect, zNear, zFar);
    g.perspective(fovy, aspect, zNear, zFar);
  }



  public void frustum(float left, float right,
                      float bottom, float top,
                      float near, float far) {
    if (recorder != null) recorder.frustum(left, right, bottom, top, near, far);
    g.frustum(left, right, bottom, top, near, far);
  }



  public void printProjection() {
    if (recorder != null) recorder.printProjection();
    g.printProjection();
  }



  public float screenX(float x, float y) {
    return g.screenX(x, y);
  }



  public float screenY(float x, float y) {
    return g.screenY(x, y);
  }



  public float screenX(float x, float y, float z) {
    return g.screenX(x, y, z);
  }



  public float screenY(float x, float y, float z) {
    return g.screenY(x, y, z);
  }



  public float screenZ(float x, float y, float z) {
    return g.screenZ(x, y, z);
  }



  public float modelX(float x, float y, float z) {
    return g.modelX(x, y, z);
  }



  public float modelY(float x, float y, float z) {
    return g.modelY(x, y, z);
  }



  public float modelZ(float x, float y, float z) {
    return g.modelZ(x, y, z);
  }



  public void pushStyle() {
    if (recorder != null) recorder.pushStyle();
    g.pushStyle();
  }



  public void popStyle() {
    if (recorder != null) recorder.popStyle();
    g.popStyle();
  }


  public void style(PStyle s) {
    if (recorder != null) recorder.style(s);
    g.style(s);
  }



  public void strokeWeight(float weight) {
    if (recorder != null) recorder.strokeWeight(weight);
    g.strokeWeight(weight);
  }



  public void strokeJoin(int join) {
    if (recorder != null) recorder.strokeJoin(join);
    g.strokeJoin(join);
  }



  public void strokeCap(int cap) {
    if (recorder != null) recorder.strokeCap(cap);
    g.strokeCap(cap);
  }



  public void noStroke() {
    if (recorder != null) recorder.noStroke();
    g.noStroke();
  }



  public void stroke(int rgb) {
    if (recorder != null) recorder.stroke(rgb);
    g.stroke(rgb);
  }



  public void stroke(int rgb, float alpha) {
    if (recorder != null) recorder.stroke(rgb, alpha);
    g.stroke(rgb, alpha);
  }



  public void stroke(float gray) {
    if (recorder != null) recorder.stroke(gray);
    g.stroke(gray);
  }


  public void stroke(float gray, float alpha) {
    if (recorder != null) recorder.stroke(gray, alpha);
    g.stroke(gray, alpha);
  }



  public void stroke(float v1, float v2, float v3) {
    if (recorder != null) recorder.stroke(v1, v2, v3);
    g.stroke(v1, v2, v3);
  }


  public void stroke(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.stroke(v1, v2, v3, alpha);
    g.stroke(v1, v2, v3, alpha);
  }



  public void noTint() {
    if (recorder != null) recorder.noTint();
    g.noTint();
  }



  public void tint(int rgb) {
    if (recorder != null) recorder.tint(rgb);
    g.tint(rgb);
  }



  public void tint(int rgb, float alpha) {
    if (recorder != null) recorder.tint(rgb, alpha);
    g.tint(rgb, alpha);
  }



  public void tint(float gray) {
    if (recorder != null) recorder.tint(gray);
    g.tint(gray);
  }


  public void tint(float gray, float alpha) {
    if (recorder != null) recorder.tint(gray, alpha);
    g.tint(gray, alpha);
  }



  public void tint(float v1, float v2, float v3) {
    if (recorder != null) recorder.tint(v1, v2, v3);
    g.tint(v1, v2, v3);
  }


  public void tint(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.tint(v1, v2, v3, alpha);
    g.tint(v1, v2, v3, alpha);
  }



  public void noFill() {
    if (recorder != null) recorder.noFill();
    g.noFill();
  }



  public void fill(int rgb) {
    if (recorder != null) recorder.fill(rgb);
    g.fill(rgb);
  }



  public void fill(int rgb, float alpha) {
    if (recorder != null) recorder.fill(rgb, alpha);
    g.fill(rgb, alpha);
  }



  public void fill(float gray) {
    if (recorder != null) recorder.fill(gray);
    g.fill(gray);
  }


  public void fill(float gray, float alpha) {
    if (recorder != null) recorder.fill(gray, alpha);
    g.fill(gray, alpha);
  }



  public void fill(float v1, float v2, float v3) {
    if (recorder != null) recorder.fill(v1, v2, v3);
    g.fill(v1, v2, v3);
  }


  public void fill(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.fill(v1, v2, v3, alpha);
    g.fill(v1, v2, v3, alpha);
  }



  public void ambient(int rgb) {
    if (recorder != null) recorder.ambient(rgb);
    g.ambient(rgb);
  }



  public void ambient(float gray) {
    if (recorder != null) recorder.ambient(gray);
    g.ambient(gray);
  }



  public void ambient(float v1, float v2, float v3) {
    if (recorder != null) recorder.ambient(v1, v2, v3);
    g.ambient(v1, v2, v3);
  }



  public void specular(int rgb) {
    if (recorder != null) recorder.specular(rgb);
    g.specular(rgb);
  }



  public void specular(float gray) {
    if (recorder != null) recorder.specular(gray);
    g.specular(gray);
  }



  public void specular(float v1, float v2, float v3) {
    if (recorder != null) recorder.specular(v1, v2, v3);
    g.specular(v1, v2, v3);
  }



  public void shininess(float shine) {
    if (recorder != null) recorder.shininess(shine);
    g.shininess(shine);
  }



  public void emissive(int rgb) {
    if (recorder != null) recorder.emissive(rgb);
    g.emissive(rgb);
  }



  public void emissive(float gray) {
    if (recorder != null) recorder.emissive(gray);
    g.emissive(gray);
  }



  public void emissive(float v1, float v2, float v3) {
    if (recorder != null) recorder.emissive(v1, v2, v3);
    g.emissive(v1, v2, v3);
  }



  public void lights() {
    if (recorder != null) recorder.lights();
    g.lights();
  }



  public void noLights() {
    if (recorder != null) recorder.noLights();
    g.noLights();
  }



  public void ambientLight(float v1, float v2, float v3) {
    if (recorder != null) recorder.ambientLight(v1, v2, v3);
    g.ambientLight(v1, v2, v3);
  }



  public void ambientLight(float v1, float v2, float v3,
                           float x, float y, float z) {
    if (recorder != null) recorder.ambientLight(v1, v2, v3, x, y, z);
    g.ambientLight(v1, v2, v3, x, y, z);
  }



  public void directionalLight(float v1, float v2, float v3,
                               float nx, float ny, float nz) {
    if (recorder != null) recorder.directionalLight(v1, v2, v3, nx, ny, nz);
    g.directionalLight(v1, v2, v3, nx, ny, nz);
  }



  public void pointLight(float v1, float v2, float v3,
                         float x, float y, float z) {
    if (recorder != null) recorder.pointLight(v1, v2, v3, x, y, z);
    g.pointLight(v1, v2, v3, x, y, z);
  }



  public void spotLight(float v1, float v2, float v3,
                        float x, float y, float z,
                        float nx, float ny, float nz,
                        float angle, float concentration) {
    if (recorder != null) recorder.spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration);
    g.spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration);
  }



  public void lightFalloff(float constant, float linear, float quadratic) {
    if (recorder != null) recorder.lightFalloff(constant, linear, quadratic);
    g.lightFalloff(constant, linear, quadratic);
  }



  public void lightSpecular(float v1, float v2, float v3) {
    if (recorder != null) recorder.lightSpecular(v1, v2, v3);
    g.lightSpecular(v1, v2, v3);
  }



  public void background(int rgb) {
    if (recorder != null) recorder.background(rgb);
    g.background(rgb);
  }



  public void background(int rgb, float alpha) {
    if (recorder != null) recorder.background(rgb, alpha);
    g.background(rgb, alpha);
  }



  public void background(float gray) {
    if (recorder != null) recorder.background(gray);
    g.background(gray);
  }


  public void background(float gray, float alpha) {
    if (recorder != null) recorder.background(gray, alpha);
    g.background(gray, alpha);
  }



  public void background(float v1, float v2, float v3) {
    if (recorder != null) recorder.background(v1, v2, v3);
    g.background(v1, v2, v3);
  }


  public void background(float v1, float v2, float v3, float alpha) {
    if (recorder != null) recorder.background(v1, v2, v3, alpha);
    g.background(v1, v2, v3, alpha);
  }



  public void clear() {
    if (recorder != null) recorder.clear();
    g.clear();
  }



  public void background(PImage image) {
    if (recorder != null) recorder.background(image);
    g.background(image);
  }



  public void colorMode(int mode) {
    if (recorder != null) recorder.colorMode(mode);
    g.colorMode(mode);
  }



  public void colorMode(int mode, float max) {
    if (recorder != null) recorder.colorMode(mode, max);
    g.colorMode(mode, max);
  }



  public void colorMode(int mode, float max1, float max2, float max3) {
    if (recorder != null) recorder.colorMode(mode, max1, max2, max3);
    g.colorMode(mode, max1, max2, max3);
  }



  public void colorMode(int mode,
                        float max1, float max2, float max3, float maxA) {
    if (recorder != null) recorder.colorMode(mode, max1, max2, max3, maxA);
    g.colorMode(mode, max1, max2, max3, maxA);
  }



  public final float alpha(int rgb) {
    return g.alpha(rgb);
  }



  public final float red(int rgb) {
    return g.red(rgb);
  }



  public final float green(int rgb) {
    return g.green(rgb);
  }



  public final float blue(int rgb) {
    return g.blue(rgb);
  }



  public final float hue(int rgb) {
    return g.hue(rgb);
  }



  public final float saturation(int rgb) {
    return g.saturation(rgb);
  }



  public final float brightness(int rgb) {
    return g.brightness(rgb);
  }



  static public int lerpColor(int c1, int c2, float amt, int mode) {
    return PGraphics.lerpColor(c1, c2, amt, mode);
  }



  static public void showDepthWarning(String method) {
    PGraphics.showDepthWarning(method);
  }



  static public void showDepthWarningXYZ(String method) {
    PGraphics.showDepthWarningXYZ(method);
  }



  static public void showMethodWarning(String method) {
    PGraphics.showMethodWarning(method);
  }



  static public void showVariationWarning(String str) {
    PGraphics.showVariationWarning(str);
  }



  static public void showMissingWarning(String method) {
    PGraphics.showMissingWarning(method);
  }



  public int get(int x, int y) {
    return g.get(x, y);
  }



  public PImage get(int x, int y, int w, int h) {
    return g.get(x, y, w, h);
  }



  public PImage get() {
    return g.get();
  }


  public PImage copy() {
    return g.copy();
  }



  public void set(int x, int y, int c) {
    if (recorder != null) recorder.set(x, y, c);
    g.set(x, y, c);
  }



  public void set(int x, int y, PImage img) {
    if (recorder != null) recorder.set(x, y, img);
    g.set(x, y, img);
  }



  public void mask(PImage img) {
    if (recorder != null) recorder.mask(img);
    g.mask(img);
  }


  public void filter(int kind) {
    if (recorder != null) recorder.filter(kind);
    g.filter(kind);
  }



  public void filter(int kind, float param) {
    if (recorder != null) recorder.filter(kind, param);
    g.filter(kind, param);
  }



  public void copy(int sx, int sy, int sw, int sh,
                   int dx, int dy, int dw, int dh) {
    if (recorder != null) recorder.copy(sx, sy, sw, sh, dx, dy, dw, dh);
    g.copy(sx, sy, sw, sh, dx, dy, dw, dh);
  }



  public void copy(PImage src,
                   int sx, int sy, int sw, int sh,
                   int dx, int dy, int dw, int dh) {
    if (recorder != null) recorder.copy(src, sx, sy, sw, sh, dx, dy, dw, dh);
    g.copy(src, sx, sy, sw, sh, dx, dy, dw, dh);
  }


  public void blend(int sx, int sy, int sw, int sh,
                    int dx, int dy, int dw, int dh, int mode) {
    if (recorder != null) recorder.blend(sx, sy, sw, sh, dx, dy, dw, dh, mode);
    g.blend(sx, sy, sw, sh, dx, dy, dw, dh, mode);
  }



  public void blend(PImage src,
                    int sx, int sy, int sw, int sh,
                    int dx, int dy, int dw, int dh, int mode) {
    if (recorder != null) recorder.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, mode);
    g.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, mode);
  }
}
