
package com.squareup.wire;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.DataType.ScalarType;
import com.squareup.protoparser.EnumElement;
import com.squareup.protoparser.ExtendElement;
import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.MessageElement;
import com.squareup.protoparser.OneOfElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.RpcElement;
import com.squareup.protoparser.ServiceElement;
import com.squareup.protoparser.TypeElement;
import com.squareup.wire.java.JavaGenerator;
import com.squareup.wire.java.TypeWriter;
import com.squareup.wire.model.Linker;
import com.squareup.wire.model.Loader;
import com.squareup.wire.model.Pruner;
import com.squareup.wire.model.WireProtoFile;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import okio.ByteString;

import static com.squareup.wire.Message.Datatype;
import static com.squareup.wire.Message.Label;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;


public class WireCompiler {
  static final boolean JAVAPOET = false;
  static final String LINE_WRAP_INDENT = "    ";

  
  static final Set<String> DEFAULT_FIELD_OPTION_KEYS =
      new LinkedHashSet<String>(Arrays.asList("default", "deprecated", "packed"));

  private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
  private static final String CODE_GENERATED_BY_WIRE =
      "Code generated by Wire protocol buffer compiler, do not edit.";

  private final String repoPath;
  private final IO io;
  private final Set<String> typesToEmit = new LinkedHashSet<String>();
  private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
  private final Set<String> javaSymbols = new LinkedHashSet<String>();
  private final Set<String> enumTypes = new LinkedHashSet<String>();
  private final Map<String, String> enumDefaults = new LinkedHashMap<String, String>();
  private final Map<String, ExtensionInfo> extensionInfo =
      new LinkedHashMap<String, ExtensionInfo>();
  private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();

  private final List<String> extensionClasses = new ArrayList<String>();
  private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);
  private final CommandLineOptions options;

  private final WireLogger log;

  private ProtoFile protoFile;
  private String sourceFileName;
  private String protoFileName;
  private String typeBeingGenerated = "";

  private Constructor<?> serviceWriterConstructor;

  
  public static void main(String... args) {
    try {
      new WireCompiler(new CommandLineOptions(args)).compile();
    } catch (WireException e) {
      System.err.print("Fatal: ");
      e.printStackTrace(System.err);
      System.exit(1);
    }
  }

  private static Constructor<?> loadServiceWriter(String serviceWriterClassName)
      throws WireException {
    Class<?> serviceWriterClass;
    try {
      serviceWriterClass = Class.forName(serviceWriterClassName);
    } catch (ClassNotFoundException e) {
      throw new WireException("Unable to load ServiceWriter class "
          + serviceWriterClassName + ".", e);
    }

    if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
      throw new WireException(
          "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
    }

    try {
      return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
    } catch (NoSuchMethodException e) {
      throw new WireException("ServiceWriter class "
          + serviceWriterClassName
          + " needs a constructor 'public "
          + serviceWriterClassName
          + "(JavaWriter writer, List<String> options)'.", e);
    }
  }

  @Deprecated
  public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions)
      throws WireException {
    this(new CommandLineOptions(protoPath, outputDirectory, sourceFileNames, roots, registryClass,
        emitOptions, new LinkedHashSet<String>(enumOptions),
        serviceWriterConstructor == null ? null : serviceWriterConstructor.getName(),
        serviceWriterOptions, false, false));
  }

  WireCompiler(CommandLineOptions options) throws WireException {
    this(options, new IO.FileIO(), new ConsoleWireLogger(options.quiet));
  }

  WireCompiler(CommandLineOptions options, IO io, WireLogger logger) throws WireException {
    this.options = options;
    this.io = io;
    this.log = logger;

    String protoPath = options.protoPath;
    if (options.javaOut == null) {
      throw new WireException("Must specify " + CommandLineOptions.JAVA_OUT_FLAG + " flag");
    }
    if (options.protoPath == null) {
      protoPath = System.getProperty("user.dir");
      System.err.println(
          CommandLineOptions.PROTO_PATH_FLAG + " flag not specified, using current dir "
              + protoPath);
    }
    if (options.serviceWriter != null) {
      serviceWriterConstructor =
          WireCompiler.loadServiceWriter(options.serviceWriter);
    }
    this.repoPath = protoPath;
    this.typesToEmit.addAll(options.roots);
  }

  public void compile() throws WireException {
    if (JAVAPOET) {
      compileWithJavaPoet();
      return;
    }

    Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();

    for (String sourceFilename : options.sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      try {
        ProtoFile protoFile = io.parse(sourcePath);
        parsedFiles.put(sourcePath, protoFile);
        loadSymbols(protoFile);
      } catch (IOException e) {
        throw new WireException("Error loading symbols for " + sourcePath, e);
      }
    }

    if (!typesToEmit.isEmpty()) {
      log.info("Analyzing dependencies of root types.");
      findDependencies(parsedFiles.values());
    }

    for (Map.Entry<String, ProtoFile> entry : parsedFiles.entrySet()) {
      this.sourceFileName = entry.getKey();
      this.protoFile = entry.getValue();
      this.protoFileName = protoFileName(protoFile.filePath());
      log.info("Compiling proto source file " + sourceFileName);
      try {
        compileOne();
      } catch (IOException e) {
        throw new WireException("Error compiling " + entry.getKey(), e);
      }
    }

    if (options.registryClass != null) {
      int packageClassSep = options.registryClass.lastIndexOf(".");
      String javaPackage = options.registryClass.substring(0, packageClassSep);
      String className = options.registryClass.substring(packageClassSep + 1);
      OutputArtifact artifact = new OutputArtifact(options.javaOut, javaPackage, className);
      log.artifact(artifact);
      if (!options.dryRun) {
        try {
          emitRegistry(artifact);
        } catch (IOException e) {
          throw new WireException("Error emitting registry class " + options.registryClass, e);
        }
      }
    }
  }

  boolean shouldEmitOptions() {
    return options.emitOptions;
  }

  Set<String> enumOptions() {
    return options.enumOptions;
  }

  ProtoFile getProtoFile() {
    return protoFile;
  }

  OptionsMapMaker getOptionsMapMaker() {
    return optionsMapMaker;
  }

  String getEnumDefault(String fullyQualifiedName) {
    return enumDefaults.get(fullyQualifiedName);
  }

  FieldInfo getField(String dollarName) {
    return fieldMap.get(dollarName);
  }

  String javaName(ProtoFile protoFile, MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(protoFile, javaName(fullyQualifiedName(protoFile, messageType, type)));
  }

  boolean fullyQualifiedNameIsOutsidePackage(String fqName) {
    return fqName != null && !getJavaPackage().equals(getPackageFromFullyQualifiedJavaName(fqName));
  }

  String prefixWithPackageName(String name) {
    return prefixWithPackageName(protoFile, name);
  }

  boolean hasFields(TypeElement type) {
    return type instanceof MessageElement && !allFields((MessageElement) type).isEmpty();
  }

  boolean hasExtensions(MessageElement messageType) {
    return !messageType.extensions().isEmpty();
  }

  String getTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(index + 1);
  }

  ExtensionInfo getExtension(String name) {
    return extensionInfo.get(name);
  }

  String getInitializerForType(Object initialValue, String javaTypeName) {
    if ("Boolean".equals(javaTypeName)) {
      return initialValue == null ? "false" : String.valueOf(initialValue);
    } else if ("Integer".equals(javaTypeName)) {
      return initialValue == null ? "0" : toInt(String.valueOf(initialValue));
    } else if ("Long".equals(javaTypeName)) {
      return initialValue == null ? "0L" : toLong(String.valueOf(initialValue));
    } else if ("Float".equals(javaTypeName)) {
      return initialValue == null ? "0F" : String.valueOf(initialValue) + "F";
    } else if ("Double".equals(javaTypeName)) {
      return initialValue == null ? "0D" : String.valueOf(initialValue) + "D";
    } else if ("String".equals(javaTypeName)) {
      return quoteString((String) initialValue);
    } else if ("ByteString".equals(javaTypeName)) {
      if (initialValue == null) {
        return "ByteString.EMPTY";
      } else {
        return "ByteString.decodeBase64(\"" + ByteString.of(
            String.valueOf(initialValue).getBytes(ISO_8859_1)).base64() + "\")";
      }
    } else {
      throw new WireCompilerException(javaTypeName + " is not an allowed scalar type");
    }
  }

  
  boolean isEnum(String type) {
    return enumTypes.contains(type);
  }

  String javaName(MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(javaName(fullyQualifiedName(messageType, type)));
  }

  String javaName(String fqName) {
    return javaSymbolMap.get(fqName);
  }

  String fullyQualifiedName(TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String fullyQualifiedName(String fqName, String type) {
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String shortenJavaName(String fullyQualifiedName) {
    return shortenJavaName(protoFile, fullyQualifiedName);
  }

  boolean isRedacted(OptionElement option) {
    return option.name().endsWith(".redacted") && "true".equals(String.valueOf(option.value()));
  }

  private void compileOne() throws IOException {
    typeBeingGenerated = "";

    if (hasExtends()) {
      OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
          "Ext_" + protoFileName);
      log.artifact(artifact);

      if (!options.dryRun) {
        emitExtensionClass(artifact);
        extensionClasses.add(artifact.fullClassName());
      }
    }

    for (TypeElement type : protoFile.typeElements()) {
      if (shouldEmitType(type.qualifiedName())) {
        String savedType = typeBeingGenerated;
        typeBeingGenerated += type.name() + ".";
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            type.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitMessageClass(type, artifact);
        }
        typeBeingGenerated = savedType;
      }
    }

    for (ServiceElement service : protoFile.services()) {
      if (shouldEmitService(service.qualifiedName())) {
        ServiceElement.Builder serviceBuilder = ServiceElement.builder()
            .name(service.name())
            .qualifiedName(service.qualifiedName())
            .documentation(service.documentation())
            .addOptions(service.options());
        for (RpcElement method : service.rpcs()) {
          if (shouldEmitServiceMethod(service.qualifiedName(), method.name())) {
            serviceBuilder.addRpc(method);
          }
        }

        ServiceElement limitedService = serviceBuilder.build();
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            service.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitServiceInterface(limitedService, artifact);
        }
      }
    }
  }

  private boolean hasFieldOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          for (OptionElement option : field.options()) {
            if (!WireCompiler.DEFAULT_FIELD_OPTION_KEYS.contains(option.name())) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  private boolean hasMessageOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private boolean hasEnumOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private void getTypes(TypeElement parent, List<TypeElement> types) {
    types.add(parent);
    for (TypeElement nestedType : parent.nestedElements()) {
      getTypes(nestedType, types);
    }
  }

  private void emitRegistry(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitPackage(artifact.javaPackage());

      writer.emitImports("java.util.List");
      writer.emitEmptyLine();

      int extensionsCount = extensionClasses.size();
      if (extensionsCount == 0) {
        writer.emitStaticImports("java.util.Collections.emptyList");
      } else {
        writer.emitStaticImports("java.util.Arrays.asList",
            "java.util.Collections.unmodifiableList");
      }
      writer.emitEmptyLine();
      writer.beginType(artifact.className(), "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      String classes;
      if (extensionsCount == 0) {
        classes = "emptyList()";
      } else {
        StringBuilder sb = new StringBuilder("unmodifiableList(asList(\n");
        for (int i = 0; i < extensionsCount; i++) {
          sb.append(writer.compressType(extensionClasses.get(i)));
          sb.append(".class");
          if (i < extensionsCount - 1) {
            sb.append(",\n");
          }
        }
        sb.append("))");
        classes = sb.toString();
      }

      writer.emitAnnotation("SuppressWarnings(\"unchecked\")");

      String wildcard = extensionsCount == 1 ? extensionClasses.get(0) : "?";
      String listType = "List<Class<" + wildcard + ">>";
      writer.emitField(listType, "EXTENSIONS", EnumSet.of(PUBLIC, STATIC, FINAL), classes);
      writer.emitEmptyLine();

      
      writer.beginMethod(null, artifact.className(), EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private boolean shouldEmitType(String name) {
    return typesToEmit.isEmpty() || typesToEmit.contains(name);
  }

  private boolean shouldEmitService(String serviceName) {
    if (typesToEmit.isEmpty()) {
      return true;
    }
    for (String type : typesToEmit) {
      if (type.equals(serviceName) || type.startsWith(serviceName + "#")) {
        return true;
      }
    }
    return false;
  }

  private boolean shouldEmitServiceMethod(String serviceName, String method) {
    if (method == null) {
      throw new IllegalArgumentException("No method specified");
    }
    return typesToEmit.isEmpty() 
        || typesToEmit.contains(serviceName) 
        || typesToEmit.contains(serviceName + "#" + method);
  }

  private void findDependencies(Collection<ProtoFile> protoFiles) throws WireException {
    Set<String> loadedDependencies = new LinkedHashSet<String>();
    int count = typesToEmit.size();
    while (true) {
      for (ProtoFile protoFile : protoFiles) {
        findDependenciesHelper(protoFile, loadedDependencies);
      }
      int newCount = typesToEmit.size();
      if (newCount == count) {
        break;
      }
      count = newCount;
    }
  }

  private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
      throws WireException {
    
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        try {
          ProtoFile dependencyFile = io.parse(dep);
          loadSymbols(dependencyFile);
        } catch (IOException e) {
          throw new WireException("Error loading symbols for " + dep, e);
        }
        loadedDependencies.add(dependency);
      }
    }

    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String typeName = extend.qualifiedName();
      typesToEmit.add(typeName);
      for (FieldElement field : extend.fields()) {
        
        
        
        String fieldTypeName = typeIsComplete(field.type().toString()) ? field.type().toString()
            : prefixWithPackageName(protoFile, field.type().toString());
        typesToEmit.add(fieldTypeName);
      }
    }

    addDependencies(protoFile.typeElements(), getJavaPackage(protoFile) + ".");
    addDependencies(protoFile.services());
  }

  
  private void addDependencies(List<ServiceElement> services) {
    for (ServiceElement service : services) {
      String fqName = service.qualifiedName();
      if (shouldEmitService(fqName)) {
        for (RpcElement rpc : service.rpcs()) {
          if (shouldEmitServiceMethod(fqName, rpc.name())) {
            addDependencyBranch(fullyQualifiedName(fqName, rpc.requestType().toString()));
            addDependencyBranch(fullyQualifiedName(fqName, rpc.responseType().toString()));
          }
        }
      }
    }
  }

  
  private void addDependencies(List<TypeElement> types, String javaPrefix) {
    for (TypeElement type : types) {
      String name = type.name();
      String fqName = type.qualifiedName();
      if (type instanceof MessageElement && typesToEmit.contains(fqName)) {
        for (FieldElement field : allFields((MessageElement) type)) {
          String fieldType = field.type().toString();
          if (!TypeInfo.isScalar(fieldType)) {
            String fqFieldType = fullyQualifiedName(fqName, field.type().toString());
            addDependencyBranch(fqFieldType);
          }
        }
      }
      addDependencies(type.nestedElements(), javaPrefix + name + ".");
    }
  }

  
  private void addDependencyBranch(String name) {
    while (typeIsComplete(name)) {
      typesToEmit.add(name);
      name = removeTrailingSegment(name);
    }
  }

  private String removeTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? "" : name.substring(0, index);
  }

  public String getTypeBeingGenerated() {
    
    return typeBeingGenerated.substring(0, typeBeingGenerated.length() - 1);
  }

  private enum LoadSymbolsPass {
    LOAD_TYPES, LOAD_FIELDS
  }

  private void loadSymbols(ProtoFile protoFile) throws IOException {
    
    
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_TYPES);
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_FIELDS);
  }

  
  private void loadSymbolsHelper(ProtoFile protoFile, Set<String> loadedDependencies,
      LoadSymbolsPass pass) throws IOException {
    
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        ProtoFile dependencyFile = io.parse(dep);
        loadSymbolsHelper(dependencyFile, loadedDependencies, pass);
        loadedDependencies.add(dependency);
      }
    }

    addTypes(protoFile.typeElements(), getJavaPackage(protoFile) + ".", pass);
    addExtensions(protoFile);
  }

  private void addExtensions(ProtoFile protoFile) {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(protoFile, null, fieldType);
        if (type == null) {
          type = javaName(protoFile, null, prefixWithPackageName(protoFile, fieldType));
        }
        type = shortenJavaName(protoFile, type);
        String fqName = prefixWithPackageName(protoFile, field.name());
        String fqType;

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum =
            !isScalar && isEnum(fullyQualifiedName(protoFile, (String) null, fieldType));
        if (isScalar) {
          type = field.type().toString();
          fqType = type;
        } else if (isEnum) {
          
          type = fullyQualifiedName(protoFile, (String) null, fieldType);
          fqType = type;
        } else {
          fqType = fullyQualifiedName(protoFile, (String) null, fieldType);
        }

        String location = protoFileName(protoFile.filePath());
        String fqLocation = getJavaPackage(protoFile) + ".Ext_" + location;
        ExtensionInfo info =
            new ExtensionInfo(type, fqType, location, fqLocation, field.label());
        extensionInfo.put(fqName, info);
      }
    }
  }

  
  String getJavaPackage(ProtoFile protoFile) {
    OptionElement javaPackage = OptionElement.findByName(protoFile.options(), "java_package");
    if (javaPackage != null) {
      return (String) javaPackage.value();
    }
    return protoFile.packageName() == null ? "" : protoFile.packageName();
  }

  String getJavaPackage() {
    return getJavaPackage(protoFile);
  }

  private void addTypes(List<TypeElement> types, String javaPrefix, LoadSymbolsPass pass) {
    for (TypeElement type : types) {
      String name = type.name();
      if (pass == LoadSymbolsPass.LOAD_TYPES) {
        String fqName = type.qualifiedName();
        javaSymbolMap.put(fqName, javaPrefix + name);
        if (type instanceof EnumElement) {
          EnumElement enumType = (EnumElement) type;
          if (!enumTypes.contains(fqName)) {
            enumTypes.add(fqName);
            enumDefaults.put(fqName, enumType.constants().get(0).name());
          }
        }
      } else if (type instanceof MessageElement) {
        addFields((MessageElement) type);
      }
      addTypes(type.nestedElements(), javaPrefix + name + ".", pass);
    }
  }

  private void addFields(MessageElement messageType) {
    for (FieldElement field : allFields(messageType)) {
      String fieldType = field.type().toString();
      String fqMessageName = messageType.qualifiedName();
      String key = fqMessageName + "$" + field.name();
      fieldMap.put(key, new FieldInfo(
          TypeInfo.isScalar(fieldType) ? fieldType : fullyQualifiedName(fqMessageName, fieldType),
          field.label()));
    }
  }

  private String fullyQualifiedName(ProtoFile protoFile, TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  private String fullyQualifiedName(ProtoFile protoFile, String fqName, String type) {
    if (typeIsComplete(type)) {
      return type;
    } else {
      String prefix = fqName == null ? protoFile.packageName() : fqName;
      while (!prefix.isEmpty()) {
        String fqname = prefix + "." + type;
        if (typeIsComplete(fqname)) return fqname;
        prefix = removeTrailingSegment(prefix);
      }
    }
    throw new WireCompilerException(
        "Unknown type " + type + " in type " + (fqName == null ? "<unknown>" : fqName));
  }

  private String shortenJavaName(ProtoFile protoFile, String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaTypeBeingGenerated = getJavaPackage(protoFile) + "." + typeBeingGenerated;
    if (fullyQualifiedName.startsWith(javaTypeBeingGenerated)) {
      return fullyQualifiedName.substring(javaTypeBeingGenerated.length());
    }

    
    for (String javaSymbol : javaSymbolMap.values()) {
      if (fullyQualifiedName.startsWith(javaSymbol)) {
        
        String pkgPrefix = getPackageFromFullyQualifiedJavaName(fullyQualifiedName) + '.';
        return fullyQualifiedName.substring(pkgPrefix.length());
      }
    }

    return fullyQualifiedName;
  }

  private String protoFileName(String path) {
    int slashIndex = path.lastIndexOf('/');
    if (slashIndex != -1) {
      path = path.substring(slashIndex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  private void emitMessageClass(TypeElement type, OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName.replace("\\", "\\\\"));
      writer.emitPackage(getJavaPackage());

      List<TypeElement> types = new ArrayList<TypeElement>();
      getTypes(type, types);
      boolean hasMessage = hasMessage(types);
      boolean hasExtensions = hasExtensions(Collections.singletonList(type));

      Set<String> imports = new LinkedHashSet<String>();
      if (hasMessage) {
        imports.add("com.squareup.wire.Message");
      }
      if (hasMessage || hasExtensions) {
        if (hasFields(type)) {
          imports.add("com.squareup.wire.ProtoField");
        }
      }
      if (hasBytesField(types)) {
        imports.add("okio.ByteString");
      }
      if (hasEnum(types)) {
        imports.add("com.squareup.wire.ProtoEnum");
      }
      if (hasRepeatedField(types)) {
        imports.add("java.util.Collections");
        imports.add("java.util.List");
      }
      if (hasExtensions) {
        imports.add("com.squareup.wire.ExtendableMessage");
        imports.add("com.squareup.wire.Extension");
      }
      if (options.emitOptions) {
        if (hasFieldOption(types)) {
          imports.add("com.google.protobuf.FieldOptions");
        }
        if (hasMessageOption(types)) {
          imports.add("com.google.protobuf.MessageOptions");
        }
        if (hasEnumOption(types)) {
          imports.add("com.google.protobuf.EnumOptions");
        }
      }

      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(type, externalTypes);

      Map<String, ?> optionsMap = null;
      if (options.emitOptions) {
        if (type instanceof MessageElement) {
          optionsMap = optionsMapMaker.createMessageOptionsMap((MessageElement) type);
          optionsMapMaker.getOptionTypes(optionsMap, externalTypes);

          for (FieldElement field : allFields((MessageElement) type)) {
            Map<String, ?> fieldOptionsMap =
                optionsMapMaker.createFieldOptionsMap((MessageElement) type, field.options());
            optionsMapMaker.getOptionTypes(fieldOptionsMap, externalTypes);
          }
        }
      }
      imports.addAll(externalTypes);

      
      Collection<Datatype> datatypes = new TreeSet<Datatype>(Datatype.ORDER_BY_NAME);
      Collection<Label> labels = new TreeSet<Label>(Label.ORDER_BY_NAME);
      getDatatypesAndLabels(type, datatypes, labels);
      
      labels.remove(Label.OPTIONAL);

      MessageWriter messageWriter = new MessageWriter(this);
      messageWriter.emitHeader(writer, imports, datatypes, labels);
      messageWriter.emitType(writer, type, protoFile.packageName() + ".", optionsMap, true);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitServiceInterface(ServiceElement service, OutputArtifact artifact)
      throws IOException {
    if (serviceWriterConstructor == null) return;
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      ServiceWriter serviceWriter;
      try {
        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
            new ArrayList<String>(options.serviceWriterOptions));
      } catch (Exception e) {
        throw new IllegalStateException(
            "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
                .getName() + ": " + e);
      }

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(artifact.javaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(service, externalTypes);
      imports.addAll(externalTypes);

      serviceWriter.emitService(service, imports);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void getExternalTypes(TypeElement parent, List<String> types) {
    if (parent instanceof MessageElement) {
      MessageElement messageType = (MessageElement) parent;
      for (FieldElement field : allFields(messageType)) {
        String fqName = fullyQualifiedJavaName(messageType, field.type().toString());
        if (fqName == null) {
          continue;
        }
        if (fullyQualifiedNameIsOutsidePackage(fqName)) {
          fqName = getTopLevelMessageName(fqName);
          types.add(fqName);
        }
        String parentType = removeTrailingSegment(fqName);
        if (javaTypeIsComplete(parentType) && fullyQualifiedNameIsOutsidePackage(parentType)) {
          types.add(parentType);
        }
      }
    }
    for (TypeElement nestedType : parent.nestedElements()) {
      getExternalTypes(nestedType, types);
    }
  }

  
  private String getTopLevelMessageName(String fqName) {
    
    String parentType = removeTrailingSegment(fqName);
    while (!parentType.isEmpty()
        && javaTypeIsComplete(parentType)
        && fullyQualifiedNameIsOutsidePackage(parentType)) {
      fqName = parentType;
      parentType = removeTrailingSegment(parentType);
    }
    return fqName;
  }

  private void getExternalTypes(ServiceElement service, List<String> types) {
    for (RpcElement rpc : service.rpcs()) {
      addType(service, rpc.requestType().toString(), types);
      addType(service, rpc.responseType().toString(), types);
    }
  }

  private void addType(ServiceElement service, String method, List<String> types) {
    String serviceFQName = service.qualifiedName();
    String servicePackage =
        serviceFQName.substring(0, serviceFQName.length() - service.name().length() - 1);
    String fqName = javaName(fullyQualifiedName(servicePackage, method));
    if (fullyQualifiedNameIsOutsidePackage(fqName)) {
      types.add(fqName);
    }
  }

  private String getPackageFromFullyQualifiedJavaName(String fqName) {
    while (javaSymbolMap.containsValue(fqName)) {
      fqName = removeTrailingSegment(fqName);
    }
    return fqName;
  }

  private List<String> getExtensionTypes() {
    List<String> extensionClasses = new ArrayList<String>();
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fqName = fullyQualifiedJavaName(null, extend.qualifiedName());
      if (fullyQualifiedNameIsOutsidePackage(fqName)) {
        extensionClasses.add(fqName);
      }
      for (FieldElement field : extend.fields()) {
        String fqFieldType = fullyQualifiedJavaName(null, field.type().toString());
        if (fullyQualifiedNameIsOutsidePackage(fqFieldType)) {
          extensionClasses.add(fqFieldType);
        }
      }
    }
    return extensionClasses;
  }

  private boolean hasExtends() {
    List<ExtendElement> declarations = protoFile.extendDeclarations();
    if (!shouldEmitOptions()) {
      for (ExtendElement declaration : declarations) {
        String name = declaration.qualifiedName();
        if (!isFieldOptions(name) && !isMessageOptions(name)) {
          return true;
        }
      }
    }
    return !declarations.isEmpty();
  }

  private void emitExtensionClass(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(getJavaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      if (hasByteStringExtension()) {
        imports.add("okio.ByteString");
      }
      imports.add("com.squareup.wire.Extension");
      if (hasRepeatedExtension()) {
        imports.add("java.util.List");
      }
      List<String> extensionTypes = getExtensionTypes();

      if (shouldEmitOptions()) {
        imports.addAll(extensionTypes);
      } else {
        for (String extensionType : extensionTypes) {
          if (!isOptionType(extensionType)) {
            imports.add(extensionType);
          }
        }
      }
      writer.emitImports(imports);
      writer.emitEmptyLine();

      String className = "Ext_" + protoFileName;
      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      
      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.emitEmptyLine();

      emitExtensions(writer);
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitExtensions(JavaWriter writer) throws IOException {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fullyQualifiedName = extend.qualifiedName();
      if (!shouldEmitOptions() && isOptionType(fullyQualifiedName)) {
        continue;
      }
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(null, fieldType);
        if (type == null) {
          type = javaName(null, prefixWithPackageName(fieldType));
        }
        type = shortenJavaName(type);
        String initialValue;
        String className = writer.compressType(name);
        String extensionName = field.name();
        String fqName = prefixWithPackageName(field.name());
        int tag = field.tag();

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fullyQualifiedName((String) null, fieldType));
        String labelString = getLabelString(field, isEnum);
        if (isScalar) {
          initialValue = String.format("Extension%n"
              + ".%1$sExtending(%2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", field.type(), className, fqName, tag, labelString);
        } else if (isEnum) {
          initialValue = String.format("Extension%n"
              + ".enumExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        } else {
          initialValue = String.format("Extension%n"
              + ".messageExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        }

        if (FieldInfo.isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", extensionName,
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  
  private static boolean isOptionType(String fullyQualifiedName) {
    return (isMessageOptions(fullyQualifiedName) || isFieldOptions(fullyQualifiedName));
  }

  
  private static boolean isFieldOptions(String name) {
    return "google.protobuf.FieldOptions".equals(name) || "com.google.protobuf.FieldOptions".equals(
        name);
  }

  
  private static boolean isMessageOptions(String fullyQualifiedName) {
    return "google.protobuf.MessageOptions".equals(fullyQualifiedName)
        || "com.google.protobuf.MessageOptions".equals(fullyQualifiedName);
  }

  private String prefixWithPackageName(ProtoFile protoFile, String name) {
    return protoFile.packageName() + "." + name;
  }

  private String getLabelString(FieldElement field, boolean isEnum) {
    switch (field.label()) {
      case OPTIONAL:
        return "Optional";
      case REQUIRED:
        return "Required";
      case REPEATED:
        return FieldInfo.isPacked(field, isEnum) ? "Packed" : "Repeated";
      default:
        throw new WireCompilerException("Unknown extension label \"" + field.label() + "\"");
    }
  }

  private boolean hasByteStringExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.type() == ScalarType.BYTES) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasRepeatedExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.label() == FieldElement.Label.REPEATED) {
          return true;
        }
      }
    }
    return false;
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue()) + "L";
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  private boolean hasEnum(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement || hasEnum(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasOneOf(List<TypeElement> types) {
    for (TypeElement type : types) {
      if ((type instanceof MessageElement && !((MessageElement) type).oneOfs().isEmpty())
          || hasOneOf(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasExtensions(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && hasExtensions(((MessageElement) type))) return true;
      if (hasExtensions(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasMessage(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !hasExtensions(((MessageElement) type))) return true;
      if (hasMessage(type.nestedElements())) return true;
    }
    return false;
  }

  
  static List<FieldElement> allFields(MessageElement messageType) {
    List<FieldElement> allFields = new ArrayList<FieldElement>();
    allFields.addAll(messageType.fields());
    for (OneOfElement oneOfElement : messageType.oneOfs()) {
      allFields.addAll(oneOfElement.fields());
    }
    return allFields;
  }

  private boolean hasRepeatedField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (FieldInfo.isRepeated(field)) return true;
        }
      }
      if (hasRepeatedField(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasBytesField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (field.type() == ScalarType.BYTES) return true;
        }
      }
      if (hasBytesField(type.nestedElements())) return true;
    }
    return false;
  }

  private void getDatatypesAndLabels(TypeElement type, Collection<Datatype> types,
      Collection<Label> labels) {
    if (type instanceof MessageElement) {
      for (FieldElement field : allFields((MessageElement) type)) {
        String fieldType = field.type().toString();
        Datatype datatype = Datatype.of(fieldType);
        
        if (datatype == null && isEnum(fullyQualifiedName(type, field.type().toString()))) {
          datatype = Datatype.ENUM;
        }
        if (datatype != null) types.add(datatype);

        
        FieldElement.Label label = field.label();
        switch (label) {
          case OPTIONAL:
            labels.add(Label.OPTIONAL);
            break;
          case REQUIRED:
            labels.add(Label.REQUIRED);
            break;
          case REPEATED:
            if (FieldInfo.isPacked(field, datatype == Datatype.ENUM)) {
              labels.add(Label.PACKED);
            } else {
              labels.add(Label.REPEATED);
            }
            break;
          case ONE_OF:
            labels.add(Label.ONE_OF);
            break;
          default:
            throw new AssertionError("Unknown label " + label);
        }
      }

      for (TypeElement nestedType : type.nestedElements()) {
        getDatatypesAndLabels(nestedType, types, labels);
      }
    }
  }

  private boolean typeIsComplete(String type) {
    return javaSymbolMap.containsKey(type);
  }

  private boolean javaTypeIsComplete(String type) {
    if (javaSymbols.isEmpty()) {
      javaSymbols.addAll(javaSymbolMap.values());
    }
    return javaSymbols.contains(type);
  }

  private String fullyQualifiedJavaName(MessageElement messageType, String type) {
    return TypeInfo.isScalar(type) ? null : javaName(fullyQualifiedName(messageType, type));
  }

  private void compileWithJavaPoet() throws WireException {
    Set<String> parsedFiles = new LinkedHashSet<String>();
    Loader loader = new Loader(repoPath, io);
    for (String sourceFilename : options.sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      parsedFiles.add(sourcePath);
      try {
        loader.add(sourceFilename);
      } catch (IOException e) {
        throw new WireException("Error loading symbols for " + sourcePath, e);
      }
    }

    List<WireProtoFile> wireProtoFiles = loader.loaded();
    Linker linker = new Linker();
    linker.link(wireProtoFiles);

    if (!typesToEmit.isEmpty()) {
      log.info("Analyzing dependencies of root types.");
      wireProtoFiles = new Pruner().retainRoots(wireProtoFiles, typesToEmit);
    }

    JavaGenerator javaGenerator = JavaGenerator.get(wireProtoFiles);
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      if (!parsedFiles.contains(wireProtoFile.sourcePath())) {
        continue; 
      }

      TypeWriter typeWriter = new TypeWriter(javaGenerator, options.emitOptions);

      for (com.squareup.wire.model.WireType type : wireProtoFile.types()) {
        ClassName javaTypeName = (ClassName) javaGenerator.typeName(type.protoTypeName());
        TypeSpec typeSpec = typeWriter.toTypeSpec(type);
        writeJavaFile(javaTypeName, typeSpec, wireProtoFile.sourcePath());
      }

      if (!wireProtoFile.wireExtends().isEmpty()) {
        ClassName javaTypeName = javaGenerator.extensionsClass(wireProtoFile);
        TypeSpec typeSpec = typeWriter.extensionsType(javaTypeName, wireProtoFile);
        writeJavaFile(javaTypeName, typeSpec, wireProtoFile.sourcePath());
      }
    }
  }

  private void writeJavaFile(
      ClassName javaTypeName, TypeSpec typeSpec, String sourceFileName) throws WireException {
    OutputArtifact artifact = new OutputArtifact(options.javaOut, javaTypeName);
    log.artifact(artifact);

    JavaFile javaFile = JavaFile.builder(javaTypeName.packageName(), typeSpec)
        .addFileComment("$L\n", CODE_GENERATED_BY_WIRE)
        .addFileComment("Source file: $L", sourceFileName)
        .build();

    try {
      if (!options.dryRun) {
        io.write(artifact, javaFile);
      }
    } catch (IOException e) {
      throw new WireException("Error emitting " + artifact.file(), e);
    }
  }
}

<code block>

package com.squareup.wire.java;

import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import com.squareup.wire.WireCompilerException;
import com.squareup.wire.model.ProtoTypeName;
import com.squareup.wire.model.WireEnum;
import com.squareup.wire.model.WireEnumConstant;
import com.squareup.wire.model.WireExtend;
import com.squareup.wire.model.WireField;
import com.squareup.wire.model.WireMessage;
import com.squareup.wire.model.WireOneOf;
import com.squareup.wire.model.WireProtoFile;
import com.squareup.wire.model.WireType;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import okio.ByteString;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public final class TypeWriter {
  private static final ImmutableSet<String> JAVA_KEYWORDS = ImmutableSet.of(
      "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
      "class", "const", "continue", "default", "do", "double", "else", "enum", "extends",
      "final", "finally", "float", "for", "goto", "if", "implements", "import", "instanceof",
      "int", "interface", "long", "native", "new", "package", "private", "protected", "public",
      "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
      "throw", "throws", "transient", "try", "void", "volatile", "while");

  private final JavaGenerator javaGenerator;
  private final boolean emitOptions;

  public TypeWriter(JavaGenerator javaGenerator, boolean emitOptions) {
    this.javaGenerator = javaGenerator;
    this.emitOptions = emitOptions;
  }

  
  public TypeSpec toTypeSpec(WireType type) {
    if (type instanceof WireMessage) {
      return toTypeSpec((WireMessage) type);
    } else if (type instanceof WireEnum) {
      return toTypeSpec((WireEnum) type);
    } else {
      throw new IllegalArgumentException("unexpected type: " + type);
    }
  }

  private TypeSpec toTypeSpec(WireEnum type) {
    ClassName typeName = (ClassName) javaGenerator.typeName(type.protoTypeName());

    TypeSpec.Builder builder = TypeSpec.enumBuilder(typeName.simpleName())
        .addModifiers(PUBLIC)
        .addSuperinterface(ProtoEnum.class);

    if (!type.documentation().isEmpty()) {
      builder.addJavadoc("$L\n", type.documentation());
    }

    

    for (WireEnumConstant constant : type.constants()) {
      Object[] enumArgs = new Object[1];
      String[] enumArgsFormat = new String[1];

      enumArgs[0] = constant.tag();
      enumArgsFormat[0] = "$L";

      TypeSpec.Builder constantBuilder = TypeSpec.anonymousClassBuilder(
          Joiner.on(", ").join(enumArgsFormat), enumArgs);
      if (!constant.documentation().isEmpty()) {
        constantBuilder.addJavadoc("$L\n", constant.documentation());
      }

      builder.addEnumConstant(constant.name(), constantBuilder.build());

      
    }

    
    builder.addField(TypeName.INT, "value", PRIVATE, FINAL);

    

    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
    constructorBuilder.addParameter(TypeName.INT, "value");
    constructorBuilder.addStatement("this.value = value");
    
    builder.addMethod(constructorBuilder.build());

    
    builder.addMethod(MethodSpec.methodBuilder("getValue")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(TypeName.INT)
        .addStatement("return value")
        .build());

    return builder.build();
  }

  private TypeSpec toTypeSpec(WireMessage type) {
    ClassName javaType = (ClassName) javaGenerator.typeName(type.protoTypeName());
    ClassName builderJavaType = javaType.nestedClass("Builder");

    TypeSpec.Builder builder = TypeSpec.classBuilder(javaType.simpleName());
    builder.addModifiers(PUBLIC, FINAL);

    if (javaType.enclosingClassName() != null) {
      builder.addModifiers(STATIC);
    }

    if (!type.documentation().isEmpty()) {
      builder.addJavadoc("$L\n", type.documentation());
    }

    builder.superclass(type.extensions().isEmpty()
        ? JavaGenerator.MESSAGE
        : JavaGenerator.extendableMessageOf(javaType));

    builder.addField(FieldSpec.builder(TypeName.LONG, "serialVersionUID")
        .addModifiers(PRIVATE, STATIC, FINAL)
        .initializer("$LL", 0L)
        .build());

    if (emitOptions) {
      for (WireField field : type.fieldsAndOneOfFields()) {
        FieldSpec options = fieldOptionsField(field);
        if (options != null) {
          builder.addField(options);
        }
      }
    }

    for (WireField field : type.fieldsAndOneOfFields()) {
      TypeName fieldType = fieldType(field);

      if (field.type().isScalar()
          || javaGenerator.isEnum(field.type())
          || field.isRepeated()) {
        builder.addField(defaultField(field, fieldType));
      }

      String name = sanitize(field.name());
      FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, name, PUBLIC, FINAL);
      fieldBuilder.addAnnotation(protoFieldAnnotation(field, javaGenerator.typeName(field.type())));
      if (!field.documentation().isEmpty()) {
        fieldBuilder.addJavadoc("$L\n", field.documentation());
      }
      if (field.isDeprecated()) {
        fieldBuilder.addAnnotation(Deprecated.class);
      }
      builder.addField(fieldBuilder.build());
    }

    builder.addMethod(messageFieldsConstructor(type));
    builder.addMethod(messageBuilderConstructor(type, builderJavaType));
    builder.addMethod(messageEquals(type));
    builder.addMethod(messageHashCode(type));
    builder.addType(builder(type, javaType, builderJavaType));

    for (WireType nestedType : type.nestedTypes()) {
      builder.addType(toTypeSpec(nestedType));
    }

    return builder.build();
  }


  
  
  
  
  
  
  private FieldSpec fieldOptionsField(WireField field) {
    CodeBlock.Builder initializer = CodeBlock.builder();
    initializer.add("$[new $T.Builder()", JavaGenerator.FIELD_OPTIONS);

    boolean empty = true;
    for (Map.Entry<WireField, ?> entry : field.options().map().entrySet()) {
      WireField extensionRoot = entry.getKey();
      if (extensionRoot.name().equals("default")
          || extensionRoot.name().equals("deprecated")
          || extensionRoot.name().equals("packed")) {
        continue; 
      }

      ClassName extensionClass = javaGenerator.extensionsClass(extensionRoot);
      initializer.add("\n.setExtension($T.$L, $L)", extensionClass, extensionRoot.name(),
          fieldInitializer(extensionRoot.type(), entry.getValue()));
      empty = false;
    }
    initializer.add("\n.build()$]");
    if (empty) return null;

    String optionsFieldName = "FIELD_OPTIONS_" + field.name().toUpperCase(Locale.US);
    return FieldSpec.builder(JavaGenerator.FIELD_OPTIONS, optionsFieldName)
        .addModifiers(PUBLIC, STATIC, FINAL)
        .initializer(initializer.build())
        .build();
  }

  private TypeName fieldType(WireField field) {
    TypeName messageType = javaGenerator.typeName(field.type());
    return field.isRepeated() ? JavaGenerator.listOf(messageType) : messageType;
  }

  
  
  
  
  private FieldSpec defaultField(WireField field, TypeName fieldType) {
    String defaultFieldName = "DEFAULT_" + field.name().toUpperCase(Locale.US);
    return FieldSpec.builder(fieldType, defaultFieldName, PUBLIC, STATIC, FINAL)
        .initializer(defaultValue(field))
        .build();
  }

  
  
  
  
  
  
  
  private AnnotationSpec protoFieldAnnotation(WireField field, TypeName messageType) {
    AnnotationSpec.Builder result = AnnotationSpec.builder(ProtoField.class);

    int tag = field.tag();
    result.addMember("tag", String.valueOf(tag));

    boolean isScalar = field.type().isScalar();
    boolean isEnum = javaGenerator.isEnum(field.type());

    String fieldType;
    if (isScalar) {
      fieldType = field.type().toString().toUpperCase(Locale.US);
    } else if (isEnum) {
      fieldType = "ENUM";
    } else {
      fieldType = null;
    }

    if (fieldType != null) {
      result.addMember("type", "$T.$L", Message.Datatype.class, fieldType);
    }

    if (!field.isOptional()) {
      String label;
      if (field.isPacked() && (isEnum || field.type().isPackableScalar())) {
        label = "PACKED";
      } else {
        label = field.label().toString();
      }
      result.addMember("label", "$T.$L", Message.Label.class, label);
    }

    if (field.isRepeated() && !isScalar) {
      String key = isEnum ? "enumType" : "messageType";
      result.addMember(key, "$T.class", messageType);
    }

    if (field.isDeprecated()) {
      result.addMember("deprecated", "true");
    }

    
    if (field.options().optionMatches(".*\\.redacted", "true")) {
      result.addMember("redacted", "true");
    }

    return result.build();
  }

  
  
  
  
  
  
  
  private MethodSpec messageFieldsConstructor(WireMessage type) {
    MethodSpec.Builder result = MethodSpec.constructorBuilder();
    result.addModifiers(PUBLIC);
    for (WireField field : type.fieldsAndOneOfFields()) {
      TypeName javaType = fieldType(field);
      String sanitizedName = sanitize(field.name());
      result.addParameter(javaType, sanitizedName);
      if (field.isRepeated()) {
        result.addStatement("this.$L = immutableCopyOf($L)", sanitizedName, sanitizedName);
      } else {
        result.addStatement("this.$L = $L", sanitizedName, sanitizedName);
      }
    }
    return result.build();
  }

  
  
  
  
  
  
  
  private MethodSpec messageBuilderConstructor(WireMessage type, ClassName builderJavaType) {
    MethodSpec.Builder result = MethodSpec.constructorBuilder()
        .addModifiers(PRIVATE)
        .addParameter(builderJavaType, "builder");

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.size() > 0) {
      result.addCode("this(");
      for (int i = 0; i < fields.size(); i++) {
        if (i > 0) result.addCode(", ");
        WireField field = fields.get(i);
        result.addCode("builder.$L", sanitize(field.name()));
      }
      result.addCode(");\n");
    }
    result.addStatement("setBuilder(builder)");
    return result.build();
  }

  
  
  
  
  
  
  
  
  
  
  private MethodSpec messageEquals(WireMessage type) {
    TypeName javaType = javaGenerator.typeName(type.protoTypeName());
    MethodSpec.Builder result = MethodSpec.methodBuilder("equals")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(boolean.class)
        .addParameter(Object.class, "other");

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.isEmpty() && type.extensions().isEmpty()) {
      result.addStatement("return other instanceof $T", javaType);
      return result.build();
    }

    result.addStatement("if (other == this) return true");
    result.addStatement("if (!(other instanceof $T)) return false", javaType);

    if (fields.size() == 1 && type.extensions().isEmpty()) {
      String name = sanitize(fields.get(0).name());
      result.addStatement("return equals($L, (($T) other).$L)",
          addThisIfOneOf(name, "other", "o"), javaType, name);
      return result.build();
    }

    result.addStatement("$T o = ($T) other", javaType, javaType);
    if (!type.extensions().isEmpty()) {
      result.addStatement("if (!extensionsEqual(o)) return false");
    }
    result.addCode("$[return ");
    for (int i = 0; i < fields.size(); i++) {
      if (i > 0) result.addCode("\n&& ");
      WireField field = fields.get(i);
      String name = sanitize(field.name());
      result.addCode("equals($L, o.$L)", addThisIfOneOf(name, "other", "o"), name);
    }
    result.addCode(";\n$]");

    return result.build();
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  private MethodSpec messageHashCode(WireMessage type) {
    MethodSpec.Builder result = MethodSpec.methodBuilder("hashCode")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(int.class);

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.isEmpty() && type.extensions().isEmpty()) {
      result.addStatement("return 0");
      return result.build();
    }

    if (fields.size() == 1 && type.extensions().isEmpty()) {
      WireField field = fields.get(0);
      String name = sanitize(field.name());
      result.addStatement("int result = hashCode");
      result.addStatement(
          "return result != 0 ? result : (hashCode = $L != null ? $L.hashCode() : $L)",
          addThisIfOneOf(name, "result"), addThisIfOneOf(name, "result"), nullHashValue(field));
      return result.build();
    }

    result.addStatement("int result = hashCode");
    result.beginControlFlow("if (result == 0)");
    boolean afterFirstAssignment = false;
    if (!type.extensions().isEmpty()) {
      result.addStatement("result = extensionsHashCode()");
      afterFirstAssignment = true;
    }
    for (WireField field : fields) {
      String name = sanitize(field.name());
      name = addThisIfOneOf(name, "result");
      if (afterFirstAssignment) {
        result.addStatement("result = result * 37 + ($L != null ? $L.hashCode() : $L)",
            name, name, nullHashValue(field));
      } else {
        result.addStatement("result = $L != null ? $L.hashCode() : $L",
            name, name, nullHashValue(field));
        afterFirstAssignment = true;
      }
    }
    result.addStatement("hashCode = result");
    result.endControlFlow();
    result.addStatement("return result");
    return result.build();
  }

  private TypeSpec builder(WireMessage type, ClassName javaType, ClassName builderType) {
    TypeSpec.Builder result = TypeSpec.classBuilder("Builder")
        .addModifiers(PUBLIC, STATIC, FINAL);

    result.superclass(type.extensions().isEmpty()
        ? JavaGenerator.builderOf(javaType)
        : JavaGenerator.extendableBuilderOf(javaType));

    List<WireField> fields = type.fieldsAndOneOfFields();
    for (WireField field : fields) {
      TypeName fieldJavaType = fieldType(field);
      result.addField(fieldJavaType, sanitize(field.name()), PUBLIC);
    }

    result.addMethod(builderNoArgsConstructor());
    result.addMethod(builderCopyConstructor(type));

    for (WireField field : type.fields()) {
      result.addMethod(setter(builderType, null, field));
    }

    for (WireOneOf oneOf : type.oneOfs()) {
      for (WireField field : oneOf.fields()) {
        result.addMethod(setter(builderType, oneOf, field));
      }
    }

    if (!type.extensions().isEmpty()) {
      result.addMethod(builderSetExtension(javaType, builderType));
    }

    result.addMethod(builderBuild(type, javaType));
    return result.build();
  }

  
  
  
  
  
  private MethodSpec builderNoArgsConstructor() {
    return MethodSpec.constructorBuilder()
        .addModifiers(PUBLIC)
        .build();
  }

  
  
  
  
  
  
  
  
  
  private MethodSpec builderCopyConstructor(WireMessage message) {
    TypeName javaType = javaGenerator.typeName(message.protoTypeName());

    MethodSpec.Builder result = MethodSpec.constructorBuilder()
        .addModifiers(PUBLIC)
        .addParameter(javaType, "message");
    result.addStatement("super(message)");

    List<WireField> fields = message.fieldsAndOneOfFields();
    if (!fields.isEmpty()) {
      result.addStatement("if (message == null) return");
    }

    for (WireField field : fields) {
      String fieldName = sanitize(field.name());
      if (field.isRepeated()) {
        result.addStatement("this.$L = copyOf(message.$L)", fieldName, fieldName);
      } else {
        result.addStatement("this.$L = message.$L", fieldName, fieldName);
      }
    }

    return result.build();
  }

  private MethodSpec setter(TypeName builderType, WireOneOf oneOf, WireField field) {
    TypeName javaType = fieldType(field);
    String fieldName = sanitize(field.name());

    MethodSpec.Builder result = MethodSpec.methodBuilder(fieldName)
        .addModifiers(PUBLIC)
        .addParameter(javaType, fieldName)
        .returns(builderType);

    if (!field.documentation().isEmpty()) {
      result.addJavadoc("$L\n", field.documentation());
    }

    if (field.isDeprecated()) {
      result.addAnnotation(Deprecated.class);
    }

    if (field.isRepeated()) {
      result.addStatement("this.$L = checkForNulls($L)", fieldName, fieldName);
    } else {
      result.addStatement("this.$L = $L", fieldName, fieldName);

      if (oneOf != null) {
        for (WireField other : oneOf.fields()) {
          if (field != other) {
            result.addStatement("this.$L = null", sanitize(other.name()));
          }
        }
      }
    }

    result.addStatement("return this");
    return result.build();
  }

  
  
  
  
  
  
  
  
  private MethodSpec builderSetExtension(ClassName javaType, ClassName builderType) {
    TypeVariableName e = TypeVariableName.get("E");
    return MethodSpec.methodBuilder("setExtension")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .addTypeVariable(e)
        .returns(builderType)
        .addParameter(JavaGenerator.extensionOf(javaType, e), "extension")
        .addParameter(e, "value")
        .addStatement("super.setExtension(extension, value)")
        .addStatement("return this")
        .build();
  }

  
  
  
  
  
  
  
  
  
  
  
  private MethodSpec builderBuild(WireMessage message, ClassName javaType) {
    MethodSpec.Builder result = MethodSpec.methodBuilder("build")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(javaType);
    if (message.hasRequiredFields()) {
      result.addStatement("checkRequiredFields()");
    }
    result.addStatement("return new $T(this)", javaType);
    return result.build();
  }

  private CodeBlock defaultValue(WireField field) {
    if (field.isRepeated()) {
      return codeBlock("$T.emptyList()", Collections.class);
    }

    Object defaultValue = field.getDefault();

    if (defaultValue == null && javaGenerator.isEnum(field.type())) {
      defaultValue = javaGenerator.enumDefault(field.type()).name();
    }

    if (field.type().isScalar() || defaultValue != null) {
      return fieldInitializer(field.type(), defaultValue);
    }

    throw new WireCompilerException("Field " + field + " cannot have default value");
  }

  private CodeBlock fieldInitializer(ProtoTypeName type, Object value) {
    TypeName javaType = javaGenerator.typeName(type);

    if (value instanceof List) {
      CodeBlock.Builder builder = CodeBlock.builder();
      builder.add("$T.asList(", Arrays.class);
      boolean first = true;
      for (Object o : (List<?>) value) {
        if (!first) builder.add(",");
        first = false;
        builder.add("\n$>$>$L$<$<", fieldInitializer(type, o));
      }
      builder.add(")");
      return builder.build();

    } else if (value instanceof Map) {
      CodeBlock.Builder builder = CodeBlock.builder();
      builder.add("new $T.Builder()", javaType);
      for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
        WireField field = (WireField) entry.getKey();
        builder.add("\n$>$>.$L($L)$<$<", field.name(), fieldInitializer(
            field.type(), entry.getValue()));
      }
      builder.add("\n$>$>.build()$<$<");
      return builder.build();

    } else if (javaType.equals(TypeName.BOOLEAN.box())) {
      return codeBlock("$L", value != null ? value : false);

    } else if (javaType.equals(TypeName.INT.box())) {
      return codeBlock("$L", value != null
          ? new BigDecimal(String.valueOf(value)).intValue()
          : 0);

    } else if (javaType.equals(TypeName.LONG.box())) {
      return codeBlock("$LL", value != null
          ? Long.toString(new BigDecimal(String.valueOf(value)).longValue())
          : 0L);

    } else if (javaType.equals(TypeName.FLOAT.box())) {
      return codeBlock("$Lf", value != null ? String.valueOf(value) : 0f);

    } else if (javaType.equals(TypeName.DOUBLE.box())) {
      return codeBlock("$Ld", value != null ? String.valueOf(value) : 0d);

    } else if (javaType.equals(JavaGenerator.STRING)) {
      return codeBlock("$S", value != null ? (String) value : "");

    } else if (javaType.equals(JavaGenerator.BYTE_STRING)) {
      if (value == null) {
        return codeBlock("$T.EMPTY", ByteString.class);
      } else {
        return codeBlock("$T.decodeBase64($S)", ByteString.class,
            ByteString.of(String.valueOf(value).getBytes(Charsets.ISO_8859_1)).base64());
      }

    } else if (javaGenerator.isEnum(type) && value != null) {
      return codeBlock("$T.$L", javaType, value);

    } else {
      throw new WireCompilerException(type + " is not an allowed scalar type");
    }
  }

  private String addThisIfOneOf(String name, String... matches) {
    for (String match : matches) {
      if (match.equals(name)) {
        return "this." + name;
      }
    }
    return name;
  }

  private static String sanitize(String name) {
    return JAVA_KEYWORDS.contains(name) ? "_" + name : name;
  }

  private static CodeBlock codeBlock(String format, Object... args) {
    return CodeBlock.builder().add(format, args).build();
  }

  private int nullHashValue(WireField field) {
    return field.isRepeated() ? 1 : 0;
  }

  public TypeSpec extensionsType(ClassName javaTypeName, WireProtoFile wireProtoFile) {
    TypeSpec.Builder builder = TypeSpec.classBuilder(javaTypeName.simpleName())
        .addModifiers(PUBLIC, FINAL);

    
    builder.addMethod(MethodSpec.constructorBuilder()
        .addModifiers(PRIVATE)
        .build());

    for (WireExtend extend : wireProtoFile.wireExtends()) {
      ProtoTypeName extendType = extend.protoTypeName();
      TypeName javaType = javaGenerator.typeName(extendType);

      if (!emitOptions && (extendType.isFieldOptions() || extendType.isMessageOptions())) {
        continue;
      }

      for (WireField field : extend.fields()) {
        builder.addField(extensionField(wireProtoFile, javaType, field));
      }
    }

    return builder.build();
  }

  private FieldSpec extensionField(
      WireProtoFile wireProtoFile, TypeName extendType, WireField field) {
    TypeName fieldType = javaGenerator.typeName(field.type());

    CodeBlock.Builder initializer = CodeBlock.builder();
    initializer.add("$[Extension\n");

    if (field.type().isScalar()) {
      initializer.add(".$LExtending($T.class)\n", field.type(), extendType);
    } else if (javaGenerator.isEnum(field.type())) {
      initializer.add(".enumExtending($T.class, $T.class)\n", fieldType, extendType);
    } else {
      initializer.add(".messageExtending($T.class, $T.class)\n", fieldType, extendType);
    }

    initializer.add(".setName($S)\n", wireProtoFile.packageName() + "." + field.name());
    initializer.add(".setTag($L)\n", field.tag());
    initializer.add(".build$L()$]", extensionLabel(field));

    if (field.isRepeated()) {
      fieldType = JavaGenerator.listOf(fieldType);
    }

    return FieldSpec.builder(JavaGenerator.extensionOf(extendType, fieldType), field.name())
        .addModifiers(PUBLIC, STATIC, FINAL)
        .initializer(initializer.build())
        .build();
  }

  private String extensionLabel(WireField field) {
    switch (field.label()) {
      case OPTIONAL:
        return "Optional";

      case REQUIRED:
        return "Required";

      case REPEATED:
        boolean packed = field.isPacked()
            && (javaGenerator.isEnum(field.type()) || field.type().isPackableScalar());
        return packed ? "Packed" : "Repeated";

      default:
        throw new WireCompilerException("Unknown extension label \"" + field.label() + "\"");
    }
  }
}

<code block>

package com.squareup.wire.java;

import com.google.common.collect.ImmutableMap;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.wire.ExtendableMessage;
import com.squareup.wire.Extension;
import com.squareup.wire.Message;
import com.squareup.wire.model.ProtoTypeName;
import com.squareup.wire.model.WireEnum;
import com.squareup.wire.model.WireEnumConstant;
import com.squareup.wire.model.WireExtend;
import com.squareup.wire.model.WireField;
import com.squareup.wire.model.WireProtoFile;
import com.squareup.wire.model.WireType;
import java.util.List;
import java.util.Map;
import okio.ByteString;

import static com.google.common.base.Preconditions.checkArgument;


public final class JavaGenerator {
  public static final ClassName BYTE_STRING = ClassName.get(ByteString.class);
  public static final ClassName STRING = ClassName.get(String.class);
  public static final ClassName LIST = ClassName.get(List.class);
  public static final ClassName MESSAGE = ClassName.get(Message.class);
  public static final ClassName EXTENDABLE_MESSAGE = ClassName.get(ExtendableMessage.class);
  public static final ClassName BUILDER = ClassName.get(Message.Builder.class);
  public static final ClassName EXTENDABLE_BUILDER
      = ClassName.get(ExtendableMessage.ExtendableBuilder.class);
  public static final ClassName EXTENSION = ClassName.get(Extension.class);
  public static final TypeName FIELD_OPTIONS = ClassName.get("com.google.protobuf", "FieldOptions");

  private static final Map<ProtoTypeName, TypeName> SCALAR_TYPES_MAP =
      ImmutableMap.<ProtoTypeName, TypeName>builder()
          .put(ProtoTypeName.BOOL, TypeName.BOOLEAN.box())
          .put(ProtoTypeName.BYTES, ClassName.get(ByteString.class))
          .put(ProtoTypeName.DOUBLE, TypeName.DOUBLE.box())
          .put(ProtoTypeName.FLOAT, TypeName.FLOAT.box())
          .put(ProtoTypeName.FIXED32, TypeName.INT.box())
          .put(ProtoTypeName.FIXED64, TypeName.LONG.box())
          .put(ProtoTypeName.INT32, TypeName.INT.box())
          .put(ProtoTypeName.INT64, TypeName.LONG.box())
          .put(ProtoTypeName.SFIXED32, TypeName.INT.box())
          .put(ProtoTypeName.SFIXED64, TypeName.LONG.box())
          .put(ProtoTypeName.SINT32, TypeName.INT.box())
          .put(ProtoTypeName.SINT64, TypeName.LONG.box())
          .put(ProtoTypeName.STRING, ClassName.get(String.class))
          .put(ProtoTypeName.UINT32, TypeName.INT.box())
          .put(ProtoTypeName.UINT64, TypeName.LONG.box())
          .build();

  private final ImmutableMap<ProtoTypeName, TypeName> wireToJava;
  private final ImmutableMap<ProtoTypeName, WireType> wireToType;
  private final ImmutableMap<WireField, WireProtoFile> extensionFieldToFile;

  public JavaGenerator(
      ImmutableMap<ProtoTypeName, TypeName> wireToJava,
      ImmutableMap<ProtoTypeName, WireType> wireToType,
      ImmutableMap<WireField, WireProtoFile> extensionFieldToFile) {
    this.wireToJava = wireToJava;
    this.wireToType = wireToType;
    this.extensionFieldToFile = extensionFieldToFile;
  }

  public static JavaGenerator get(List<WireProtoFile> wireProtoFiles) {
    ImmutableMap.Builder<ProtoTypeName, TypeName> wireToJava = ImmutableMap.builder();
    ImmutableMap.Builder<ProtoTypeName, WireType> wireToType = ImmutableMap.builder();
    ImmutableMap.Builder<WireField, WireProtoFile> extensionFieldToFile = ImmutableMap.builder();
    wireToJava.putAll(SCALAR_TYPES_MAP);

    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      String javaPackage = javaPackage(wireProtoFile);
      putAll(wireToJava, wireToType, javaPackage, null, wireProtoFile.types());

      for (WireExtend wireExtend : wireProtoFile.wireExtends()) {
        for (WireField field : wireExtend.fields()) {
          extensionFieldToFile.put(field, wireProtoFile);
        }
      }
    }

    return new JavaGenerator(wireToJava.build(), wireToType.build(),
        extensionFieldToFile.build());
  }

  private static void putAll(ImmutableMap.Builder<ProtoTypeName, TypeName> wireToJava,
      ImmutableMap.Builder<ProtoTypeName, WireType> wireToType, String javaPackage,
      ClassName enclosingClassName, List<WireType> types) {
    for (WireType type : types) {
      ClassName className = enclosingClassName != null
          ? enclosingClassName.nestedClass(type.protoTypeName().simpleName())
          : ClassName.get(javaPackage, type.protoTypeName().simpleName());
      wireToJava.put(type.protoTypeName(), className);
      wireToType.put(type.protoTypeName(), type);
      putAll(wireToJava, wireToType, javaPackage, className, type.nestedTypes());
    }
  }

  public ClassName extensionsClass(WireProtoFile protoFile) {
    return ClassName.get(javaPackage(protoFile), "Ext_" + protoFile.name());
  }

  public ClassName extensionsClass(WireField extensionRoot) {
    WireProtoFile protoFile = extensionFieldToFile.get(extensionRoot);
    checkArgument(protoFile != null, "unrecognized extension %s", extensionRoot);
    return extensionsClass(protoFile);
  }

  public TypeName typeName(ProtoTypeName protoTypeName) {
    TypeName candidate = wireToJava.get(protoTypeName);
    checkArgument(candidate != null, "unexpected type %s", protoTypeName);
    return candidate;
  }

  private static String javaPackage(WireProtoFile wireProtoFile) {
    Object javaPackageOption = wireProtoFile.options().get("java_package");
    if (javaPackageOption != null) {
      return String.valueOf(javaPackageOption);
    } else if (wireProtoFile.packageName() != null) {
      return wireProtoFile.packageName();
    } else {
      return "";
    }
  }

  public boolean isEnum(ProtoTypeName type) {
    WireType wireType = wireToType.get(type);
    return wireType instanceof WireEnum;
  }

  public WireEnumConstant enumDefault(ProtoTypeName type) {
    WireEnum wireEnum = (WireEnum) wireToType.get(type);
    return wireEnum.constants().get(0);
  }

  public static TypeName listOf(TypeName type) {
    return ParameterizedTypeName.get(LIST, type);
  }

  public static TypeName extendableMessageOf(TypeName type) {
    return ParameterizedTypeName.get(JavaGenerator.EXTENDABLE_MESSAGE, type);
  }

  public static TypeName builderOf(TypeName messageType) {
    return ParameterizedTypeName.get(BUILDER, messageType);
  }

  public static TypeName extendableBuilderOf(TypeName messageType) {
    return ParameterizedTypeName.get(EXTENDABLE_BUILDER, messageType);
  }

  public static TypeName extensionOf(TypeName messageType, TypeName fieldType) {
    return ParameterizedTypeName.get(EXTENSION, messageType, fieldType);
  }
}

<code block>

package com.squareup.wire.internal;

import java.util.ArrayList;
import java.util.List;

public final class Util {
  private Util() {
  }

  public static <T> List<T> concatenate(List<T> a, T b) {
    List<T> result = new ArrayList<T>();
    result.addAll(a);
    result.add(b);
    return result;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.DataType;
import com.squareup.wire.internal.Util;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;


public final class Linker {
  private final Map<String, WireType> protoTypeNames;
  private final Map<ProtoTypeName, Map<String, WireField>> extensionsMap;

  
  private final List<WireType> enclosingTypes;

  public Linker() {
    this.protoTypeNames = new LinkedHashMap<String, WireType>();
    this.extensionsMap = new LinkedHashMap<ProtoTypeName, Map<String, WireField>>();
    this.enclosingTypes = Collections.emptyList();
  }

  private Linker(Linker enclosing, WireType type) {
    this.protoTypeNames = enclosing.protoTypeNames;
    this.extensionsMap = enclosing.extensionsMap;
    this.enclosingTypes = type != null
        ? Util.concatenate(enclosing.enclosingTypes, type)
        : enclosing.enclosingTypes;
  }

  public void link(Collection<WireProtoFile> wireProtoFiles) {
    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireType type : wireProtoFile.types()) {
        register(type);
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireExtend extend : wireProtoFile.wireExtends()) {
        extend.link(this);
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireExtend extend : wireProtoFile.wireExtends()) {
        Map<String, WireField> map = extensionsMap.get(extend.protoTypeName());
        if (map == null) {
          map = new LinkedHashMap<String, WireField>();
          extensionsMap.put(extend.protoTypeName(), map);
        }
        for (WireField field : extend.fields()) {
          map.put(extend.packageName() + "." + field.name(), field);
        }
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireType type : wireProtoFile.types()) {
        type.link(this);
      }
      for (WireService service : wireProtoFile.services()) {
        service.link(this);
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      wireProtoFile.options().link(this);
      for (WireType type : wireProtoFile.types()) {
        type.linkOptions(this);
      }
      for (WireService service : wireProtoFile.services()) {
        service.linkOptions(this);
      }
    }
  }

  private void register(WireType type) {
    protoTypeNames.put(type.protoTypeName().toString(), type);
    for (WireType nestedType : type.nestedTypes()) {
      register(nestedType);
    }
  }

  
  ProtoTypeName resolveType(String packageName, DataType type) {
    switch (type.kind()) {
      case SCALAR:
        return ProtoTypeName.getScalar(type.toString());

      case NAMED:
        return resolveNamedType(packageName, type.toString());

      default:
        
        throw new UnsupportedOperationException("unexpected type: " + type);
    }
  }

  
  ProtoTypeName resolveNamedType(String packageName, String name) {
    WireType fullyQualified = protoTypeNames.get(name);
    if (fullyQualified != null) return fullyQualified.protoTypeName();

    if (packageName != null) {
      WireType samePackage = protoTypeNames.get(packageName + "." + name);
      if (samePackage != null) return samePackage.protoTypeName();
    }

    
    for (int i = enclosingTypes.size() - 1; i >= 0; i--) {
      WireType enclosingType = enclosingTypes.get(i);

      if (name.equals(enclosingType.protoTypeName().simpleName())) {
        return enclosingType.protoTypeName();
      }

      for (WireType peerType : enclosingType.nestedTypes()) {
        if (name.equals(peerType.protoTypeName().simpleName())) {
          return peerType.protoTypeName();
        }
      }
    }

    
    throw new IllegalArgumentException("unrecognized type name: " + name);
  }

  
  public Map<String, WireField> extensions(ProtoTypeName extensionType) {
    return extensionsMap.get(extensionType);
  }

  
  WireField dereference(String packageName, WireField self, String field) {
    if (field.startsWith("[") && field.endsWith("]")) {
      field = field.substring(1, field.length() - 1);
    }

    WireType wireType = protoTypeNames.get(self.type().toString());
    if (wireType instanceof WireMessage) {
      WireField messageField = ((WireMessage) wireType).field(field);
      if (messageField != null) {
        return messageField;
      }

      Map<String, WireField> typeExtensions = extensionsMap.get(self.type());
      WireField extensionField = typeExtensions.get(field);
      if (extensionField != null) {
        return extensionField;
      }

      WireField fullyQualifiedExtensionField = typeExtensions.get(packageName + "." + field);
      if (fullyQualifiedExtensionField != null) {
        return fullyQualifiedExtensionField;
      }
    }

    return null; 
  }

  
  Linker withMessage(WireMessage message) {
    return new Linker(this, message);
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumConstantElement;
import com.squareup.protoparser.EnumElement;
import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.MessageElement;
import com.squareup.protoparser.OneOfElement;
import com.squareup.protoparser.TypeElement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public abstract class WireType {
  public abstract ProtoTypeName protoTypeName();
  public abstract String documentation();
  public abstract Options options();
  public abstract List<WireType> nestedTypes();
  abstract void link(Linker linker);
  abstract void linkOptions(Linker linker);
  abstract WireType retainAll(Set<String> identifiers);

  static WireType get(ProtoTypeName protoTypeName, TypeElement type) {
    if (type instanceof EnumElement) {
      EnumElement enumElement = (EnumElement) type;

      List<WireEnumConstant> constants = new ArrayList<WireEnumConstant>();
      for (EnumConstantElement constant : enumElement.constants()) {
        constants.add(new WireEnumConstant(protoTypeName.packageName(), constant));
      }

      Options options = new Options(
          ProtoTypeName.ENUM_OPTIONS, protoTypeName.packageName(), enumElement.options());

      return new WireEnum(protoTypeName, enumElement, constants, options);

    } else if (type instanceof MessageElement) {
      MessageElement messageElement = (MessageElement) type;
      String packageName = protoTypeName.packageName();

      List<WireField> fields = new ArrayList<WireField>();
      for (FieldElement field : messageElement.fields()) {
        fields.add(new WireField(packageName, field));
      }

      List<WireOneOf> oneOfs = new ArrayList<WireOneOf>();
      for (OneOfElement oneOf : messageElement.oneOfs()) {
        oneOfs.add(new WireOneOf(packageName, oneOf));
      }

      List<WireType> nestedTypes = new ArrayList<WireType>();
      for (TypeElement nestedType : messageElement.nestedElements()) {
        nestedTypes.add(WireType.get(protoTypeName.nestedType(nestedType.name()), nestedType));
      }

      Options options = new Options(
          ProtoTypeName.MESSAGE_OPTIONS, protoTypeName.packageName(), messageElement.options());

      return new WireMessage(protoTypeName, messageElement, fields, oneOfs, nestedTypes, options);

    } else {
      throw new IllegalArgumentException("unexpected type: " + type.getClass());
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumConstantElement;

public final class WireEnumConstant {
  private final String packageName;
  private final EnumConstantElement element;
  private final Options options;

  WireEnumConstant(String packageName, EnumConstantElement element) {
    this.packageName = packageName;
    this.element = element;
    this.options = new Options(
        ProtoTypeName.ENUM_VALUE_OPTIONS, packageName, element.options());
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public int tag() {
    return element.tag();
  }

  public String documentation() {
    return element.documentation();
  }

  public Options options() {
    return options;
  }

  void linkOptions(Linker linker) {
    options.link(linker);
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.FieldElement;

public final class WireField {
  private final String packageName;
  private final FieldElement element;
  private final Options options;
  private ProtoTypeName type;

  WireField(String packageName, FieldElement element) {
    this.packageName = packageName;
    this.element = element;
    this.options = new Options(ProtoTypeName.FIELD_OPTIONS, packageName, element.options());
  }

  public String packageName() {
    return packageName;
  }

  public FieldElement.Label label() {
    return element.label();
  }

  public boolean isRepeated() {
    return label() == FieldElement.Label.REPEATED;
  }

  public boolean isOptional() {
    return label() == FieldElement.Label.OPTIONAL;
  }

  public boolean isRequired() {
    return label() == FieldElement.Label.REQUIRED;
  }

  public ProtoTypeName type() {
    return type;
  }

  public String name() {
    return element.name();
  }

  public int tag() {
    return element.tag();
  }

  public String documentation() {
    return element.documentation();
  }

  public Options options() {
    return options;
  }

  public boolean isDeprecated() {
    return element.isDeprecated();
  }

  public boolean isPacked() {
    return element.isPacked();
  }

  public Object getDefault() {
    return options.get("default");
  }

  void link(Linker linker) {
    type = linker.resolveType(packageName, element.type());
  }

  void linkOptions(Linker linker) {
    options.link(linker);
  }

  @Override public String toString() {
    return name();
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.squareup.protoparser.ExtendElement;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.ServiceElement;
import com.squareup.protoparser.TypeElement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public final class WireProtoFile {
  private final String sourcePath;
  private final ProtoFile protoFile;
  private final List<WireType> types;
  private final List<WireService> services;
  private final List<WireExtend> wireExtends;
  private final Options options;

  private WireProtoFile(String sourcePath, ProtoFile protoFile, List<WireType> types,
      List<WireService> services, List<WireExtend> wireExtends, Options options) {
    this.sourcePath = sourcePath;
    this.protoFile = protoFile;
    this.types = ImmutableList.copyOf(types);
    this.services = ImmutableList.copyOf(services);
    this.wireExtends = ImmutableList.copyOf(wireExtends);
    this.options = options;
  }

  public static WireProtoFile get(String sourcePath, ProtoFile protoFile) {
    String packageName = protoFile.packageName();

    List<WireType> types = new ArrayList<WireType>();
    for (TypeElement type : protoFile.typeElements()) {
      ProtoTypeName protoTypeName = ProtoTypeName.get(packageName, type.name());
      types.add(WireType.get(protoTypeName, type));
    }

    List<WireService> services = new ArrayList<WireService>();
    for (ServiceElement service : protoFile.services()) {
      ProtoTypeName protoTypeName = ProtoTypeName.get(packageName, service.name());
      services.add(WireService.get(protoTypeName, service));
    }

    List<WireExtend> wireExtends = new ArrayList<WireExtend>();
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      wireExtends.add(new WireExtend(packageName, extend));
    }

    Options options = new Options(
        ProtoTypeName.FILE_OPTIONS, packageName, protoFile.options());

    return new WireProtoFile(sourcePath, protoFile, types, services, wireExtends, options);
  }

  public String sourcePath() {
    return sourcePath;
  }

  
  public String name() {
    String result = sourcePath;

    int slashIndex = result.lastIndexOf('/');
    if (slashIndex != -1) {
      result = result.substring(slashIndex + 1);
    }

    if (result.endsWith(".proto")) {
      result = result.substring(0, result.length() - ".proto".length());
    }

    return result;
  }

  public String packageName() {
    return protoFile.packageName();
  }

  public List<WireType> types() {
    return types;
  }

  public List<WireService> services() {
    return services;
  }

  public List<WireExtend> wireExtends() {
    return wireExtends;
  }

  public Options options() {
    return options;
  }

  
  WireProtoFile retainAll(Set<String> identifiers) {
    List<WireType> retainedTypes = new ArrayList<WireType>();
    for (WireType type : types) {
      WireType retainedType = type.retainAll(identifiers);
      if (retainedType != null) {
        retainedTypes.add(retainedType);
      }
    }

    List<WireService> retainedServices = new ArrayList<WireService>();
    for (WireService service : services) {
      WireService retainedService = service.retainAll(identifiers);
      if (retainedService != null) {
        retainedServices.add(retainedService);
      }
    }

    return new WireProtoFile(
        sourcePath, protoFile, retainedTypes, retainedServices, wireExtends, options);
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.RpcElement;
import com.squareup.protoparser.ServiceElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

public final class WireService {
  private final ProtoTypeName protoTypeName;
  private final ServiceElement element;
  private final List<WireRpc> rpcs;
  private final Options options;

  private WireService(ProtoTypeName protoTypeName, ServiceElement element, List<WireRpc> rpcs,
      Options options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.rpcs = Collections.unmodifiableList(rpcs);
    this.options = options;
  }

  public static WireService get(ProtoTypeName protoTypeName, ServiceElement element) {
    List<WireRpc> rpcs = new ArrayList<WireRpc>();
    for (RpcElement rpc : element.rpcs()) {
      rpcs.add(new WireRpc(protoTypeName.packageName(), rpc));
    }

    Options options = new Options(
        ProtoTypeName.SERVICE_OPTIONS, protoTypeName.packageName(), element.options());

    return new WireService(protoTypeName, element, rpcs, options);
  }

  public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireRpc> rpcs() {
    return rpcs;
  }

  
  public WireRpc rpc(String name) {
    for (WireRpc rpc : rpcs) {
      if (rpc.name().equals(name)) {
        return rpc;
      }
    }
    return null;
  }

  public Options options() {
    return options;
  }

  void link(Linker linker) {
    for (WireRpc rpc : rpcs) {
      rpc.link(linker);
    }
  }

  void linkOptions(Linker linker) {
    for (WireRpc rpc : rpcs) {
      rpc.linkOptions(linker);
    }
    options.link(linker);
  }

  WireService retainAll(Set<String> identifiers) {
    String serviceName = protoTypeName.toString();
    if (identifiers.contains(serviceName)) {
      return this; 
    }

    List<WireRpc> retainedRpcs = new ArrayList<WireRpc>();
    for (WireRpc rpc : rpcs) {
      if (identifiers.contains(serviceName + '#' + rpc.name())) {
        retainedRpcs.add(rpc);
      }
    }

    
    if (!retainedRpcs.isEmpty()) {
      return new WireService(protoTypeName, element, retainedRpcs, options);
    }

    
    return null;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.OneOfElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class WireOneOf {
  private final String packageName;
  private final OneOfElement element;
  private final List<WireField> fields;

  WireOneOf(String packageName, OneOfElement element) {
    this.packageName = packageName;
    this.element = element;

    List<WireField> fields = new ArrayList<WireField>();
    for (FieldElement field : element.fields()) {
      fields.add(new WireField(packageName, field));
    }
    this.fields = Collections.unmodifiableList(fields);
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireField> fields() {
    return fields;
  }

  void link(Linker linker) {
    for (WireField field : fields) {
      field.link(linker);
    }
  }

  void linkOptions(Linker linker) {
    for (WireField field : fields) {
      field.linkOptions(linker);
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.RpcElement;

public final class WireRpc {
  private final String packageName;
  private final RpcElement element;
  private final Options options;
  private ProtoTypeName requestType;
  private ProtoTypeName responseType;

  WireRpc(String packageName, RpcElement element) {
    this.packageName = packageName;
    this.element = element;
    this.options = new Options(ProtoTypeName.METHOD_OPTIONS, packageName, element.options());
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public String documentation() {
    return element.documentation();
  }

  public ProtoTypeName requestType() {
    return requestType;
  }

  public ProtoTypeName responseType() {
    return responseType;
  }

  public Options options() {
    return options;
  }

  void link(Linker linker) {
    requestType = linker.resolveNamedType(packageName, element.requestType().name());
    responseType = linker.resolveNamedType(packageName, element.responseType().name());
  }

  void linkOptions(Linker linker) {
    options.link(linker);
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.squareup.protoparser.OptionElement;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Iterables.getOnlyElement;


public final class Options {
  private final ProtoTypeName optionType;
  private final String packageName;
  private final ImmutableList<OptionElement> optionElements;
  private ImmutableMap<WireField, Object> map;

  public Options(ProtoTypeName optionType, String packageName, List<OptionElement> elements) {
    this.optionType = optionType;
    this.packageName = packageName;
    this.optionElements = ImmutableList.copyOf(elements);
  }

  public String packageName() {
    return packageName;
  }

  
  public Map<WireField, Object> map() {
    return map;
  }

  public Object get(String name) {
    checkNotNull(name, "name");

    OptionElement found = null;
    for (OptionElement option : optionElements) {
      if (option.name().equals(name)) {
        if (found != null) {
          throw new IllegalStateException("Multiple options match name: " + name);
        }
        found = option;
      }
    }
    return found != null ? found.value() : null;
  }

  
  public boolean optionMatches(String namePattern, String valuePattern) {
    Matcher nameMatcher = Pattern.compile(namePattern).matcher("");
    Matcher valueMatcher = Pattern.compile(valuePattern).matcher("");
    for (OptionElement option : optionElements) {
      if (nameMatcher.reset(option.name()).matches()
          && valueMatcher.reset(String.valueOf(option.value())).matches()) {
        return true;
      }
    }
    return false;
  }

  void link(Linker linker) {
    Map<WireField, Object> map = new LinkedHashMap<WireField, Object>();
    for (OptionElement option : optionElements) {
      Map<WireField, Object> canonicalOption = canonicalizeOption(linker, optionType, option);
      if (canonicalOption != null) {
        map = union(map, canonicalOption);
      }
    }

    this.map = ImmutableMap.copyOf(map);
  }

  Map<WireField, Object> canonicalizeOption(
      Linker linker, ProtoTypeName extensionType, OptionElement option) {
    Map<String, WireField> extensionsForType = linker.extensions(extensionType);
    if (extensionsForType == null) {
      return null; 
    }

    String[] path = resolveFieldPath(option.name(), extensionsForType.keySet());
    if (path == null && packageName != null) {
      
      path = resolveFieldPath(packageName + "." + option.name(), extensionsForType.keySet());
    }
    if (path == null) {
      return null; 
    }

    Map<WireField, Object> result = new LinkedHashMap<WireField, Object>();
    Map<WireField, Object> last = result;

    WireField field = extensionsForType.get(path[0]);
    for (int i = 1; i < path.length; i++) {
      Map<WireField, Object> nested = new LinkedHashMap<WireField, Object>();
      last.put(field, nested);
      last = nested;
      field = linker.dereference(packageName, field, path[i]);
    }

    last.put(field, canonicalizeValue(linker, field, option.value()));
    return result;
  }

  
  static String[] resolveFieldPath(String name, Set<String> fullyQualifiedNames) {
    
    for (int i = 0; i < name.length(); i++) {
      i = name.indexOf('.', i);
      if (i == -1) i = name.length();

      String candidate = name.substring(0, i);
      if (fullyQualifiedNames.contains(candidate)) {
        String[] path = name.substring(i).split("\\.", -1);
        path[0] = name.substring(0, i);
        return path;
      }
    }

    return null;
  }

  private Object canonicalizeValue(Linker linker, WireField context, Object value) {
    if (value instanceof OptionElement) {
      ImmutableMap.Builder<WireField, Object> result = ImmutableMap.builder();
      OptionElement option = (OptionElement) value;
      WireField field = linker.dereference(packageName, context, option.name());
      result.put(field, canonicalizeValue(linker, field, option.value()));
      return coerceValueForField(context, result.build());
    }

    if (value instanceof Map) {
      ImmutableMap.Builder<WireField, Object> result = ImmutableMap.builder();
      for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
        String name = (String) entry.getKey();
        WireField field = linker.dereference(packageName, context, name);
        result.put(field, canonicalizeValue(linker, field, entry.getValue()));
      }
      return coerceValueForField(context, result.build());
    }

    if (value instanceof List) {
      ImmutableList.Builder<Object> result = ImmutableList.builder();
      for (Object element : (List<?>) value) {
        result.addAll((List) canonicalizeValue(linker, context, element));
      }
      return coerceValueForField(context, result.build());
    }

    if (value instanceof String) {
      return coerceValueForField(context, value);
    }

    throw new IllegalArgumentException("Unexpected option value: " + value);
  }

  private Object coerceValueForField(WireField context, Object value) {
    if (context.isRepeated()) {
      return value instanceof List ? value : ImmutableList.of(value);
    } else {
      return value instanceof List ? getOnlyElement((List) value) : value;
    }
  }

  
  @SuppressWarnings("unchecked")
  private Object union(Object a, Object b) {
    if (a instanceof List) {
      return union((List<?>) a, (List<?>) b);
    } else if (a instanceof Map) {
      return union((Map<WireField, Object>) a, (Map<WireField, Object>) b);
    } else {
      throw new IllegalArgumentException("Unable to union values: " + a + ", " + b);
    }
  }

  private Map<WireField, Object> union(Map<WireField, Object> a, Map<WireField, Object> b) {
    Map<WireField, Object> result = new LinkedHashMap<WireField, Object>(a);
    for (Map.Entry<WireField, Object> entry : b.entrySet()) {
      Object aValue = result.get(entry.getKey());
      Object bValue = entry.getValue();
      Object union = aValue != null ? union(aValue, bValue) : bValue;
      result.put(entry.getKey(), union);
    }
    return ImmutableMap.copyOf(result);
  }

  private ImmutableList<Object> union(List<?> a, List<?> b) {
    return ImmutableList.builder().addAll(a).addAll(b).build();
  }

  public ImmutableSet<WireField> fields() {
    ImmutableSet.Builder<WireField> result = ImmutableSet.builder();
    gatherFields(result, map);
    return result.build();
  }

  private void gatherFields(ImmutableSet.Builder<WireField> sink, Object o) {
    if (o instanceof Map) {
      for (Map.Entry<?, ?> entry : ((Map<?, ?>) o).entrySet()) {
        sink.add((WireField) entry.getKey());
        gatherFields(sink, entry.getValue());
      }
    } else if (o instanceof List) {
      for (Object e : (List) o) {
        gatherFields(sink, e);
      }
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.squareup.protoparser.ExtensionsElement;
import com.squareup.protoparser.MessageElement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public final class WireMessage extends WireType {
  private final ProtoTypeName protoTypeName;
  private final MessageElement element;
  private final List<WireField> fields;
  private final List<WireOneOf> oneOfs;
  private final List<WireType> nestedTypes;
  private final Options options;

  public WireMessage(ProtoTypeName protoTypeName, MessageElement element,
      List<WireField> fields, List<WireOneOf> oneOfs,
      List<WireType> nestedTypes, Options options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.fields = ImmutableList.copyOf(fields);
    this.oneOfs = ImmutableList.copyOf(oneOfs);
    this.nestedTypes = ImmutableList.copyOf(nestedTypes);
    this.options = options;
  }

  @Override public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  @Override public String documentation() {
    return element.documentation();
  }

  @Override public List<WireType> nestedTypes() {
    return nestedTypes;
  }

  @Override public Options options() {
    return options;
  }

  public List<WireField> fields() {
    return fields;
  }

  public boolean hasRequiredFields() {
    for (WireField field : fieldsAndOneOfFields()) {
      if (field.isRequired()) return true;
    }
    return false;
  }

  public List<WireField> fieldsAndOneOfFields() {
    ImmutableList.Builder<WireField> result = ImmutableList.builder();
    result.addAll(fields);
    for (WireOneOf oneOf : oneOfs) {
      result.addAll(oneOf.fields());
    }
    return result.build();
  }

  
  public WireField field(String name) {
    for (WireField field : fields) {
      if (field.name().equals(name)) {
        return field;
      }
    }
    return null;
  }

  public List<WireOneOf> oneOfs() {
    return oneOfs;
  }

  public List<ExtensionsElement> extensions() {
    return element.extensions();
  }

  void link(Linker linker) {
    linker = linker.withMessage(this);
    for (WireField field : fields) {
      field.link(linker);
    }
    for (WireOneOf oneOf : oneOfs) {
      oneOf.link(linker);
    }
    for (WireType type : nestedTypes) {
      type.link(linker);
    }
  }

  void linkOptions(Linker linker) {
    linker = linker.withMessage(this);
    for (WireType type : nestedTypes) {
      type.linkOptions(linker);
    }
    for (WireField field : fields) {
      field.linkOptions(linker);
    }
    for (WireOneOf oneOf : oneOfs) {
      oneOf.linkOptions(linker);
    }
    options.link(linker);
  }

  @Override WireType retainAll(Set<String> identifiers) {
    List<WireType> retainedNestedTypes = new ArrayList<WireType>();
    for (WireType nestedType : nestedTypes) {
      WireType retainedNestedType = nestedType.retainAll(identifiers);
      if (retainedNestedType != null) {
        retainedNestedTypes.add(retainedNestedType);
      }
    }

    
    if (identifiers.contains(protoTypeName.toString()) || !retainedNestedTypes.isEmpty()) {
      return new WireMessage(protoTypeName, element, fields, oneOfs, retainedNestedTypes, options);
    }

    
    return null;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumElement;
import java.util.Collections;
import java.util.List;
import java.util.Set;

public final class WireEnum extends WireType {
  private final ProtoTypeName protoTypeName;
  private final EnumElement element;
  private final List<WireEnumConstant> constants;
  private final Options options;

  WireEnum(ProtoTypeName protoTypeName, EnumElement element, List<WireEnumConstant> constants,
      Options options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.constants = Collections.unmodifiableList(constants);
    this.options = options;
  }

  @Override public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  @Override public String documentation() {
    return element.documentation();
  }

  @Override public Options options() {
    return options;
  }

  @Override public List<WireType> nestedTypes() {
    return Collections.emptyList(); 
  }

  public List<WireEnumConstant> constants() {
    return constants;
  }

  @Override void link(Linker linker) {
  }

  @Override void linkOptions(Linker linker) {
    options.link(linker);
    for (WireEnumConstant constant : constants) {
      constant.linkOptions(linker);
    }
  }

  @Override WireType retainAll(Set<String> identifiers) {
    return identifiers.contains(protoTypeName.toString()) ? this : null;
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


public final class Pruner {
  
  final Set<String> marks = new LinkedHashSet<String>();

  
  final Deque<String> queue = new ArrayDeque<String>();

  
  public List<WireProtoFile> retainRoots(List<WireProtoFile> protoFiles, Set<String> roots) {
    if (roots.isEmpty()) throw new IllegalArgumentException();
    if (!marks.isEmpty()) throw new IllegalStateException();

    Map<String, WireType> typesIndex = buildTypesIndex(protoFiles);
    Map<String, WireService> servicesIndex = buildServicesIndex(protoFiles);

    
    for (String s : roots) {
      mark(s);
    }

    
    for (WireProtoFile protoFile : protoFiles) {
      for (WireExtend extend : protoFile.wireExtends()) {
        markExtend(extend);
      }
      markOptions(protoFile.options());
    }

    
    for (String name; (name = queue.poll()) != null;) {
      if (ProtoTypeName.getScalar(name) != null) {
        continue; 
      }

      WireType type = typesIndex.get(name);
      if (type != null) {
        markType(type);
        continue;
      }

      WireService service = servicesIndex.get(name);
      if (service != null) {
        markService(service);
        continue;
      }

      
      int hash = name.indexOf('#');
      if (hash != -1) {
        String serviceName = name.substring(0, hash);
        String rpcName = name.substring(hash + 1);
        WireService partialService = servicesIndex.get(serviceName);
        if (partialService != null) {
          WireRpc rpc = partialService.rpc(rpcName);
          if (rpc != null) {
            markOptions(partialService.options());
            markRpc(rpc);
            continue;
          }
        }
      }

      throw new IllegalArgumentException("Unexpected type: " + name);
    }

    List<WireProtoFile> retained = new ArrayList<WireProtoFile>();
    for (WireProtoFile protoFile : protoFiles) {
      retained.add(protoFile.retainAll(marks));
    }

    return ImmutableList.copyOf(retained);
  }

  private static Map<String, WireType> buildTypesIndex(Collection<WireProtoFile> protoFiles) {
    Map<String, WireType> result = new LinkedHashMap<String, WireType>();
    for (WireProtoFile protoFile : protoFiles) {
      for (WireType type : protoFile.types()) {
        index(result, type);
      }
    }
    return ImmutableMap.copyOf(result);
  }

  private static void index(Map<String, WireType> typesByName, WireType type) {
    typesByName.put(type.protoTypeName().toString(), type);
    for (WireType nested : type.nestedTypes()) {
      index(typesByName, nested);
    }
  }

  private static Map<String, WireService> buildServicesIndex(Collection<WireProtoFile> protoFiles) {
    Map<String, WireService> result = new LinkedHashMap<String, WireService>();
    for (WireProtoFile protoFile : protoFiles) {
      for (WireService service : protoFile.services()) {
        result.put(service.protoTypeName().toString(), service);
      }
    }
    return ImmutableMap.copyOf(result);
  }

  private void mark(ProtoTypeName typeName) {
    mark(typeName.toString());
  }

  private void mark(String identifier) {
    if (marks.add(identifier)) {
      queue.add(identifier); 
    }
  }

  private void markExtend(WireExtend extend) {
    mark(extend.protoTypeName());
    markFields(extend.fields());
  }

  private void markType(WireType type) {
    markOptions(type.options());

    ProtoTypeName enclosingTypeName = type.protoTypeName().enclosingTypeName();
    if (enclosingTypeName != null) {
      mark(enclosingTypeName);
    }

    for (WireType nestedType : type.nestedTypes()) {
      mark(nestedType.protoTypeName());
    }

    if (type instanceof WireMessage) {
      markMessage((WireMessage) type);
    } else if (type instanceof WireEnum) {
      markEnum((WireEnum) type);
    }
  }

  private void markMessage(WireMessage message) {
    markFields(message.fields());
    for (WireOneOf oneOf : message.oneOfs()) {
      markFields(oneOf.fields());
    }
  }

  private void markEnum(WireEnum wireEnum) {
    markOptions(wireEnum.options());
    for (WireEnumConstant constant : wireEnum.constants()) {
      markOptions(constant.options());
    }
  }

  private void markFields(List<WireField> fields) {
    for (WireField field : fields) {
      markField(field);
    }
  }

  private void markField(WireField field) {
    markOptions(field.options());
    mark(field.type());
  }

  private void markOptions(Options options) {
    for (WireField field : options.fields()) {
      markField(field);
    }
  }

  private void markService(WireService service) {
    markOptions(service.options());
    for (WireRpc rpc : service.rpcs()) {
      markRpc(rpc);
    }
  }

  private void markRpc(WireRpc rpc) {
    markOptions(rpc.options());
    mark(rpc.requestType());
    mark(rpc.responseType());
  }
}

<code block>

package com.squareup.wire.model;

import java.util.LinkedHashSet;
import java.util.Set;
import org.junit.Test;

import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

public final class OptionsTest {
  @Test public void resolveFieldPathMatchesFirstSegment() throws Exception {
    assertEquals(
        asList("a", "b", "c", "d"),
        asList(Options.resolveFieldPath("a.b.c.d", set("a", "z", "y"))));
  }

  @Test public void resolveFieldPathMatchesMultipleSegments() throws Exception {
    assertEquals(
        asList("a.b", "c", "d"),
        asList(Options.resolveFieldPath("a.b.c.d", set("a.b", "z.b", "y.b"))));
  }

  @Test public void resolveFieldPathMatchesAllSegments() throws Exception {
    assertEquals(
        asList("a.b.c.d"),
        asList(Options.resolveFieldPath("a.b.c.d", set("a.b.c.d", "z.b.c.d"))));
  }

  @Test public void resolveFieldPathMatchesOnlySegment() throws Exception {
    assertEquals(
        asList("a"),
        asList(Options.resolveFieldPath("a", set("a", "b"))));
  }

  @Test public void resolveFieldPathDoesntMatch() throws Exception {
    assertNull(Options.resolveFieldPath("a.b", set("c", "d")));
  }

  private Set<String> set(String... elements) {
    return new LinkedHashSet<String>(asList(elements));
  }
}

<code block>

package com.squareup.wire;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javawriter.JavaWriter;
import com.squareup.protoparser.DataType.ScalarType;
import com.squareup.protoparser.EnumElement;
import com.squareup.protoparser.ExtendElement;
import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.MessageElement;
import com.squareup.protoparser.OneOfElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.RpcElement;
import com.squareup.protoparser.ServiceElement;
import com.squareup.protoparser.TypeElement;
import com.squareup.wire.java.JavaGenerator;
import com.squareup.wire.java.TypeWriter;
import com.squareup.wire.model.Linker;
import com.squareup.wire.model.Loader;
import com.squareup.wire.model.Pruner;
import com.squareup.wire.model.WireProtoFile;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import okio.ByteString;

import static com.squareup.wire.Message.Datatype;
import static com.squareup.wire.Message.Label;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;


public class WireCompiler {
  static final boolean JAVAPOET = false;
  static final String LINE_WRAP_INDENT = "    ";

  
  static final Set<String> DEFAULT_FIELD_OPTION_KEYS =
      new LinkedHashSet<String>(Arrays.asList("default", "deprecated", "packed"));

  private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
  private static final String CODE_GENERATED_BY_WIRE =
      "Code generated by Wire protocol buffer compiler, do not edit.";

  private final String repoPath;
  private final IO io;
  private final Set<String> typesToEmit = new LinkedHashSet<String>();
  private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
  private final Set<String> javaSymbols = new LinkedHashSet<String>();
  private final Set<String> enumTypes = new LinkedHashSet<String>();
  private final Map<String, String> enumDefaults = new LinkedHashMap<String, String>();
  private final Map<String, ExtensionInfo> extensionInfo =
      new LinkedHashMap<String, ExtensionInfo>();
  private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();

  private final List<String> extensionClasses = new ArrayList<String>();
  private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);
  private final CommandLineOptions options;

  private final WireLogger log;

  private ProtoFile protoFile;
  private String sourceFileName;
  private String protoFileName;
  private String typeBeingGenerated = "";

  private Constructor<?> serviceWriterConstructor;

  
  public static void main(String... args) {
    try {
      new WireCompiler(new CommandLineOptions(args)).compile();
    } catch (WireException e) {
      System.err.print("Fatal: ");
      e.printStackTrace(System.err);
      System.exit(1);
    }
  }

  private static Constructor<?> loadServiceWriter(String serviceWriterClassName)
      throws WireException {
    Class<?> serviceWriterClass;
    try {
      serviceWriterClass = Class.forName(serviceWriterClassName);
    } catch (ClassNotFoundException e) {
      throw new WireException("Unable to load ServiceWriter class "
          + serviceWriterClassName + ".", e);
    }

    if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
      throw new WireException(
          "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
    }

    try {
      return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
    } catch (NoSuchMethodException e) {
      throw new WireException("ServiceWriter class "
          + serviceWriterClassName
          + " needs a constructor 'public "
          + serviceWriterClassName
          + "(JavaWriter writer, List<String> options)'.", e);
    }
  }

  @Deprecated
  public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions)
      throws WireException {
    this(new CommandLineOptions(protoPath, outputDirectory, sourceFileNames, roots, registryClass,
        emitOptions, new LinkedHashSet<String>(enumOptions),
        serviceWriterConstructor == null ? null : serviceWriterConstructor.getName(),
        serviceWriterOptions, false, false));
  }

  WireCompiler(CommandLineOptions options) throws WireException {
    this(options, new IO.FileIO(), new ConsoleWireLogger(options.quiet));
  }

  WireCompiler(CommandLineOptions options, IO io, WireLogger logger) throws WireException {
    this.options = options;
    this.io = io;
    this.log = logger;

    String protoPath = options.protoPath;
    if (options.javaOut == null) {
      throw new WireException("Must specify " + CommandLineOptions.JAVA_OUT_FLAG + " flag");
    }
    if (options.protoPath == null) {
      protoPath = System.getProperty("user.dir");
      System.err.println(
          CommandLineOptions.PROTO_PATH_FLAG + " flag not specified, using current dir "
              + protoPath);
    }
    if (options.serviceWriter != null) {
      serviceWriterConstructor =
          WireCompiler.loadServiceWriter(options.serviceWriter);
    }
    this.repoPath = protoPath;
    this.typesToEmit.addAll(options.roots);
  }

  public void compile() throws WireException {
    if (JAVAPOET) {
      compileWithJavaPoet();
      return;
    }

    Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();

    for (String sourceFilename : options.sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      try {
        ProtoFile protoFile = io.parse(sourcePath);
        parsedFiles.put(sourcePath, protoFile);
        loadSymbols(protoFile);
      } catch (IOException e) {
        throw new WireException("Error loading symbols for " + sourcePath, e);
      }
    }

    if (!typesToEmit.isEmpty()) {
      log.info("Analyzing dependencies of root types.");
      findDependencies(parsedFiles.values());
    }

    for (Map.Entry<String, ProtoFile> entry : parsedFiles.entrySet()) {
      this.sourceFileName = entry.getKey();
      this.protoFile = entry.getValue();
      this.protoFileName = protoFileName(protoFile.filePath());
      log.info("Compiling proto source file " + sourceFileName);
      try {
        compileOne();
      } catch (IOException e) {
        throw new WireException("Error compiling " + entry.getKey(), e);
      }
    }

    if (options.registryClass != null) {
      int packageClassSep = options.registryClass.lastIndexOf(".");
      String javaPackage = options.registryClass.substring(0, packageClassSep);
      String className = options.registryClass.substring(packageClassSep + 1);
      OutputArtifact artifact = new OutputArtifact(options.javaOut, javaPackage, className);
      log.artifact(artifact);
      if (!options.dryRun) {
        try {
          emitRegistry(artifact);
        } catch (IOException e) {
          throw new WireException("Error emitting registry class " + options.registryClass, e);
        }
      }
    }
  }

  boolean shouldEmitOptions() {
    return options.emitOptions;
  }

  Set<String> enumOptions() {
    return options.enumOptions;
  }

  ProtoFile getProtoFile() {
    return protoFile;
  }

  OptionsMapMaker getOptionsMapMaker() {
    return optionsMapMaker;
  }

  String getEnumDefault(String fullyQualifiedName) {
    return enumDefaults.get(fullyQualifiedName);
  }

  FieldInfo getField(String dollarName) {
    return fieldMap.get(dollarName);
  }

  String javaName(ProtoFile protoFile, MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(protoFile, javaName(fullyQualifiedName(protoFile, messageType, type)));
  }

  boolean fullyQualifiedNameIsOutsidePackage(String fqName) {
    return fqName != null && !getJavaPackage().equals(getPackageFromFullyQualifiedJavaName(fqName));
  }

  String prefixWithPackageName(String name) {
    return prefixWithPackageName(protoFile, name);
  }

  boolean hasFields(TypeElement type) {
    return type instanceof MessageElement && !allFields((MessageElement) type).isEmpty();
  }

  boolean hasExtensions(MessageElement messageType) {
    return !messageType.extensions().isEmpty();
  }

  String getTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? name : name.substring(index + 1);
  }

  ExtensionInfo getExtension(String name) {
    return extensionInfo.get(name);
  }

  String getInitializerForType(Object initialValue, String javaTypeName) {
    if ("Boolean".equals(javaTypeName)) {
      return initialValue == null ? "false" : String.valueOf(initialValue);
    } else if ("Integer".equals(javaTypeName)) {
      return initialValue == null ? "0" : toInt(String.valueOf(initialValue));
    } else if ("Long".equals(javaTypeName)) {
      return initialValue == null ? "0L" : toLong(String.valueOf(initialValue));
    } else if ("Float".equals(javaTypeName)) {
      return initialValue == null ? "0F" : String.valueOf(initialValue) + "F";
    } else if ("Double".equals(javaTypeName)) {
      return initialValue == null ? "0D" : String.valueOf(initialValue) + "D";
    } else if ("String".equals(javaTypeName)) {
      return quoteString((String) initialValue);
    } else if ("ByteString".equals(javaTypeName)) {
      if (initialValue == null) {
        return "ByteString.EMPTY";
      } else {
        return "ByteString.decodeBase64(\"" + ByteString.of(
            String.valueOf(initialValue).getBytes(ISO_8859_1)).base64() + "\")";
      }
    } else {
      throw new WireCompilerException(javaTypeName + " is not an allowed scalar type");
    }
  }

  
  boolean isEnum(String type) {
    return enumTypes.contains(type);
  }

  String javaName(MessageElement messageType, String type) {
    String scalarType = TypeInfo.scalarType(type);
    return scalarType != null ? scalarType
        : shortenJavaName(javaName(fullyQualifiedName(messageType, type)));
  }

  String javaName(String fqName) {
    return javaSymbolMap.get(fqName);
  }

  String fullyQualifiedName(TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String fullyQualifiedName(String fqName, String type) {
    return fullyQualifiedName(protoFile, fqName, type);
  }

  String shortenJavaName(String fullyQualifiedName) {
    return shortenJavaName(protoFile, fullyQualifiedName);
  }

  boolean isRedacted(OptionElement option) {
    return option.name().endsWith(".redacted") && "true".equals(String.valueOf(option.value()));
  }

  private void compileOne() throws IOException {
    typeBeingGenerated = "";

    if (hasExtends()) {
      OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
          "Ext_" + protoFileName);
      log.artifact(artifact);

      if (!options.dryRun) {
        emitExtensionClass(artifact);
        extensionClasses.add(artifact.fullClassName());
      }
    }

    for (TypeElement type : protoFile.typeElements()) {
      if (shouldEmitType(type.qualifiedName())) {
        String savedType = typeBeingGenerated;
        typeBeingGenerated += type.name() + ".";
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            type.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitMessageClass(type, artifact);
        }
        typeBeingGenerated = savedType;
      }
    }

    for (ServiceElement service : protoFile.services()) {
      if (shouldEmitService(service.qualifiedName())) {
        ServiceElement.Builder serviceBuilder = ServiceElement.builder()
            .name(service.name())
            .qualifiedName(service.qualifiedName())
            .documentation(service.documentation())
            .addOptions(service.options());
        for (RpcElement method : service.rpcs()) {
          if (shouldEmitServiceMethod(service.qualifiedName(), method.name())) {
            serviceBuilder.addRpc(method);
          }
        }

        ServiceElement limitedService = serviceBuilder.build();
        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
            service.name());
        log.artifact(artifact);
        if (!options.dryRun) {
          emitServiceInterface(limitedService, artifact);
        }
      }
    }
  }

  private boolean hasFieldOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          for (OptionElement option : field.options()) {
            if (!WireCompiler.DEFAULT_FIELD_OPTION_KEYS.contains(option.name())) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  private boolean hasMessageOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private boolean hasEnumOption(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement && !type.options().isEmpty()) {
        return true;
      }
    }
    return false;
  }

  private void getTypes(TypeElement parent, List<TypeElement> types) {
    types.add(parent);
    for (TypeElement nestedType : parent.nestedElements()) {
      getTypes(nestedType, types);
    }
  }

  private void emitRegistry(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitPackage(artifact.javaPackage());

      writer.emitImports("java.util.List");
      writer.emitEmptyLine();

      int extensionsCount = extensionClasses.size();
      if (extensionsCount == 0) {
        writer.emitStaticImports("java.util.Collections.emptyList");
      } else {
        writer.emitStaticImports("java.util.Arrays.asList",
            "java.util.Collections.unmodifiableList");
      }
      writer.emitEmptyLine();
      writer.beginType(artifact.className(), "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      String classes;
      if (extensionsCount == 0) {
        classes = "emptyList()";
      } else {
        StringBuilder sb = new StringBuilder("unmodifiableList(asList(\n");
        for (int i = 0; i < extensionsCount; i++) {
          sb.append(writer.compressType(extensionClasses.get(i)));
          sb.append(".class");
          if (i < extensionsCount - 1) {
            sb.append(",\n");
          }
        }
        sb.append("))");
        classes = sb.toString();
      }

      writer.emitAnnotation("SuppressWarnings(\"unchecked\")");

      String wildcard = extensionsCount == 1 ? extensionClasses.get(0) : "?";
      String listType = "List<Class<" + wildcard + ">>";
      writer.emitField(listType, "EXTENSIONS", EnumSet.of(PUBLIC, STATIC, FINAL), classes);
      writer.emitEmptyLine();

      
      writer.beginMethod(null, artifact.className(), EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private boolean shouldEmitType(String name) {
    return typesToEmit.isEmpty() || typesToEmit.contains(name);
  }

  private boolean shouldEmitService(String serviceName) {
    if (typesToEmit.isEmpty()) {
      return true;
    }
    for (String type : typesToEmit) {
      if (type.equals(serviceName) || type.startsWith(serviceName + "#")) {
        return true;
      }
    }
    return false;
  }

  private boolean shouldEmitServiceMethod(String serviceName, String method) {
    if (method == null) {
      throw new IllegalArgumentException("No method specified");
    }
    return typesToEmit.isEmpty() 
        || typesToEmit.contains(serviceName) 
        || typesToEmit.contains(serviceName + "#" + method);
  }

  private void findDependencies(Collection<ProtoFile> protoFiles) throws WireException {
    Set<String> loadedDependencies = new LinkedHashSet<String>();
    int count = typesToEmit.size();
    while (true) {
      for (ProtoFile protoFile : protoFiles) {
        findDependenciesHelper(protoFile, loadedDependencies);
      }
      int newCount = typesToEmit.size();
      if (newCount == count) {
        break;
      }
      count = newCount;
    }
  }

  private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
      throws WireException {
    
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        try {
          ProtoFile dependencyFile = io.parse(dep);
          loadSymbols(dependencyFile);
        } catch (IOException e) {
          throw new WireException("Error loading symbols for " + dep, e);
        }
        loadedDependencies.add(dependency);
      }
    }

    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String typeName = extend.qualifiedName();
      typesToEmit.add(typeName);
      for (FieldElement field : extend.fields()) {
        
        
        
        String fieldTypeName = typeIsComplete(field.type().toString()) ? field.type().toString()
            : prefixWithPackageName(protoFile, field.type().toString());
        typesToEmit.add(fieldTypeName);
      }
    }

    addDependencies(protoFile.typeElements(), getJavaPackage(protoFile) + ".");
    addDependencies(protoFile.services());
  }

  
  private void addDependencies(List<ServiceElement> services) {
    for (ServiceElement service : services) {
      String fqName = service.qualifiedName();
      if (shouldEmitService(fqName)) {
        for (RpcElement rpc : service.rpcs()) {
          if (shouldEmitServiceMethod(fqName, rpc.name())) {
            addDependencyBranch(fullyQualifiedName(fqName, rpc.requestType().toString()));
            addDependencyBranch(fullyQualifiedName(fqName, rpc.responseType().toString()));
          }
        }
      }
    }
  }

  
  private void addDependencies(List<TypeElement> types, String javaPrefix) {
    for (TypeElement type : types) {
      String name = type.name();
      String fqName = type.qualifiedName();
      if (type instanceof MessageElement && typesToEmit.contains(fqName)) {
        for (FieldElement field : allFields((MessageElement) type)) {
          String fieldType = field.type().toString();
          if (!TypeInfo.isScalar(fieldType)) {
            String fqFieldType = fullyQualifiedName(fqName, field.type().toString());
            addDependencyBranch(fqFieldType);
          }
        }
      }
      addDependencies(type.nestedElements(), javaPrefix + name + ".");
    }
  }

  
  private void addDependencyBranch(String name) {
    while (typeIsComplete(name)) {
      typesToEmit.add(name);
      name = removeTrailingSegment(name);
    }
  }

  private String removeTrailingSegment(String name) {
    int index = name.lastIndexOf('.');
    return index == -1 ? "" : name.substring(0, index);
  }

  public String getTypeBeingGenerated() {
    
    return typeBeingGenerated.substring(0, typeBeingGenerated.length() - 1);
  }

  private enum LoadSymbolsPass {
    LOAD_TYPES, LOAD_FIELDS
  }

  private void loadSymbols(ProtoFile protoFile) throws IOException {
    
    
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_TYPES);
    loadSymbolsHelper(protoFile, new LinkedHashSet<String>(), LoadSymbolsPass.LOAD_FIELDS);
  }

  
  private void loadSymbolsHelper(ProtoFile protoFile, Set<String> loadedDependencies,
      LoadSymbolsPass pass) throws IOException {
    
    for (String dependency : protoFile.dependencies()) {
      if (!loadedDependencies.contains(dependency)) {
        String dep = repoPath + File.separator + dependency;
        ProtoFile dependencyFile = io.parse(dep);
        loadSymbolsHelper(dependencyFile, loadedDependencies, pass);
        loadedDependencies.add(dependency);
      }
    }

    addTypes(protoFile.typeElements(), getJavaPackage(protoFile) + ".", pass);
    addExtensions(protoFile);
  }

  private void addExtensions(ProtoFile protoFile) {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(protoFile, null, fieldType);
        if (type == null) {
          type = javaName(protoFile, null, prefixWithPackageName(protoFile, fieldType));
        }
        type = shortenJavaName(protoFile, type);
        String fqName = prefixWithPackageName(protoFile, field.name());
        String fqType;

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum =
            !isScalar && isEnum(fullyQualifiedName(protoFile, (String) null, fieldType));
        if (isScalar) {
          type = field.type().toString();
          fqType = type;
        } else if (isEnum) {
          
          type = fullyQualifiedName(protoFile, (String) null, fieldType);
          fqType = type;
        } else {
          fqType = fullyQualifiedName(protoFile, (String) null, fieldType);
        }

        String location = protoFileName(protoFile.filePath());
        String fqLocation = getJavaPackage(protoFile) + ".Ext_" + location;
        ExtensionInfo info =
            new ExtensionInfo(type, fqType, location, fqLocation, field.label());
        extensionInfo.put(fqName, info);
      }
    }
  }

  
  String getJavaPackage(ProtoFile protoFile) {
    OptionElement javaPackage = OptionElement.findByName(protoFile.options(), "java_package");
    if (javaPackage != null) {
      return (String) javaPackage.value();
    }
    return protoFile.packageName() == null ? "" : protoFile.packageName();
  }

  String getJavaPackage() {
    return getJavaPackage(protoFile);
  }

  private void addTypes(List<TypeElement> types, String javaPrefix, LoadSymbolsPass pass) {
    for (TypeElement type : types) {
      String name = type.name();
      if (pass == LoadSymbolsPass.LOAD_TYPES) {
        String fqName = type.qualifiedName();
        javaSymbolMap.put(fqName, javaPrefix + name);
        if (type instanceof EnumElement) {
          EnumElement enumType = (EnumElement) type;
          if (!enumTypes.contains(fqName)) {
            enumTypes.add(fqName);
            enumDefaults.put(fqName, enumType.constants().get(0).name());
          }
        }
      } else if (type instanceof MessageElement) {
        addFields((MessageElement) type);
      }
      addTypes(type.nestedElements(), javaPrefix + name + ".", pass);
    }
  }

  private void addFields(MessageElement messageType) {
    for (FieldElement field : allFields(messageType)) {
      String fieldType = field.type().toString();
      String fqMessageName = messageType.qualifiedName();
      String key = fqMessageName + "$" + field.name();
      fieldMap.put(key, new FieldInfo(
          TypeInfo.isScalar(fieldType) ? fieldType : fullyQualifiedName(fqMessageName, fieldType),
          field.label()));
    }
  }

  private String fullyQualifiedName(ProtoFile protoFile, TypeElement scope, String type) {
    String fqName = scope == null ? null : scope.qualifiedName();
    return fullyQualifiedName(protoFile, fqName, type);
  }

  private String fullyQualifiedName(ProtoFile protoFile, String fqName, String type) {
    if (typeIsComplete(type)) {
      return type;
    } else {
      String prefix = fqName == null ? protoFile.packageName() : fqName;
      while (!prefix.isEmpty()) {
        String fqname = prefix + "." + type;
        if (typeIsComplete(fqname)) return fqname;
        prefix = removeTrailingSegment(prefix);
      }
    }
    throw new WireCompilerException(
        "Unknown type " + type + " in type " + (fqName == null ? "<unknown>" : fqName));
  }

  private String shortenJavaName(ProtoFile protoFile, String fullyQualifiedName) {
    if (fullyQualifiedName == null) return null;
    String javaTypeBeingGenerated = getJavaPackage(protoFile) + "." + typeBeingGenerated;
    if (fullyQualifiedName.startsWith(javaTypeBeingGenerated)) {
      return fullyQualifiedName.substring(javaTypeBeingGenerated.length());
    }

    
    for (String javaSymbol : javaSymbolMap.values()) {
      if (fullyQualifiedName.startsWith(javaSymbol)) {
        
        String pkgPrefix = getPackageFromFullyQualifiedJavaName(fullyQualifiedName) + '.';
        return fullyQualifiedName.substring(pkgPrefix.length());
      }
    }

    return fullyQualifiedName;
  }

  private String protoFileName(String path) {
    int slashIndex = path.lastIndexOf('/');
    if (slashIndex != -1) {
      path = path.substring(slashIndex + 1);
    }
    if (path.endsWith(".proto")) {
      path = path.substring(0, path.length() - ".proto".length());
    }
    return path;
  }

  private void emitMessageClass(TypeElement type, OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName.replace("\\", "\\\\"));
      writer.emitPackage(getJavaPackage());

      List<TypeElement> types = new ArrayList<TypeElement>();
      getTypes(type, types);
      boolean hasMessage = hasMessage(types);
      boolean hasExtensions = hasExtensions(Collections.singletonList(type));

      Set<String> imports = new LinkedHashSet<String>();
      if (hasMessage) {
        imports.add("com.squareup.wire.Message");
      }
      if (hasMessage || hasExtensions) {
        if (hasFields(type)) {
          imports.add("com.squareup.wire.ProtoField");
        }
      }
      if (hasBytesField(types)) {
        imports.add("okio.ByteString");
      }
      if (hasEnum(types)) {
        imports.add("com.squareup.wire.ProtoEnum");
      }
      if (hasRepeatedField(types)) {
        imports.add("java.util.Collections");
        imports.add("java.util.List");
      }
      if (hasExtensions) {
        imports.add("com.squareup.wire.ExtendableMessage");
        imports.add("com.squareup.wire.Extension");
      }
      if (options.emitOptions) {
        if (hasFieldOption(types)) {
          imports.add("com.google.protobuf.FieldOptions");
        }
        if (hasMessageOption(types)) {
          imports.add("com.google.protobuf.MessageOptions");
        }
        if (hasEnumOption(types)) {
          imports.add("com.google.protobuf.EnumOptions");
        }
      }

      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(type, externalTypes);

      Map<String, ?> optionsMap = null;
      if (options.emitOptions) {
        if (type instanceof MessageElement) {
          optionsMap = optionsMapMaker.createMessageOptionsMap((MessageElement) type);
          optionsMapMaker.getOptionTypes(optionsMap, externalTypes);

          for (FieldElement field : allFields((MessageElement) type)) {
            Map<String, ?> fieldOptionsMap =
                optionsMapMaker.createFieldOptionsMap((MessageElement) type, field.options());
            optionsMapMaker.getOptionTypes(fieldOptionsMap, externalTypes);
          }
        }
      }
      imports.addAll(externalTypes);

      
      Collection<Datatype> datatypes = new TreeSet<Datatype>(Datatype.ORDER_BY_NAME);
      Collection<Label> labels = new TreeSet<Label>(Label.ORDER_BY_NAME);
      getDatatypesAndLabels(type, datatypes, labels);
      
      labels.remove(Label.OPTIONAL);

      MessageWriter messageWriter = new MessageWriter(this);
      messageWriter.emitHeader(writer, imports, datatypes, labels);
      messageWriter.emitType(writer, type, protoFile.packageName() + ".", optionsMap, true);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitServiceInterface(ServiceElement service, OutputArtifact artifact)
      throws IOException {
    if (serviceWriterConstructor == null) return;
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);
      ServiceWriter serviceWriter;
      try {
        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
            new ArrayList<String>(options.serviceWriterOptions));
      } catch (Exception e) {
        throw new IllegalStateException(
            "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
                .getName() + ": " + e);
      }

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(artifact.javaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      List<String> externalTypes = new ArrayList<String>();
      getExternalTypes(service, externalTypes);
      imports.addAll(externalTypes);

      serviceWriter.emitService(service, imports);
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void getExternalTypes(TypeElement parent, List<String> types) {
    if (parent instanceof MessageElement) {
      MessageElement messageType = (MessageElement) parent;
      for (FieldElement field : allFields(messageType)) {
        String fqName = fullyQualifiedJavaName(messageType, field.type().toString());
        if (fqName == null) {
          continue;
        }
        if (fullyQualifiedNameIsOutsidePackage(fqName)) {
          fqName = getTopLevelMessageName(fqName);
          types.add(fqName);
        }
        String parentType = removeTrailingSegment(fqName);
        if (javaTypeIsComplete(parentType) && fullyQualifiedNameIsOutsidePackage(parentType)) {
          types.add(parentType);
        }
      }
    }
    for (TypeElement nestedType : parent.nestedElements()) {
      getExternalTypes(nestedType, types);
    }
  }

  
  private String getTopLevelMessageName(String fqName) {
    
    String parentType = removeTrailingSegment(fqName);
    while (!parentType.isEmpty()
        && javaTypeIsComplete(parentType)
        && fullyQualifiedNameIsOutsidePackage(parentType)) {
      fqName = parentType;
      parentType = removeTrailingSegment(parentType);
    }
    return fqName;
  }

  private void getExternalTypes(ServiceElement service, List<String> types) {
    for (RpcElement rpc : service.rpcs()) {
      addType(service, rpc.requestType().toString(), types);
      addType(service, rpc.responseType().toString(), types);
    }
  }

  private void addType(ServiceElement service, String method, List<String> types) {
    String serviceFQName = service.qualifiedName();
    String servicePackage =
        serviceFQName.substring(0, serviceFQName.length() - service.name().length() - 1);
    String fqName = javaName(fullyQualifiedName(servicePackage, method));
    if (fullyQualifiedNameIsOutsidePackage(fqName)) {
      types.add(fqName);
    }
  }

  private String getPackageFromFullyQualifiedJavaName(String fqName) {
    while (javaSymbolMap.containsValue(fqName)) {
      fqName = removeTrailingSegment(fqName);
    }
    return fqName;
  }

  private List<String> getExtensionTypes() {
    List<String> extensionClasses = new ArrayList<String>();
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fqName = fullyQualifiedJavaName(null, extend.qualifiedName());
      if (fullyQualifiedNameIsOutsidePackage(fqName)) {
        extensionClasses.add(fqName);
      }
      for (FieldElement field : extend.fields()) {
        String fqFieldType = fullyQualifiedJavaName(null, field.type().toString());
        if (fullyQualifiedNameIsOutsidePackage(fqFieldType)) {
          extensionClasses.add(fqFieldType);
        }
      }
    }
    return extensionClasses;
  }

  private boolean hasExtends() {
    List<ExtendElement> declarations = protoFile.extendDeclarations();
    if (!shouldEmitOptions()) {
      for (ExtendElement declaration : declarations) {
        String name = declaration.qualifiedName();
        if (!isFieldOptions(name) && !isMessageOptions(name)) {
          return true;
        }
      }
    }
    return !declarations.isEmpty();
  }

  private void emitExtensionClass(OutputArtifact artifact) throws IOException {
    JavaWriter writer = null;
    try {
      writer = io.getJavaWriter(artifact);

      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
      writer.emitSingleLineComment("Source file: %s", sourceFileName);
      writer.emitPackage(getJavaPackage());

      Set<String> imports = new LinkedHashSet<String>();
      if (hasByteStringExtension()) {
        imports.add("okio.ByteString");
      }
      imports.add("com.squareup.wire.Extension");
      if (hasRepeatedExtension()) {
        imports.add("java.util.List");
      }
      List<String> extensionTypes = getExtensionTypes();

      if (shouldEmitOptions()) {
        imports.addAll(extensionTypes);
      } else {
        for (String extensionType : extensionTypes) {
          if (!isOptionType(extensionType)) {
            imports.add(extensionType);
          }
        }
      }
      writer.emitImports(imports);
      writer.emitEmptyLine();

      String className = "Ext_" + protoFileName;
      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
      writer.emitEmptyLine();

      
      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
      writer.endMethod();
      writer.emitEmptyLine();

      emitExtensions(writer);
      writer.endType();
    } finally {
      if (writer != null) {
        writer.close();
      }
    }
  }

  private void emitExtensions(JavaWriter writer) throws IOException {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      String fullyQualifiedName = extend.qualifiedName();
      if (!shouldEmitOptions() && isOptionType(fullyQualifiedName)) {
        continue;
      }
      String javaName = javaName(null, fullyQualifiedName);
      String name = shortenJavaName(javaName);
      for (FieldElement field : extend.fields()) {
        String fieldType = field.type().toString();
        String type = javaName(null, fieldType);
        if (type == null) {
          type = javaName(null, prefixWithPackageName(fieldType));
        }
        type = shortenJavaName(type);
        String initialValue;
        String className = writer.compressType(name);
        String extensionName = field.name();
        String fqName = prefixWithPackageName(field.name());
        int tag = field.tag();

        boolean isScalar = TypeInfo.isScalar(fieldType);
        boolean isEnum = !isScalar && isEnum(fullyQualifiedName((String) null, fieldType));
        String labelString = getLabelString(field, isEnum);
        if (isScalar) {
          initialValue = String.format("Extension%n"
              + ".%1$sExtending(%2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", field.type(), className, fqName, tag, labelString);
        } else if (isEnum) {
          initialValue = String.format("Extension%n"
              + ".enumExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        } else {
          initialValue = String.format("Extension%n"
              + ".messageExtending(%1$s.class, %2$s.class)%n"
              + ".setName(\"%3$s\")%n"
              + ".setTag(%4$d)%n"
              + ".build%5$s()", type, className, fqName, tag, labelString);
        }

        if (FieldInfo.isRepeated(field)) {
          type = "List<" + type + ">";
        }
        writer.emitField("Extension<" + name + ", " + type + ">", extensionName,
            EnumSet.of(PUBLIC, STATIC, FINAL), initialValue);
      }
    }
  }

  
  private static boolean isOptionType(String fullyQualifiedName) {
    return (isMessageOptions(fullyQualifiedName) || isFieldOptions(fullyQualifiedName));
  }

  
  private static boolean isFieldOptions(String name) {
    return "google.protobuf.FieldOptions".equals(name) || "com.google.protobuf.FieldOptions".equals(
        name);
  }

  
  private static boolean isMessageOptions(String fullyQualifiedName) {
    return "google.protobuf.MessageOptions".equals(fullyQualifiedName)
        || "com.google.protobuf.MessageOptions".equals(fullyQualifiedName);
  }

  private String prefixWithPackageName(ProtoFile protoFile, String name) {
    return protoFile.packageName() + "." + name;
  }

  private String getLabelString(FieldElement field, boolean isEnum) {
    switch (field.label()) {
      case OPTIONAL:
        return "Optional";
      case REQUIRED:
        return "Required";
      case REPEATED:
        return FieldInfo.isPacked(field, isEnum) ? "Packed" : "Repeated";
      default:
        throw new WireCompilerException("Unknown extension label \"" + field.label() + "\"");
    }
  }

  private boolean hasByteStringExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.type() == ScalarType.BYTES) {
          return true;
        }
      }
    }
    return false;
  }

  private boolean hasRepeatedExtension() {
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      for (FieldElement field : extend.fields()) {
        if (field.label() == FieldElement.Label.REPEATED) {
          return true;
        }
      }
    }
    return false;
  }

  private String toInt(String value) {
    return Integer.toString(new BigDecimal(value).intValue());
  }

  private String toLong(String value) {
    return Long.toString(new BigDecimal(value).longValue()) + "L";
  }

  private String quoteString(String initialValue) {
    return initialValue == null ? "\"\"" : JavaWriter.stringLiteral(initialValue);
  }

  private boolean hasEnum(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof EnumElement || hasEnum(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasOneOf(List<TypeElement> types) {
    for (TypeElement type : types) {
      if ((type instanceof MessageElement && !((MessageElement) type).oneOfs().isEmpty())
          || hasOneOf(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasExtensions(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && hasExtensions(((MessageElement) type))) return true;
      if (hasExtensions(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasMessage(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement && !hasExtensions(((MessageElement) type))) return true;
      if (hasMessage(type.nestedElements())) return true;
    }
    return false;
  }

  
  static List<FieldElement> allFields(MessageElement messageType) {
    List<FieldElement> allFields = new ArrayList<FieldElement>();
    allFields.addAll(messageType.fields());
    for (OneOfElement oneOfElement : messageType.oneOfs()) {
      allFields.addAll(oneOfElement.fields());
    }
    return allFields;
  }

  private boolean hasRepeatedField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (FieldInfo.isRepeated(field)) return true;
        }
      }
      if (hasRepeatedField(type.nestedElements())) return true;
    }
    return false;
  }

  private boolean hasBytesField(List<TypeElement> types) {
    for (TypeElement type : types) {
      if (type instanceof MessageElement) {
        for (FieldElement field : allFields((MessageElement) type)) {
          if (field.type() == ScalarType.BYTES) return true;
        }
      }
      if (hasBytesField(type.nestedElements())) return true;
    }
    return false;
  }

  private void getDatatypesAndLabels(TypeElement type, Collection<Datatype> types,
      Collection<Label> labels) {
    if (type instanceof MessageElement) {
      for (FieldElement field : allFields((MessageElement) type)) {
        String fieldType = field.type().toString();
        Datatype datatype = Datatype.of(fieldType);
        
        if (datatype == null && isEnum(fullyQualifiedName(type, field.type().toString()))) {
          datatype = Datatype.ENUM;
        }
        if (datatype != null) types.add(datatype);

        
        FieldElement.Label label = field.label();
        switch (label) {
          case OPTIONAL:
            labels.add(Label.OPTIONAL);
            break;
          case REQUIRED:
            labels.add(Label.REQUIRED);
            break;
          case REPEATED:
            if (FieldInfo.isPacked(field, datatype == Datatype.ENUM)) {
              labels.add(Label.PACKED);
            } else {
              labels.add(Label.REPEATED);
            }
            break;
          case ONE_OF:
            labels.add(Label.ONE_OF);
            break;
          default:
            throw new AssertionError("Unknown label " + label);
        }
      }

      for (TypeElement nestedType : type.nestedElements()) {
        getDatatypesAndLabels(nestedType, types, labels);
      }
    }
  }

  private boolean typeIsComplete(String type) {
    return javaSymbolMap.containsKey(type);
  }

  private boolean javaTypeIsComplete(String type) {
    if (javaSymbols.isEmpty()) {
      javaSymbols.addAll(javaSymbolMap.values());
    }
    return javaSymbols.contains(type);
  }

  private String fullyQualifiedJavaName(MessageElement messageType, String type) {
    return TypeInfo.isScalar(type) ? null : javaName(fullyQualifiedName(messageType, type));
  }

  private void compileWithJavaPoet() throws WireException {
    Set<String> parsedFiles = new LinkedHashSet<String>();
    Loader loader = new Loader(repoPath, io);
    for (String sourceFilename : options.sourceFileNames) {
      String sourcePath = repoPath + File.separator + sourceFilename;
      parsedFiles.add(sourcePath);
      try {
        loader.add(sourceFilename);
      } catch (IOException e) {
        throw new WireException("Error loading symbols for " + sourcePath, e);
      }
    }

    List<WireProtoFile> wireProtoFiles = loader.loaded();
    Linker linker = new Linker();
    linker.link(wireProtoFiles);

    if (!typesToEmit.isEmpty()) {
      log.info("Analyzing dependencies of root types.");
      wireProtoFiles = new Pruner().retainRoots(wireProtoFiles, typesToEmit);
    }

    JavaGenerator javaGenerator = JavaGenerator.get(wireProtoFiles);
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      if (!parsedFiles.contains(wireProtoFile.sourcePath())) {
        continue; 
      }

      TypeWriter typeWriter = new TypeWriter(javaGenerator, options.emitOptions);

      for (com.squareup.wire.model.WireType type : wireProtoFile.types()) {
        ClassName javaTypeName = (ClassName) javaGenerator.typeName(type.protoTypeName());
        TypeSpec typeSpec = typeWriter.toTypeSpec(type);
        writeJavaFile(javaTypeName, typeSpec, wireProtoFile.sourcePath());
      }

      if (options.emitOptions && !wireProtoFile.wireExtends().isEmpty()) {
        ClassName javaTypeName = javaGenerator.extensionsClass(wireProtoFile);
        TypeSpec typeSpec = typeWriter.extensionsType(javaTypeName, wireProtoFile);
        writeJavaFile(javaTypeName, typeSpec, wireProtoFile.sourcePath());
      }
    }
  }

  private void writeJavaFile(
      ClassName javaTypeName, TypeSpec typeSpec, String sourceFileName) throws WireException {
    OutputArtifact artifact = new OutputArtifact(options.javaOut, javaTypeName);
    log.artifact(artifact);

    JavaFile javaFile = JavaFile.builder(javaTypeName.packageName(), typeSpec)
        .addFileComment("$L\n", CODE_GENERATED_BY_WIRE)
        .addFileComment("Source file: $L", sourceFileName)
        .build();

    try {
      if (!options.dryRun) {
        io.write(artifact, javaFile);
      }
    } catch (IOException e) {
      throw new WireException("Error emitting " + artifact.file(), e);
    }
  }
}

<code block>

package com.squareup.wire.java;

import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import com.squareup.wire.WireCompilerException;
import com.squareup.wire.internal.Util;
import com.squareup.wire.model.ProtoTypeName;
import com.squareup.wire.model.WireEnum;
import com.squareup.wire.model.WireEnumConstant;
import com.squareup.wire.model.WireExtend;
import com.squareup.wire.model.WireField;
import com.squareup.wire.model.WireMessage;
import com.squareup.wire.model.WireOneOf;
import com.squareup.wire.model.WireOption;
import com.squareup.wire.model.WireProtoFile;
import com.squareup.wire.model.WireType;
import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import okio.ByteString;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public final class TypeWriter {
  private static final ImmutableSet<String> JAVA_KEYWORDS = ImmutableSet.of(
      "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
      "class", "const", "continue", "default", "do", "double", "else", "enum", "extends",
      "final", "finally", "float", "for", "goto", "if", "implements", "import", "instanceof",
      "int", "interface", "long", "native", "new", "package", "private", "protected", "public",
      "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
      "throw", "throws", "transient", "try", "void", "volatile", "while");

  private final JavaGenerator javaGenerator;
  private final boolean emitOptions;

  public TypeWriter(JavaGenerator javaGenerator, boolean emitOptions) {
    this.javaGenerator = javaGenerator;
    this.emitOptions = emitOptions;
  }

  
  public TypeSpec toTypeSpec(WireType type) {
    if (type instanceof WireMessage) {
      return toTypeSpec((WireMessage) type);
    } else if (type instanceof WireEnum) {
      return toTypeSpec((WireEnum) type);
    } else {
      throw new IllegalArgumentException("unexpected type: " + type);
    }
  }

  private TypeSpec toTypeSpec(WireEnum type) {
    ClassName typeName = (ClassName) javaGenerator.typeName(type.protoTypeName());

    TypeSpec.Builder builder = TypeSpec.enumBuilder(typeName.simpleName())
        .addModifiers(PUBLIC)
        .addSuperinterface(ProtoEnum.class);

    if (!type.documentation().isEmpty()) {
      builder.addJavadoc("$L\n", type.documentation());
    }

    

    for (WireEnumConstant constant : type.constants()) {
      Object[] enumArgs = new Object[1];
      String[] enumArgsFormat = new String[1];

      enumArgs[0] = constant.tag();
      enumArgsFormat[0] = "$L";

      TypeSpec.Builder constantBuilder = TypeSpec.anonymousClassBuilder(
          Joiner.on(", ").join(enumArgsFormat), enumArgs);
      if (!constant.documentation().isEmpty()) {
        constantBuilder.addJavadoc("$L\n", constant.documentation());
      }

      builder.addEnumConstant(constant.name(), constantBuilder.build());

      
    }

    
    builder.addField(TypeName.INT, "value", PRIVATE, FINAL);

    

    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
    constructorBuilder.addParameter(TypeName.INT, "value");
    constructorBuilder.addStatement("this.value = value");
    
    builder.addMethod(constructorBuilder.build());

    
    builder.addMethod(MethodSpec.methodBuilder("getValue")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(TypeName.INT)
        .addStatement("return value")
        .build());

    return builder.build();
  }

  private TypeSpec toTypeSpec(WireMessage type) {
    ClassName javaType = (ClassName) javaGenerator.typeName(type.protoTypeName());
    ClassName builderJavaType = javaType.nestedClass("Builder");

    TypeSpec.Builder builder = TypeSpec.classBuilder(javaType.simpleName());
    builder.addModifiers(PUBLIC, FINAL);

    if (javaType.enclosingClassName() != null) {
      builder.addModifiers(STATIC);
    }

    if (!type.documentation().isEmpty()) {
      builder.addJavadoc("$L\n", type.documentation());
    }

    builder.superclass(type.extensions().isEmpty()
        ? JavaGenerator.MESSAGE
        : JavaGenerator.extendableMessageOf(javaType));

    builder.addField(FieldSpec.builder(TypeName.LONG, "serialVersionUID")
        .addModifiers(PRIVATE, STATIC, FINAL)
        .initializer("$LL", 0L)
        .build());

    for (WireField field : type.fieldsAndOneOfFields()) {
      TypeName fieldType = fieldType(field);

      if (field.type().isScalar()
          || javaGenerator.isEnum(field.type())
          || field.isRepeated()) {
        builder.addField(defaultField(field, fieldType));
      }

      String name = sanitize(field.name());
      FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, name, PUBLIC, FINAL);
      fieldBuilder.addAnnotation(protoFieldAnnotation(field, javaGenerator.typeName(field.type())));
      if (!field.documentation().isEmpty()) {
        fieldBuilder.addJavadoc("$L\n", field.documentation());
      }
      if (field.isDeprecated()) {
        fieldBuilder.addAnnotation(Deprecated.class);
      }
      builder.addField(fieldBuilder.build());
    }

    builder.addMethod(messageFieldsConstructor(type));
    builder.addMethod(messageBuilderConstructor(type, builderJavaType));
    builder.addMethod(messageEquals(type));
    builder.addMethod(messageHashCode(type));
    builder.addType(builder(type, javaType, builderJavaType));

    for (WireType nestedType : type.nestedTypes()) {
      builder.addType(toTypeSpec(nestedType));
    }

    return builder.build();
  }

  private TypeName fieldType(WireField field) {
    TypeName messageType = javaGenerator.typeName(field.type());
    return field.isRepeated() ? JavaGenerator.listOf(messageType) : messageType;
  }

  
  
  
  
  private FieldSpec defaultField(WireField field, TypeName fieldType) {
    String defaultFieldName = "DEFAULT_" + field.name().toUpperCase(Locale.US);
    return FieldSpec.builder(fieldType, defaultFieldName, PUBLIC, STATIC, FINAL)
        .initializer(defaultValue(field))
        .build();
  }

  
  
  
  
  
  
  
  private AnnotationSpec protoFieldAnnotation(WireField field, TypeName messageType) {
    AnnotationSpec.Builder result = AnnotationSpec.builder(ProtoField.class);

    int tag = field.tag();
    result.addMember("tag", String.valueOf(tag));

    boolean isScalar = field.type().isScalar();
    boolean isEnum = javaGenerator.isEnum(field.type());

    String fieldType;
    if (isScalar) {
      fieldType = field.type().toString().toUpperCase(Locale.US);
    } else if (isEnum) {
      fieldType = "ENUM";
    } else {
      fieldType = null;
    }

    if (fieldType != null) {
      result.addMember("type", "$T.$L", Message.Datatype.class, fieldType);
    }

    if (!field.isOptional()) {
      String label;
      if (field.isPacked() && (isEnum || field.type().isPackableScalar())) {
        label = "PACKED";
      } else {
        label = field.label().toString();
      }
      result.addMember("label", "$T.$L", Message.Label.class, label);
    }

    if (field.isRepeated() && !isScalar) {
      String key = isEnum ? "enumType" : "messageType";
      result.addMember(key, "$T.class", messageType);
    }

    if (field.isDeprecated()) {
      result.addMember("deprecated", "true");
    }

    
    if (Util.optionMatches(field.options(), ".*\\.redacted", "true")) {
      result.addMember("redacted", "true");
    }

    return result.build();
  }

  
  
  
  
  
  
  
  private MethodSpec messageFieldsConstructor(WireMessage type) {
    MethodSpec.Builder result = MethodSpec.constructorBuilder();
    result.addModifiers(PUBLIC);
    for (WireField field : type.fieldsAndOneOfFields()) {
      TypeName javaType = fieldType(field);
      String sanitizedName = sanitize(field.name());
      result.addParameter(javaType, sanitizedName);
      if (field.isRepeated()) {
        result.addStatement("this.$L = immutableCopyOf($L)", sanitizedName, sanitizedName);
      } else {
        result.addStatement("this.$L = $L", sanitizedName, sanitizedName);
      }
    }
    return result.build();
  }

  
  
  
  
  
  
  
  private MethodSpec messageBuilderConstructor(WireMessage type, ClassName builderJavaType) {
    MethodSpec.Builder result = MethodSpec.constructorBuilder()
        .addModifiers(PRIVATE)
        .addParameter(builderJavaType, "builder");

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.size() > 0) {
      result.addCode("this(");
      for (int i = 0; i < fields.size(); i++) {
        if (i > 0) result.addCode(", ");
        WireField field = fields.get(i);
        result.addCode("builder.$L", sanitize(field.name()));
      }
      result.addCode(");\n");
    }
    result.addStatement("setBuilder(builder)");
    return result.build();
  }

  
  
  
  
  
  
  
  
  
  
  private MethodSpec messageEquals(WireMessage type) {
    TypeName javaType = javaGenerator.typeName(type.protoTypeName());
    MethodSpec.Builder result = MethodSpec.methodBuilder("equals")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(boolean.class)
        .addParameter(Object.class, "other");

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.isEmpty() && type.extensions().isEmpty()) {
      result.addStatement("return other instanceof $T", javaType);
      return result.build();
    }

    result.addStatement("if (other == this) return true");
    result.addStatement("if (!(other instanceof $T)) return false", javaType);

    if (fields.size() == 1 && type.extensions().isEmpty()) {
      String name = sanitize(fields.get(0).name());
      result.addStatement("return equals($L, (($T) other).$L)",
          addThisIfOneOf(name, "other", "o"), javaType, name);
      return result.build();
    }

    result.addStatement("$T o = ($T) other", javaType, javaType);
    if (!type.extensions().isEmpty()) {
      result.addStatement("if (!extensionsEqual(o)) return false");
    }
    result.addCode("$[return ");
    for (int i = 0; i < fields.size(); i++) {
      if (i > 0) result.addCode("\n&& ");
      WireField field = fields.get(i);
      String name = sanitize(field.name());
      result.addCode("equals($L, o.$L)", addThisIfOneOf(name, "other", "o"), name);
    }
    result.addCode(";\n$]");

    return result.build();
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  private MethodSpec messageHashCode(WireMessage type) {
    MethodSpec.Builder result = MethodSpec.methodBuilder("hashCode")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(int.class);

    List<WireField> fields = type.fieldsAndOneOfFields();
    if (fields.isEmpty() && type.extensions().isEmpty()) {
      result.addStatement("return 0");
      return result.build();
    }

    if (fields.size() == 1 && type.extensions().isEmpty()) {
      WireField field = fields.get(0);
      String name = sanitize(field.name());
      result.addStatement("int result = hashCode");
      result.addStatement(
          "return result != 0 ? result : (hashCode = $L != null ? $L.hashCode() : $L)",
          addThisIfOneOf(name, "result"), addThisIfOneOf(name, "result"), nullHashValue(field));
      return result.build();
    }

    result.addStatement("int result = hashCode");
    result.beginControlFlow("if (result == 0)");
    boolean afterFirstAssignment = false;
    if (!type.extensions().isEmpty()) {
      result.addStatement("result = extensionsHashCode()");
      afterFirstAssignment = true;
    }
    for (WireField field : fields) {
      String name = sanitize(field.name());
      name = addThisIfOneOf(name, "result");
      if (afterFirstAssignment) {
        result.addStatement("result = result * 37 + ($L != null ? $L.hashCode() : $L)",
            name, name, nullHashValue(field));
      } else {
        result.addStatement("result = $L != null ? $L.hashCode() : $L",
            name, name, nullHashValue(field));
        afterFirstAssignment = true;
      }
    }
    result.addStatement("hashCode = result");
    result.endControlFlow();
    result.addStatement("return result");
    return result.build();
  }

  private TypeSpec builder(WireMessage type, ClassName javaType, ClassName builderType) {
    TypeSpec.Builder result = TypeSpec.classBuilder("Builder")
        .addModifiers(PUBLIC, STATIC, FINAL);

    result.superclass(type.extensions().isEmpty()
        ? JavaGenerator.builderOf(javaType)
        : JavaGenerator.extendableBuilderOf(javaType));

    List<WireField> fields = type.fieldsAndOneOfFields();
    for (WireField field : fields) {
      TypeName fieldJavaType = fieldType(field);
      result.addField(fieldJavaType, sanitize(field.name()), PUBLIC);
    }

    result.addMethod(builderNoArgsConstructor());
    result.addMethod(builderCopyConstructor(type));

    for (WireField field : type.fields()) {
      result.addMethod(setter(builderType, null, field));
    }

    for (WireOneOf oneOf : type.oneOfs()) {
      for (WireField field : oneOf.fields()) {
        result.addMethod(setter(builderType, oneOf, field));
      }
    }

    if (!type.extensions().isEmpty()) {
      result.addMethod(builderSetExtension(javaType, builderType));
    }

    result.addMethod(builderBuild(type, javaType));
    return result.build();
  }

  
  
  
  
  
  private MethodSpec builderNoArgsConstructor() {
    return MethodSpec.constructorBuilder()
        .addModifiers(PUBLIC)
        .build();
  }

  
  
  
  
  
  
  
  
  
  private MethodSpec builderCopyConstructor(WireMessage message) {
    TypeName javaType = javaGenerator.typeName(message.protoTypeName());

    MethodSpec.Builder result = MethodSpec.constructorBuilder()
        .addModifiers(PUBLIC)
        .addParameter(javaType, "message");
    result.addStatement("super(message)");

    List<WireField> fields = message.fieldsAndOneOfFields();
    if (!fields.isEmpty()) {
      result.addStatement("if (message == null) return");
    }

    for (WireField field : fields) {
      String fieldName = sanitize(field.name());
      if (field.isRepeated()) {
        result.addStatement("this.$L = copyOf(message.$L)", fieldName, fieldName);
      } else {
        result.addStatement("this.$L = message.$L", fieldName, fieldName);
      }
    }

    return result.build();
  }

  private MethodSpec setter(TypeName builderType, WireOneOf oneOf, WireField field) {
    TypeName javaType = fieldType(field);
    String fieldName = sanitize(field.name());

    MethodSpec.Builder result = MethodSpec.methodBuilder(fieldName)
        .addModifiers(PUBLIC)
        .addParameter(javaType, fieldName)
        .returns(builderType);

    if (!field.documentation().isEmpty()) {
      result.addJavadoc("$L\n", field.documentation());
    }

    if (field.isDeprecated()) {
      result.addAnnotation(Deprecated.class);
    }

    if (field.isRepeated()) {
      result.addStatement("this.$L = checkForNulls($L)", fieldName, fieldName);
    } else {
      result.addStatement("this.$L = $L", fieldName, fieldName);

      if (oneOf != null) {
        for (WireField other : oneOf.fields()) {
          if (field != other) {
            result.addStatement("this.$L = null", sanitize(other.name()));
          }
        }
      }
    }

    result.addStatement("return this");
    return result.build();
  }

  
  
  
  
  
  
  
  
  private MethodSpec builderSetExtension(ClassName javaType, ClassName builderType) {
    TypeVariableName e = TypeVariableName.get("E");
    return MethodSpec.methodBuilder("setExtension")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .addTypeVariable(e)
        .returns(builderType)
        .addParameter(JavaGenerator.extensionOf(javaType, e), "extension")
        .addParameter(e, "value")
        .addStatement("super.setExtension(extension, value)")
        .addStatement("return this")
        .build();
  }

  
  
  
  
  
  
  
  
  
  
  
  private MethodSpec builderBuild(WireMessage message, ClassName javaType) {
    MethodSpec.Builder result = MethodSpec.methodBuilder("build")
        .addAnnotation(Override.class)
        .addModifiers(PUBLIC)
        .returns(javaType);
    if (message.hasRequiredFields()) {
      result.addStatement("checkRequiredFields()");
    }
    result.addStatement("return new $T(this)", javaType);
    return result.build();
  }

  private CodeBlock defaultValue(WireField field) {
    if (field.isRepeated()) {
      return codeBlock("$T.emptyList()", Collections.class);
    }

    WireOption fieldDefault = field.getDefault();
    TypeName javaType = fieldType(field);

    if (field.type().isScalar()) {
      Object initialValue = fieldDefault != null ? fieldDefault.value() : null;
      return fieldInitializer(javaType, initialValue);
    }

    if (fieldDefault != null) {
      return codeBlock("$T.$L", javaType, fieldDefault.value());
    }

    if (javaGenerator.isEnum(field.type())) {
      WireEnumConstant defaultValue = javaGenerator.enumDefault(field.type());
      return codeBlock("$T.$L", javaType, defaultValue.name());
    }

    throw new WireCompilerException("Field " + field + " cannot have default value");
  }

  private CodeBlock fieldInitializer(TypeName type, Object value) {
    if (type.equals(TypeName.BOOLEAN.box())) {
      return codeBlock("$L", value != null ? value : false);

    } else if (type.equals(TypeName.INT.box())) {
      return codeBlock("$L", value != null
          ? new BigDecimal(String.valueOf(value)).intValue()
          : 0);

    } else if (type.equals(TypeName.LONG.box())) {
      return codeBlock("$LL", value != null
          ? Long.toString(new BigDecimal(String.valueOf(value)).longValue())
          : 0L);

    } else if (type.equals(TypeName.FLOAT.box())) {
      return codeBlock("$Lf", value != null ? String.valueOf(value) : 0f);

    } else if (type.equals(TypeName.DOUBLE.box())) {
      return codeBlock("$Ld", value != null ? String.valueOf(value) : 0d);

    } else if (type.equals(JavaGenerator.STRING)) {
      return codeBlock("$S", value != null ? (String) value : "");

    } else if (type.equals(JavaGenerator.BYTE_STRING)) {
      if (value == null) {
        return codeBlock("$T.EMPTY", ByteString.class);
      } else {
        return codeBlock("$T.decodeBase64($S)", ByteString.class,
            ByteString.of(String.valueOf(value).getBytes(Charsets.ISO_8859_1)).base64());
      }
    } else {
      throw new WireCompilerException(type + " is not an allowed scalar type");
    }
  }

  private String addThisIfOneOf(String name, String... matches) {
    for (String match : matches) {
      if (match.equals(name)) {
        return "this." + name;
      }
    }
    return name;
  }

  private static String sanitize(String name) {
    return JAVA_KEYWORDS.contains(name) ? "_" + name : name;
  }

  private static CodeBlock codeBlock(String format, Object... args) {
    return CodeBlock.builder().add(format, args).build();
  }

  private int nullHashValue(WireField field) {
    return field.isRepeated() ? 1 : 0;
  }

  public TypeSpec extensionsType(ClassName javaTypeName, WireProtoFile wireProtoFile) {
    TypeSpec.Builder builder = TypeSpec.classBuilder(javaTypeName.simpleName())
        .addModifiers(PUBLIC, FINAL);

    
    builder.addMethod(MethodSpec.constructorBuilder()
        .addModifiers(PRIVATE)
        .build());

    for (WireExtend extend : wireProtoFile.wireExtends()) {
      ProtoTypeName extendType = extend.protoTypeName();
      TypeName javaType = javaGenerator.typeName(extendType);

      if (!emitOptions && (extendType.isFieldOptions() || extendType.isMessageOptions())) {
        continue;
      }

      for (WireField field : extend.fields()) {
        builder.addField(extensionField(wireProtoFile, javaType, field));
      }
    }

    return builder.build();
  }

  private FieldSpec extensionField(
      WireProtoFile wireProtoFile, TypeName extendType, WireField field) {
    TypeName fieldType = javaGenerator.typeName(field.type());

    CodeBlock.Builder initializer = CodeBlock.builder();
    initializer.add("$[Extension\n");

    if (field.type().isScalar()) {
      initializer.add(".$LExtending($T.class)\n", field.type(), extendType);
    } else if (javaGenerator.isEnum(field.type())) {
      initializer.add(".enumExtending($T.class, $T.class)\n", fieldType, extendType);
    } else {
      initializer.add(".messageExtending($T.class, $T.class)\n", fieldType, extendType);
    }

    initializer.add(".setName($S)\n", wireProtoFile.packageName() + "." + field.name());
    initializer.add(".setTag($L)\n", field.tag());
    initializer.add(".build$L()$]", extensionLabel(field));

    if (field.isRepeated()) {
      fieldType = JavaGenerator.listOf(fieldType);
    }

    return FieldSpec.builder(JavaGenerator.extensionOf(extendType, fieldType), field.name())
        .addModifiers(PUBLIC, STATIC, FINAL)
        .initializer(initializer.build())
        .build();
  }

  private String extensionLabel(WireField field) {
    switch (field.label()) {
      case OPTIONAL:
        return "Optional";

      case REQUIRED:
        return "Required";

      case REPEATED:
        boolean packed = field.isPacked()
            && (javaGenerator.isEnum(field.type()) || field.type().isPackableScalar());
        return packed ? "Packed" : "Repeated";

      default:
        throw new WireCompilerException("Unknown extension label \"" + field.label() + "\"");
    }
  }
}

<code block>

package com.squareup.wire.java;

import com.google.common.collect.ImmutableMap;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.wire.ExtendableMessage;
import com.squareup.wire.Extension;
import com.squareup.wire.Message;
import com.squareup.wire.internal.Util;
import com.squareup.wire.model.ProtoTypeName;
import com.squareup.wire.model.WireEnum;
import com.squareup.wire.model.WireEnumConstant;
import com.squareup.wire.model.WireOption;
import com.squareup.wire.model.WireProtoFile;
import com.squareup.wire.model.WireType;
import java.util.List;
import java.util.Map;
import okio.ByteString;

import static com.google.common.base.Preconditions.checkArgument;


public final class JavaGenerator {
  public static final ClassName BYTE_STRING = ClassName.get(ByteString.class);
  public static final ClassName STRING = ClassName.get(String.class);
  public static final ClassName LIST = ClassName.get(List.class);
  public static final ClassName MESSAGE = ClassName.get(Message.class);
  public static final ClassName EXTENDABLE_MESSAGE = ClassName.get(ExtendableMessage.class);
  public static final ClassName BUILDER = ClassName.get(Message.Builder.class);
  public static final ClassName EXTENDABLE_BUILDER
      = ClassName.get(ExtendableMessage.ExtendableBuilder.class);
  public static final ClassName EXTENSION = ClassName.get(Extension.class);

  private static final Map<ProtoTypeName, TypeName> SCALAR_TYPES_MAP =
      ImmutableMap.<ProtoTypeName, TypeName>builder()
          .put(ProtoTypeName.BOOL, TypeName.BOOLEAN.box())
          .put(ProtoTypeName.BYTES, ClassName.get(ByteString.class))
          .put(ProtoTypeName.DOUBLE, TypeName.DOUBLE.box())
          .put(ProtoTypeName.FLOAT, TypeName.FLOAT.box())
          .put(ProtoTypeName.FIXED32, TypeName.INT.box())
          .put(ProtoTypeName.FIXED64, TypeName.LONG.box())
          .put(ProtoTypeName.INT32, TypeName.INT.box())
          .put(ProtoTypeName.INT64, TypeName.LONG.box())
          .put(ProtoTypeName.SFIXED32, TypeName.INT.box())
          .put(ProtoTypeName.SFIXED64, TypeName.LONG.box())
          .put(ProtoTypeName.SINT32, TypeName.INT.box())
          .put(ProtoTypeName.SINT64, TypeName.LONG.box())
          .put(ProtoTypeName.STRING, ClassName.get(String.class))
          .put(ProtoTypeName.UINT32, TypeName.INT.box())
          .put(ProtoTypeName.UINT64, TypeName.LONG.box())
          .build();

  private final ImmutableMap<ProtoTypeName, TypeName> wireToJava;
  private final ImmutableMap<ProtoTypeName, WireType> wireToType;

  public JavaGenerator(
      ImmutableMap<ProtoTypeName, TypeName> wireToJava,
      ImmutableMap<ProtoTypeName, WireType> wireToType) {
    this.wireToJava = wireToJava;
    this.wireToType = wireToType;
  }

  public static JavaGenerator get(List<WireProtoFile> wireProtoFiles) {
    ImmutableMap.Builder<ProtoTypeName, TypeName> wireToJava = ImmutableMap.builder();
    ImmutableMap.Builder<ProtoTypeName, WireType> wireToType = ImmutableMap.builder();
    wireToJava.putAll(SCALAR_TYPES_MAP);

    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      String javaPackage = javaPackage(wireProtoFile);
      putAll(wireToJava, wireToType, javaPackage, null, wireProtoFile.types());
    }

    return new JavaGenerator(wireToJava.build(), wireToType.build());
  }

  private static void putAll(ImmutableMap.Builder<ProtoTypeName, TypeName> wireToJava,
      ImmutableMap.Builder<ProtoTypeName, WireType> wireToType, String javaPackage,
      ClassName enclosingClassName, List<WireType> types) {
    for (WireType type : types) {
      ClassName className = enclosingClassName != null
          ? enclosingClassName.nestedClass(type.protoTypeName().simpleName())
          : ClassName.get(javaPackage, type.protoTypeName().simpleName());
      wireToJava.put(type.protoTypeName(), className);
      wireToType.put(type.protoTypeName(), type);
      putAll(wireToJava, wireToType, javaPackage, className, type.nestedTypes());
    }
  }

  public ClassName extensionsClass(WireProtoFile protoFile) {
    return ClassName.get(javaPackage(protoFile), "Ext_" + protoFile.name());
  }

  public TypeName typeName(ProtoTypeName protoTypeName) {
    TypeName candidate = wireToJava.get(protoTypeName);
    checkArgument(candidate != null, "unexpected type %s", protoTypeName);
    return candidate;
  }

  private static String javaPackage(WireProtoFile wireProtoFile) {
    WireOption javaPackageOption = Util.findOption(wireProtoFile.options(), "java_package");
    if (javaPackageOption != null) {
      return String.valueOf(javaPackageOption.value());
    } else if (wireProtoFile.packageName() != null) {
      return wireProtoFile.packageName();
    } else {
      return "";
    }
  }

  public boolean isEnum(ProtoTypeName type) {
    WireType wireType = wireToType.get(type);
    return wireType instanceof WireEnum;
  }

  public WireEnumConstant enumDefault(ProtoTypeName type) {
    WireEnum wireEnum = (WireEnum) wireToType.get(type);
    return wireEnum.constants().get(0);
  }

  public static TypeName listOf(TypeName type) {
    return ParameterizedTypeName.get(LIST, type);
  }

  public static TypeName extendableMessageOf(TypeName type) {
    return ParameterizedTypeName.get(JavaGenerator.EXTENDABLE_MESSAGE, type);
  }

  public static TypeName builderOf(TypeName messageType) {
    return ParameterizedTypeName.get(BUILDER, messageType);
  }

  public static TypeName extendableBuilderOf(TypeName messageType) {
    return ParameterizedTypeName.get(EXTENDABLE_BUILDER, messageType);
  }

  public static TypeName extensionOf(TypeName messageType, TypeName fieldType) {
    return ParameterizedTypeName.get(EXTENSION, messageType, fieldType);
  }
}

<code block>

package com.squareup.wire.internal;

import com.squareup.wire.model.WireOption;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.google.common.base.Preconditions.checkNotNull;

public final class Util {
  private Util() {
  }

  public static <T> List<T> concatenate(List<T> a, T b) {
    List<T> result = new ArrayList<T>();
    result.addAll(a);
    result.add(b);
    return result;
  }

  public static WireOption findOption(List<WireOption> options, String name) {
    checkNotNull(options, "options");
    checkNotNull(name, "name");

    WireOption found = null;
    for (WireOption option : options) {
      if (option.name().equals(name)) {
        if (found != null) {
          throw new IllegalStateException("Multiple options match name: " + name);
        }
        found = option;
      }
    }
    return found;
  }

  
  public static boolean optionMatches(
      List<WireOption> options, String namePattern, String valuePattern) {
    Matcher nameMatcher = Pattern.compile(namePattern).matcher("");
    Matcher valueMatcher = Pattern.compile(valuePattern).matcher("");
    for (WireOption option : options) {
      if (nameMatcher.reset(option.name()).matches()
          && valueMatcher.reset(String.valueOf(option.value())).matches()) {
        return true;
      }
    }
    return false;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.DataType;
import com.squareup.wire.internal.Util;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public final class Linker {
  private final Map<String, WireType> protoTypeNames;
  private final Map<ProtoTypeName, Map<String, WireField>> extensionsMap;

  
  private final List<WireType> enclosingTypes;

  public Linker() {
    this.protoTypeNames = new LinkedHashMap<String, WireType>();
    this.extensionsMap = new LinkedHashMap<ProtoTypeName, Map<String, WireField>>();
    this.enclosingTypes = Collections.emptyList();
  }

  private Linker(Linker enclosing, WireType type) {
    this.protoTypeNames = enclosing.protoTypeNames;
    this.extensionsMap = enclosing.extensionsMap;
    this.enclosingTypes = type != null
        ? Util.concatenate(enclosing.enclosingTypes, type)
        : enclosing.enclosingTypes;
  }

  public void link(Collection<WireProtoFile> wireProtoFiles) {
    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireType type : wireProtoFile.types()) {
        register(type);
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireExtend extend : wireProtoFile.wireExtends()) {
        Map<String, WireField> map = extensionsMap.get(extend.protoTypeName());
        if (map == null) {
          map = new LinkedHashMap<String, WireField>();
          extensionsMap.put(extend.protoTypeName(), map);
        }
        for (WireField field : extend.fields()) {
          map.put(extend.packageName() + "." + field.name(), field);
        }
      }
    }

    
    for (WireProtoFile wireProtoFile : wireProtoFiles) {
      for (WireType type : wireProtoFile.types()) {
        type.link(this);
      }
      for (WireService service : wireProtoFile.services()) {
        service.link(this);
      }
      for (WireExtend extend : wireProtoFile.wireExtends()) {
        extend.link(this);
      }
      for (WireOption option : wireProtoFile.options()) {
        option.link(ProtoTypeName.FILE_OPTIONS, this);
      }
    }
  }

  private void register(WireType type) {
    protoTypeNames.put(type.protoTypeName().toString(), type);
    for (WireType nestedType : type.nestedTypes()) {
      register(nestedType);
    }
  }

  
  ProtoTypeName resolveType(String packageName, DataType type) {
    switch (type.kind()) {
      case SCALAR:
        return ProtoTypeName.getScalar(type.toString());

      case NAMED:
        return resolveNamedType(packageName, type.toString());

      default:
        
        throw new UnsupportedOperationException("unexpected type: " + type);
    }
  }

  
  ProtoTypeName resolveNamedType(String packageName, String name) {
    WireType fullyQualified = protoTypeNames.get(name);
    if (fullyQualified != null) return fullyQualified.protoTypeName();

    if (packageName != null) {
      WireType samePackage = protoTypeNames.get(packageName + "." + name);
      if (samePackage != null) return samePackage.protoTypeName();
    }

    
    for (int i = enclosingTypes.size() - 1; i >= 0; i--) {
      WireType enclosingType = enclosingTypes.get(i);

      if (name.equals(enclosingType.protoTypeName().simpleName())) {
        return enclosingType.protoTypeName();
      }

      for (WireType peerType : enclosingType.nestedTypes()) {
        if (name.equals(peerType.protoTypeName().simpleName())) {
          return peerType.protoTypeName();
        }
      }
    }

    
    throw new IllegalArgumentException("unrecognized type name: " + name);
  }

  
  List<WireField> fieldPath(String packageName, ProtoTypeName extensionType, String fieldPath) {
    Map<String, WireField> extensionsForType = extensionsMap.get(extensionType);
    if (extensionsForType == null) {
      return null; 
    }

    String[] path = resolveFieldPath(fieldPath, extensionsForType.keySet());
    if (path == null && packageName != null) {
      
      path = resolveFieldPath(packageName + "." + fieldPath, extensionsForType.keySet());
    }
    if (path == null) {
      return null; 
    }

    List<WireField> fields = new ArrayList<WireField>();
    WireField field = extensionsForType.get(path[0]);
    fields.add(field);

    for (int i = 1; i < path.length; i++) {
      String pathSegment = path[i];
      ProtoTypeName valueType = field.type();
      WireType wireType = protoTypeNames.get(valueType.toString());
      if (wireType instanceof WireMessage) {
        field = ((WireMessage) wireType).field(pathSegment);
        fields.add(field);
      } else {
        return null; 
      }
    }

    return fields;
  }

  
  static String[] resolveFieldPath(String name, Set<String> fullyQualifiedNames) {
    
    for (int i = 0; i < name.length(); i++) {
      i = name.indexOf('.', i);
      if (i == -1) i = name.length();

      String candidate = name.substring(0, i);
      if (fullyQualifiedNames.contains(candidate)) {
        String[] path = name.substring(i).split("\\.", -1);
        path[0] = name.substring(0, i);
        return path;
      }
    }

    return null;
  }

  
  Linker withMessage(WireMessage message) {
    return new Linker(this, message);
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumConstantElement;
import com.squareup.protoparser.EnumElement;
import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.MessageElement;
import com.squareup.protoparser.OneOfElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.TypeElement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public abstract class WireType {
  public abstract ProtoTypeName protoTypeName();
  public abstract String documentation();
  public abstract List<WireOption> options();
  public abstract List<WireType> nestedTypes();
  abstract void link(Linker linker);
  abstract WireType retainAll(Set<String> identifiers);

  static WireType get(ProtoTypeName protoTypeName, TypeElement type) {
    if (type instanceof EnumElement) {
      EnumElement enumElement = (EnumElement) type;

      List<WireEnumConstant> constants = new ArrayList<WireEnumConstant>();
      for (EnumConstantElement constant : enumElement.constants()) {
        constants.add(new WireEnumConstant(protoTypeName.packageName(), constant));
      }

      List<WireOption> options = new ArrayList<WireOption>();
      for (OptionElement option : enumElement.options()) {
        options.add(new WireOption(protoTypeName.packageName(), option));
      }

      return new WireEnum(protoTypeName, enumElement, constants, options);

    } else if (type instanceof MessageElement) {
      MessageElement messageElement = (MessageElement) type;
      String packageName = protoTypeName.packageName();

      List<WireField> fields = new ArrayList<WireField>();
      for (FieldElement field : messageElement.fields()) {
        fields.add(new WireField(packageName, field));
      }

      List<WireOneOf> oneOfs = new ArrayList<WireOneOf>();
      for (OneOfElement oneOf : messageElement.oneOfs()) {
        oneOfs.add(new WireOneOf(packageName, oneOf));
      }

      List<WireType> nestedTypes = new ArrayList<WireType>();
      for (TypeElement nestedType : messageElement.nestedElements()) {
        nestedTypes.add(WireType.get(protoTypeName.nestedType(nestedType.name()), nestedType));
      }

      List<WireOption> options = new ArrayList<WireOption>();
      for (OptionElement option : messageElement.options()) {
        options.add(new WireOption(packageName, option));
      }

      return new WireMessage(protoTypeName, messageElement, fields, oneOfs, nestedTypes, options);

    } else {
      throw new IllegalArgumentException("unexpected type: " + type.getClass());
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumConstantElement;
import com.squareup.protoparser.OptionElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class WireEnumConstant {
  private final String packageName;
  private final EnumConstantElement element;
  private final List<WireOption> options;

  WireEnumConstant(String packageName, EnumConstantElement element) {
    this.packageName = packageName;
    this.element = element;

    List<WireOption> options = new ArrayList<WireOption>();
    for (OptionElement option : element.options()) {
      options.add(new WireOption(packageName, option));
    }
    this.options = Collections.unmodifiableList(options);
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public int tag() {
    return element.tag();
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireOption> options() {
    return options;
  }

  void link(Linker linker) {
    for (WireOption option : options) {
      option.link(ProtoTypeName.ENUM_VALUE_OPTIONS, linker);
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.OptionElement;
import java.util.List;

public final class WireOption {
  private final String packageName;
  private final OptionElement element;
  private List<WireField> fieldPath;

  public WireOption(String packageName, OptionElement element) {
    this.packageName = packageName;
    this.element = element;
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public List<WireField> fieldPath() {
    return fieldPath;
  }

  public OptionElement.Kind kind() {
    return element.kind();
  }

  public Object value() {
    return element.value();
  }

  public boolean isParenthesized() {
    return element.isParenthesized();
  }

  void link(ProtoTypeName optionType, Linker linker) {
    fieldPath = linker.fieldPath(packageName, optionType, element.name());
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.wire.internal.Util;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class WireField {
  private final String packageName;
  private final FieldElement element;
  private final List<WireOption> options;
  private ProtoTypeName type;

  WireField(String packageName, FieldElement element) {
    this.packageName = packageName;
    this.element = element;

    List<WireOption> options = new ArrayList<WireOption>();
    for (OptionElement option : element.options()) {
      options.add(new WireOption(packageName, option));
    }
    this.options = Collections.unmodifiableList(options);
  }

  public String packageName() {
    return packageName;
  }

  public FieldElement.Label label() {
    return element.label();
  }

  public boolean isRepeated() {
    return label() == FieldElement.Label.REPEATED;
  }

  public boolean isOptional() {
    return label() == FieldElement.Label.OPTIONAL;
  }

  public boolean isRequired() {
    return label() == FieldElement.Label.REQUIRED;
  }

  public ProtoTypeName type() {
    return type;
  }

  public String name() {
    return element.name();
  }

  public int tag() {
    return element.tag();
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireOption> options() {
    return options;
  }

  public boolean isDeprecated() {
    return element.isDeprecated();
  }

  public boolean isPacked() {
    return element.isPacked();
  }

  public WireOption getDefault() {
    return Util.findOption(options, "default");
  }

  void link(Linker linker) {
    type = linker.resolveType(packageName, element.type());
    for (WireOption option : options) {
      option.link(ProtoTypeName.FIELD_OPTIONS, linker);
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.squareup.protoparser.ExtendElement;
import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.ProtoFile;
import com.squareup.protoparser.ServiceElement;
import com.squareup.protoparser.TypeElement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public final class WireProtoFile {
  private final String sourcePath;
  private final ProtoFile protoFile;
  private final List<WireType> types;
  private final List<WireService> services;
  private final List<WireExtend> wireExtends;
  private final List<WireOption> options;

  private WireProtoFile(String sourcePath, ProtoFile protoFile, List<WireType> types,
      List<WireService> services, List<WireExtend> wireExtends, List<WireOption> options) {
    this.sourcePath = sourcePath;
    this.protoFile = protoFile;
    this.types = ImmutableList.copyOf(types);
    this.services = ImmutableList.copyOf(services);
    this.wireExtends = ImmutableList.copyOf(wireExtends);
    this.options = ImmutableList.copyOf(options);
  }

  public static WireProtoFile get(String sourcePath, ProtoFile protoFile) {
    String packageName = protoFile.packageName();

    List<WireType> types = new ArrayList<WireType>();
    for (TypeElement type : protoFile.typeElements()) {
      ProtoTypeName protoTypeName = ProtoTypeName.get(packageName, type.name());
      types.add(WireType.get(protoTypeName, type));
    }

    List<WireService> services = new ArrayList<WireService>();
    for (ServiceElement service : protoFile.services()) {
      ProtoTypeName protoTypeName = ProtoTypeName.get(packageName, service.name());
      services.add(WireService.get(protoTypeName, service));
    }

    List<WireExtend> wireExtends = new ArrayList<WireExtend>();
    for (ExtendElement extend : protoFile.extendDeclarations()) {
      wireExtends.add(new WireExtend(packageName, extend));
    }

    List<WireOption> options = new ArrayList<WireOption>();
    for (OptionElement option : protoFile.options()) {
      options.add(new WireOption(packageName, option));
    }

    return new WireProtoFile(sourcePath, protoFile, types, services, wireExtends, options);
  }

  public String sourcePath() {
    return sourcePath;
  }

  
  public String name() {
    String result = sourcePath;

    int slashIndex = result.lastIndexOf('/');
    if (slashIndex != -1) {
      result = result.substring(slashIndex + 1);
    }

    if (result.endsWith(".proto")) {
      result = result.substring(0, result.length() - ".proto".length());
    }

    return result;
  }

  public String packageName() {
    return protoFile.packageName();
  }

  public List<WireType> types() {
    return types;
  }

  public List<WireService> services() {
    return services;
  }

  public List<WireExtend> wireExtends() {
    return wireExtends;
  }

  public List<WireOption> options() {
    return options;
  }

  
  WireProtoFile retainAll(Set<String> identifiers) {
    List<WireType> retainedTypes = new ArrayList<WireType>();
    for (WireType type : types) {
      WireType retainedType = type.retainAll(identifiers);
      if (retainedType != null) {
        retainedTypes.add(retainedType);
      }
    }

    List<WireService> retainedServices = new ArrayList<WireService>();
    for (WireService service : services) {
      WireService retainedService = service.retainAll(identifiers);
      if (retainedService != null) {
        retainedServices.add(retainedService);
      }
    }

    return new WireProtoFile(
        sourcePath, protoFile, retainedTypes, retainedServices, wireExtends, options);
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.RpcElement;
import com.squareup.protoparser.ServiceElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

public final class WireService {
  private final ProtoTypeName protoTypeName;
  private final ServiceElement element;
  private final List<WireRpc> rpcs;
  private final List<WireOption> options;

  private WireService(ProtoTypeName protoTypeName, ServiceElement element, List<WireRpc> rpcs,
      List<WireOption> options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.rpcs = Collections.unmodifiableList(rpcs);
    this.options = Collections.unmodifiableList(options);
  }

  public static WireService get(ProtoTypeName protoTypeName, ServiceElement element) {
    List<WireRpc> rpcs = new ArrayList<WireRpc>();
    for (RpcElement rpc : element.rpcs()) {
      rpcs.add(new WireRpc(protoTypeName.packageName(), rpc));
    }

    List<WireOption> options = new ArrayList<WireOption>();
    for (OptionElement option : element.options()) {
      options.add(new WireOption(protoTypeName.packageName(), option));
    }

    return new WireService(protoTypeName, element, rpcs, options);
  }

  public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireRpc> rpcs() {
    return rpcs;
  }

  
  public WireRpc rpc(String name) {
    for (WireRpc rpc : rpcs) {
      if (rpc.name().equals(name)) {
        return rpc;
      }
    }
    return null;
  }

  public List<WireOption> options() {
    return options;
  }

  void link(Linker linker) {
    for (WireRpc rpc : rpcs) {
      rpc.link(linker);
    }
    for (WireOption option : options) {
      option.link(ProtoTypeName.SERVICE_OPTIONS, linker);
    }
  }

  WireService retainAll(Set<String> identifiers) {
    String serviceName = protoTypeName.toString();
    if (identifiers.contains(serviceName)) {
      return this; 
    }

    List<WireRpc> retainedRpcs = new ArrayList<WireRpc>();
    for (WireRpc rpc : rpcs) {
      if (identifiers.contains(serviceName + '#' + rpc.name())) {
        retainedRpcs.add(rpc);
      }
    }

    
    if (!retainedRpcs.isEmpty()) {
      return new WireService(protoTypeName, element, retainedRpcs, options);
    }

    
    return null;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.FieldElement;
import com.squareup.protoparser.OneOfElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class WireOneOf {
  private final String packageName;
  private final OneOfElement element;
  private final List<WireField> fields;

  WireOneOf(String packageName, OneOfElement element) {
    this.packageName = packageName;
    this.element = element;

    List<WireField> fields = new ArrayList<WireField>();
    for (FieldElement field : element.fields()) {
      fields.add(new WireField(packageName, field));
    }
    this.fields = Collections.unmodifiableList(fields);
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public String documentation() {
    return element.documentation();
  }

  public List<WireField> fields() {
    return fields;
  }

  void link(Linker linker) {
    for (WireField field : fields) {
      field.link(linker);
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.OptionElement;
import com.squareup.protoparser.RpcElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class WireRpc {
  private final String packageName;
  private final RpcElement element;
  private final List<WireOption> options;
  private ProtoTypeName requestType;
  private ProtoTypeName responseType;

  WireRpc(String packageName, RpcElement element) {
    this.packageName = packageName;
    this.element = element;

    List<WireOption> options = new ArrayList<WireOption>();
    for (OptionElement option : element.options()) {
      options.add(new WireOption(packageName, option));
    }
    this.options = Collections.unmodifiableList(options);
  }

  public String packageName() {
    return packageName;
  }

  public String name() {
    return element.name();
  }

  public String documentation() {
    return element.documentation();
  }

  public ProtoTypeName requestType() {
    return requestType;
  }

  public ProtoTypeName responseType() {
    return responseType;
  }

  public List<WireOption> options() {
    return options;
  }

  void link(Linker linker) {
    requestType = linker.resolveNamedType(packageName, element.requestType().name());
    responseType = linker.resolveNamedType(packageName, element.responseType().name());
    for (WireOption option : options) {
      option.link(ProtoTypeName.METHOD_OPTIONS, linker);
    }
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.squareup.protoparser.ExtensionsElement;
import com.squareup.protoparser.MessageElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

public final class WireMessage extends WireType {
  private final ProtoTypeName protoTypeName;
  private final MessageElement element;
  private final List<WireField> fields;
  private final List<WireOneOf> oneOfs;
  private final List<WireType> nestedTypes;
  private final List<WireOption> options;

  public WireMessage(ProtoTypeName protoTypeName, MessageElement element,
      List<WireField> fields, List<WireOneOf> oneOfs,
      List<WireType> nestedTypes, List<WireOption> options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.fields = ImmutableList.copyOf(fields);
    this.oneOfs = ImmutableList.copyOf(oneOfs);
    this.nestedTypes = ImmutableList.copyOf(nestedTypes);
    this.options = ImmutableList.copyOf(options);
  }

  @Override public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  @Override public String documentation() {
    return element.documentation();
  }

  @Override public List<WireType> nestedTypes() {
    return nestedTypes;
  }

  @Override public List<WireOption> options() {
    return options;
  }

  public List<WireField> fields() {
    return fields;
  }

  public boolean hasRequiredFields() {
    for (WireField field : fieldsAndOneOfFields()) {
      if (field.isRequired()) return true;
    }
    return false;
  }

  public List<WireField> fieldsAndOneOfFields() {
    ImmutableList.Builder<WireField> result = ImmutableList.builder();
    result.addAll(fields);
    for (WireOneOf oneOf : oneOfs) {
      result.addAll(oneOf.fields());
    }
    return result.build();
  }

  
  public WireField field(String name) {
    for (WireField field : fields) {
      if (field.name().equals(name)) {
        return field;
      }
    }
    return null;
  }

  public List<WireOneOf> oneOfs() {
    return oneOfs;
  }

  public List<ExtensionsElement> extensions() {
    return element.extensions();
  }

  void link(Linker linker) {
    linker = linker.withMessage(this);
    for (WireField field : fields) {
      field.link(linker);
    }
    for (WireOneOf oneOf : oneOfs) {
      oneOf.link(linker);
    }
    for (WireType type : nestedTypes) {
      type.link(linker);
    }
    for (WireOption option : options) {
      option.link(ProtoTypeName.MESSAGE_OPTIONS, linker);
    }
  }

  @Override WireType retainAll(Set<String> identifiers) {
    List<WireType> retainedNestedTypes = new ArrayList<WireType>();
    for (WireType nestedType : nestedTypes) {
      WireType retainedNestedType = nestedType.retainAll(identifiers);
      if (retainedNestedType != null) {
        retainedNestedTypes.add(retainedNestedType);
      }
    }

    
    if (identifiers.contains(protoTypeName.toString())) {
      return new WireMessage(protoTypeName, element, fields, oneOfs, retainedNestedTypes, options);
    }

    
    if (!retainedNestedTypes.isEmpty()) {
      return new WireMessage(protoTypeName, element, Collections.<WireField>emptyList(),
          Collections.<WireOneOf>emptyList(), retainedNestedTypes, options);
    }

    
    return null;
  }
}

<code block>

package com.squareup.wire.model;

import com.squareup.protoparser.EnumElement;
import java.util.Collections;
import java.util.List;
import java.util.Set;

public final class WireEnum extends WireType {
  private final ProtoTypeName protoTypeName;
  private final EnumElement element;
  private final List<WireEnumConstant> constants;
  private final List<WireOption> options;

  WireEnum(ProtoTypeName protoTypeName, EnumElement element, List<WireEnumConstant> constants,
      List<WireOption> options) {
    this.protoTypeName = protoTypeName;
    this.element = element;
    this.constants = Collections.unmodifiableList(constants);
    this.options = Collections.unmodifiableList(options);
  }

  @Override public ProtoTypeName protoTypeName() {
    return protoTypeName;
  }

  @Override public String documentation() {
    return element.documentation();
  }

  @Override public List<WireOption> options() {
    return options;
  }

  @Override public List<WireType> nestedTypes() {
    return Collections.emptyList(); 
  }

  public List<WireEnumConstant> constants() {
    return constants;
  }

  @Override void link(Linker linker) {
    for (WireEnumConstant constant : constants) {
      constant.link(linker);
    }
    for (WireOption option : options) {
      option.link(ProtoTypeName.ENUM_OPTIONS, linker);
    }
  }

  @Override WireType retainAll(Set<String> identifiers) {
    return identifiers.contains(protoTypeName.toString()) ? this : null;
  }
}

<code block>

package com.squareup.wire.model;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


public final class Pruner {
  
  final Set<String> marks = new LinkedHashSet<String>();

  
  final Deque<String> queue = new ArrayDeque<String>();

  
  public List<WireProtoFile> retainRoots(List<WireProtoFile> protoFiles, Set<String> roots) {
    if (roots.isEmpty()) throw new IllegalArgumentException();
    if (!marks.isEmpty()) throw new IllegalStateException();

    Map<String, WireType> typesIndex = buildTypesIndex(protoFiles);
    Map<String, WireService> servicesIndex = buildServicesIndex(protoFiles);

    
    for (String s : roots) {
      mark(s);
    }

    
    for (WireProtoFile protoFile : protoFiles) {
      for (WireExtend extend : protoFile.wireExtends()) {
        markExtend(extend);
      }
      markOptions(protoFile.options());
    }

    
    for (String name; (name = queue.poll()) != null;) {
      if (ProtoTypeName.getScalar(name) != null) {
        continue; 
      }

      WireType type = typesIndex.get(name);
      if (type != null) {
        markType(type);
        continue;
      }

      WireService service = servicesIndex.get(name);
      if (service != null) {
        markService(service);
        continue;
      }

      
      int hash = name.indexOf('#');
      if (hash != -1) {
        String serviceName = name.substring(0, hash);
        String rpcName = name.substring(hash + 1);
        WireService partialService = servicesIndex.get(serviceName);
        if (partialService != null) {
          WireRpc rpc = partialService.rpc(rpcName);
          if (rpc != null) {
            markOptions(partialService.options());
            markRpc(rpc);
            continue;
          }
        }
      }

      throw new IllegalArgumentException("Unexpected type: " + name);
    }

    List<WireProtoFile> retained = new ArrayList<WireProtoFile>();
    for (WireProtoFile protoFile : protoFiles) {
      retained.add(protoFile.retainAll(marks));
    }

    return ImmutableList.copyOf(retained);
  }

  private static Map<String, WireType> buildTypesIndex(Collection<WireProtoFile> protoFiles) {
    Map<String, WireType> result = new LinkedHashMap<String, WireType>();
    for (WireProtoFile protoFile : protoFiles) {
      for (WireType type : protoFile.types()) {
        index(result, type);
      }
    }
    return ImmutableMap.copyOf(result);
  }

  private static void index(Map<String, WireType> typesByName, WireType type) {
    typesByName.put(type.protoTypeName().toString(), type);
    for (WireType nested : type.nestedTypes()) {
      index(typesByName, nested);
    }
  }

  private static Map<String, WireService> buildServicesIndex(Collection<WireProtoFile> protoFiles) {
    Map<String, WireService> result = new LinkedHashMap<String, WireService>();
    for (WireProtoFile protoFile : protoFiles) {
      for (WireService service : protoFile.services()) {
        result.put(service.protoTypeName().toString(), service);
      }
    }
    return ImmutableMap.copyOf(result);
  }

  private void mark(ProtoTypeName typeName) {
    mark(typeName.toString());
  }

  private void mark(String identifier) {
    if (marks.add(identifier)) {
      queue.add(identifier); 
    }
  }

  private void markExtend(WireExtend extend) {
    mark(extend.protoTypeName());
    markFields(extend.fields());
  }

  private void markType(WireType type) {
    markOptions(type.options());
    for (WireType nestedType : type.nestedTypes()) {
      mark(nestedType.protoTypeName());
    }
    if (type instanceof WireMessage) {
      markMessage((WireMessage) type);
    } else if (type instanceof WireEnum) {
      markEnum((WireEnum) type);
    }
  }

  private void markMessage(WireMessage message) {
    markFields(message.fields());
    for (WireOneOf oneOf : message.oneOfs()) {
      markFields(oneOf.fields());
    }
  }

  private void markEnum(WireEnum wireEnum) {
    markOptions(wireEnum.options());
    for (WireEnumConstant constant : wireEnum.constants()) {
      markOptions(constant.options());
    }
  }

  private void markFields(List<WireField> fields) {
    for (WireField field : fields) {
      markField(field);
    }
  }

  private void markField(WireField field) {
    markOptions(field.options());
    mark(field.type());
  }

  private void markOptions(List<WireOption> options) {
    for (WireOption option : options) {
      if (option.fieldPath() != null) {
        markFields(option.fieldPath());
      }
    }
  }

  private void markService(WireService service) {
    markOptions(service.options());
    for (WireRpc rpc : service.rpcs()) {
      markRpc(rpc);
    }
  }

  private void markRpc(WireRpc rpc) {
    markOptions(rpc.options());
    mark(rpc.requestType());
    mark(rpc.responseType());
  }
}

<code block>

package com.squareup.wire.model;

import java.util.LinkedHashSet;
import java.util.Set;
import org.junit.Test;

import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

public final class LinkerTest {
  @Test public void resolveFieldPathMatchesFirstSegment() throws Exception {
    assertEquals(
        asList("a", "b", "c", "d"),
        asList(Linker.resolveFieldPath("a.b.c.d", set("a", "z", "y"))));
  }

  @Test public void resolveFieldPathMatchesMultipleSegments() throws Exception {
    assertEquals(
        asList("a.b", "c", "d"),
        asList(Linker.resolveFieldPath("a.b.c.d", set("a.b", "z.b", "y.b"))));
  }

  @Test public void resolveFieldPathMatchesAllSegments() throws Exception {
    assertEquals(
        asList("a.b.c.d"),
        asList(Linker.resolveFieldPath("a.b.c.d", set("a.b.c.d", "z.b.c.d"))));
  }

  @Test public void resolveFieldPathMatchesOnlySegment() throws Exception {
    assertEquals(
        asList("a"),
        asList(Linker.resolveFieldPath("a", set("a", "b"))));
  }

  @Test public void resolveFieldPathDoesntMatch() throws Exception {
    assertNull(Linker.resolveFieldPath("a.b", set("c", "d")));
  }

  private Set<String> set(String... elements) {
    return new LinkedHashSet<String>(asList(elements));
  }
}
