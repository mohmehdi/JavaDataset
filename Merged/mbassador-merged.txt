package net.engio.mbassy.dispatch.el;

import javax.el.*;
import java.lang.reflect.Method;


public class StandardELResolutionContext extends ELContext {

	private final ELResolver resolver;
	private final FunctionMapper functionMapper;
	private final VariableMapper variableMapper;
    private final Object message;


	public StandardELResolutionContext(Object message) {
		super();
        this.message = message;
		this.functionMapper = new NoopFunctionMapper();
		this.variableMapper = new MsgMapper();


        this.resolver = new BeanELResolver(true);
	}
	



	@Override
	public ELResolver getELResolver() {
		return this.resolver;
	}


	@Override
	public FunctionMapper getFunctionMapper() {
		return this.functionMapper;
	}


	@Override
	public VariableMapper getVariableMapper() {
		return this.variableMapper;
	}


	private class MsgMapper extends VariableMapper {
        private static final String msg = "msg";

        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());

		public ValueExpression resolveVariable(final String s) {

            return !s.equals(msg) ? null : msgExpression;
		}

		public ValueExpression setVariable(String s,
				ValueExpression valueExpression) {

			return null;
		}
	}


	private class NoopFunctionMapper extends FunctionMapper {
		public Method resolveFunction(String s, String s1) {
			return null;
		}
	}

}

<code block>
package net.engio.mbassy.bus;

import net.engio.mbassy.bus.common.DeadMessage;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.common.PubSubSupport;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionManager;

import java.util.*;

import static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;


public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {



    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();

    private final MessagePublication.Factory publicationFactory;

    private final SubscriptionManager subscriptionManager;

    private final BusRuntime runtime;

    public static final String ERROR_HANDLER_MSG = "INFO: No error handler has been configured to handle exceptions during publication.\n" +
            "Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\n" +
            "Falling back to console logger.";




    public AbstractPubSubSupport(IBusConfiguration configuration) {


        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());
        if (errorHandlers.isEmpty()) {
            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());
            System.out.println(ERROR_HANDLER_MSG);
        }
        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())
                                           .add(Properties.Common.Id, UUID.randomUUID()
                                                                          .toString());

        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);
        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()
                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);
        this.publicationFactory = pubSubFeature.getPublicationFactory();
    }

    protected MessagePublication.Factory getPublicationFactory() {
        return publicationFactory;
    }


    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {
        return Collections.unmodifiableCollection(errorHandlers);
    }

    public boolean unsubscribe(Object listener) {
        return subscriptionManager.unsubscribe(listener);
    }


    public void subscribe(Object listener) {
        subscriptionManager.subscribe(listener);
    }


    @Override
    public BusRuntime getRuntime() {
        return runtime;
    }

    protected IMessagePublication createMessagePublication(T message) {
        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());
        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()
                                                                          .equals(DeadMessage.class)) {

            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);
            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));
        } else {
            return getPublicationFactory().createPublication(runtime, subscriptions, message);
        }
    }



    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {
        return subscriptionManager.getSubscriptionsByMessageType(messageType);
    }


    public void handlePublicationError(PublicationError error) {
        for (IPublicationErrorHandler errorHandler : errorHandlers) {
            errorHandler.handleError(error);
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{ " + runtime.get(Properties.Common.Id) + "}";
    }
}

<code block>
package net.engio.mbassy.bus.common;


public final class Properties {

    public static final class Handler {

        public static final String PublicationError = "bus.handlers.error";
        public static final String AsynchronousHandlerExecutor = "bus.handlers.async-executor";
    }

    public static final class Common {

        public static final String Id = "bus.id";
    }




}

<code block>
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;


public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>
        extends GenericMessagePublicationSupport<T, P>{


    @Override
    P post(T message);


    boolean hasPendingMessages();


    void shutdown();


}

<code block>
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;

import java.util.Collection;



public interface ErrorHandlingSupport {



    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();

}

<code block>
package net.engio.mbassy.listener;

import net.engio.mbassy.subscription.SubscriptionContext;


public interface IMessageFilter<M> {


    boolean accepts(M message, SubscriptionContext context);
}

<code block>
package net.engio.mbassy.subscription;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.MessageBusException;
import net.engio.mbassy.common.StrongConcurrentSet;
import net.engio.mbassy.common.WeakConcurrentSet;
import net.engio.mbassy.dispatch.*;
import net.engio.mbassy.listener.MessageHandler;

import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.Collection;


public class SubscriptionFactory {

    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{
        try {
            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);
            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);
            IHandlerInvocation invocation = buildInvocationForHandler(context);
            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);
            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()
                ? new StrongConcurrentSet<Object>()
                : new WeakConcurrentSet<Object>());
        } catch (Exception e) {
            throw new MessageBusException(e);
        }
    }

    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {
        IHandlerInvocation invocation = createBaseHandlerInvocation(context);
        if(context.getHandler().isSynchronized()){
            invocation = new SynchronizedHandlerInvocation(invocation);
        }
        if (context.getHandler().isAsynchronous()) {
            invocation = new AsynchronousHandlerInvocation(invocation);
        }
        return invocation;
    }

    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {
        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);
        if (context.getHandler().isEnveloped()) {
            dispatcher = new EnvelopedMessageDispatcher(dispatcher);
        }
        if (context.getHandler().isFiltered()) {
            dispatcher = new FilteredMessageDispatcher(dispatcher);
        }
        return dispatcher;
    }

    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {
        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();
        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){
            throw new MessageBusException("The handler invocation must be top level class or nested STATIC inner class");
        }
        try {
            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);
            return constructor.newInstance(context);
        } catch (NoSuchMethodException e) {
            throw new MessageBusException("The provided handler invocation did not specify the necessary constructor "
                    + invocation.getSimpleName() + "(SubscriptionContext);", e);
        } catch (Exception e) {
            throw new MessageBusException("Could not instantiate the provided handler invocation "
                    + invocation.getSimpleName(), e);
        }
    }
}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;


public class SyncAsyncTest extends MessageBusTest {


    @Test
    public void testSyncPublicationSyncHandlers() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.synchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
    }


    @Test
    public void testSyncPublicationAsyncHandlers() throws Exception {
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);

        final MessageManager messageManager = new MessageManager();
        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {

                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);
    }

    @Test
    public void testAsynchronousMessagePublication() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        final MessageManager messageManager = new MessageManager();

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);

                bus.post(standardMessage).asynchronously();
                bus.post(multipartMessage).asynchronously();
                bus.post(MessageTypes.Simple).asynchronously();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);

    }


    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };


        IBusConfiguration config = SyncAsync();
        config.addPublicationErrorHandler(ExceptionCounter);
        final MBassador bus = new MBassador(config);

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                bus.post(new StandardMessage()).asynchronously();

            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener, exceptionCount.get());



        exceptionCount.set(0);
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());

    }




}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.common.MessageBusTest;
import net.engio.mbassy.listener.Enveloped;
import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listener.Listener;
import net.engio.mbassy.listener.References;
import net.engio.mbassy.subscription.MessageEnvelope;
import org.junit.Test;

import java.util.HashSet;
import java.util.Set;



public class ConditionalHandlers extends MessageBusTest {

	public static class TestEvent {

		private Set<String> handledBy = new HashSet<String>();
		private String type;
		private int size;

		public TestEvent(String type, int size) {
			super();
			this.type = type;
			this.size = size;
		}
		
		public String getType() {
			return type;
		}

		public int getSize() {
			return size;
		}

        public boolean wasHandledBy(String ...handlers){
            for(String handler : handlers){
                if (!handledBy.contains(handler)) return false;
            }
            return true;
        }

        public void handledBy(String handler){
            handledBy.add(handler);
        }
		
	}

    @Listener(references = References.Strong)
	public static class ConditionalMessageListener {

		@Handler(condition = "msg.type == 'TEST'")
		public void handleTypeMessage(TestEvent message) {
			message.handledBy("handleTypeMessage");
		}

		@Handler(condition = "msg.size > 4")
		public void handleSizeMessage(TestEvent message) {
			message.handledBy("handleSizeMessage");
		}

        @Handler(condition = "msg.foo > 4")
        public void handleInvalidEL(TestEvent message) {
            message.handledBy("handleInvalidEL");
        }
		
		@Handler(condition = "msg.size > 2 && msg.size < 4")
		public void handleCombinedEL(TestEvent message) {
			message.handledBy( "handleCombinedEL");
		}
		
		@Handler(condition = "msg.getType().equals('XYZ') && msg.getSize() == 1")
		public void handleMethodAccessEL(TestEvent message) {
			message.handledBy("handleMethodAccessEL");
		}

        @Handler(condition = "msg.type == 'TEST'")
        @Enveloped(messages = {TestEvent.class, Object.class})
        public void handleEnvelopedMessage(MessageEnvelope envelope) {
            envelope.<TestEvent>getMessage().handledBy("handleEnvelopedMessage");
        }
		
	}



	@Test
	public void testSimpleStringCondition() throws Exception {
		MBassador bus = createBus(SyncAsync(false));
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("TEST", 0);
		bus.publish(message);

		assertTrue(message.wasHandledBy("handleTypeMessage", "handleEnvelopedMessage"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}



	@Test
	public void testSimpleNumberCondition() throws Exception {
		MBassador bus =  createBus(SyncAsync(false));
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 5);
		bus.publish(message);

		assertTrue(message.wasHandledBy("handleSizeMessage"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}
	

	@Test
	public void testHandleCombinedEL() throws Exception {
		MBassador bus = createBus(SyncAsync(false));
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 3);
		bus.publish(message);

        assertTrue(message.wasHandledBy("handleCombinedEL"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}
	

	@Test
	public void testNotMatchingAnyCondition() throws Exception {
		MBassador bus = createBus(SyncAsync(false));
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 0);
		bus.publish(message);

		assertTrue(message.handledBy.isEmpty());
	}
	

	@Test
	public void testHandleMethodAccessEL() throws Exception {
		MBassador bus = createBus(SyncAsync(false));
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("XYZ", 1);
		bus.publish(message);

        assertTrue(message.wasHandledBy("handleMethodAccessEL"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));

    }

}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listener.MetadataReader;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.*;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionFactory;
import net.engio.mbassy.subscription.SubscriptionManager;
import org.junit.Test;

import java.util.Collection;
import java.util.Collections;


public class SubscriptionManagerTest extends AssertSupport {

    private static final int InstancesPerListener = 5000;
    private static final int ConcurrentUnits = 10;

    @Test
    public void testIMessageListener(){
        ListenerFactory listeners = listeners(
                IMessageListener.DefaultListener.class,
                IMessageListener.AsyncListener.class,
                IMessageListener.DisabledListener.class,
                IMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testAbstractMessageListener(){
        ListenerFactory listeners = listeners(
                AbstractMessageListener.DefaultListener.class,
                AbstractMessageListener.AsyncListener.class,
                AbstractMessageListener.DisabledListener.class,
                AbstractMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)
                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)
                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMessagesListener(){
        ListenerFactory listeners = listeners(
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class,
                MessagesListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                MultipartMessageListener.DefaultListener.class,
                MultipartMessageListener.AsyncListener.class,
                MultipartMessageListener.DisabledListener.class,
                MultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testIMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                IMultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStandardMessageListener(){
        ListenerFactory listeners = listeners(
                StandardMessageListener.DefaultListener.class,
                StandardMessageListener.AsyncListener.class,
                StandardMessageListener.DisabledListener.class,
                StandardMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testICountableListener(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                ICountableListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)
                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipleMessageListeners(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStrongListenerSubscription() throws Exception {
        ListenerFactory listeners = listeners(CustomInvocationListener.class);
        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();
        runGC();

        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);
        assertEquals(1, subscriptions.size());
        for(Subscription sub : subscriptions)
            assertEquals(InstancesPerListener,  sub.size());
    }

    @Test
    public void testOverloadedMessageHandlers(){
        ListenerFactory listeners = listeners(
                Overloading.ListenerBase.class,
                Overloading.ListenerSub.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)
                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testPrioritizedMessageHandlers(){
        ListenerFactory listeners = listeners(PrioritizedListener.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    private BusRuntime mockedRuntime(){
        return new BusRuntime(null)
                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)
                .add(Properties.Handler.AsynchronousHandlerExecutor, null);
    }

    private ListenerFactory listeners(Class ...listeners){
        ListenerFactory factory = new ListenerFactory();
        for(Class listener : listeners){
            factory.create(InstancesPerListener, listener);
        }
        return factory;
    }

    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){
        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        validator.validate(subscriptionManager);

        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();

        validator.validate(subscriptionManager);
    }



    public static class PrioritizedListener{


        @net.engio.mbassy.listener.Handler(priority = 1)
        public void handlePrio1(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 2)
        public void handlePrio2(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 3)
        public void handlePrio3(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 4)
        public void handlePrio4(IMessage message){
            message.handled(this.getClass());
        }
    }


}

<code block>
package net.engio.mbassy;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;


@RunWith(Suite.class)
@Suite.SuiteClasses({
        StrongConcurrentSetTest.class,
        WeakConcurrentSetTest.class,
        SyncAsyncTest.class,
        SyncBusTest.MBassadorTest.class,
        SyncBusTest.SyncMessageBusTest.class,
        FilterTest.class,
        MetadataReaderTest.class,
        MethodDispatchTest.class,
        DeadMessageTest.class,
        SynchronizedHandlerTest.class,
        SubscriptionManagerTest.class,
        AsyncFIFOBusTest.class,
        ConditionalHandlers.class
})
public class AllTests {
}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.SyncMessageBus;
import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.ConcurrentExecutor;
import net.engio.mbassy.common.ListenerFactory;
import net.engio.mbassy.common.MessageBusTest;
import net.engio.mbassy.common.TestUtil;
import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listeners.CustomInvocationListener;
import net.engio.mbassy.listeners.ExceptionThrowingListener;
import net.engio.mbassy.listeners.IMessageListener;
import net.engio.mbassy.listeners.MessagesListener;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;


public abstract class SyncBusTest extends MessageBusTest {


    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);

    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);

    @Test
    public void testSynchronousMessagePublication() throws Exception {

        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, IMessageListener.DefaultListener.class)
                .create(InstancesPerListener, IMessageListener.DisabledListener.class)
                .create(InstancesPerListener, MessagesListener.DefaultListener.class)
                .create(InstancesPerListener, MessagesListener.DisabledListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();
                bus.post(MessageTypes.Multipart).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));
    }



    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };


        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publish = new Runnable() {
            @Override
            public void run() {
                bus.post(new StandardMessage()).now();
            }
        };


        ConcurrentExecutor.runConcurrent(publish, 1);

        exceptionCount.set(0);


        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());
    }

    @Test
    public void testCustomHandlerInvocation(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, CustomInvocationListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }

    @Test
    public void testHandlerPriorities(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, PrioritizedListener.class)
                .create(InstancesPerListener, Object.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                bus.post(new IncrementingMessage()).now();
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }


    public static class MBassadorTest extends SyncBusTest {


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());
            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));
            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));
            if (errorHandler != null) {
                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);
            }
            return new MBassador(asyncFIFOConfig);

        }


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }

    }

    public static class SyncMessageBusTest extends SyncBusTest {


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());
            if (errorHandler != null) {
                syncPubSubCfg.addPublicationErrorHandler(errorHandler);
            }
            return new SyncMessageBus(syncPubSubCfg);
        }

        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }
    }





    static class IncrementingMessage{

        private int count = 1;

        public void markHandled(int newVal){

            if(count == newVal || count + 1 == newVal) count = newVal;
            else throw new RuntimeException("Message was handled out of order");
        }
    }


    public static class PrioritizedListener{

        @Handler(priority = Integer.MIN_VALUE)
        public void handle1(IncrementingMessage message) {
            message.markHandled(4);
        }

        @Handler(priority = -2)
        public void handle2(IncrementingMessage message) {
            message.markHandled(3);
        }

        @Handler
        public void handle3(IncrementingMessage message) {
            message.markHandled(2);
        }

        @Handler(priority = Integer.MAX_VALUE)
        public void handle4(IncrementingMessage message) {
            message.markHandled(1);
        }


    }



}

<code block>
package net.engio.mbassy.bus;

import com.mycila.testing.junit.MycilaJunitRunner;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.MessageBusTest;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


@RunWith(MycilaJunitRunner.class)
public class AbstractPubSubSupportTest {

    IBusConfiguration configuration;

    @Mock
    IPublicationErrorHandler handler1;

    @Mock
    IPublicationErrorHandler handler2;

    @Mock
    IPublicationErrorHandler handler3;

    @Mock
    PublicationError publicationError;


    @Before
    public void setup() {
        configuration = MessageBusTest.SyncAsync();
    }


    @Test
    public void testHandlePublicationError_handlers_present_sync() {


        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);

        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_handlers_present_async() {


        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);

        MBassador<String> bus = new MBassador<String>(configuration);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }


    @Test
    public void testHandlePublicationError_construct_with_handler_sync() {



        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_constrcut_with_handler_async() {


        configuration.addPublicationErrorHandler(handler1);

        MBassador<String> bus = new MBassador<String>(handler1);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {

        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            MBassador<String> bus = new MBassador<String>(configuration);
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);

            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }

    @Test
    public void testHandlePublicationError_default_construct_sync() {

        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            SyncMessageBus<String> bus = new SyncMessageBus<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);

            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }
    }

    @Test
    public void testHandlePublicationError_default_construct_async() {

        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            MBassador<String> bus = new MBassador<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);

            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }


}
<code block>
package net.engio.mbassy.listeners;

import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listener.Listener;
import net.engio.mbassy.listener.References;
import net.engio.mbassy.messages.StandardMessage;


@Listener(references = References.Strong)
public class ExceptionThrowingListener {



    @Handler()
    public void handle(StandardMessage message) {
        throw new RuntimeException("This is an expected exception");
    }


}

<code block>
package net.engio.mbassy.common;

import net.engio.mbassy.bus.IMessagePublication;
import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.messages.MessageTypes;
import org.junit.Before;


public abstract class MessageBusTest extends AssertSupport {




    protected static final int processingTimeInMS = 6000;
    protected static final int InstancesPerListener = 5000;
    protected static final int ConcurrentUnits = 10;
    protected static final int IterationsPerThread = 100;

    public static final class AssertionErrorHandler implements IPublicationErrorHandler{

        private boolean failOnException;

        public AssertionErrorHandler(boolean failOnException) {
            this.failOnException = failOnException;
        }

        @Override
        public void handleError(PublicationError error) {
            if(failOnException)
                org.junit.Assert.fail(error.getCause().getMessage());
        }
    }

    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();

    @Before
    public void setUp(){
        issuedPublications = new StrongConcurrentSet<IMessagePublication>();
        for(MessageTypes mes : MessageTypes.values())
            mes.reset();
    }

    public static IBusConfiguration SyncAsync() {
        return SyncAsync(true);
    }

    public static IBusConfiguration SyncAsync(boolean failOnError) {
        return new BusConfiguration()
            .addFeature(Feature.SyncPubSub.Default())
            .addFeature(Feature.AsynchronousHandlerInvocation.Default())
            .addFeature(Feature.AsynchronousMessageDispatch.Default());


    }

    public MBassador createBus(IBusConfiguration configuration) {
        MBassador bus = new MBassador(configuration);
        return bus;
    }

    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {
        MBassador bus = new MBassador(configuration);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);
        return bus;
    }

    protected void track(IMessagePublication asynchronously) {
        issuedPublications.add(asynchronously);
    }

    public void waitForPublications(long timeOutInMs){
        long start = System.currentTimeMillis();
        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){
            for(IMessagePublication pub : issuedPublications){
                if(pub.isFinished())
                    issuedPublications.remove(pub);
            }
        }
        if(issuedPublications.size() > 0)
            fail("Issued publications did not finish within specified timeout of " + timeOutInMs + " ms");
    }

    public void addPublication(IMessagePublication publication){
        issuedPublications.add(publication);
    }

}

<code block>
package net.engio.mbassy.common;

import net.engio.mbassy.messages.IMessage;

import java.util.Collection;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class MessageManager {
	private static final Logger LOG =
			LoggerFactory.getLogger(MessageManager.class);


    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();


    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void waitForMessages(int timeoutInMs){
        long start = System.currentTimeMillis();
        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){

            for(MessageContext messageCtx : messages){
                boolean handledCompletely = true;
                for(Class listener : messageCtx.getListeners()){
                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();
                }

                if(handledCompletely){
                    logSuccess(messageCtx);
                    messages.remove(messageCtx);
                }

            }
            pause(100);
        }
        if(messages.size() > 0){
            logFailingMessages(messages);
            throw new RuntimeException("Message were not fully processed in given time");
        }


    }

    private void pause(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

   private void logSuccess(MessageContext mCtx){
       LOG.info("Message " + mCtx.getMessage() + " was successfully handled " + mCtx.getExpectedCount() + " times by " + mCtx.printListeners());
   }



    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){
        StringBuilder errorMessage = new StringBuilder();
        errorMessage.append("Failing messages:\n");
        for(MessageContext failingMessage : failing)
            errorMessage.append(failingMessage);
        LOG.info(errorMessage.toString());
    }

    private class MessageContext{

        private long expectedCount;
        private IMessage message;
        private Class[] listeners;

        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners;
        }

        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners.toArray(new Class[]{});
        }

        private long getExpectedCount() {
            return expectedCount;
        }

        private IMessage getMessage() {
            return message;
        }

        private Class[] getListeners() {
            return listeners;
        }

        private String printListeners(){
            StringBuilder listenersAsString = new StringBuilder();
            for(Class listener : listeners){
                listenersAsString.append(listener.getName());
                listenersAsString.append(",");
            }
            return listenersAsString.toString();
        }

        @Override
        public String toString() {

            return message.getClass().getSimpleName() + "{" +
                    "expectedCount=" + expectedCount +
                    ", listeners=" + printListeners() +
                    '}';
        }
    }


}

<code block>
package net.engio.mbassy.dispatch.el;

import javax.el.*;
import java.lang.reflect.Method;


public class StandardELResolutionContext extends ELContext {

	private final ELResolver resolver;
	private final FunctionMapper functionMapper;
	private final VariableMapper variableMapper;
    private final Object message;


	public StandardELResolutionContext(Object message) {
		super();
        this.message = message;
		this.functionMapper = new NoopFunctionMapper();
		this.variableMapper = new MsgMapper();


        this.resolver = new BeanELResolver(true);
	}
	



	@Override
	public ELResolver getELResolver() {
		return this.resolver;
	}


	@Override
	public FunctionMapper getFunctionMapper() {
		return this.functionMapper;
	}


	@Override
	public VariableMapper getVariableMapper() {
		return this.variableMapper;
	}


	private class MsgMapper extends VariableMapper {
        private static final String msg = "msg";

        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());

		public ValueExpression resolveVariable(final String s) {

            return !s.equals(msg) ? null : msgExpression;
		}

		public ValueExpression setVariable(String s,
				ValueExpression valueExpression) {

			return null;
		}
	}


	private class NoopFunctionMapper extends FunctionMapper {
		public Method resolveFunction(String s, String s1) {
			return null;
		}
	}

}

<code block>
package net.engio.mbassy.bus;

import net.engio.mbassy.bus.common.DeadMessage;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.common.PubSubSupport;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionManager;

import java.util.*;

import static net.engio.mbassy.bus.common.Properties.Handler.PublicationErrorHandlers;


public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {



    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();

    private final MessagePublication.Factory publicationFactory;

    private final SubscriptionManager subscriptionManager;

    private final BusRuntime runtime;

    public static final String ERROR_HANDLER_MSG = "INFO: No error handler has been configured to handle exceptions during publication.\n" +
            "Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\n" +
            "Falling back to console logger.";




    public AbstractPubSubSupport(IBusConfiguration configuration) {


        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());
        if (errorHandlers.isEmpty()) {
            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());
            System.out.println(ERROR_HANDLER_MSG);
        }
        this.runtime = new BusRuntime(this).add(PublicationErrorHandlers, getRegisteredErrorHandlers())
                                           .add(Properties.Common.Id, UUID.randomUUID()
                                                                          .toString());

        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);
        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()
                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);
        this.publicationFactory = pubSubFeature.getPublicationFactory();
    }

    protected MessagePublication.Factory getPublicationFactory() {
        return publicationFactory;
    }


    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {
        return Collections.unmodifiableCollection(errorHandlers);
    }

    public boolean unsubscribe(Object listener) {
        return subscriptionManager.unsubscribe(listener);
    }


    public void subscribe(Object listener) {
        subscriptionManager.subscribe(listener);
    }


    @Override
    public BusRuntime getRuntime() {
        return runtime;
    }

    protected IMessagePublication createMessagePublication(T message) {
        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());
        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()
                                                                          .equals(DeadMessage.class)) {

            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);
            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));
        } else {
            return getPublicationFactory().createPublication(runtime, subscriptions, message);
        }
    }



    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {
        return subscriptionManager.getSubscriptionsByMessageType(messageType);
    }


    protected void handlePublicationError(PublicationError error) {
        for (IPublicationErrorHandler errorHandler : errorHandlers) {
            errorHandler.handleError(error);
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{ " + runtime.get(Properties.Common.Id) + "}";
    }
}

<code block>
package net.engio.mbassy.bus.common;


public final class Properties {

    public static final class Handler {

        public static final String PublicationErrorHandlers = "bus.handlers.error";
        public static final String AsynchronousHandlerExecutor = "bus.handlers.async-executor";
    }

    public static final class Common {

        public static final String Id = "bus.id";
    }




}

<code block>
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;


public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>
        extends GenericMessagePublicationSupport<T, P>{


    @Override
    P post(T message);


    boolean hasPendingMessages();


    void shutdown();


}

<code block>
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;

import java.util.Collection;



public interface ErrorHandlingSupport {



    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();

}

<code block>
package net.engio.mbassy.listener;

import net.engio.mbassy.subscription.SubscriptionContext;


public interface IMessageFilter<M> {


    boolean accepts(M message, SubscriptionContext context);
}

<code block>
package net.engio.mbassy.subscription;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.MessageBusException;
import net.engio.mbassy.common.StrongConcurrentSet;
import net.engio.mbassy.common.WeakConcurrentSet;
import net.engio.mbassy.dispatch.*;
import net.engio.mbassy.listener.MessageHandler;

import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.Collection;


public class SubscriptionFactory {

    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{
        try {
            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationErrorHandlers);
            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);
            IHandlerInvocation invocation = buildInvocationForHandler(context);
            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);
            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()
                ? new StrongConcurrentSet<Object>()
                : new WeakConcurrentSet<Object>());
        } catch (Exception e) {
            throw new MessageBusException(e);
        }
    }

    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {
        IHandlerInvocation invocation = createBaseHandlerInvocation(context);
        if(context.getHandler().isSynchronized()){
            invocation = new SynchronizedHandlerInvocation(invocation);
        }
        if (context.getHandler().isAsynchronous()) {
            invocation = new AsynchronousHandlerInvocation(invocation);
        }
        return invocation;
    }

    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {
        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);
        if (context.getHandler().isEnveloped()) {
            dispatcher = new EnvelopedMessageDispatcher(dispatcher);
        }
        if (context.getHandler().isFiltered()) {
            dispatcher = new FilteredMessageDispatcher(dispatcher);
        }
        return dispatcher;
    }

    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {
        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();
        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){
            throw new MessageBusException("The handler invocation must be top level class or nested STATIC inner class");
        }
        try {
            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);
            return constructor.newInstance(context);
        } catch (NoSuchMethodException e) {
            throw new MessageBusException("The provided handler invocation did not specify the necessary constructor "
                    + invocation.getSimpleName() + "(SubscriptionContext);", e);
        } catch (Exception e) {
            throw new MessageBusException("Could not instantiate the provided handler invocation "
                    + invocation.getSimpleName(), e);
        }
    }
}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.common.MessageBusTest;
import net.engio.mbassy.listener.Enveloped;
import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listener.Listener;
import net.engio.mbassy.listener.References;
import net.engio.mbassy.subscription.MessageEnvelope;
import org.junit.Test;

import java.util.HashSet;
import java.util.Set;



public class ConditionalHandlerTest extends MessageBusTest {


	@Test
	public void testSimpleStringCondition(){
		MBassador bus = createBus(SyncAsync());
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("TEST", 0);
		bus.publish(message);

		assertTrue(message.wasHandledBy("handleTypeMessage", "handleEnvelopedMessage"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}

	@Test
	public void testSimpleNumberCondition(){
		MBassador bus =  createBus(SyncAsync());
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 5);
		bus.publish(message);

		assertTrue(message.wasHandledBy("handleSizeMessage"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}

	@Test
	public void testHandleCombinedEL(){
		MBassador bus = createBus(SyncAsync());
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 3);
		bus.publish(message);

        assertTrue(message.wasHandledBy("handleCombinedEL"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));
	}

	@Test
	public void testNotMatchingAnyCondition(){
		MBassador bus = createBus(SyncAsync());
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("", 0);
		bus.publish(message);

		assertTrue(message.handledBy.isEmpty());
	}

	@Test
	public void testHandleMethodAccessEL(){
		MBassador bus = createBus(SyncAsync());
		bus.subscribe(new ConditionalMessageListener());

		TestEvent message = new TestEvent("XYZ", 1);
		bus.publish(message);

        assertTrue(message.wasHandledBy("handleMethodAccessEL"));
        assertFalse(message.wasHandledBy("handleInvalidEL"));

    }

    public static class TestEvent {

        private Set<String> handledBy = new HashSet<String>();
        private String type;
        private int size;

        public TestEvent(String type, int size) {
            super();
            this.type = type;
            this.size = size;
        }

        public String getType() {
            return type;
        }

        public int getSize() {
            return size;
        }

        public boolean wasHandledBy(String ...handlers){
            for(String handler : handlers){
                if (!handledBy.contains(handler)) return false;
            }
            return true;
        }

        public void handledBy(String handler){
            handledBy.add(handler);
        }

    }

    @Listener(references = References.Strong)
    public static class ConditionalMessageListener {

        @Handler(condition = "msg.type == 'TEST'")
        public void handleTypeMessage(TestEvent message) {
            message.handledBy("handleTypeMessage");
        }

        @Handler(condition = "msg.size > 4")
        public void handleSizeMessage(TestEvent message) {
            message.handledBy("handleSizeMessage");
        }

        @Handler(condition = "msg.foo > 4")
        public void handleInvalidEL(TestEvent message) {
            message.handledBy("handleInvalidEL");
        }

        @Handler(condition = "msg.size > 2 && msg.size < 4")
        public void handleCombinedEL(TestEvent message) {
            message.handledBy( "handleCombinedEL");
        }

        @Handler(condition = "msg.getType().equals('XYZ') && msg.getSize() == 1")
        public void handleMethodAccessEL(TestEvent message) {
            message.handledBy("handleMethodAccessEL");
        }

        @Handler(condition = "msg.type == 'TEST'")
        @Enveloped(messages = {TestEvent.class, Object.class})
        public void handleEnvelopedMessage(MessageEnvelope envelope) {
            envelope.<TestEvent>getMessage().handledBy("handleEnvelopedMessage");
        }

    }

    public static IBusConfiguration SyncAsync() {
        return MessageBusTest.SyncAsync(false)
                .addPublicationErrorHandler(new EmptyErrorHandler());
    }



}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;


public class SyncAsyncTest extends MessageBusTest {


    @Test
    public void testSyncPublicationSyncHandlers() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.synchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
    }


    @Test
    public void testSyncPublicationAsyncHandlers() throws Exception {
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);

        final MessageManager messageManager = new MessageManager();
        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {

                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);
    }

    @Test
    public void testAsynchronousMessagePublication() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        final MessageManager messageManager = new MessageManager();

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);

                bus.post(standardMessage).asynchronously();
                bus.post(multipartMessage).asynchronously();
                bus.post(MessageTypes.Simple).asynchronously();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);

    }


    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };


        IBusConfiguration config = SyncAsync(false)
            .addPublicationErrorHandler(ExceptionCounter);

        final MBassador bus = new MBassador(config);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable asynchronousPublication = new Runnable() {
            @Override
            public void run() {
                bus.post(new Object()).asynchronously();
            }
        };


        ConcurrentExecutor.runConcurrent(asynchronousPublication, 1);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener, exceptionCount.get());



        exceptionCount.set(0);
        ConcurrentExecutor.runConcurrent(asynchronousPublication, ConcurrentUnits);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());

    }




}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listener.MetadataReader;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.*;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionFactory;
import net.engio.mbassy.subscription.SubscriptionManager;
import org.junit.Test;

import java.util.Collection;
import java.util.Collections;


public class SubscriptionManagerTest extends AssertSupport {

    private static final int InstancesPerListener = 5000;
    private static final int ConcurrentUnits = 10;

    @Test
    public void testIMessageListener(){
        ListenerFactory listeners = listeners(
                IMessageListener.DefaultListener.class,
                IMessageListener.AsyncListener.class,
                IMessageListener.DisabledListener.class,
                IMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testAbstractMessageListener(){
        ListenerFactory listeners = listeners(
                AbstractMessageListener.DefaultListener.class,
                AbstractMessageListener.AsyncListener.class,
                AbstractMessageListener.DisabledListener.class,
                AbstractMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)
                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)
                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMessagesListener(){
        ListenerFactory listeners = listeners(
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class,
                MessagesListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                MultipartMessageListener.DefaultListener.class,
                MultipartMessageListener.AsyncListener.class,
                MultipartMessageListener.DisabledListener.class,
                MultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testIMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                IMultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStandardMessageListener(){
        ListenerFactory listeners = listeners(
                StandardMessageListener.DefaultListener.class,
                StandardMessageListener.AsyncListener.class,
                StandardMessageListener.DisabledListener.class,
                StandardMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testICountableListener(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                ICountableListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)
                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipleMessageListeners(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStrongListenerSubscription() throws Exception {
        ListenerFactory listeners = listeners(CustomInvocationListener.class);
        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();
        runGC();

        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);
        assertEquals(1, subscriptions.size());
        for(Subscription sub : subscriptions)
            assertEquals(InstancesPerListener,  sub.size());
    }

    @Test
    public void testOverloadedMessageHandlers(){
        ListenerFactory listeners = listeners(
                Overloading.ListenerBase.class,
                Overloading.ListenerSub.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)
                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testPrioritizedMessageHandlers(){
        ListenerFactory listeners = listeners(PrioritizedListener.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    private BusRuntime mockedRuntime(){
        return new BusRuntime(null)
                .add(Properties.Handler.PublicationErrorHandlers, Collections.EMPTY_SET)
                .add(Properties.Handler.AsynchronousHandlerExecutor, null);
    }

    private ListenerFactory listeners(Class ...listeners){
        ListenerFactory factory = new ListenerFactory();
        for(Class listener : listeners){
            factory.create(InstancesPerListener, listener);
        }
        return factory;
    }

    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){
        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        validator.validate(subscriptionManager);

        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();

        validator.validate(subscriptionManager);
    }



    public static class PrioritizedListener{


        @net.engio.mbassy.listener.Handler(priority = 1)
        public void handlePrio1(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 2)
        public void handlePrio2(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 3)
        public void handlePrio3(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 4)
        public void handlePrio4(IMessage message){
            message.handled(this.getClass());
        }
    }


}

<code block>
package net.engio.mbassy;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;


@RunWith(Suite.class)
@Suite.SuiteClasses({
        StrongConcurrentSetTest.class,
        WeakConcurrentSetTest.class,
        SyncAsyncTest.class,
        SyncBusTest.MBassadorTest.class,
        SyncBusTest.SyncMessageBusTest.class,
        FilterTest.class,
        MetadataReaderTest.class,
        MethodDispatchTest.class,
        DeadMessageTest.class,
        SynchronizedHandlerTest.class,
        SubscriptionManagerTest.class,
        AsyncFIFOBusTest.class,
        ConditionalHandlerTest.class
})
public class AllTests {
}

<code block>
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.SyncMessageBus;
import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.ConcurrentExecutor;
import net.engio.mbassy.common.ListenerFactory;
import net.engio.mbassy.common.MessageBusTest;
import net.engio.mbassy.common.TestUtil;
import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listeners.CustomInvocationListener;
import net.engio.mbassy.listeners.ExceptionThrowingListener;
import net.engio.mbassy.listeners.IMessageListener;
import net.engio.mbassy.listeners.MessagesListener;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;


public abstract class SyncBusTest extends MessageBusTest {


    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);

    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);

    @Test
    public void testSynchronousMessagePublication() throws Exception {

        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, IMessageListener.DefaultListener.class)
                .create(InstancesPerListener, IMessageListener.DisabledListener.class)
                .create(InstancesPerListener, MessagesListener.DefaultListener.class)
                .create(InstancesPerListener, MessagesListener.DisabledListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();
                bus.post(MessageTypes.Multipart).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));
    }



    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };


        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publish = new Runnable() {
            @Override
            public void run() {
                bus.post(new Object()).now();
            }
        };


        ConcurrentExecutor.runConcurrent(publish, 1);
        assertEquals(InstancesPerListener, exceptionCount.get());
        exceptionCount.set(0); 


        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());
    }

    @Test
    public void testCustomHandlerInvocation(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, CustomInvocationListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }

    @Test
    public void testHandlerPriorities(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, PrioritizedListener.class)
                .create(InstancesPerListener, Object.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                bus.post(new IncrementingMessage()).now();
            }
        };


        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);


        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }


    public static class MBassadorTest extends SyncBusTest {


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());
            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));
            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));
            if (errorHandler != null) {
                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);
            }
            return new MBassador(asyncFIFOConfig);

        }


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }

    }

    public static class SyncMessageBusTest extends SyncBusTest {


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());
            if (errorHandler != null) {
                syncPubSubCfg.addPublicationErrorHandler(errorHandler);
            }
            return new SyncMessageBus(syncPubSubCfg);
        }

        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }
    }





    static class IncrementingMessage{

        private int count = 1;

        public void markHandled(int newVal){

            if(count == newVal || count + 1 == newVal) count = newVal;
            else throw new RuntimeException("Message was handled out of order");
        }
    }


    public static class PrioritizedListener{

        @Handler(priority = Integer.MIN_VALUE)
        public void handle1(IncrementingMessage message) {
            message.markHandled(4);
        }

        @Handler(priority = -2)
        public void handle2(IncrementingMessage message) {
            message.markHandled(3);
        }

        @Handler
        public void handle3(IncrementingMessage message) {
            message.markHandled(2);
        }

        @Handler(priority = Integer.MAX_VALUE)
        public void handle4(IncrementingMessage message) {
            message.markHandled(1);
        }


    }



}

<code block>
package net.engio.mbassy.bus;

import com.mycila.testing.junit.MycilaJunitRunner;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.MessageBusTest;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


@RunWith(MycilaJunitRunner.class)
public class AbstractPubSubSupportTest {

    IBusConfiguration configuration;

    @Mock
    IPublicationErrorHandler handler1;

    @Mock
    IPublicationErrorHandler handler2;

    @Mock
    IPublicationErrorHandler handler3;

    @Mock
    PublicationError publicationError;


    @Before
    public void setup() {
        configuration = MessageBusTest.SyncAsync(false);
    }


    @Test
    public void testHandlePublicationError_handlers_present_sync() {


        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);

        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_handlers_present_async() {


        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);

        MBassador<String> bus = new MBassador<String>(configuration);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }


    @Test
    public void testHandlePublicationError_construct_with_handler_sync() {



        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_constrcut_with_handler_async() {


        configuration.addPublicationErrorHandler(handler1);

        MBassador<String> bus = new MBassador<String>(handler1);
        bus.handlePublicationError(publicationError);

        verify(handler1).handleError(publicationError);
    }


    @Test
    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {

        PrintStream old = null;
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            MBassador<String> bus = new MBassador<String>(configuration);

            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }

    @Test
    public void testHandlePublicationError_default_construct_sync() {

        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            SyncMessageBus<String> bus = new SyncMessageBus<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);

            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }
    }

    @Test
    public void testHandlePublicationError_default_construct_async() {

        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);

            MBassador<String> bus = new MBassador<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);

            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }


}
<code block>
package net.engio.mbassy.listeners;

import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listener.Listener;
import net.engio.mbassy.listener.References;


@Listener(references = References.Strong)
public class ExceptionThrowingListener {


    @Handler()
    public void handle(Object message) {
        throw new RuntimeException("This is an expected exception");
    }


}

<code block>
package net.engio.mbassy.common;

import net.engio.mbassy.bus.IMessagePublication;
import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.messages.MessageTypes;
import org.junit.Before;


public abstract class MessageBusTest extends AssertSupport {




    protected static final int processingTimeInMS = 6000;
    protected static final int InstancesPerListener = 5000;
    protected static final int ConcurrentUnits = 10;
    protected static final int IterationsPerThread = 100;

    public static final class AssertionErrorHandler implements IPublicationErrorHandler{

        private boolean failOnException;

        public AssertionErrorHandler(boolean failOnException) {
            this.failOnException = failOnException;
        }

        @Override
        public void handleError(PublicationError error) {
            if(failOnException)
                org.junit.Assert.fail(error.getCause().getMessage());
        }
    }

    public static final class EmptyErrorHandler implements IPublicationErrorHandler{

        @Override
        public void handleError(PublicationError error) {
        }
    }

    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();

    @Before
    public void setUp(){
        issuedPublications = new StrongConcurrentSet<IMessagePublication>();
        for(MessageTypes mes : MessageTypes.values())
            mes.reset();
    }

    public static IBusConfiguration SyncAsync() {
        return SyncAsync(true);
    }

    public static IBusConfiguration SyncAsync(boolean failOnError) {
        IBusConfiguration config = new BusConfiguration()
            .addFeature(Feature.SyncPubSub.Default())
            .addFeature(Feature.AsynchronousHandlerInvocation.Default())
            .addFeature(Feature.AsynchronousMessageDispatch.Default());
        if(failOnError)
            config.addPublicationErrorHandler(new AssertionErrorHandler(failOnError));
        return config;
    }

    public MBassador createBus(IBusConfiguration configuration) {
        MBassador bus = new MBassador(configuration);
        return bus;
    }

    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {
        MBassador bus = new MBassador(configuration);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);
        return bus;
    }

    protected void track(IMessagePublication asynchronously) {
        issuedPublications.add(asynchronously);
    }

    public void waitForPublications(long timeOutInMs){
        long start = System.currentTimeMillis();
        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){
            for(IMessagePublication pub : issuedPublications){
                if(pub.isFinished())
                    issuedPublications.remove(pub);
            }
        }
        if(issuedPublications.size() > 0)
            fail("Issued publications did not finish within specified timeout of " + timeOutInMs + " ms");
    }

    public void addPublication(IMessagePublication publication){
        issuedPublications.add(publication);
    }

}

<code block>
package net.engio.mbassy.common;

import net.engio.mbassy.messages.IMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;


public class MessageManager {
	private static final Logger LOG =
			LoggerFactory.getLogger(MessageManager.class);


    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();


    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void waitForMessages(int timeoutInMs){
        long start = System.currentTimeMillis();
        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){

            for(MessageContext messageCtx : messages){
                boolean handledCompletely = true;
                for(Class listener : messageCtx.getListeners()){
                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();
                }

                if(handledCompletely){
                    logSuccess(messageCtx);
                    messages.remove(messageCtx);
                }

            }
            pause(100);
        }
        if(messages.size() > 0){
            logFailingMessages(messages);
            throw new RuntimeException("Message were not fully processed in given time");
        }


    }

    private void pause(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

   private void logSuccess(MessageContext mCtx){
       LOG.info(mCtx.getMessage().getClass().getSimpleName() + " successfully handled " + mCtx.getExpectedCount() + " times by " + mCtx.printListeners());
   }



    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){
        StringBuilder errorMessage = new StringBuilder();
        errorMessage.append("Failing messages:\n");
        for(MessageContext failingMessage : failing)
            errorMessage.append(failingMessage);
        LOG.info(errorMessage.toString());
    }

    private class MessageContext{

        private long expectedCount;
        private IMessage message;
        private Class[] listeners;

        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners;
        }

        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners.toArray(new Class[]{});
        }

        private long getExpectedCount() {
            return expectedCount;
        }

        private IMessage getMessage() {
            return message;
        }

        private Class[] getListeners() {
            return listeners;
        }

        private String printListeners(){
            StringBuilder listenersAsString = new StringBuilder();
            for(Class listener : listeners){
                listenersAsString.append(listener.getName());
                listenersAsString.append(",");
            }
            return listenersAsString.toString();
        }

        @Override
        public String toString() {

            return message.getClass().getSimpleName() + "{" +
                    "expectedCount=" + expectedCount +
                    ", listeners=" + printListeners() +
                    '}';
        }
    }


}
