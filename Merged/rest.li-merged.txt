

package com.linkedin.pegasus.generator;


import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.generator.AbstractGenerator;
import com.linkedin.data.schema.resolver.FileDataSchemaLocation;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.util.FileUtil;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JPackage;
import com.sun.codemodel.writer.FileCodeWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class PegasusDataTemplateGenerator
{
  
  public static final String GENERATOR_GENERATE_IMPORTED = "generator.generate.imported";

  private static final Logger _log = LoggerFactory.getLogger(PegasusDataTemplateGenerator.class);

  public static class DataTemplatePersistentClassChecker implements JavaCodeUtil.PersistentClassChecker
  {
    private final boolean _generateImported;
    private final TemplateSpecGenerator _specGenerator;
    private final JavaDataTemplateGenerator _dataTemplateGenerator;
    private final Set<File> _sourceFiles;

    public DataTemplatePersistentClassChecker(boolean generateImported,
                                              TemplateSpecGenerator specGenerator,
                                              JavaDataTemplateGenerator dataTemplateGenerator,
                                              Set<File> sourceFiles)
    {
      _generateImported = generateImported;
      _specGenerator = specGenerator;
      _dataTemplateGenerator = dataTemplateGenerator;
      _sourceFiles = sourceFiles;
    }

    @Override
    public boolean isPersistent(JDefinedClass clazz)
    {
      if (_generateImported)
      {
        return true;
      }
      else
      {
        final ClassTemplateSpec spec = _dataTemplateGenerator.getGeneratedClasses().get(clazz);
        final DataSchemaLocation location = _specGenerator.getClassLocation(spec);
        return location == null  
            || _sourceFiles.contains(location.getSourceFile());
      }
    }
  }

  public static void main(String[] args)
      throws IOException
  {
    if (args.length < 2)
    {
      _log.error("Usage: PegasusDataTemplateGenerator targetDirectoryPath [sourceFile or sourceDirectory or schemaName]+");
      System.exit(1);
    }

    final String generateImportedProperty = System.getProperty(PegasusDataTemplateGenerator.GENERATOR_GENERATE_IMPORTED);
    final boolean generateImported = generateImportedProperty == null ? true : Boolean.parseBoolean(generateImportedProperty);
    PegasusDataTemplateGenerator.run(System.getProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH),
                                     System.getProperty(JavaCodeGeneratorBase.GENERATOR_DEFAULT_PACKAGE),
                                     generateImported,
                                     args[0],
                                     Arrays.copyOfRange(args, 1, args.length));
  }

  public static GeneratorResult run(String resolverPath, String defaultPackage, final boolean generateImported, String targetDirectoryPath, String[] sources)
      throws IOException
  {
    final DataSchemaParser schemaParser = new DataSchemaParser(resolverPath);
    final TemplateSpecGenerator specGenerator = new TemplateSpecGenerator(schemaParser.getSchemaResolver());
    final JavaDataTemplateGenerator dataTemplateGenerator = new JavaDataTemplateGenerator(defaultPackage);

    for (DataSchema predefinedSchema : JavaDataTemplateGenerator.PredefinedJavaClasses.keySet())
    {
      specGenerator.registerDefinedSchema(predefinedSchema);
    }

    final DataSchemaParser.ParseResult parseResult = schemaParser.parseSources(sources);

    for (CodeUtil.Pair<DataSchema, File> pair : parseResult.getSchemaAndFiles())
    {
      final DataSchemaLocation location = new FileDataSchemaLocation(pair.second);
      specGenerator.generate(pair.first, location);
    }
    for (CodeUtil.Pair<DataSchema, DataSchemaLocation> pair : parseResult.getSchemaAndLocations())
    {
      specGenerator.generate(pair.first, pair.second);
    }
    for (ClassTemplateSpec spec : specGenerator.getGeneratedSpecs())
    {
      dataTemplateGenerator.generate(spec);
    }

    final JavaCodeUtil.PersistentClassChecker checker = new DataTemplatePersistentClassChecker(generateImported, specGenerator, dataTemplateGenerator, parseResult.getSourceFiles());

    final File targetDirectory = new File(targetDirectoryPath);
    final List<File> targetFiles = JavaCodeUtil.targetFiles(targetDirectory, dataTemplateGenerator.getCodeModel(), JavaCodeUtil.classLoaderFromResolverPath(schemaParser.getResolverPath()), checker);

    final List<File> modifiedFiles;
    if (FileUtil.upToDate(parseResult.getSourceFiles(), targetFiles))
    {
      modifiedFiles = Collections.emptyList();
      _log.info("Target files are up-to-date: " + targetFiles);
    }
    else
    {
      modifiedFiles = targetFiles;
      _log.info("Generating " + targetFiles.size() + " files: " + targetFiles);
      validateDefinedClassRegistration(dataTemplateGenerator.getCodeModel(), dataTemplateGenerator.getGeneratedClasses().keySet());
      dataTemplateGenerator.getCodeModel().build(new FileCodeWriter(targetDirectory, true));
    }
    return new DefaultGeneratorResult(parseResult.getSourceFiles(), targetFiles, modifiedFiles);
  }

  
  private static void validateDefinedClassRegistration(JCodeModel codeModel, Collection<JDefinedClass> classes)
  {
    for (Iterator<JPackage> packageIterator = codeModel.packages(); packageIterator.hasNext(); )
    {
      final JPackage currentPackage = packageIterator.next();
      for (Iterator<JDefinedClass> classIterator = currentPackage.classes(); classIterator.hasNext(); )
      {
        final JDefinedClass currentClass = classIterator.next();
        if (!classes.contains(currentClass))
        {
          throw new IllegalStateException("Attempting to generate unregistered class: '" + currentClass.fullName() + "'");
        }
      }
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.DataMap;
import com.linkedin.data.schema.ArrayDataSchema;
import com.linkedin.data.schema.ComplexDataSchema;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.DataSchemaResolver;
import com.linkedin.data.schema.EnumDataSchema;
import com.linkedin.data.schema.FixedDataSchema;
import com.linkedin.data.schema.MapDataSchema;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.PrimitiveDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.TyperefDataSchema;
import com.linkedin.data.schema.UnionDataSchema;
import com.linkedin.data.template.DataTemplate;
import com.linkedin.pegasus.generator.spec.ArrayTemplateSpec;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.pegasus.generator.spec.CustomInfoSpec;
import com.linkedin.pegasus.generator.spec.EnumTemplateSpec;
import com.linkedin.pegasus.generator.spec.FixedTemplateSpec;
import com.linkedin.pegasus.generator.spec.MapTemplateSpec;
import com.linkedin.pegasus.generator.spec.ModifierSpec;
import com.linkedin.pegasus.generator.spec.PrimitiveTemplateSpec;
import com.linkedin.pegasus.generator.spec.RecordTemplateSpec;
import com.linkedin.pegasus.generator.spec.TyperefTemplateSpec;
import com.linkedin.pegasus.generator.spec.UnionTemplateSpec;

import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class TemplateSpecGenerator
{
  private static final Logger _log = LoggerFactory.getLogger(TemplateSpecGenerator.class);

  private static final String CLASS_PROPERTY = "class";
  private static final String JAVA_PROPERTY = "java";
  private static final String COERCER_CLASS_PROPERTY = "coercerClass";
  private static final String ARRAY_SUFFIX = "Array";
  private static final String MAP_SUFFIX = "Map";
  private static final String[] SPECIAL_SUFFIXES = {ARRAY_SUFFIX, MAP_SUFFIX};
  private static final String _templatePackageName = DataTemplate.class.getPackage().getName();

  private final Collection<ClassTemplateSpec> _classTemplateSpecs = new HashSet<ClassTemplateSpec>();
  
  private final Map<ClassTemplateSpec, DataSchemaLocation> _classToDataSchemaLocationMap = new HashMap<ClassTemplateSpec, DataSchemaLocation>();
  
  private final Map<String, DataSchema> _classNameToSchemaMap = new HashMap<String, DataSchema>(100);
  
  private final IdentityHashMap<DataSchema, ClassTemplateSpec> _schemaToClassMap = new IdentityHashMap<DataSchema, ClassTemplateSpec>(100);
  
  private final Deque<DataSchemaLocation> _locationStack = new ArrayDeque<DataSchemaLocation>();
  private final Map<DataSchema, CustomInfoSpec> _immediateCustomMap = new IdentityHashMap<DataSchema, CustomInfoSpec>();

  private final DataSchemaResolver _schemaResolver;

  
  public static String classNameForNamedSchema(NamedDataSchema schema)
  {
    final StringBuilder sb = new StringBuilder();
    final String namespace = schema.getNamespace();
    if (!namespace.isEmpty())
    {
      sb.append(namespace);
      sb.append('.');
    }
    sb.append(schema.getName());
    return sb.toString();
  }

  public TemplateSpecGenerator(DataSchemaResolver schemaResolver)
  {
    _schemaResolver = schemaResolver;
  }

  
  public DataSchemaLocation getClassLocation(ClassTemplateSpec classSpec)
  {
    return _classToDataSchemaLocationMap.get(classSpec);
  }

  
  public void registerDefinedSchema(DataSchema schema)
  {
    final ClassTemplateSpec spec = ClassTemplateSpec.createFromDataSchema(schema);
    _schemaToClassMap.put(schema, spec);
    _classNameToSchemaMap.put(spec.getFullName(), schema);
  }

  
  public ClassTemplateSpec generate(DataSchema schema, DataSchemaLocation location)
  {
    pushCurrentLocation(location);
    final ClassTemplateSpec result = processSchema(schema, null, null);
    popCurrentLocation();
    return result;
  }

  public Collection<ClassTemplateSpec> getGeneratedSpecs()
  {
    return _classTemplateSpecs;
  }

  
  private static void checkClassNameForSpecialSuffix(String className)
  {
    for (String suffix : SPECIAL_SUFFIXES)
    {
      if (className.endsWith(suffix))
      {
        _log.warn("Class name for named type ends with a suffix that may conflict with derived class names for unnamed types" +
                      ", name: " + className +
                      ", suffix: " + suffix);
        break;
      }
    }
  }

  
  private static boolean allowCustomClass(DataSchema schema)
  {
    boolean result = false;
    final DataSchema.Type type = schema.getType();
    if (type == DataSchema.Type.TYPEREF || type == DataSchema.Type.RECORD)
    {
      
      final DataSchema dereferencedSchema = schema.getDereferencedDataSchema();
      if (dereferencedSchema.getType() == DataSchema.Type.RECORD || (CodeUtil.isDirectType(dereferencedSchema) && dereferencedSchema.getType() != DataSchema.Type.ENUM))
      {
        result = true;
      }
    }
    return result;
  }

  private static DataSchema dereferenceIfTyperef(DataSchema schema)
  {
    final DataSchema.Type type = schema.getType();
    return type == DataSchema.Type.TYPEREF ? ((TyperefDataSchema) schema).getRef() : null;
  }

  
  private static IllegalArgumentException nullTypeNotAllowed(ClassTemplateSpec enclosingClass, String memberName)
  {
    return new IllegalArgumentException("The null type can only be used in unions, null found" + enclosingClassAndMemberNameToString(enclosingClass, memberName));
  }

  
  private static IllegalStateException unrecognizedSchemaType(ClassTemplateSpec enclosingClass, String memberName, DataSchema schema)
  {
    return new IllegalStateException("Unrecognized schema: " + schema +
                                         enclosingClassAndMemberNameToString(enclosingClass, memberName));
  }

  
  private static String enclosingClassAndMemberNameToString(ClassTemplateSpec enclosingClass, String memberName)
  {
    final StringBuilder sb = new StringBuilder();
    if (memberName != null)
    {
      sb.append(" in ");
      sb.append(memberName);
    }
    if (enclosingClass != null)
    {
      sb.append(" in ");
      sb.append(enclosingClass.getFullName());
    }
    return sb.toString();
  }

  
  private void checkForClassNameConflict(String className, DataSchema schema)
      throws IllegalArgumentException
  {
    final DataSchema schemaFromClassName = _classNameToSchemaMap.get(className);
    boolean conflict = false;
    if (schemaFromClassName != null && schemaFromClassName != schema)
    {
      final DataSchema.Type schemaType = schema.getType();
      if (schemaFromClassName.getType() != schemaType)
      {
        conflict = true;
      }
      else if (schema instanceof NamedDataSchema)
      {
        conflict = true;
      }
      else if (!schemaFromClassName.equals(schema))
      {
        assert schemaType == DataSchema.Type.ARRAY || schemaType == DataSchema.Type.MAP;
        
        
        
        
        
        
        _log.info("Class name: " + className +
                      ", bound to schema:" + schemaFromClassName +
                      ", instead of schema: " + schema);
      }
    }
    if (conflict)
    {
      throw new IllegalArgumentException("Class name conflict detected, class name: " + className +
                                             ", class already bound to schema: " + schemaFromClassName +
                                             ", attempting to rebind to schema: " + schema);
    }
  }

  private DataSchemaLocation currentLocation()
  {
    return _locationStack.getLast();
  }

  private void pushCurrentLocation(DataSchemaLocation location)
  {
    _locationStack.addLast(location);
  }

  private void popCurrentLocation()
  {
    _locationStack.removeLast();
  }

  
  private void registerClassTemplateSpec(DataSchema schema, ClassTemplateSpec classTemplateSpec)
  {
    classTemplateSpec.setLocation(currentLocation().toString());
    _schemaToClassMap.put(schema, classTemplateSpec);
    _classNameToSchemaMap.put(classTemplateSpec.getFullName(), schema);
    _classToDataSchemaLocationMap.put(classTemplateSpec, currentLocation());

    if (schema instanceof NamedDataSchema)
    {
      checkClassNameForSpecialSuffix(classTemplateSpec.getFullName());
    }

    _classTemplateSpecs.add(classTemplateSpec);
  }

  private ClassTemplateSpec processSchema(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    ClassTemplateSpec result = null;

    final CustomInfoSpec customInfo = getImmediateCustomInfo(schema);
    while (schema.getType() == DataSchema.Type.TYPEREF)
    {
      final TyperefDataSchema typerefSchema = (TyperefDataSchema) schema;
      final ClassTemplateSpec found = _schemaToClassMap.get(schema);
      if (found == null)
      {
        if (typerefSchema.getRef().getType() == DataSchema.Type.UNION)
        {
          result = generateUnion((UnionDataSchema) typerefSchema.getRef(), typerefSchema);
          break;
        }
        else
        {
          generateTyperef(typerefSchema);
        }
      }
      else if (typerefSchema.getRef().getType() == DataSchema.Type.UNION)
      {
        result = found;
        break;
      }
      schema = typerefSchema.getRef();
    }
    if (result == null)
    {
      assert schema == schema.getDereferencedDataSchema();
      if (schema instanceof ComplexDataSchema)
      {
        final ClassTemplateSpec found = _schemaToClassMap.get(schema);
        if (found == null)
        {
          if (schema instanceof NamedDataSchema)
          {
            result = generateNamedSchema((NamedDataSchema) schema);
          }
          else
          {
            result = generateUnnamedComplexSchema(schema, enclosingClass, memberName);
          }
        }
        else
        {
          result = found;
        }

        if (customInfo != null)
        {
          result = customInfo.getCustomClass();
        }
      }
      else if (schema instanceof PrimitiveDataSchema)
      {
        result = (customInfo != null) ? customInfo.getCustomClass() : getPrimitiveClassForSchema((PrimitiveDataSchema) schema, enclosingClass, memberName);
      }
    }

    if (result == null)
    {
      throw unrecognizedSchemaType(enclosingClass, memberName, schema);
    }

    return result;
  }

  
  private CustomClasses getCustomClasses(DataSchema schema)
  {
    CustomClasses customClasses = null;
    final Map<String, Object> properties = schema.getProperties();
    final Object java = properties.get(JAVA_PROPERTY);
    if (java != null)
    {
      if (java.getClass() != DataMap.class)
      {
        throw new IllegalArgumentException(schema + " has \"java\" property that is not a DataMap");
      }
      final DataMap map = (DataMap) java;
      final Object custom = map.get(CLASS_PROPERTY);
      if (custom != null)
      {
        if (custom.getClass() != String.class)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"class\" that is not a string");
        }
        
        customClasses = new CustomClasses();
        customClasses.customClass = new ClassTemplateSpec();
        customClasses.customClass.setFullName((String) custom);
        if (!allowCustomClass(schema))
        {
          throw new IllegalArgumentException(schema + " cannot have custom class binding");
        }
      }
      
      final Object coercerClass = map.get(COERCER_CLASS_PROPERTY);
      if (coercerClass != null)
      {
        if (coercerClass.getClass() != String.class)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"coercerClass\" that is not a string");
        }
        if (customClasses == null)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"coercerClass\" but does not have \"class\" property");
        }
        
        customClasses.customCoercerClass = new ClassTemplateSpec();
        customClasses.customCoercerClass.setFullName((String) coercerClass);
      }
    }
    return customClasses;
  }

  private CustomInfoSpec getImmediateCustomInfo(DataSchema schema)
  {
    if (_immediateCustomMap.containsKey(schema))
    {
      return _immediateCustomMap.get(schema);
    }

    CustomInfoSpec immediate = null;
    for (DataSchema current = schema; current != null; current = dereferenceIfTyperef(current))
    {
      final CustomClasses customClasses = getCustomClasses(current);
      if (customClasses != null)
      {
        immediate = new CustomInfoSpec((NamedDataSchema) schema, (NamedDataSchema) current, customClasses.customClass, customClasses.customCoercerClass);
        break;
      }
    }

    
    _immediateCustomMap.put(schema, immediate);
    return immediate;
  }

  private ClassTemplateSpec getPrimitiveClassForSchema(PrimitiveDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    switch (schema.getType())
    {
      case INT:
      case DOUBLE:
      case BOOLEAN:
      case STRING:
      case LONG:
      case FLOAT:
      case BYTES:
        return PrimitiveTemplateSpec.getInstance(schema.getType());
      case NULL:
        throw nullTypeNotAllowed(enclosingClass, memberName);
    }
    throw unrecognizedSchemaType(enclosingClass, memberName, schema);
  }

  private ClassTemplateSpec generateNamedSchema(NamedDataSchema schema)
  {
    pushCurrentLocation(_schemaResolver.nameToDataSchemaLocations().get(schema.getFullName()));

    final String className = classNameForNamedSchema(schema);
    checkForClassNameConflict(className, schema);

    final ClassTemplateSpec templateClass;
    switch (schema.getType())
    {
      case RECORD:
        templateClass = generateRecord((RecordDataSchema) schema);
        break;
      case ENUM:
        templateClass = generateEnum((EnumDataSchema) schema);
        break;
      case FIXED:
        templateClass = generateFixed((FixedDataSchema) schema);
        break;
      default:
        throw unrecognizedSchemaType(null, null, schema);
    }

    popCurrentLocation();

    return templateClass;
  }

  private ClassTemplateSpec generateUnnamedComplexSchema(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    if (schema instanceof ArrayDataSchema)
    {
      return generateArray((ArrayDataSchema) schema, enclosingClass, memberName);
    }
    else if (schema instanceof MapDataSchema)
    {
      return generateMap((MapDataSchema) schema, enclosingClass, memberName);
    }
    else if (schema instanceof UnionDataSchema)
    {
      return generateUnion((UnionDataSchema) schema, enclosingClass, memberName);
    }
    else
    {
      throw unrecognizedSchemaType(enclosingClass, memberName, schema);
    }
  }

  private ClassTemplateSpec determineDataClass(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final ClassTemplateSpec result;
    final DataSchema dereferencedSchema = schema.getDereferencedDataSchema();
    if (dereferencedSchema.getType() == DataSchema.Type.ENUM)
    {
      result = PrimitiveTemplateSpec.getInstance(DataSchema.Type.STRING);
    }
    else if (CodeUtil.isDirectType(dereferencedSchema))
    {
      result = getPrimitiveClassForSchema((PrimitiveDataSchema) dereferencedSchema, enclosingClass, memberName);
    }
    else
    {
      result = null;
    }
    return result;
  }

  private ArrayTemplateSpec generateArray(ArrayDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final DataSchema itemSchema = schema.getItems();

    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      
      processSchema(itemSchema, enclosingClass, memberName);

      return (ArrayTemplateSpec) classInfo.existingClass;
    }

    final ArrayTemplateSpec arrayClass = (ArrayTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, arrayClass);

    arrayClass.setItemClass(processSchema(itemSchema, enclosingClass, memberName));
    arrayClass.setItemDataClass(determineDataClass(itemSchema, enclosingClass, memberName));

    final CustomInfoSpec customInfo = getImmediateCustomInfo(itemSchema);
    arrayClass.setCustomInfo(customInfo);

    return arrayClass;
  }

  private MapTemplateSpec generateMap(MapDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final DataSchema valueSchema = schema.getValues();

    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      
      processSchema(valueSchema, enclosingClass, memberName);

      return (MapTemplateSpec) classInfo.existingClass;
    }

    final MapTemplateSpec mapClass = (MapTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, mapClass);

    mapClass.setValueClass(processSchema(valueSchema, enclosingClass, memberName));
    mapClass.setValueDataClass(determineDataClass(valueSchema, enclosingClass, memberName));

    final CustomInfoSpec customInfo = getImmediateCustomInfo(valueSchema);
    mapClass.setCustomInfo(customInfo);

    return mapClass;
  }

  private UnionTemplateSpec generateUnion(UnionDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    if (enclosingClass == null || memberName == null)
    {
      throw new IllegalArgumentException("Cannot processSchema template for top level union: " + schema);
    }
    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      return (UnionTemplateSpec) classInfo.existingClass;
    }
    final UnionTemplateSpec unionClass = (UnionTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, unionClass);
    return generateUnion(schema, unionClass);
  }

  private ClassTemplateSpec generateUnion(UnionDataSchema schema, TyperefDataSchema typerefDataSchema)
  {
    assert typerefDataSchema.getRef() == schema;

    pushCurrentLocation(_schemaResolver.nameToDataSchemaLocations().get(typerefDataSchema.getFullName()));

    final UnionTemplateSpec unionClass = new UnionTemplateSpec(schema);
    unionClass.setNamespace(typerefDataSchema.getNamespace());
    unionClass.setClassName(typerefDataSchema.getName());
    unionClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(typerefDataSchema, unionClass);

    final TyperefTemplateSpec typerefInfoClass = new TyperefTemplateSpec(typerefDataSchema);
    typerefInfoClass.setEnclosingClass(unionClass);
    typerefInfoClass.setClassName("UnionTyperefInfo");
    typerefInfoClass.setModifiers(ModifierSpec.PRIVATE, ModifierSpec.STATIC, ModifierSpec.FINAL);

    final UnionTemplateSpec result = generateUnion(schema, unionClass);
    result.setTyperefClass(typerefInfoClass);

    popCurrentLocation();
    return result;
  }

  private UnionTemplateSpec generateUnion(UnionDataSchema schema, UnionTemplateSpec unionClass)
  {
    for (DataSchema memberType : schema.getTypes())
    {
      final UnionTemplateSpec.Member newMember = new UnionTemplateSpec.Member();
      unionClass.getMembers().add(newMember);

      newMember.setSchema(memberType);

      if (memberType.getDereferencedType() != DataSchema.Type.NULL)
      {
        newMember.setClassTemplateSpec(processSchema(memberType, unionClass, memberType.getUnionMemberKey()));
        newMember.setDataClass(determineDataClass(memberType, unionClass, memberType.getUnionMemberKey()));
      }
    }

    return unionClass;
  }

  private ClassTemplateSpec generateEnum(EnumDataSchema schema)
  {
    final EnumTemplateSpec enumClass = new EnumTemplateSpec(schema);
    enumClass.setNamespace(schema.getNamespace());
    enumClass.setClassName(schema.getName());
    enumClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, enumClass);
    return enumClass;
  }

  private ClassTemplateSpec generateFixed(FixedDataSchema schema)
  {
    final FixedTemplateSpec fixedClass = new FixedTemplateSpec(schema);
    fixedClass.setNamespace(schema.getNamespace());
    fixedClass.setClassName(schema.getName());
    fixedClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, fixedClass);

    return fixedClass;
  }

  private TyperefTemplateSpec generateTyperef(TyperefDataSchema schema)
  {
    final TyperefTemplateSpec typerefClass = new TyperefTemplateSpec(schema);
    typerefClass.setNamespace(schema.getNamespace());
    typerefClass.setClassName(schema.getName());
    typerefClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, typerefClass);
    return typerefClass;
  }

  private RecordTemplateSpec generateRecord(RecordDataSchema schema)
  {
    final RecordTemplateSpec recordClass = new RecordTemplateSpec(schema);
    recordClass.setNamespace(schema.getNamespace());
    recordClass.setClassName(schema.getName());
    recordClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, recordClass);

    
    
    final List<NamedDataSchema> includes = schema.getInclude();
    for (NamedDataSchema includedSchema : includes)
    {
      processSchema(includedSchema, null, null);
    }

    final Map<CustomInfoSpec, Object> customInfoMap = new IdentityHashMap<CustomInfoSpec, Object>(schema.getFields().size() * 2);

    for (RecordDataSchema.Field field : schema.getFields())
    {
      final ClassTemplateSpec fieldClass = processSchema(field.getType(), recordClass, field.getName());
      final RecordTemplateSpec.Field newField = new RecordTemplateSpec.Field();
      newField.setSchemaField(field);
      newField.setType(fieldClass);
      newField.setDataClass(determineDataClass(field.getType(), recordClass, field.getName()));

      final CustomInfoSpec customInfo = getImmediateCustomInfo(field.getType());
      if (customInfo != null && !customInfoMap.containsKey(customInfo))
      {
        customInfoMap.put(customInfo, null);
        newField.setCustomInfo(customInfo);
      }

      recordClass.addField(newField);
    }

    return recordClass;
  }

  
  private ClassInfo classInfoForUnnamed(ClassTemplateSpec enclosingClass, String name, DataSchema schema)
  {
    assert !(schema instanceof NamedDataSchema);
    assert !(schema instanceof PrimitiveDataSchema);

    final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, name, schema);
    final String className = classInfo.fullName();

    final DataSchema schemaFromClassName = _classNameToSchemaMap.get(className);
    if (schemaFromClassName == null)
    {
      final ClassTemplateSpec classTemplateSpec = ClassTemplateSpec.createFromDataSchema(schema);

      if (enclosingClass != null && classInfo.namespace.equals(enclosingClass.getFullName()))
      {
        classTemplateSpec.setEnclosingClass(enclosingClass);
        classTemplateSpec.setClassName(classInfo.name);
        classTemplateSpec.setModifiers(ModifierSpec.PUBLIC, ModifierSpec.STATIC, ModifierSpec.FINAL);
      }
      else
      {
        classTemplateSpec.setNamespace(classInfo.namespace);
        classTemplateSpec.setClassName(classInfo.name);
        classTemplateSpec.setModifiers(ModifierSpec.PUBLIC);
      }
      classInfo.definedClass = classTemplateSpec;
    }
    else
    {
      checkForClassNameConflict(className, schema);
      classInfo.existingClass = _schemaToClassMap.get(schemaFromClassName);
    }

    return classInfo;
  }

  private ClassInfo classNameForUnnamedTraverse(ClassTemplateSpec enclosingClass, String memberName, DataSchema schema)
  {
    final DataSchema dereferencedDataSchema = schema.getDereferencedDataSchema();
    switch (dereferencedDataSchema.getType())
    {
      case ARRAY:
        final ArrayDataSchema arraySchema = (ArrayDataSchema) dereferencedDataSchema;
        CustomInfoSpec customInfo = getImmediateCustomInfo(arraySchema.getItems());
        if (customInfo != null)
        {
          return new ClassInfo(customInfo.getCustomSchema().getNamespace(), customInfo.getCustomSchema().getName() + ARRAY_SUFFIX);
        }
        else
        {
          final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, memberName, arraySchema.getItems());
          classInfo.name += ARRAY_SUFFIX;
          return classInfo;
        }
      case MAP:
        final MapDataSchema mapSchema = (MapDataSchema) dereferencedDataSchema;
        customInfo = getImmediateCustomInfo(mapSchema.getValues());
        if (customInfo != null)
        {
          return new ClassInfo(customInfo.getCustomSchema().getNamespace(), customInfo.getCustomSchema().getName() + MAP_SUFFIX);
        }
        else
        {
          final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, memberName, mapSchema.getValues());
          classInfo.name += MAP_SUFFIX;
          return classInfo;
        }

      case UNION:
        if (schema.getType() == DataSchema.Type.TYPEREF)
        {
          DataSchema referencedDataSchema;
          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) schema;
          while ((referencedDataSchema = typerefDataSchema.getDereferencedDataSchema()) != dereferencedDataSchema)
          {
            typerefDataSchema = (TyperefDataSchema) referencedDataSchema;
          }
          return new ClassInfo(typerefDataSchema.getNamespace(), CodeUtil.capitalize(typerefDataSchema.getName()));
        }
        else
        {
          return new ClassInfo(enclosingClass.getFullName(), CodeUtil.capitalize(memberName));
        }

      case FIXED:
      case RECORD:
      case ENUM:
        final NamedDataSchema namedSchema = (NamedDataSchema) dereferencedDataSchema;
        return new ClassInfo(namedSchema.getNamespace(), CodeUtil.capitalize(namedSchema.getName()));

      case BOOLEAN:
        return new ClassInfo(_templatePackageName, "Boolean");

      case INT:
        return new ClassInfo(_templatePackageName, "Integer");

      case LONG:
        return new ClassInfo(_templatePackageName, "Long");

      case FLOAT:
        return new ClassInfo(_templatePackageName, "Float");

      case DOUBLE:
        return new ClassInfo(_templatePackageName, "Double");

      case STRING:
        return new ClassInfo(_templatePackageName, "String");

      case BYTES:
        return new ClassInfo(_templatePackageName, "ByteString");

      case NULL:
        throw nullTypeNotAllowed(enclosingClass, memberName);

      default:
        throw unrecognizedSchemaType(enclosingClass, memberName, dereferencedDataSchema);
    }
  }

  private static class CustomClasses
  {
    private ClassTemplateSpec customClass;
    private ClassTemplateSpec customCoercerClass;
  }

  private static class ClassInfo
  {
    private String namespace;
    private String name;
    private ClassTemplateSpec existingClass;
    private ClassTemplateSpec definedClass;

    private ClassInfo(String namespace, String name)
    {
      this.namespace = namespace;
      this.name = name;
    }

    private String fullName()
    {
      return namespace.isEmpty() ? name : namespace + '.' + name;
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.DataSchemaResolver;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.SchemaParser;
import com.linkedin.data.schema.resolver.FileDataSchemaLocation;
import com.linkedin.data.schema.resolver.FileDataSchemaResolver;
import com.linkedin.util.FileUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;



public class DataSchemaParser
{
  private final String _resolverPath;
  private final DataSchemaResolver _schemaResolver;

  
  public DataSchemaParser(String resolverPath)
  {
    _resolverPath = resolverPath;
    _schemaResolver = CodeUtil.createSchemaResolver(resolverPath);
  }

  public String getResolverPath()
  {
    return _resolverPath;
  }

  public DataSchemaResolver getSchemaResolver()
  {
    return _schemaResolver;
  }

  
  public ParseResult parseSources(String sources[])
      throws IOException
  {
    final ParseResult result = new ParseResult();

    try
    {
      for (String source : sources)
      {
        final File sourceFile = new File(source);
        if (sourceFile.exists())
        {
          if (sourceFile.isDirectory())
          {
            final FileUtil.FileExtensionFilter filter = new FileUtil.FileExtensionFilter(FileDataSchemaResolver.DEFAULT_EXTENSION);
            final List<File> sourceFilesInDirectory = FileUtil.listFiles(sourceFile, filter);
            for (File f : sourceFilesInDirectory)
            {
              parseFile(f, result);
            }
          }
          else
          {
            parseFile(sourceFile, result);
          }
        }
        else
        {
          final StringBuilder errorMessage = new StringBuilder();
          final DataSchema schema = _schemaResolver.findDataSchema(source, errorMessage);
          if (schema == null)
          {
            result.getMessage().append("File cannot be opened or schema name cannot be resolved: ").append(source).append("\n");
          }
          if (errorMessage.length() > 0)
          {
            result.getMessage().append(errorMessage.toString());
          }
          if (schema != null)
          {
            final DataSchemaLocation location = _schemaResolver.nameToDataSchemaLocations().get(source);
            result.getSchemaAndLocations().add(new CodeUtil.Pair<DataSchema, DataSchemaLocation>(schema, location));
          }
        }
      }

      if (result.getMessage().length() > 0)
      {
        throw new IOException(result.getMessage().toString());
      }

      appendSourceFilesFromSchemaResolver(result);

      return result;
    }
    catch (RuntimeException e)
    {
      if (result.getMessage().length() > 0)
      {
        e = new RuntimeException("Unexpected " + e.getClass().getSimpleName() + " encountered.\n" +
                                     "This may be caused by the following parsing or processing errors:\n" +
                                     result.getMessage(), e);
      }
      throw e;
    }
  }

  
  private void parseFile(File schemaSourceFile, ParseResult result)
      throws IOException
  {
    if (wasResolved(schemaSourceFile))
    {
      return;
    }

    final List<DataSchema> schemas = parseSchema(schemaSourceFile, result);

    for (DataSchema schema : schemas)
    {
      validateSchemaWithFilePath(schemaSourceFile, schema);
      result.getSchemaAndFiles().add(new CodeUtil.Pair<DataSchema, File>(schema, schemaSourceFile));
      result.getSourceFiles().add(schemaSourceFile);
    }
  }

  
  private void validateSchemaWithFilePath(File schemaSourceFile, DataSchema schema)
  {
    if (schemaSourceFile != null && schemaSourceFile.isFile() && schema instanceof NamedDataSchema)
    {
      final NamedDataSchema namedDataSchema = (NamedDataSchema) schema;
      final String namespace = namedDataSchema.getNamespace();

      if (!FileUtil.removeFileExtension(schemaSourceFile.getName()).equalsIgnoreCase(namedDataSchema.getName()))
      {
        throw new IllegalArgumentException(namedDataSchema.getFullName() + " has name that does not match filename '" +
                                               schemaSourceFile.getAbsolutePath() + "'");
      }

      final String directory = schemaSourceFile.getParentFile().getAbsolutePath();
      if (!directory.endsWith(namespace.replace('.', File.separatorChar)))
      {
        throw new IllegalArgumentException(namedDataSchema.getFullName() + " has namespace that does not match " +
                                               "file path '" + schemaSourceFile.getAbsolutePath() + "'");
      }
    }
  }

  
  private boolean wasResolved(File schemaSourceFile)
  {
    final FileDataSchemaLocation schemaLocation = new FileDataSchemaLocation(schemaSourceFile);
    return _schemaResolver.locationResolved(schemaLocation);
  }

  
  private List<DataSchema> parseSchema(final File schemaSourceFile, ParseResult result)
      throws IOException
  {
    final SchemaParser parser = new SchemaParser(_schemaResolver);
    final FileInputStream schemaStream = new SchemaFileInputStream(schemaSourceFile);
    try
    {
      parser.setLocation(new FileDataSchemaLocation(schemaSourceFile));
      parser.parse(schemaStream);
      if (parser.hasError())
      {
        return Collections.emptyList();
      }
      return parser.topLevelDataSchemas();
    }
    finally
    {
      schemaStream.close();
      if (parser.hasError())
      {
        result.getMessage().append(schemaSourceFile.getPath() + ",");
        result.getMessage().append(parser.errorMessage());
      }
    }
  }

  
  private void appendSourceFilesFromSchemaResolver(ParseResult result)
  {
    for (Map.Entry<String, DataSchemaLocation> entry : _schemaResolver.nameToDataSchemaLocations().entrySet())
    {
      final File sourceFile = entry.getValue().getSourceFile();
      if (sourceFile != null)
      {
        result.getSourceFiles().add(sourceFile);
      }
    }
  }

  
  public static class ParseResult
  {
    
    private final Collection<CodeUtil.Pair<DataSchema, File>> _schemaAndFiles = new ArrayList<CodeUtil.Pair<DataSchema, File>>();
    private final Collection<CodeUtil.Pair<DataSchema, DataSchemaLocation>> _schemaAndLocations = new ArrayList<CodeUtil.Pair<DataSchema, DataSchemaLocation>>();
    private final Set<File> _sourceFiles = new HashSet<File>();
    private final StringBuilder _message = new StringBuilder();

    
    public Collection<CodeUtil.Pair<DataSchema, File>> getSchemaAndFiles()
    {
      return _schemaAndFiles;
    }

    
    public Collection<CodeUtil.Pair<DataSchema, DataSchemaLocation>> getSchemaAndLocations()
    {
      return _schemaAndLocations;
    }

    
    public Set<File> getSourceFiles()
    {
      return _sourceFiles;
    }

    public StringBuilder getMessage()
    {
      return _message;
    }
  }

  private static class SchemaFileInputStream extends FileInputStream
  {
    private File _schemaSourceFile;

    private SchemaFileInputStream(File file)
        throws FileNotFoundException
    {
      super(file);
      _schemaSourceFile = file;
    }

    @Override
    public String toString()
    {
      return _schemaSourceFile.toString();
    }
  }
}

<code block>


package com.linkedin.data.avro;


import com.linkedin.data.DataMap;
import com.linkedin.data.TestUtil;
import com.linkedin.data.avro.util.AvroUtil;
import com.linkedin.data.it.Predicate;
import com.linkedin.data.it.Predicates;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.SchemaParser;
import com.linkedin.data.schema.util.Filters;

import java.io.IOException;

import org.apache.avro.Schema;
import org.apache.avro.generic.GenericRecord;
import org.testng.annotations.Test;

import static org.testng.Assert.assertEquals;


public class TestFilteredSchemaDataTranslation
{
  
  @Test
  public void testFilteredAvroSchemaDataTranslation() throws IOException
  {
    Object inputs[][] = {
      {
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : \"int\", \"optional\" : true }, " +
        "    { \"name\" : \"c\", \"type\" : \"int\", \"optional\" : true, \"derived\" : true } " +
        "  ] " +
        "}",
        Predicates.hasChildWithNameValue("derived", true),
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : [ \"null\", \"int\" ], \"default\" : null } " +
        "  ] " +
        "}",
        
        "{ \"a\" : 1, \"b\" : 2, \"c\" : 3 }",
        "{ \"a\" : 1, \"b\" : { \"int\" : 2 } }",
        
        "{ \"a\" : 1, \"c\" : 3 }",
        "{ \"a\" : 1, \"b\" : null }",
      }
    };

    for (Object[] row : inputs)
    {
      int i = 0;
      String schemaText = (String) row[i++];
      Predicate predicate = (Predicate) row[i++];
      String avroSchemaText = (String) row[i++];

      RecordDataSchema schema = (RecordDataSchema) TestUtil.dataSchemaFromString(schemaText);
      NamedDataSchema filteredSchema = Filters.removeByPredicate(schema, predicate, new SchemaParser());
      Schema filteredAvroSchema = SchemaTranslator.dataToAvroSchema(filteredSchema);

      Schema expectedAvroSchema = Schema.parse(avroSchemaText);
      assertEquals(filteredAvroSchema, expectedAvroSchema);

      while (i < row.length)
      {
        String translationSourceJson = (String) row[i++];
        String translationResultJson = (String) row[i++];

        DataMap dataMap = TestUtil.dataMapFromString(translationSourceJson);
        GenericRecord genericRecord = DataTranslator.dataMapToGenericRecord(dataMap, schema, filteredAvroSchema);

        String avroJson = AvroUtil.jsonFromGenericRecord(genericRecord);
        DataMap avroJsonAsDataMap = TestUtil.dataMapFromString(avroJson);

        assertEquals(avroJsonAsDataMap, TestUtil.dataMapFromString(translationResultJson));
      }
    }
  }

  
  @Test
  public void testFilteredDataSchemaDataTranslation() throws IOException
  {
    Object inputs[][] = {
      {
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : [ \"null\", \"int\" ], \"default\" : null }, " +
        "    { \"name\" : \"removeMe\", \"type\" : \"int\" } " +
        "  ] " +
        "}",
        Predicates.hasChildWithNameValue("name", "removeMe"),
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : \"int\", \"optional\" : true } " +
        "  ] " +
        "}",
        
        "{ \"a\" : 1, \"b\" : { \"int\" : 2 }, \"removeMe\" : 3 }",
        "{ \"a\" : 1, \"b\" : 2 }",
        
        "{ \"a\" : 1, \"b\" : null, \"removeMe\" : 3 }",
        "{ \"a\" : 1 }",
      }
    };

    for (Object[] row : inputs)
    {
      int i = 0;
      String avroSchemaText = (String) row[i++];
      Predicate predicate = (Predicate) row[i++];
      String schemaText = (String) row[i++];

      Schema avroSchema = Schema.parse(avroSchemaText);
      System.out.println(avroSchema);
      RecordDataSchema schema = (RecordDataSchema) SchemaTranslator.avroToDataSchema(avroSchema);
      RecordDataSchema filteredSchema = (RecordDataSchema) Filters.removeByPredicate(schema, predicate, new SchemaParser());

      DataSchema expectedSchema = TestUtil.dataSchemaFromString(schemaText);
      System.out.println(filteredSchema);
      assertEquals(filteredSchema, expectedSchema);

      while (i < row.length)
      {
        String translationSourceJson = (String) row[i++];
        String translationExpectedJson = (String) row[i++];

        GenericRecord genericRecord = AvroUtil.genericRecordFromJson(translationSourceJson, avroSchema);
        DataMap dataMap = DataTranslator.genericRecordToDataMap(genericRecord, filteredSchema, avroSchema);

        assertEquals(dataMap, TestUtil.dataMapFromString(translationExpectedJson));
      }
    }
  }
}

<code block>


package com.linkedin.pegasus.generator.test;


import com.linkedin.data.TestUtil;
import com.linkedin.pegasus.generator.PegasusDataTemplateGenerator;

import java.io.File;
import java.io.IOException;
import java.util.Map;

import org.testng.annotations.Test;

import static com.linkedin.data.TestUtil.asMap;
import static com.linkedin.data.TestUtil.ensureEmptyOutputDir;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;


public class TestBadSchemas
{
  private final Object _badSchemas[][] =
    {
      {
        asMap(
          "com/linkedin/pegasus/generator/test/ArrayNameDuplicateTest.pdsc",
          "{\n" +
          "  \"type\" : \"record\",\n" +
          "  \"name\" : \"ArrayNameDuplicateTest\",\n" +
          "  \"namespace\" : \"com.linkedin.pegasus.generator.test\",\n" +
          "  \"fields\" : [\n" +
          "    {\n" +
          "      \"name\" : \"x\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"enum\",\n" +
          "        \"name\" : \"X\",\n" +
          "        \"symbols\" : [ \"X\" ]\n" +
          "      }\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"arrayOfX\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"array\",\n" +
          "        \"items\" : \"X\"\n" +
          "      }\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"xArray\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"enum\",\n" +
          "        \"name\" : \"XArray\",\n" +
          "        \"symbols\" : [ \"Y\" ]\n" +
          "      }\n" +
          "    }\n" +
          "  ]\n" +
          "}"
        ),
        IllegalArgumentException.class,
        "Class name conflict detected, class name: com.linkedin.pegasus.generator.test.XArray, class already bound to schema: { \"type\" : \"array\", \"items\" : { \"type\" : \"enum\", \"name\" : \"X\", \"namespace\" : \"com.linkedin.pegasus.generator.test\", \"symbols\" : [ \"X\" ] } }, attempting to rebind to schema: { \"type\" : \"enum\", \"name\" : \"XArray\", \"namespace\" : \"com.linkedin.pegasus.generator.test\", \"symbols\" : [ \"Y\" ] }"
      },
      {
        asMap(
          "com/linkedin/pegasus/generator/test/FieldDefinedTwice.pdsc",
          "{\n" +
          "  \"type\" : \"record\",\n" +
          "  \"name\" : \"FieldDefinedTwice\",\n" +
          "  \"namespace\" : \"com.linkedin.pegasus.generator.test\",\n" +
          "  \"fields\" : [\n" +
          "    {\n" +
          "      \"name\" : \"foo\",\n" +
          "      \"type\" : \"long\"\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"foo\",\n" +
          "      \"type\" : \"string\"\n" +
          "    }\n" +
          "  ]\n" +
          "}"
        ),
        IOException.class,
        "build/test/testGeneratorBadSchemas/pegasus/com/linkedin/pegasus/generator/test/FieldDefinedTwice.pdsc,4,54: Field \"foo\" defined more than once, with \"long\" and \"string\"."
      }
    };

  private final static String _sourceDirName = "testGeneratorBadSchemas/pegasus";
  private final static String _targetDirName = "testGeneratorBadSchemas/codegen/out";

  @Test
  public void testBadSchemas() throws IOException
  {
    boolean debug = false;

    System.setProperty("generator.resolver.path", "");

    for (Object[] row : _badSchemas)
    {
      @SuppressWarnings("unchecked")
      Map<String,String> testSchemas = (Map<String,String>) row[0];

      File testDir = TestUtil.testDir(_sourceDirName, debug);
      Map<File, Map.Entry<String,String>> files = TestUtil.createSchemaFiles(testDir, testSchemas, debug);

      File targetDir = TestUtil.testDir(_targetDirName, debug);
      ensureEmptyOutputDir(targetDir, debug);

      String[] args = new String[files.size() + 1];
      int i = 0;
      args[i++] = targetDir.getCanonicalPath();
      for (Map.Entry<File, Map.Entry<String,String>> fileEntry : files.entrySet())
      {
        File file = fileEntry.getKey();
        String fileName = file.getCanonicalPath();
        args[i++] = fileName;
      }

      Class<?> expectedExceptionClass = null;
      if (row.length > 1)
      {
        expectedExceptionClass = (Class<?>) row[1];
      }

      try
      {
        PegasusDataTemplateGenerator.main(args);
        assertTrue(expectedExceptionClass == null);
      }
      catch (Exception exc)
      {
        assertTrue(expectedExceptionClass != null);
        assertEquals(exc.getClass(), expectedExceptionClass);
        String message = exc.getMessage();
        for (int j = 2; j < row.length; j++)
        {
          String expectedString = (String) row[j];
          assertTrue(message.contains(expectedString), message + " does not contain " + expectedString);
        }
      }
    }
  }
}

<code block>


package com.linkedin.data;

import com.linkedin.data.codec.DataLocation;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.SchemaParser;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.regex.Pattern;

import static org.testng.Assert.assertTrue;


public class TestUtil
{
  static public final PrintStream out = new PrintStream(new FileOutputStream(FileDescriptor.out));

  static public String stringFromException(Exception e)
  {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    PrintStream printStream = new PrintStream(outputStream);
    e.printStackTrace(printStream);
    printStream.flush();
    return outputStream.toString();
  }

  static public void dumpBytes(PrintStream printStream, byte bytes[])
  {
    for (int i = 0; i < bytes.length; i++)
    {
      if (i % 16 == 0)
        printStream.printf("%1$06X:", i);
      printStream.print(' ');
      if (bytes[i] < 32 || bytes[i] >= 127)
        printStream.print(' ');
      else
        printStream.print((char) bytes[i]);
      printStream.printf(" %1$02X", bytes[i]);
      if (i % 16 == 15)
        printStream.println();
    }
  }

  static public List<Object> asList(Object... objects)
  {
    ArrayList<Object> list = new ArrayList<Object>();
    for (Object object : objects)
    {
      list.add(object);
    }
    return list;
  }

  @SuppressWarnings("unchecked")
  static public <V> Map<String, V> asMap(Object... objects)
  {
    int index = 0;
    String key = null;
    HashMap<String,V> map = new HashMap<String,V>();
    for (Object object : objects)
    {
      if (index % 2 == 0)
      {
        key = (String) object;
      }
      else
      {
        map.put(key, (V) object);
      }
      index++;
    }
    return map;
  }

  static public InputStream inputStreamFromString(String s) throws UnsupportedEncodingException
  {
    byte[] bytes = s.getBytes(Data.UTF_8_CHARSET);
    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
    return bais;
  }

  static public SchemaParser schemaParserFromString(String s) throws UnsupportedEncodingException, IOException
  {
    SchemaParser parser = new SchemaParser();
    parser.parse(inputStreamFromString(s));
    return parser;
  }

  static public SchemaParser schemaParserFromObjects(List<Object> objects) throws IOException
  {
    SchemaParser parser = new SchemaParser();
    parser.parse(objects);
    return parser;
  }

  static public SchemaParser schemaParserFromObjectsString(String stringOfObjects) throws IOException
  {
    List<Object> objects = objectsFromString(stringOfObjects);
    return schemaParserFromObjects(objects);
  }

  static public DataSchema dataSchemaFromString(String s) throws IOException
  {
    SchemaParser parser = schemaParserFromString(s);
    if (parser.hasError())
    {
      out.println("ERROR: " + parser.errorMessage());
      return null;
    }
    return parser.topLevelDataSchemas().get(parser.topLevelDataSchemas().size() - 1);
  }

  private static final JacksonDataCodec codec = new JacksonDataCodec();

  public static List<Object> objectsFromString(String string) throws IOException
  {
    return objectsFromInputStream(inputStreamFromString(string));
  }

  public static List<Object> objectsFromInputStream(InputStream inputStream) throws IOException
  {
    StringBuilder errorMessageBuilder = new StringBuilder();
    List<Object> objects = codec.parse(inputStream, errorMessageBuilder, new HashMap<Object, DataLocation>());
    if (errorMessageBuilder.length() > 0)
    {
      throw new IOException(errorMessageBuilder.toString());
    }
    return objects;
  }

  public static DataMap dataMapFromString(String json) throws IOException
  {
    return codec.stringToMap(json);
  }

  public static boolean deleteRecursive(String path, boolean debug) throws FileNotFoundException
  {
    return deleteRecursive(new File(path), debug);
  }

  public static void ensureEmptyOutputDir(File dir, boolean debug) throws FileNotFoundException
  {
    deleteRecursive(dir, debug);
    dir.mkdirs();
    assertTrue(dir.exists());
    assertTrue(dir.isDirectory());
    assertTrue(dir.canWrite());
  }

  public static boolean deleteRecursive(File path, boolean debug) throws FileNotFoundException
  {
    if (!path.exists())
    {
      return true;
    }
    boolean ret = true;
    if (path.isDirectory())
    {
      for (File f : path.listFiles())
      {
        ret = ret && deleteRecursive(f, debug);
      }
    }
    if (debug) out.println("deleting " + path);
    return ret && path.delete();
  }

  public static File testDir(String testName, boolean debug) throws IOException
  {
    File currentDir = new File(".");
    String currentDirName = currentDir.getCanonicalPath();
    if (debug) out.println(currentDir.getCanonicalPath());
    String testDirName = currentDirName +
                         File.separator + "build" +
                         File.separator + "test" +
                         File.separator +
                         testName.replace("/", File.separator);
    if (debug) out.println(testDirName);
    return new File(testDirName);
  }

  public static Map<File, Map.Entry<String, String>> createSchemaFiles(File testDir, Map<String, String> fileToSchemaMap, boolean debug) throws IOException
  {
    Map<File, Map.Entry<String,String>> result = new HashMap<File, Map.Entry<String, String>>();

    ensureEmptyOutputDir(testDir, debug);

    
    for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
    {
      String filename = (testDir.getCanonicalPath() + File.separator + entry.getKey()).replace('/', File.separatorChar);
      File file = new File(filename);
      if (debug) out.println("creating " + file);
      File parentFile = file.getParentFile();
      parentFile.mkdirs();
      FileOutputStream outputStream = new FileOutputStream(file);
      outputStream.write(entry.getValue().getBytes(Data.UTF_8_CHARSET));
      outputStream.close();
      result.put(file, entry);
    }
    return result;
  }

  public static void createSchemaJar(String jarFileName, Map<String, String> fileToSchemaMap, boolean debug) throws IOException
  {
    if (debug) out.println("creating " + jarFileName);
    FileOutputStream jarFileStream = new FileOutputStream(jarFileName);
    JarOutputStream jarStream = new JarOutputStream(jarFileStream, new Manifest());
    for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
    {
      String key = entry.getKey();
      
      String filename = "pegasus" + key.replace(File.separatorChar, '/');
      if (debug) out.println("  adding " + filename);
      JarEntry jarEntry = new JarEntry(filename);
      jarStream.putNextEntry(jarEntry);
      jarStream.write(entry.getValue().getBytes(Data.UTF_8_CHARSET));
    }
    jarStream.close();
    jarFileStream.close();
  }

  public static Collection<String> computePathFromRelativePaths(File testDir, Collection<String> relativePaths) throws IOException
  {
    Collection<String> paths = new ArrayList<String>();

    
    for (String testPath : relativePaths)
    {
      String dirname = (testDir.getCanonicalPath() + testPath).replace('/', File.separatorChar);
      paths.add((new File(dirname)).getCanonicalPath());
    }
    return paths;
  }

  public static Collection<String> createJarsFromRelativePaths(File testDir,
                                                               Map<String, String> fileToSchemaMap,
                                                               Collection<String> relativePaths,
                                                               boolean debug)
    throws IOException
  {
    Collection<String> paths = new ArrayList<String>();

    
    paths.clear();
    for (String testPath : relativePaths)
    {
      String jarFileName = (testDir.getCanonicalPath() + testPath + ".jar").replace('/', File.separatorChar);
      Map<String,String> jarFileContents = new HashMap<String, String>();
      for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
      {
        if (entry.getKey().startsWith(testPath))
        {
          String key = entry.getKey();
          jarFileContents.put(key.substring(testPath.length()), entry.getValue());
        }
      }
      TestUtil.createSchemaJar(jarFileName, jarFileContents, debug);
      paths.add(jarFileName);
    }
    return paths;
  }

  public static String pathsToString(Collection<String> paths)
  {
    boolean first = true;
    StringBuilder sb = new StringBuilder();

    String separator = File.pathSeparator;

    for (String path : paths)
    {
      if (!first) sb.append(separator);
      sb.append(path);
      first = false;
    }
    return sb.toString();
  }

  public static void checkEachLineStartsWithLocation(String message)
  {
    String lines[] = message.split("\n");
    for (String line : lines)
    {
      assertTrue(LOCATION_REGEX.matcher(line).matches(), "\"" + line + "\" does not start with location");
    }
  }

  public static void assertEquivalent(Object actual, Object expected)
  {
    assertTrue(equivalent(actual, expected),
               "Expected :" + expected + "\n" +
               "Actual   :" + actual + "\n");
  }

  public static boolean equivalent(Object o1, Object o2)
  {
    assert(o1 != null);
    assert(o2 != null);

    boolean result = true;

    if (o1 instanceof DataMap && o2 instanceof DataMap)
    {
      DataMap map1 = (DataMap) o1;
      DataMap map2 = (DataMap) o2;
      if (map1.size() != map2.size())
      {
        result = false;
      }
      else
      {
        for (Map.Entry<String, Object> entry : map1.entrySet())
        {
          String k1 = entry.getKey();
          Object v1 = entry.getValue();
          Object v2 = map2.get(k1);
          if (v2 != null)
          {
            if (equivalent(v1, v2) == false)
            {
              result = false;
              break;
            }
          }
        }
      }
    }
    else if (o1 instanceof DataList && o2 instanceof DataList)
    {
      DataList list1 = (DataList) o1;
      DataList list2 = (DataList) o2;
      if (list1.size() != list2.size())
      {
        result = false;
      }
      else
      {
        for (int i = 0; i < list1.size(); i++)
        {
          if (equivalent(list1.get(i), list2.get(i)) == false)
          {
            result = false;
            break;
          }
        }
      }
    }
    else
    {
      Object upgraded1 = upgradeLowerValueToUpperClassIfValueIsLowerClass(o1, o2.getClass());
      Object upgraded2 = upgradeLowerValueToUpperClassIfValueIsLowerClass(o2, o1.getClass());
      result = upgraded1.equals(upgraded2);
    }
    return result;
  }

  private static Object upgradeLowerValueToUpperClassIfValueIsLowerClass(Object lower, Class<?> upperClass)
  {
    Object result;
    Class<?> lowerClass = lower.getClass();
    if (upperClass == lowerClass)
    {
      result = lower;
    }
    else if (upperClass == ByteString.class && lowerClass == String.class)
    {
      result = ByteString.copyAvroString((String) lower, true);
    }
    else if (upperClass == Double.class && (lowerClass == Integer.class || lowerClass == Long.class || lowerClass == Float.class))
    {
      result = ((Number) lower).doubleValue();
    }
    else if (upperClass == Float.class && (lowerClass == Integer.class || lowerClass == Long.class))
    {
      result = ((Number) lower).floatValue();
    }
    else if (upperClass == Long.class && (lowerClass == Integer.class))
    {
      result = ((Number) lower).longValue();
    }
    else
    {
      result = lower;
    }
    return result;
  }

  public static boolean mutateChild(Object object)
  {
    if (object instanceof DataComplex)
    {
      return mutateDataComplex((DataComplex) object);
    }
    else
    {
      return false;
    }
  }

  public static boolean mutateDataComplex(DataComplex dataComplex)
  {
    if (dataComplex.getClass() == DataMap.class)
    {
      return mutateDataMap((DataMap) dataComplex);
    }
    else if (dataComplex.getClass() == DataList.class)
    {
      return mutateDataList((DataList) dataComplex);
    }
    else
    {
      throw new IllegalStateException("unknown DataComplex");
    }
  }

  public static boolean mutateDataMap(DataMap dataMap)
  {
    if (dataMap.isEmpty())
    {
      dataMap.put("inserted", Data.NULL);
    }
    else
    {
      dataMap.remove(dataMap.entrySet().iterator().next().getKey());
    }
    return true;
  }

  public static boolean mutateDataList(DataList dataList)
  {
    if (dataList.isEmpty())
    {
      dataList.add(Data.NULL);
    }
    else
    {
      dataList.remove(dataList.size() - 1);
    }
    return true;
  }

  public static boolean noCommonDataComplex(Object o1, Object o2)
  {
    Set<DataComplex> set1 = collectDataComplex(o1);
    Set<DataComplex> set2 = collectDataComplex(o2);
    return set1.removeAll(set2) == false && set2.removeAll(set1) == false;
  }

  
  private static Set<DataComplex> collectDataComplex(final Object object)
  {
    IdentityHashMap<DataComplex, Boolean> identityHashMap = new IdentityHashMap<DataComplex, Boolean>();
    collectDataComplex(object, identityHashMap);
    return identityHashMap.keySet();
  }

  private static void collectDataComplex(Object object, IdentityHashMap<DataComplex, Boolean> identityHashMap)
  {
    if (object instanceof DataComplex)
    {
      DataComplex complex = (DataComplex) object;
      Boolean previous = identityHashMap.put(complex, Boolean.TRUE);
      if (previous == null)
      {
        if (object.getClass() == DataMap.class)
        {
          for (Object child : ((DataMap) object).values())
          {
            collectDataComplex(child, identityHashMap);
          }
        }
        else if (object.getClass() == DataList.class)
        {
          for (Object child : ((DataList) object))
          {
            collectDataComplex(child, identityHashMap);
          }
        }
        else
        {
          throw new IllegalStateException("unknown DataComplex");
        }
      }
    }
  }

  private static final Pattern LOCATION_REGEX = Pattern.compile("^\\d+,\\d+: .*$");
}

<code block>


package com.linkedin.data.transform.filter;


import com.linkedin.data.DataComplex;
import com.linkedin.data.DataList;
import com.linkedin.data.DataMap;
import com.linkedin.data.transform.DataComplexProcessor;
import com.linkedin.data.transform.DataProcessingException;
import com.linkedin.data.transform.Escaper;

import java.util.HashMap;
import java.util.Map;

import static com.linkedin.data.transform.filter.FilterConstants.COUNT;
import static com.linkedin.data.transform.filter.FilterConstants.NEGATIVE;
import static com.linkedin.data.transform.filter.FilterConstants.POSITIVE;
import static com.linkedin.data.transform.filter.FilterConstants.START;
import static com.linkedin.data.transform.filter.FilterUtil.getIntegerWithDefaultValue;



public abstract class AbstractFilter
{
  public Object filter(Object data, DataMap opNode)
  {
    if ((data != null) && (opNode != null))
    {
      
      final NodeMode defaultMode = _dafaultNodeModeCalculator.getDefaultNodeMode(opNode);

      
      final DataMap complexWildCard = getComplexWildCard(opNode);

      if (data.getClass() == DataList.class)
      {
        return filterDataList(opNode, ((DataList) data));
      }
      else if (data.getClass() == DataMap.class)
      {
        return filterDataMap(opNode, ((DataMap) data), defaultMode, complexWildCard);
      }
      else
      {
        return onError(null,
                       "Data type in instruction must be DataMap or DataList, but is: %1$s",
                       data.getClass().getName());
      }
    }
    else
    {
      return onError(null, "Either data or operation is null");
    }
  }

  protected abstract Object onFilterDataList(DataList data, int start, int count, Object operation);
  protected abstract Object onFilterDataMap(DataMap data, Map<String, Object> fieldToOperation);
  protected abstract Object onError(Object field, String format, Object... args);
  protected abstract boolean isValidDataMapFieldOperation(Map<String, Object> result, String name, Object operation);

  
  private static DataMap getComplexWildCard(DataMap opNode)
  {
    assert opNode != null;

    final Object o = opNode.get(FilterConstants.WILDCARD);
    if ((o != null) && (o.getClass() == DataMap.class))
    {
      return (DataMap) o;
    }
    else
    {
      return null;
    }
  }

  
  private static boolean areFieldsExplicitlyRemoved(NodeMode defaultMode)
  {
    return defaultMode.equals(NodeMode.HIDE_HIGH);
  }

  
  private static boolean isValidMaskType(Object mask)
  {
    return mask == null || mask.getClass() == Integer.class || mask.getClass() == DataMap.class;
  }

  
  private static DataMap wildcard(Integer v)
  {
    final DataMap wildcardMap = new DataMap();
    wildcardMap.put(FilterConstants.WILDCARD, v);
    return wildcardMap;
  }

  
  private static NodeMode getExplicitNodeMode(DataMap opNode, String name)
  {
    
    
    assert opNode != null;

    final Object childModeObj = opNode.get(Escaper.replaceAll(name, "$", "$$"));
    if (childModeObj != null && !(childModeObj.getClass() == DataMap.class))
    {
      if (childModeObj instanceof Integer)
        return NodeMode.fromRepresentation((Integer) childModeObj);
    }
    return null;
  }

  
  private Object filterDataList(DataMap opNode, DataList valueDataList)
  {
    assert opNode != null;

    final Integer start = getIntegerWithDefaultValue(opNode, START, 0);
    if (start == null || start < 0)
    {
      onError(null, "value of %1$s must be positive integer but is equal to %2$d", START, start);
    }

    final Integer count = getIntegerWithDefaultValue(opNode, COUNT, Integer.MAX_VALUE);
    if (count == null || count < 0)
    {
      onError(null, "value of %1$s must be positive integer but is equal to %2$d", COUNT, count);
    }

    if (start != null && start >= 0 && count != null && count >= 0)
    {
      final Object operation = filterByWildcard(opNode, valueDataList);
      return onFilterDataList(valueDataList, start, count, operation);
    }

    return null;
  }

  
  private Object filterByWildcard(DataMap opNode, DataList valueDataList)
  {
    final Object wildcard = opNode.get(FilterConstants.WILDCARD);
    if (wildcard != null)
    {
      if (wildcard.equals(NEGATIVE))
      {
        return FilterConstants.NEGATIVE;
      }
      else if (wildcard.getClass() == DataMap.class)
      {
        for (int i = 0; i < valueDataList.size(); ++i)
        {
          final Object elem = valueDataList.get(i);

          
          
          
          if (!(elem instanceof DataComplex))
          {
            onError(i,
                    "complex filter defined for array element, which is not an object nor an array, " +
                        "but it is of type: %1$s, with value: %2$s",
                    elem.getClass().getName(),
                    elem);
          }
        }
        return wildcard;
      }
      else if (!wildcard.equals(POSITIVE))
      {
        
        
        onError(null,
                "wildcard can be either 0, 1 or DataMap instance, but it is of type: %1$s, equal to: %2$s",
                wildcard.getClass().getName(),
                wildcard);
      }
      
    }
    
    
    return FilterConstants.POSITIVE;
  }

  private Object filterDataMap(DataMap opNode,
                               DataMap valueDataMap,
                               NodeMode defaultMode,
                               DataMap complexWildCard)
  {
    assert opNode != null;

    final Map<String, Object> result = new HashMap<String, Object>();
    for (Map.Entry<String, Object> entry : valueDataMap.entrySet())
    {
      final String name = entry.getKey();
      final Object childValue = entry.getValue();

      
      if (!isValidMaskType(opNode.get(Escaper.replaceAll(name, "$", "$$"))))
      {
        onError(name,
                "mask value for field %2$s should be of type Integer or DataMap, instead it is of type: %1$s, ",
                opNode.get(Escaper.replaceAll(name, "$", "$$")),
                name);
        
        continue;
      }

      Object operation = FilterConstants.POSITIVE;

      
      
      final NodeMode explicitFieldMode = getExplicitNodeMode(opNode, name);
      if (explicitFieldMode != null)
      {
        if (areFieldsExplicitlyRemoved(explicitFieldMode))
        {
          
          operation = FilterConstants.NEGATIVE;
        }
        else if (complexWildCard != null)
        
        
        
        {
          if (childValue instanceof DataComplex)
          {
            final DataMap composed = compose(name, complexWildCard, wildcard(1));
            if (composed != null)
            {
              operation = composed;
            }
          }
          
          
          
          
        }
      }
      else
      {
        

        final Object opChild = opNode.get(Escaper.replaceAll(name, "$", "$$"));

        

        if (opChild == null)
        {
          
          
          if (areFieldsExplicitlyRemoved(defaultMode)
              || areFieldsImplicitlyRemoved(defaultMode, complexWildCard))
          {
            operation = FilterConstants.NEGATIVE;
          }
          else if (complexWildCard != null)
          {
            if (childValue instanceof DataComplex)
            {
              operation = complexWildCard;
            }
            else if (needsRemoving(defaultMode, complexWildCard))
            {
              operation = FilterConstants.NEGATIVE;
            }
          }
        }
        else
        {
          
          assert (opChild.getClass() == DataMap.class) : opChild;

          final Object rawWildcard = opNode.get(FilterConstants.WILDCARD);
          final DataMap effectiveComplexWildcard =
              ((rawWildcard != null && rawWildcard.equals(POSITIVE)) ? wildcard(POSITIVE)
                  : (DataMap) rawWildcard);
          
          
          final DataMap effectiveMask =
              ((effectiveComplexWildcard == null) ? (DataMap) opChild
                  : compose(name, (DataMap) opChild, effectiveComplexWildcard));

          
          if (needsRemoving(defaultMode, effectiveMask))
          {
            operation = FilterConstants.NEGATIVE;
          }
          else
          {
            if (childValue instanceof DataComplex)
            {
              operation = effectiveMask;
            }
            else
            {
              onError(name, "data is of primitive value: %1$s, but filter: %2$s is complex",
                      childValue,
                      opChild);
            }
          }
        }
      }

      if (isValidDataMapFieldOperation(result, name, operation))
      {
        result.put(name, operation);
      }
    }

    return onFilterDataMap(valueDataMap, result);
  }

  
  private boolean needsRemoving(NodeMode defaultMode, DataMap effectiveMask)
  {
    return areFieldsExplicitlyRemoved(defaultMode)
        || (defaultMode.equals(NodeMode.HIDE_LOW) && (_dafaultNodeModeCalculator.getDefaultNodeMode(effectiveMask)
        .equals(NodeMode.SHOW_LOW) || _dafaultNodeModeCalculator.getDefaultNodeMode(effectiveMask)
        .equals(NodeMode.HIDE_HIGH)));
  }

  
  private boolean areFieldsImplicitlyRemoved(NodeMode defaultMode, DataMap complexWildCard)
  {
    return defaultMode.equals(NodeMode.HIDE_LOW)
        && (complexWildCard == null || !_dafaultNodeModeCalculator.getDefaultNodeMode(complexWildCard)
        .equals(NodeMode.HIDE_LOW));
  }

  
  private DataMap compose(String fieldName, DataMap mask1, DataMap mask2)
  {
    
    assert mask2 != null;
    assert mask1 != null;

    try
    {
      final DataMap clone = mask1.copy();
      new DataComplexProcessor(new MaskComposition(), mask2, clone).run(true);
      return clone;
    }
    catch (CloneNotSupportedException e)
    {
      onError(fieldName, "could not clone mask: %1$s, exception: %2$s", mask1, e);
    }
    catch (DataProcessingException e)
    {
      onError(fieldName, "error composing mask %1$s with %2$s, exception: %3$s", mask1, mask2, e);
    }
    return null;
  }

  private final DefaultNodeModeCalculator _dafaultNodeModeCalculator = new DefaultNodeModeCalculator();
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.generator.AbstractGenerator;
import com.linkedin.data.schema.resolver.FileDataSchemaLocation;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.util.FileUtil;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JPackage;
import com.sun.codemodel.writer.FileCodeWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class PegasusDataTemplateGenerator
{
  
  public static final String GENERATOR_GENERATE_IMPORTED = "generator.generate.imported";

  private static final Logger _log = LoggerFactory.getLogger(PegasusDataTemplateGenerator.class);

  public static class DataTemplatePersistentClassChecker implements JavaCodeUtil.PersistentClassChecker
  {
    private final boolean _generateImported;
    private final TemplateSpecGenerator _specGenerator;
    private final JavaDataTemplateGenerator _dataTemplateGenerator;
    private final Set<File> _sourceFiles;

    public DataTemplatePersistentClassChecker(boolean generateImported,
                                              TemplateSpecGenerator specGenerator,
                                              JavaDataTemplateGenerator dataTemplateGenerator,
                                              Set<File> sourceFiles)
    {
      _generateImported = generateImported;
      _specGenerator = specGenerator;
      _dataTemplateGenerator = dataTemplateGenerator;
      _sourceFiles = sourceFiles;
    }

    @Override
    public boolean isPersistent(JDefinedClass clazz)
    {
      if (_generateImported)
      {
        return true;
      }
      else
      {
        final ClassTemplateSpec spec = _dataTemplateGenerator.getGeneratedClasses().get(clazz);
        final DataSchemaLocation location = _specGenerator.getClassLocation(spec);
        return location == null  
            || _sourceFiles.contains(location.getSourceFile());
      }
    }
  }

  public static void main(String[] args)
      throws IOException
  {
    if (args.length < 2)
    {
      _log.error("Usage: PegasusDataTemplateGenerator targetDirectoryPath [sourceFile or sourceDirectory or schemaName]+");
      System.exit(1);
    }

    final String generateImportedProperty = System.getProperty(PegasusDataTemplateGenerator.GENERATOR_GENERATE_IMPORTED);
    final boolean generateImported = generateImportedProperty == null ? true : Boolean.parseBoolean(generateImportedProperty);
    PegasusDataTemplateGenerator.run(System.getProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH),
                                     System.getProperty(JavaCodeGeneratorBase.GENERATOR_DEFAULT_PACKAGE),
                                     generateImported,
                                     args[0],
                                     Arrays.copyOfRange(args, 1, args.length));
  }

  public static GeneratorResult run(String resolverPath, String defaultPackage, final boolean generateImported, String targetDirectoryPath, String[] sources)
      throws IOException
  {
    final DataSchemaParser schemaParser = new DataSchemaParser(resolverPath);
    final TemplateSpecGenerator specGenerator = new TemplateSpecGenerator(schemaParser.getSchemaResolver());
    final JavaDataTemplateGenerator dataTemplateGenerator = new JavaDataTemplateGenerator(defaultPackage);

    for (DataSchema predefinedSchema : JavaDataTemplateGenerator.PredefinedJavaClasses.keySet())
    {
      specGenerator.registerDefinedSchema(predefinedSchema);
    }

    final DataSchemaParser.ParseResult parseResult = schemaParser.parseSources(sources);

    for (CodeUtil.Pair<DataSchema, File> pair : parseResult.getSchemaAndFiles())
    {
      final DataSchemaLocation location = new FileDataSchemaLocation(pair.second);
      specGenerator.generate(pair.first, location);
    }
    for (CodeUtil.Pair<DataSchema, String> pair : parseResult.getSchemaAndNames())
    {
      specGenerator.generate(pair.first);
    }
    for (ClassTemplateSpec spec : specGenerator.getGeneratedSpecs())
    {
      dataTemplateGenerator.generate(spec);
    }

    final JavaCodeUtil.PersistentClassChecker checker = new DataTemplatePersistentClassChecker(generateImported, specGenerator, dataTemplateGenerator, parseResult.getSourceFiles());

    final File targetDirectory = new File(targetDirectoryPath);
    final List<File> targetFiles = JavaCodeUtil.targetFiles(targetDirectory, dataTemplateGenerator.getCodeModel(), JavaCodeUtil.classLoaderFromResolverPath(schemaParser.getResolverPath()), checker);

    final List<File> modifiedFiles;
    if (FileUtil.upToDate(parseResult.getSourceFiles(), targetFiles))
    {
      modifiedFiles = Collections.emptyList();
      _log.info("Target files are up-to-date: " + targetFiles);
    }
    else
    {
      modifiedFiles = targetFiles;
      _log.info("Generating " + targetFiles.size() + " files: " + targetFiles);
      validateDefinedClassRegistration(dataTemplateGenerator.getCodeModel(), dataTemplateGenerator.getGeneratedClasses().keySet());
      dataTemplateGenerator.getCodeModel().build(new FileCodeWriter(targetDirectory, true));
    }
    return new DefaultGeneratorResult(parseResult.getSourceFiles(), targetFiles, modifiedFiles);
  }

  
  private static void validateDefinedClassRegistration(JCodeModel codeModel, Collection<JDefinedClass> classes)
  {
    for (Iterator<JPackage> packageIterator = codeModel.packages(); packageIterator.hasNext(); )
    {
      final JPackage currentPackage = packageIterator.next();
      for (Iterator<JDefinedClass> classIterator = currentPackage.classes(); classIterator.hasNext(); )
      {
        final JDefinedClass currentClass = classIterator.next();
        if (!classes.contains(currentClass))
        {
          throw new IllegalStateException("Attempting to generate unregistered class: '" + currentClass.fullName() + "'");
        }
      }
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.DataMap;
import com.linkedin.data.schema.ArrayDataSchema;
import com.linkedin.data.schema.ComplexDataSchema;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.DataSchemaResolver;
import com.linkedin.data.schema.EnumDataSchema;
import com.linkedin.data.schema.FixedDataSchema;
import com.linkedin.data.schema.MapDataSchema;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.PrimitiveDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.TyperefDataSchema;
import com.linkedin.data.schema.UnionDataSchema;
import com.linkedin.data.template.DataTemplate;
import com.linkedin.pegasus.generator.spec.ArrayTemplateSpec;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.pegasus.generator.spec.CustomInfoSpec;
import com.linkedin.pegasus.generator.spec.EnumTemplateSpec;
import com.linkedin.pegasus.generator.spec.FixedTemplateSpec;
import com.linkedin.pegasus.generator.spec.MapTemplateSpec;
import com.linkedin.pegasus.generator.spec.ModifierSpec;
import com.linkedin.pegasus.generator.spec.PrimitiveTemplateSpec;
import com.linkedin.pegasus.generator.spec.RecordTemplateSpec;
import com.linkedin.pegasus.generator.spec.TyperefTemplateSpec;
import com.linkedin.pegasus.generator.spec.UnionTemplateSpec;

import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class TemplateSpecGenerator
{
  private static final Logger _log = LoggerFactory.getLogger(TemplateSpecGenerator.class);

  private static final String CLASS_PROPERTY = "class";
  private static final String JAVA_PROPERTY = "java";
  private static final String COERCER_CLASS_PROPERTY = "coercerClass";
  private static final String ARRAY_SUFFIX = "Array";
  private static final String MAP_SUFFIX = "Map";
  private static final String[] SPECIAL_SUFFIXES = {ARRAY_SUFFIX, MAP_SUFFIX};
  private static final String _templatePackageName = DataTemplate.class.getPackage().getName();

  private final Collection<ClassTemplateSpec> _classTemplateSpecs = new HashSet<ClassTemplateSpec>();
  
  private final Map<ClassTemplateSpec, DataSchemaLocation> _classToDataSchemaLocationMap = new HashMap<ClassTemplateSpec, DataSchemaLocation>();
  
  private final Map<String, DataSchema> _classNameToSchemaMap = new HashMap<String, DataSchema>(100);
  
  private final IdentityHashMap<DataSchema, ClassTemplateSpec> _schemaToClassMap = new IdentityHashMap<DataSchema, ClassTemplateSpec>(100);
  
  private final Deque<DataSchemaLocation> _locationStack = new ArrayDeque<DataSchemaLocation>();
  private final Map<DataSchema, CustomInfoSpec> _immediateCustomMap = new IdentityHashMap<DataSchema, CustomInfoSpec>();

  private final DataSchemaResolver _schemaResolver;

  
  public static String classNameForNamedSchema(NamedDataSchema schema)
  {
    final StringBuilder sb = new StringBuilder();
    final String namespace = schema.getNamespace();
    if (!namespace.isEmpty())
    {
      sb.append(namespace);
      sb.append('.');
    }
    sb.append(schema.getName());
    return sb.toString();
  }

  public TemplateSpecGenerator(DataSchemaResolver schemaResolver)
  {
    _schemaResolver = schemaResolver;
  }

  
  public DataSchemaLocation getClassLocation(ClassTemplateSpec classSpec)
  {
    return _classToDataSchemaLocationMap.get(classSpec);
  }

  
  public void registerDefinedSchema(DataSchema schema)
  {
    final ClassTemplateSpec spec = ClassTemplateSpec.createFromDataSchema(schema);
    _schemaToClassMap.put(schema, spec);
    _classNameToSchemaMap.put(spec.getFullName(), schema);
  }

  
  public ClassTemplateSpec generate(DataSchema schema)
  {
    return processSchema(schema, null, null);
  }

  
  public ClassTemplateSpec generate(DataSchema schema, DataSchemaLocation location)
  {
    pushCurrentLocation(location);
    final ClassTemplateSpec result = generate(schema);
    popCurrentLocation();
    return result;
  }

  public Collection<ClassTemplateSpec> getGeneratedSpecs()
  {
    return _classTemplateSpecs;
  }

  
  private static void checkClassNameForSpecialSuffix(String className)
  {
    for (String suffix : SPECIAL_SUFFIXES)
    {
      if (className.endsWith(suffix))
      {
        _log.warn("Class name for named type ends with a suffix that may conflict with derived class names for unnamed types" +
                      ", name: " + className +
                      ", suffix: " + suffix);
        break;
      }
    }
  }

  
  private static boolean allowCustomClass(DataSchema schema)
  {
    boolean result = false;
    final DataSchema.Type type = schema.getType();
    if (type == DataSchema.Type.TYPEREF || type == DataSchema.Type.RECORD)
    {
      
      final DataSchema dereferencedSchema = schema.getDereferencedDataSchema();
      if (dereferencedSchema.getType() == DataSchema.Type.RECORD || (CodeUtil.isDirectType(dereferencedSchema) && dereferencedSchema.getType() != DataSchema.Type.ENUM))
      {
        result = true;
      }
    }
    return result;
  }

  private static DataSchema dereferenceIfTyperef(DataSchema schema)
  {
    final DataSchema.Type type = schema.getType();
    return type == DataSchema.Type.TYPEREF ? ((TyperefDataSchema) schema).getRef() : null;
  }

  
  private static IllegalArgumentException nullTypeNotAllowed(ClassTemplateSpec enclosingClass, String memberName)
  {
    return new IllegalArgumentException("The null type can only be used in unions, null found" + enclosingClassAndMemberNameToString(enclosingClass, memberName));
  }

  
  private static IllegalStateException unrecognizedSchemaType(ClassTemplateSpec enclosingClass, String memberName, DataSchema schema)
  {
    return new IllegalStateException("Unrecognized schema: " + schema +
                                         enclosingClassAndMemberNameToString(enclosingClass, memberName));
  }

  
  private static String enclosingClassAndMemberNameToString(ClassTemplateSpec enclosingClass, String memberName)
  {
    final StringBuilder sb = new StringBuilder();
    if (memberName != null)
    {
      sb.append(" in ");
      sb.append(memberName);
    }
    if (enclosingClass != null)
    {
      sb.append(" in ");
      sb.append(enclosingClass.getFullName());
    }
    return sb.toString();
  }

  
  private void checkForClassNameConflict(String className, DataSchema schema)
      throws IllegalArgumentException
  {
    final DataSchema schemaFromClassName = _classNameToSchemaMap.get(className);
    boolean conflict = false;
    if (schemaFromClassName != null && schemaFromClassName != schema)
    {
      final DataSchema.Type schemaType = schema.getType();
      if (schemaFromClassName.getType() != schemaType)
      {
        conflict = true;
      }
      else if (schema instanceof NamedDataSchema)
      {
        conflict = true;
      }
      else if (!schemaFromClassName.equals(schema))
      {
        assert schemaType == DataSchema.Type.ARRAY || schemaType == DataSchema.Type.MAP;
        
        
        
        
        
        
        _log.info("Class name: " + className +
                      ", bound to schema:" + schemaFromClassName +
                      ", instead of schema: " + schema);
      }
    }
    if (conflict)
    {
      throw new IllegalArgumentException("Class name conflict detected, class name: " + className +
                                             ", class already bound to schema: " + schemaFromClassName +
                                             ", attempting to rebind to schema: " + schema);
    }
  }

  private DataSchemaLocation currentLocation()
  {
    return _locationStack.getLast();
  }

  private void pushCurrentLocation(DataSchemaLocation location)
  {
    _locationStack.addLast(location);
  }

  private void popCurrentLocation()
  {
    _locationStack.removeLast();
  }

  
  private void registerClassTemplateSpec(DataSchema schema, ClassTemplateSpec classTemplateSpec)
  {
    classTemplateSpec.setLocation(currentLocation().toString());
    _schemaToClassMap.put(schema, classTemplateSpec);
    _classNameToSchemaMap.put(classTemplateSpec.getFullName(), schema);
    _classToDataSchemaLocationMap.put(classTemplateSpec, currentLocation());

    if (schema instanceof NamedDataSchema)
    {
      checkClassNameForSpecialSuffix(classTemplateSpec.getFullName());
    }

    _classTemplateSpecs.add(classTemplateSpec);
  }

  private ClassTemplateSpec processSchema(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    ClassTemplateSpec result = null;

    final CustomInfoSpec customInfo = getImmediateCustomInfo(schema);
    while (schema.getType() == DataSchema.Type.TYPEREF)
    {
      final TyperefDataSchema typerefSchema = (TyperefDataSchema) schema;
      final ClassTemplateSpec found = _schemaToClassMap.get(schema);
      if (found == null)
      {
        if (typerefSchema.getRef().getType() == DataSchema.Type.UNION)
        {
          result = generateUnion((UnionDataSchema) typerefSchema.getRef(), typerefSchema);
          break;
        }
        else
        {
          generateTyperef(typerefSchema);
        }
      }
      else if (typerefSchema.getRef().getType() == DataSchema.Type.UNION)
      {
        result = found;
        break;
      }
      schema = typerefSchema.getRef();
    }
    if (result == null)
    {
      assert schema == schema.getDereferencedDataSchema();
      if (schema instanceof ComplexDataSchema)
      {
        final ClassTemplateSpec found = _schemaToClassMap.get(schema);
        if (found == null)
        {
          if (schema instanceof NamedDataSchema)
          {
            result = generateNamedSchema((NamedDataSchema) schema);
          }
          else
          {
            result = generateUnnamedComplexSchema(schema, enclosingClass, memberName);
          }
        }
        else
        {
          result = found;
        }

        if (customInfo != null)
        {
          result = customInfo.getCustomClass();
        }
      }
      else if (schema instanceof PrimitiveDataSchema)
      {
        result = (customInfo != null) ? customInfo.getCustomClass() : getPrimitiveClassForSchema((PrimitiveDataSchema) schema, enclosingClass, memberName);
      }
    }

    if (result == null)
    {
      throw unrecognizedSchemaType(enclosingClass, memberName, schema);
    }

    return result;
  }

  
  private CustomClasses getCustomClasses(DataSchema schema)
  {
    CustomClasses customClasses = null;
    final Map<String, Object> properties = schema.getProperties();
    final Object java = properties.get(JAVA_PROPERTY);
    if (java != null)
    {
      if (java.getClass() != DataMap.class)
      {
        throw new IllegalArgumentException(schema + " has \"java\" property that is not a DataMap");
      }
      final DataMap map = (DataMap) java;
      final Object custom = map.get(CLASS_PROPERTY);
      if (custom != null)
      {
        if (custom.getClass() != String.class)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"class\" that is not a string");
        }
        
        customClasses = new CustomClasses();
        customClasses.customClass = new ClassTemplateSpec();
        customClasses.customClass.setFullName((String) custom);
        if (!allowCustomClass(schema))
        {
          throw new IllegalArgumentException(schema + " cannot have custom class binding");
        }
      }
      
      final Object coercerClass = map.get(COERCER_CLASS_PROPERTY);
      if (coercerClass != null)
      {
        if (coercerClass.getClass() != String.class)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"coercerClass\" that is not a string");
        }
        if (customClasses == null)
        {
          throw new IllegalArgumentException(schema + " has \"java\" property with \"coercerClass\" but does not have \"class\" property");
        }
        
        customClasses.customCoercerClass = new ClassTemplateSpec();
        customClasses.customCoercerClass.setFullName((String) coercerClass);
      }
    }
    return customClasses;
  }

  private CustomInfoSpec getImmediateCustomInfo(DataSchema schema)
  {
    if (_immediateCustomMap.containsKey(schema))
    {
      return _immediateCustomMap.get(schema);
    }

    CustomInfoSpec immediate = null;
    for (DataSchema current = schema; current != null; current = dereferenceIfTyperef(current))
    {
      final CustomClasses customClasses = getCustomClasses(current);
      if (customClasses != null)
      {
        immediate = new CustomInfoSpec((NamedDataSchema) schema, (NamedDataSchema) current, customClasses.customClass, customClasses.customCoercerClass);
        break;
      }
    }

    
    _immediateCustomMap.put(schema, immediate);
    return immediate;
  }

  private ClassTemplateSpec getPrimitiveClassForSchema(PrimitiveDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    switch (schema.getType())
    {
      case INT:
      case DOUBLE:
      case BOOLEAN:
      case STRING:
      case LONG:
      case FLOAT:
      case BYTES:
        return PrimitiveTemplateSpec.getInstance(schema.getType());
      case NULL:
        throw nullTypeNotAllowed(enclosingClass, memberName);
    }
    throw unrecognizedSchemaType(enclosingClass, memberName, schema);
  }

  private ClassTemplateSpec generateNamedSchema(NamedDataSchema schema)
  {
    pushCurrentLocation(_schemaResolver.nameToDataSchemaLocations().get(schema.getFullName()));

    final String className = classNameForNamedSchema(schema);
    checkForClassNameConflict(className, schema);

    final ClassTemplateSpec templateClass;
    switch (schema.getType())
    {
      case RECORD:
        templateClass = generateRecord((RecordDataSchema) schema);
        break;
      case ENUM:
        templateClass = generateEnum((EnumDataSchema) schema);
        break;
      case FIXED:
        templateClass = generateFixed((FixedDataSchema) schema);
        break;
      default:
        throw unrecognizedSchemaType(null, null, schema);
    }

    popCurrentLocation();

    return templateClass;
  }

  private ClassTemplateSpec generateUnnamedComplexSchema(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    if (schema instanceof ArrayDataSchema)
    {
      return generateArray((ArrayDataSchema) schema, enclosingClass, memberName);
    }
    else if (schema instanceof MapDataSchema)
    {
      return generateMap((MapDataSchema) schema, enclosingClass, memberName);
    }
    else if (schema instanceof UnionDataSchema)
    {
      return generateUnion((UnionDataSchema) schema, enclosingClass, memberName);
    }
    else
    {
      throw unrecognizedSchemaType(enclosingClass, memberName, schema);
    }
  }

  private ClassTemplateSpec determineDataClass(DataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final ClassTemplateSpec result;
    final DataSchema dereferencedSchema = schema.getDereferencedDataSchema();
    if (dereferencedSchema.getType() == DataSchema.Type.ENUM)
    {
      result = PrimitiveTemplateSpec.getInstance(DataSchema.Type.STRING);
    }
    else if (CodeUtil.isDirectType(dereferencedSchema))
    {
      result = getPrimitiveClassForSchema((PrimitiveDataSchema) dereferencedSchema, enclosingClass, memberName);
    }
    else
    {
      result = null;
    }
    return result;
  }

  private ArrayTemplateSpec generateArray(ArrayDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final DataSchema itemSchema = schema.getItems();

    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      
      processSchema(itemSchema, enclosingClass, memberName);

      return (ArrayTemplateSpec) classInfo.existingClass;
    }

    final ArrayTemplateSpec arrayClass = (ArrayTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, arrayClass);

    arrayClass.setItemClass(processSchema(itemSchema, enclosingClass, memberName));
    arrayClass.setItemDataClass(determineDataClass(itemSchema, enclosingClass, memberName));

    final CustomInfoSpec customInfo = getImmediateCustomInfo(itemSchema);
    arrayClass.setCustomInfo(customInfo);

    return arrayClass;
  }

  private MapTemplateSpec generateMap(MapDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    final DataSchema valueSchema = schema.getValues();

    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      
      processSchema(valueSchema, enclosingClass, memberName);

      return (MapTemplateSpec) classInfo.existingClass;
    }

    final MapTemplateSpec mapClass = (MapTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, mapClass);

    mapClass.setValueClass(processSchema(valueSchema, enclosingClass, memberName));
    mapClass.setValueDataClass(determineDataClass(valueSchema, enclosingClass, memberName));

    final CustomInfoSpec customInfo = getImmediateCustomInfo(valueSchema);
    mapClass.setCustomInfo(customInfo);

    return mapClass;
  }

  private UnionTemplateSpec generateUnion(UnionDataSchema schema, ClassTemplateSpec enclosingClass, String memberName)
  {
    if (enclosingClass == null || memberName == null)
    {
      throw new IllegalArgumentException("Cannot processSchema template for top level union: " + schema);
    }
    final ClassInfo classInfo = classInfoForUnnamed(enclosingClass, memberName, schema);
    if (classInfo.existingClass != null)
    {
      return (UnionTemplateSpec) classInfo.existingClass;
    }
    final UnionTemplateSpec unionClass = (UnionTemplateSpec) classInfo.definedClass;
    registerClassTemplateSpec(schema, unionClass);
    return generateUnion(schema, unionClass);
  }

  private ClassTemplateSpec generateUnion(UnionDataSchema schema, TyperefDataSchema typerefDataSchema)
  {
    assert typerefDataSchema.getRef() == schema;

    pushCurrentLocation(_schemaResolver.nameToDataSchemaLocations().get(typerefDataSchema.getFullName()));

    final UnionTemplateSpec unionClass = new UnionTemplateSpec(schema);
    unionClass.setNamespace(typerefDataSchema.getNamespace());
    unionClass.setClassName(typerefDataSchema.getName());
    unionClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(typerefDataSchema, unionClass);

    final TyperefTemplateSpec typerefInfoClass = new TyperefTemplateSpec(typerefDataSchema);
    typerefInfoClass.setEnclosingClass(unionClass);
    typerefInfoClass.setClassName("UnionTyperefInfo");
    typerefInfoClass.setModifiers(ModifierSpec.PRIVATE, ModifierSpec.STATIC, ModifierSpec.FINAL);

    final UnionTemplateSpec result = generateUnion(schema, unionClass);
    result.setTyperefClass(typerefInfoClass);

    popCurrentLocation();
    return result;
  }

  private UnionTemplateSpec generateUnion(UnionDataSchema schema, UnionTemplateSpec unionClass)
  {
    for (DataSchema memberType : schema.getTypes())
    {
      final UnionTemplateSpec.Member newMember = new UnionTemplateSpec.Member();
      unionClass.getMembers().add(newMember);

      newMember.setSchema(memberType);

      if (memberType.getDereferencedType() != DataSchema.Type.NULL)
      {
        newMember.setClassTemplateSpec(processSchema(memberType, unionClass, memberType.getUnionMemberKey()));
        newMember.setDataClass(determineDataClass(memberType, unionClass, memberType.getUnionMemberKey()));
      }
    }

    return unionClass;
  }

  private ClassTemplateSpec generateEnum(EnumDataSchema schema)
  {
    final EnumTemplateSpec enumClass = new EnumTemplateSpec(schema);
    enumClass.setNamespace(schema.getNamespace());
    enumClass.setClassName(schema.getName());
    enumClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, enumClass);
    return enumClass;
  }

  private ClassTemplateSpec generateFixed(FixedDataSchema schema)
  {
    final FixedTemplateSpec fixedClass = new FixedTemplateSpec(schema);
    fixedClass.setNamespace(schema.getNamespace());
    fixedClass.setClassName(schema.getName());
    fixedClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, fixedClass);

    return fixedClass;
  }

  private TyperefTemplateSpec generateTyperef(TyperefDataSchema schema)
  {
    final TyperefTemplateSpec typerefClass = new TyperefTemplateSpec(schema);
    typerefClass.setNamespace(schema.getNamespace());
    typerefClass.setClassName(schema.getName());
    typerefClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, typerefClass);
    return typerefClass;
  }

  private RecordTemplateSpec generateRecord(RecordDataSchema schema)
  {
    final RecordTemplateSpec recordClass = new RecordTemplateSpec(schema);
    recordClass.setNamespace(schema.getNamespace());
    recordClass.setClassName(schema.getName());
    recordClass.setModifiers(ModifierSpec.PUBLIC);
    registerClassTemplateSpec(schema, recordClass);

    
    
    final List<NamedDataSchema> includes = schema.getInclude();
    for (NamedDataSchema includedSchema : includes)
    {
      generate(includedSchema);
    }

    final Map<CustomInfoSpec, Object> customInfoMap = new IdentityHashMap<CustomInfoSpec, Object>(schema.getFields().size() * 2);

    for (RecordDataSchema.Field field : schema.getFields())
    {
      final ClassTemplateSpec fieldClass = processSchema(field.getType(), recordClass, field.getName());
      final RecordTemplateSpec.Field newField = new RecordTemplateSpec.Field();
      newField.setSchemaField(field);
      newField.setType(fieldClass);
      newField.setDataClass(determineDataClass(field.getType(), recordClass, field.getName()));

      final CustomInfoSpec customInfo = getImmediateCustomInfo(field.getType());
      if (customInfo != null && !customInfoMap.containsKey(customInfo))
      {
        customInfoMap.put(customInfo, null);
        newField.setCustomInfo(customInfo);
      }

      recordClass.addField(newField);
    }

    return recordClass;
  }

  
  private ClassInfo classInfoForUnnamed(ClassTemplateSpec enclosingClass, String name, DataSchema schema)
  {
    assert !(schema instanceof NamedDataSchema);
    assert !(schema instanceof PrimitiveDataSchema);

    final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, name, schema);
    final String className = classInfo.fullName();

    final DataSchema schemaFromClassName = _classNameToSchemaMap.get(className);
    if (schemaFromClassName == null)
    {
      final ClassTemplateSpec classTemplateSpec = ClassTemplateSpec.createFromDataSchema(schema);

      if (enclosingClass != null && classInfo.namespace.equals(enclosingClass.getFullName()))
      {
        classTemplateSpec.setEnclosingClass(enclosingClass);
        classTemplateSpec.setClassName(classInfo.name);
        classTemplateSpec.setModifiers(ModifierSpec.PUBLIC, ModifierSpec.STATIC, ModifierSpec.FINAL);
      }
      else
      {
        classTemplateSpec.setNamespace(classInfo.namespace);
        classTemplateSpec.setClassName(classInfo.name);
        classTemplateSpec.setModifiers(ModifierSpec.PUBLIC);
      }
      classInfo.definedClass = classTemplateSpec;
    }
    else
    {
      checkForClassNameConflict(className, schema);
      classInfo.existingClass = _schemaToClassMap.get(schemaFromClassName);
    }

    return classInfo;
  }

  private ClassInfo classNameForUnnamedTraverse(ClassTemplateSpec enclosingClass, String memberName, DataSchema schema)
  {
    final DataSchema dereferencedDataSchema = schema.getDereferencedDataSchema();
    switch (dereferencedDataSchema.getType())
    {
      case ARRAY:
        final ArrayDataSchema arraySchema = (ArrayDataSchema) dereferencedDataSchema;
        CustomInfoSpec customInfo = getImmediateCustomInfo(arraySchema.getItems());
        if (customInfo != null)
        {
          return new ClassInfo(customInfo.getCustomSchema().getNamespace(), customInfo.getCustomSchema().getName() + ARRAY_SUFFIX);
        }
        else
        {
          final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, memberName, arraySchema.getItems());
          classInfo.name += ARRAY_SUFFIX;
          return classInfo;
        }
      case MAP:
        final MapDataSchema mapSchema = (MapDataSchema) dereferencedDataSchema;
        customInfo = getImmediateCustomInfo(mapSchema.getValues());
        if (customInfo != null)
        {
          return new ClassInfo(customInfo.getCustomSchema().getNamespace(), customInfo.getCustomSchema().getName() + MAP_SUFFIX);
        }
        else
        {
          final ClassInfo classInfo = classNameForUnnamedTraverse(enclosingClass, memberName, mapSchema.getValues());
          classInfo.name += MAP_SUFFIX;
          return classInfo;
        }

      case UNION:
        if (schema.getType() == DataSchema.Type.TYPEREF)
        {
          DataSchema referencedDataSchema;
          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) schema;
          while ((referencedDataSchema = typerefDataSchema.getDereferencedDataSchema()) != dereferencedDataSchema)
          {
            typerefDataSchema = (TyperefDataSchema) referencedDataSchema;
          }
          return new ClassInfo(typerefDataSchema.getNamespace(), CodeUtil.capitalize(typerefDataSchema.getName()));
        }
        else
        {
          return new ClassInfo(enclosingClass.getFullName(), CodeUtil.capitalize(memberName));
        }

      case FIXED:
      case RECORD:
      case ENUM:
        final NamedDataSchema namedSchema = (NamedDataSchema) dereferencedDataSchema;
        return new ClassInfo(namedSchema.getNamespace(), CodeUtil.capitalize(namedSchema.getName()));

      case BOOLEAN:
        return new ClassInfo(_templatePackageName, "Boolean");

      case INT:
        return new ClassInfo(_templatePackageName, "Integer");

      case LONG:
        return new ClassInfo(_templatePackageName, "Long");

      case FLOAT:
        return new ClassInfo(_templatePackageName, "Float");

      case DOUBLE:
        return new ClassInfo(_templatePackageName, "Double");

      case STRING:
        return new ClassInfo(_templatePackageName, "String");

      case BYTES:
        return new ClassInfo(_templatePackageName, "ByteString");

      case NULL:
        throw nullTypeNotAllowed(enclosingClass, memberName);

      default:
        throw unrecognizedSchemaType(enclosingClass, memberName, dereferencedDataSchema);
    }
  }

  private static class CustomClasses
  {
    private ClassTemplateSpec customClass;
    private ClassTemplateSpec customCoercerClass;
  }

  private static class ClassInfo
  {
    private String namespace;
    private String name;
    private ClassTemplateSpec existingClass;
    private ClassTemplateSpec definedClass;

    private ClassInfo(String namespace, String name)
    {
      this.namespace = namespace;
      this.name = name;
    }

    private String fullName()
    {
      return namespace.isEmpty() ? name : namespace + '.' + name;
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.DataSchemaLocation;
import com.linkedin.data.schema.DataSchemaResolver;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.SchemaParser;
import com.linkedin.data.schema.resolver.FileDataSchemaLocation;
import com.linkedin.data.schema.resolver.FileDataSchemaResolver;
import com.linkedin.util.FileUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;



public class DataSchemaParser
{
  private final String _resolverPath;
  private final DataSchemaResolver _schemaResolver;

  
  public DataSchemaParser(String resolverPath)
  {
    _resolverPath = resolverPath;
    _schemaResolver = CodeUtil.createSchemaResolver(resolverPath);
  }

  public String getResolverPath()
  {
    return _resolverPath;
  }

  public DataSchemaResolver getSchemaResolver()
  {
    return _schemaResolver;
  }

  
  public ParseResult parseSources(String sources[])
      throws IOException
  {
    final ParseResult result = new ParseResult();

    try
    {
      for (String source : sources)
      {
        final File sourceFile = new File(source);
        if (sourceFile.exists())
        {
          if (sourceFile.isDirectory())
          {
            final FileUtil.FileExtensionFilter filter = new FileUtil.FileExtensionFilter(FileDataSchemaResolver.DEFAULT_EXTENSION);
            final List<File> sourceFilesInDirectory = FileUtil.listFiles(sourceFile, filter);
            for (File f : sourceFilesInDirectory)
            {
              parseFile(f, result);
            }
          }
          else
          {
            parseFile(sourceFile, result);
          }
        }
        else
        {
          final StringBuilder errorMessage = new StringBuilder();
          final DataSchema schema = _schemaResolver.findDataSchema(source, errorMessage);
          if (schema == null)
          {
            result.getMessage().append("File cannot be opened or schema name cannot be resolved: ").append(source).append("\n");
          }
          if (errorMessage.length() > 0)
          {
            result.getMessage().append(errorMessage.toString());
          }
          if (schema != null)
          {
            result.getSchemaAndNames().add(new CodeUtil.Pair<DataSchema, String>(schema, source));
          }
        }
      }

      if (result.getMessage().length() > 0)
      {
        throw new IOException(result.getMessage().toString());
      }

      appendSourceFilesFromSchemaResolver(result);

      return result;
    }
    catch (RuntimeException e)
    {
      if (result.getMessage().length() > 0)
      {
        e = new RuntimeException("Unexpected " + e.getClass().getSimpleName() + " encountered.\n" +
                                     "This may be caused by the following parsing or processing errors:\n" +
                                     result.getMessage(), e);
      }
      throw e;
    }
  }

  
  private void parseFile(File schemaSourceFile, ParseResult result)
      throws IOException
  {
    if (wasResolved(schemaSourceFile))
    {
      return;
    }

    final List<DataSchema> schemas = parseSchema(schemaSourceFile, result);

    for (DataSchema schema : schemas)
    {
      validateSchemaWithFilePath(schemaSourceFile, schema);
      result.getSchemaAndFiles().add(new CodeUtil.Pair<DataSchema, File>(schema, schemaSourceFile));
      result.getSourceFiles().add(schemaSourceFile);
    }
  }

  
  private void validateSchemaWithFilePath(File schemaSourceFile, DataSchema schema)
  {
    if (schemaSourceFile != null && schemaSourceFile.isFile() && schema instanceof NamedDataSchema)
    {
      final NamedDataSchema namedDataSchema = (NamedDataSchema) schema;
      final String namespace = namedDataSchema.getNamespace();

      if (!FileUtil.removeFileExtension(schemaSourceFile.getName()).equalsIgnoreCase(namedDataSchema.getName()))
      {
        throw new IllegalArgumentException(namedDataSchema.getFullName() + " has name that does not match filename '" +
                                               schemaSourceFile.getAbsolutePath() + "'");
      }

      final String directory = schemaSourceFile.getParentFile().getAbsolutePath();
      if (!directory.endsWith(namespace.replace('.', File.separatorChar)))
      {
        throw new IllegalArgumentException(namedDataSchema.getFullName() + " has namespace that does not match " +
                                               "file path '" + schemaSourceFile.getAbsolutePath() + "'");
      }
    }
  }

  
  private boolean wasResolved(File schemaSourceFile)
  {
    final FileDataSchemaLocation schemaLocation = new FileDataSchemaLocation(schemaSourceFile);
    return _schemaResolver.locationResolved(schemaLocation);
  }

  
  private List<DataSchema> parseSchema(final File schemaSourceFile, ParseResult result)
      throws IOException
  {
    final SchemaParser parser = new SchemaParser(_schemaResolver);
    final FileInputStream schemaStream = new SchemaFileInputStream(schemaSourceFile);
    try
    {
      parser.setLocation(new FileDataSchemaLocation(schemaSourceFile));
      parser.parse(schemaStream);
      if (parser.hasError())
      {
        return Collections.emptyList();
      }
      return parser.topLevelDataSchemas();
    }
    finally
    {
      schemaStream.close();
      if (parser.hasError())
      {
        result.getMessage().append(schemaSourceFile.getPath() + ",");
        result.getMessage().append(parser.errorMessage());
      }
    }
  }

  
  private void appendSourceFilesFromSchemaResolver(ParseResult result)
  {
    for (Map.Entry<String, DataSchemaLocation> entry : _schemaResolver.nameToDataSchemaLocations().entrySet())
    {
      final File sourceFile = entry.getValue().getSourceFile();
      if (sourceFile != null)
      {
        result.getSourceFiles().add(sourceFile);
      }
    }
  }

  
  public static class ParseResult
  {
    
    private final Collection<CodeUtil.Pair<DataSchema, File>> _schemaAndFiles = new ArrayList<CodeUtil.Pair<DataSchema, File>>();
    private final Collection<CodeUtil.Pair<DataSchema, String>> _schemaAndNames = new ArrayList<CodeUtil.Pair<DataSchema, String>>();
    private final Set<File> _sourceFiles = new HashSet<File>();
    private final StringBuilder _message = new StringBuilder();

    
    public Collection<CodeUtil.Pair<DataSchema, File>> getSchemaAndFiles()
    {
      return _schemaAndFiles;
    }

    
    public Collection<CodeUtil.Pair<DataSchema, String>> getSchemaAndNames()
    {
      return _schemaAndNames;
    }

    
    public Set<File> getSourceFiles()
    {
      return _sourceFiles;
    }

    public StringBuilder getMessage()
    {
      return _message;
    }
  }

  private static class SchemaFileInputStream extends FileInputStream
  {
    private File _schemaSourceFile;

    private SchemaFileInputStream(File file)
        throws FileNotFoundException
    {
      super(file);
      _schemaSourceFile = file;
    }

    @Override
    public String toString()
    {
      return _schemaSourceFile.toString();
    }
  }
}

<code block>


package com.linkedin.data.avro;


import com.linkedin.data.DataMap;
import com.linkedin.data.TestUtil;
import com.linkedin.data.avro.util.AvroUtil;
import com.linkedin.data.it.Predicate;
import com.linkedin.data.it.Predicates;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.NamedDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.SchemaParser;
import com.linkedin.data.schema.util.Filters;
import java.io.IOException;
import org.apache.avro.Schema;
import org.apache.avro.generic.GenericRecord;
import org.testng.annotations.Test;

import static org.testng.Assert.assertEquals;


public class TestFilteredSchemaDataTranslation
{
  
  @Test
  public void testFilteredAvroSchemaDataTranslation() throws IOException
  {
    Object inputs[][] = {
      {
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : \"int\", \"optional\" : true }, " +
        "    { \"name\" : \"c\", \"type\" : \"int\", \"optional\" : true, \"derived\" : true } " +
        "  ] " +
        "}",
        Predicates.hasChildWithNameValue("derived", true),
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : [ \"null\", \"int\" ], \"default\" : null } " +
        "  ] " +
        "}",
        
        "{ \"a\" : 1, \"b\" : 2, \"c\" : 3 }",
        "{ \"a\" : 1, \"b\" : { \"int\" : 2 } }",
        
        "{ \"a\" : 1, \"c\" : 3 }",
        "{ \"a\" : 1, \"b\" : null }",
      }
    };

    for (Object[] row : inputs)
    {
      int i = 0;
      String schemaText = (String) row[i++];
      Predicate predicate = (Predicate) row[i++];
      String avroSchemaText = (String) row[i++];

      RecordDataSchema schema = (RecordDataSchema) TestUtil.dataSchemaFromString(schemaText);
      NamedDataSchema filteredSchema = Filters.removeByPredicate(schema, predicate, new SchemaParser());
      Schema filteredAvroSchema = SchemaTranslator.dataToAvroSchema(filteredSchema);

      Schema expectedAvroSchema = Schema.parse(avroSchemaText);
      assertEquals(filteredAvroSchema, expectedAvroSchema);

      while (i < row.length)
      {
        String translationSourceJson = (String) row[i++];
        String translationResultJson = (String) row[i++];

        DataMap dataMap = TestUtil.dataMapFromString(translationSourceJson);
        GenericRecord genericRecord = DataTranslator.dataMapToGenericRecord(dataMap, schema, filteredAvroSchema);

        String avroJson = AvroUtil.jsonFromGenericRecord(genericRecord);
        DataMap avroJsonAsDataMap = TestUtil.dataMapFromString(avroJson);

        assertEquals(avroJsonAsDataMap, TestUtil.dataMapFromString(translationResultJson));
      }
    }
  }

  
  @Test
  public void testFilteredDataSchemaDataTranslation() throws IOException
  {
    Object inputs[][] = {
      {
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : [ \"null\", \"int\" ], \"default\" : null }, " +
        "    { \"name\" : \"removeMe\", \"type\" : \"int\" } " +
        "  ] " +
        "}",
        Predicates.hasChildWithNameValue("name", "removeMe"),
        "{ " +
        "  \"type\" : \"record\", " +
        "  \"name\" : \"Foo\", " +
        "  \"fields\" : [ " +
        "    { \"name\" : \"a\", \"type\" : \"int\" }, " +
        "    { \"name\" : \"b\", \"type\" : \"int\", \"optional\" : true } " +
        "  ] " +
        "}",
        
        "{ \"a\" : 1, \"b\" : { \"int\" : 2 }, \"removeMe\" : 3 }",
        "{ \"a\" : 1, \"b\" : 2 }",
        
        "{ \"a\" : 1, \"b\" : null, \"removeMe\" : 3 }",
        "{ \"a\" : 1 }",
      }
    };

    for (Object[] row : inputs)
    {
      int i = 0;
      String avroSchemaText = (String) row[i++];
      Predicate predicate = (Predicate) row[i++];
      String schemaText = (String) row[i++];

      Schema avroSchema = Schema.parse(avroSchemaText);
      System.out.println(avroSchema);
      RecordDataSchema schema = (RecordDataSchema) SchemaTranslator.avroToDataSchema(avroSchema);
      RecordDataSchema filteredSchema = (RecordDataSchema) Filters.removeByPredicate(schema, predicate, new SchemaParser());

      DataSchema expectedSchema = TestUtil.dataSchemaFromString(schemaText);
      System.out.println(filteredSchema);
      assertEquals(filteredSchema, expectedSchema);

      while (i < row.length)
      {
        String translationSourceJson = (String) row[i++];
        String translationExpectedJson = (String) row[i++];

        GenericRecord genericRecord = AvroUtil.genericRecordFromJson(translationSourceJson, avroSchema);
        DataMap dataMap = DataTranslator.genericRecordToDataMap(genericRecord, filteredSchema, avroSchema);

        assertEquals(dataMap, TestUtil.dataMapFromString(translationExpectedJson));
      }
    }
  }
}

<code block>


package com.linkedin.pegasus.generator.test;


import com.linkedin.data.TestUtil;
import com.linkedin.pegasus.generator.PegasusDataTemplateGenerator;

import java.io.File;
import java.io.IOException;
import java.util.Map;

import org.testng.annotations.Test;

import static com.linkedin.data.TestUtil.asMap;
import static com.linkedin.data.TestUtil.ensureEmptyOutputDir;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;


public class TestBadSchemas
{
  private final Object _badSchemas[][] =
    {
      {
        asMap(
          "com/linkedin/pegasus/generator/test/ArrayNameDuplicateTest.pdsc",
          "{\n" +
          "  \"type\" : \"record\",\n" +
          "  \"name\" : \"ArrayNameDuplicateTest\",\n" +
          "  \"namespace\" : \"com.linkedin.pegasus.generator.test\",\n" +
          "  \"fields\" : [\n" +
          "    {\n" +
          "      \"name\" : \"x\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"enum\",\n" +
          "        \"name\" : \"X\",\n" +
          "        \"symbols\" : [ \"X\" ]\n" +
          "      }\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"arrayOfX\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"array\",\n" +
          "        \"items\" : \"X\"\n" +
          "      }\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"xArray\",\n" +
          "      \"type\" : {\n" +
          "        \"type\" : \"enum\",\n" +
          "        \"name\" : \"XArray\",\n" +
          "        \"symbols\" : [ \"Y\" ]\n" +
          "      }\n" +
          "    }\n" +
          "  ]\n" +
          "}"
        ),
        IllegalArgumentException.class,
        "Class name conflict detected, class name: com.linkedin.pegasus.generator.test.XArray, class already bound to schema: { \"type\" : \"array\", \"items\" : { \"type\" : \"enum\", \"name\" : \"X\", \"namespace\" : \"com.linkedin.pegasus.generator.test\", \"symbols\" : [ \"X\" ] } }, attempting to rebind to schema: { \"type\" : \"enum\", \"name\" : \"XArray\", \"namespace\" : \"com.linkedin.pegasus.generator.test\", \"symbols\" : [ \"Y\" ] }"
      },
      {
        asMap(
          "com/linkedin/pegasus/generator/test/FieldDefinedTwice.pdsc",
          "{\n" +
          "  \"type\" : \"record\",\n" +
          "  \"name\" : \"FieldDefinedTwice\",\n" +
          "  \"namespace\" : \"com.linkedin.pegasus.generator.test\",\n" +
          "  \"fields\" : [\n" +
          "    {\n" +
          "      \"name\" : \"foo\",\n" +
          "      \"type\" : \"long\"\n" +
          "    },\n" +
          "    {\n" +
          "      \"name\" : \"foo\",\n" +
          "      \"type\" : \"string\"\n" +
          "    }\n" +
          "  ]\n" +
          "}"
        ),
        IOException.class,
        "build/test/testGeneratorBadSchemas/pegasuscom/linkedin/pegasus/generator/test/FieldDefinedTwice.pdsc,4,54: Field \"foo\" defined more than once, with \"long\" and \"string\"."
      }
    };

  private final static String _sourceDirName = "testGeneratorBadSchemas/pegasus";
  private final static String _targetDirName = "testGeneratorBadSchemas/codegen/out";

  @Test
  public void testBadSchemas() throws IOException
  {
    boolean debug = false;

    System.setProperty("generator.resolver.path", "");

    for (Object[] row : _badSchemas)
    {
      @SuppressWarnings("unchecked")
      Map<String,String> testSchemas = (Map<String,String>) row[0];

      File testDir = TestUtil.testDir(_sourceDirName, debug);
      Map<File, Map.Entry<String,String>> files = TestUtil.createSchemaFiles(testDir, testSchemas, debug);

      File targetDir = TestUtil.testDir(_targetDirName, debug);
      ensureEmptyOutputDir(targetDir, debug);

      String[] args = new String[files.size() + 1];
      int i = 0;
      args[i++] = targetDir.getCanonicalPath();
      for (Map.Entry<File, Map.Entry<String,String>> fileEntry : files.entrySet())
      {
        File file = fileEntry.getKey();
        String fileName = file.getCanonicalPath();
        args[i++] = fileName;
      }

      Class<?> expectedExceptionClass = null;
      if (row.length > 1)
      {
        expectedExceptionClass = (Class<?>) row[1];
      }

      try
      {
        PegasusDataTemplateGenerator.main(args);
        assertTrue(expectedExceptionClass == null);
      }
      catch (Exception exc)
      {
        assertTrue(expectedExceptionClass != null);
        assertEquals(exc.getClass(), expectedExceptionClass);
        String message = exc.getMessage();
        for (int j = 2; j < row.length; j++)
        {
          String expectedString = (String) row[j];
          assertTrue(message.contains(expectedString), message + " does not contain " + expectedString);
        }
      }
    }
  }
}

<code block>


package com.linkedin.data;

import com.linkedin.data.codec.DataLocation;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.SchemaParser;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.regex.Pattern;

import static org.testng.Assert.assertTrue;


public class TestUtil
{
  static public final PrintStream out = new PrintStream(new FileOutputStream(FileDescriptor.out));

  static public String stringFromException(Exception e)
  {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    PrintStream printStream = new PrintStream(outputStream);
    e.printStackTrace(printStream);
    printStream.flush();
    return outputStream.toString();
  }

  static public void dumpBytes(PrintStream printStream, byte bytes[])
  {
    for (int i = 0; i < bytes.length; i++)
    {
      if (i % 16 == 0)
        printStream.printf("%1$06X:", i);
      printStream.print(' ');
      if (bytes[i] < 32 || bytes[i] >= 127)
        printStream.print(' ');
      else
        printStream.print((char) bytes[i]);
      printStream.printf(" %1$02X", bytes[i]);
      if (i % 16 == 15)
        printStream.println();
    }
  }

  static public List<Object> asList(Object... objects)
  {
    ArrayList<Object> list = new ArrayList<Object>();
    for (Object object : objects)
    {
      list.add(object);
    }
    return list;
  }

  @SuppressWarnings("unchecked")
  static public <V> Map<String, V> asMap(Object... objects)
  {
    int index = 0;
    String key = null;
    HashMap<String,V> map = new HashMap<String,V>();
    for (Object object : objects)
    {
      if (index % 2 == 0)
      {
        key = (String) object;
      }
      else
      {
        map.put(key, (V) object);
      }
      index++;
    }
    return map;
  }

  static public InputStream inputStreamFromString(String s) throws UnsupportedEncodingException
  {
    byte[] bytes = s.getBytes(Data.UTF_8_CHARSET);
    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
    return bais;
  }

  static public SchemaParser schemaParserFromString(String s) throws UnsupportedEncodingException, IOException
  {
    SchemaParser parser = new SchemaParser();
    parser.parse(inputStreamFromString(s));
    return parser;
  }

  static public SchemaParser schemaParserFromObjects(List<Object> objects) throws IOException
  {
    SchemaParser parser = new SchemaParser();
    parser.parse(objects);
    return parser;
  }

  static public SchemaParser schemaParserFromObjectsString(String stringOfObjects) throws IOException
  {
    List<Object> objects = objectsFromString(stringOfObjects);
    return schemaParserFromObjects(objects);
  }

  static public DataSchema dataSchemaFromString(String s) throws IOException
  {
    SchemaParser parser = schemaParserFromString(s);
    if (parser.hasError())
    {
      out.println("ERROR: " + parser.errorMessage());
      return null;
    }
    return parser.topLevelDataSchemas().get(parser.topLevelDataSchemas().size() - 1);
  }

  private static final JacksonDataCodec codec = new JacksonDataCodec();

  public static List<Object> objectsFromString(String string) throws IOException
  {
    return objectsFromInputStream(inputStreamFromString(string));
  }

  public static List<Object> objectsFromInputStream(InputStream inputStream) throws IOException
  {
    StringBuilder errorMessageBuilder = new StringBuilder();
    List<Object> objects = codec.parse(inputStream, errorMessageBuilder, new HashMap<Object, DataLocation>());
    if (errorMessageBuilder.length() > 0)
    {
      throw new IOException(errorMessageBuilder.toString());
    }
    return objects;
  }

  public static DataMap dataMapFromString(String json) throws IOException
  {
    return codec.stringToMap(json);
  }

  public static boolean deleteRecursive(String path, boolean debug) throws FileNotFoundException
  {
    return deleteRecursive(new File(path), debug);
  }

  public static void ensureEmptyOutputDir(File dir, boolean debug) throws FileNotFoundException
  {
    deleteRecursive(dir, debug);
    dir.mkdirs();
    assertTrue(dir.exists());
    assertTrue(dir.isDirectory());
    assertTrue(dir.canWrite());
  }

  public static boolean deleteRecursive(File path, boolean debug) throws FileNotFoundException
  {
    if (!path.exists())
    {
      return true;
    }
    boolean ret = true;
    if (path.isDirectory())
    {
      for (File f : path.listFiles())
      {
        ret = ret && deleteRecursive(f, debug);
      }
    }
    if (debug) out.println("deleting " + path);
    return ret && path.delete();
  }

  public static File testDir(String testName, boolean debug) throws IOException
  {
    File currentDir = new File(".");
    String currentDirName = currentDir.getCanonicalPath();
    if (debug) out.println(currentDir.getCanonicalPath());
    String testDirName = currentDirName +
                         File.separator + "build" +
                         File.separator + "test" +
                         File.separator +
                         testName.replace("/", File.separator);
    if (debug) out.println(testDirName);
    return new File(testDirName);
  }

  public static Map<File, Map.Entry<String, String>> createSchemaFiles(File testDir, Map<String, String> fileToSchemaMap, boolean debug) throws IOException
  {
    Map<File, Map.Entry<String,String>> result = new HashMap<File, Map.Entry<String, String>>();

    ensureEmptyOutputDir(testDir, debug);

    
    for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
    {
      String filename = (testDir.getCanonicalPath() + entry.getKey()).replace('/', File.separatorChar);
      File file = new File(filename);
      if (debug) out.println("creating " + file);
      File parentFile = file.getParentFile();
      parentFile.mkdirs();
      FileOutputStream outputStream = new FileOutputStream(file);
      outputStream.write(entry.getValue().getBytes(Data.UTF_8_CHARSET));
      outputStream.close();
      result.put(file, entry);
    }
    return result;
  }

  public static void createSchemaJar(String jarFileName, Map<String, String> fileToSchemaMap, boolean debug) throws IOException
  {
    if (debug) out.println("creating " + jarFileName);
    FileOutputStream jarFileStream = new FileOutputStream(jarFileName);
    JarOutputStream jarStream = new JarOutputStream(jarFileStream, new Manifest());
    for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
    {
      String key = entry.getKey();
      
      String filename = "pegasus" + key.replace(File.separatorChar, '/');
      if (debug) out.println("  adding " + filename);
      JarEntry jarEntry = new JarEntry(filename);
      jarStream.putNextEntry(jarEntry);
      jarStream.write(entry.getValue().getBytes(Data.UTF_8_CHARSET));
    }
    jarStream.close();
    jarFileStream.close();
  }

  public static Collection<String> computePathFromRelativePaths(File testDir, Collection<String> relativePaths) throws IOException
  {
    Collection<String> paths = new ArrayList<String>();

    
    for (String testPath : relativePaths)
    {
      String dirname = (testDir.getCanonicalPath() + testPath).replace('/', File.separatorChar);
      paths.add((new File(dirname)).getCanonicalPath());
    }
    return paths;
  }

  public static Collection<String> createJarsFromRelativePaths(File testDir,
                                                               Map<String, String> fileToSchemaMap,
                                                               Collection<String> relativePaths,
                                                               boolean debug)
    throws IOException
  {
    Collection<String> paths = new ArrayList<String>();

    
    paths.clear();
    for (String testPath : relativePaths)
    {
      String jarFileName = (testDir.getCanonicalPath() + testPath + ".jar").replace('/', File.separatorChar);
      Map<String,String> jarFileContents = new HashMap<String, String>();
      for (Map.Entry<String,String> entry : fileToSchemaMap.entrySet())
      {
        if (entry.getKey().startsWith(testPath))
        {
          String key = entry.getKey();
          jarFileContents.put(key.substring(testPath.length()), entry.getValue());
        }
      }
      TestUtil.createSchemaJar(jarFileName, jarFileContents, debug);
      paths.add(jarFileName);
    }
    return paths;
  }

  public static String pathsToString(Collection<String> paths)
  {
    boolean first = true;
    StringBuilder sb = new StringBuilder();

    String separator = File.pathSeparator;

    for (String path : paths)
    {
      if (!first) sb.append(separator);
      sb.append(path);
      first = false;
    }
    return sb.toString();
  }

  public static void checkEachLineStartsWithLocation(String message)
  {
    String lines[] = message.split("\n");
    for (String line : lines)
    {
      assertTrue(LOCATION_REGEX.matcher(line).matches(), "\"" + line + "\" does not start with location");
    }
  }

  public static void assertEquivalent(Object actual, Object expected)
  {
    assertTrue(equivalent(actual, expected),
               "Expected :" + expected + "\n" +
               "Actual   :" + actual + "\n");
  }

  public static boolean equivalent(Object o1, Object o2)
  {
    assert(o1 != null);
    assert(o2 != null);

    boolean result = true;

    if (o1 instanceof DataMap && o2 instanceof DataMap)
    {
      DataMap map1 = (DataMap) o1;
      DataMap map2 = (DataMap) o2;
      if (map1.size() != map2.size())
      {
        result = false;
      }
      else
      {
        for (Map.Entry<String, Object> entry : map1.entrySet())
        {
          String k1 = entry.getKey();
          Object v1 = entry.getValue();
          Object v2 = map2.get(k1);
          if (v2 != null)
          {
            if (equivalent(v1, v2) == false)
            {
              result = false;
              break;
            }
          }
        }
      }
    }
    else if (o1 instanceof DataList && o2 instanceof DataList)
    {
      DataList list1 = (DataList) o1;
      DataList list2 = (DataList) o2;
      if (list1.size() != list2.size())
      {
        result = false;
      }
      else
      {
        for (int i = 0; i < list1.size(); i++)
        {
          if (equivalent(list1.get(i), list2.get(i)) == false)
          {
            result = false;
            break;
          }
        }
      }
    }
    else
    {
      Object upgraded1 = upgradeLowerValueToUpperClassIfValueIsLowerClass(o1, o2.getClass());
      Object upgraded2 = upgradeLowerValueToUpperClassIfValueIsLowerClass(o2, o1.getClass());
      result = upgraded1.equals(upgraded2);
    }
    return result;
  }

  private static Object upgradeLowerValueToUpperClassIfValueIsLowerClass(Object lower, Class<?> upperClass)
  {
    Object result;
    Class<?> lowerClass = lower.getClass();
    if (upperClass == lowerClass)
    {
      result = lower;
    }
    else if (upperClass == ByteString.class && lowerClass == String.class)
    {
      result = ByteString.copyAvroString((String) lower, true);
    }
    else if (upperClass == Double.class && (lowerClass == Integer.class || lowerClass == Long.class || lowerClass == Float.class))
    {
      result = ((Number) lower).doubleValue();
    }
    else if (upperClass == Float.class && (lowerClass == Integer.class || lowerClass == Long.class))
    {
      result = ((Number) lower).floatValue();
    }
    else if (upperClass == Long.class && (lowerClass == Integer.class))
    {
      result = ((Number) lower).longValue();
    }
    else
    {
      result = lower;
    }
    return result;
  }

  public static boolean mutateChild(Object object)
  {
    if (object instanceof DataComplex)
    {
      return mutateDataComplex((DataComplex) object);
    }
    else
    {
      return false;
    }
  }

  public static boolean mutateDataComplex(DataComplex dataComplex)
  {
    if (dataComplex.getClass() == DataMap.class)
    {
      return mutateDataMap((DataMap) dataComplex);
    }
    else if (dataComplex.getClass() == DataList.class)
    {
      return mutateDataList((DataList) dataComplex);
    }
    else
    {
      throw new IllegalStateException("unknown DataComplex");
    }
  }

  public static boolean mutateDataMap(DataMap dataMap)
  {
    if (dataMap.isEmpty())
    {
      dataMap.put("inserted", Data.NULL);
    }
    else
    {
      dataMap.remove(dataMap.entrySet().iterator().next().getKey());
    }
    return true;
  }

  public static boolean mutateDataList(DataList dataList)
  {
    if (dataList.isEmpty())
    {
      dataList.add(Data.NULL);
    }
    else
    {
      dataList.remove(dataList.size() - 1);
    }
    return true;
  }

  public static boolean noCommonDataComplex(Object o1, Object o2)
  {
    Set<DataComplex> set1 = collectDataComplex(o1);
    Set<DataComplex> set2 = collectDataComplex(o2);
    return set1.removeAll(set2) == false && set2.removeAll(set1) == false;
  }

  
  private static Set<DataComplex> collectDataComplex(final Object object)
  {
    IdentityHashMap<DataComplex, Boolean> identityHashMap = new IdentityHashMap<DataComplex, Boolean>();
    collectDataComplex(object, identityHashMap);
    return identityHashMap.keySet();
  }

  private static void collectDataComplex(Object object, IdentityHashMap<DataComplex, Boolean> identityHashMap)
  {
    if (object instanceof DataComplex)
    {
      DataComplex complex = (DataComplex) object;
      Boolean previous = identityHashMap.put(complex, Boolean.TRUE);
      if (previous == null)
      {
        if (object.getClass() == DataMap.class)
        {
          for (Object child : ((DataMap) object).values())
          {
            collectDataComplex(child, identityHashMap);
          }
        }
        else if (object.getClass() == DataList.class)
        {
          for (Object child : ((DataList) object))
          {
            collectDataComplex(child, identityHashMap);
          }
        }
        else
        {
          throw new IllegalStateException("unknown DataComplex");
        }
      }
    }
  }

  private static final Pattern LOCATION_REGEX = Pattern.compile("^\\d+,\\d+: .*$");
}

<code block>


package com.linkedin.data.transform.filter;


import com.linkedin.data.DataComplex;
import com.linkedin.data.DataList;
import com.linkedin.data.DataMap;
import com.linkedin.data.transform.DataComplexProcessor;
import com.linkedin.data.transform.DataProcessingException;
import com.linkedin.data.transform.Escaper;

import java.util.HashMap;
import java.util.Map;

import static com.linkedin.data.transform.filter.FilterConstants.COUNT;
import static com.linkedin.data.transform.filter.FilterConstants.NEGATIVE;
import static com.linkedin.data.transform.filter.FilterConstants.POSITIVE;
import static com.linkedin.data.transform.filter.FilterConstants.START;
import static com.linkedin.data.transform.filter.FilterUtil.getIntegerWithDefaultValue;



public abstract class AbstractFilter
{
  public Object filter(Object data, DataMap opNode)
  {
    if ((data != null) && (opNode != null))
    {
      
      final NodeMode defaultMode = _dafaultNodeModeCalculator.getDefaultNodeMode(opNode);

      
      final DataMap complexWildCard = getComplexWildCard(opNode);

      if (data.getClass() == DataList.class)
      {
        return filterDataList(opNode, ((DataList) data));
      }
      else if (data.getClass() == DataMap.class)
      {
        return filterDataMap(opNode, ((DataMap) data), defaultMode, complexWildCard);
      }
      else
      {
        return onError(null,
                       "Data type in instruction must be DataMap or DataList, but is: %1$s",
                       data.getClass().getName());
      }
    }
    else
    {
      return onError(null, "Either data or operation is null");
    }
  }

  protected abstract Object onFilterDataList(DataList data, int start, int count, Object operation);
  protected abstract Object onFilterDataMap(DataMap data, Map<String, Object> fieldToOperation);
  protected abstract Object onError(Object field, String format, Object... args);
  protected abstract boolean isValidDataMapFieldOperation(Map<String, Object> result, String name, Object operation);

  
  private static DataMap getComplexWildCard(DataMap opNode)
  {
    assert opNode != null;

    final Object o = opNode.get(FilterConstants.WILDCARD);
    if ((o != null) && (o.getClass() == DataMap.class))
    {
      return (DataMap) o;
    }
    else
    {
      return null;
    }
  }

  
  private static boolean areFieldsExplicitlyRemoved(NodeMode defaultMode)
  {
    return defaultMode.equals(NodeMode.HIDE_HIGH);
  }

  
  private static boolean isValidMaskType(Object mask)
  {
    return mask == null || mask.getClass() == Integer.class || mask.getClass() == DataMap.class;
  }

  
  private static DataMap wildcard(Integer v)
  {
    final DataMap wildcardMap = new DataMap();
    wildcardMap.put(FilterConstants.WILDCARD, v);
    return wildcardMap;
  }

  
  private static NodeMode getExplicitNodeMode(DataMap opNode, String name)
  {
    
    
    assert opNode != null;

    final Object childModeObj = opNode.get(Escaper.replaceAll(name, "$", "$$"));
    if (childModeObj != null && !(childModeObj.getClass() == DataMap.class))
    {
      if (childModeObj instanceof Integer)
        return NodeMode.fromRepresentation((Integer) childModeObj);
    }
    return null;
  }

  
  private Object filterDataList(DataMap opNode, DataList valueDataList)
  {
    assert opNode != null;

    final Integer start = getIntegerWithDefaultValue(opNode, START, 0);
    if (start == null || start < 0)
    {
      onError(null, "value of %1$s must be positive integer but is equal to %2$d", START, start);
    }

    final Integer count = getIntegerWithDefaultValue(opNode, COUNT, Integer.MAX_VALUE);
    if (count == null || count < 0)
    {
      onError(null, "value of %1$s must be positive integer but is equal to %2$d", COUNT, count);
    }

    if (start != null && start >= 0 && count != null && count >= 0)
    {
      final Object operation = filterByWildcard(opNode, valueDataList);
      return onFilterDataList(valueDataList, start, count, operation);
    }

    return null;
  }

  
  private Object filterByWildcard(DataMap opNode, DataList valueDataList)
  {
    final Object wildcard = opNode.get(FilterConstants.WILDCARD);
    if (wildcard != null)
    {
      if (wildcard.equals(NEGATIVE))
      {
        return FilterConstants.NEGATIVE;
      }
      else if (wildcard.getClass() == DataMap.class)
      {
        for (int i = 0; i < valueDataList.size(); ++i)
        {
          final Object elem = valueDataList.get(i);

          
          
          
          if (!(elem instanceof DataComplex))
          {
            onError(i,
                    "complex filter defined for array element, which is not an object nor an array, " +
                        "but it is of type: %1$s, with value: %2$s",
                    elem.getClass().getName(),
                    elem);
          }
        }
        return wildcard;
      }
      else if (!wildcard.equals(POSITIVE))
      {
        
        
        onError(null,
                "wildcard can be either 0, 1 or DataMap instance, but it is of type: %1$s, equal to: %2$s",
                wildcard.getClass().getName(),
                wildcard);
      }
      
    }
    
    
    return FilterConstants.POSITIVE;
  }

  private Object filterDataMap(DataMap opNode,
                               DataMap valueDataMap,
                               NodeMode defaultMode,
                               DataMap complexWildCard)
  {
    assert opNode != null;

    final Map<String, Object> result = new HashMap<String, Object>();
    for (Map.Entry<String, Object> entry : valueDataMap.entrySet())
    {
      final String name = entry.getKey();
      final Object childValue = entry.getValue();

      
      if (!isValidMaskType(opNode.get(Escaper.replaceAll(name, "$", "$$"))))
      {
        onError(name,
                "mask value for field %2$s should be of type Integer or DataMap, instead it is of type: %1$s, ",
                opNode.get(Escaper.replaceAll(name, "$", "$$")),
                name);
        
        continue;
      }

      Object operation = FilterConstants.POSITIVE;

      
      
      final NodeMode explicitFieldMode = getExplicitNodeMode(opNode, name);
      if (explicitFieldMode != null)
      {
        if (areFieldsExplicitlyRemoved(explicitFieldMode))
        {
          
          operation = FilterConstants.NEGATIVE;
        }
        else if (complexWildCard != null)
        
        
        
        {
          if (childValue instanceof DataComplex)
          {
            final DataMap composed = compose(name, complexWildCard, wildcard(1));
            if (composed != null)
            {
              operation = composed;
            }
          }
          
          
          
          
        }
      }
      else
      {
        

        final Object opChild = opNode.get(Escaper.replaceAll(name, "$", "$$"));

        

        if (opChild == null)
        {
          
          
          if (areFieldsExplicitlyRemoved(defaultMode)
              || areFieldsImplicitlyRemoved(defaultMode, complexWildCard))
          {
            operation = FilterConstants.NEGATIVE;
          }
          else if (complexWildCard != null)
          {
            if (childValue instanceof DataComplex)
            {
              operation = complexWildCard;
            }
            else if (needsRemoving(defaultMode, complexWildCard))
            {
              operation = FilterConstants.NEGATIVE;
            }
          }
        }
        else
        {
          
          assert (opChild.getClass() == DataMap.class) : opChild;

          final Object rawWildcard = opNode.get(FilterConstants.WILDCARD);
          final DataMap effectiveComplexWildcard =
              ((rawWildcard != null && rawWildcard.equals(POSITIVE)) ? wildcard(POSITIVE)
                  : (DataMap) rawWildcard);
          
          
          final DataMap effectiveMask =
              ((effectiveComplexWildcard == null) ? (DataMap) opChild
                  : compose(name, (DataMap) opChild, effectiveComplexWildcard));

          
          if (needsRemoving(defaultMode, effectiveMask))
          {
            operation = FilterConstants.NEGATIVE;
          }
          else
          {
            if (childValue instanceof DataComplex)
            {
              operation = effectiveMask;
            }
            else
            {
              onError(name, "data is of primitve value: %1$s, but filter: %2$s is complex",
                      childValue,
                      opChild);
            }
          }
        }
      }

      if (isValidDataMapFieldOperation(result, name, operation))
      {
        result.put(name, operation);
      }
    }

    return onFilterDataMap(valueDataMap, result);
  }

  
  private boolean needsRemoving(NodeMode defaultMode, DataMap effectiveMask)
  {
    return areFieldsExplicitlyRemoved(defaultMode)
        || (defaultMode.equals(NodeMode.HIDE_LOW) && (_dafaultNodeModeCalculator.getDefaultNodeMode(effectiveMask)
        .equals(NodeMode.SHOW_LOW) || _dafaultNodeModeCalculator.getDefaultNodeMode(effectiveMask)
        .equals(NodeMode.HIDE_HIGH)));
  }

  
  private boolean areFieldsImplicitlyRemoved(NodeMode defaultMode, DataMap complexWildCard)
  {
    return defaultMode.equals(NodeMode.HIDE_LOW)
        && (complexWildCard == null || !_dafaultNodeModeCalculator.getDefaultNodeMode(complexWildCard)
        .equals(NodeMode.HIDE_LOW));
  }

  
  private DataMap compose(String fieldName, DataMap mask1, DataMap mask2)
  {
    
    assert mask2 != null;
    assert mask1 != null;

    try
    {
      final DataMap clone = mask1.copy();
      new DataComplexProcessor(new MaskComposition(), mask2, clone).run(true);
      return clone;
    }
    catch (CloneNotSupportedException e)
    {
      onError(fieldName, "could not clone mask: %1$s, exception: %2$s", mask1, e);
    }
    catch (DataProcessingException e)
    {
      onError(fieldName, "error composing mask %1$s with %2$s, exception: %3$s", mask1, mask2, e);
    }
    return null;
  }

  private final DefaultNodeModeCalculator _dafaultNodeModeCalculator = new DefaultNodeModeCalculator();
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataList;
import com.linkedin.data.DataMap;
import com.linkedin.data.schema.PathSpec;
import com.linkedin.data.template.Custom;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.GetMode;
import com.linkedin.data.template.SetMode;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.sun.codemodel.JClass;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JFieldRef;
import com.sun.codemodel.JPackage;



public class JavaCodeGeneratorBase
{
  
  public static final String GENERATOR_DEFAULT_PACKAGE = "generator.default.package";

  protected static final String SUPER = "super";
  protected static final String THIS = "this";

  private static final Set<String> _reserved = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(
      "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class",
      "const", "continue", "default", "do", "double", "else", "enum", "extends", "final",
      "finally", "float", "for", "goto", "if", "implements", "import", "instanceof", "int",
      "interface", "long", "native", "new", "null", "package", "private", "protected", "public",
      "return", "short", "static", "strictfp", "super", "switch", "synchronized",
      "this", "throw", "throws", "transient", "try", "void", "volatile", "while"
  )));

  
  protected final JClass _byteStringClass;
  protected final JClass _collectionClass;
  protected final JClass _customClass;
  protected final JClass _dataListClass;
  protected final JClass _dataMapClass;
  protected final JClass _dataTemplateUtilClass;
  protected final JClass _getModeClass;
  protected final JClass _mapClass;
  protected final JClass _pathSpecClass;
  protected final JClass _setModeClass;
  protected final JClass _stringBuilderClass;
  protected final JClass _stringClass;

  protected final JFieldRef _disallowNullSetMode;
  protected final JFieldRef _strictGetMode;
  
  private final JCodeModel _codeModel = new JCodeModel();
  
  private JPackage _package;

  public JavaCodeGeneratorBase(String defaultPackage)
  {
    _byteStringClass = getCodeModel().ref(ByteString.class);
    _collectionClass = getCodeModel().ref(Collection.class);
    _customClass = getCodeModel().ref(Custom.class);
    _dataListClass = getCodeModel().ref(DataList.class);
    _dataMapClass = getCodeModel().ref(DataMap.class);
    _dataTemplateUtilClass = getCodeModel().ref(DataTemplateUtil.class);
    _getModeClass = getCodeModel().ref(GetMode.class);
    _mapClass = getCodeModel().ref(Map.class);
    _pathSpecClass = getCodeModel().ref(PathSpec.class);
    _setModeClass = getCodeModel().ref(SetMode.class);
    _stringBuilderClass = getCodeModel().ref(StringBuilder.class);
    _stringClass = getCodeModel().ref(String.class);

    _disallowNullSetMode = getCodeModel().ref(SetMode.class).staticRef("DISALLOW_NULL");
    _strictGetMode = getCodeModel().ref(GetMode.class).staticRef("STRICT");

    _package = getCodeModel()._package(defaultPackage == null ? "" : defaultPackage);
  }

  protected static boolean isReserved(String name)
  {
    return _reserved.contains(name);
  }

  protected static String escapeReserved(String name)
  {
    if (_reserved.contains(name))
    {
      return name + '_';
    }
    return name;
  }

  
  public JCodeModel getCodeModel()
  {
    return _codeModel;
  }

  protected JPackage getPackage()
  {
    return _package;
  }

  protected JPackage getPackage(String namespace)
  {
    return namespace.isEmpty() ? getPackage() : _codeModel._package(namespace);
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataMap;
import com.linkedin.data.schema.ArrayDataSchema;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.EnumDataSchema;
import com.linkedin.data.schema.JsonBuilder;
import com.linkedin.data.schema.MapDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.SchemaToJsonEncoder;
import com.linkedin.data.template.BooleanArray;
import com.linkedin.data.template.BooleanMap;
import com.linkedin.data.template.BytesArray;
import com.linkedin.data.template.BytesMap;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.DirectArrayTemplate;
import com.linkedin.data.template.DirectMapTemplate;
import com.linkedin.data.template.DoubleArray;
import com.linkedin.data.template.DoubleMap;
import com.linkedin.data.template.FixedTemplate;
import com.linkedin.data.template.FloatArray;
import com.linkedin.data.template.FloatMap;
import com.linkedin.data.template.HasTyperefInfo;
import com.linkedin.data.template.IntegerArray;
import com.linkedin.data.template.IntegerMap;
import com.linkedin.data.template.LongArray;
import com.linkedin.data.template.LongMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.data.template.StringArray;
import com.linkedin.data.template.StringMap;
import com.linkedin.data.template.TyperefInfo;
import com.linkedin.data.template.UnionTemplate;
import com.linkedin.data.template.WrappingArrayTemplate;
import com.linkedin.data.template.WrappingMapTemplate;
import com.linkedin.pegasus.generator.spec.ArrayTemplateSpec;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.pegasus.generator.spec.CustomInfoSpec;
import com.linkedin.pegasus.generator.spec.EnumTemplateSpec;
import com.linkedin.pegasus.generator.spec.FixedTemplateSpec;
import com.linkedin.pegasus.generator.spec.MapTemplateSpec;
import com.linkedin.pegasus.generator.spec.ModifierSpec;
import com.linkedin.pegasus.generator.spec.PrimitiveTemplateSpec;
import com.linkedin.pegasus.generator.spec.RecordTemplateSpec;
import com.linkedin.pegasus.generator.spec.TyperefTemplateSpec;
import com.linkedin.pegasus.generator.spec.UnionTemplateSpec;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sun.codemodel.ClassType;
import com.sun.codemodel.JAnnotatable;
import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JClassContainer;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JDocCommentable;
import com.sun.codemodel.JEnumConstant;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JInvocation;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JVar;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class JavaDataTemplateGenerator extends JavaCodeGeneratorBase
{
  
  public static final Map<DataSchema, Class<?>> PredefinedJavaClasses;
  static
  {
    final Class<?>[] predefinedClass = new Class<?>[] {
        BooleanArray.class,
        BooleanMap.class,
        BytesArray.class,
        BytesMap.class,
        DoubleArray.class,
        DoubleMap.class,
        FloatArray.class,
        FloatMap.class,
        IntegerArray.class,
        IntegerMap.class,
        LongArray.class,
        LongMap.class,
        StringArray.class,
        StringMap.class
    };

    PredefinedJavaClasses = new HashMap<DataSchema, Class<?>>();

    for (Class<?> clazz : predefinedClass)
    {
      final DataSchema schema = DataTemplateUtil.getSchema(clazz);
      PredefinedJavaClasses.put(schema, clazz);
    }
  }

  private static final int MAX_SCHEMA_FIELD_JSON_LENGTH = 32000;
  private static final Logger _log = LoggerFactory.getLogger(JavaDataTemplateGenerator.class);
  
  
  
  private static final String DEPRECATED_KEY = "deprecated";
  private static final String DEPRECATED_SYMBOLS_KEY = "deprecatedSymbols";

  private final Map<ClassTemplateSpec, JDefinedClass> _definedClasses = new HashMap<ClassTemplateSpec, JDefinedClass>();
  private final Map<JDefinedClass, ClassTemplateSpec> _generatedClasses = new HashMap<JDefinedClass, ClassTemplateSpec>();

  private final JClass _recordBaseClass;
  private final JClass _unionBaseClass;
  private final JClass _wrappingArrayBaseClass;
  private final JClass _wrappingMapBaseClass;
  private final JClass _directArrayBaseClass;
  private final JClass _directMapBaseClass;

  private final boolean _recordFieldAccessorWithMode;
  private final boolean _recordFieldRemove;
  private final boolean _pathSpecMethods;
  private final boolean _copierMethods;

  private JavaDataTemplateGenerator(String defaultPackage,
                                    boolean recordFieldAccessorWithMode,
                                    boolean recordFieldRemove,
                                    boolean pathSpecMethods,
                                    boolean copierMethods)
  {
    super(defaultPackage);

    _recordBaseClass = getCodeModel().ref(RecordTemplate.class);
    _unionBaseClass = getCodeModel().ref(UnionTemplate.class);
    _wrappingArrayBaseClass = getCodeModel().ref(WrappingArrayTemplate.class);
    _wrappingMapBaseClass = getCodeModel().ref(WrappingMapTemplate.class);
    _directArrayBaseClass = getCodeModel().ref(DirectArrayTemplate.class);
    _directMapBaseClass = getCodeModel().ref(DirectMapTemplate.class);

    _recordFieldAccessorWithMode = recordFieldAccessorWithMode;
    _recordFieldRemove = recordFieldRemove;
    _pathSpecMethods = pathSpecMethods;
    _copierMethods = copierMethods;
  }

  public JavaDataTemplateGenerator(Config config)
  {
    this(config.getDefaultPackage(),
         config.getRecordFieldAccessorWithMode(),
         config.getRecordFieldRemove(),
         config.getPathSpecMethods(),
         config.getCopierMethods());
  }

  
  public JavaDataTemplateGenerator(String defaultPackage)
  {
    this(defaultPackage,
         true,
         true,
         true,
         true);
  }

  public Map<JDefinedClass, ClassTemplateSpec> getGeneratedClasses()
  {
    return _generatedClasses;
  }

  public JClass generate(ClassTemplateSpec classTemplateSpec)
  {
    final JClass result;

    if (classTemplateSpec == null)
    {
      result = null;
    }
    else
    {
      if (classTemplateSpec.getSchema() == null)
      {
        result = getCodeModel().directClass(classTemplateSpec.getFullName());
      }
      else if (PredefinedJavaClasses.containsKey(classTemplateSpec.getSchema()))
      {
        final Class<?> nativeJavaClass = PredefinedJavaClasses.get(classTemplateSpec.getSchema());
        result = getCodeModel().ref(nativeJavaClass);
      }
      else if (classTemplateSpec.getSchema().isPrimitive())
      {
        result = generatePrimitive((PrimitiveTemplateSpec) classTemplateSpec);
      }
      else
      {
        try
        {
          final JDefinedClass definedClass = defineClass(classTemplateSpec);
          populateClassContent(classTemplateSpec, definedClass);
          result = definedClass;
        }
        catch (JClassAlreadyExistsException e)
        {
          throw new IllegalArgumentException(classTemplateSpec.getFullName());
        }
      }
    }

    return result;
  }

  private static JInvocation dataClassArg(JInvocation inv, JClass dataClass)
  {
    if (dataClass != null)
    {
      inv.arg(JExpr.dotclass(dataClass));
    }
    return inv;
  }

  private static void generateCopierMethods(JDefinedClass templateClass)
  {
    overrideCopierMethod(templateClass, "clone");
    overrideCopierMethod(templateClass, "copy");
  }

  private static boolean hasNestedFields(DataSchema schema)
  {
    while (true)
    {
      switch (schema.getDereferencedType())
      {
        case RECORD:
          return true;
        case UNION:
          return true;
        case ARRAY:
          schema = ((ArrayDataSchema) schema.getDereferencedDataSchema()).getItems();
          continue;
        case MAP:
          schema = ((MapDataSchema) schema.getDereferencedDataSchema()).getValues();
          continue;
        default:
          return false;
      }
    }
  }

  private static void generateConstructorWithNoArg(JDefinedClass cls, JVar schemaField, JClass newClass)
  {
    final JMethod noArgConstructor = cls.constructor(JMod.PUBLIC);
    noArgConstructor.body().invoke(SUPER).arg(JExpr._new(newClass)).arg(schemaField);
  }

  private static void generateConstructorWithNoArg(JDefinedClass cls, JClass newClass)
  {
    final JMethod noArgConstructor = cls.constructor(JMod.PUBLIC);
    noArgConstructor.body().invoke(THIS).arg(JExpr._new(newClass));
  }

  private static void generateConstructorWithObjectArg(JDefinedClass cls, JVar schemaField)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(Object.class, "data");
    argConstructor.body().invoke(SUPER).arg(param).arg(schemaField);
  }

  private static void generateConstructorWithArg(JDefinedClass cls, JVar schemaField, JClass paramClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(paramClass, "data");
    argConstructor.body().invoke(SUPER).arg(param).arg(schemaField);
  }

  private static void generateConstructorWithArg(JDefinedClass cls, JVar schemaField, JClass paramClass, JClass elementClass, JClass dataClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(paramClass, "data");
    final JInvocation inv = argConstructor.body().invoke(SUPER).arg(param).arg(schemaField).arg(JExpr.dotclass(elementClass));
    dataClassArg(inv, dataClass);
  }

  
  private static DataSchema schemaForArrayItemsOrMapValues(CustomInfoSpec customInfo, DataSchema schema)
  {
    return customInfo != null ? customInfo.getCustomSchema() : schema.getDereferencedDataSchema();
  }

  private static void overrideCopierMethod(JDefinedClass templateClass, String methodName)
  {
    final JMethod copierMethod = templateClass.method(JMod.PUBLIC, templateClass, methodName);
    copierMethod.annotate(Override.class);
    copierMethod._throws(CloneNotSupportedException.class);
    copierMethod.body()._return(JExpr.cast(templateClass, JExpr._super().invoke(methodName)));
  }

  private static void setDeprecatedAnnotationAndJavadoc(DataSchema schema, JDefinedClass schemaClass)
  {
    setDeprecatedAnnotationAndJavadoc(schema.getProperties().get(DEPRECATED_KEY), schemaClass, schemaClass);
  }

  private static void setDeprecatedAnnotationAndJavadoc(JMethod method, RecordDataSchema.Field field)
  {
    setDeprecatedAnnotationAndJavadoc(field.getProperties().get(DEPRECATED_KEY), method, method);
  }

  private static void setDeprecatedAnnotationAndJavadoc(EnumDataSchema enumSchema, String symbol, JEnumConstant constant)
  {
    final Object deprecatedSymbolsProp = enumSchema.getProperties().get(DEPRECATED_SYMBOLS_KEY);
    if (deprecatedSymbolsProp instanceof DataMap)
    {
      final DataMap deprecatedSymbols = (DataMap) deprecatedSymbolsProp;

      final Object deprecatedProp = deprecatedSymbols.get(symbol);
      setDeprecatedAnnotationAndJavadoc(deprecatedProp, constant, constant);
    }
  }

  private static void setDeprecatedAnnotationAndJavadoc(Object deprecatedProp, JAnnotatable annotatable, JDocCommentable commentable)
  {
    if (Boolean.TRUE.equals(deprecatedProp) && annotatable != null)
    {
      annotatable.annotate(Deprecated.class);
    }
    else if (deprecatedProp instanceof String)
    {
      if (commentable != null)
      {
        final String deprecatedReason = (String) deprecatedProp;
        commentable.javadoc().addDeprecated().append(deprecatedReason);
      }
      if (annotatable != null)
      {
        annotatable.annotate(Deprecated.class);
      }
    }
  }

  private static int getJModValue(Set<ModifierSpec> modifiers)
  {
    try
    {
      int value = 0;
      for (ModifierSpec mod : modifiers)
      {
        value |= JMod.class.getDeclaredField(mod.name()).getInt(null);
      }
      return value;
    }
    catch (NoSuchFieldException e)
    {
      throw new RuntimeException(e);
    }
    catch (IllegalAccessException e)
    {
      throw new RuntimeException(e);
    }
  }

  private static void addAccessorDoc(JMethod method, RecordDataSchema.Field field, String prefix)
  {
    method.javadoc().append(prefix + " for " + field.getName());
    method.javadoc().addXdoclet("see Fields#" + escapeReserved(field.getName()));
  }

  private JDefinedClass defineClass(ClassTemplateSpec classTemplateSpec)
      throws JClassAlreadyExistsException
  {
    JDefinedClass result = _definedClasses.get(classTemplateSpec);
    if (result == null)
    {
      final int jmodValue = getJModValue(classTemplateSpec.getModifiers());
      final JClassContainer container;
      if (classTemplateSpec.getEnclosingClass() == null)
      {
        container = getPackage(classTemplateSpec.getNamespace());
      }
      else
      {
        container = defineClass(classTemplateSpec.getEnclosingClass());
      }

      if (classTemplateSpec instanceof ArrayTemplateSpec ||
          classTemplateSpec instanceof FixedTemplateSpec ||
          classTemplateSpec instanceof MapTemplateSpec ||
          classTemplateSpec instanceof RecordTemplateSpec ||
          classTemplateSpec instanceof TyperefTemplateSpec ||
          classTemplateSpec instanceof UnionTemplateSpec)
      {
        result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()));
      }
      else if (classTemplateSpec instanceof EnumTemplateSpec)
      {
        result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()), ClassType.ENUM);
      }
      else
      {
        throw new RuntimeException();
      }

      _definedClasses.put(classTemplateSpec, result);
    }

    return result;
  }

  protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)
      throws JClassAlreadyExistsException
  {
    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());
    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());

    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))
    {
      arrayClass._extends(_directArrayBaseClass.narrow(itemJClass));
    }
    else
    {
      extendWrappingArrayBaseClass(itemJClass, arrayClass);
    }

    
    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));
    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);

    generateConstructorWithNoArg(arrayClass, _dataListClass);
    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);
    generateConstructorWithCollection(arrayClass, itemJClass);
    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);

    if (_pathSpecMethods)
    {
      generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, "items");
    }

    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());

    if (_copierMethods)
    {
      generateCopierMethods(arrayClass);
    }
  }

  protected void extendWrappingArrayBaseClass(JClass itemJClass, JDefinedClass arrayClass)
  {
    arrayClass._extends(_wrappingArrayBaseClass.narrow(itemJClass));
  }

  protected void generateEnum(JDefinedClass enumClass, EnumTemplateSpec enumSpec)
  {
    enumClass.javadoc().append(enumSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), enumClass);

    generateSchemaField(enumClass, enumSpec.getSchema());

    for (String value : enumSpec.getSchema().getSymbols())
    {
      if (isReserved(value))
      {
        throw new IllegalArgumentException("Enum contains Java reserved symbol: " + value + " schema: " + enumSpec.getSchema());
      }

      final JEnumConstant enumConstant = enumClass.enumConstant(value);

      final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);

      if (enumConstantDoc != null)
      {
        enumConstant.javadoc().append(enumConstantDoc);
      }

      setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);
    }
    enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);
  }

  protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)
  {
    fixedClass.javadoc().append(fixedSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(fixedSpec.getSchema(), fixedClass);

    fixedClass._extends(FixedTemplate.class);

    final JVar schemaField = generateSchemaField(fixedClass, fixedSpec.getSchema());

    final JMethod bytesConstructor = fixedClass.constructor(JMod.PUBLIC);
    final JVar param = bytesConstructor.param(ByteString.class, "value");
    bytesConstructor.body().invoke(SUPER).arg(param).arg(schemaField);

    generateConstructorWithObjectArg(fixedClass, schemaField);

    if (_copierMethods)
    {
      generateCopierMethods(fixedClass);
    }
  }

  protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)
      throws JClassAlreadyExistsException
  {
    final JClass valueJClass = generate(mapSpec.getValueClass());
    final JClass dataJClass = generate(mapSpec.getValueDataClass());

    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))
    {
      mapClass._extends(_directMapBaseClass.narrow(valueJClass));
    }
    else
    {
      extendWrappingMapBaseClass(valueJClass, mapClass);
    }

    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));
    final JVar schemaField = generateSchemaField(mapClass, bareSchema);

    generateConstructorWithNoArg(mapClass, _dataMapClass);
    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);
    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);
    generateConstructorWithMap(mapClass, valueJClass);
    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);

    if (_pathSpecMethods)
    {
      generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, "values");
    }

    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());

    if (_copierMethods)
    {
      generateCopierMethods(mapClass);
    }
  }

  protected void extendWrappingMapBaseClass(JClass valueJClass, JDefinedClass mapClass)
  {
    mapClass._extends(_wrappingMapBaseClass.narrow(valueJClass));
  }

  private JClass generatePrimitive(PrimitiveTemplateSpec primitiveSpec)
  {
    switch (primitiveSpec.getSchema().getType())
    {
      case INT:
        return getCodeModel().INT.boxify();

      case DOUBLE:
        return getCodeModel().DOUBLE.boxify();

      case BOOLEAN:
        return getCodeModel().BOOLEAN.boxify();

      case STRING:
        return _stringClass;

      case LONG:
        return getCodeModel().LONG.boxify();

      case FLOAT:
        return getCodeModel().FLOAT.boxify();

      case BYTES:
        return _byteStringClass;

      default:
        throw new RuntimeException("Not supported primitive: " + primitiveSpec);
    }
  }

  protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)
      throws JClassAlreadyExistsException
  {
    templateClass.javadoc().append(recordSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);

    extendRecordBaseClass(templateClass);

    if (_pathSpecMethods)
    {
      generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);
    }

    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());
    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);
    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);

    for (RecordTemplateSpec.Field field : recordSpec.getFields())
    {
      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);

      if (field.getCustomInfo() != null)
      {
        generateCustomClassInitialization(templateClass, field.getCustomInfo());
      }
    }

    if (_copierMethods)
    {
      generateCopierMethods(templateClass);
    }
  }

  protected void extendRecordBaseClass(JDefinedClass templateClass)
  {
    templateClass._extends(_recordBaseClass);
  }

  private void generatePathSpecMethodsForRecord(List<RecordTemplateSpec.Field> fieldSpecs, JDefinedClass templateClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(templateClass);

    for (RecordTemplateSpec.Field field : fieldSpecs)
    {
      JClass fieldsRefType = _pathSpecClass;
      if (hasNestedFields(field.getSchemaField().getType()))
      {
        final JClass fieldType = generate(field.getType());
        fieldsRefType = getCodeModel().ref(fieldType.fullName() + ".Fields");
      }

      final JMethod constantField = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, escapeReserved(field.getSchemaField().getName()));
      constantField.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke("getPathComponents")).arg(field.getSchemaField().getName()));
      if (!field.getSchemaField().getDoc().isEmpty())
      {
        constantField.javadoc().append(field.getSchemaField().getDoc());
      }
      setDeprecatedAnnotationAndJavadoc(constantField, field.getSchemaField());
    }

    final JVar staticFields = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, fieldsNestedClass, "_fields").init(JExpr._new(fieldsNestedClass));
    final JMethod staticFieldsAccessor = templateClass.method(JMod.PUBLIC | JMod.STATIC, fieldsNestedClass, "fields");
    staticFieldsAccessor.body()._return(staticFields);
  }

  private void generateRecordFieldAccessors(JDefinedClass templateClass, RecordTemplateSpec.Field field, JClass type, JVar schemaFieldVar)
  {
    final RecordDataSchema.Field schemaField = field.getSchemaField();
    final DataSchema fieldSchema = schemaField.getType();
    final boolean isDirect = CodeUtil.isDirectType(fieldSchema);
    final String wrappedOrDirect;
    if (isDirect)
    {
      wrappedOrDirect = (field.getCustomInfo() == null ? "Direct" : "CustomType");
    }
    else
    {
      wrappedOrDirect = "Wrapped";
    }
    final String capitalizedName = CodeUtil.capitalize(schemaField.getName());

    final String fieldFieldName = "FIELD_" + capitalizedName;
    final JFieldVar fieldField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, RecordDataSchema.Field.class, fieldFieldName);
    fieldField.init(schemaFieldVar.invoke("getField").arg(schemaField.getName()));

    
    final JMethod has = templateClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, "has" + capitalizedName);
    addAccessorDoc(has, schemaField, "Existence checker");
    setDeprecatedAnnotationAndJavadoc(has, schemaField);
    final JBlock hasBody = has.body();
    JExpression res = JExpr.invoke("contains").arg(fieldField);
    hasBody._return(res);

    if (_recordFieldRemove)
    {
      
      final String removeName = "remove" + capitalizedName;
      final JMethod remove = templateClass.method(JMod.PUBLIC, getCodeModel().VOID, removeName);
      addAccessorDoc(remove, schemaField, "Remover");
      setDeprecatedAnnotationAndJavadoc(remove, schemaField);
      final JBlock removeBody = remove.body();
      removeBody.invoke("remove").arg(fieldField);
    }

    final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);

    if (_recordFieldAccessorWithMode)
    {
      
      final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);
      addAccessorDoc(getterWithMode, schemaField, "Getter");
      setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);
      JVar modeParam = getterWithMode.param(_getModeClass, "mode");
      final JBlock getterWithModeBody = getterWithMode.body();
      res = JExpr.invoke("obtain" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(modeParam);
      getterWithModeBody._return(res);
    }

    
    final JMethod getterWithoutMode = templateClass.method(JMod.PUBLIC, type, getterName);
    addAccessorDoc(getterWithoutMode, schemaField, "Getter");
    setDeprecatedAnnotationAndJavadoc(getterWithoutMode, schemaField);
    final JBlock getterWithoutModeBody = getterWithoutMode.body();
    res = JExpr.invoke("obtain" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(_strictGetMode);
    getterWithoutModeBody._return(res);

    
    final JClass dataClass = generate(field.getDataClass());
    final String setterName = "set" + capitalizedName;

    if (_recordFieldAccessorWithMode)
    {
      
      final JMethod setterWithMode = templateClass.method(JMod.PUBLIC, templateClass, setterName);
      addAccessorDoc(setterWithMode, schemaField, "Setter");
      setDeprecatedAnnotationAndJavadoc(setterWithMode, schemaField);
      JVar param = setterWithMode.param(type, "value");
      JVar modeParam = setterWithMode.param(_setModeClass, "mode");
      JInvocation inv = setterWithMode.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
      dataClassArg(inv, dataClass).arg(param).arg(modeParam);
      setterWithMode.body()._return(JExpr._this());
    }

    
    final JMethod setter = templateClass.method(JMod.PUBLIC, templateClass, setterName);
    addAccessorDoc(setter, schemaField, "Setter");
    setDeprecatedAnnotationAndJavadoc(setter, schemaField);
    JVar param = setter.param(type, "value");
    JInvocation inv = setter.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
    dataClassArg(inv, dataClass).arg(param).arg(_disallowNullSetMode);
    setter.body()._return(JExpr._this());

    
    if (!type.unboxify().equals(type))
    {
      final JMethod unboxifySetter = templateClass.method(JMod.PUBLIC, templateClass, setterName);
      addAccessorDoc(unboxifySetter, schemaField, "Setter");
      setDeprecatedAnnotationAndJavadoc(unboxifySetter, schemaField);
      param = unboxifySetter.param(type.unboxify(), "value");
      inv = unboxifySetter.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
      dataClassArg(inv, dataClass).arg(param).arg(_disallowNullSetMode);
      unboxifySetter.body()._return(JExpr._this());
    }
  }

  protected void generateTyperef(JDefinedClass typerefClass, TyperefTemplateSpec typerefSpec)
  {
    typerefClass.javadoc().append(typerefSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(typerefSpec.getSchema(), typerefClass);

    typerefClass._extends(TyperefInfo.class);

    final JVar schemaField = generateSchemaField(typerefClass, typerefSpec.getSchema());

    final JMethod constructor = typerefClass.constructor(JMod.PUBLIC);
    constructor.body().invoke(SUPER).arg(schemaField);
  }

  protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)
      throws JClassAlreadyExistsException
  {
    extendUnionBaseClass(unionClass);

    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());

    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);
    generateConstructorWithObjectArg(unionClass, schemaField);

    for (UnionTemplateSpec.Member member : unionSpec.getMembers())
    {
      if (member.getClassTemplateSpec() != null)
      {
        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);
      }
    }

    if (_pathSpecMethods)
    {
      generatePathSpecMethodsForUnion(unionSpec, unionClass);
    }

    if (_copierMethods)
    {
      generateCopierMethods(unionClass);
    }

    if (unionSpec.getTyperefClass() != null)
    {
      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();
      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));
      generateTyperef(typerefInfoClass, typerefClassSpec);

      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);
      typerefInfoField.init(JExpr._new(typerefInfoClass));

      unionClass._implements(HasTyperefInfo.class);
      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, "typerefInfo");
      typerefInfoMethod.body()._return(typerefInfoField);
    }
  }

  protected void extendUnionBaseClass(JDefinedClass unionClass)
  {
    unionClass._extends(_unionBaseClass);
  }

  private void generateUnionMemberAccessors(JDefinedClass unionClass, DataSchema memberType, JClass memberClass, JClass dataClass, JVar schemaField)
  {
    final boolean isDirect = CodeUtil.isDirectType(memberType);
    final String wrappedOrDirect = isDirect ? "Direct" : "Wrapped";
    final String memberKey = memberType.getUnionMemberKey();
    final String capitalizedName = CodeUtil.getUnionMemberName(memberType);

    final String memberFieldName = "MEMBER_" + capitalizedName;
    final JFieldVar memberField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, DataSchema.class, memberFieldName);
    memberField.init(schemaField.invoke("getType").arg(memberKey));
    final String setterName = "set" + capitalizedName;

    

    final JMethod createMethod = unionClass.method(JMod.PUBLIC | JMod.STATIC, unionClass, "create");
    JVar param = createMethod.param(memberClass, "value");
    final JVar newUnionVar = createMethod.body().decl(unionClass, "newUnion", JExpr._new(unionClass));
    createMethod.body().invoke(newUnionVar, setterName).arg(param);
    createMethod.body()._return(newUnionVar);

    

    final JMethod is = unionClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, "is" + capitalizedName);
    final JBlock isBody = is.body();
    JExpression res = JExpr.invoke("memberIs").arg(memberKey);
    isBody._return(res);

    

    final String getterName = "get" + capitalizedName;
    final JMethod getter = unionClass.method(JMod.PUBLIC, memberClass, getterName);
    final JBlock getterBody = getter.body();
    res = JExpr.invoke("obtain" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass)).arg(memberKey);
    getterBody._return(res);

    

    final JMethod setter = unionClass.method(JMod.PUBLIC, Void.TYPE, setterName);
    param = setter.param(memberClass, "value");
    final JInvocation inv = setter.body().invoke("select" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass));
    dataClassArg(inv, dataClass).arg(memberKey).arg(param);
  }

  private void generatePathSpecMethodsForUnion(UnionTemplateSpec unionSpec, JDefinedClass unionClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(unionClass);

    for (UnionTemplateSpec.Member member : unionSpec.getMembers())
    {
      JClass fieldsRefType = _pathSpecClass;
      if (hasNestedFields(member.getSchema()))
      {
        final JClass unionMemberClass = generate(member.getClassTemplateSpec());
        fieldsRefType = getCodeModel().ref(unionMemberClass.fullName() + ".Fields");
      }
      final JMethod accessorMethod = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, CodeUtil.getUnionMemberName(member.getSchema()));
      accessorMethod.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke("getPathComponents")).arg(member.getSchema().getUnionMemberKey()));
    }
  }

  private void populateClassContent(ClassTemplateSpec classTemplateSpec, JDefinedClass definedClass)
      throws JClassAlreadyExistsException
  {
    if (!_generatedClasses.containsKey(definedClass))
    {
      _generatedClasses.put(definedClass, classTemplateSpec);

      JavaCodeUtil.annotate(definedClass, "Data Template", classTemplateSpec.getLocation());

      if (classTemplateSpec instanceof ArrayTemplateSpec)
      {
        generateArray(definedClass, (ArrayTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof EnumTemplateSpec)
      {
        generateEnum(definedClass, (EnumTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof FixedTemplateSpec)
      {
        generateFixed(definedClass, (FixedTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof MapTemplateSpec)
      {
        generateMap(definedClass, (MapTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof RecordTemplateSpec)
      {
        generateRecord(definedClass, (RecordTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof TyperefTemplateSpec)
      {
        generateTyperef(definedClass, (TyperefTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof UnionTemplateSpec)
      {
        generateUnion(definedClass, (UnionTemplateSpec) classTemplateSpec);
      }
      else
      {
        throw new RuntimeException();
      }
    }
  }

  private JFieldVar generateSchemaField(JDefinedClass templateClass, DataSchema schema)
  {
    final JFieldVar schemaField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, schema.getClass(), DataTemplateUtil.SCHEMA_FIELD_NAME);
    final String schemaJson = SchemaToJsonEncoder.schemaToJson(schema, JsonBuilder.Pretty.COMPACT);
    final JInvocation parseSchemaInvocation;
    if (schemaJson.length() < MAX_SCHEMA_FIELD_JSON_LENGTH)
    {
      parseSchemaInvocation = _dataTemplateUtilClass.staticInvoke("parseSchema").arg(schemaJson);
    }
    else
    {
      JInvocation stringBuilderInvocation = JExpr._new(_stringBuilderClass);
      for (int index = 0; index < schemaJson.length(); index += MAX_SCHEMA_FIELD_JSON_LENGTH)
      {
        stringBuilderInvocation = stringBuilderInvocation.
            invoke("append").
            arg(schemaJson.substring(index, Math.min(schemaJson.length(), index + MAX_SCHEMA_FIELD_JSON_LENGTH)));
      }
      stringBuilderInvocation = stringBuilderInvocation.invoke("toString");
      parseSchemaInvocation = _dataTemplateUtilClass.staticInvoke("parseSchema").arg(stringBuilderInvocation);
    }
    schemaField.init(JExpr.cast(getCodeModel()._ref(schema.getClass()), parseSchemaInvocation));

    return schemaField;
  }

  private void generatePathSpecMethodsForCollection(JDefinedClass templateClass, DataSchema schema, JClass childClass, String wildcardMethodName)
      throws JClassAlreadyExistsException
  {
    if (hasNestedFields(schema))
    {
      final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(templateClass);

      final JClass itemsFieldType = getCodeModel().ref(childClass.fullName() + ".Fields");

      final JMethod constantField = fieldsNestedClass.method(JMod.PUBLIC, itemsFieldType, wildcardMethodName);
      constantField.body()._return(JExpr._new(itemsFieldType).arg(JExpr.invoke("getPathComponents")).arg(_pathSpecClass.staticRef("WILDCARD")));
    }
  }

  private JDefinedClass generatePathSpecNestedClass(JDefinedClass templateClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = templateClass._class(JMod.PUBLIC | JMod.STATIC, "Fields");
    fieldsNestedClass._extends(_pathSpecClass);

    final JMethod constructor = fieldsNestedClass.constructor(JMod.PUBLIC);
    final JClass listString = getCodeModel().ref(List.class).narrow(String.class);
    final JVar namespace = constructor.param(listString, "path");
    final JVar name = constructor.param(String.class, "name");
    constructor.body().invoke(SUPER).arg(namespace).arg(name);

    fieldsNestedClass.constructor(JMod.PUBLIC).body().invoke(SUPER);
    return fieldsNestedClass;
  }

  
  private void generateCustomClassInitialization(JDefinedClass templateClass, CustomInfoSpec customInfo)
  {
    if (customInfo != null)
    {
      
      final String customClassFullName = customInfo.getCustomClass().getNamespace() + "." + customInfo.getCustomClass().getClassName();
      templateClass.init().add(_customClass.staticInvoke("initializeCustomClass").arg(getCodeModel().ref(customClassFullName).dotclass()));

      
      if (customInfo.getCoercerClass() != null)
      {
        final String coercerClassFullName = customInfo.getCoercerClass().getNamespace() + "." + customInfo.getCoercerClass().getClassName();
        templateClass.init().add(_customClass.staticInvoke("initializeCoercerClass").arg(getCodeModel().ref(coercerClassFullName).dotclass()));
      }
    }
  }

  private void generateConstructorWithInitialCapacity(JDefinedClass cls, JClass elementClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar initialCapacity = argConstructor.param(getCodeModel().INT, "initialCapacity");
    argConstructor.body().invoke(THIS).arg(JExpr._new(elementClass).arg(initialCapacity));
  }

  private void generateConstructorWithCollection(JDefinedClass cls, JClass elementClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar c = argConstructor.param(_collectionClass.narrow(elementClass), "c");
    argConstructor.body().invoke(THIS).arg(JExpr._new(_dataListClass).arg(c.invoke("size")));
    argConstructor.body().invoke("addAll").arg(c);
  }

  private void generateConstructorWithInitialCapacityAndLoadFactor(JDefinedClass cls)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar initialCapacity = argConstructor.param(getCodeModel().INT, "initialCapacity");
    final JVar loadFactor = argConstructor.param(getCodeModel().FLOAT, "loadFactor");
    argConstructor.body().invoke(THIS).arg(JExpr._new(_dataMapClass).arg(initialCapacity).arg(loadFactor));
  }

  private void generateConstructorWithMap(JDefinedClass cls, JClass valueClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar m = argConstructor.param(_mapClass.narrow(_stringClass, valueClass), "m");
    argConstructor.body().invoke(THIS).arg(JExpr.invoke("newDataMapOfSize").arg(m.invoke("size")));
    argConstructor.body().invoke("putAll").arg(m);
  }

  public static class Config
  {
    private String _defaultPackage;
    private boolean _recordFieldAccessorWithMode;
    private boolean _recordFieldRemove;
    private boolean _pathSpecMethods;
    private boolean _copierMethods;

    public Config()
    {
      _defaultPackage = null;
      _recordFieldAccessorWithMode = true;
      _recordFieldRemove = true;
      _pathSpecMethods = true;
      _copierMethods = true;
    }

    public void setDefaultPackage(String defaultPackage)
    {
      _defaultPackage = defaultPackage;
    }

    public String getDefaultPackage()
    {
      return _defaultPackage;
    }

    public void setRecordFieldAccessorWithMode(boolean recordFieldAccessorWithMode)
    {
      _recordFieldAccessorWithMode = recordFieldAccessorWithMode;
    }

    public boolean getRecordFieldAccessorWithMode()
    {
      return _recordFieldAccessorWithMode;
    }

    public void setRecordFieldRemove(boolean recordFieldRemove)
    {
      _recordFieldRemove = recordFieldRemove;
    }

    public boolean getRecordFieldRemove()
    {
      return _recordFieldRemove;
    }

    public void setPathSpecMethods(boolean pathSpecMethods)
    {
      _pathSpecMethods = pathSpecMethods;
    }

    public boolean getPathSpecMethods()
    {
      return _pathSpecMethods;
    }

    public void setCopierMethods(boolean copierMethods)
    {
      _copierMethods = copierMethods;
    }

    public boolean getCopierMethods()
    {
      return _copierMethods;
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataList;
import com.linkedin.data.DataMap;
import com.linkedin.data.schema.PathSpec;
import com.linkedin.data.template.Custom;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.DirectArrayTemplate;
import com.linkedin.data.template.DirectMapTemplate;
import com.linkedin.data.template.GetMode;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.data.template.SetMode;
import com.linkedin.data.template.UnionTemplate;
import com.linkedin.data.template.WrappingArrayTemplate;
import com.linkedin.data.template.WrappingMapTemplate;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.sun.codemodel.JClass;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JFieldRef;
import com.sun.codemodel.JPackage;



public class JavaCodeGeneratorBase
{
  
  public static final String GENERATOR_DEFAULT_PACKAGE = "generator.default.package";

  protected static final String SUPER = "super";
  protected static final String THIS = "this";

  private static final Set<String> _reserved = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(
      "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class",
      "const", "continue", "default", "do", "double", "else", "enum", "extends", "final",
      "finally", "float", "for", "goto", "if", "implements", "import", "instanceof", "int",
      "interface", "long", "native", "new", "null", "package", "private", "protected", "public",
      "return", "short", "static", "strictfp", "super", "switch", "synchronized",
      "this", "throw", "throws", "transient", "try", "void", "volatile", "while"
  )));

  
  protected final JClass _byteStringClass;
  protected final JClass _collectionClass;
  protected final JClass _customClass;
  protected final JClass _dataListClass;
  protected final JClass _dataMapClass;
  protected final JClass _dataTemplateUtilClass;
  protected final JClass _directArrayClass;
  protected final JClass _directMapClass;
  protected final JClass _getModeClass;
  protected final JClass _mapClass;
  protected final JClass _pathSpecClass;
  protected final JClass _setModeClass;
  protected final JClass _stringBuilderClass;
  protected final JClass _stringClass;

  protected final JClass _recordClass;
  protected final JClass _unionClass;
  protected final JClass _wrappingArrayClass;
  protected final JClass _wrappingMapClass;

  protected final JFieldRef _disallowNullSetMode;
  protected final JFieldRef _strictGetMode;
  
  private final JCodeModel _codeModel = new JCodeModel();
  
  private JPackage _package;

  public JavaCodeGeneratorBase(String defaultPackage)
  {
    _byteStringClass = getCodeModel().ref(ByteString.class);
    _collectionClass = getCodeModel().ref(Collection.class);
    _customClass = getCodeModel().ref(Custom.class);
    _dataListClass = getCodeModel().ref(DataList.class);
    _dataMapClass = getCodeModel().ref(DataMap.class);
    _dataTemplateUtilClass = getCodeModel().ref(DataTemplateUtil.class);
    _directArrayClass = getCodeModel().ref(DirectArrayTemplate.class);
    _directMapClass = getCodeModel().ref(DirectMapTemplate.class);
    _getModeClass = getCodeModel().ref(GetMode.class);
    _mapClass = getCodeModel().ref(Map.class);
    _pathSpecClass = getCodeModel().ref(PathSpec.class);
    _setModeClass = getCodeModel().ref(SetMode.class);
    _stringBuilderClass = getCodeModel().ref(StringBuilder.class);
    _stringClass = getCodeModel().ref(String.class);

    _recordClass = getRecordClass();
    _unionClass = getUnionClass();
    _wrappingArrayClass = getWrappingArrayClass();
    _wrappingMapClass = getWrappingMapClass();

    _disallowNullSetMode = getCodeModel().ref(SetMode.class).staticRef("DISALLOW_NULL");
    _strictGetMode = getCodeModel().ref(GetMode.class).staticRef("STRICT");

    _package = getCodeModel()._package(defaultPackage == null ? "" : defaultPackage);
  }

  protected JClass getRecordClass()
  {
    return getCodeModel().ref(RecordTemplate.class);
  }

  protected JClass getUnionClass()
  {
    return getCodeModel().ref(UnionTemplate.class);
  }

  protected JClass getWrappingArrayClass()
  {
    return getCodeModel().ref(WrappingArrayTemplate.class);
  }

  protected JClass getWrappingMapClass()
  {
    return getCodeModel().ref(WrappingMapTemplate.class);
  }

  protected static boolean isReserved(String name)
  {
    return _reserved.contains(name);
  }

  protected static String escapeReserved(String name)
  {
    if (_reserved.contains(name))
    {
      return name + '_';
    }
    return name;
  }

  
  public JCodeModel getCodeModel()
  {
    return _codeModel;
  }

  protected JPackage getPackage()
  {
    return _package;
  }

  protected JPackage getPackage(String namespace)
  {
    return namespace.isEmpty() ? getPackage() : _codeModel._package(namespace);
  }
}

<code block>


package com.linkedin.pegasus.generator;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataMap;
import com.linkedin.data.schema.ArrayDataSchema;
import com.linkedin.data.schema.DataSchema;
import com.linkedin.data.schema.EnumDataSchema;
import com.linkedin.data.schema.JsonBuilder;
import com.linkedin.data.schema.MapDataSchema;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.schema.SchemaToJsonEncoder;
import com.linkedin.data.template.BooleanArray;
import com.linkedin.data.template.BooleanMap;
import com.linkedin.data.template.BytesArray;
import com.linkedin.data.template.BytesMap;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.DoubleArray;
import com.linkedin.data.template.DoubleMap;
import com.linkedin.data.template.FixedTemplate;
import com.linkedin.data.template.FloatArray;
import com.linkedin.data.template.FloatMap;
import com.linkedin.data.template.HasTyperefInfo;
import com.linkedin.data.template.IntegerArray;
import com.linkedin.data.template.IntegerMap;
import com.linkedin.data.template.LongArray;
import com.linkedin.data.template.LongMap;
import com.linkedin.data.template.StringArray;
import com.linkedin.data.template.StringMap;
import com.linkedin.data.template.TyperefInfo;
import com.linkedin.pegasus.generator.spec.ArrayTemplateSpec;
import com.linkedin.pegasus.generator.spec.ClassTemplateSpec;
import com.linkedin.pegasus.generator.spec.CustomInfoSpec;
import com.linkedin.pegasus.generator.spec.EnumTemplateSpec;
import com.linkedin.pegasus.generator.spec.FixedTemplateSpec;
import com.linkedin.pegasus.generator.spec.MapTemplateSpec;
import com.linkedin.pegasus.generator.spec.ModifierSpec;
import com.linkedin.pegasus.generator.spec.PrimitiveTemplateSpec;
import com.linkedin.pegasus.generator.spec.RecordTemplateSpec;
import com.linkedin.pegasus.generator.spec.TyperefTemplateSpec;
import com.linkedin.pegasus.generator.spec.UnionTemplateSpec;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sun.codemodel.ClassType;
import com.sun.codemodel.JAnnotatable;
import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JClassContainer;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JDocCommentable;
import com.sun.codemodel.JEnumConstant;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JInvocation;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JVar;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class JavaDataTemplateGenerator extends JavaCodeGeneratorBase
{
  
  public static final Map<DataSchema, Class<?>> PredefinedJavaClasses;
  static
  {
    final Class<?>[] predefinedClass = new Class<?>[] {
        BooleanArray.class,
        BooleanMap.class,
        BytesArray.class,
        BytesMap.class,
        DoubleArray.class,
        DoubleMap.class,
        FloatArray.class,
        FloatMap.class,
        IntegerArray.class,
        IntegerMap.class,
        LongArray.class,
        LongMap.class,
        StringArray.class,
        StringMap.class
    };

    PredefinedJavaClasses = new HashMap<DataSchema, Class<?>>();

    for (Class<?> clazz : predefinedClass)
    {
      final DataSchema schema = DataTemplateUtil.getSchema(clazz);
      PredefinedJavaClasses.put(schema, clazz);
    }
  }

  private static final int MAX_SCHEMA_FIELD_JSON_LENGTH = 32000;
  private static final Logger _log = LoggerFactory.getLogger(JavaDataTemplateGenerator.class);
  
  
  
  private static final String DEPRECATED_KEY = "deprecated";
  private static final String DEPRECATED_SYMBOLS_KEY = "deprecatedSymbols";

  private final Map<ClassTemplateSpec, JDefinedClass> _definedClasses = new HashMap<ClassTemplateSpec, JDefinedClass>();
  private final Map<JDefinedClass, ClassTemplateSpec> _generatedClasses = new HashMap<JDefinedClass, ClassTemplateSpec>();

  private final boolean _recordFieldAccessorWithMode;

  private JavaDataTemplateGenerator(String defaultPackage,
                                    boolean recordFieldAccessorWithMode)
  {
    super(defaultPackage);

    _recordFieldAccessorWithMode = recordFieldAccessorWithMode;
  }

  public JavaDataTemplateGenerator(Config config)
  {
    this(config.getDefaultPackage(),
         config.getRecordFieldAccessorWithMode());
  }

  
  public JavaDataTemplateGenerator(String defaultPackage)
  {
    this(defaultPackage, true);
  }

  public Map<JDefinedClass, ClassTemplateSpec> getGeneratedClasses()
  {
    return _generatedClasses;
  }

  public JClass generate(ClassTemplateSpec classTemplateSpec)
  {
    final JClass result;

    if (classTemplateSpec == null)
    {
      result = null;
    }
    else
    {
      if (classTemplateSpec.getSchema() == null)
      {
        result = getCodeModel().directClass(classTemplateSpec.getFullName());
      }
      else if (PredefinedJavaClasses.containsKey(classTemplateSpec.getSchema()))
      {
        final Class<?> nativeJavaClass = PredefinedJavaClasses.get(classTemplateSpec.getSchema());
        result = getCodeModel().ref(nativeJavaClass);
      }
      else if (classTemplateSpec.getSchema().isPrimitive())
      {
        result = generatePrimitive((PrimitiveTemplateSpec) classTemplateSpec);
      }
      else
      {
        try
        {
          final JDefinedClass definedClass = defineClass(classTemplateSpec);
          populateClassContent(classTemplateSpec, definedClass);
          result = definedClass;
        }
        catch (JClassAlreadyExistsException e)
        {
          throw new IllegalArgumentException(classTemplateSpec.getFullName());
        }
      }
    }

    return result;
  }

  private static JInvocation dataClassArg(JInvocation inv, JClass dataClass)
  {
    if (dataClass != null)
    {
      inv.arg(JExpr.dotclass(dataClass));
    }
    return inv;
  }

  private static void generateCopierMethods(JDefinedClass templateClass)
  {
    overrideCopierMethod(templateClass, "clone");
    overrideCopierMethod(templateClass, "copy");
  }

  private static boolean hasNestedFields(DataSchema schema)
  {
    while (true)
    {
      switch (schema.getDereferencedType())
      {
        case RECORD:
          return true;
        case UNION:
          return true;
        case ARRAY:
          schema = ((ArrayDataSchema) schema.getDereferencedDataSchema()).getItems();
          continue;
        case MAP:
          schema = ((MapDataSchema) schema.getDereferencedDataSchema()).getValues();
          continue;
        default:
          return false;
      }
    }
  }

  private static void generateConstructorWithNoArg(JDefinedClass cls, JVar schemaField, JClass newClass)
  {
    final JMethod noArgConstructor = cls.constructor(JMod.PUBLIC);
    noArgConstructor.body().invoke(SUPER).arg(JExpr._new(newClass)).arg(schemaField);
  }

  private static void generateConstructorWithNoArg(JDefinedClass cls, JClass newClass)
  {
    final JMethod noArgConstructor = cls.constructor(JMod.PUBLIC);
    noArgConstructor.body().invoke(THIS).arg(JExpr._new(newClass));
  }

  private static void generateConstructorWithObjectArg(JDefinedClass cls, JVar schemaField)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(Object.class, "data");
    argConstructor.body().invoke(SUPER).arg(param).arg(schemaField);
  }

  private static void generateConstructorWithArg(JDefinedClass cls, JVar schemaField, JClass paramClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(paramClass, "data");
    argConstructor.body().invoke(SUPER).arg(param).arg(schemaField);
  }

  private static void generateConstructorWithArg(JDefinedClass cls, JVar schemaField, JClass paramClass, JClass elementClass, JClass dataClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar param = argConstructor.param(paramClass, "data");
    final JInvocation inv = argConstructor.body().invoke(SUPER).arg(param).arg(schemaField).arg(JExpr.dotclass(elementClass));
    dataClassArg(inv, dataClass);
  }

  
  private static DataSchema schemaForArrayItemsOrMapValues(CustomInfoSpec customInfo, DataSchema schema)
  {
    return customInfo != null ? customInfo.getCustomSchema() : schema.getDereferencedDataSchema();
  }

  private static void overrideCopierMethod(JDefinedClass templateClass, String methodName)
  {
    final JMethod copierMethod = templateClass.method(JMod.PUBLIC, templateClass, methodName);
    copierMethod.annotate(Override.class);
    copierMethod._throws(CloneNotSupportedException.class);
    copierMethod.body()._return(JExpr.cast(templateClass, JExpr._super().invoke(methodName)));
  }

  private static void setDeprecatedAnnotationAndJavadoc(DataSchema schema, JDefinedClass schemaClass)
  {
    setDeprecatedAnnotationAndJavadoc(schema.getProperties().get(DEPRECATED_KEY), schemaClass, schemaClass);
  }

  private static void setDeprecatedAnnotationAndJavadoc(JMethod method, RecordDataSchema.Field field)
  {
    setDeprecatedAnnotationAndJavadoc(field.getProperties().get(DEPRECATED_KEY), method, method);
  }

  private static void setDeprecatedAnnotationAndJavadoc(EnumDataSchema enumSchema, String symbol, JEnumConstant constant)
  {
    final Object deprecatedSymbolsProp = enumSchema.getProperties().get(DEPRECATED_SYMBOLS_KEY);
    if (deprecatedSymbolsProp instanceof DataMap)
    {
      final DataMap deprecatedSymbols = (DataMap) deprecatedSymbolsProp;

      final Object deprecatedProp = deprecatedSymbols.get(symbol);
      setDeprecatedAnnotationAndJavadoc(deprecatedProp, constant, constant);
    }
  }

  private static void setDeprecatedAnnotationAndJavadoc(Object deprecatedProp, JAnnotatable annotatable, JDocCommentable commentable)
  {
    if (Boolean.TRUE.equals(deprecatedProp) && annotatable != null)
    {
      annotatable.annotate(Deprecated.class);
    }
    else if (deprecatedProp instanceof String)
    {
      if (commentable != null)
      {
        final String deprecatedReason = (String) deprecatedProp;
        commentable.javadoc().addDeprecated().append(deprecatedReason);
      }
      if (annotatable != null)
      {
        annotatable.annotate(Deprecated.class);
      }
    }
  }

  private static int getJModValue(Set<ModifierSpec> modifiers)
  {
    try
    {
      int value = 0;
      for (ModifierSpec mod : modifiers)
      {
        value |= JMod.class.getDeclaredField(mod.name()).getInt(null);
      }
      return value;
    }
    catch (NoSuchFieldException e)
    {
      throw new RuntimeException(e);
    }
    catch (IllegalAccessException e)
    {
      throw new RuntimeException(e);
    }
  }

  private static void addAccessorDoc(JMethod method, RecordDataSchema.Field field, String prefix)
  {
    method.javadoc().append(prefix + " for " + field.getName());
    method.javadoc().addXdoclet("see Fields#" + escapeReserved(field.getName()));
  }

  private JDefinedClass defineClass(ClassTemplateSpec classTemplateSpec)
      throws JClassAlreadyExistsException
  {
    JDefinedClass result = _definedClasses.get(classTemplateSpec);
    if (result == null)
    {
      final int jmodValue = getJModValue(classTemplateSpec.getModifiers());
      final JClassContainer container;
      if (classTemplateSpec.getEnclosingClass() == null)
      {
        container = getPackage(classTemplateSpec.getNamespace());
      }
      else
      {
        container = defineClass(classTemplateSpec.getEnclosingClass());
      }

      if (classTemplateSpec instanceof ArrayTemplateSpec ||
          classTemplateSpec instanceof FixedTemplateSpec ||
          classTemplateSpec instanceof MapTemplateSpec ||
          classTemplateSpec instanceof RecordTemplateSpec ||
          classTemplateSpec instanceof TyperefTemplateSpec ||
          classTemplateSpec instanceof UnionTemplateSpec)
      {
        result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()));
      }
      else if (classTemplateSpec instanceof EnumTemplateSpec)
      {
        result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()), ClassType.ENUM);
      }
      else
      {
        throw new RuntimeException();
      }

      _definedClasses.put(classTemplateSpec, result);
    }

    return result;
  }

  protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)
      throws JClassAlreadyExistsException
  {
    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());
    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());

    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))
    {
      arrayClass._extends(_directArrayClass.narrow(itemJClass));
    }
    else
    {
      arrayClass._extends(_wrappingArrayClass.narrow(itemJClass));
    }

    
    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));
    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);

    generateConstructorWithNoArg(arrayClass, _dataListClass);
    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);
    generateConstructorWithCollection(arrayClass, itemJClass);
    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);

    generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, "items");

    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());

    generateCopierMethods(arrayClass);
  }

  protected void generateEnum(JDefinedClass enumClass, EnumTemplateSpec enumSpec)
  {
    enumClass.javadoc().append(enumSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), enumClass);

    generateSchemaField(enumClass, enumSpec.getSchema());

    for (String value : enumSpec.getSchema().getSymbols())
    {
      if (isReserved(value))
      {
        throw new IllegalArgumentException("Enum contains Java reserved symbol: " + value + " schema: " + enumSpec.getSchema());
      }

      final JEnumConstant enumConstant = enumClass.enumConstant(value);

      final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);

      if (enumConstantDoc != null)
      {
        enumConstant.javadoc().append(enumConstantDoc);
      }

      setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);
    }
    enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);
  }

  protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)
  {
    fixedClass.javadoc().append(fixedSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(fixedSpec.getSchema(), fixedClass);

    fixedClass._extends(FixedTemplate.class);

    final JVar schemaField = generateSchemaField(fixedClass, fixedSpec.getSchema());

    final JMethod bytesConstructor = fixedClass.constructor(JMod.PUBLIC);
    final JVar param = bytesConstructor.param(ByteString.class, "value");
    bytesConstructor.body().invoke(SUPER).arg(param).arg(schemaField);

    generateConstructorWithObjectArg(fixedClass, schemaField);

    generateCopierMethods(fixedClass);
  }

  protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)
      throws JClassAlreadyExistsException
  {
    final JClass valueJClass = generate(mapSpec.getValueClass());
    final JClass dataJClass = generate(mapSpec.getValueDataClass());

    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))
    {
      mapClass._extends(_directMapClass.narrow(valueJClass));
    }
    else
    {
      mapClass._extends(_wrappingMapClass.narrow(valueJClass));
    }

    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));
    final JVar schemaField = generateSchemaField(mapClass, bareSchema);

    generateConstructorWithNoArg(mapClass, _dataMapClass);
    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);
    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);
    generateConstructorWithMap(mapClass, valueJClass);
    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);

    generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, "values");

    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());

    generateCopierMethods(mapClass);
  }

  private JClass generatePrimitive(PrimitiveTemplateSpec primitiveSpec)
  {
    switch (primitiveSpec.getSchema().getType())
    {
      case INT:
        return getCodeModel().INT.boxify();

      case DOUBLE:
        return getCodeModel().DOUBLE.boxify();

      case BOOLEAN:
        return getCodeModel().BOOLEAN.boxify();

      case STRING:
        return _stringClass;

      case LONG:
        return getCodeModel().LONG.boxify();

      case FLOAT:
        return getCodeModel().FLOAT.boxify();

      case BYTES:
        return _byteStringClass;

      default:
        throw new RuntimeException("Not supported primitive: " + primitiveSpec);
    }
  }

  protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)
      throws JClassAlreadyExistsException
  {
    templateClass.javadoc().append(recordSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);

    templateClass._extends(_recordClass);

    generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);

    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());
    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);
    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);

    for (RecordTemplateSpec.Field field : recordSpec.getFields())
    {
      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);

      if (field.getCustomInfo() != null)
      {
        generateCustomClassInitialization(templateClass, field.getCustomInfo());
      }
    }

    generateCopierMethods(templateClass);
  }

  private void generatePathSpecMethodsForRecord(List<RecordTemplateSpec.Field> fieldSpecs, JDefinedClass templateClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(templateClass);

    for (RecordTemplateSpec.Field field : fieldSpecs)
    {
      JClass fieldsRefType = _pathSpecClass;
      if (hasNestedFields(field.getSchemaField().getType()))
      {
        final JClass fieldType = generate(field.getType());
        fieldsRefType = getCodeModel().ref(fieldType.fullName() + ".Fields");
      }

      final JMethod constantField = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, escapeReserved(field.getSchemaField().getName()));
      constantField.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke("getPathComponents")).arg(field.getSchemaField().getName()));
      if (!field.getSchemaField().getDoc().isEmpty())
      {
        constantField.javadoc().append(field.getSchemaField().getDoc());
      }
      setDeprecatedAnnotationAndJavadoc(constantField, field.getSchemaField());
    }

    final JVar staticFields = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, fieldsNestedClass, "_fields").init(JExpr._new(fieldsNestedClass));
    final JMethod staticFieldsAccessor = templateClass.method(JMod.PUBLIC | JMod.STATIC, fieldsNestedClass, "fields");
    staticFieldsAccessor.body()._return(staticFields);
  }

  private void generateRecordFieldAccessors(JDefinedClass templateClass, RecordTemplateSpec.Field field, JClass type, JVar schemaFieldVar)
  {
    final RecordDataSchema.Field schemaField = field.getSchemaField();
    final DataSchema fieldSchema = schemaField.getType();
    final boolean isDirect = CodeUtil.isDirectType(fieldSchema);
    final String wrappedOrDirect;
    if (isDirect)
    {
      wrappedOrDirect = (field.getCustomInfo() == null ? "Direct" : "CustomType");
    }
    else
    {
      wrappedOrDirect = "Wrapped";
    }
    final String capitalizedName = CodeUtil.capitalize(schemaField.getName());

    final String fieldFieldName = "FIELD_" + capitalizedName;
    final JFieldVar fieldField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, RecordDataSchema.Field.class, fieldFieldName);
    fieldField.init(schemaFieldVar.invoke("getField").arg(schemaField.getName()));

    
    final JMethod has = templateClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, "has" + capitalizedName);
    addAccessorDoc(has, schemaField, "Existence checker");
    setDeprecatedAnnotationAndJavadoc(has, schemaField);
    final JBlock hasBody = has.body();
    JExpression res = JExpr.invoke("contains").arg(fieldField);
    hasBody._return(res);

    
    final String removeName = "remove" + capitalizedName;
    final JMethod remove = templateClass.method(JMod.PUBLIC, getCodeModel().VOID, removeName);
    addAccessorDoc(remove, schemaField, "Remover");
    setDeprecatedAnnotationAndJavadoc(remove, schemaField);
    final JBlock removeBody = remove.body();
    removeBody.invoke("remove").arg(fieldField);

    final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);

    if (_recordFieldAccessorWithMode)
    {
      
      final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);
      addAccessorDoc(getterWithMode, schemaField, "Getter");
      setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);
      JVar modeParam = getterWithMode.param(_getModeClass, "mode");
      final JBlock getterWithModeBody = getterWithMode.body();
      res = JExpr.invoke("obtain" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(modeParam);
      getterWithModeBody._return(res);
    }

    
    final JMethod getterWithoutMode = templateClass.method(JMod.PUBLIC, type, getterName);
    addAccessorDoc(getterWithoutMode, schemaField, "Getter");
    setDeprecatedAnnotationAndJavadoc(getterWithoutMode, schemaField);
    final JBlock getterWithoutModeBody = getterWithoutMode.body();
    res = JExpr.invoke("obtain" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(_strictGetMode);
    getterWithoutModeBody._return(res);

    
    final JClass dataClass = generate(field.getDataClass());
    final String setterName = "set" + capitalizedName;

    if (_recordFieldAccessorWithMode)
    {
      
      final JMethod setterWithMode = templateClass.method(JMod.PUBLIC, templateClass, setterName);
      addAccessorDoc(setterWithMode, schemaField, "Setter");
      setDeprecatedAnnotationAndJavadoc(setterWithMode, schemaField);
      JVar param = setterWithMode.param(type, "value");
      JVar modeParam = setterWithMode.param(_setModeClass, "mode");
      JInvocation inv = setterWithMode.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
      dataClassArg(inv, dataClass).arg(param).arg(modeParam);
      setterWithMode.body()._return(JExpr._this());
    }

    
    final JMethod setter = templateClass.method(JMod.PUBLIC, templateClass, setterName);
    addAccessorDoc(setter, schemaField, "Setter");
    setDeprecatedAnnotationAndJavadoc(setter, schemaField);
    JVar param = setter.param(type, "value");
    JInvocation inv = setter.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
    dataClassArg(inv, dataClass).arg(param).arg(_disallowNullSetMode);
    setter.body()._return(JExpr._this());

    
    if (!type.unboxify().equals(type))
    {
      final JMethod unboxifySetter = templateClass.method(JMod.PUBLIC, templateClass, setterName);
      addAccessorDoc(unboxifySetter, schemaField, "Setter");
      setDeprecatedAnnotationAndJavadoc(unboxifySetter, schemaField);
      param = unboxifySetter.param(type.unboxify(), "value");
      inv = unboxifySetter.body().invoke("put" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));
      dataClassArg(inv, dataClass).arg(param).arg(_disallowNullSetMode);
      unboxifySetter.body()._return(JExpr._this());
    }
  }

  protected void generateTyperef(JDefinedClass typerefClass, TyperefTemplateSpec typerefSpec)
  {
    typerefClass.javadoc().append(typerefSpec.getSchema().getDoc());

    setDeprecatedAnnotationAndJavadoc(typerefSpec.getSchema(), typerefClass);

    typerefClass._extends(TyperefInfo.class);

    final JVar schemaField = generateSchemaField(typerefClass, typerefSpec.getSchema());

    final JMethod constructor = typerefClass.constructor(JMod.PUBLIC);
    constructor.body().invoke(SUPER).arg(schemaField);
  }

  protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)
      throws JClassAlreadyExistsException
  {
    unionClass._extends(getUnionClass());

    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());

    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);
    generateConstructorWithObjectArg(unionClass, schemaField);

    for (UnionTemplateSpec.Member member : unionSpec.getMembers())
    {
      if (member.getClassTemplateSpec() != null)
      {
        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);
      }
    }

    generatePathSpecMethodsForUnion(unionSpec, unionClass);

    generateCopierMethods(unionClass);

    if (unionSpec.getTyperefClass() != null)
    {
      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();
      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));
      generateTyperef(typerefInfoClass, typerefClassSpec);

      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);
      typerefInfoField.init(JExpr._new(typerefInfoClass));

      unionClass._implements(HasTyperefInfo.class);
      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, "typerefInfo");
      typerefInfoMethod.body()._return(typerefInfoField);
    }
  }

  private void generateUnionMemberAccessors(JDefinedClass unionClass, DataSchema memberType, JClass memberClass, JClass dataClass, JVar schemaField)
  {
    final boolean isDirect = CodeUtil.isDirectType(memberType);
    final String wrappedOrDirect = isDirect ? "Direct" : "Wrapped";
    final String memberKey = memberType.getUnionMemberKey();
    final String capitalizedName = CodeUtil.getUnionMemberName(memberType);

    final String memberFieldName = "MEMBER_" + capitalizedName;
    final JFieldVar memberField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, DataSchema.class, memberFieldName);
    memberField.init(schemaField.invoke("getType").arg(memberKey));
    final String setterName = "set" + capitalizedName;

    

    final JMethod createMethod = unionClass.method(JMod.PUBLIC | JMod.STATIC, unionClass, "create");
    JVar param = createMethod.param(memberClass, "value");
    final JVar newUnionVar = createMethod.body().decl(unionClass, "newUnion", JExpr._new(unionClass));
    createMethod.body().invoke(newUnionVar, setterName).arg(param);
    createMethod.body()._return(newUnionVar);

    

    final JMethod is = unionClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, "is" + capitalizedName);
    final JBlock isBody = is.body();
    JExpression res = JExpr.invoke("memberIs").arg(memberKey);
    isBody._return(res);

    

    final String getterName = "get" + capitalizedName;
    final JMethod getter = unionClass.method(JMod.PUBLIC, memberClass, getterName);
    final JBlock getterBody = getter.body();
    res = JExpr.invoke("obtain" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass)).arg(memberKey);
    getterBody._return(res);

    

    final JMethod setter = unionClass.method(JMod.PUBLIC, Void.TYPE, setterName);
    param = setter.param(memberClass, "value");
    final JInvocation inv = setter.body().invoke("select" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass));
    dataClassArg(inv, dataClass).arg(memberKey).arg(param);
  }

  private void generatePathSpecMethodsForUnion(UnionTemplateSpec unionSpec, JDefinedClass unionClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(unionClass);

    for (UnionTemplateSpec.Member member : unionSpec.getMembers())
    {
      JClass fieldsRefType = _pathSpecClass;
      if (hasNestedFields(member.getSchema()))
      {
        final JClass unionMemberClass = generate(member.getClassTemplateSpec());
        fieldsRefType = getCodeModel().ref(unionMemberClass.fullName() + ".Fields");
      }
      final JMethod accessorMethod = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, CodeUtil.getUnionMemberName(member.getSchema()));
      accessorMethod.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke("getPathComponents")).arg(member.getSchema().getUnionMemberKey()));
    }
  }

  private void populateClassContent(ClassTemplateSpec classTemplateSpec, JDefinedClass definedClass)
      throws JClassAlreadyExistsException
  {
    if (!_generatedClasses.containsKey(definedClass))
    {
      _generatedClasses.put(definedClass, classTemplateSpec);

      JavaCodeUtil.annotate(definedClass, "Data Template", classTemplateSpec.getLocation());

      if (classTemplateSpec instanceof ArrayTemplateSpec)
      {
        generateArray(definedClass, (ArrayTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof EnumTemplateSpec)
      {
        generateEnum(definedClass, (EnumTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof FixedTemplateSpec)
      {
        generateFixed(definedClass, (FixedTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof MapTemplateSpec)
      {
        generateMap(definedClass, (MapTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof RecordTemplateSpec)
      {
        generateRecord(definedClass, (RecordTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof TyperefTemplateSpec)
      {
        generateTyperef(definedClass, (TyperefTemplateSpec) classTemplateSpec);
      }
      else if (classTemplateSpec instanceof UnionTemplateSpec)
      {
        generateUnion(definedClass, (UnionTemplateSpec) classTemplateSpec);
      }
      else
      {
        throw new RuntimeException();
      }
    }
  }

  private JFieldVar generateSchemaField(JDefinedClass templateClass, DataSchema schema)
  {
    final JFieldVar schemaField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, schema.getClass(), DataTemplateUtil.SCHEMA_FIELD_NAME);
    final String schemaJson = SchemaToJsonEncoder.schemaToJson(schema, JsonBuilder.Pretty.COMPACT);
    final JInvocation parseSchemaInvocation;
    if (schemaJson.length() < MAX_SCHEMA_FIELD_JSON_LENGTH)
    {
      parseSchemaInvocation = _dataTemplateUtilClass.staticInvoke("parseSchema").arg(schemaJson);
    }
    else
    {
      JInvocation stringBuilderInvocation = JExpr._new(_stringBuilderClass);
      for (int index = 0; index < schemaJson.length(); index += MAX_SCHEMA_FIELD_JSON_LENGTH)
      {
        stringBuilderInvocation = stringBuilderInvocation.
            invoke("append").
            arg(schemaJson.substring(index, Math.min(schemaJson.length(), index + MAX_SCHEMA_FIELD_JSON_LENGTH)));
      }
      stringBuilderInvocation = stringBuilderInvocation.invoke("toString");
      parseSchemaInvocation = _dataTemplateUtilClass.staticInvoke("parseSchema").arg(stringBuilderInvocation);
    }
    schemaField.init(JExpr.cast(getCodeModel()._ref(schema.getClass()), parseSchemaInvocation));

    return schemaField;
  }

  private void generatePathSpecMethodsForCollection(JDefinedClass templateClass, DataSchema schema, JClass childClass, String wildcardMethodName)
      throws JClassAlreadyExistsException
  {
    if (hasNestedFields(schema))
    {
      final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(templateClass);

      final JClass itemsFieldType = getCodeModel().ref(childClass.fullName() + ".Fields");

      final JMethod constantField = fieldsNestedClass.method(JMod.PUBLIC, itemsFieldType, wildcardMethodName);
      constantField.body()._return(JExpr._new(itemsFieldType).arg(JExpr.invoke("getPathComponents")).arg(_pathSpecClass.staticRef("WILDCARD")));
    }
  }

  private JDefinedClass generatePathSpecNestedClass(JDefinedClass templateClass)
      throws JClassAlreadyExistsException
  {
    final JDefinedClass fieldsNestedClass = templateClass._class(JMod.PUBLIC | JMod.STATIC, "Fields");
    fieldsNestedClass._extends(_pathSpecClass);

    final JMethod constructor = fieldsNestedClass.constructor(JMod.PUBLIC);
    final JClass listString = getCodeModel().ref(List.class).narrow(String.class);
    final JVar namespace = constructor.param(listString, "path");
    final JVar name = constructor.param(String.class, "name");
    constructor.body().invoke(SUPER).arg(namespace).arg(name);

    fieldsNestedClass.constructor(JMod.PUBLIC).body().invoke(SUPER);
    return fieldsNestedClass;
  }

  
  private void generateCustomClassInitialization(JDefinedClass templateClass, CustomInfoSpec customInfo)
  {
    if (customInfo != null)
    {
      
      final String customClassFullName = customInfo.getCustomClass().getNamespace() + "." + customInfo.getCustomClass().getClassName();
      templateClass.init().add(_customClass.staticInvoke("initializeCustomClass").arg(getCodeModel().ref(customClassFullName).dotclass()));

      
      if (customInfo.getCoercerClass() != null)
      {
        final String coercerClassFullName = customInfo.getCoercerClass().getNamespace() + "." + customInfo.getCoercerClass().getClassName();
        templateClass.init().add(_customClass.staticInvoke("initializeCoercerClass").arg(getCodeModel().ref(coercerClassFullName).dotclass()));
      }
    }
  }

  private void generateConstructorWithInitialCapacity(JDefinedClass cls, JClass elementClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar initialCapacity = argConstructor.param(getCodeModel().INT, "initialCapacity");
    argConstructor.body().invoke(THIS).arg(JExpr._new(elementClass).arg(initialCapacity));
  }

  private void generateConstructorWithCollection(JDefinedClass cls, JClass elementClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar c = argConstructor.param(_collectionClass.narrow(elementClass), "c");
    argConstructor.body().invoke(THIS).arg(JExpr._new(_dataListClass).arg(c.invoke("size")));
    argConstructor.body().invoke("addAll").arg(c);
  }

  private void generateConstructorWithInitialCapacityAndLoadFactor(JDefinedClass cls)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar initialCapacity = argConstructor.param(getCodeModel().INT, "initialCapacity");
    final JVar loadFactor = argConstructor.param(getCodeModel().FLOAT, "loadFactor");
    argConstructor.body().invoke(THIS).arg(JExpr._new(_dataMapClass).arg(initialCapacity).arg(loadFactor));
  }

  private void generateConstructorWithMap(JDefinedClass cls, JClass valueClass)
  {
    final JMethod argConstructor = cls.constructor(JMod.PUBLIC);
    final JVar m = argConstructor.param(_mapClass.narrow(_stringClass, valueClass), "m");
    argConstructor.body().invoke(THIS).arg(JExpr.invoke("newDataMapOfSize").arg(m.invoke("size")));
    argConstructor.body().invoke("putAll").arg(m);
  }

  public static class Config
  {
    private String _defaultPackage;
    private boolean _recordFieldAccessorWithMode;

    public Config()
    {
      _defaultPackage = null;
      _recordFieldAccessorWithMode = true;
    }

    public void setDefaultPackage(String defaultPackage)
    {
      _defaultPackage = defaultPackage;
    }

    public String getDefaultPackage()
    {
      return _defaultPackage;
    }

    public void setRecordFieldAccessorWithMode(boolean recordFieldAccessorWithMode)
    {
      _recordFieldAccessorWithMode = recordFieldAccessorWithMode;
    }

    public boolean getRecordFieldAccessorWithMode()
    {
      return _recordFieldAccessorWithMode;
    }
  }
}

<code block>


package com.linkedin.pegasus.generator;

import com.linkedin.pegasus.generator.spec.ArrayTemplateSpec;
import com.linkedin.pegasus.generator.spec.EnumTemplateSpec;
import com.linkedin.pegasus.generator.spec.FixedTemplateSpec;
import com.linkedin.pegasus.generator.spec.MapTemplateSpec;
import com.linkedin.pegasus.generator.spec.RecordTemplateSpec;
import com.linkedin.pegasus.generator.spec.TyperefTemplateSpec;
import com.linkedin.pegasus.generator.spec.UnionTemplateSpec;

import com.sun.codemodel.JClass;
import com.sun.codemodel.JClassAlreadyExistsException;
import com.sun.codemodel.JDefinedClass;


public class CustomJavaDataTemplateGenerator extends JavaDataTemplateGenerator
{

  public CustomJavaDataTemplateGenerator(String defaultPackage)
  {
    super(defaultPackage);
  }

  @Override
  protected JClass getRecordClass()
  {
    return super.getRecordClass();
  }

  @Override
  protected JClass getWrappingArrayClass()
  {
    return super.getWrappingArrayClass();
  }

  @Override
  protected JClass getWrappingMapClass()
  {
    return super.getWrappingMapClass();
  }

  @Override
  protected void generateArray(JDefinedClass arrayClass,
                               ArrayTemplateSpec arrayDataTemplateSpec) throws JClassAlreadyExistsException
  {
    super.generateArray(arrayClass, arrayDataTemplateSpec);
  }

  @Override
  protected void generateEnum(JDefinedClass enumClass, EnumTemplateSpec enumSpec)
  {
    super.generateEnum(enumClass, enumSpec);
  }

  @Override
  protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)
  {
    super.generateFixed(fixedClass, fixedSpec);
  }

  @Override
  protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec) throws JClassAlreadyExistsException
  {
    super.generateMap(mapClass, mapSpec);
  }

  @Override
  protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec) throws JClassAlreadyExistsException
  {
    super.generateRecord(templateClass, recordSpec);
  }

  @Override
  protected void generateTyperef(JDefinedClass typerefClass,
                                 TyperefTemplateSpec typerefSpec)
  {
    super.generateTyperef(typerefClass, typerefSpec);
  }

  @Override
  protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec) throws JClassAlreadyExistsException
  {
    super.generateUnion(unionClass, unionSpec);
  }
}

<code block>


package com.linkedin.pegasus.generator;

import org.testng.Assert;
import org.testng.annotations.Test;


public class TestCustomJavaDataTemplateGenerator
{
  @Test
  public void testCreateGenerator()
  {
    JavaDataTemplateGenerator generator = new CustomJavaDataTemplateGenerator("defaultPackage");
    Assert.assertEquals(generator.getRecordClass().name(), "RecordTemplate");
    Assert.assertEquals(generator.getWrappingArrayClass().name(), "WrappingArrayTemplate");
    Assert.assertEquals(generator.getWrappingMapClass().name(), "WrappingMapTemplate");
  }
}

<code block>


package com.linkedin.restli.server;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import java.util.Map;



public interface RestLiResponseData
{
  
  boolean isErrorResponse();

  
  RestLiServiceException getServiceException();

  
  HttpStatus getStatus();

  
  ResponseType getResponseType();

  
  RecordResponseEnvelope getRecordResponseEnvelope();

  
  CollectionResponseEnvelope getCollectionResponseEnvelope();

  
  CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope();

  
  BatchResponseEnvelope getBatchResponseEnvelope();

  
  EmptyResponseEnvelope getEmptyResponseEnvelope();

  
  Map<String, String> getHeaders();
}

<code block>


package com.linkedin.restli.server;

import com.linkedin.data.DataMap;
import com.linkedin.restli.common.HttpStatus;


public class RestLiServiceException extends RuntimeException
{
  private static final long serialVersionUID = 1L;

  private final HttpStatus    _status;
  private Integer             _serviceErrorCode;
  private DataMap             _errorDetails;
  private ErrorResponseFormat _errorResponseFormat;

  public RestLiServiceException(final HttpStatus status)
  {
    this(status, null, null);
  }

  public RestLiServiceException(final HttpStatus status, final String message)
  {
    this(status, message, null);
  }

  public RestLiServiceException(final HttpStatus status,
                                final Throwable cause)
  {
    super(cause);
    _status = status;
  }

  public RestLiServiceException(final HttpStatus status,
                                final String message,
                                final Throwable cause)
  {
    super(message, cause);
    _status = status;
  }

  public HttpStatus getStatus()
  {
    return _status;
  }

  public RestLiServiceException setServiceErrorCode(final Integer serviceErrorCode)
  {
    _serviceErrorCode = serviceErrorCode;
    return this;
  }

  public boolean hasServiceErrorCode()
  {
    return _serviceErrorCode != null;
  }

  public Integer getServiceErrorCode()
  {
    return _serviceErrorCode;
  }

  public DataMap getErrorDetails()
  {
    return _errorDetails;
  }

  public boolean hasErrorDetails()
  {
    return _errorDetails != null;
  }

  public RestLiServiceException setErrorDetails(final DataMap errorDetails)
  {
    _errorDetails = errorDetails;
    return this;
  }

  @Override
  public String toString()
  {
    StringBuilder sb = new StringBuilder();
    sb.append(getClass().getName());
    sb.append(" [HTTP Status:").append(_status.getCode());
    if (_serviceErrorCode != null)
    {
      sb.append(", serviceErrorCode:").append(_serviceErrorCode);
    }
    sb.append("]");
    String message = getLocalizedMessage();
    if (message != null)
    {
      sb.append(": ").append(message);
    }
    return sb.toString();
  }

  
  public void setOverridingFormat(ErrorResponseFormat errorResponseFormat)
  {
    _errorResponseFormat = errorResponseFormat;
  }

  
  public boolean hasOverridingErrorResponseFormat()
  {
    return _errorResponseFormat != null;
  }

  public ErrorResponseFormat getOverridingFormat()
  {
    return _errorResponseFormat;
  }
}

<code block>
package com.linkedin.restli.server;


import java.util.EnumSet;



public enum ErrorResponseFormat
{

  
  FULL(EnumSet.allOf(ErrorResponsePart.class)),

  
  MESSAGE_AND_DETAILS(EnumSet.of(ErrorResponsePart.MESSAGE, ErrorResponsePart.DETAILS, ErrorResponsePart.HEADERS)),

  
  MESSAGE_AND_SERVICECODE(EnumSet.of(ErrorResponsePart.MESSAGE, ErrorResponsePart.SERVICE_ERROR_CODE, ErrorResponsePart.HEADERS)),

  
  MESSAGE_ONLY(EnumSet.of(ErrorResponsePart.MESSAGE, ErrorResponsePart.HEADERS)),

  
  MINIMAL(EnumSet.of(ErrorResponsePart.HEADERS));

  private static enum ErrorResponsePart
  {
    HEADERS,
    STATUS_CODE_IN_BODY,
    STACKTRACE,
    MESSAGE,
    SERVICE_ERROR_CODE,
    DETAILS
  }

  private final EnumSet<ErrorResponsePart> _errorPartsToShow;

  ErrorResponseFormat(EnumSet<ErrorResponsePart> errorPartsToShow)
  {
    _errorPartsToShow = errorPartsToShow;
  }

  public static ErrorResponseFormat defaultFormat()
  {
    return FULL;
  }

  public boolean showHeaders()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.HEADERS);
  }

  public boolean showStatusCodeInBody()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.STATUS_CODE_IN_BODY);
  }

  public boolean showStacktrace()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.STACKTRACE);
  }

  public boolean showMessage()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.MESSAGE);
  }

  public boolean showServiceErrorCode()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.SERVICE_ERROR_CODE);
  }

  public boolean showDetails()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.DETAILS);
  }
}

<code block>


package com.linkedin.restli.server.filter;


import com.linkedin.restli.server.RestLiResponseData;

import java.util.Map;



public interface FilterResponseContext
{

  
  RestLiResponseData getResponseData();
}

<code block>


package com.linkedin.restli.server.validation;


import com.linkedin.data.schema.validation.ValidationResult;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.validation.RestLiDataValidator;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.List;
import java.util.Map;



public class RestLiOutputValidationFilter implements ResponseFilter
{
  @Override
  public void onResponse(final FilterRequestContext requestContext, final FilterResponseContext responseContext)
  {
    Class<?> resourceClass = requestContext.getFilterResourceModel().getResourceClass();
    ResourceMethod method = requestContext.getMethodType();
    RestLiDataValidator validator = new RestLiDataValidator(resourceClass.getAnnotations(), requestContext.getFilterResourceModel().getValueClass(), method);
    RestLiResponseData responseData = responseContext.getResponseData();
    if (responseData.isErrorResponse())
    {
      return;
    }
    if (method == ResourceMethod.GET)
    {
      ValidationResult result = validator.validate(responseData.getRecordResponseEnvelope().getRecord());
      if (!result.isValid())
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, result.getMessages().toString());
      }

    }
    else if (method == ResourceMethod.GET_ALL || method == ResourceMethod.FINDER)
    {
      List<? extends RecordTemplate> entities;
      entities = responseData.getCollectionResponseEnvelope().getCollectionResponse();

      StringBuilder sb = new StringBuilder();
      for (RecordTemplate entity : entities)
      {
        ValidationResult result = validator.validate(entity);
        if (!result.isValid())
        {
          sb.append(result.getMessages().toString());
        }
      }

      if (sb.length() > 0)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, sb.toString());
      }
    }
    else if (method == ResourceMethod.BATCH_GET)
    {
      StringBuilder sb = new StringBuilder();
      for (Map.Entry<?, ? extends BatchResponseEnvelope.BatchResponseEntry> entry : responseData.getBatchResponseEnvelope().getBatchResponseMap().entrySet())
      {
        if (entry.getValue().hasException())
        {
          continue;
        }
        ValidationResult result = validator.validate(entry.getValue().getRecord());
        if (!result.isValid())
        {
          sb.append("Key: ");
          sb.append(entry.getKey());
          sb.append(", ");
          sb.append(result.getMessages().toString());
        }
      }

      if (sb.length() > 0)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, sb.toString());
      }
    }
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.restli.common.ResourceMethod;

import java.util.Arrays;
import java.util.List;

import static com.linkedin.restli.common.ResourceMethod.GET;
import static com.linkedin.restli.common.ResourceMethod.ACTION;
import static com.linkedin.restli.common.ResourceMethod.CREATE;
import static com.linkedin.restli.common.ResourceMethod.GET_ALL;
import static com.linkedin.restli.common.ResourceMethod.FINDER;
import static com.linkedin.restli.common.ResourceMethod.BATCH_CREATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_GET;
import static com.linkedin.restli.common.ResourceMethod.BATCH_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_PARTIAL_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_DELETE;
import static com.linkedin.restli.common.ResourceMethod.PARTIAL_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.UPDATE;
import static com.linkedin.restli.common.ResourceMethod.DELETE;
import static com.linkedin.restli.common.ResourceMethod.OPTIONS;



public enum ResponseType
{
  
  SINGLE_ENTITY(GET, ACTION, CREATE),

  
  GET_COLLECTION(GET_ALL, FINDER),

  
  CREATE_COLLECTION(BATCH_CREATE),

  
  BATCH_ENTITIES(BATCH_GET, BATCH_UPDATE, BATCH_PARTIAL_UPDATE, BATCH_DELETE),

  
  STATUS_ONLY(PARTIAL_UPDATE, UPDATE, DELETE, OPTIONS);

  private ResponseType(ResourceMethod... types)
  {
    _methodTypes = Arrays.asList(types);
  }

  
  public static ResponseType fromMethodType(ResourceMethod type)
  {
    if (type == null)
    {
      return STATUS_ONLY;
    }

    for (ResponseType responseType : values())
    {
      if (responseType._methodTypes.contains(type))
      {
        return responseType;
      }
    }

    throw new UnsupportedOperationException("Unexpected resource method found: " + type.toString());
  }

  private final List<ResourceMethod> _methodTypes;
}

<code block>


package com.linkedin.restli.internal.server;

import com.linkedin.data.DataMap;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.server.methods.MethodAdapterRegistry;
import com.linkedin.restli.internal.server.methods.response.ErrorResponseBuilder;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.internal.server.methods.response.RestLiResponseBuilder;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.util.DataMapUtils;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.resources.CollectionResource;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import java.util.TreeMap;



public class RestLiResponseHandler
{
  private final MethodAdapterRegistry _methodAdapterRegistry;
  private final ErrorResponseBuilder _errorResponseBuilder;

  public RestLiResponseHandler(MethodAdapterRegistry methodAdapterRegistry, ErrorResponseBuilder errorResponseBuilder)
  {
    _methodAdapterRegistry = methodAdapterRegistry;
    _errorResponseBuilder = errorResponseBuilder;
  }

  public static class Builder
  {
    private MethodAdapterRegistry _methodAdapterRegistry = null;
    private ErrorResponseBuilder _errorResponseBuilder = null;
    private boolean _permissiveEncoding = false;

    public Builder setMethodAdapterRegistry(MethodAdapterRegistry methodAdapterRegistry)
    {
      _methodAdapterRegistry = methodAdapterRegistry;
      return this;
    }

    public Builder setErrorResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
    {
      _errorResponseBuilder = errorResponseBuilder;
      return this;
    }

    public RestLiResponseHandler build()
    {
      if (_errorResponseBuilder == null)
      {
        _errorResponseBuilder = new ErrorResponseBuilder();
      }
      if (_methodAdapterRegistry == null)
      {
        _methodAdapterRegistry = new MethodAdapterRegistry(_errorResponseBuilder);
      }
      return new RestLiResponseHandler(_methodAdapterRegistry, _errorResponseBuilder);
    }
  }

  
  public RestResponse buildResponse(final RestRequest request,
                                    final RoutingResult routingResult,
                                    final Object responseObject) throws IOException
  {
    return buildResponse(routingResult,
                         buildPartialResponse(routingResult,
                                              buildRestLiResponseData(request, routingResult, responseObject)));
  }


  
  public RestResponse buildResponse(final RoutingResult routingResult,
                                     PartialRestResponse partialResponse)
  {
    RestResponseBuilder builder =
        new RestResponseBuilder().setHeaders(partialResponse.getHeaders()).setStatus(partialResponse.getStatus()
                                                                                                    .getCode());
    if (partialResponse.hasData())
    {
      DataMap dataMap = partialResponse.getDataMap();
      String mimeType = ((ServerResourceContext) routingResult.getContext()).getResponseMimeType();
      builder = encodeResult(mimeType, builder, dataMap);
    }
    return builder.build();
  }

  
  public PartialRestResponse buildPartialResponse(final RoutingResult routingResult,
                                                  final RestLiResponseEnvelope responseData)
  {
    if (responseData.isErrorResponse()){
      return _errorResponseBuilder.buildResponse(routingResult, responseData);
    }

    return chooseResponseBuilder(null, routingResult).buildResponse(routingResult, responseData);
  }

  
  public RestLiResponseEnvelope buildRestLiResponseData(final RestRequest request,
                                                            final RoutingResult routingResult,
                                                            final Object responseObject) throws IOException
  {
    ServerResourceContext context = (ServerResourceContext) routingResult.getContext();
    final ProtocolVersion protocolVersion = context.getRestliProtocolVersion();
    Map<String, String> responseHeaders = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
    responseHeaders.putAll(context.getResponseHeaders());
    responseHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());

    if (responseObject == null)
    {
      
      if (routingResult.getResourceMethod().getType().equals(ResourceMethod.ACTION))
      {
        return new RecordResponseEnvelope(HttpStatus.S_200_OK, null, responseHeaders);
      }
      else if (routingResult.getResourceMethod().getType().equals(ResourceMethod.GET))
      {
        throw new RestLiServiceException(HttpStatus.S_404_NOT_FOUND,
            "Requested entity not found: " + routingResult.getResourceMethod());
      }
      else
      {
        
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null returned by the resource method: " + routingResult.getResourceMethod());
      }
    }

    RestLiResponseBuilder responseBuilder = chooseResponseBuilder(responseObject, routingResult);

    if (responseBuilder == null)
    {
      
      ResourceMethodDescriptor resourceMethod = routingResult.getResourceMethod();
      String fqMethodName =
          resourceMethod.getResourceModel().getResourceClass().getName() + '#'
              + routingResult.getResourceMethod().getMethod().getName();
      throw new RestLiInternalException("Invalid return type '" + responseObject.getClass() + " from method '"
          + fqMethodName + '\'');
    }
    return responseBuilder.buildRestLiResponseData(request, routingResult, responseObject, responseHeaders);
  }

  public RestLiResponseEnvelope buildExceptionResponseData(final RestRequest request,
                                                                final RoutingResult routingResult,
                                                                final Object object,
                                                                final Map<String, String> headers)
  {
    return _errorResponseBuilder.buildRestLiResponseData(request, routingResult, object, headers);
  }

  public RestException buildRestException(final Throwable e, PartialRestResponse partialResponse)
  {
    RestResponseBuilder builder =
        new RestResponseBuilder().setHeaders(partialResponse.getHeaders()).setStatus(partialResponse.getStatus()
                                                                                                    .getCode());
    if (partialResponse.hasData())
    {
      DataMap dataMap = partialResponse.getDataMap();
      ByteArrayOutputStream baos = new ByteArrayOutputStream(4096);
      DataMapUtils.write(dataMap, null, baos, true); 
      builder.setEntity(baos.toByteArray());
    }
    RestResponse restResponse = builder.build();
    RestException restException = new RestException(restResponse, e);
    return restException;
  }


  private RestResponseBuilder encodeResult(String mimeType, RestResponseBuilder builder, DataMap dataMap)
  {
    if (RestConstants.HEADER_VALUE_APPLICATION_PSON.equalsIgnoreCase(mimeType))
    {
      builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, RestConstants.HEADER_VALUE_APPLICATION_PSON);
      builder.setEntity(DataMapUtils.mapToPsonBytes(dataMap));
    }
    else if (RestConstants.HEADER_VALUE_APPLICATION_JSON.equalsIgnoreCase(mimeType))
    {
      builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, RestConstants.HEADER_VALUE_APPLICATION_JSON);
      builder.setEntity(DataMapUtils.mapToBytes(dataMap));
    }
    else
    {
      throw new RoutingException("No acceptable types can be returned", HttpStatus.S_406_NOT_ACCEPTABLE.getCode());
    }
    return builder;
  }

  private RestLiResponseBuilder chooseResponseBuilder(final Object responseObject,
                                                      final RoutingResult routingResult)
  {
    if (responseObject != null && responseObject instanceof RestLiServiceException)
    {
      return _errorResponseBuilder;
    }

    return _methodAdapterRegistry.getResponsebuilder(routingResult.getResourceMethod()
                                                                 .getType());
  }
}

<code block>



package com.linkedin.restli.internal.server;


import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.filter.FilterResponseContextInternal;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.server.RequestExecutionCallback;
import com.linkedin.restli.server.RequestExecutionReport;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;


public class RestLiCallback<T> implements RequestExecutionCallback<T>
{
  private final RoutingResult _method;
  private final RestLiResponseHandler _responseHandler;
  private final RequestExecutionCallback<RestResponse> _callback;
  private final RestRequest _request;
  private final List<ResponseFilter> _responseFilters;
  private final FilterRequestContext _filterRequestContext;

  public RestLiCallback(final RestRequest request,
                        final RoutingResult method,
                        final RestLiResponseHandler responseHandler,
                        final RequestExecutionCallback<RestResponse> callback,
                        final List<ResponseFilter> responseFilters,
                        final FilterRequestContext filterRequestContext)
  {
    _request = request;
    _method = method;
    _responseHandler = responseHandler;
    _callback = callback;
    if (responseFilters != null)
    {
      _responseFilters = responseFilters;
    }
    else
    {
      _responseFilters = new ArrayList<ResponseFilter>();
    }
    _filterRequestContext = filterRequestContext;
  }

  @Override
  public void onSuccess(final T result, RequestExecutionReport executionReport)
  {
    try
    {
      
      final RestLiResponseEnvelope responseData = _responseHandler.buildRestLiResponseData(_request, _method, result);
      
      if (!_responseFilters.isEmpty())
      {
        invokeFiltersAndProcessResults(executionReport, responseData, null);
      }
      else
      {
        
        final PartialRestResponse response = _responseHandler.buildPartialResponse(_method, responseData);
        
        _callback.onSuccess(_responseHandler.buildResponse(_method, response), executionReport);
      }
    }
    catch (Exception e)
    {
      
      
      
      onError(e, executionReport);
    }
  }

  @Override
  public void onError(final Throwable e, RequestExecutionReport executionReport)
  {
    final RestLiResponseEnvelope responseData = convertExceptionToRestLiResponseData(e);
    
    if (!_responseFilters.isEmpty())
    {
      invokeFiltersAndProcessResults(executionReport, responseData, e);
    }
    else
    {
      
      _callback.onError(_responseHandler.buildRestException(e, _responseHandler.buildPartialResponse(_method,
                                                                                                     responseData)),
                        executionReport);
    }
  }

  private void invokeFiltersAndProcessResults(RequestExecutionReport executionReport,
                                              final RestLiResponseEnvelope responseData,
                                              final Throwable appEx)
  {
    
    final FilterResponseContextInternal responseContext = new FilterResponseContextAdapter(responseData);
    try
    {
      invokeResponseFilters(responseContext, appEx);
      
      
      
      final PartialRestResponse response = _responseHandler.buildPartialResponse(_method, responseContext.getRestLiResponseEnvelope());
      
      _callback.onSuccess(_responseHandler.buildResponse(_method, response), executionReport);
    }
    catch (Throwable e)
    {
      
      _callback.onError(_responseHandler.buildRestException(e,
                                                            _responseHandler.buildPartialResponse(_method,
                                                                                                  responseContext.getRestLiResponseEnvelope())),
                        executionReport);
    }
  }

  
  RestLiResponseEnvelope convertExceptionToRestLiResponseData(Throwable e)
  {
    RestLiServiceException restLiServiceException;
    if (e instanceof RestLiServiceException)
    {
      restLiServiceException = (RestLiServiceException) e;
    }
    else if (e instanceof RoutingException)
    {
      RoutingException routingException = (RoutingException) e;

      restLiServiceException =
          new RestLiServiceException(HttpStatus.fromCode(routingException.getStatus()),
                                     routingException.getMessage(),
                                     routingException);
    }
    else
    {
      restLiServiceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, e.getMessage(), e);
    }

    Map<String, String> requestHeaders = _request.getHeaders();
    Map<String, String> headers = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION,
                ProtocolVersionUtil.extractProtocolVersion(requestHeaders).toString());
    headers.put(HeaderUtil.getErrorResponseHeaderName(requestHeaders), RestConstants.HEADER_VALUE_ERROR);
    return _responseHandler.buildExceptionResponseData(_request, _method, restLiServiceException, headers);
  }

  private void invokeResponseFilters(final FilterResponseContextInternal responseContext, Throwable lastException) throws Throwable
  {
    for (ResponseFilter filter : _responseFilters)
    {
      try
      {
        filter.onResponse(_filterRequestContext, responseContext);
        
        
        if (!responseContext.getRestLiResponseEnvelope().isErrorResponse())
        {
          lastException = null;
        }
      }
      catch (Exception ex)
      {
        
        lastException = ex;
        responseContext.setRestLiResponseEnvelope(convertExceptionToRestLiResponseData(ex));
      }
    }
    
    if (lastException != null)
    {
      throw lastException;
    }
  }

  
  static class FilterResponseContextAdapter implements FilterResponseContextInternal
  {
    private RestLiResponseEnvelope _responseData;
    public FilterResponseContextAdapter(final RestLiResponseEnvelope response)
    {
      _responseData = response;
    }

    @Override
    public RestLiResponseData getResponseData()
    {
      return _responseData;
    }

    @Override
    public void setRestLiResponseEnvelope(RestLiResponseEnvelope data)
    {
      _responseData = data;
    }

    @Override
    public RestLiResponseEnvelope getRestLiResponseEnvelope()
    {
      return _responseData;
    }
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;
import java.util.TreeMap;



public abstract class RestLiResponseEnvelope implements RestLiResponseData
{
  
  private HttpStatus _status;
  private RestLiServiceException _exception;
  private Map<String, String> _headers;

  
  private RestLiResponseEnvelope(Map<String, String> headers)
  {
    _headers = new TreeMap<String, String>(headers);
  }

  
  protected RestLiResponseEnvelope(HttpStatus httpStatus, Map<String, String> headers)
  {
    this(headers);
    setStatus(httpStatus);
  }

  
  protected RestLiResponseEnvelope(RestLiServiceException exception, Map<String, String> headers)
  {
    this(headers);
    setException(exception);
  }

  @Override
  public boolean isErrorResponse()
  {
    return _exception != null;
  }

  @Override
  public RestLiServiceException getServiceException()
  {
    return _exception;
  }

  @Override
  public abstract ResponseType getResponseType();

  
  protected void setException(RestLiServiceException exception)
  {
    if (exception == null)
    {
      throw new UnsupportedOperationException("Null is not permitted in setting an exception.");
    }
    _exception = exception;
    _status = null;
  }

  
  @Override
  public HttpStatus getStatus()
  {
    return _exception != null ? _exception.getStatus() : _status;
  }

  
  protected void setStatus(HttpStatus status)
  {
    if (status == null)
    {
      throw new UnsupportedOperationException("Setting status to null is not permitted for when there are no exceptions.");
    }
    _status = status;
    _exception = null;

    _headers.remove(HeaderUtil.getErrorResponseHeaderName(_headers));
  }

  
  public Map<String, String> getHeaders()
  {
    return _headers;
  }
}

<code block>


package com.linkedin.restli.internal.server.filter;


import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.server.filter.FilterResponseContext;



public interface FilterResponseContextInternal extends FilterResponseContext
{
  
  void setRestLiResponseEnvelope(RestLiResponseEnvelope data);

  
  RestLiResponseEnvelope getRestLiResponseEnvelope();
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.template.FieldDef;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.ActionResult;
import com.linkedin.restli.server.RestLiServiceException;
import java.util.Map;


public class ActionResponseBuilder implements RestLiResponseBuilder
{

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult,
                                           RestLiResponseEnvelope responseData)
  {
    return new PartialRestResponse.Builder().status(responseData.getStatus())
                                            .entity(responseData.getRecordResponseEnvelope().getRecord())
                                            .headers(responseData.getHeaders())
                                            .build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request,
                                                            RoutingResult routingResult,
                                                            Object result,
                                                            Map<String, String> headers)
  {
    final Object value;
    final HttpStatus status;
    if (result instanceof ActionResult)
    {
      final ActionResult<?> actionResult = (ActionResult<?>) result;
      value = actionResult.getValue();
      status = actionResult.getStatus();
      if (status == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null HttpStatus inside of an ActionResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }
    }
    else
    {
      value = result;
      status = HttpStatus.S_200_OK;
    }
    RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();
    @SuppressWarnings("unchecked")
    FieldDef<Object> actionReturnFieldDef =
        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();
    final ActionResponse<?> actionResponse =
        new ActionResponse<Object>(value, actionReturnFieldDef, actionReturnRecordDataSchema);
    return new RecordResponseEnvelope(status, actionResponse, headers);
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;


public class BatchCreateResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchCreateResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  @SuppressWarnings("unchecked")
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    List<CreateCollectionResponseEnvelope.CollectionCreateResponseItem> collectionCreateResponses = responseData.getCreateCollectionResponseEnvelope().getCreateResponses();
    List<CreateIdStatus<Object>> formattedResponses = new ArrayList<CreateIdStatus<Object>>(collectionCreateResponses.size());

    
    
    for (CreateCollectionResponseEnvelope.CollectionCreateResponseItem response : collectionCreateResponses)
    {
      if (response.isErrorResponse())
      {
        RestLiServiceException exception = response.getException();
        formattedResponses.add(new CreateIdStatus<Object>(exception.getStatus().getCode(),
                                                          response.getId(),
                                                          _errorResponseBuilder.buildErrorResponse(exception),
                                                          ProtocolVersionUtil.extractProtocolVersion(responseData.getHeaders())));
      }
      else
      {
        formattedResponses.add((CreateIdStatus<Object>) response.getRecord());
      }
    }

    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    BatchCreateIdResponse<Object> batchCreateIdResponse = new BatchCreateIdResponse<Object>(formattedResponses);
    return builder.headers(responseData.getHeaders()).entity(batchCreateIdResponse).build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                        Object result, Map<String, String> headers)
  {
    BatchCreateResult<?, ?> list = (BatchCreateResult<?, ?>) result;

    
    if (list.getResults() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null List inside of a BatchCreateResult returned by the resource method: " + routingResult
              .getResourceMethod());
    }

    List<CreateCollectionResponseEnvelope.CollectionCreateResponseItem> collectionCreateList = new ArrayList<CreateCollectionResponseEnvelope.CollectionCreateResponseItem>(list.getResults().size());
    for (CreateResponse e : list.getResults())
    {
      
      if (e == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null element inside of List inside of a BatchCreateResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      if (e.getError() == null)
      {
        CreateIdStatus<Object> entry = new CreateIdStatus<Object>(e.getStatus().getCode(), e.getId(), null, ProtocolVersionUtil.extractProtocolVersion(headers));
        collectionCreateList.add(new CreateCollectionResponseEnvelope.CollectionCreateResponseItem(entry));
      }
      else
      {
        collectionCreateList.add(new CreateCollectionResponseEnvelope.CollectionCreateResponseItem(e.getError(), e.getId()));
      }
    }

    return new CreateCollectionResponseEnvelope(collectionCreateList, headers);
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ResourceContext;

import java.util.Map;


public class GetResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    return new PartialRestResponse.Builder().headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .entity(responseData.getRecordResponseEnvelope().getRecord()).build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    final RecordTemplate record;
    final HttpStatus status;
    if (result instanceof GetResult)
    {
      final GetResult<?> getResult = (GetResult<?>) result;
      record = getResult.getValue();
      status = getResult.getStatus();
    }
    else
    {
      record = (RecordTemplate) result;
      status = HttpStatus.S_200_OK;
    }
    final ResourceContext resourceContext = routingResult.getContext();
    final DataMap data = RestUtils.projectFields(record.data(), resourceContext.getProjectionMode(),
        resourceContext.getProjectionMask());

    return new RecordResponseEnvelope(status, new AnyRecord((data)), headers);
  }
}
<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.ErrorDetails;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.ErrorResponseFormat;
import com.linkedin.restli.server.RestLiServiceException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Map;



public final class ErrorResponseBuilder implements RestLiResponseBuilder
{
  public static final String DEFAULT_INTERNAL_ERROR_MESSAGE = "Error in application code";
  private final ErrorResponseFormat _errorResponseFormat;
  private final String _internalErrorMessage;

  public ErrorResponseBuilder()
  {
    this(ErrorResponseFormat.defaultFormat());
  }

  public ErrorResponseBuilder(ErrorResponseFormat errorResponseFormat)
  {
    this(errorResponseFormat, DEFAULT_INTERNAL_ERROR_MESSAGE);
  }

  public ErrorResponseBuilder(ErrorResponseFormat errorResponseFormat, String internalErrorMessage)
  {
    _errorResponseFormat = errorResponseFormat;
    _internalErrorMessage = internalErrorMessage;
  }

  public String getInternalErrorMessage()
  {
    return _internalErrorMessage;
  }

  public ErrorResponse buildErrorResponse(RestLiServiceException result)
  {
    return buildErrorResponse(result, result.hasOverridingErrorResponseFormat() ? result.getOverridingFormat() : _errorResponseFormat);
  }

  private ErrorResponse buildErrorResponse(RestLiServiceException result, ErrorResponseFormat errorResponseFormat)
  {
    ErrorResponse er = new ErrorResponse();
    if (errorResponseFormat.showStatusCodeInBody())
    {
      er.setStatus(result.getStatus().getCode());
    }

    if (errorResponseFormat.showMessage() && result.getMessage() != null)
    {
      er.setMessage(result.getMessage());
    }
    if (errorResponseFormat.showServiceErrorCode() && result.hasServiceErrorCode())
    {
      er.setServiceErrorCode(result.getServiceErrorCode());
    }
    if (errorResponseFormat.showDetails() && result.hasErrorDetails())
    {
      er.setErrorDetails(new ErrorDetails(result.getErrorDetails()));
    }

    if (errorResponseFormat.showStacktrace())
    {
      StringWriter sw = new StringWriter();
      PrintWriter pw = new PrintWriter(sw);
      result.printStackTrace(pw);
      er.setStackTrace(sw.toString());

      er.setExceptionClass(result.getClass().getName());
    }

    return er;
  }

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    ErrorResponse errorResponse = buildErrorResponse(responseData.getServiceException());
    return new PartialRestResponse.Builder().headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .entity(errorResponse).build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object object, Map<String, String> headers)
  {
    RestLiServiceException exceptionResult = (RestLiServiceException) object;
    if (_errorResponseFormat.showHeaders())
    {
      final ProtocolVersion protocolVersion = ProtocolVersionUtil.extractProtocolVersion(headers);
      headers.put(HeaderUtil.getErrorResponseHeaderName(protocolVersion), RestConstants.HEADER_VALUE_ERROR);
    }
    final ResourceMethod type;
    if (routingResult != null && routingResult.getResourceMethod() != null)
    {
      type = routingResult.getResourceMethod().getMethodType();
    }
    else
    {
      type = null;
    }

    switch (ResponseType.fromMethodType(type))
    {
      case SINGLE_ENTITY:
        return new RecordResponseEnvelope(exceptionResult, headers);
      case GET_COLLECTION:
        return new CollectionResponseEnvelope(exceptionResult, headers);
      case CREATE_COLLECTION:
        return new CreateCollectionResponseEnvelope(exceptionResult, headers);
      case BATCH_ENTITIES:
        return new BatchResponseEnvelope(exceptionResult, headers);
      case STATUS_ONLY:
        return new EmptyResponseEnvelope(exceptionResult, headers);
      default:
        throw new IllegalArgumentException();
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.Map;


public class UpdateResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    return new PartialRestResponse.Builder().headers(responseData.getHeaders())
                                            .status(responseData.getStatus())
                                            .build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    UpdateResponse updateResponse = (UpdateResponse) result;
    
    if (updateResponse.getStatus() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. HttpStatus is null inside of a UpdateResponse returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    return new EmptyResponseEnvelope(updateResponse.getStatus(), headers);
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataList;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CollectionResult.PageIncrement;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;


public class CollectionResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    CollectionResponseEnvelope response = responseData.getCollectionResponseEnvelope();
    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    CollectionResponse<AnyRecord> collectionResponse = new CollectionResponse<AnyRecord>(AnyRecord.class);
    collectionResponse.setPaging(response.getCollectionResponsePaging());
    DataList elementsMap = (DataList) collectionResponse.data().get(CollectionResponse.ELEMENTS);
    for (RecordTemplate entry : response.getCollectionResponse())
    {
      CheckedUtil.addWithoutChecking(elementsMap, entry.data());
    }
    if (response.getCollectionResponseCustomMetadata() != null)
    {
      collectionResponse.setMetadataRaw(response.getCollectionResponseCustomMetadata().data());
    }
    builder.entity(collectionResponse);
    return builder.headers(responseData.getHeaders()).build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object object, Map<String, String> headers)
  {
    if (object instanceof List)
    {
      @SuppressWarnings({ "unchecked" })
      
      List<? extends RecordTemplate> result = (List<? extends RecordTemplate>) object;

      return buildRestLiResponseData(request, routingResult, result, PageIncrement.RELATIVE, null, null, headers);
    }
    else
    {
      @SuppressWarnings({ "unchecked" })
      
      CollectionResult<? extends RecordTemplate, ? extends RecordTemplate> collectionResult =
          (CollectionResult<? extends RecordTemplate, ? extends RecordTemplate>) object;

      
      if (collectionResult.getElements() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null elements List inside of CollectionResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      return buildRestLiResponseData(request, routingResult, collectionResult.getElements(),
                                     collectionResult.getPageIncrement(), collectionResult.getMetadata(),
                                     collectionResult.getTotal(), headers);
    }
  }

  private static RestLiResponseEnvelope buildRestLiResponseData(final RestRequest request,
                                                                     final RoutingResult routingResult,
                                                                     final List<? extends RecordTemplate> elements,
                                                                     final PageIncrement pageIncrement,
                                                                     final RecordTemplate customMetadata,
                                                                     final Integer totalResults,
                                                                     final Map<String, String> headers)
  {
    
    final ResourceContext resourceContext = routingResult.getContext();

    
    final CollectionMetadata paging =
        RestUtils.buildMetadata(request.getURI(), resourceContext, routingResult.getResourceMethod(),
                                elements, pageIncrement, totalResults);

    
    
    
    
    
    
    
    
    
    
    
    
    
    final RecordTemplate anyRecord = new AnyRecord(RestUtils.projectFields(paging.data(),
        ProjectionMode.AUTOMATIC, resourceContext.getPagingProjectionMask()));
    final CollectionMetadata projectedPaging = new CollectionMetadata(anyRecord.data());

    
    List<AnyRecord> processedElements = new ArrayList<AnyRecord>(elements.size());
    for (RecordTemplate entry : elements)
    {
      
      if (entry == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null element inside of a List returned by the resource method: " + routingResult
                .getResourceMethod());
      }
      processedElements.add(new AnyRecord(RestUtils
          .projectFields(entry.data(), resourceContext.getProjectionMode(), resourceContext.getProjectionMask())));
    }

    
    final AnyRecord projectedCustomMetadata;
    if (customMetadata != null)
    {
      projectedCustomMetadata = new AnyRecord(RestUtils
          .projectFields(customMetadata.data(), resourceContext.getMetadataProjectionMode(),
              resourceContext.getMetadataProjectionMask()));
    }
    else
    {
      projectedCustomMetadata = null;
    }

    return new CollectionResponseEnvelope(processedElements,
                                          projectedPaging,
                                          projectedCustomMetadata,
                                          headers);
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.data.template.SetMode;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope.BatchResponseEntry;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.BatchResult;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class BatchGetResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchGetResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  @SuppressWarnings("unchecked")
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    final Map<Object, BatchResponseEntry> responses = (Map<Object, BatchResponseEntry>) responseData.getBatchResponseEnvelope().getBatchResponseMap();

    
    Map<Object, EntityResponse<RecordTemplate>> entityBatchResponse = buildEntityResponse(routingResult, responses);

    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    final ProtocolVersion protocolVersion = ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();

    @SuppressWarnings("unchecked")
    final BatchResponse<AnyRecord> response = toBatchResponse(entityBatchResponse, protocolVersion);
    builder.entity(response);
    return builder.headers(responseData.getHeaders()).build();
  }

  
  
  private Map<Object, EntityResponse<RecordTemplate>> buildEntityResponse(RoutingResult routingResult,
                                                                          Map<Object, BatchResponseEntry> mergedResponse)
  {
    Map<Object, EntityResponse<RecordTemplate>> entityBatchResponse = new HashMap<Object, EntityResponse<RecordTemplate>>(mergedResponse.size());

    for (Map.Entry<Object, BatchResponseEntry> entry : mergedResponse.entrySet())
    {
      @SuppressWarnings("unchecked")
      final EntityResponse<RecordTemplate> entityResponse = entry.getValue().hasException() ?
                                                              createEntityResponse(null, routingResult) :
                                                              createEntityResponse(entry.getValue().getRecord(), routingResult);

      if (entry.getKey() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null errors Map found inside of the result returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      entityResponse.setStatus(entry.getValue().getStatus(), SetMode.IGNORE_NULL);
      if (entry.getValue().hasException())
      {
        entityResponse.setError(_errorResponseBuilder.buildErrorResponse(entry.getValue().getException()));
      }
      entityBatchResponse.put(entry.getKey(), entityResponse);
    }

    return entityBatchResponse;
  }

  private static EntityResponse<RecordTemplate> createEntityResponse(RecordTemplate entityTemplate, RoutingResult routingResult)
  {
    final EntityResponse<RecordTemplate> entityResponse;
    if (entityTemplate == null)
    {
      entityResponse = new EntityResponse<RecordTemplate>(null);
    }
    else
    {
      @SuppressWarnings("unchecked")
      final Class<RecordTemplate> entityClass = (Class<RecordTemplate>) entityTemplate.getClass();
      entityResponse = new EntityResponse<RecordTemplate>(entityClass);

      final DataMap projectedData = RestUtils.projectFields(entityTemplate.data(),
                                                            routingResult.getContext().getProjectionMode(),
                                                            routingResult.getContext().getProjectionMask());
      CheckedUtil.putWithoutChecking(entityResponse.data(), EntityResponse.ENTITY, projectedData);
    }

    return entityResponse;
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    @SuppressWarnings({ "unchecked" })
    
    final Map<Object, RecordTemplate> entities = (Map<Object, RecordTemplate>) result;
    Map<Object, HttpStatus> statuses = Collections.emptyMap();
    Map<Object, RestLiServiceException> serviceErrors = Collections.emptyMap();

    if (result instanceof BatchResult)
    {
      @SuppressWarnings({ "unchecked" })
      
      final BatchResult<Object, RecordTemplate> batchResult = (BatchResult<Object, RecordTemplate>) result;
      statuses = batchResult.getStatuses();
      serviceErrors = batchResult.getErrors();
    }

    try
    {
      if (statuses.containsKey(null))
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key inside of a Map returned by the resource method: " + routingResult
                .getResourceMethod());
      }
    }
    catch (NullPointerException e)
    {
      
      
    }

    Map<Object, BatchResponseEntry> batchResult = new HashMap<Object, BatchResponseEntry>(entities.size() + serviceErrors.size());
    for (Map.Entry<Object, RecordTemplate> entity : entities.entrySet())
    {
      if (entity.getKey() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key inside of a Map returned by the resource method: " + routingResult
                .getResourceMethod());
      }

      batchResult.put(entity.getKey(), new BatchResponseEntry(statuses.get(entity.getKey()), entity.getValue()));
    }

    for (Map.Entry<Object, RestLiServiceException> entity : serviceErrors.entrySet())
    {
      if (entity.getKey() == null || entity.getValue() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key inside of a Map returned by the resource method: " + routingResult
                .getResourceMethod());
      }
      batchResult.put(entity.getKey(), new BatchResponseEntry(statuses.get(entity.getKey()), entity.getValue()));
    }

    final Map<Object, RestLiServiceException> contextErrors = ((ServerResourceContext) routingResult.getContext()).getBatchKeyErrors();
    for (Map.Entry<Object, RestLiServiceException> entry : contextErrors.entrySet())
    {
      batchResult.put(entry.getKey(), new BatchResponseEntry(statuses.get(entry.getKey()), entry.getValue()));
    }

    return new BatchResponseEnvelope(batchResult, headers);
  }

  private static <K, V extends RecordTemplate> BatchResponse<AnyRecord> toBatchResponse(Map<K, EntityResponse<V>> entities,
                                                                                        ProtocolVersion protocolVersion)
  {
    final DataMap splitResponseData = new DataMap();
    final DataMap splitResults = new DataMap();
    final DataMap splitStatuses = new DataMap();
    final DataMap splitErrors = new DataMap();

    for (Map.Entry<K, EntityResponse<V>> resultEntry : entities.entrySet())
    {
      final DataMap entityResponseData = resultEntry.getValue().data();
      final String stringKey = URIParamUtils.encodeKeyForBody(resultEntry.getKey(), false, protocolVersion);

      final DataMap entityData = entityResponseData.getDataMap(EntityResponse.ENTITY);
      if (entityData != null)
      {
        CheckedUtil.putWithoutChecking(splitResults, stringKey, entityData);
      }

      final Integer status = entityResponseData.getInteger(EntityResponse.STATUS);
      if (status != null)
      {
        CheckedUtil.putWithoutChecking(splitStatuses, stringKey, status);
      }

      final DataMap error = entityResponseData.getDataMap(EntityResponse.ERROR);
      if (error != null)
      {
        CheckedUtil.putWithoutChecking(splitErrors, stringKey, error);
      }
    }

    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.RESULTS, splitResults);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.STATUSES, splitStatuses);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.ERRORS, splitErrors);

    return new BatchResponse<AnyRecord>(splitResponseData, AnyRecord.class);
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;

import java.util.Map;



public interface RestLiResponseBuilder
{
  PartialRestResponse buildResponse(RoutingResult routingResult,
                                    RestLiResponseEnvelope responseData);

  RestLiResponseEnvelope buildRestLiResponseData(RestRequest request,
                                                 RoutingResult routingResult,
                                                 Object result,
                                                 Map<String, String> headers);
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.jersey.api.uri.UriBuilder;
import com.linkedin.jersey.api.uri.UriComponent;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;


public class CreateResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    return new PartialRestResponse.Builder().entity(responseData.getRecordResponseEnvelope().getRecord())
                                            .headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .build();
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    CreateResponse createResponse = (CreateResponse) result;
    if (createResponse.hasId())
    {
      final ProtocolVersion protocolVersion = ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();
      String stringKey = URIParamUtils.encodeKeyForUri(createResponse.getId(), UriComponent.Type.PATH_SEGMENT, protocolVersion);
      UriBuilder uribuilder = UriBuilder.fromUri(request.getURI());
      uribuilder.path(stringKey);
      headers.put(RestConstants.HEADER_LOCATION, uribuilder.build((Object) null).toString());
    }
    IdResponse<?> idResponse = new IdResponse<Object>(createResponse.getId());

    
    if (createResponse.getStatus() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. HttpStatus is null inside of a CreateResponse from the resource method: "
              + routingResult.getResourceMethod());
    }

    return new RecordResponseEnvelope(createResponse.getStatus(), idResponse, headers);
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope.BatchResponseEntry;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.HashMap;
import java.util.Map;


public final class BatchUpdateResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchUpdateResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  @SuppressWarnings("unchecked")
  public PartialRestResponse buildResponse(RoutingResult routingResult, RestLiResponseEnvelope responseData)
  {
    Map<Object, UpdateStatus> mergedResults = new HashMap<Object, UpdateStatus>();

    final Map<Object, BatchResponseEntry> responses = (Map<Object, BatchResponseEntry>) responseData.getBatchResponseEnvelope().getBatchResponseMap();
    generateResultEntityResponse(routingResult, responses, mergedResults);

    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    final ProtocolVersion protocolVersion =
        ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();

    @SuppressWarnings("unchecked")
    final BatchResponse<AnyRecord> response = toBatchResponse(mergedResults, protocolVersion);
    return builder.entity(response).headers(responseData.getHeaders()).build();
  }

  
  private void generateResultEntityResponse(RoutingResult routingResult, Map<Object, BatchResponseEntry> responses , Map<Object, UpdateStatus> mergedResults)
  {
    for (Map.Entry<?, BatchResponseEntry> entry : responses.entrySet())
    {
      if (entry.getKey() == null || entry.getValue() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null errors Map found inside of the result returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      UpdateStatus status = new UpdateStatus();
      status.setStatus(entry.getValue().getStatus().getCode());
      if (entry.getValue().hasException())
      {
        status.setError(_errorResponseBuilder.buildErrorResponse(entry.getValue().getException()));
      }
      mergedResults.put(entry.getKey(), status);
    }
  }

  @Override
  public RestLiResponseEnvelope buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    @SuppressWarnings({ "unchecked" })
    
    final BatchUpdateResult<Object, ?> updateResult = (BatchUpdateResult<Object, ?>) result;
    final Map<Object, UpdateResponse> results = updateResult.getResults();

    
    if (results == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null Map found inside of the BatchUpdateResult returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    final Map<Object, RestLiServiceException> serviceErrors = updateResult.getErrors();
    if (serviceErrors == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null errors Map found inside of the BatchUpdateResult returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    Map<Object, BatchResponseEntry> batchResponseMap = new HashMap<Object, BatchResponseEntry>();
    for (Map.Entry<Object, UpdateResponse> entry : results.entrySet())
    {
      if (entry.getKey() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key inside of the Map returned inside of the BatchUpdateResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      if (!serviceErrors.containsKey(entry.getKey()))
      {
        batchResponseMap.put(entry.getKey(), new BatchResponseEntry(entry.getValue().getStatus(), (RecordTemplate) null));
      }
    }

    for (Map.Entry<Object, RestLiServiceException> entry : serviceErrors.entrySet())
    {
      if (entry.getKey() == null || entry.getValue() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key or value inside of the Map returned inside of the BatchUpdateResult returned by the resource method: "
          + routingResult.getResourceMethod());
      }
      batchResponseMap.put(entry.getKey(), new BatchResponseEntry(entry.getValue().getStatus(), entry.getValue()));
    }

    for (Map.Entry<Object, RestLiServiceException> entry : ((ServerResourceContext) routingResult.getContext()).getBatchKeyErrors().entrySet())
    {
      batchResponseMap.put(entry.getKey(), new BatchResponseEntry(entry.getValue().getStatus(), entry.getValue()));
    }

    return new BatchResponseEnvelope(batchResponseMap, headers);
  }

  private static <K> BatchResponse<AnyRecord> toBatchResponse(Map<K, UpdateStatus> statuses,
                                                              ProtocolVersion protocolVersion)
  {
    final DataMap splitResponseData = new DataMap();
    final DataMap splitStatuses = new DataMap();
    final DataMap splitErrors = new DataMap();

    for (Map.Entry<K, UpdateStatus> statusEntry : statuses.entrySet())
    {
      final DataMap statusData = statusEntry.getValue().data();
      final String stringKey = URIParamUtils.encodeKeyForBody(statusEntry.getKey(), false, protocolVersion);

      final DataMap error = statusData.getDataMap("error");
      if (error == null)
      {
        
        CheckedUtil.putWithoutChecking(splitStatuses, stringKey, statusData);
      }
      else
      {
        CheckedUtil.putWithoutChecking(splitErrors, stringKey, error);
      }
    }

    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.RESULTS, splitStatuses);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.ERRORS, splitErrors);

    return new BatchResponse<AnyRecord>(splitResponseData, AnyRecord.class);
  }
}

<code block>


package com.linkedin.restli.internal.server.response;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;



public final class BatchResponseEnvelope extends RestLiResponseEnvelope
{
  private Map<?, BatchResponseEntry> _batchResponseMap;

  
  public BatchResponseEnvelope(Map<?, BatchResponseEntry> batchResponseMap, Map<String, String> headers)
  {
    super(HttpStatus.S_200_OK, headers);
    _batchResponseMap = batchResponseMap;
  }

  
  public BatchResponseEnvelope(RestLiServiceException exception, Map<String, String> headers)
  {
    super(exception, headers);
    _batchResponseMap = null;
  }

  
  public void setBatchResponseMap(HttpStatus httpStatus, Map<?, BatchResponseEntry> batchResponseMap)
  {
    super.setStatus(httpStatus);
    _batchResponseMap = batchResponseMap;
  }

  
  public Map<?, BatchResponseEntry> getBatchResponseMap()
  {
    return _batchResponseMap;
  }

  
  public void setException(RestLiServiceException exception)
  {
    super.setException(exception);
    _batchResponseMap = null;
  }

  @Override
  public ResponseType getResponseType()
  {
    return ResponseType.BATCH_ENTITIES;
  }

  
  public static final class BatchResponseEntry
  {
    
    
    
    private RecordTemplate _recordTemplate;

    
    private RestLiServiceException _restLiServiceException;

    
    
    
    
    
    
    private HttpStatus _httpStatus;

    
    public BatchResponseEntry(HttpStatus httpStatus, RecordTemplate recordTemplate)
    {
      _httpStatus = httpStatus;
      _recordTemplate = recordTemplate;
      _restLiServiceException = null;
    }

    
    public BatchResponseEntry(HttpStatus httpStatus, RestLiServiceException exception)
    {
      _httpStatus = httpStatus;
      _recordTemplate = null;
      _restLiServiceException = exception;
    }

    
    public RecordTemplate getRecord()
    {
      return _recordTemplate;
    }

    
    public HttpStatus getStatus()
    {
      return _httpStatus;
    }

    
    public boolean hasException()
    {
      return _restLiServiceException != null;
    }

    
    public RestLiServiceException getException()
    {
      return _restLiServiceException;
    }
  }

  @Override
  public RecordResponseEnvelope getRecordResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CollectionResponseEnvelope getCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public BatchResponseEnvelope getBatchResponseEnvelope()
  {
    return this;
  }

  @Override
  public EmptyResponseEnvelope getEmptyResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }
}

<code block>


package com.linkedin.restli.internal.server.response;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.List;
import java.util.Map;



public final class CollectionResponseEnvelope extends RestLiResponseEnvelope
{
  private List<? extends RecordTemplate> _collectionResponse;
  private RecordTemplate _collectionResponseCustomMetadata;
  private CollectionMetadata _collectionResponsePaging;

  
  public CollectionResponseEnvelope(List<? extends RecordTemplate> collectionResponse,
                                    CollectionMetadata collectionResponsePaging,
                                    RecordTemplate collectionResponseCustomMetadata,
                                    Map<String, String> headers)
  {
    super(HttpStatus.S_200_OK, headers);
    setCollectionResponse(HttpStatus.S_200_OK, collectionResponse, collectionResponsePaging, collectionResponseCustomMetadata);
  }

  
  public CollectionResponseEnvelope(RestLiServiceException exception,
                                    Map<String, String> headers)
  {
    super(exception, headers);
    _collectionResponse = null;
    _collectionResponseCustomMetadata = null;
    _collectionResponsePaging = null;
  }

  
  public List<? extends RecordTemplate> getCollectionResponse()
  {
    return _collectionResponse;
  }

  
  public CollectionMetadata getCollectionResponsePaging()
  {
    return _collectionResponsePaging;
  }

  
  public RecordTemplate getCollectionResponseCustomMetadata()
  {
    return _collectionResponseCustomMetadata;
  }

  
  public void setCollectionResponse(HttpStatus httpStatus,
                                    List<? extends RecordTemplate> collectionResponse,
                                    CollectionMetadata collectionResponsePaging,
                                    RecordTemplate collectionResponseCustomMetadata)
  {
    super.setStatus(httpStatus);
    _collectionResponse = collectionResponse;
    _collectionResponsePaging = collectionResponsePaging;
    _collectionResponseCustomMetadata = collectionResponseCustomMetadata;
  }

  
  public void setException(RestLiServiceException exception)
  {
    super.setException(exception);
    _collectionResponse = null;
    _collectionResponsePaging = null;
    _collectionResponseCustomMetadata = null;
  }

  @Override
  public ResponseType getResponseType()
  {
    return ResponseType.GET_COLLECTION;
  }

  @Override
  public RecordResponseEnvelope getRecordResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CollectionResponseEnvelope getCollectionResponseEnvelope()
  {
    return this;
  }

  @Override
  public CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public BatchResponseEnvelope getBatchResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public EmptyResponseEnvelope getEmptyResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }
}

<code block>


package com.linkedin.restli.internal.server.response;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;



public final class EmptyResponseEnvelope extends RestLiResponseEnvelope
{
  
  public EmptyResponseEnvelope(HttpStatus httpStatus, Map<String, String> headers)
  {
    super(httpStatus, headers);
  }

  
  public EmptyResponseEnvelope(RestLiServiceException exception, Map<String, String> headers)
  {
    super(exception, headers);
  }

  @Override
  public ResponseType getResponseType()
  {
    return ResponseType.STATUS_ONLY;
  }

  @Override
  public RecordResponseEnvelope getRecordResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CollectionResponseEnvelope getCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public BatchResponseEnvelope getBatchResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public EmptyResponseEnvelope getEmptyResponseEnvelope()
  {
    return this;
  }
}
<code block>


package com.linkedin.restli.internal.server.response;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.List;
import java.util.Map;



public final class CreateCollectionResponseEnvelope extends RestLiResponseEnvelope
{
  private List<CollectionCreateResponseItem> _createResponses;

  
  public CreateCollectionResponseEnvelope(List<CollectionCreateResponseItem> createResponse, Map<String, String> headers)
  {
    super(HttpStatus.S_200_OK, headers);
    _createResponses = createResponse;
  }

  
  public CreateCollectionResponseEnvelope(RestLiServiceException exception, Map<String, String> headers)
  {
    super(exception, headers);
    _createResponses = null;
  }

  
  public List<CollectionCreateResponseItem> getCreateResponses()
  {
    return _createResponses;
  }

  
  public void setCreateResponse(HttpStatus httpStatus, List<CollectionCreateResponseItem> createResponse)
  {
    super.setStatus(httpStatus);
    _createResponses = createResponse;
  }

  
  public void setException(RestLiServiceException exception)
  {
    super.setException(exception);
    _createResponses = null;
  }

  @Override
  public ResponseType getResponseType()
  {
    return ResponseType.CREATE_COLLECTION;
  }

  @Override
  public RecordResponseEnvelope getRecordResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CollectionResponseEnvelope getCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope()
  {
    return this;
  }

  @Override
  public BatchResponseEnvelope getBatchResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public EmptyResponseEnvelope getEmptyResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  
  public static final class CollectionCreateResponseItem
  {
    
    
    
    private CreateIdStatus<?> _recordResponse;

    
    private Object _id;
    private RestLiServiceException _exception;

    
    public CollectionCreateResponseItem(CreateIdStatus response)
    {
      setCollectionCreateResponseItem(response);
    }

    
    public CollectionCreateResponseItem(RestLiServiceException exception, Object id)
    {
      setCollectionCreateResponseItem(exception, id);
    }

    
    public void setCollectionCreateResponseItem(CreateIdStatus<?> response)
    {
      _recordResponse = response;

      _id = null;
      _exception = null;
    }

    
    public void setCollectionCreateResponseItem(RestLiServiceException exception, Object id)
    {
      _exception = exception;
      _id = id;

      _recordResponse = null;
    }

    
    public CreateIdStatus<?> getRecord()
    {
      return _recordResponse;
    }

    
    public Object getId()
    {
      return _id;
    }

    
    public boolean isErrorResponse()
    {
      return _exception != null;
    }

    
    public RestLiServiceException getException()
    {
      return _exception;
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.response;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.ResponseType;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;



public final class RecordResponseEnvelope extends RestLiResponseEnvelope
{
  private RecordTemplate _recordResponse;

  
  public RecordResponseEnvelope(HttpStatus httpStatus, RecordTemplate response, Map<String, String> headers)
  {
    super(httpStatus, headers);
    _recordResponse = response;
  }

  
  public RecordResponseEnvelope(RestLiServiceException exception, Map<String, String> headers)
  {
    super(exception, headers);
  }

  
  public RecordTemplate getRecord()
  {
    return _recordResponse;
  }

  
  public void setRecord(RecordTemplate response, HttpStatus httpStatus)
  {
    super.setStatus(httpStatus);
    _recordResponse = response;
  }

  
  public void setException(RestLiServiceException exception)
  {
    super.setException(exception);
    _recordResponse = null;
  }

  @Override
  public ResponseType getResponseType()
  {
    return ResponseType.SINGLE_ENTITY;
  }

  @Override
  public RecordResponseEnvelope getRecordResponseEnvelope()
  {
    return this;
  }

  @Override
  public CollectionResponseEnvelope getCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public CreateCollectionResponseEnvelope getCreateCollectionResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public BatchResponseEnvelope getBatchResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }

  @Override
  public EmptyResponseEnvelope getEmptyResponseEnvelope()
  {
    throw new UnsupportedOperationException();
  }
}

<code block>


package com.linkedin.restli.server.test;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.DataCodec;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.codec.PsonDataCodec;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.data.template.FieldDef;
import com.linkedin.data.template.StringMap;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.CreateStatus;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.Link;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.PathKeysImpl;
import com.linkedin.restli.internal.server.ResourceContextImpl;
import com.linkedin.restli.internal.server.RestLiResponseHandler;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.internal.server.model.Parameter;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor.InterfaceType;
import com.linkedin.restli.internal.server.model.ResourceModel;
import com.linkedin.restli.internal.server.util.DataMapUtils;
import com.linkedin.restli.internal.server.util.RestLiSyntaxException;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.internal.testutils.URIDetails;
import com.linkedin.restli.server.ActionResult;
import com.linkedin.restli.server.BasicCollectionResult;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ResourceLevel;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.annotations.RestLiCollection;
import com.linkedin.restli.server.resources.CollectionResourceTemplate;
import com.linkedin.restli.server.twitter.StatusCollectionResource;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.Status;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import static com.linkedin.restli.server.test.RestLiTestHelper.buildResourceModel;
import static com.linkedin.restli.server.test.RestLiTestHelper.doubleQuote;
import static org.testng.Assert.*;



public class TestRestLiResponseHandler
{
  private final RestLiResponseHandler _responseHandler = new RestLiResponseHandler.Builder().build();

  private static final String APPLICATION_JSON = "application/json";
  private static final String APPLICATION_PSON = "application/x-pson";

  private static final Map<String, String> JSON_ACCEPT_HEADERS  = Collections.singletonMap("Accept", APPLICATION_JSON);
  private static final Map<String, String> PSON_ACCEPT_HEADERS  = Collections.singletonMap("Accept", APPLICATION_PSON);
  private static final Map<String, String> EMPTY_ACCEPT_HEADERS = Collections.emptyMap();
  private static final Map<String, String> ANY_ACCEPT_HEADERS   = Collections.singletonMap("Accept", "*
  private final RoutingResult buildRoutingResultAction(Class<?> actionReturnType, RestRequest request, Map<String, String> headers)
          throws NoSuchMethodException, RestLiSyntaxException, URISyntaxException
  {
    if (actionReturnType == Void.class)
    {
      actionReturnType = Void.TYPE;
    }

    
    Method method = ProjectionTestFixture.class.getMethod("batchGet", Set.class);

    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);

    String actionName = "return" + actionReturnType.getSimpleName();
    List<Parameter<?>> parameters = Collections.<Parameter<?>>emptyList();

    RecordDataSchema actionReturnRecordDataSchema;
    FieldDef<?> returnFieldDef;
    if (actionReturnType != Void.TYPE)
    {
      @SuppressWarnings({"unchecked","rawtypes"})
      FieldDef<?> nonVoidFieldDef = new FieldDef(ActionResponse.VALUE_NAME,
                                 actionReturnType,
                                 DataTemplateUtil.getSchema(actionReturnType));
      returnFieldDef = nonVoidFieldDef;
      actionReturnRecordDataSchema = DynamicRecordMetadata.buildSchema(actionName,
                                                                       Collections.singleton(returnFieldDef));
    }
    else
    {
      returnFieldDef = null;
      actionReturnRecordDataSchema = DynamicRecordMetadata.buildSchema(actionName, Collections.<FieldDef<?>>emptyList());
    }

    ResourceMethodDescriptor methodDescriptor =
            ResourceMethodDescriptor.createForAction(method,
                                                     parameters,
                                                     actionName,
                                                     ResourceLevel.COLLECTION,
                                                     returnFieldDef,
                                                     actionReturnRecordDataSchema,
                                                     DynamicRecordMetadata.buildSchema(actionName, parameters),
                                                     InterfaceType.SYNC,
                                                     new DataMap());

    model.addResourceMethodDescriptor(methodDescriptor);

    ServerResourceContext resourceContext = new ResourceContextImpl(new PathKeysImpl(), request, new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(headers, resourceContext);
    return new RoutingResult(resourceContext, methodDescriptor);
  }

  private final RoutingResult buildRoutingResult(RestRequest request, Map<String, String> acceptHeaders)
          throws SecurityException, NoSuchMethodException, RestLiSyntaxException
  {
    return buildRoutingResult(ResourceMethod.GET, request, acceptHeaders);
  }

  private final RoutingResult buildRoutingResult(ResourceMethod resourceMethod, RestRequest request, Map<String, String> acceptHeaders)
          throws SecurityException, NoSuchMethodException, RestLiSyntaxException
  {
    Method method = ProjectionTestFixture.class.getMethod("batchGet", Set.class);
    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);
    ResourceMethodDescriptor methodDescriptor =
        ResourceMethodDescriptor.createForRestful(resourceMethod, method, InterfaceType.SYNC);
    model.addResourceMethodDescriptor(methodDescriptor);
    ServerResourceContext context =  new ResourceContextImpl(new PathKeysImpl(), request,
                            new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(acceptHeaders, context);
    return new RoutingResult(context, methodDescriptor);
  }


  private final RoutingResult buildRoutingResultFinder(RestRequest request, Map<String, String> acceptHeaders) throws SecurityException,
      NoSuchMethodException,
      RestLiSyntaxException
  {
    Method method = ProjectionTestFixture.class.getMethod("find");
    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);
    ResourceMethodDescriptor methodDescriptor =
        ResourceMethodDescriptor.createForRestful(ResourceMethod.FINDER, method, InterfaceType.SYNC);
    model.addResourceMethodDescriptor(methodDescriptor);
    ServerResourceContext context = new ResourceContextImpl(new PathKeysImpl(), request, new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(acceptHeaders, context);
    return new RoutingResult(context, methodDescriptor);
  }

  @RestLiCollection(name="test")
  private static class ProjectionTestFixture extends CollectionResourceTemplate<Integer, Status>
  {
    @Override
    public Map<Integer, Status> batchGet(Set<Integer> ids)
    {
      return null;
    }

    public BasicCollectionResult<Status> find()
    {
      return null;
    }
  }

  private void checkResponse(PartialRestResponse response,
                             HttpStatus status,
                             int numHeaders,
                             boolean hasError,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    assertEquals(response.getStatus(), status);
    assertEquals(response.getHeaders().size(), numHeaders);
    if (hasError)
    {
      assertEquals(response.getHeader(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(response.getHeader(errorResponseHeaderName));
    }

    assertEquals(response.getEntity() != null, hasEntity);
  }

  private void checkResponseData(RestLiResponseEnvelope responseData, HttpStatus status, int numHeaders,
                                 boolean hasError, boolean hasEntity, String errorResponseHeaderName)
  {
    assertEquals(responseData.getStatus(), status);
    assertEquals(responseData.getHeaders().size(), numHeaders);
    if (hasError)
    {
      assertEquals(responseData.getHeaders().get(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(responseData.getHeaders().get(errorResponseHeaderName));
    }

    assertEquals(responseData.getRecordResponseEnvelope().getRecord() != null, hasEntity);
  }

  private void checkResponse(RestResponse response,
                             int status,
                             int numHeaders,
                             String contentType,
                             String type,
                             String subType,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    checkResponse(response, status, numHeaders, contentType, type, subType, false, hasEntity, errorResponseHeaderName);
  }

  private void checkResponse(RestResponse response,
                             int status,
                             int numHeaders,
                             String contentType,
                             String type,
                             String subType,
                             boolean hasError,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    assertEquals(response.getStatus(), status);
    assertEquals(response.getHeaders().size(), numHeaders);
    assertEquals(response.getHeader(RestConstants.HEADER_CONTENT_TYPE), contentType);

    if (hasError)
    {
      assertEquals(response.getHeader(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(response.getHeader(errorResponseHeaderName));
    }

    assertEquals(response.getEntity().length() > 0, hasEntity);
  }

  private List<Status> buildStatusList(int num)
  {
    List<Status> list = new ArrayList<Status>();
    for (int i = 0; i < num; i++)
    {
      list.add(buildStatusRecord());
    }

    return list;
  }

  private Status buildStatusRecord()
  {
    DataMap map = new DataMap();
    map.put("text", "test status");
    Status status = new Status(map);
    return status;
  }

  private Status buildStatusWithFields(String... fields)
  {
    DataMap map = new DataMap();
    for (String field : fields)
    {
      map.put(field, "value");
    }
    Status status = new Status(map);
    return status;
  }

  private BasicCollectionResult<Status> buildStatusCollectionResult(int numResults,
                                                                    String... fields)
  {

    List<Status> data = buildStatusListResult(numResults, fields);

    return new BasicCollectionResult<Status>(data, numResults);
  }

  private List<Status> buildStatusListResult(int numResults, String... fields)
  {
    List<Status> data = new ArrayList<Status>();

    for (int i = 0; i < numResults; i++)
    {
      Status status = buildStatusWithFields(fields);
      data.add(status);
    }
    return data;
  }


  private Map<Integer, Status> buildStatusBatchResponse(int numResults, String... fields)
  {
    Map<Integer, Status> map = new HashMap<Integer, Status>();

    for (int i = 0; i < numResults; i++)
    {
      Status status = buildStatusWithFields(fields);
      map.put(i, status);
    }

    return map;
  }

  private void checkCollectionResponse(RestResponse response,
                                       int numElements,
                                       int start,
                                       int count,
                                       int numLinks,
                                       Integer total,
                                       URIDetails prevLink,
                                       URIDetails nextLink,
                                       AcceptTypeData acceptTypeData)
          throws Exception
  {
    DataMap dataMap = acceptTypeData.dataCodec.readMap(response.getEntity().asInputStream());
    CollectionResponse<Status> collectionResponse = new CollectionResponse<Status>(dataMap, Status.class);

    assertEquals(collectionResponse.getElements().size(), numElements);
    assertEquals(collectionResponse.getPaging().getStart().intValue(), start);
    assertEquals(collectionResponse.getPaging().getCount().intValue(), count);
    assertEquals(collectionResponse.getPaging().getLinks().size(), numLinks);
    if (total == null)
    {
      assertFalse(collectionResponse.getPaging().hasTotal());
    }
    else
    {
      assertEquals(collectionResponse.getPaging().getTotal().intValue(), total.intValue());
    }
    if (prevLink != null)
    {
      checkLink(collectionResponse.getPaging().getLinks().get(0), "prev", prevLink, acceptTypeData.responseContentType);
    }
    if (nextLink != null)
    {
      int idx = prevLink != null ? 1 : 0;
      checkLink(collectionResponse.getPaging().getLinks().get(idx), "next", nextLink, acceptTypeData.responseContentType);
    }
  }

  private static void checkLink(Link link, String rel, URIDetails expectedURIDetails, String type)
  {
    assertEquals(link.getRel(), rel);
    assertEquals(link.getType(), type);
    URIDetails.testUriGeneration(link.getHref(), expectedURIDetails);
  }

  private static void checkProjectedFields(RestResponse response, String[] expectedFields, String[] missingFields)
          throws UnsupportedEncodingException
  {
    DataMap dataMap = DataMapUtils.readMap(response);

    for (String field : expectedFields)
    {
      assertTrue(DataMapContains(dataMap, field));
    }
    for (String field : missingFields)
    {
      assertFalse(DataMapContains(dataMap, field));
    }
  }

  private static boolean DataMapContains(DataMap data, String field)
  {
    for(String key : data.keySet())
    {
      if (key.equals(field))
        return true;

      Object value = data.get(key);
      if (value instanceof DataMap)
        return DataMapContains((DataMap)value, field);
    }
    return false;

  }

  @SuppressWarnings("unchecked")
  static public <V> Map<String, V> asMap(Object... objects)
  {
    int index = 0;
    String key = null;
    HashMap<String,V> map = new HashMap<String,V>();
    for (Object object : objects)
    {
      if (index % 2 == 0)
      {
        key = (String) object;
      }
      else
      {
        map.put(key, (V) object);
      }
      index++;
    }
    return map;
  }
}

<code block>
package com.linkedin.restli.internal.server;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestRestLiResponseEnvelope
{
  private final RestLiServiceException exception500 = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
  private final RestLiServiceException exception503 = new RestLiServiceException(HttpStatus.S_503_SERVICE_UNAVAILABLE);

  
  @Test (dataProvider = "baseClassOperations")
  public void testRestLiResponseEnvelopeInvariant(RestLiResponseEnvelope responseEnvelope)
  {
    
    Map<String, String> headers = new HashMap<String, String>();
    Assert.assertEquals(responseEnvelope.getHeaders(), headers);
    String headerKey = "testKey";
    String headerValue = "testValue";
    responseEnvelope.getHeaders().put(headerKey, headerValue);
    Assert.assertEquals(responseEnvelope.getHeaders().get(headerKey), headerValue);

    
    if (responseEnvelope.isErrorResponse())
    {
      Assert.assertNotNull(responseEnvelope.getServiceException());
      Assert.assertEquals(responseEnvelope.getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
      responseEnvelope.setException(exception503);
      Assert.assertEquals(responseEnvelope.getServiceException().getStatus(), HttpStatus.S_503_SERVICE_UNAVAILABLE);

      
      responseEnvelope.setStatus(HttpStatus.S_200_OK);
      Assert.assertFalse(responseEnvelope.isErrorResponse());
      Assert.assertEquals(responseEnvelope.getStatus(), HttpStatus.S_200_OK);
    }
    else
    {
      Assert.assertNull(responseEnvelope.getServiceException());
      Assert.assertEquals(responseEnvelope.getStatus(), HttpStatus.S_200_OK);
      responseEnvelope.setStatus(HttpStatus.S_201_CREATED);
      Assert.assertEquals(responseEnvelope.getStatus(), HttpStatus.S_201_CREATED);
    }
  }

  @DataProvider(name = "baseClassOperations")
  public Object[][] provideAllBaseObjects()
  {
    RestLiServiceException exception = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    return new Object[][]
    {
      {new RecordResponseEnvelope(exception, Collections.<String, String>emptyMap())},
      {new BatchResponseEnvelope(exception, Collections.<String, String>emptyMap())},
      {new CreateCollectionResponseEnvelope(exception, Collections.<String, String>emptyMap())},
      {new CollectionResponseEnvelope(exception, Collections.<String, String>emptyMap())},
      {new EmptyResponseEnvelope(exception, Collections.<String, String>emptyMap())},

      {new RecordResponseEnvelope(HttpStatus.S_200_OK, new EmptyRecord(), Collections.<String, String>emptyMap())},
      {new BatchResponseEnvelope(Collections.<Object, BatchResponseEnvelope.BatchResponseEntry>emptyMap(), Collections.<String, String>emptyMap())},
      {new CreateCollectionResponseEnvelope(Collections.<CreateCollectionResponseEnvelope.CollectionCreateResponseItem>emptyList(), Collections.<String, String>emptyMap())},
      {new CollectionResponseEnvelope(Collections.<EmptyRecord>emptyList(), new CollectionMetadata(), null, Collections.<String, String>emptyMap())},
      {new EmptyResponseEnvelope(HttpStatus.S_200_OK, Collections.<String, String>emptyMap())}
    };
  }

  @Test
  public void testRecordResponseEnvelopeUpdates()
  {
    RecordResponseEnvelope record = new RecordResponseEnvelope(HttpStatus.S_200_OK, new EmptyRecord(), Collections.<String, String>emptyMap());
    Assert.assertFalse(record.isErrorResponse());
    Assert.assertEquals(record.getRecord(), new EmptyRecord());

    
    record.setException(exception500);
    Assert.assertNull(record.getRecord());
    Assert.assertEquals(record.getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    Assert.assertEquals(record.getServiceException(), exception500);

    
    record = new RecordResponseEnvelope(HttpStatus.S_200_OK, new EmptyRecord(), Collections.<String, String>emptyMap());
    Assert.assertFalse(record.isErrorResponse());
    Assert.assertEquals(record.getRecord(), new EmptyRecord());
  }

  @Test
  @SuppressWarnings("unchecked")
  public void testCollectionResponseEnvelopeUpdates()
  {
    CollectionResponseEnvelope response = new CollectionResponseEnvelope(Collections.<EmptyRecord>emptyList(),
                                                                         new CollectionMetadata(),
                                                                         new EmptyRecord(),
                                                                         Collections.<String, String>emptyMap());
    Assert.assertFalse(response.isErrorResponse());
    Assert.assertEquals(response.getCollectionResponse(), Collections.<EmptyRecord>emptyList());
    Assert.assertEquals(response.getCollectionResponsePaging(), new CollectionMetadata());
    Assert.assertEquals(response.getCollectionResponseCustomMetadata(), new EmptyRecord());

    
    response.setException(exception500);
    Assert.assertNull(response.getCollectionResponse());
    Assert.assertNull(response.getCollectionResponseCustomMetadata());
    Assert.assertNull(response.getCollectionResponsePaging());
    Assert.assertEquals(response.getServiceException(), exception500);
    Assert.assertEquals(response.getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);

    
    response.setCollectionResponse(HttpStatus.S_200_OK,
                                   new ArrayList<RecordTemplate>(),
                                   new CollectionMetadata(),
                                   new EmptyRecord());
    Assert.assertFalse(response.isErrorResponse());
    Assert.assertEquals(response.getCollectionResponse(), Collections.<EmptyRecord>emptyList());
    Assert.assertEquals(response.getCollectionResponsePaging(), new CollectionMetadata());
    Assert.assertEquals(response.getCollectionResponseCustomMetadata(), new EmptyRecord());

    
    List<EmptyRecord> temp = (List<EmptyRecord>) response.getCollectionResponse();
    temp.add(new EmptyRecord());
    Assert.assertEquals(response.getCollectionResponse().size(), 1);
  }

  @Test
  public void testCreateCollectionResponseEnvelopeUpdates()
  {
    CreateCollectionResponseEnvelope response = new CreateCollectionResponseEnvelope(Collections.<CreateCollectionResponseEnvelope.CollectionCreateResponseItem>emptyList(),
                                                                                     Collections.<String, String>emptyMap());
    Assert.assertNull(response.getServiceException());
    Assert.assertEquals(response.getCreateResponses(), Collections.emptyList());
    Assert.assertFalse(response.isErrorResponse());

    response.setException(exception500);
    Assert.assertNull(response.getCreateResponses());

    response.setCreateResponse(HttpStatus.S_200_OK, new ArrayList<CreateCollectionResponseEnvelope.CollectionCreateResponseItem>());
    Assert.assertNull(response.getServiceException());

    Assert.assertEquals(response.getCreateResponses().size(), 0);
    response.getCreateResponses().add(new CreateCollectionResponseEnvelope.CollectionCreateResponseItem(new CreateIdStatus<Object>(new DataMap(), new Object())));
    response.getCreateResponses().add(new CreateCollectionResponseEnvelope.CollectionCreateResponseItem(exception500, 2));
    Assert.assertEquals(response.getCreateResponses().size(), 2);
  }

  @Test
  public void testBatchResponseEnvelopeUpdates()
  {
    BatchResponseEnvelope response = new BatchResponseEnvelope(Collections.<Object, BatchResponseEnvelope.BatchResponseEntry>emptyMap(), Collections.<String, String>emptyMap());
    Assert.assertFalse(response.isErrorResponse());
    Assert.assertNull(response.getServiceException());

    response.setException(exception500);
    Assert.assertNull(response.getBatchResponseMap());

    Map<Object, BatchResponseEnvelope.BatchResponseEntry> targetMap = new HashMap<Object, BatchResponseEnvelope.BatchResponseEntry>();
    response.setBatchResponseMap(HttpStatus.S_200_OK, targetMap);
    Assert.assertNull(response.getServiceException());
    targetMap.put("key", new BatchResponseEnvelope.BatchResponseEntry(null, new EmptyRecord()));
    Assert.assertEquals(response.getBatchResponseMap().size(), 1);
    Assert.assertEquals(response.getBatchResponseMap().get("key").getRecord(), new EmptyRecord());
  }
}
<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Collections;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;


public class TestRestLiResponseEnvelopeExceptions
{
  @DataProvider(name = "restliResponseEnvelope")
  public Object[][] provideRestLiResponseEnvelope()
  {
    RestLiServiceException exception = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    RecordResponseEnvelope recordResponse = new RecordResponseEnvelope(exception, Collections.<String, String>emptyMap());
    CollectionResponseEnvelope collectionResponse = new CollectionResponseEnvelope(exception, Collections.<String, String>emptyMap());
    CreateCollectionResponseEnvelope collectionCreateResponse = new CreateCollectionResponseEnvelope(exception, Collections.<String, String>emptyMap());
    BatchResponseEnvelope batchResponse = new BatchResponseEnvelope(exception, Collections.<String, String>emptyMap());
    EmptyResponseEnvelope emptyResponse = new EmptyResponseEnvelope(exception, Collections.<String, String>emptyMap());

    return new Object[][]{
        {recordResponse},
        {collectionResponse},
        {collectionCreateResponse},
        {batchResponse},
        {emptyResponse}
    };
  }

  @Test(dataProvider = "restliResponseEnvelope")
  public void testUnsupportedOperations(RestLiResponseEnvelope data)
  {
    
    ResponseType type = data.getResponseType();
    try
    {
      data.getRecordResponseEnvelope();
      if (type != ResponseType.SINGLE_ENTITY)
      {
        Assert.fail();
      }
      else
      {
        Assert.assertEquals(data.getRecordResponseEnvelope(), data);
      }
    }
    catch (UnsupportedOperationException e)
    {
      if (type == ResponseType.SINGLE_ENTITY) Assert.fail();
    }

    try
    {
      data.getCollectionResponseEnvelope();
      if (type != ResponseType.GET_COLLECTION)
      {
        Assert.fail();
      }
      else
      {
        Assert.assertEquals(data.getCollectionResponseEnvelope(), data);
      }
    }
    catch (UnsupportedOperationException e)
    {
      if (type == ResponseType.GET_COLLECTION) Assert.fail();
    }

    try
    {
      data.getCreateCollectionResponseEnvelope();
      if (type != ResponseType.CREATE_COLLECTION)
      {
        Assert.fail();
      }
      else
      {
        Assert.assertEquals(data.getCreateCollectionResponseEnvelope(), data);
      }
    }
    catch (UnsupportedOperationException e)
    {
      if (type == ResponseType.CREATE_COLLECTION) Assert.fail();
    }

    try
    {
      data.getBatchResponseEnvelope();
      if (type != ResponseType.BATCH_ENTITIES)
      {
        Assert.fail();
      }
      else
      {
        Assert.assertEquals(data.getBatchResponseEnvelope(), data);
      }
    }
    catch (UnsupportedOperationException e)
    {
      if (type == ResponseType.BATCH_ENTITIES) Assert.fail();
    }

    try
    {
      data.getEmptyResponseEnvelope();
      if (type != ResponseType.STATUS_ONLY)
      {
        Assert.fail();
      }
      else
      {
        Assert.assertEquals(data.getEmptyResponseEnvelope(), data);
      }
    }
    catch (UnsupportedOperationException e)
    {
      if (type == ResponseType.STATUS_ONLY) Assert.fail();
    }
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.server.filter.FilterResponseContextInternal;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.internal.server.response.BatchResponseEnvelope;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.CollectionResponseEnvelope;
import com.linkedin.restli.internal.server.response.EmptyResponseEnvelope;
import com.linkedin.restli.internal.server.response.RecordResponseEnvelope;
import com.linkedin.restli.server.RequestExecutionCallback;
import com.linkedin.restli.server.RequestExecutionReport;
import com.linkedin.restli.server.RequestExecutionReportBuilder;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.collect.Maps;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyMap;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.testng.Assert.*;



public class TestRestLiCallback
{
  @Mock
  private RestRequest _restRequest;
  @Mock
  private RoutingResult _routingResult;
  @Mock
  private RestLiResponseHandler _responseHandler;
  @Mock
  private RequestExecutionCallback<RestResponse> _callback;

  private RestLiCallback<Object> _noFilterRestLiCallback;

  private RestLiCallback<Object> _twoFilterRestLiCallback;

  @Mock
  private FilterRequestContext _filterRequestContext;

  @Mock
  private ResponseFilter _filter;

  @BeforeTest
  protected void setUp() throws Exception
  {
    MockitoAnnotations.initMocks(this);
    _noFilterRestLiCallback =
        new RestLiCallback<Object>(_restRequest, _routingResult, _responseHandler, _callback, null, null);
    _twoFilterRestLiCallback =
        new RestLiCallback<Object>(_restRequest, _routingResult, _responseHandler, _callback, Arrays.asList(_filter,
                                                                                                            _filter),
                                   _filterRequestContext);
  }

  @AfterMethod
  protected void resetMocks()
  {
    reset(_filter, _filterRequestContext, _restRequest, _routingResult, _responseHandler, _callback);
  }

  @Test
  public void testOnSuccessNoFilters() throws Exception
  {
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, null, Collections.<String, String>emptyMap());
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    RestResponse restResponse = new RestResponseBuilder().build();
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);

    
    _noFilterRestLiCallback.onSuccess(result, executionReport);

    
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verifyZeroInteractions(_restRequest, _routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorRestLiServiceExceptionNoFilters() throws Exception
  {
    RestLiServiceException ex = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    Map<String, String> inputHeaders = Maps.newHashMap();
    inputHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION,
                     AllProtocolVersions.BASELINE_PROTOCOL_VERSION.toString());

    Map<String, String> restExceptionHeaders = Maps.newHashMap();
    restExceptionHeaders.put("foo", "bar");

    @SuppressWarnings("rawtypes")
    ArgumentCaptor<Map> augErrorHeadersCapture = ArgumentCaptor.forClass(Map.class);
    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(ex, restExceptionHeaders);

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    RestException restException = new RestException(new RestResponseBuilder().build());
    
    when(_restRequest.getHeaders()).thenReturn(inputHeaders);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), eq(ex),
             augErrorHeadersCapture.capture())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildRestException(ex, partialResponse)).thenReturn(restException);

    
    _noFilterRestLiCallback.onError(ex, executionReport);

    
    verify(_responseHandler).buildRestException(ex, partialResponse);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult), eq(ex),
        augErrorHeadersCapture.capture());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    Map<String, String> augErrorHeaders = augErrorHeadersCapture.getValue();
    assertNotNull(augErrorHeaders);
    assertFalse(augErrorHeaders.isEmpty());
    assertTrue(augErrorHeaders.containsKey(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION));
    assertEquals(augErrorHeaders.get(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION),
                 AllProtocolVersions.BASELINE_PROTOCOL_VERSION.toString());
    String errorHeaderName = HeaderUtil.getErrorResponseHeaderName(inputHeaders);
    assertTrue(augErrorHeaders.containsKey(errorHeaderName));
    assertEquals(augErrorHeaders.get(errorHeaderName), RestConstants.HEADER_VALUE_ERROR);
  }

  @DataProvider(name = "provideExceptions")
  private Object[][] provideExceptions()
  {
    return new Object[][] { { new RuntimeException("Test runtime exception") },
        { new RoutingException("Test routing exception", 404) },
        { new RestException(new RestResponseBuilder().setStatus(404).build()) },
        { new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Test service exception") },
        { new RestLiServiceException(HttpStatus.S_403_FORBIDDEN, "Wrapped runtime exception with custom status",
            new RuntimeException("Original cause")) } };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideExceptions")
  public void testOnErrorOtherExceptionNoFilters(Exception ex) throws Exception
  {
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, null, Collections.<String, String>emptyMap());
    RestException restException = new RestException(new RestResponseBuilder().build());
    Map<String, String> inputHeaders = Maps.newHashMap();
    inputHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, "2.0.0");

    
    when(_restRequest.getHeaders()).thenReturn(inputHeaders);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildRestException(ex, partialResponse)).thenReturn(restException);

    
    _noFilterRestLiCallback.onError(ex, executionReport);

    
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestException(ex, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    if (ex instanceof RoutingException)
    {
      assertEquals(HttpStatus.fromCode(((RoutingException) ex).getStatus()), restliEx.getStatus());
    }
    else if (ex instanceof RestLiServiceException)
    {
      assertEquals(((RestLiServiceException) ex).getStatus(), restliEx.getStatus());
    }
    else
    {
      assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    }
    assertEquals(ex.getMessage(), restliEx.getMessage());
    if (ex instanceof RestLiServiceException)
    {
      assertEquals(ex, restliEx);
    }
    else
    {
      assertEquals(ex, restliEx.getCause());
    }
  }

  @Test
  public void testOnSuccessWithFiltersSuccessful() throws Exception
  {
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "One");
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final RecordTemplate entityFromFilter1 = Foo.createFoo("Key", "Two");
    final RecordTemplate entityFromFilter2 = Foo.createFoo("Key", "Three");
    final Map<String, String> headersFromFilters = Maps.newHashMap();
    headersFromFilters.put("Key", "Output");
    RestLiResponseEnvelope appResponseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, entityFromApp, headersFromApp);
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();

    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(appResponseData);
    when(_responseHandler.buildPartialResponse(_routingResult, appResponseData)).thenReturn(partialResponse);
    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_200_OK, context.getResponseData().getStatus());
        assertEquals(headersFromApp, context.getResponseData().getHeaders());
        assertEquals(entityFromApp, context.getResponseData().getRecordResponseEnvelope().getRecord());
        
        setStatus(context, HttpStatus.S_400_BAD_REQUEST);
        context.getResponseData().getRecordResponseEnvelope().setRecord(entityFromFilter1,
            HttpStatus.S_400_BAD_REQUEST);
        context.getResponseData().getHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getResponseData().getStatus());
        assertTrue(context.getResponseData().getHeaders().isEmpty());
        assertEquals(context.getResponseData().getRecordResponseEnvelope().getRecord(), entityFromFilter1);
        
        setStatus(context, HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().getRecordResponseEnvelope().setRecord(entityFromFilter2, HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().getHeaders().putAll(headersFromFilters);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    RestResponse restResponse = new RestResponseBuilder().build();
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);

    
    _twoFilterRestLiCallback.onSuccess(result, executionReport);

    
    assertNotNull(appResponseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, appResponseData.getStatus());
    assertEquals(entityFromFilter2, appResponseData.getRecordResponseEnvelope().getRecord());
    assertEquals(headersFromFilters, appResponseData.getHeaders());
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildPartialResponse(_routingResult, appResponseData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verifyZeroInteractions(_restRequest, _routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromFirstFilterSecondFilterHandlesEx() throws Exception
  {
    
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "One");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiResponseEnvelope appResponseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, entityFromApp, Collections.<String, String>emptyMap());

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    final RestLiServiceException exceptionFromFilter = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    RestLiResponseEnvelope responseErrorData = new RecordResponseEnvelope(exceptionFromFilter, headersFromFilter);
    final RecordTemplate entityFromFilter = Foo.createFoo("Key", "Two");
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Exception From Filter");
    
    RestResponse restResponse = new RestResponseBuilder().build();
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, entityFromApp)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(responseErrorData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseErrorData)).thenReturn(partialFilterErrorResponse);

    when(_responseHandler.buildResponse(_routingResult, partialFilterErrorResponse)).thenReturn(restResponse);
    
    doThrow(exFromFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        assertEquals(context.getResponseData().getHeaders(), headersFromFilter);
        assertEquals(context.getResponseData().getServiceException(), exceptionFromFilter);

        
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        context.getResponseData().getRecordResponseEnvelope().setRecord(entityFromFilter,
            HttpStatus.S_402_PAYMENT_REQUIRED);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(entityFromApp, executionReport);

    
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, entityFromApp);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildResponse(_routingResult, partialFilterErrorResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    assertFalse(responseErrorData.isErrorResponse());
    assertEquals(responseErrorData.getRecordResponseEnvelope().getRecord(), entityFromFilter);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(responseErrorData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseErrorData.getStatus());
    assertEquals(responseErrorData.getHeaders(), headersFromFilter);
    assertNull(responseErrorData.getServiceException());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromFirstFilterSecondFilterDoesNotHandleEx() throws Exception
  {
    
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "Two");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiResponseEnvelope appResponseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, entityFromApp, Collections.<String, String>emptyMap());

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    RestLiServiceException exceptionFromFilter = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    RestLiResponseEnvelope responseErrorData = new RecordResponseEnvelope(exceptionFromFilter, headersFromFilter);
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Exception From Filter");

    
    RestException finalRestException = new RestException(new RestResponseBuilder().build());
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, entityFromApp)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(responseErrorData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseErrorData)).thenReturn(partialFilterErrorResponse);
    when(_responseHandler.buildRestException(exFromFilter, partialFilterErrorResponse)).thenReturn(finalRestException);    
    doThrow(exFromFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        assertEquals(context.getResponseData().getHeaders(), headersFromFilter);

        
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(entityFromApp, executionReport);

    
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, entityFromApp);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildRestException(exFromFilter, partialFilterErrorResponse);
    verify(_callback).onError(finalRestException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(responseErrorData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseErrorData.getStatus());
    assertEquals(responseErrorData.getHeaders(), headersFromFilter);
    assertNull(responseErrorData.getRecordResponseEnvelope().getRecord());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromSecondFilter() throws Exception
  {
    
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiResponseEnvelope appResponseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, null, Collections.<String, String>emptyMap());

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    RestLiResponseEnvelope filterResponseData = new RecordResponseEnvelope(new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR), headersFromFilter);
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Excepiton From Filter");

    
    RestException finalRestException = new RestException(new RestResponseBuilder().build());
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(filterResponseData);
    when(_responseHandler.buildPartialResponse(_routingResult, filterResponseData)).thenReturn(partialFilterErrorResponse);
    when(_responseHandler.buildRestException(exFromFilter, partialFilterErrorResponse)).thenReturn(finalRestException);
    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_200_OK);
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        assertTrue(context.getResponseData().getHeaders().isEmpty());
        
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        return null;
      }
    }).doThrow(exFromFilter).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(result, executionReport);

    
    verify(_responseHandler).buildPartialResponse(_routingResult, filterResponseData);
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, filterResponseData);
    verify(_responseHandler).buildRestException(exFromFilter, partialFilterErrorResponse);
    verify(_callback).onError(finalRestException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(filterResponseData);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, filterResponseData.getStatus());
    assertEquals(filterResponseData.getHeaders(), headersFromFilter);
    assertNull(filterResponseData.getRecordResponseEnvelope().getRecord());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersNotHandlingAppEx() throws Exception
  {
    Exception exFromApp = new RuntimeException("Runtime exception from app");
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Output");

    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(appException, headersFromApp);
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_404_NOT_FOUND, context.getResponseData().getStatus());
        assertEquals(headersFromApp, context.getResponseData().getHeaders());
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        
        setStatus(context, HttpStatus.S_400_BAD_REQUEST);
        context.getResponseData().getHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getResponseData().getStatus());
        assertTrue(context.getResponseData().getHeaders().isEmpty());
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        
        setStatus(context, HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().getHeaders().putAll(headersFromFilter);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));
    RestException restException = new RestException(new RestResponseBuilder().build());
    when(_responseHandler.buildRestException(exFromApp, partialResponse)).thenReturn(restException);
    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);
    
    assertNotNull(responseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, responseData.getStatus());
    assertNull(responseData.getRecordResponseEnvelope().getRecord());
    assertTrue(responseData.isErrorResponse());
    assertEquals(responseData.getServiceException().getErrorDetails(), appException.getErrorDetails());
    assertEquals(responseData.getServiceException().getOverridingFormat(), appException.getOverridingFormat());
    assertEquals(responseData.getServiceException().getServiceErrorCode(), appException.getServiceErrorCode());
    assertEquals(responseData.getServiceException().getMessage(), appException.getMessage());

    assertEquals(headersFromFilter, responseData.getHeaders());
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestException(exFromApp, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    assertEquals(exFromApp, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersSuccessfulyHandlingAppEx() throws Exception
  {
    Exception exFromApp = new RuntimeException("Runtime exception from app");
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final RecordTemplate entityFromFilter = Foo.createFoo("Key", "Two");
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Output");

    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(appException, headersFromApp);

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_404_NOT_FOUND, context.getResponseData().getStatus());
        assertEquals(headersFromApp, context.getResponseData().getHeaders());
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        
        setStatus(context, HttpStatus.S_400_BAD_REQUEST);
        context.getResponseData().getHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getResponseData().getStatus());
        assertTrue(context.getResponseData().getHeaders().isEmpty());
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        
        setStatus(context, HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().getRecordResponseEnvelope().setRecord(entityFromFilter, HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().getHeaders().putAll(headersFromFilter);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    RestResponse restResponse = new RestResponseBuilder().build();
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);


    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);
    
    assertNotNull(responseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, responseData.getStatus());
    assertEquals(entityFromFilter, responseData.getRecordResponseEnvelope().getRecord());
    assertEquals(headersFromFilter, responseData.getHeaders());
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    assertEquals(exFromApp, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersExceptionFromFirstFilterSecondFilterDoesNotHandle() throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RestLiResponseEnvelope responseAppData = new RecordResponseEnvelope(appException, Collections.<String, String>emptyMap());

    
    final Exception exFromFirstFilter = new RuntimeException("Runtime exception from first filter");
    RestLiServiceException filterException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    RestLiResponseEnvelope responseFilterData = new RecordResponseEnvelope(filterException, Collections.<String, String>emptyMap());

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestException restException = new RestException(new RestResponseBuilder().build());

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(_responseHandler.buildRestException(exFromFirstFilter, partialResponse)).thenReturn(restException);

    
    doThrow(exFromFirstFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        assertTrue(context.getResponseData().getHeaders().isEmpty());
        assertTrue(context.getResponseData().isErrorResponse());

        
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildRestException(exFromFirstFilter, partialResponse);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseFilterData.getStatus());
    assertTrue(responseFilterData.getHeaders().isEmpty());
    assertNull(responseFilterData.getRecordResponseEnvelope().getRecord());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFirstFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFirstFilter, restliEx.getCause());
  }

  @DataProvider(name = "provideResponseEntities")
  private Object[][] provideResponseEntities()
  {
    List<Foo> fooCollection = new ArrayList<Foo>();
    fooCollection.add(Foo.createFoo("Key", "One"));
    fooCollection.add(Foo.createFoo("Key", "Two"));
    fooCollection.add(Foo.createFoo("Key", "Three"));
    Map<String, Foo> fooBatch = new HashMap<String, Foo>();
    fooBatch.put("batchKey1", Foo.createFoo("Key", "One"));
    fooBatch.put("batchKey2", Foo.createFoo("Key", "Two"));
    return new Object[][] {
        { ResourceMethod.GET, Foo.createFoo("Key", "One") },
        { ResourceMethod.FINDER, fooCollection },
        { ResourceMethod.BATCH_GET, fooBatch }
    };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideResponseEntities")
  public void testOnErrorWithFiltersExceptionFromFirstFilterSecondFilterHandles(final ResourceMethod resourceMethod, final Object entityFromFilter2) throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);

    RestLiResponseEnvelope responseAppData;
    switch (ResponseType.fromMethodType(resourceMethod))
    {
      case SINGLE_ENTITY:
        responseAppData = new RecordResponseEnvelope(appException, Collections.<String, String>emptyMap());
        break;
      case GET_COLLECTION:
        responseAppData = new CollectionResponseEnvelope(appException, Collections.<String, String>emptyMap());
        break;
      case CREATE_COLLECTION:
        responseAppData = new CreateCollectionResponseEnvelope(appException, Collections.<String, String>emptyMap());
        break;
      case BATCH_ENTITIES:
        responseAppData = new BatchResponseEnvelope(appException, Collections.<String, String>emptyMap());
        break;
      case STATUS_ONLY:
        responseAppData = new EmptyResponseEnvelope(appException, Collections.<String, String>emptyMap());
        break;
      default:
        throw new IllegalStateException();
    }

    
    final Exception exFromFirstFilter = new RuntimeException("Runtime exception from first filter");
    RestLiServiceException filterException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, AllProtocolVersions.LATEST_PROTOCOL_VERSION.toString());
    String errorResponseHeaderName = HeaderUtil.getErrorResponseHeaderName(AllProtocolVersions.LATEST_PROTOCOL_VERSION);
    headersFromFilter.put(errorResponseHeaderName, RestConstants.HEADER_VALUE_ERROR);

    RestLiResponseEnvelope responseFilterData;
    switch (ResponseType.fromMethodType(resourceMethod))
    {
      case SINGLE_ENTITY:
        responseFilterData = new RecordResponseEnvelope(filterException, headersFromFilter);
        break;
      case GET_COLLECTION:
        responseFilterData = new CollectionResponseEnvelope(filterException, headersFromFilter);
        break;
      case CREATE_COLLECTION:
        responseFilterData = new CreateCollectionResponseEnvelope(filterException, headersFromFilter);
        break;
      case BATCH_ENTITIES:
        responseFilterData = new BatchResponseEnvelope(filterException, headersFromFilter);
        break;
      case STATUS_ONLY:
        responseFilterData = new EmptyResponseEnvelope(filterException, headersFromFilter);
        break;
      default:
        throw new IllegalStateException();
    }

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestResponse restResponse = new RestResponseBuilder().build();
    final String customHeader = "Custom-Header";
    final String customHeaderValue = "CustomValue";

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);
    when(_restRequest.getHeaders()).thenReturn(null);

    
    doThrow(exFromFirstFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);

        switch (ResponseType.fromMethodType(resourceMethod))
        {
          case SINGLE_ENTITY:
            assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
            break;
          case GET_COLLECTION:
            assertNull(context.getResponseData().getCollectionResponseEnvelope().getCollectionResponse());
            break;
          case CREATE_COLLECTION:
            assertNull(context.getResponseData().getCreateCollectionResponseEnvelope().getCreateResponses());
            break;
          case BATCH_ENTITIES:
            assertNull(context.getResponseData().getBatchResponseEnvelope().getBatchResponseMap());
            break;
          case STATUS_ONLY:
            break;
        }

        assertEquals(context.getResponseData().getHeaders(), headersFromFilter);
        assertTrue(context.getResponseData().isErrorResponse());

        
        context.getResponseData().getHeaders().put(customHeader, customHeaderValue);
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        
        if (entityFromFilter2 instanceof RecordTemplate)
        {
          context.getResponseData().getRecordResponseEnvelope().setRecord((RecordTemplate) entityFromFilter2,
              HttpStatus.S_402_PAYMENT_REQUIRED);
        }
        else if (entityFromFilter2 instanceof List)
        {
          context.getResponseData().getCollectionResponseEnvelope().setCollectionResponse(HttpStatus.S_402_PAYMENT_REQUIRED,
                                                                                          (List<? extends RecordTemplate>) entityFromFilter2,
                                                                                          new CollectionMetadata(),
                                                                                          null);
        }
        else
        {
          Map<Object, BatchResponseEnvelope.BatchResponseEntry> responseMap =  new HashMap<Object, BatchResponseEnvelope.BatchResponseEntry>();
          for (Map.Entry<?, RecordTemplate> entry : ((Map<?, RecordTemplate>) entityFromFilter2).entrySet())
          {
            responseMap.put(entry.getKey(), new BatchResponseEnvelope.BatchResponseEntry(HttpStatus.S_200_OK, entry.getValue()));
          }

          context.getResponseData().getBatchResponseEnvelope().setBatchResponseMap(HttpStatus.S_402_PAYMENT_REQUIRED,
              responseMap);
        }
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseFilterData.getStatus());
    
    assertFalse(responseFilterData.getHeaders().containsKey(errorResponseHeaderName));
    assertEquals(responseFilterData.getHeaders().get(customHeader), customHeaderValue);
    if (entityFromFilter2 instanceof RecordTemplate)
    {
      assertTrue(responseFilterData.getResponseType() == ResponseType.SINGLE_ENTITY);
      assertEquals(responseFilterData.getRecordResponseEnvelope().getRecord(), entityFromFilter2);
    }
    else if (entityFromFilter2 instanceof List)
    {
      if (responseFilterData.getResponseType() == ResponseType.GET_COLLECTION)
      {
        assertEquals(responseFilterData.getCollectionResponseEnvelope().getCollectionResponse(), entityFromFilter2);
      }
      else
      {
        fail();
      }
    }
    else
    {
      assertTrue(responseFilterData.getResponseType() == ResponseType.BATCH_ENTITIES);

      Map<Object, RecordTemplate> values = new HashMap<Object, RecordTemplate>();
      for(Map.Entry<?, BatchResponseEnvelope.BatchResponseEntry> entry: responseFilterData.getBatchResponseEnvelope().getBatchResponseMap().entrySet())
      {
        values.put(entry.getKey(), entry.getValue().getRecord());
      }

      assertEquals(values, entityFromFilter2);
    }
    assertFalse(responseFilterData.isErrorResponse());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFirstFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFirstFilter, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersExceptionFromSecondFilter() throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiResponseEnvelope responseAppData = new RecordResponseEnvelope(exFromApp, Collections.<String, String>emptyMap());

    
    final Exception exFromSecondFilter = new RuntimeException("Runtime exception from second filter");
    RestLiResponseEnvelope responseFilterData = new RecordResponseEnvelope(new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
                                                                                                      exFromSecondFilter),
                                                                           Collections.<String, String>emptyMap());

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();

    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestException restException = new RestException(new RestResponseBuilder().build());

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(_responseHandler.buildRestException(exFromSecondFilter, partialResponse)).thenReturn(restException);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        assertEquals(context.getResponseData().getStatus(), HttpStatus.S_404_NOT_FOUND);
        assertNull(context.getResponseData().getRecordResponseEnvelope().getRecord());
        assertTrue(context.getResponseData().getHeaders().isEmpty());

        
        setStatus(context, HttpStatus.S_402_PAYMENT_REQUIRED);
        return null;
      }
    }).doThrow(exFromSecondFilter).when(_filter)
      .onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_responseHandler).buildRestException(exFromSecondFilter, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, responseFilterData.getStatus());
    assertTrue(responseFilterData.getHeaders().isEmpty());
    assertNull(responseFilterData.getRecordResponseEnvelope().getRecord());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromSecondFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromSecondFilter, restliEx.getCause());
  }

  @Test
  public void testFilterResponseContextAdapter()
  {
    DataMap dataMap = new DataMap();
    dataMap.put("foo", "bar");
    Map<String, String> headers = Maps.newHashMap();
    headers.put("x", "y");
    RecordTemplate entity1 = new Foo(dataMap);
    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(HttpStatus.S_200_OK, entity1, headers);
    RestLiResponseEnvelope updatedResponseData = new EmptyResponseEnvelope(HttpStatus.S_200_OK, Collections.<String, String>emptyMap());
    FilterResponseContext context = new RestLiCallback.FilterResponseContextAdapter(responseData);
    assertEquals(headers, context.getResponseData().getHeaders());
    assertEquals(entity1, context.getResponseData().getRecordResponseEnvelope().getRecord());
    assertEquals(HttpStatus.S_200_OK, context.getResponseData().getStatus());

    Foo entity2 = Foo.createFoo("boo", "bar");
    context.getResponseData().getRecordResponseEnvelope().setRecord(entity2, HttpStatus.S_404_NOT_FOUND);
    assertEquals(context.getResponseData().getRecordResponseEnvelope().getRecord(), entity2);
    assertEquals(HttpStatus.S_404_NOT_FOUND, context.getResponseData().getStatus());
    assertEquals(HttpStatus.S_404_NOT_FOUND, responseData.getStatus());
    assertEquals(responseData, context.getResponseData());
    assertEquals(responseData, ((FilterResponseContextInternal) context).getRestLiResponseEnvelope());
    ((FilterResponseContextInternal) context).setRestLiResponseEnvelope(updatedResponseData);
    assertEquals(updatedResponseData, ((FilterResponseContextInternal) context).getRestLiResponseEnvelope());
  }

  @DataProvider(name = "provideExceptionsAndStatuses")
  private Object[][] provideExceptionsAndStatuses()
  {
    return new Object[][] {
        { new RuntimeException("Test runtime exception"), HttpStatus.S_500_INTERNAL_SERVER_ERROR },
        { new RoutingException("Test routing exception", 404), HttpStatus.S_404_NOT_FOUND},
        { new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Test service exception"), HttpStatus.S_400_BAD_REQUEST },
        { new RestLiServiceException(HttpStatus.S_403_FORBIDDEN, "Wrapped runtime exception with custom status",
            new RuntimeException("Original cause")), HttpStatus.S_403_FORBIDDEN }
    };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideExceptionsAndStatuses")
  public void testConvertExceptionToRestLiResponseData(Exception e, HttpStatus status)
  {
    RestLiServiceException serviceException;
    if (e instanceof RestLiServiceException)
    {
      serviceException = (RestLiServiceException) e;
    }
    else
    {
      serviceException = new RestLiServiceException(status, e);
    }
    RestLiResponseEnvelope responseData = new RecordResponseEnvelope(serviceException, Collections.<String, String>emptyMap());
    ArgumentCaptor<RestLiServiceException> exceptionArgumentCaptor = ArgumentCaptor.forClass(RestLiServiceException.class);

    
    when(_responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exceptionArgumentCaptor.capture(),
        anyMap())).thenReturn(responseData);
    when(_restRequest.getHeaders()).thenReturn(null);

    
    RestLiResponseEnvelope resultData = _noFilterRestLiCallback.convertExceptionToRestLiResponseData(e);

    
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exceptionArgumentCaptor.capture(),
        anyMap());
    verify(_restRequest).getHeaders();
    verifyNoMoreInteractions(_responseHandler, _restRequest);
    verifyZeroInteractions(_routingResult, _callback);
    
    RestLiServiceException exceptionArgument = exceptionArgumentCaptor.getValue();
    assertTrue(exceptionArgument.equals(e) || exceptionArgument.getCause().equals(e));
    assertEquals(exceptionArgument.getStatus(), status);
    
    assertTrue(resultData.isErrorResponse());
    assertTrue(resultData.getServiceException().equals(e) || resultData.getServiceException().getCause().equals(e));
    assertEquals(resultData.getServiceException().getStatus(), status);
  }

  private static class Foo extends RecordTemplate
  {
    private Foo(DataMap map)
    {
      super(map, null);
    }

    public static Foo createFoo(String key, String value)
    {
      DataMap dataMap = new DataMap();
      dataMap.put(key, value);
      return new Foo(dataMap);
    }
  }

  
  private static void setStatus(FilterResponseContext context, HttpStatus status)
  {
    if (context.getResponseData().isErrorResponse())
    {
      RestLiServiceException exception = new RestLiServiceException(status);
      switch (context.getResponseData().getResponseType())
      {
        case SINGLE_ENTITY:
          context.getResponseData().getRecordResponseEnvelope().setException(exception);
          break;
        case GET_COLLECTION:
          context.getResponseData().getCollectionResponseEnvelope().setException(exception);
          break;
        case CREATE_COLLECTION:
          context.getResponseData().getCreateCollectionResponseEnvelope().setException(exception);
          break;
        case BATCH_ENTITIES:
          context.getResponseData().getBatchResponseEnvelope().setException(exception);
          break;
        case STATUS_ONLY:
          context.getResponseData().getEmptyResponseEnvelope().setException(exception);
          break;
      }
    }
    else
    {
      switch (context.getResponseData().getResponseType())
      {
        case SINGLE_ENTITY:
          context.getResponseData().getRecordResponseEnvelope().setStatus(status);
          break;
        case GET_COLLECTION:
          context.getResponseData().getCollectionResponseEnvelope().setStatus(status);
          break;
        case CREATE_COLLECTION:
          context.getResponseData().getCreateCollectionResponseEnvelope().setStatus(status);
          break;
        case BATCH_ENTITIES:
          context.getResponseData().getBatchResponseEnvelope().setStatus(status);
          break;
        case STATUS_ONLY:
          context.getResponseData().getEmptyResponseEnvelope().setStatus(status);
          break;
      }
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.pegasus.generator.examples.Fruits;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;

import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestGetResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    DataMap projectionDataMap = new DataMap();
    projectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree maskTree = new MaskTree(projectionDataMap);

    ProjectionMode manual = ProjectionMode.MANUAL;
    ProjectionMode auto = ProjectionMode.AUTOMATIC;

    return new Object[][]
        {
            
            {getRecord(), HttpStatus.S_200_OK, null, auto},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, null, auto},

            
            {getRecord(), HttpStatus.S_200_OK, null, manual},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, null, manual},

            
            {getRecord(), HttpStatus.S_200_OK, maskTree, manual},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, maskTree, manual},

            
            {getRecord(), HttpStatus.S_200_OK, maskTree, auto},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, maskTree, auto}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(Object record, HttpStatus expectedHttpStatus, MaskTree maskTree, ProjectionMode projectionMode)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceContext mockContext = getMockResourceContext(maskTree, projectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();

    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    GetResponseBuilder getResponseBuilder = new GetResponseBuilder();

    RestLiResponseEnvelope responseData = getResponseBuilder.buildRestLiResponseData(null,
                                                                                          routingResult,
                                                                                          record,
                                                                                          headers);

    PartialRestResponse partialRestResponse = getResponseBuilder.buildResponse(null, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, headers);
    Assert.assertEquals(partialRestResponse.getStatus(), expectedHttpStatus);
    if (maskTree == null || projectionMode == ProjectionMode.MANUAL)
    {
      Assert.assertEquals(partialRestResponse.getEntity(), getRecord());
    }
    else
    {
      Assert.assertEquals(partialRestResponse.getEntity(), getProjectedRecord());
    }
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ResourceContext getMockResourceContext(MaskTree maskTree, ProjectionMode projectionMode)
  {
    ResourceContext mockContext = EasyMock.createMock(ResourceContext.class);
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(projectionMode).once();
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(maskTree).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static Foo getRecord()
  {
    return new Foo().setStringField("foo").setBooleanField(false).setFruitsField(Fruits.ORANGE);
  }

  private static Foo getProjectedRecord()
  {
    return new Foo().setStringField("foo");
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.internal.server.response.CreateCollectionResponseEnvelope;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchCreateResponseBuilder
{
  @Test
  @SuppressWarnings("unchecked")
  public void testBuilder()
  {
    List<CreateResponse> createResponses = Arrays.asList(new CreateResponse(1L), new CreateResponse(2L));
    BatchCreateResult<Long, Foo> results =
        new BatchCreateResult<Long, Foo>(createResponses);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    BatchCreateResponseBuilder responseBuilder = new BatchCreateResponseBuilder(null);
    RestLiResponseEnvelope responseData = responseBuilder.buildRestLiResponseData(null,
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);

    List<com.linkedin.restli.common.CreateIdStatus<Long>> items = new ArrayList<CreateIdStatus<Long>>();
    for (CreateCollectionResponseEnvelope.CollectionCreateResponseItem item : responseData.getCreateCollectionResponseEnvelope().getCreateResponses())
    {
      items.add((CreateIdStatus<Long>) item.getRecord());
    }

    Assert.assertEquals(restResponse.getEntity(),
                        new BatchCreateIdResponse<Long>(items));
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {new BatchCreateResult<Long, Foo>(Arrays.asList(new CreateResponse(1L), null)),
                "Unexpected null encountered. Null element inside of List inside of a BatchCreateResult returned by the resource method: "},
            {new BatchCreateResult<Long, Foo>(null),
                "Unexpected null encountered. Null List inside of a BatchCreateResult returned by the resource method: "}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilderExceptions(Object result, String expectedErrorMessage)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);
    BatchCreateResponseBuilder responseBuilder = new BatchCreateResponseBuilder(null);
    try
    {
      responseBuilder.buildRestLiResponseData(null, routingResult, result, headers);
      Assert.fail("buildRestLiResponseData should have thrown an exception because of null elements");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.pegasus.generator.examples.Fruits;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.BatchResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchGetResponseBuilder
{
  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "testData")
  public Object[][] dataProvider()
  {
    Map<CompoundKey, Foo> results = new HashMap<CompoundKey, Foo>();
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    CompoundKey c2 = new CompoundKey().append("a", "a2").append("b", 2);
    CompoundKey c3 = new CompoundKey().append("a", "a3").append("b", 3);
    Foo record1 = new Foo().setStringField("record1").setFruitsField(Fruits.APPLE);
    Foo projectedRecord1 = new Foo().setStringField("record1");
    Foo record2 = new Foo().setStringField("record2").setIntField(7);
    Foo projectedRecord2 = new Foo().setStringField("record2");
    results.put(c1, record1);
    results.put(c2, record2);

    DataMap projectionDataMap = new DataMap();
    projectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree maskTree = new MaskTree(projectionDataMap);

    Map<String, Foo> protocol1TransformedResults = new HashMap<String, Foo>();
    protocol1TransformedResults.put("a=a1&b=1", record1);
    protocol1TransformedResults.put("a=a2&b=2", record2);
    Map<String, Foo> protocol1TransformedResultsWithProjection = new HashMap<String, Foo>();
    protocol1TransformedResultsWithProjection.put("a=a1&b=1", projectedRecord1);
    protocol1TransformedResultsWithProjection.put("a=a2&b=2", projectedRecord2);

    Map<String, Foo> protocol2TransformedResults = new HashMap<String, Foo>();
    protocol2TransformedResults.put("(a:a1,b:1)", record1);
    protocol2TransformedResults.put("(a:a2,b:2)", record2);
    Map<String, Foo> protocol2TransformedResultsWithProjection = new HashMap<String, Foo>();
    protocol2TransformedResultsWithProjection.put("(a:a1,b:1)", projectedRecord1);
    protocol2TransformedResultsWithProjection.put("(a:a2,b:2)", projectedRecord2);

    Map<String, ErrorResponse> protocol1Errors = Collections.singletonMap("a=a3&b=3", new ErrorResponse().setStatus(404));
    Map<String, ErrorResponse> protocol2Errors = Collections.singletonMap("(a:a3,b:3)", new ErrorResponse().setStatus(404));

    Map<CompoundKey, HttpStatus> statuses = new HashMap<CompoundKey, HttpStatus>();
    statuses.put(c1, HttpStatus.S_200_OK);
    statuses.put(c2, HttpStatus.S_200_OK);
    Map<CompoundKey, RestLiServiceException> exceptions = new HashMap<CompoundKey, RestLiServiceException>();
    exceptions.put(c3, new RestLiServiceException(HttpStatus.S_404_NOT_FOUND));
    BatchResult<CompoundKey, Foo> batchResult = new BatchResult<CompoundKey, Foo>(results, statuses, exceptions);
    Map<Object, RestLiServiceException> exceptionsWithUntypedKey = new HashMap<Object, RestLiServiceException>(exceptions);

    ProtocolVersion protocolVersion1 = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    ProtocolVersion protocolVersion2 = AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion();

    ProjectionMode auto = ProjectionMode.AUTOMATIC;
    ProjectionMode manual = ProjectionMode.MANUAL;

    return new Object[][]
        {
            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, auto},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, auto},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, auto},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, auto},

            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, manual},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, manual},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, manual},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, manual},

            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, maskTree, manual},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, maskTree, manual},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, maskTree, manual},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, maskTree, manual},

            
            {results, protocolVersion1, protocol1TransformedResultsWithProjection, protocol1Errors, exceptionsWithUntypedKey, maskTree, auto},
            {results, protocolVersion2, protocol2TransformedResultsWithProjection, protocol2Errors, exceptionsWithUntypedKey, maskTree, auto},
            {batchResult, protocolVersion1, protocol1TransformedResultsWithProjection, protocol1Errors, exceptionsWithUntypedKey, maskTree, auto},
            {batchResult, protocolVersion2, protocol2TransformedResultsWithProjection, protocol2Errors, exceptionsWithUntypedKey, maskTree, auto},
        };
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "testData")
  @SuppressWarnings("unchecked")
  public void testBuilder(Object results,
                          ProtocolVersion protocolVersion,
                          Map<String, Foo> expectedTransformedResult,
                          Map<String, ErrorResponse> expectedErrors,
                          Map<Object, RestLiServiceException> expectedExceptionsWithUntypedKey,
                          MaskTree maskTree,
                          ProjectionMode projectionMode)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion,
                                                         expectedExceptionsWithUntypedKey,
                                                         maskTree,
                                                         projectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    RestLiResponseEnvelope responseData = responseBuilder.buildRestLiResponseData(null,
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
    BatchResponse<Foo> entity = (BatchResponse<Foo>)restResponse.getEntity();
    Assert.assertEquals(entity.getResults(), expectedTransformedResult);
    if (results instanceof BatchResult)
    {
      Map<String, Integer> expectedStatuses = new HashMap<String, Integer>();
      for (String key: entity.getResults().keySet())
      {
        expectedStatuses.put(key, HttpStatus.S_200_OK.getCode());
      }
      Assert.assertEquals(entity.getStatuses(), expectedStatuses);
    }
    else
    {
      
      Assert.assertEquals(entity.getStatuses(), Collections.emptyMap());
    }
    Assert.assertEquals(entity.getErrors().size(), expectedErrors.size());
    for (Map.Entry<String, ErrorResponse> entry: entity.getErrors().entrySet())
    {
      String key = entry.getKey();
      ErrorResponse value = entry.getValue();
      Assert.assertEquals(value.getStatus(), expectedErrors.get(key).getStatus());
    }
  }

  @Test
  public void testContextErrors()
  {
    BatchGetResponseBuilder builder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    ServerResourceContext context = EasyMock.createMock(ServerResourceContext.class);
    Map<Object,RestLiServiceException> errors = new HashMap<Object, RestLiServiceException>();
    RestLiServiceException exception = new RestLiServiceException(HttpStatus.S_402_PAYMENT_REQUIRED);
    errors.put("foo", exception);
    EasyMock.expect(context.getBatchKeyErrors()).andReturn(errors);
    EasyMock.replay(context);
    RoutingResult routingResult = new RoutingResult(context, null);
    RestLiResponseEnvelope envelope = builder.buildRestLiResponseData(null,
                                                                      routingResult,
                                                                      new BatchResult<Object, EmptyRecord>(Collections.<Object, EmptyRecord>emptyMap(), Collections.<Object, RestLiServiceException>emptyMap()),
                                                                      Collections.<String, String>emptyMap());
    Assert.assertEquals(envelope.getBatchResponseEnvelope().getBatchResponseMap().get("foo").getException(),
        exception);
    Assert.assertEquals(envelope.getBatchResponseEnvelope().getBatchResponseMap().size(), 1);
  }

  @DataProvider(name = "exceptionTestData")
  public Object[][] exceptionDataProvider()
  {
    Map<Long, Foo> results = new HashMap<Long, Foo>();
    Foo f1 = new Foo().setStringField("f1");
    Foo f2 = new Foo().setStringField("f2");
    results.put(null, f1);
    results.put(1L, f2);

    BatchResult<Long, Foo> batchResult = new BatchResult<Long, Foo>(Collections.singletonMap(1L, f1),
                                                                    Collections.<Long, HttpStatus>singletonMap(null, HttpStatus.S_404_NOT_FOUND),
                                                                    null);
    final String expectedMessage = "Unexpected null encountered. Null key inside of a Map returned by the resource method: ";
    return new Object[][]
        {
            {results, expectedMessage},
            {batchResult, expectedMessage}
        };
  }

  @Test(dataProvider = "exceptionTestData")
  public void testBuilderExceptions(Object results, String expectedErrorMessage)
  {
    
    ResourceContext mockContext = getMockResourceContext(null, Collections.<Object, RestLiServiceException>emptyMap(),
        null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    try
    {
      responseBuilder.buildRestLiResponseData(null, routingResult, results, headers);
      Assert.fail("buildRestLiResponseData should have failed because of null elements!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }

 
  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "unsupportedNullKeyMapData")
  public Object[][] unsupportedNullKeyMapData()
  {
    Map<CompoundKey, Foo> results = new ConcurrentHashMap<CompoundKey, Foo>();
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    Foo record1 = new Foo().setStringField("record1").setFruitsField(Fruits.APPLE);
    results.put(c1, record1);

    Map<CompoundKey, HttpStatus> statuses = new ConcurrentHashMap<CompoundKey, HttpStatus>();
    statuses.put(c1, HttpStatus.S_200_OK);

    final BatchResult<CompoundKey, Foo> batchResult =
        new BatchResult<CompoundKey, Foo>(results, statuses, new ConcurrentHashMap<CompoundKey, RestLiServiceException>());

    final Map<String, Foo> protocol1TransformedResults = new ConcurrentHashMap<String, Foo>();
    protocol1TransformedResults.put("a=a1&b=1", record1);

    final Map<String, Foo> protocol2TransformedResults = new ConcurrentHashMap<String, Foo>();
    protocol2TransformedResults.put("(a:a1,b:1)", record1);

    ProtocolVersion protocolVersion1 = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    ProtocolVersion protocolVersion2 = AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion();

    return new Object[][]
        {
            {results, protocolVersion1, protocol1TransformedResults},
            {results, protocolVersion2, protocol2TransformedResults},
            {batchResult, protocolVersion1, protocol1TransformedResults},
            {batchResult, protocolVersion2, protocol2TransformedResults}
        };
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "unsupportedNullKeyMapData")
  @SuppressWarnings("unchecked")
  public void unsupportedNullKeyMapTest(Object results, ProtocolVersion protocolVersion, Map<String, Foo> expectedTransformedResult)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion,
        Collections.<Object, RestLiServiceException>emptyMap(), null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    RestLiResponseEnvelope responseData = responseBuilder.buildRestLiResponseData(null,
        routingResult,
        results,
        headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
    BatchResponse<Foo> entity = (BatchResponse<Foo>)restResponse.getEntity();
    Assert.assertEquals(entity.getResults(), expectedTransformedResult);
    if (results instanceof BatchResult)
    {
      Map<String, Integer> expectedStatuses = new HashMap<String, Integer>();
      for (String key: entity.getResults().keySet())
      {
        expectedStatuses.put(key, HttpStatus.S_200_OK.getCode());
      }
      Assert.assertEquals(entity.getStatuses(), expectedStatuses);
    }
    else
    {
      
      Assert.assertEquals(entity.getStatuses(), Collections.emptyMap());
    }
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion,
                                                        Map<Object, RestLiServiceException> exceptions,
                                                        MaskTree maskTree,
                                                        ProjectionMode projectionMode)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getBatchKeyErrors()).andReturn(exceptions).once();
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(projectionMode).times(2);
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(maskTree).times(2);
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.LinkArray;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.Parameter;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiResponseDataException;
import com.linkedin.restli.server.RestLiServiceException;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCollectionResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider() throws CloneNotSupportedException
  {
    Foo metadata = new Foo().setStringField("metadata").setIntField(7);
    Foo projectedMetadata = new Foo().setIntField(7);
    final List<Foo> generatedList = generateTestList();
    final List<Foo> testListWithProjection = generateTestListWithProjection();
    CollectionResult<Foo, Foo> collectionResult = new CollectionResult<Foo, Foo>(generatedList, generatedList.size(), metadata);

    DataMap dataProjectionDataMap = new DataMap();
    dataProjectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree dataMaskTree = new MaskTree(dataProjectionDataMap);

    DataMap metadataProjectionDataMap = new DataMap();
    metadataProjectionDataMap.put("intField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree metadataMaskTree = new MaskTree(metadataProjectionDataMap);

    DataMap pagingProjectDataMap = new DataMap();
    pagingProjectDataMap.put("count", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree pagingMaskTree = new MaskTree(pagingProjectDataMap);

    CollectionMetadata collectionMetadata1 = new CollectionMetadata().setCount(10).setStart(0).setLinks(new LinkArray());
    CollectionMetadata collectionMetadata2 = collectionMetadata1.clone().setTotal(2);
    CollectionMetadata collectionMetadataWithProjection = new CollectionMetadata().setCount(10);

    ProjectionMode auto = ProjectionMode.AUTOMATIC;
    ProjectionMode manual = ProjectionMode.MANUAL;

    return new Object[][]
        {
            
            {generatedList, null, generatedList, collectionMetadata1, null, null, null, auto, auto},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadata2,
                null,
                null,
                null,
                auto,
                auto},

            
            {generatedList, null, generatedList, collectionMetadata1, null, null, null, manual, manual},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadata2,
                null,
                null,
                null,
                manual,
                manual},

            
            
            
            {generatedList,
                null,
                generatedList,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                manual,
                manual},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                manual,
                manual},

            
            {generatedList,
                null,
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                null,
                pagingMaskTree,
                auto,
                auto},

            
            {collectionResult,
                projectedMetadata.data(),
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                auto,
                auto},

            
            {collectionResult,
                metadata.data(),
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                auto,
                manual},
        };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "testData")
  public void testBuilder(Object results,
                          DataMap expectedMetadata,
                          List<Foo> expectedElements,
                          CollectionMetadata expectedPaging,
                          MaskTree dataMaskTree,
                          MaskTree metaDataMaskTree,
                          MaskTree pagingMaskTree,
                          ProjectionMode dataProjectionMode,
                          ProjectionMode metadataProjectionMode) throws URISyntaxException
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceContext mockContext = getMockResourceContext(dataMaskTree,
                                                         metaDataMaskTree,
                                                         pagingMaskTree,
                                                         dataProjectionMode,
                                                         metadataProjectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CollectionResponseBuilder responseBuilder = new CollectionResponseBuilder();
    RestLiResponseEnvelope responseData = responseBuilder.buildRestLiResponseData(getRestRequest(),
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    CollectionResponse<Foo> actualResults = (CollectionResponse<Foo>) restResponse.getEntity();
    Assert.assertEquals(actualResults.getElements(), expectedElements);
    Assert.assertEquals(actualResults.getMetadataRaw(), expectedMetadata);
    Assert.assertEquals(actualResults.getPaging(), expectedPaging);
  }

  @DataProvider(name = "exceptionTestData")
  public Object[][] exceptionDataProvider()
  {
    Foo f1 = new Foo().setStringField("f1");

    return new Object[][]
        {
            {Arrays.asList(f1, null),
                "Unexpected null encountered. Null element inside of a List returned by the resource method: "},
            {new CollectionResult<Foo, Foo>(null),
                "Unexpected null encountered. Null elements List inside of CollectionResult returned by the resource method: "}
        };
  }

  @Test(dataProvider = "exceptionTestData")
  public void testBuilderExceptions(Object results, String expectedErrorMessage)
      throws URISyntaxException
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceContext mockContext = getMockResourceContext(null, null, null, null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);
    CollectionResponseBuilder responseBuilder = new CollectionResponseBuilder();
    try
    {
      responseBuilder.buildRestLiResponseData(getRestRequest(), routingResult, results, headers);
      Assert.fail("An exception should have been thrown because of null elements!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }

  private static ResourceContext getMockResourceContext(MaskTree dataMaskTree,
                                                        MaskTree metadataMaskTree,
                                                        MaskTree pagingMaskTree,
                                                        ProjectionMode dataProjectionMode,
                                                        ProjectionMode metadataProjectionMode)
      throws URISyntaxException
  {
    ResourceContext mockContext = EasyMock.createMock(ResourceContext.class);
    EasyMock.expect(mockContext.getParameter(EasyMock.<String>anyObject())).andReturn(null).times(2);
    EasyMock.expect(mockContext.getRequestHeaders()).andReturn(ResponseBuilderUtil.getHeaders()).once();
    EasyMock.expect(mockContext.getRawRequest()).andReturn(getRestRequest()).once();

    
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(dataProjectionMode).times(generateTestList().size());
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(dataMaskTree).times(generateTestList().size());

    
    EasyMock.expect(mockContext.getMetadataProjectionMode()).andReturn(metadataProjectionMode).anyTimes();
    EasyMock.expect(mockContext.getMetadataProjectionMask()).andReturn(metadataMaskTree).anyTimes();

    
    EasyMock.expect(mockContext.getPagingProjectionMask()).andReturn(pagingMaskTree).once();

    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getParametersWithType(EasyMock.<Parameter.ParamType>anyObject())).andReturn(Collections.<Parameter<?>>emptyList()).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static List<Foo> generateTestList()
  {
    Foo f1 = new Foo().setStringField("f1").setIntField(1);
    Foo f2 = new Foo().setStringField("f2").setIntField(2);
    List<Foo> results = Arrays.asList(f1, f2);
    return results;
  }

  private static List<Foo> generateTestListWithProjection()
  {
    Foo f1 = new Foo().setStringField("f1");
    Foo f2 = new Foo().setStringField("f2");
    List<Foo> results = Arrays.asList(f1, f2);
    return results;
  }

  private static RestRequest getRestRequest()
      throws URISyntaxException
  {
    return new RestRequestBuilder(new URI("/?q=finder")).build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.FieldDef;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.ActionResult;

import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestActionResponseBuilder
{
  private static final FieldDef<Long> LONG_RETURN = new FieldDef<Long>("longReturn", Long.class);

  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {1L, HttpStatus.S_200_OK, 1L},
            {new ActionResult<Long>(1L, HttpStatus.S_202_ACCEPTED), HttpStatus.S_202_ACCEPTED, 1L}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(Object result, HttpStatus httpStatus, long returnValue)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    ActionResponseBuilder actionResponseBuilder = new ActionResponseBuilder();
    RestLiResponseEnvelope responseData = actionResponseBuilder.buildRestLiResponseData(null,
                                                                                             routingResult,
                                                                                             result,
                                                                                             headers);
    PartialRestResponse restResponse = actionResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), httpStatus);
    Assert.assertEquals((restResponse.getEntity()), getActionResponse(returnValue));
  }

  @SuppressWarnings("unchecked")
  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);

    EasyMock.expect(mockDescriptor.getActionReturnRecordDataSchema()).andReturn(LONG_RETURN.getField().getRecord()).once();
    EasyMock.expect(((FieldDef<Long>)mockDescriptor.getActionReturnFieldDef())).andReturn(LONG_RETURN).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ActionResponse<Long> getActionResponse(long returnValue)
  {
    DataMap dataMap = new DataMap();
    dataMap.put(LONG_RETURN.getName(), returnValue);
    return new ActionResponse<Long>(dataMap, LONG_RETURN, LONG_RETURN.getField().getRecord());
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCreateResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), "/foo/a=a&b=1", "a=a&b=1"},
            {AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), "/foo/(a:a,b:1)", "(a:a,b:1)"}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(ProtocolVersion protocolVersion, String location, String id) throws URISyntaxException
  {
    CompoundKey compoundKey = new CompoundKey().append("a", "a").append("b", 1);
    CreateResponse createResponse = new CreateResponse(compoundKey);
    IdResponse<CompoundKey> idResponse = new IdResponse<CompoundKey>(compoundKey);
    RestRequest restRequest = new RestRequestBuilder(new URI("/foo")).build();
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
    
    Map<String, String> expectedHeaders = new HashMap<String, String>(headers);

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CreateResponseBuilder createResponseBuilder = new CreateResponseBuilder();
    RestLiResponseEnvelope responseData = createResponseBuilder.buildRestLiResponseData(restRequest,
                                                                                             routingResult,
                                                                                             createResponse,
                                                                                             headers);
    PartialRestResponse partialRestResponse = createResponseBuilder.buildResponse(routingResult, responseData);

    expectedHeaders.put(RestConstants.HEADER_LOCATION, location);
    if (protocolVersion.equals(AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()))
    {
      expectedHeaders.put(RestConstants.HEADER_ID, id);
    }
    else
    {
      expectedHeaders.put(RestConstants.HEADER_RESTLI_ID, id);
    }

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, expectedHeaders);
    Assert.assertEquals(partialRestResponse.getStatus(), HttpStatus.S_201_CREATED);
    Assert.assertEquals(partialRestResponse.getEntity(), idResponse);
  }

  @Test
  public void testBuilderException()
      throws URISyntaxException
  {
    CompoundKey compoundKey = new CompoundKey().append("a", "a").append("b", 1);
    CreateResponse createResponse = new CreateResponse(compoundKey, null);
    RestRequest restRequest = new RestRequestBuilder(new URI("/foo")).build();
    ProtocolVersion protocolVersion = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CreateResponseBuilder createResponseBuilder = new CreateResponseBuilder();
    try
    {
      createResponseBuilder.buildRestLiResponseData(restRequest, routingResult, createResponse, headers);
      Assert.fail("buildRestLiResponseData should have thrown an exception because the status is null!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains("Unexpected null encountered. HttpStatus is null inside of a CreateResponse from the resource method: "));
    }
  }


  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.Test;



public class TestUpdateResponseBuilder
{
  @Test
  public void testBuilder()
  {
    HttpStatus status = HttpStatus.S_200_OK;
    UpdateResponse updateResponse = new UpdateResponse(status);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    UpdateResponseBuilder updateResponseBuilder = new UpdateResponseBuilder();
    RestLiResponseEnvelope responseData = updateResponseBuilder.buildRestLiResponseData(null,
                                                                                             routingResult,
                                                                                             updateResponse,
                                                                                             headers);
    PartialRestResponse partialRestResponse = updateResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, headers);
    Assert.assertEquals(partialRestResponse.getStatus(), status);
  }

  @Test
  public void testBuilderException()
  {
    UpdateResponse updateResponse = new UpdateResponse(null);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    UpdateResponseBuilder updateResponseBuilder = new UpdateResponseBuilder();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    try
    {
      updateResponseBuilder.buildRestLiResponseData(null, routingResult, updateResponse, headers);
      Assert.fail("buildRestLiResponseData should have failed because of a null HTTP status!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains("Unexpected null encountered. HttpStatus is null inside of a UpdateResponse returned by the resource method: "));
    }
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.easymock.EasyMock;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchUpdateResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    CompoundKey c2 = new CompoundKey().append("a", "a2").append("b", 2);
    CompoundKey c3 = new CompoundKey().append("a", "a3").append("b", 3);
    Map<CompoundKey, UpdateResponse> results = new HashMap<CompoundKey, UpdateResponse>();
    results.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    results.put(c2, new UpdateResponse(HttpStatus.S_202_ACCEPTED));

    RestLiServiceException restLiServiceException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    Map<CompoundKey, RestLiServiceException> errors = Collections.singletonMap(c3, restLiServiceException);

    BatchUpdateResult<CompoundKey, Foo> batchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(results, errors);

    Map<CompoundKey, UpdateResponse> keyOverlapResults = new HashMap<CompoundKey, UpdateResponse>();
    keyOverlapResults.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    keyOverlapResults.put(c2, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    keyOverlapResults.put(c3, new UpdateResponse(HttpStatus.S_404_NOT_FOUND));
    BatchUpdateResult<CompoundKey, Foo> keyOverlapBatchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(keyOverlapResults, errors);

    UpdateStatus updateStatus = new UpdateStatus().setStatus(202);
    ErrorResponse errorResponse = new ErrorResponse().setStatus(404);

    Map<String, UpdateStatus> expectedProtocol1Results = new HashMap<String, UpdateStatus>();
    expectedProtocol1Results.put("a=a1&b=1", updateStatus);
    expectedProtocol1Results.put("a=a2&b=2", updateStatus);
    Map<String, ErrorResponse> expectedProtocol1Errors = new HashMap<String, ErrorResponse>();
    expectedProtocol1Errors.put("a=a3&b=3", errorResponse);

    Map<String, UpdateStatus> expectedProtocol2Results = new HashMap<String, UpdateStatus>();
    expectedProtocol2Results.put("(a:a1,b:1)", updateStatus);
    expectedProtocol2Results.put("(a:a2,b:2)", updateStatus);
    Map<String, ErrorResponse> expectedProtocol2Errors = new HashMap<String, ErrorResponse>();
    expectedProtocol2Errors.put("(a:a3,b:3)", errorResponse);

    return new Object[][]
        {
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), expectedProtocol1Results, expectedProtocol1Errors},
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results, expectedProtocol2Errors},
            {keyOverlapBatchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results, expectedProtocol2Errors}
        };
  }

  @Test(dataProvider = "testData")
  @SuppressWarnings("unchecked")
  public void testBuilder(Object results,
                          ProtocolVersion protocolVersion,
                          Map<String, UpdateStatus> expectedResults,
                          Map<String, ErrorResponse> expectedErrors)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchUpdateResponseBuilder batchUpdateResponseBuilder = new BatchUpdateResponseBuilder(new ErrorResponseBuilder());
    RestLiResponseEnvelope responseData = batchUpdateResponseBuilder.buildRestLiResponseData(null,
                                                                                                  routingResult,
                                                                                                  results,
                                                                                                  headers);
    PartialRestResponse restResponse = batchUpdateResponseBuilder.buildResponse(routingResult, responseData);

    BatchResponse<UpdateStatus> batchResponse = (BatchResponse<UpdateStatus>) restResponse.getEntity();
    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(batchResponse.getResults(), expectedResults);
    Assert.assertEquals(batchResponse.getErrors().size(), expectedErrors.size());
    for (Map.Entry<String, ErrorResponse> entry: batchResponse.getErrors().entrySet())
    {
      String key = entry.getKey();
      ErrorResponse value = entry.getValue();
      Assert.assertEquals(value.getStatus(), expectedErrors.get(key).getStatus());
    }
  }

  @Test
  public void testContextErrors()
  {
    BatchUpdateResponseBuilder builder = new BatchUpdateResponseBuilder(new ErrorResponseBuilder());
    ServerResourceContext context = EasyMock.createMock(ServerResourceContext.class);
    Map<Object,RestLiServiceException> errors = new HashMap<Object, RestLiServiceException>();
    RestLiServiceException exception = new RestLiServiceException(HttpStatus.S_402_PAYMENT_REQUIRED);
    errors.put("foo", exception);
    EasyMock.expect(context.getBatchKeyErrors()).andReturn(errors);
    EasyMock.replay(context);
    RoutingResult routingResult = new RoutingResult(context, null);
    RestLiResponseEnvelope envelope = builder.buildRestLiResponseData(null,
                                                                      routingResult,
                                                                      new BatchUpdateResult<Object, Integer>(Collections.<Object, UpdateResponse>emptyMap()),
                                                                      Collections.<String, String>emptyMap());
    Assert.assertEquals(envelope.getBatchResponseEnvelope().getBatchResponseMap().get("foo").getException(),
                        exception);
    Assert.assertEquals(envelope.getBatchResponseEnvelope().getBatchResponseMap().size(), 1);
  }

  @DataProvider(name = "unsupportedNullKeyMapData")
  public Object[][] unsupportedNullKeyMapData()
  {
    final CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    final Map<CompoundKey, UpdateResponse> results = new ConcurrentHashMap<CompoundKey, UpdateResponse>();
    results.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));

    final BatchUpdateResult<CompoundKey, Foo> batchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(results, new ConcurrentHashMap<CompoundKey, RestLiServiceException>());
    final UpdateStatus updateStatus = new UpdateStatus().setStatus(202);

    final Map<String, UpdateStatus> expectedProtocol1Results = new HashMap<String, UpdateStatus>();
    expectedProtocol1Results.put("a=a1&b=1", updateStatus);
    final Map<String, UpdateStatus> expectedProtocol2Results = new HashMap<String, UpdateStatus>();
    expectedProtocol2Results.put("(a:a1,b:1)", updateStatus);

    return new Object[][]
        {
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), expectedProtocol1Results},
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results}
        };
  }

 
  @Test(dataProvider = "unsupportedNullKeyMapData")
  @SuppressWarnings("unchecked")
  public void unsupportedNullKeyMapTest(Object results, ProtocolVersion protocolVersion, Map<String, UpdateStatus> expectedResults)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchUpdateResponseBuilder batchUpdateResponseBuilder = new BatchUpdateResponseBuilder(new ErrorResponseBuilder());
    RestLiResponseEnvelope responseData = batchUpdateResponseBuilder.buildRestLiResponseData(null,
        routingResult,
        results,
        headers);
    PartialRestResponse restResponse = batchUpdateResponseBuilder.buildResponse(routingResult, responseData);

    BatchResponse<UpdateStatus> batchResponse = (BatchResponse<UpdateStatus>) restResponse.getEntity();
    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(batchResponse.getResults(), expectedResults);
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getBatchKeyErrors()).andReturn(Collections.<Object, RestLiServiceException>emptyMap()).once();
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);

    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.server.RestLiResponseEnvelope;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.ErrorResponseFormat;
import com.linkedin.restli.server.RestLiServiceException;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestErrorResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()},
            {AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(ProtocolVersion protocolVersion)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    Map<String, String> expectedHeaders = new HashMap<String, String>(headers);
    expectedHeaders.put(HeaderUtil.getErrorResponseHeaderName(protocolVersion), RestConstants.HEADER_VALUE_ERROR);

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    RuntimeException runtimeException = new RuntimeException("Internal server error!");
    RestLiServiceException serviceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
                                                                         runtimeException);

    ErrorResponseBuilder errorResponseBuilder = new ErrorResponseBuilder();
    RestLiResponseEnvelope responseData = errorResponseBuilder.buildRestLiResponseData(null,
                                                                                            routingResult,
                                                                                            serviceException,
                                                                                            headers);
    PartialRestResponse restResponse = errorResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ErrorResponse errorResponse = (ErrorResponse)restResponse.getEntity();
    Assert.assertEquals(errorResponse.getStatus(), new Integer(500));
    Assert.assertTrue(errorResponse.getMessage().contains(runtimeException.getMessage()));
  }

  private ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.GET);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  @Test
  public void testOverride()
  {
    RestLiServiceException exception = new RestLiServiceException(HttpStatus.S_200_OK, "Some message", new IllegalStateException("Some other message"));
    exception.setServiceErrorCode(123);
    exception.setErrorDetails(new DataMap());
    ErrorResponseBuilder builder = new ErrorResponseBuilder(ErrorResponseFormat.FULL);

    ErrorResponse errorResponse = builder.buildErrorResponse(exception);
    Assert.assertTrue(errorResponse.hasErrorDetails());
    Assert.assertTrue(errorResponse.hasExceptionClass());
    Assert.assertTrue(errorResponse.hasStatus());
    Assert.assertTrue(errorResponse.hasMessage());
    Assert.assertTrue(errorResponse.hasServiceErrorCode());
    Assert.assertTrue(errorResponse.hasStackTrace());

    exception.setOverridingFormat(ErrorResponseFormat.MESSAGE_AND_SERVICECODE);
    errorResponse = builder.buildErrorResponse(exception);
    Assert.assertFalse(errorResponse.hasErrorDetails());
    Assert.assertFalse(errorResponse.hasExceptionClass());
    Assert.assertFalse(errorResponse.hasStatus());
    Assert.assertTrue(errorResponse.hasMessage());
    Assert.assertTrue(errorResponse.hasServiceErrorCode());
    Assert.assertFalse(errorResponse.hasStackTrace());
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.data.schema.validation.ValidateDataAgainstSchema;
import com.linkedin.data.schema.validation.ValidationOptions;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.restli.client.CreateIdRequest;
import com.linkedin.restli.client.CreateIdRequestBuilder;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.response.CreateResponse;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.GreetingsBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsCallbackBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsCallbackRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseCtxBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseCtxRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsTaskBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsTaskRequestBuilders;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Sets;

import static com.linkedin.restli.examples.TestConstants.FORCE_USE_NEXT_OPTIONS;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;



public class TestFilters extends RestLiIntegrationTest
{
  private static final String REQ_FILTER_ERROR_MESSAGE = "You are forbidden from creating an insulting greeting.";
  private static final HttpStatus REQ_FILTER_ERROR_STATUS = HttpStatus.S_403_FORBIDDEN;
  private static final String RESP_FILTER_ERROR_MESSAGE = "Thou shall not insult other";
  private static final HttpStatus RESP_FILTER_ERROR_STATUS = HttpStatus.S_400_BAD_REQUEST;
  private static final BiMap<Tone, Tone> toneMapper;
  static
  {
    toneMapper = HashBiMap.create();
    toneMapper.put(Tone.FRIENDLY, Tone.SINCERE);
    toneMapper.put(Tone.SINCERE, Tone.INSULTING);
  }

  @Mock
  private RequestFilter _requestFilter;
  @Mock
  private ResponseFilter _responseFilter;

  @BeforeClass
  public void initClass() throws Exception
  {
    MockitoAnnotations.initMocks(this);
  }

  @AfterMethod
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  
  @Test(dataProvider = "requestBuilderDataProvider")
  public void testGetOldBuilders(RootBuilderWrapper<Long, Greeting> builders, Tone tone, boolean responseFilter, Exception responseFilterException) throws Exception
  {
    setupFilters(responseFilter, responseFilterException);
    Greeting greeting = generateTestGreeting("Test greeting.....", tone);
    Long createdId = null;
    try
    {
      createdId = createTestData(builders, greeting);
    }
    catch (RestLiResponseException e)
    {
      if (tone != Tone.INSULTING)
      {
        fail();
      }
      if (responseFilter)
      {
        assertEquals(e.getServiceErrorMessage(), RESP_FILTER_ERROR_MESSAGE);
        assertEquals(e.getResponse().getStatus(), RESP_FILTER_ERROR_STATUS.getCode());
      }
      else
      {
        assertEquals(e.getServiceErrorMessage(), REQ_FILTER_ERROR_MESSAGE);
        assertEquals(e.getResponse().getStatus(), REQ_FILTER_ERROR_STATUS.getCode());
      }
      verifyFilters(tone, responseFilter);
      return;
    }
    if (tone == Tone.INSULTING)
    {
      fail();
    }
    if (!responseFilter)
    {
      greeting.setTone(mapToneForIncomingRequest(tone));
    }
    greeting.setId(createdId);
    Request<Greeting> getRequest = builders.get().id(createdId).build();
    Greeting getReturnedGreeting = getClient().sendRequest(getRequest).getResponse().getEntity();
    ValidateDataAgainstSchema.validate(getReturnedGreeting.data(), getReturnedGreeting.schema(),
                                       new ValidationOptions());
    assertEquals(getReturnedGreeting, greeting);
    deleteAndVerifyTestData(builders, createdId);
    verifyFilters(tone, responseFilter);
  }

  private Greeting generateTestGreeting(String message, Tone tone)
  {
    return new Greeting().setMessage(message).setTone(tone);
  }

  private void deleteAndVerifyTestData(RootBuilderWrapper<Long, Greeting> builders, Long id) throws RemoteInvocationException
  {
    Request<EmptyRecord> request = builders.delete().id(id).build();
    ResponseFuture<EmptyRecord> future = getClient().sendRequest(request);
    Response<EmptyRecord> response = future.getResponse();
    assertEquals(response.getStatus(), HttpStatus.S_204_NO_CONTENT.getCode());
  }

  private Long createTestData(RootBuilderWrapper<Long, Greeting> builders, Greeting greeting) throws RemoteInvocationException
  {
    RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> createBuilderWrapper = builders.create();
    Long createdId;
    if (createBuilderWrapper.isRestLi2Builder())
    {
      Object objBuilder = createBuilderWrapper.getBuilder();
      @SuppressWarnings("unchecked")
      CreateIdRequestBuilder<Long, Greeting> createIdRequestBuilder =
          (CreateIdRequestBuilder<Long, Greeting>) objBuilder;
      CreateIdRequest<Long, Greeting> request = createIdRequestBuilder.input(greeting).build();
      Response<IdResponse<Long>> response = getClient().sendRequest(request).getResponse();
      createdId = response.getEntity().getId();
    }
    else
    {
      Request<EmptyRecord> request = createBuilderWrapper.input(greeting).build();
      Response<EmptyRecord> response = getClient().sendRequest(request).getResponse();
      @SuppressWarnings("unchecked")
      CreateResponse<Long> createResponse = (CreateResponse<Long>) response.getEntity();
      createdId = createResponse.getId();
    }
    return createdId;

  }

  private void verifyFilters(Tone tone, boolean respFilter)
  {
    int count = tone == Tone.INSULTING ? 1 : 3;
    verify(_requestFilter, times(count)).onRequest(any(FilterRequestContext.class));
    verifyNoMoreInteractions(_requestFilter);
    if (respFilter)
    {
      verify(_responseFilter, times(count)).onResponse(any(FilterRequestContext.class),
                                                       any(FilterResponseContext.class));
      verifyNoMoreInteractions(_responseFilter);
    }
  }

  private void setupFilters(boolean responseFilter, final Exception responseFilterException) throws IOException
  {
    reset(_requestFilter);
    final Integer spValue = new Integer(100);
    final String spKey = "Counter";
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterRequestContext requestContext = (FilterRequestContext) args[0];
        requestContext.getFilterScratchpad().put(spKey, spValue);
        if (requestContext.getMethodType() == ResourceMethod.CREATE)
        {
          RecordTemplate entity = requestContext.getRequestData().getEntity();
          if (entity != null && entity instanceof Greeting)
          {
            Greeting greeting = (Greeting) entity;
            if (greeting.hasTone())
            {
              Tone tone = greeting.getTone();
              if (tone == Tone.INSULTING)
              {
                throw new RestLiServiceException(REQ_FILTER_ERROR_STATUS, REQ_FILTER_ERROR_MESSAGE);
              }
              greeting.setTone(mapToneForIncomingRequest(tone));
            }
          }
        }
        return null;
      }
    }).when(_requestFilter).onRequest(any(FilterRequestContext.class));
    List<RequestFilter> reqFilters = Arrays.asList(_requestFilter);

    List<ResponseFilter> respFilters = null;
    if (responseFilter)
    {
      reset(_responseFilter);
      doAnswer(new Answer<Object>()
      {
        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable
        {
          Object[] args = invocation.getArguments();
          FilterRequestContext requestContext = (FilterRequestContext) args[0];
          FilterResponseContext responseContext = (FilterResponseContext) args[1];
          
          assertTrue(requestContext.getFilterScratchpad().get(spKey) == spValue);
          RecordTemplate entity;

          switch (responseContext.getResponseData().getResponseType())
          {
            case SINGLE_ENTITY:
              entity = responseContext.getResponseData().getRecordResponseEnvelope().getRecord();
              break;
            case STATUS_ONLY:
              entity = null;
              break;
            default:
              throw new RuntimeException("Unexpected resolver type.");
          }
          if (entity != null && requestContext.getMethodType() == ResourceMethod.GET
              && responseContext.getResponseData().getStatus() == HttpStatus.S_200_OK)
          {
            Greeting greeting = new Greeting(entity.data());
            if (greeting.hasTone())
            {
              greeting.setTone(mapToneForOutgoingResponse(greeting.getTone()));
              responseContext.getResponseData().getRecordResponseEnvelope().setRecord(greeting, HttpStatus.S_200_OK);
            }
          }
          if (responseContext.getResponseData().isErrorResponse()
              && requestContext.getMethodType() == ResourceMethod.CREATE
              && responseContext.getResponseData().getStatus() == REQ_FILTER_ERROR_STATUS)
          {
            throw responseFilterException;
          }
          return null;
        }
      }).when(_responseFilter).onResponse(any(FilterRequestContext.class), any(FilterResponseContext.class));
      respFilters = Arrays.asList(_responseFilter);
    }
    init(reqFilters, respFilters);
  }

  private static Tone mapToneForIncomingRequest(Tone inputTone)
  {
    return toneMapper.get(inputTone);
  }

  private static Tone mapToneForOutgoingResponse(Tone outputTone)
  {
    return toneMapper.inverse().get(outputTone);
  }

  private Object[][] to2DArray(Set<List<Object>> objectSet)
  {
    Object[][] result = new Object[objectSet.size()][];
    int i = 0;
    for (List<Object> objects : objectSet)
    {
      result[i] = objects.toArray();
      i++;
    }
    return result;
  }

  @SuppressWarnings("unchecked")
  @DataProvider
  private Object[][] requestBuilderDataProvider()
  {
    Object[] builders = new Object[]{
        new GreetingsBuilders(),
        new GreetingsRequestBuilders(),
        new GreetingsPromiseBuilders(),
        new GreetingsPromiseRequestBuilders(),
        new GreetingsCallbackBuilders(),
        new GreetingsCallbackRequestBuilders(),
        new GreetingsPromiseCtxBuilders(),
        new GreetingsPromiseCtxRequestBuilders(),
        new GreetingsTaskBuilders(),
        new GreetingsTaskRequestBuilders(),
        new GreetingsBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsCallbackBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsCallbackRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseCtxBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseCtxRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsTaskBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsTaskRequestBuilders(FORCE_USE_NEXT_OPTIONS)
    };
    Set<Object> builderWrapperSet = new HashSet<Object>();
    for (Object builder : builders)
    {
      builderWrapperSet.add(new RootBuilderWrapper<Long, Greeting>(builder));
    }
    Set<Tone> toneSet = new HashSet<Tone>(Arrays.asList(Tone.FRIENDLY, Tone.INSULTING));
    Set<Boolean> responseFilterSet = new HashSet<Boolean>(Arrays.asList(false, true));
    Set<Exception> exceptionSet = new HashSet<Exception>(Arrays.asList(
        new RestLiServiceException(RESP_FILTER_ERROR_STATUS, RESP_FILTER_ERROR_MESSAGE),
        new RestLiServiceException(RESP_FILTER_ERROR_STATUS, RESP_FILTER_ERROR_MESSAGE, new RuntimeException("Original cause")),
        new RoutingException(RESP_FILTER_ERROR_MESSAGE, RESP_FILTER_ERROR_STATUS.getCode())
    ));
    List<Set<? extends Object>> sets = Arrays.asList(builderWrapperSet, toneSet, responseFilterSet, exceptionSet);
    Object[][] dataSources = to2DArray(Sets.cartesianProduct(sets));
    
    assertEquals(dataSources.length, builderWrapperSet.size() * toneSet.size() * responseFilterSet.size() * exceptionSet.size());
    for (int i = 0; i < dataSources.length; i++)
    {
      assertEquals(dataSources[i].length, sets.size());
    }
    return dataSources;
  }
}

<code block>


package com.linkedin.restli.examples;


import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.restli.client.BatchGetEntityRequest;
import com.linkedin.restli.client.BatchGetEntityRequestBuilder;
import com.linkedin.restli.client.CreateIdRequest;
import com.linkedin.restli.client.CreateIdRequestBuilder;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.response.BatchKVResponse;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.NullGreetingBuilders;
import com.linkedin.restli.examples.greetings.client.NullGreetingRequestBuilders;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.BatchCreateHelper;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestNullGreetingsClient extends RestLiIntegrationTest
{
  @BeforeClass
  public void initClass() throws Exception
  {
    super.init(Collections.<RequestFilter>emptyList(), ImmutableList.of(new ResponseFilter() {
      @Override
      public void onResponse(FilterRequestContext requestContext, FilterResponseContext responseContext) {
        
        
        responseContext.getResponseData().getHeaders().put("X-Null-Greetings-Filter", "Ack");
      }
    }));
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullCreateResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper = builders.create();
    final Greeting illGreeting = new Greeting().setMessage("nullCreateResponse").setTone(Tone.INSULTING);
    createAndAssertNullMessages(methodBuilderWrapper, illGreeting);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullHttpStatusCreateResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper = builders.create();
    final Greeting illGreeting = new Greeting().setMessage("nullHttpStatus").setTone(Tone.INSULTING);
    createAndAssertNullMessages(methodBuilderWrapper, illGreeting);
  }

  private void createAndAssertNullMessages(
      final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper,
      final Greeting illGreeting)
      throws RemoteInvocationException
  {
    if (methodBuilderWrapper.isRestLi2Builder())
    {
      final Object objBuilder = methodBuilderWrapper.getBuilder();
      @SuppressWarnings("unchecked")
      final CreateIdRequestBuilder<Long, Greeting> createIdRequestBuilder =
          (CreateIdRequestBuilder<Long, Greeting>) objBuilder;
      final CreateIdRequest<Long, Greeting> request = createIdRequestBuilder.input(illGreeting).build();
      try
      {
        getClient().sendRequest(request).getResponse();
        Assert.fail("We should not reach here!");
      }
      catch (final RestLiResponseException responseException)
      {
        assertCorrectInternalServerMessageForNull(responseException, "create");
      }
    }
    else
    {
      final Request<EmptyRecord> request = methodBuilderWrapper.input(illGreeting).build();
      try
      {
        getClient().sendRequest(request).getResponse();
        Assert.fail("We should not reach here!");
      }
      catch (final RestLiResponseException responseException)
      {
        assertCorrectInternalServerMessageForNull(responseException, "create");
      }
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("searchReturnNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("searchReturnNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testCallBackFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(
        builders.findBy("finderCallbackNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderCallbackNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testPromiseFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("finderPromiseNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderPromiseNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testTaskFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("finderTaskNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderTaskNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullsInCollectionResult(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.SINCERE).build());

    
    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.FRIENDLY).build());
  }

  private void finderAndAssertNullMessages(final Request<CollectionResponse<Greeting>> req)
      throws RemoteInvocationException
  {
    try
    {
      getClient().sendRequest(req).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "finder");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testGetNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.get().id(1l).build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 404, "We should have gotten a 404 back");
      Assert.assertNotNull(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "We should have" +
          " a header applied by the filter");
      Assert.assertEquals(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "Ack",
          "The value of the header applied by the response filter should be correct");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testGetAllNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.getAll().build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "get");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testUpdateNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendUpdateAndAssert(builders, 1l);

    
    sendUpdateAndAssert(builders, 2l);
  }

  private void sendUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
      getClient().sendRequest(builders.update().id(id).input(someGreeting).build()).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchUpdate(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendBatchUpdateAndAssert(builders, 1l);

    
    sendBatchUpdateAndAssert(builders, 2l);

    
    sendBatchUpdateAndAssert(builders, 3l);

    
    sendBatchUpdateAndAssert(builders, 4l);

    
    sendBatchUpdateAndAssert(builders, 5l);

    
    sendBatchUpdateAndAssert(builders, 6l);
  }

  private void sendBatchUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
      Request<BatchKVResponse<Long, UpdateStatus>> writeRequest =
          builders.batchUpdate().input(id, someGreeting).build();
      getClient().sendRequest(writeRequest).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchUpdateUnsupportedNullKeyMap(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(7l, someGreeting).build();
    Response<BatchKVResponse<Long, UpdateStatus>> response = getClient().sendRequest(writeRequest).getResponse();

    Map<Long, ErrorResponse> actualErrors = response.getEntity().getErrors();
    Assert.assertEquals(actualErrors.size(), 0, "Errors map should be empty");

    Map<Long, UpdateStatus> actualResults = response.getEntity().getResults();
    Map<Long, UpdateStatus> expectedResults = new HashMap<Long, UpdateStatus>();
    UpdateStatus updateStatus = new UpdateStatus().setStatus(201);
    expectedResults.put(3l, updateStatus);
    Assert.assertEquals(actualResults, expectedResults, "The results map should be correct");
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchPartialUpdate(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendBatchPartialUpdateAndAssert(builders, 1l);

    
    sendBatchPartialUpdateAndAssert(builders, 2l);

    
    sendBatchPartialUpdateAndAssert(builders, 3l);

    
    sendBatchPartialUpdateAndAssert(builders, 4l);
  }

  private void sendBatchPartialUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Map<Long, PatchRequest<Greeting>> patchedGreetingsDiffs = new HashMap<Long, PatchRequest<Greeting>>();
      patchedGreetingsDiffs.put(id, new PatchRequest<Greeting>());
      final Request<BatchKVResponse<Long, UpdateStatus>> batchUpdateRequest =
          builders.batchPartialUpdate().patchInputs(patchedGreetingsDiffs).build();
      getClient().sendRequest(batchUpdateRequest).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_partial_update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testDeleteNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.delete().id(1l).build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "delete");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchDeleteNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<BatchKVResponse<Long, UpdateStatus>> deleteRequest =
          builders.batchDelete().ids(ImmutableList.of(1l)).build();
      getClient().sendRequest(deleteRequest).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_delete");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullStringArray(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final Request<Integer> request = builders.<Integer>action("returnNullStringArray").build();
    final Response<Integer> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 back");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullActionResult(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final Request<Integer> request = builders.<Integer>action("returnNullActionResult").build();
    final Response<Integer> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 back");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testStringArrayNullElement(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnStringArrayWithNullElement").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
      Assert.assertTrue(responseException.getMessage().contains("Error in application code"), "The error message should be correct");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testActionResultNullValue(RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnActionResultWithNullValue").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
      Assert.assertTrue(
          responseException.getMessage().contains("Cannot set field value of com.linkedin.restli.common.ActionResponse to null"),
          "The error message should be correct");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testActionResultNullStatus(RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnActionResultWithNullStatus").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "action");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchCreateNulls(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    final Greeting firstGreeting = new Greeting().setMessage("first").setTone(Tone.INSULTING);
    final Greeting secondGreeting = new Greeting().setMessage("first").setTone(Tone.INSULTING);

    
    sendBatchCreateAndAssert(builders, Collections.<Greeting>emptyList());

    
    sendBatchCreateAndAssert(builders, ImmutableList.of(firstGreeting));

    
    sendBatchCreateAndAssert(builders, ImmutableList.of(firstGreeting, secondGreeting));
  }

  private void sendBatchCreateAndAssert(final RootBuilderWrapper<Long, Greeting> builders,
      final List<Greeting> greetingList)
      throws RemoteInvocationException
  {
    try
    {
      BatchCreateHelper.batchCreate(getClient(), builders, greetingList);
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_create");
    }
  }

  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  private static Object[][] requestBuilderDataProvider()
  {
    return new Object[][]
    {
        {
            new RootBuilderWrapper<Long, Greeting>(new NullGreetingBuilders())
        },
        {
            new RootBuilderWrapper<Long, Greeting>(new NullGreetingRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS))
        }
    };
  }

  private void assertCorrectInternalServerMessageForNull(final RestLiResponseException responseException, final String type)
  {
    Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
    Assert.assertTrue(responseException.getMessage().contains("Unexpected null encountered"), "The error message should be correct");
    Assert.assertTrue(responseException.getMessage().contains("type="+type.toLowerCase()), "The type should be correct");
    Assert.assertTrue(responseException.getMessage().contains("resourceName=nullGreeting"), "The resourceName should be correct");
    Assert.assertNotNull(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "We should have" +
        " a header applied by the filter");
    Assert.assertEquals(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "Ack", "The value" +
        " of the header applied by the response filter should be correct");
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullBatchResult(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    try
    {
      
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(1l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullBatchResultInternals(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    BatchGetEntityRequest<Long, Greeting> request =
        builder.ids(ImmutableSet.of(2l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 here!");
    Assert.assertNotNull(response.getHeader("X-Null-Greetings-Filter"), "We should have" +
        " a header applied by the filter");
    Assert.assertEquals(response.getHeader("X-Null-Greetings-Filter"), "Ack", "The value" +
        " of the header applied by the response filter should be correct");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullKeyBatchResultStatusMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    
    try
    {
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(3l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullKeyBatchResultMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    try
    {
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(4l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetUnsupportedNullKeyMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException, CloneNotSupportedException
  {
    BatchGetEntityRequest<Long, Greeting> request =
        builder.ids(ImmutableSet.of(5l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> response = getClient().sendRequest(request).getResponse();
    final Greeting actualGreeting = response.getEntity().getResults().get(0l).getEntity();
    Assert.assertEquals(actualGreeting.getMessage(), "Good morning!", "We should get the correct Greeting back");
  }

  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  private static Object[][] batchGetRequestBuilderDataProvider()
  {
    return new Object[][]
    {
        {
            new NullGreetingRequestBuilders().batchGet()
        },
        {
            new NullGreetingRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS).batchGet()
        }
    };
  }
}
<code block>


package com.linkedin.restli.server;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CollectionMetadata;

import java.util.List;
import java.util.Map;



public interface RestLiResponseData
{
  
  boolean isEntityResponse();

  
  boolean isCollectionResponse();

  
  boolean isBatchResponse();

  
  boolean isErrorResponse();

  
  RecordTemplate getEntityResponse();

  
  void setEntityResponse(RecordTemplate entity) throws RestLiResponseDataException;

  
  RestLiServiceException getServiceException();

  
  List<? extends RecordTemplate> getCollectionResponse();

  
  void setCollectionResponse(List<? extends RecordTemplate> responseEntities) throws RestLiResponseDataException;

  
  CollectionMetadata getCollectionResponsePaging();

  
  void setCollectionResponsePaging(CollectionMetadata paging) throws RestLiResponseDataException;

  
  RecordTemplate getCollectionResponseCustomMetadata();

  
  void setCollectionResponseCustomMetadata(RecordTemplate metadata) throws RestLiResponseDataException;

  
  Map<?, ? extends RecordTemplate> getBatchResponseMap();

  
  void setBatchKeyResponseMap(Map<?, ? extends RecordTemplate> batchEntityMap) throws RestLiResponseDataException;
}

<code block>


package com.linkedin.restli.server;

import com.linkedin.data.DataMap;
import com.linkedin.restli.common.HttpStatus;


public class RestLiServiceException extends RuntimeException
{
  private static final long serialVersionUID = 1L;

  private final HttpStatus  _status;
  private Integer           _serviceErrorCode;
  private DataMap           _errorDetails;

  public RestLiServiceException(final HttpStatus status)
  {
    this(status, null, null);
  }

  public RestLiServiceException(final HttpStatus status, final String message)
  {
    this(status, message, null);
  }

  public RestLiServiceException(final HttpStatus status,
                                final Throwable cause)
  {
    super(cause);
    _status = status;
  }

  public RestLiServiceException(final HttpStatus status,
                                final String message,
                                final Throwable cause)
  {
    super(message, cause);
    _status = status;
  }

  public HttpStatus getStatus()
  {
    return _status;
  }

  public RestLiServiceException setServiceErrorCode(final Integer serviceErrorCode)
  {
    _serviceErrorCode = serviceErrorCode;
    return this;
  }

  public boolean hasServiceErrorCode()
  {
    return _serviceErrorCode != null;
  }

  public Integer getServiceErrorCode()
  {
    return _serviceErrorCode;
  }

  public DataMap getErrorDetails()
  {
    return _errorDetails;
  }

  public boolean hasErrorDetails()
  {
    return _errorDetails != null;
  }

  public RestLiServiceException setErrorDetails(final DataMap errorDetails)
  {
    _errorDetails = errorDetails;
    return this;
  }

  @Override
  public String toString()
  {
    StringBuilder sb = new StringBuilder();
    sb.append(getClass().getName());
    sb.append(" [HTTP Status:").append(_status.getCode());
    if (_serviceErrorCode != null)
    {
      sb.append(", serviceErrorCode:").append(_serviceErrorCode);
    }
    sb.append("]");
    String message = getLocalizedMessage();
    if (message != null)
    {
      sb.append(": ").append(message);
    }
    return sb.toString();
  }
}

<code block>
package com.linkedin.restli.server;


import java.util.EnumSet;



public enum ErrorResponseFormat
{

  
  FULL(EnumSet.allOf(ErrorResponsePart.class)),

  
  MESSAGE_AND_DETAILS(EnumSet.of(ErrorResponsePart.MESSAGE, ErrorResponsePart.DETAILS)),

  
  MESSAGE_ONLY(EnumSet.of(ErrorResponsePart.MESSAGE)),

  
  MINIMAL(EnumSet.noneOf(ErrorResponsePart.class));

  private static enum ErrorResponsePart
  {
    HEADERS,
    STATUS_CODE_IN_BODY,
    STACKTRACE,
    MESSAGE,
    SERVICE_ERROR_CODE,
    DETAILS
  }

  private final EnumSet<ErrorResponsePart> _errorPartsToShow;

  ErrorResponseFormat(EnumSet<ErrorResponsePart> errorPartsToShow)
  {
    _errorPartsToShow = errorPartsToShow;
  }

  public static ErrorResponseFormat defaultFormat()
  {
    return FULL;
  }

  public boolean showHeaders()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.HEADERS);
  }

  public boolean showStatusCodeInBody()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.STATUS_CODE_IN_BODY);
  }

  public boolean showStacktrace()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.STACKTRACE);
  }

  public boolean showMessage()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.MESSAGE);
  }

  public boolean showServiceErrorCode()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.SERVICE_ERROR_CODE);
  }

  public boolean showDetails()
  {
    return _errorPartsToShow.contains(ErrorResponsePart.DETAILS);
  }
}

<code block>


package com.linkedin.restli.server.filter;


import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.server.RestLiResponseData;

import java.util.Map;



public interface FilterResponseContext
{

  
  RestLiResponseData getResponseData();

  
  HttpStatus getHttpStatus();

  
  void setHttpStatus(HttpStatus status);

  
  Map<String, String> getResponseHeaders();
}

<code block>


package com.linkedin.restli.server.validation;


import com.linkedin.data.schema.validation.ValidationResult;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.validation.RestLiDataValidator;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.Map;


public class RestLiOutputValidationFilter implements ResponseFilter
{
  @Override
  public void onResponse(final FilterRequestContext requestContext, final FilterResponseContext responseContext)
  {
    Class<?> resourceClass = requestContext.getFilterResourceModel().getResourceClass();
    ResourceMethod method = requestContext.getMethodType();
    RestLiDataValidator validator = new RestLiDataValidator(resourceClass.getAnnotations(), requestContext.getFilterResourceModel().getValueClass(), method);
    RestLiResponseData responseData = responseContext.getResponseData();
    if (responseData.isErrorResponse())
    {
      return;
    }
    if (method == ResourceMethod.GET)
    {
      ValidationResult result = validator.validate(responseData.getEntityResponse());
      if (!result.isValid())
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, result.getMessages().toString());
      }
    }
    else if (method == ResourceMethod.GET_ALL || method == ResourceMethod.FINDER)
    {
      StringBuilder sb = new StringBuilder();
      for (RecordTemplate entity : responseData.getCollectionResponse())
      {
        ValidationResult result = validator.validate(entity);
        if (!result.isValid())
        {
          sb.append(result.getMessages().toString());
        }
      }
      if (sb.length() > 0)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, sb.toString());
      }
    }
    else if (method == ResourceMethod.BATCH_GET)
    {
      StringBuilder sb = new StringBuilder();
      for (Map.Entry<?, ? extends RecordTemplate> entry : responseData.getBatchResponseMap().entrySet())
      {
        EntityResponse<? extends RecordTemplate> entityResponse = (EntityResponse) entry.getValue();
        if (entityResponse.hasError())
        {
          continue;
        }
        ValidationResult result = validator.validate(entityResponse.getEntity());
        if (!result.isValid())
        {
          sb.append("Key: ");
          sb.append(entry.getKey());
          sb.append(", ");
          sb.append(result.getMessages().toString());
        }
      }
      if (sb.length() > 0)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, sb.toString());
      }
    }
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiResponseDataException;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.apache.commons.lang.Validate;

import static com.linkedin.restli.common.ResourceMethod.ACTION;
import static com.linkedin.restli.common.ResourceMethod.BATCH_CREATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_DELETE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_GET;
import static com.linkedin.restli.common.ResourceMethod.BATCH_PARTIAL_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.CREATE;
import static com.linkedin.restli.common.ResourceMethod.DELETE;
import static com.linkedin.restli.common.ResourceMethod.FINDER;
import static com.linkedin.restli.common.ResourceMethod.GET;
import static com.linkedin.restli.common.ResourceMethod.GET_ALL;
import static com.linkedin.restli.common.ResourceMethod.OPTIONS;
import static com.linkedin.restli.common.ResourceMethod.PARTIAL_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.UPDATE;



public class AugmentedRestLiResponseData implements RestLiResponseData
{
  private RecordTemplate _entity;
  private RestLiServiceException _serviceException;
  private List<? extends RecordTemplate> _entities;
  private Map<?, ? extends RecordTemplate> _keyEntityMap;
  private HttpStatus _status;
  private final Map<String, String> _headers;
  private CollectionMetadata _paging;
  private RecordTemplate _collectionResponseCustomMetadata;
  private final ResponseType _responseType;

  private AugmentedRestLiResponseData(ResponseType responseType,
                                      RecordTemplate entity,
                                      RestLiServiceException serviceException,
                                      List<? extends RecordTemplate> entities,
                                      CollectionMetadata paging,
                                      RecordTemplate metadata,
                                      Map<?, ? extends RecordTemplate> keyEntityMap,
                                      HttpStatus status,
                                      Map<String, String> headers)
  {
    _responseType = responseType;
    _entity = entity;
    _serviceException = serviceException;
    _entities = entities;
    _keyEntityMap = keyEntityMap;
    _status = status;
    _headers = headers;
    _paging = paging;
    _collectionResponseCustomMetadata = metadata;
  }

  @Override
  public boolean isEntityResponse()
  {
    return _entity != null;
  }

  @Override
  public boolean isCollectionResponse()
  {
    return _entities != null;
  }

  @Override
  public boolean isBatchResponse()
  {
    return _keyEntityMap != null;
  }

  @Override
  public boolean isErrorResponse()
  {
    return _serviceException != null;
  }

  @Override
  public RecordTemplate getEntityResponse()
  {
    return _entity;
  }

  @Override
  public void setEntityResponse(RecordTemplate entity) throws RestLiResponseDataException
  {
    _responseType.validateResponseData(entity);
    _entity = entity;
    _entities = null;
    _keyEntityMap = null;
    clearServiceException();
  }

  @Override
  public RestLiServiceException getServiceException()
  {
    return _serviceException;
  }

  @Override
  public List<? extends RecordTemplate> getCollectionResponse()
  {
    return _entities;
  }

  @Override
  public Map<?, ? extends RecordTemplate> getBatchResponseMap()
  {
    return _keyEntityMap;
  }

  @Override
  public CollectionMetadata getCollectionResponsePaging()
  {
    return _paging;
  }

  @Override
  public void setCollectionResponsePaging(CollectionMetadata paging) throws RestLiResponseDataException
  {
    if (paging != null && !isCollectionResponse())
    {
      throw new RestLiResponseDataException("This method can be invoked only for collection responses");
    }
    _paging = paging;
  }

  @Override
  public RecordTemplate getCollectionResponseCustomMetadata()
  {
    return _collectionResponseCustomMetadata;
  }

  @Override
  public void setCollectionResponseCustomMetadata(RecordTemplate metadata) throws RestLiResponseDataException
  {
    if (metadata != null && !isCollectionResponse())
    {
      throw new RestLiResponseDataException("This method can be invoked only for collection responses");
    }
    _collectionResponseCustomMetadata = metadata;
  }

  @Override
  public void setCollectionResponse(List<? extends RecordTemplate> responseEntities) throws RestLiResponseDataException
  {
    _responseType.validateResponseData(responseEntities);
    _entities = responseEntities;
    _entity = null;
    _keyEntityMap = null;
    clearServiceException();
  }

  @Override
  public void setBatchKeyResponseMap(Map<?, ? extends RecordTemplate> batchEntityMap) throws RestLiResponseDataException
  {
    _responseType.validateResponseData(batchEntityMap);
    _keyEntityMap = batchEntityMap;
    _entity = null;
    _entities = null;
    clearServiceException();
  }

  private void clearServiceException()
  {
    _serviceException = null;
    _headers.remove(HeaderUtil.getErrorResponseHeaderName(_headers));
  }

  public HttpStatus getStatus()
  {
    return _status;
  }

  public void setStatus(HttpStatus status)
  {
    _status = status;
  }

  public Map<String, String> getHeaders()
  {
    return _headers;
  }

  public static class Builder
  {
    private RecordTemplate _entity;
    private RestLiServiceException _serviceException;
    private List<? extends RecordTemplate> _entities;
    private Map<?, ? extends RecordTemplate> _keyEntityMap;
    private HttpStatus _status;
    private Map<String, String> _headers;
    private CollectionMetadata _collectionResponsePaging;
    private RecordTemplate _collectionMetadata;
    private final ResponseType _responseType;

    public Builder(ResourceMethod methodType)
    {
      _responseType = ResponseType.fromMethodType(methodType);
      _status = HttpStatus.S_200_OK;
      _headers = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
    }

    public Builder status(HttpStatus status)
    {
      _status = status;
      return this;
    }

    public Builder headers(Map<String, String> headers)
    {
      _headers = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
      _headers.putAll(headers);
      return this;
    }

    public Builder collectionResponsePaging(CollectionMetadata paging)
    {
      try
      {
        _responseType.validatePagingAndCustomMetadata();
      }
      catch (RestLiResponseDataException e)
      {
        throw new IllegalArgumentException(e);
      }
      _collectionResponsePaging = paging;
      return this;
    }

    public Builder collectionCustomMetadata(RecordTemplate metadata)
    {
      try
      {
        _responseType.validatePagingAndCustomMetadata();
      }
      catch (RestLiResponseDataException e)
      {
        throw new IllegalArgumentException(e);
      }
      _collectionMetadata = metadata;
      return this;
    }

    public Builder entity(RecordTemplate entity)
    {
      try
      {
        _responseType.validateResponseData(entity);
      }
      catch (RestLiResponseDataException e)
      {
        throw new IllegalArgumentException(e);
      }
      _entity = entity;
      return this;
    }

    public Builder serviceException(RestLiServiceException serviceException)
    {
      _serviceException = serviceException;
      return this;
    }

    public Builder collectionEntities(List<? extends RecordTemplate> entities)
    {
      try
      {
        _responseType.validateResponseData(entities);
      }
      catch (RestLiResponseDataException e)
      {
        throw new IllegalArgumentException(e);
      }
      _entities = entities;
      return this;
    }

    public Builder batchKeyEntityMap(Map<?, ? extends RecordTemplate> map)
    {
      try
      {
        _responseType.validateResponseData(map);
      }
      catch (RestLiResponseDataException e)
      {
        throw new IllegalArgumentException(e);
      }
      _keyEntityMap = map;
      return this;
    }

    public AugmentedRestLiResponseData build()
    {
      return new AugmentedRestLiResponseData(_responseType, _entity, _serviceException, _entities,
                                             _collectionResponsePaging, _collectionMetadata, _keyEntityMap, _status,
                                             _headers);
    }
  }

  private enum ResponseType
  {
    SIMPLE(RecordTemplate.class, false, GET, ACTION, CREATE),
    GET_COLLECTION(List.class, true, GET_ALL, FINDER),
    CREATE_COLLECTION(List.class, false, BATCH_CREATE),
    BATCH(Map.class, false, BATCH_GET, BATCH_UPDATE, BATCH_PARTIAL_UPDATE, BATCH_DELETE),
    NONE(null, false, PARTIAL_UPDATE, UPDATE, DELETE, OPTIONS);

    private ResponseType(Class<?> clasz, boolean supportsPagingAndCustomMetadata, ResourceMethod... types)
    {
      _methodTypes = Arrays.asList(types);
      _class = clasz;
      _supportsPagingAndCustomMetadata = supportsPagingAndCustomMetadata;
    }

    public static ResponseType fromMethodType(ResourceMethod type)
    {
      for (ResponseType responseType : values())
      {
        if (responseType._methodTypes.contains(type))
        {
          return responseType;
        }
      }
      return NONE;
    }

    public void validatePagingAndCustomMetadata() throws RestLiResponseDataException
    {
      if (!_supportsPagingAndCustomMetadata)
      {
        throw new RestLiResponseDataException(String.format("Paging and/or custom metadata "
            + "is not permitted for %s method types.", _methodTypes));
      }
    }

    public void validateResponseData(Object value) throws RestLiResponseDataException
    {
      if (_class != null)
      {
        Validate.notNull(value);
        if (!_class.isAssignableFrom(value.getClass()))
        {
          throw new RestLiResponseDataException(
                                                String.format("Response data of type %s is not permitted for %s method types.",
                                                              value.getClass().getSimpleName(), _methodTypes));
        }
      }
      else
      {
        throw new RestLiResponseDataException(String.format("No response data is permitted for %s method types",
                                                            _methodTypes));
      }
    }

    private final List<ResourceMethod> _methodTypes;
    private final Class<?> _class;
    private final boolean _supportsPagingAndCustomMetadata;
  }
}

<code block>



package com.linkedin.restli.internal.server;

import com.linkedin.data.DataMap;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.methods.MethodAdapterRegistry;
import com.linkedin.restli.internal.server.methods.response.ErrorResponseBuilder;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.internal.server.methods.response.RestLiResponseBuilder;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.internal.server.util.DataMapUtils;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.resources.CollectionResource;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Map;
import java.util.TreeMap;



public class RestLiResponseHandler
{
  private final MethodAdapterRegistry _methodAdapterRegistry;
  private final ErrorResponseBuilder _errorResponseBuilder;

  public RestLiResponseHandler(MethodAdapterRegistry methodAdapterRegistry, ErrorResponseBuilder errorResponseBuilder)
  {
    _methodAdapterRegistry = methodAdapterRegistry;
    _errorResponseBuilder = errorResponseBuilder;
  }

  public static class Builder
  {
    private MethodAdapterRegistry _methodAdapterRegistry = null;
    private ErrorResponseBuilder _errorResponseBuilder = null;
    private boolean _permissiveEncoding = false;

    public Builder setMethodAdapterRegistry(MethodAdapterRegistry methodAdapterRegistry)
    {
      _methodAdapterRegistry = methodAdapterRegistry;
      return this;
    }

    public Builder setErrorResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
    {
      _errorResponseBuilder = errorResponseBuilder;
      return this;
    }

    public RestLiResponseHandler build()
    {
      if (_errorResponseBuilder == null)
      {
        _errorResponseBuilder = new ErrorResponseBuilder();
      }
      if (_methodAdapterRegistry == null)
      {
        _methodAdapterRegistry = new MethodAdapterRegistry(_errorResponseBuilder);
      }
      return new RestLiResponseHandler(_methodAdapterRegistry, _errorResponseBuilder);
    }
  }

  
  public RestResponse buildResponse(final RestRequest request,
                                    final RoutingResult routingResult,
                                    final Object responseObject) throws IOException
  {
    return buildResponse(routingResult,
                         buildPartialResponse(routingResult,
                                              buildRestLiResponseData(request, routingResult, responseObject)));
  }


  
  public RestResponse buildResponse(final RoutingResult routingResult,
                                     PartialRestResponse partialResponse)
  {
    RestResponseBuilder builder =
        new RestResponseBuilder().setHeaders(partialResponse.getHeaders()).setStatus(partialResponse.getStatus()
                                                                                                    .getCode());
    if (partialResponse.hasData())
    {
      DataMap dataMap = partialResponse.getDataMap();
      String mimeType = ((ServerResourceContext) routingResult.getContext()).getResponseMimeType();
      builder = encodeResult(mimeType, builder, dataMap);
    }
    return builder.build();
  }

  
  public PartialRestResponse buildPartialResponse(final RoutingResult routingResult,
                                                  final AugmentedRestLiResponseData responseData)
  {
    if (responseData.isErrorResponse()){
      return _errorResponseBuilder.buildResponse(routingResult, responseData);
    }
    return chooseResponseBuilder(null, routingResult).buildResponse(routingResult, responseData);
  }

  
  public AugmentedRestLiResponseData buildRestLiResponseData(final RestRequest request,
                                                            final RoutingResult routingResult,
                                                            final Object responseObject) throws IOException
  {
    ServerResourceContext context = (ServerResourceContext) routingResult.getContext();
    final ProtocolVersion protocolVersion = context.getRestliProtocolVersion();
    Map<String, String> responseHeaders = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
    responseHeaders.putAll(context.getResponseHeaders());
    responseHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());

    if (responseObject == null)
    {
      
      if (routingResult.getResourceMethod().getType().equals(ResourceMethod.ACTION))
      {
        return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType())
            .status(HttpStatus.S_200_OK).headers(responseHeaders).build();
      }
      else if (routingResult.getResourceMethod().getType().equals(ResourceMethod.GET))
      {
        throw new RestLiServiceException(HttpStatus.S_404_NOT_FOUND,
            "Requested entity not found: " + routingResult.getResourceMethod());
      }
      else
      {
        
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null returned by the resource method: " + routingResult.getResourceMethod());
      }
    }

    RestLiResponseBuilder responseBuilder = chooseResponseBuilder(responseObject, routingResult);

    if (responseBuilder == null)
    {
      
      ResourceMethodDescriptor resourceMethod = routingResult.getResourceMethod();
      String fqMethodName =
          resourceMethod.getResourceModel().getResourceClass().getName() + '#'
              + routingResult.getResourceMethod().getMethod().getName();
      throw new RestLiInternalException("Invalid return type '" + responseObject.getClass() + " from method '"
          + fqMethodName + '\'');
    }
    return responseBuilder.buildRestLiResponseData(request, routingResult, responseObject, responseHeaders);
  }

  public AugmentedRestLiResponseData buildExceptionResponseData(final RestRequest request,
                                                                final RoutingResult routingResult,
                                                                final Object object,
                                                                final Map<String, String> headers)
  {
    return _errorResponseBuilder.buildRestLiResponseData(request, routingResult, object, headers);
  }

  public RestException buildRestException(final Throwable e, PartialRestResponse partialResponse)
  {
    RestResponseBuilder builder =
        new RestResponseBuilder().setHeaders(partialResponse.getHeaders()).setStatus(partialResponse.getStatus()
                                                                                                    .getCode());
    if (partialResponse.hasData())
    {
      DataMap dataMap = partialResponse.getDataMap();
      ByteArrayOutputStream baos = new ByteArrayOutputStream(4096);
      DataMapUtils.write(dataMap, null, baos, true); 
      builder.setEntity(baos.toByteArray());
    }
    RestResponse restResponse = builder.build();
    RestException restException = new RestException(restResponse, e);
    return restException;
  }


  private RestResponseBuilder encodeResult(String mimeType, RestResponseBuilder builder, DataMap dataMap)
  {
    if (RestConstants.HEADER_VALUE_APPLICATION_PSON.equalsIgnoreCase(mimeType))
    {
      builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, RestConstants.HEADER_VALUE_APPLICATION_PSON);
      builder.setEntity(DataMapUtils.mapToPsonBytes(dataMap));
    }
    else if (RestConstants.HEADER_VALUE_APPLICATION_JSON.equalsIgnoreCase(mimeType))
    {
      builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, RestConstants.HEADER_VALUE_APPLICATION_JSON);
      builder.setEntity(DataMapUtils.mapToBytes(dataMap));
    }
    else
    {
      throw new RoutingException("No acceptable types can be returned", HttpStatus.S_406_NOT_ACCEPTABLE.getCode());
    }
    return builder;
  }

  private RestLiResponseBuilder chooseResponseBuilder(final Object responseObject,
                                                      final RoutingResult routingResult)
  {
    if (responseObject != null && responseObject instanceof RestLiServiceException)
    {
      return _errorResponseBuilder;
    }

    return _methodAdapterRegistry.getResponsebuilder(routingResult.getResourceMethod()
                                                                 .getType());
  }
}

<code block>



package com.linkedin.restli.internal.server;

import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.filter.FilterResponseContextInternal;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.server.RequestExecutionCallback;
import com.linkedin.restli.server.RequestExecutionReport;
import com.linkedin.restli.server.RestLiResponseData;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;


public class RestLiCallback<T> implements RequestExecutionCallback<T>
{
  private final RoutingResult _method;
  private final RestLiResponseHandler _responseHandler;
  private final RequestExecutionCallback<RestResponse> _callback;
  private final RestRequest _request;
  private final List<ResponseFilter> _responseFilters;
  private final FilterRequestContext _filterRequestContext;

  public RestLiCallback(final RestRequest request,
                        final RoutingResult method,
                        final RestLiResponseHandler responseHandler,
                        final RequestExecutionCallback<RestResponse> callback,
                        final List<ResponseFilter> responseFilters,
                        final FilterRequestContext filterRequestContext)
  {
    _request = request;
    _method = method;
    _responseHandler = responseHandler;
    _callback = callback;
    if (responseFilters != null)
    {
      _responseFilters = responseFilters;
    }
    else
    {
      _responseFilters = new ArrayList<ResponseFilter>();
    }
    _filterRequestContext = filterRequestContext;
  }

  @Override
  public void onSuccess(final T result, RequestExecutionReport executionReport)
  {
    try
    {
      
      final AugmentedRestLiResponseData responseData = _responseHandler.buildRestLiResponseData(_request, _method, result);
      
      if (_responseFilters != null && !_responseFilters.isEmpty())
      {
        invokeFiltersAndProcessResults(executionReport, responseData, null);
      }
      else
      {
        
        final PartialRestResponse response = _responseHandler.buildPartialResponse(_method, responseData);
        
        _callback.onSuccess(_responseHandler.buildResponse(_method, response), executionReport);
      }
    }
    catch (Exception e)
    {
      
      
      
      onError(e, executionReport);
    }
  }

  @Override
  public void onError(final Throwable e, RequestExecutionReport executionReport)
  {
    final AugmentedRestLiResponseData responseData = convertExceptionToRestLiResponseData(e);
    
    if (_responseFilters != null && !_responseFilters.isEmpty())
    {
      invokeFiltersAndProcessResults(executionReport, responseData, e);
    }
    else
    {
      
      _callback.onError(_responseHandler.buildRestException(e, _responseHandler.buildPartialResponse(_method,
                                                                                                     responseData)),
                        executionReport);
    }
  }

  private void invokeFiltersAndProcessResults(RequestExecutionReport executionReport,
                                              final AugmentedRestLiResponseData responseData,
                                              final Throwable appEx)
  {
    
    final FilterResponseContextInternal responseContext = new FilterResponseContextAdapter(responseData);
    try
    {
      invokeResponseFilters(responseContext, appEx);
      
      
      
      final PartialRestResponse response = _responseHandler.buildPartialResponse(_method, responseContext.getAugmentedRestLiResponseData());
      
      _callback.onSuccess(_responseHandler.buildResponse(_method, response), executionReport);
    }
    catch (Throwable e)
    {
      
      _callback.onError(_responseHandler.buildRestException(e,
                                                            _responseHandler.buildPartialResponse(_method,
                                                                                                  responseContext.getAugmentedRestLiResponseData())),
                        executionReport);
    }
  }

  private RestException toRestException(final Throwable e)
  {
    PartialRestResponse partialResponse =
        _responseHandler.buildPartialResponse(_method, convertExceptionToRestLiResponseData(e));
    return _responseHandler.buildRestException(e, partialResponse);
  }

  
  AugmentedRestLiResponseData convertExceptionToRestLiResponseData(Throwable e)
  {
    RestLiServiceException restLiServiceException;
    if (e instanceof RestLiServiceException)
    {
      restLiServiceException = (RestLiServiceException) e;
    }
    else if (e instanceof RoutingException)
    {
      RoutingException routingException = (RoutingException) e;

      restLiServiceException =
          new RestLiServiceException(HttpStatus.fromCode(routingException.getStatus()),
                                     routingException.getMessage(),
                                     routingException);
    }
    else
    {
      restLiServiceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, e.getMessage(), e);
    }

    Map<String, String> requestHeaders = _request.getHeaders();
    Map<String, String> headers = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION,
                ProtocolVersionUtil.extractProtocolVersion(requestHeaders).toString());
    headers.put(HeaderUtil.getErrorResponseHeaderName(requestHeaders), RestConstants.HEADER_VALUE_ERROR);
    return _responseHandler.buildExceptionResponseData(_request, _method, restLiServiceException, headers);
  }

  private void invokeResponseFilters(final FilterResponseContextInternal responseContext, Throwable lastException) throws Throwable
  {
    for (ResponseFilter filter : _responseFilters)
    {
      try
      {
        filter.onResponse(_filterRequestContext, responseContext);
        
        
        if (!responseContext.getAugmentedRestLiResponseData().isErrorResponse())
        {
          lastException = null;
        }
      }
      catch (Exception ex)
      {
        
        lastException = ex;
        responseContext.setAugmentedRestLiResponseData(convertExceptionToRestLiResponseData(ex));
      }
    }
    
    if (lastException != null)
    {
      throw lastException;
    }
  }

  
  static class FilterResponseContextAdapter implements FilterResponseContextInternal
  {
    private AugmentedRestLiResponseData _responseData;
    public FilterResponseContextAdapter(final AugmentedRestLiResponseData response)
    {
      _responseData = response;
    }

    @Override
    public void setHttpStatus(HttpStatus status)
    {
      _responseData.setStatus(status);
    }

    @Override
    public Map<String, String> getResponseHeaders()
    {
      return _responseData.getHeaders();
    }

    @Override
    public HttpStatus getHttpStatus()
    {
      return _responseData.getStatus();
    }

    @Override
    public RestLiResponseData getResponseData()
    {
      return _responseData;
    }

    @Override
    public void setAugmentedRestLiResponseData(AugmentedRestLiResponseData data)
    {
      _responseData = data;
    }

    @Override
    public AugmentedRestLiResponseData getAugmentedRestLiResponseData()
    {
      return _responseData;
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.filter;


import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.server.filter.FilterResponseContext;



public interface FilterResponseContextInternal extends FilterResponseContext
{
  
  void setAugmentedRestLiResponseData(AugmentedRestLiResponseData data);

  
  AugmentedRestLiResponseData getAugmentedRestLiResponseData();
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.template.FieldDef;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.ActionResult;
import com.linkedin.restli.server.RestLiServiceException;
import java.util.Map;


public class ActionResponseBuilder implements RestLiResponseBuilder
{

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult,
                                           AugmentedRestLiResponseData responseData)
  {
    return new PartialRestResponse.Builder().status(responseData.getStatus())
                                            .entity(responseData.getEntityResponse())
                                            .headers(responseData.getHeaders())
                                            .build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request,
                                                            RoutingResult routingResult,
                                                            Object result,
                                                            Map<String, String> headers)
  {
    final Object value;
    final HttpStatus status;
    if (result instanceof ActionResult)
    {
      final ActionResult<?> actionResult = (ActionResult<?>) result;
      value = actionResult.getValue();
      status = actionResult.getStatus();
      if (status == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null HttpStatus inside of an ActionResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }
    }
    else
    {
      value = result;
      status = HttpStatus.S_200_OK;
    }
    RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();
    @SuppressWarnings("unchecked")
    FieldDef<Object> actionReturnFieldDef =
        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();
    final ActionResponse<?> actionResponse =
        new ActionResponse<Object>(value, actionReturnFieldDef, actionReturnRecordDataSchema);
    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).status(status).entity(actionResponse).headers(headers).build();
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;


public class BatchCreateResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchCreateResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    @SuppressWarnings("unchecked")
    List<CreateIdStatus<Object>> elements = (List<CreateIdStatus<Object>>) responseData.getCollectionResponse();
    BatchCreateIdResponse<Object> batchCreateIdResponse = new BatchCreateIdResponse<Object>(elements);
    builder.entity(batchCreateIdResponse);
    return builder.headers(responseData.getHeaders()).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    BatchCreateResult<?, ?> list = (BatchCreateResult<?, ?>) result;

    
    if (list.getResults() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null List inside of a BatchCreateResult returned by the resource method: " + routingResult
              .getResourceMethod());
    }

    List<CreateIdStatus<Object>> statuses = new ArrayList<CreateIdStatus<Object>>(list.getResults().size());
    for (CreateResponse e : list.getResults())
    {
      
      if (e == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null element inside of List inside of a BatchCreateResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }
      statuses.add(new CreateIdStatus<Object>(e.getStatus().getCode(), e.getId(), e.getError() == null ? null
          : _errorResponseBuilder.buildErrorResponse(e.getError()), ProtocolVersionUtil.extractProtocolVersion(headers)));
    }
    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).headers(headers)
                                                                                                     .collectionEntities(statuses)
                                                                                                     .build();
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ResourceContext;

import java.util.Map;


public class GetResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    return new PartialRestResponse.Builder().headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .entity(responseData.getEntityResponse()).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    final RecordTemplate record;
    final HttpStatus status;
    if (result instanceof GetResult)
    {
      final GetResult<?> getResult = (GetResult<?>) result;
      record = getResult.getValue();
      status = getResult.getStatus();
    }
    else
    {
      record = (RecordTemplate) result;
      status = HttpStatus.S_200_OK;
    }
    final ResourceContext resourceContext = routingResult.getContext();
    final DataMap data = RestUtils.projectFields(record.data(), resourceContext.getProjectionMode(),
        resourceContext.getProjectionMask());
    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).headers(headers)
                                                                                                     .status(status)
                                                                                                     .entity(new AnyRecord(data))
                                                                                                     .build();
  }
}
<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.ErrorDetails;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.common.ProtocolVersionUtil;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.ErrorResponseFormat;
import com.linkedin.restli.server.RestLiServiceException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Map;



public final class ErrorResponseBuilder implements RestLiResponseBuilder
{
  public static final String DEFAULT_INTERNAL_ERROR_MESSAGE = "Error in application code";
  private final ErrorResponseFormat _errorResponseFormat;
  private final String _internalErrorMessage;

  public ErrorResponseBuilder()
  {
    this(ErrorResponseFormat.defaultFormat());
  }

  public ErrorResponseBuilder(ErrorResponseFormat errorResponseFormat)
  {
    this(errorResponseFormat, DEFAULT_INTERNAL_ERROR_MESSAGE);
  }

  public ErrorResponseBuilder(ErrorResponseFormat errorResponseFormat, String internalErrorMessage)
  {
    _errorResponseFormat = errorResponseFormat;
    _internalErrorMessage = internalErrorMessage;
  }

  public String getInternalErrorMessage()
  {
    return _internalErrorMessage;
  }

  public ErrorResponse buildErrorResponse(RestLiServiceException result)
  {
    ErrorResponse er = new ErrorResponse();
    if (_errorResponseFormat.showStatusCodeInBody())
    {
      er.setStatus(result.getStatus().getCode());
    }

    if (_errorResponseFormat.showMessage() && result.getMessage() != null)
    {
      er.setMessage(result.getMessage());
    }
    if (_errorResponseFormat.showServiceErrorCode() && result.hasServiceErrorCode())
    {
      er.setServiceErrorCode(result.getServiceErrorCode());
    }
    if (_errorResponseFormat.showDetails() && result.hasErrorDetails())
    {
      er.setErrorDetails(new ErrorDetails(result.getErrorDetails()));
    }

    if (_errorResponseFormat.showStacktrace())
    {
      StringWriter sw = new StringWriter();
      PrintWriter pw = new PrintWriter(sw);
      result.printStackTrace(pw);
      er.setStackTrace(sw.toString());

      er.setExceptionClass(result.getClass().getName());
    }

    return er;
  }

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    ErrorResponse errorResponse = buildErrorResponse(responseData.getServiceException());
    return new PartialRestResponse.Builder().headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .entity(errorResponse).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object object, Map<String, String> headers)
  {
    RestLiServiceException exceptionResult = (RestLiServiceException) object;
    if (_errorResponseFormat.showHeaders())
    {
      final ProtocolVersion protocolVersion = ProtocolVersionUtil.extractProtocolVersion(headers);
      headers.put(HeaderUtil.getErrorResponseHeaderName(protocolVersion), RestConstants.HEADER_VALUE_ERROR);
    }
    final ResourceMethod type;
    if (routingResult != null && routingResult.getResourceMethod() != null)
    {
      type = routingResult.getResourceMethod().getMethodType();
    }
    else
    {
      type = null;
    }
    return new AugmentedRestLiResponseData.Builder(type).headers(headers).status(exceptionResult.getStatus()).serviceException(exceptionResult)
        .build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.Map;


public class UpdateResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    return new PartialRestResponse.Builder().headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    UpdateResponse updateResponse = (UpdateResponse) result;
    
    if (updateResponse.getStatus() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. HttpStatus is null inside of a UpdateResponse returned by the resource method: "
              + routingResult.getResourceMethod());
    }
    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).headers(headers)
                                                                                                     .status(updateResponse.getStatus())
                                                                                                     .build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataList;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CollectionResult.PageIncrement;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;


public class CollectionResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    CollectionResponse<AnyRecord> collectionResponse = new CollectionResponse<AnyRecord>(AnyRecord.class);
    collectionResponse.setPaging(responseData.getCollectionResponsePaging());
    DataList elementsMap = (DataList) collectionResponse.data().get(CollectionResponse.ELEMENTS);
    for (RecordTemplate entry : responseData.getCollectionResponse())
    {
      CheckedUtil.addWithoutChecking(elementsMap, entry.data());
    }
    if (responseData.getCollectionResponseCustomMetadata() != null)
    {
      collectionResponse.setMetadataRaw(responseData.getCollectionResponseCustomMetadata().data());
    }
    builder.entity(collectionResponse);
    return builder.headers(responseData.getHeaders()).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object object, Map<String, String> headers)
  {
    if (object instanceof List)
    {
      @SuppressWarnings({ "unchecked" })
      
      List<? extends RecordTemplate> result = (List<? extends RecordTemplate>) object;

      return buildRestLiResponseData(request, routingResult, result, PageIncrement.RELATIVE, null, null, headers);
    }
    else
    {
      @SuppressWarnings({ "unchecked" })
      
      CollectionResult<? extends RecordTemplate, ? extends RecordTemplate> collectionResult =
          (CollectionResult<? extends RecordTemplate, ? extends RecordTemplate>) object;

      
      if (collectionResult.getElements() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null elements List inside of CollectionResult returned by the resource method: "
                + routingResult.getResourceMethod());
      }

      return buildRestLiResponseData(request, routingResult, collectionResult.getElements(),
                                     collectionResult.getPageIncrement(), collectionResult.getMetadata(),
                                     collectionResult.getTotal(), headers);
    }
  }

  private static AugmentedRestLiResponseData buildRestLiResponseData(final RestRequest request,
                                                                     final RoutingResult routingResult,
                                                                     final List<? extends RecordTemplate> elements,
                                                                     final PageIncrement pageIncrement,
                                                                     final RecordTemplate customMetadata,
                                                                     final Integer totalResults,
                                                                     final Map<String, String> headers)
  {
    
    final ResourceContext resourceContext = routingResult.getContext();

    
    final CollectionMetadata paging =
        RestUtils.buildMetadata(request.getURI(), resourceContext, routingResult.getResourceMethod(),
                                elements, pageIncrement, totalResults);

    
    
    
    
    
    
    
    
    
    
    
    
    
    final RecordTemplate anyRecord = new AnyRecord(RestUtils.projectFields(paging.data(),
        ProjectionMode.AUTOMATIC, resourceContext.getPagingProjectionMask()));
    final CollectionMetadata projectedPaging = new CollectionMetadata(anyRecord.data());

    
    List<AnyRecord> processedElements = new ArrayList<AnyRecord>(elements.size());
    for (RecordTemplate entry : elements)
    {
      
      if (entry == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null element inside of a List returned by the resource method: " + routingResult
                .getResourceMethod());
      }
      processedElements.add(new AnyRecord(RestUtils
          .projectFields(entry.data(), resourceContext.getProjectionMode(), resourceContext.getProjectionMask())));
    }

    
    final AnyRecord projectedCustomMetadata;
    if (customMetadata != null)
    {
      projectedCustomMetadata = new AnyRecord(RestUtils
          .projectFields(customMetadata.data(), resourceContext.getMetadataProjectionMode(),
              resourceContext.getMetadataProjectionMask()));
    }
    else
    {
      projectedCustomMetadata = null;
    }

    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).headers(headers)
        .collectionEntities(processedElements)
        .collectionResponsePaging(projectedPaging)
        .collectionCustomMetadata(projectedCustomMetadata).build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.HashMap;
import java.util.Map;



class BatchResponseUtil
{
  static <K> Map<K, ErrorResponse> populateErrors(final Map<K, RestLiServiceException> serviceErrors,
                                                  final RoutingResult routingResult,
                                                  final ErrorResponseBuilder builder)
  {
    final Map<K, ErrorResponse> mergedErrors = new HashMap<K, ErrorResponse>();

    for (Map.Entry<K, RestLiServiceException> serviceErrorEntry : serviceErrors.entrySet())
    {
      if (serviceErrorEntry.getKey() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null key inside of the errors map returned by resource method: "
                + routingResult.getResourceMethod());
      }

      if (serviceErrorEntry.getValue() == null)
      {
        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
            "Unexpected null encountered. Null value inside of the errors map returned by resource method: "
                + routingResult.getResourceMethod());
      }
      mergedErrors.put(serviceErrorEntry.getKey(), builder.buildErrorResponse(serviceErrorEntry.getValue()));
    }

    final ServerResourceContext context = (ServerResourceContext) routingResult.getContext();
    for (Map.Entry<Object, RestLiServiceException> batchErrorEntry : context.getBatchKeyErrors().entrySet())
    {
      @SuppressWarnings("unchecked")
      final K errorKey = (K) batchErrorEntry.getKey();
      mergedErrors.put(errorKey, builder.buildErrorResponse(batchErrorEntry.getValue()));
    }

    return mergedErrors;
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.data.template.SetMode;
import com.linkedin.internal.common.util.CollectionUtils;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.server.BatchResult;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


public class BatchGetResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchGetResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    final ProtocolVersion protocolVersion =
        ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();
    @SuppressWarnings("unchecked")
    final BatchResponse<AnyRecord> response =
        toBatchResponse((Map<Object, EntityResponse<RecordTemplate>>) responseData.getBatchResponseMap(),
                        protocolVersion);
    builder.entity(response);
    return builder.headers(responseData.getHeaders()).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    @SuppressWarnings({ "unchecked" })
    
    final Map<Object, RecordTemplate> entities = (Map<Object, RecordTemplate>) result;
    Map<Object, HttpStatus> statuses = Collections.emptyMap();
    Map<Object, RestLiServiceException> serviceErrors = Collections.emptyMap();

    if (result instanceof BatchResult)
    {
      @SuppressWarnings({ "unchecked" })
      
      final BatchResult<Object, RecordTemplate> batchResult = (BatchResult<Object, RecordTemplate>) result;
      statuses = batchResult.getStatuses();
      serviceErrors = batchResult.getErrors();
    }

    final ServerResourceContext context = (ServerResourceContext) routingResult.getContext();
    
    final Map<Object, ErrorResponse> errors =
        BatchResponseUtil.populateErrors(serviceErrors, routingResult, _errorResponseBuilder);

    final Set<Object> mergedKeys = new HashSet<Object>(entities.keySet());
    mergedKeys.addAll(statuses.keySet());
    
    
    
    if (mergedKeys.contains(null))
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null key inside of a Map returned by the resource method: " + routingResult
              .getResourceMethod());
    }

    mergedKeys.addAll(errors.keySet());

    final Map<Object, EntityResponse<RecordTemplate>> results =
        new HashMap<Object, EntityResponse<RecordTemplate>>(
            CollectionUtils.getMapInitialCapacity(mergedKeys.size(), 0.75f), 0.75f);

    for (Object key : mergedKeys)
    {
      final EntityResponse<RecordTemplate> entityResponse;

      final RecordTemplate entityTemplate = entities.get(key);
      if (entityTemplate == null)
      {
        entityResponse = new EntityResponse<RecordTemplate>(null);
      }
      else
      {
        @SuppressWarnings("unchecked")
        final Class<RecordTemplate> entityClass = (Class<RecordTemplate>) entityTemplate.getClass();
        entityResponse = new EntityResponse<RecordTemplate>(entityClass);

        final DataMap projectedData =
            RestUtils.projectFields(entityTemplate.data(), context.getProjectionMode(), context.getProjectionMask());
        CheckedUtil.putWithoutChecking(entityResponse.data(), EntityResponse.ENTITY, projectedData);
      }

      entityResponse.setStatus(statuses.get(key), SetMode.IGNORE_NULL);
      entityResponse.setError(errors.get(key), SetMode.IGNORE_NULL);
      results.put(key, entityResponse);
    }
    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).batchKeyEntityMap(results)
                                                                                                     .headers(headers)
                                                                                                     .build();
  }

  private static <K, V extends RecordTemplate> BatchResponse<AnyRecord> toBatchResponse(Map<K, EntityResponse<V>> entities,
                                                                                        ProtocolVersion protocolVersion)
  {
    final DataMap splitResponseData = new DataMap();
    final DataMap splitResults = new DataMap();
    final DataMap splitStatuses = new DataMap();
    final DataMap splitErrors = new DataMap();

    for (Map.Entry<K, EntityResponse<V>> resultEntry : entities.entrySet())
    {
      final DataMap entityResponseData = resultEntry.getValue().data();
      final String stringKey = URIParamUtils.encodeKeyForBody(resultEntry.getKey(), false, protocolVersion);

      final DataMap entityData = entityResponseData.getDataMap(EntityResponse.ENTITY);
      if (entityData != null)
      {
        CheckedUtil.putWithoutChecking(splitResults, stringKey, entityData);
      }

      final Integer status = entityResponseData.getInteger(EntityResponse.STATUS);
      if (status != null)
      {
        CheckedUtil.putWithoutChecking(splitStatuses, stringKey, status);
      }

      final DataMap error = entityResponseData.getDataMap(EntityResponse.ERROR);
      if (error != null)
      {
        CheckedUtil.putWithoutChecking(splitErrors, stringKey, error);
      }
    }

    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.RESULTS, splitResults);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.STATUSES, splitStatuses);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.ERRORS, splitErrors);

    return new BatchResponse<AnyRecord>(splitResponseData, AnyRecord.class);
  }
}

<code block>




package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;

import java.util.Map;



public interface RestLiResponseBuilder
{
  PartialRestResponse buildResponse(RoutingResult routingResult,
                                    AugmentedRestLiResponseData responseData);

  AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request,
                                                     RoutingResult routingResult,
                                                     Object result,
                                                     Map<String, String> headers);
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.jersey.api.uri.UriBuilder;
import com.linkedin.jersey.api.uri.UriComponent;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Map;


public class CreateResponseBuilder implements RestLiResponseBuilder
{
  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    return new PartialRestResponse.Builder().entity(responseData.getEntityResponse())
                                            .headers(responseData.getHeaders()).status(responseData.getStatus())
                                            .build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    CreateResponse createResponse = (CreateResponse) result;
    if (createResponse.hasId())
    {
      final ProtocolVersion protocolVersion = ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();
      String stringKey = URIParamUtils.encodeKeyForUri(createResponse.getId(), UriComponent.Type.PATH_SEGMENT, protocolVersion);
      UriBuilder uribuilder = UriBuilder.fromUri(request.getURI());
      uribuilder.path(stringKey);
      headers.put(RestConstants.HEADER_LOCATION, uribuilder.build((Object) null).toString());
    }
    IdResponse<?> idResponse = new IdResponse<Object>(createResponse.getId());

    
    if (createResponse.getStatus() == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. HttpStatus is null inside of a CreateResponse from the resource method: "
              + routingResult.getResourceMethod());
    }

    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).entity(idResponse)
                                                                                                     .headers(headers)
                                                                                                     .status(createResponse.getStatus())
                                                                                                     .build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.collections.CheckedUtil;
import com.linkedin.internal.common.util.CollectionUtils;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.URIParamUtils;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.AnyRecord;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


public final class BatchUpdateResponseBuilder implements RestLiResponseBuilder
{
  private final ErrorResponseBuilder _errorResponseBuilder;

  public BatchUpdateResponseBuilder(ErrorResponseBuilder errorResponseBuilder)
  {
    _errorResponseBuilder = errorResponseBuilder;
  }

  @Override
  public PartialRestResponse buildResponse(RoutingResult routingResult, AugmentedRestLiResponseData responseData)
  {
    PartialRestResponse.Builder builder = new PartialRestResponse.Builder();
    final ProtocolVersion protocolVersion =
        ((ServerResourceContext) routingResult.getContext()).getRestliProtocolVersion();
    @SuppressWarnings("unchecked")
    final BatchResponse<AnyRecord> response =
        toBatchResponse((Map<Object, UpdateStatus>) responseData.getBatchResponseMap(), protocolVersion);
    builder.entity(response);
    return builder.headers(responseData.getHeaders()).build();
  }

  @Override
  public AugmentedRestLiResponseData buildRestLiResponseData(RestRequest request, RoutingResult routingResult,
                                                             Object result, Map<String, String> headers)
  {
    @SuppressWarnings({ "unchecked" })
    
    final BatchUpdateResult<Object, ?> updateResult = (BatchUpdateResult<Object, ?>) result;

    final Map<Object, UpdateResponse> results = updateResult.getResults();
    
    if (results == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null Map found inside of the BatchUpdateResult returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    final Map<Object, RestLiServiceException> serviceErrors = updateResult.getErrors();
    
    
    
    if (serviceErrors == null)
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null errors Map found inside of the BatchUpdateResult returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    final Map<Object, ErrorResponse> errors =
        BatchResponseUtil.populateErrors(serviceErrors, routingResult, _errorResponseBuilder);

    final Set<Object> mergedKeys = new HashSet<Object>(results.keySet());
    
    
    
    if (mergedKeys.contains(null))
    {
      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
          "Unexpected null encountered. Null key inside of the Map returned inside of the BatchUpdateResult returned by the resource method: "
              + routingResult.getResourceMethod());
    }

    mergedKeys.addAll(errors.keySet());

    final Map<Object, UpdateStatus> mergedResults =
        new HashMap<Object, UpdateStatus>(
            CollectionUtils.getMapInitialCapacity(mergedKeys.size(), 0.75f), 0.75f);

    for (Object key : mergedKeys)
    {
      final UpdateStatus mergedResult = new UpdateStatus();

      final UpdateResponse update = results.get(key);
      if (update != null)
      {
        mergedResult.setStatus(update.getStatus().getCode());
      }

      final ErrorResponse error = errors.get(key);
      if (error != null)
      {
        
        
        mergedResult.setStatus(error.getStatus());
        mergedResult.setError(error);
      }

      mergedResults.put(key, mergedResult);
    }

    return new AugmentedRestLiResponseData.Builder(routingResult.getResourceMethod().getMethodType()).batchKeyEntityMap(mergedResults)
                                                                                                     .headers(headers)
                                                                                                     .build();
  }

  private static <K> BatchResponse<AnyRecord> toBatchResponse(Map<K, UpdateStatus> statuses,
                                                              ProtocolVersion protocolVersion)
  {
    final DataMap splitResponseData = new DataMap();
    final DataMap splitStatuses = new DataMap();
    final DataMap splitErrors = new DataMap();

    for (Map.Entry<K, UpdateStatus> statusEntry : statuses.entrySet())
    {
      final DataMap statusData = statusEntry.getValue().data();
      final String stringKey = URIParamUtils.encodeKeyForBody(statusEntry.getKey(), false, protocolVersion);

      final DataMap error = statusData.getDataMap("error");
      if (error == null)
      {
        
        CheckedUtil.putWithoutChecking(splitStatuses, stringKey, statusData);
      }
      else
      {
        CheckedUtil.putWithoutChecking(splitErrors, stringKey, error);
      }
    }

    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.RESULTS, splitStatuses);
    CheckedUtil.putWithoutChecking(splitResponseData, BatchResponse.ERRORS, splitErrors);

    return new BatchResponse<AnyRecord>(splitResponseData, AnyRecord.class);
  }
}

<code block>


package com.linkedin.restli.server.test;


import com.linkedin.data.ByteString;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.DataCodec;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.codec.PsonDataCodec;
import com.linkedin.data.schema.RecordDataSchema;
import com.linkedin.data.template.DataTemplateUtil;
import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.data.template.FieldDef;
import com.linkedin.data.template.StringMap;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.CreateStatus;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.Link;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.PathKeysImpl;
import com.linkedin.restli.internal.server.ResourceContextImpl;
import com.linkedin.restli.internal.server.RestLiResponseHandler;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.internal.server.model.Parameter;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor.InterfaceType;
import com.linkedin.restli.internal.server.model.ResourceModel;
import com.linkedin.restli.internal.server.util.DataMapUtils;
import com.linkedin.restli.internal.server.util.RestLiSyntaxException;
import com.linkedin.restli.internal.server.util.RestUtils;
import com.linkedin.restli.internal.testutils.URIDetails;
import com.linkedin.restli.server.ActionResult;
import com.linkedin.restli.server.BasicCollectionResult;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ResourceLevel;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.annotations.RestLiCollection;
import com.linkedin.restli.server.resources.CollectionResourceTemplate;
import com.linkedin.restli.server.twitter.StatusCollectionResource;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.Status;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import static com.linkedin.restli.server.test.RestLiTestHelper.buildResourceModel;
import static com.linkedin.restli.server.test.RestLiTestHelper.doubleQuote;
import static org.testng.Assert.*;



public class TestRestLiResponseHandler
{
  private final RestLiResponseHandler _responseHandler = new RestLiResponseHandler.Builder().build();

  private static final String APPLICATION_JSON = "application/json";
  private static final String APPLICATION_PSON = "application/x-pson";

  private static final Map<String, String> JSON_ACCEPT_HEADERS  = Collections.singletonMap("Accept", APPLICATION_JSON);
  private static final Map<String, String> PSON_ACCEPT_HEADERS  = Collections.singletonMap("Accept", APPLICATION_PSON);
  private static final Map<String, String> EMPTY_ACCEPT_HEADERS = Collections.emptyMap();
  private static final Map<String, String> ANY_ACCEPT_HEADERS   = Collections.singletonMap("Accept", "*
  private final RoutingResult buildRoutingResultAction(Class<?> actionReturnType, RestRequest request, Map<String, String> headers)
          throws NoSuchMethodException, RestLiSyntaxException, URISyntaxException
  {
    if (actionReturnType == Void.class)
    {
      actionReturnType = Void.TYPE;
    }

    
    Method method = ProjectionTestFixture.class.getMethod("batchGet", Set.class);

    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);

    String actionName = "return" + actionReturnType.getSimpleName();
    List<Parameter<?>> parameters = Collections.<Parameter<?>>emptyList();

    RecordDataSchema actionReturnRecordDataSchema;
    FieldDef<?> returnFieldDef;
    if (actionReturnType != Void.TYPE)
    {
      @SuppressWarnings({"unchecked","rawtypes"})
      FieldDef<?> nonVoidFieldDef = new FieldDef(ActionResponse.VALUE_NAME,
                                 actionReturnType,
                                 DataTemplateUtil.getSchema(actionReturnType));
      returnFieldDef = nonVoidFieldDef;
      actionReturnRecordDataSchema = DynamicRecordMetadata.buildSchema(actionName,
                                                                       Collections.singleton(returnFieldDef));
    }
    else
    {
      returnFieldDef = null;
      actionReturnRecordDataSchema = DynamicRecordMetadata.buildSchema(actionName, Collections.<FieldDef<?>>emptyList());
    }

    ResourceMethodDescriptor methodDescriptor =
            ResourceMethodDescriptor.createForAction(method,
                                                     parameters,
                                                     actionName,
                                                     ResourceLevel.COLLECTION,
                                                     returnFieldDef,
                                                     actionReturnRecordDataSchema,
                                                     DynamicRecordMetadata.buildSchema(actionName, parameters),
                                                     InterfaceType.SYNC,
                                                     new DataMap());

    model.addResourceMethodDescriptor(methodDescriptor);

    ServerResourceContext resourceContext = new ResourceContextImpl(new PathKeysImpl(), request, new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(headers, resourceContext);
    return new RoutingResult(resourceContext, methodDescriptor);
  }

  private final RoutingResult buildRoutingResult(RestRequest request, Map<String, String> acceptHeaders)
          throws SecurityException, NoSuchMethodException, RestLiSyntaxException
  {
    return buildRoutingResult(ResourceMethod.GET, request, acceptHeaders);
  }

  private final RoutingResult buildRoutingResult(ResourceMethod resourceMethod, RestRequest request, Map<String, String> acceptHeaders)
          throws SecurityException, NoSuchMethodException, RestLiSyntaxException
  {
    Method method = ProjectionTestFixture.class.getMethod("batchGet", Set.class);
    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);
    ResourceMethodDescriptor methodDescriptor =
        ResourceMethodDescriptor.createForRestful(resourceMethod, method, InterfaceType.SYNC);
    model.addResourceMethodDescriptor(methodDescriptor);
    ServerResourceContext context =  new ResourceContextImpl(new PathKeysImpl(), request,
                            new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(acceptHeaders, context);
    return new RoutingResult(context, methodDescriptor);
  }


  private final RoutingResult buildRoutingResultFinder(RestRequest request, Map<String, String> acceptHeaders) throws SecurityException,
      NoSuchMethodException,
      RestLiSyntaxException
  {
    Method method = ProjectionTestFixture.class.getMethod("find");
    ResourceModel model = RestLiTestHelper.buildResourceModel(StatusCollectionResource.class);
    ResourceMethodDescriptor methodDescriptor =
        ResourceMethodDescriptor.createForRestful(ResourceMethod.FINDER, method, InterfaceType.SYNC);
    model.addResourceMethodDescriptor(methodDescriptor);
    ServerResourceContext context = new ResourceContextImpl(new PathKeysImpl(), request, new RequestContext());
    RestUtils.validateRequestHeadersAndUpdateResourceContext(acceptHeaders, context);
    return new RoutingResult(context, methodDescriptor);
  }

  @RestLiCollection(name="test")
  private static class ProjectionTestFixture extends CollectionResourceTemplate<Integer, Status>
  {
    @Override
    public Map<Integer, Status> batchGet(Set<Integer> ids)
    {
      return null;
    }

    public BasicCollectionResult<Status> find()
    {
      return null;
    }
  }

  private void checkResponse(PartialRestResponse response,
                             HttpStatus status,
                             int numHeaders,
                             boolean hasError,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    assertEquals(response.getStatus(), status);
    assertEquals(response.getHeaders().size(), numHeaders);
    if (hasError)
    {
      assertEquals(response.getHeader(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(response.getHeader(errorResponseHeaderName));
    }

    assertEquals(response.getEntity() != null, hasEntity);
  }

  private void checkResponseData(AugmentedRestLiResponseData responseData, HttpStatus status, int numHeaders,
                                 boolean hasError, boolean hasEntity, String errorResponseHeaderName)
  {
    assertEquals(responseData.getStatus(), status);
    assertEquals(responseData.getHeaders().size(), numHeaders);
    if (hasError)
    {
      assertEquals(responseData.getHeaders().get(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(responseData.getHeaders().get(errorResponseHeaderName));
    }

    assertEquals(responseData.getEntityResponse() != null, hasEntity);
  }

  private void checkResponse(RestResponse response,
                             int status,
                             int numHeaders,
                             String contentType,
                             String type,
                             String subType,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    checkResponse(response, status, numHeaders, contentType, type, subType, false, hasEntity, errorResponseHeaderName);
  }

  private void checkResponse(RestResponse response,
                             int status,
                             int numHeaders,
                             String contentType,
                             String type,
                             String subType,
                             boolean hasError,
                             boolean hasEntity,
                             String errorResponseHeaderName)
  {
    assertEquals(response.getStatus(), status);
    assertEquals(response.getHeaders().size(), numHeaders);
    assertEquals(response.getHeader(RestConstants.HEADER_CONTENT_TYPE), contentType);

    if (hasError)
    {
      assertEquals(response.getHeader(errorResponseHeaderName), RestConstants.HEADER_VALUE_ERROR);
    }
    else
    {
      assertNull(response.getHeader(errorResponseHeaderName));
    }

    assertEquals(response.getEntity().length() > 0, hasEntity);
  }

  private List<Status> buildStatusList(int num)
  {
    List<Status> list = new ArrayList<Status>();
    for (int i = 0; i < num; i++)
    {
      list.add(buildStatusRecord());
    }

    return list;
  }

  private Status buildStatusRecord()
  {
    DataMap map = new DataMap();
    map.put("text", "test status");
    Status status = new Status(map);
    return status;
  }

  private Status buildStatusWithFields(String... fields)
  {
    DataMap map = new DataMap();
    for (String field : fields)
    {
      map.put(field, "value");
    }
    Status status = new Status(map);
    return status;
  }

  private BasicCollectionResult<Status> buildStatusCollectionResult(int numResults,
                                                                    String... fields)
  {

    List<Status> data = buildStatusListResult(numResults, fields);

    return new BasicCollectionResult<Status>(data, numResults);
  }

  private List<Status> buildStatusListResult(int numResults, String... fields)
  {
    List<Status> data = new ArrayList<Status>();

    for (int i = 0; i < numResults; i++)
    {
      Status status = buildStatusWithFields(fields);
      data.add(status);
    }
    return data;
  }


  private Map<Integer, Status> buildStatusBatchResponse(int numResults, String... fields)
  {
    Map<Integer, Status> map = new HashMap<Integer, Status>();

    for (int i = 0; i < numResults; i++)
    {
      Status status = buildStatusWithFields(fields);
      map.put(i, status);
    }

    return map;
  }

  private void checkCollectionResponse(RestResponse response,
                                       int numElements,
                                       int start,
                                       int count,
                                       int numLinks,
                                       Integer total,
                                       URIDetails prevLink,
                                       URIDetails nextLink,
                                       AcceptTypeData acceptTypeData)
          throws Exception
  {
    DataMap dataMap = acceptTypeData.dataCodec.readMap(response.getEntity().asInputStream());
    CollectionResponse<Status> collectionResponse = new CollectionResponse<Status>(dataMap, Status.class);

    assertEquals(collectionResponse.getElements().size(), numElements);
    assertEquals(collectionResponse.getPaging().getStart().intValue(), start);
    assertEquals(collectionResponse.getPaging().getCount().intValue(), count);
    assertEquals(collectionResponse.getPaging().getLinks().size(), numLinks);
    if (total == null)
    {
      assertFalse(collectionResponse.getPaging().hasTotal());
    }
    else
    {
      assertEquals(collectionResponse.getPaging().getTotal().intValue(), total.intValue());
    }
    if (prevLink != null)
    {
      checkLink(collectionResponse.getPaging().getLinks().get(0), "prev", prevLink, acceptTypeData.responseContentType);
    }
    if (nextLink != null)
    {
      int idx = prevLink != null ? 1 : 0;
      checkLink(collectionResponse.getPaging().getLinks().get(idx), "next", nextLink, acceptTypeData.responseContentType);
    }
  }

  private static void checkLink(Link link, String rel, URIDetails expectedURIDetails, String type)
  {
    assertEquals(link.getRel(), rel);
    assertEquals(link.getType(), type);
    URIDetails.testUriGeneration(link.getHref(), expectedURIDetails);
  }

  private static void checkProjectedFields(RestResponse response, String[] expectedFields, String[] missingFields)
          throws UnsupportedEncodingException
  {
    DataMap dataMap = DataMapUtils.readMap(response);

    for (String field : expectedFields)
    {
      assertTrue(DataMapContains(dataMap, field));
    }
    for (String field : missingFields)
    {
      assertFalse(DataMapContains(dataMap, field));
    }
  }

  private static boolean DataMapContains(DataMap data, String field)
  {
    for(String key : data.keySet())
    {
      if (key.equals(field))
        return true;

      Object value = data.get(key);
      if (value instanceof DataMap)
        return DataMapContains((DataMap)value, field);
    }
    return false;

  }

  @SuppressWarnings("unchecked")
  static public <V> Map<String, V> asMap(Object... objects)
  {
    int index = 0;
    String key = null;
    HashMap<String,V> map = new HashMap<String,V>();
    for (Object object : objects)
    {
      if (index % 2 == 0)
      {
        key = (String) object;
      }
      else
      {
        map.put(key, (V) object);
      }
      index++;
    }
    return map;
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.server.RestLiResponseDataException;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.google.common.collect.ImmutableMap;

import static com.linkedin.restli.common.ResourceMethod.ACTION;
import static com.linkedin.restli.common.ResourceMethod.BATCH_CREATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_DELETE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_GET;
import static com.linkedin.restli.common.ResourceMethod.BATCH_PARTIAL_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.BATCH_UPDATE;
import static com.linkedin.restli.common.ResourceMethod.CREATE;
import static com.linkedin.restli.common.ResourceMethod.FINDER;
import static com.linkedin.restli.common.ResourceMethod.GET;
import static com.linkedin.restli.common.ResourceMethod.GET_ALL;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertFalse;
import static org.testng.Assert.assertNull;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;


public class TestAugmentedRestLiResponseData
{

  @Test(dataProvider = "responseDataProvider")
  public void testResponse(ResourceMethod type, boolean entityException, boolean collectionException,
                           boolean batchException) throws Exception
  {
    AugmentedRestLiResponseData responseData = new AugmentedRestLiResponseData.Builder(type).build();
    RecordTemplate rt = Foo.createFoo("foo", "bar");
    try
    {
      responseData.setEntityResponse(rt);
      if (entityException)
      {
        fail();
      }
    }
    catch (RestLiResponseDataException e)
    {
      if (!entityException)
      {
        throw e;
      }
    }
    try
    {
      responseData.setCollectionResponse(Arrays.asList(rt));
      if (collectionException)
      {
        fail();
      }
    }
    catch (RestLiResponseDataException e)
    {
      if (!collectionException)
      {
        throw e;
      }
    }
    try
    {
      responseData.setCollectionResponseCustomMetadata(rt);
      if (collectionException)
      {
        fail();
      }
    }
    catch (RestLiResponseDataException e)
    {
      if (!collectionException)
      {
        throw e;
      }
    }
    try
    {
      responseData.setCollectionResponsePaging(new CollectionMetadata());
      if (collectionException)
      {
        fail();
      }
    }
    catch (RestLiResponseDataException e)
    {
      if (!collectionException)
      {
        throw e;
      }
    }
    try
    {
      responseData.setBatchKeyResponseMap(ImmutableMap.of("foo", rt));
      if (batchException)
      {
        fail();
      }
    }
    catch (RestLiResponseDataException e)
    {
      if (!batchException)
      {
        throw e;
      }
    }
  }

  @Test(dataProvider = "builderDataProvider")
  public void testBuilder(ResourceMethod methodType, RecordTemplate entity, RestLiServiceException exception,
                          List<? extends RecordTemplate> entities, CollectionMetadata collectionPaging,
                          RecordTemplate collectionMetadata, Map<?, ? extends RecordTemplate> batchEntities,
                          Map<String, String> headers, HttpStatus status, boolean expectException)
  {
    AugmentedRestLiResponseData.Builder builder =
        new AugmentedRestLiResponseData.Builder(methodType).status(status).headers(headers);
    try
    {
      if (entity != null)
      {
        builder.entity(entity);
      }
      if (exception != null)
      {
        builder.serviceException(exception);
      }
      if (entities != null)
      {
        builder.collectionEntities(entities);
      }
      if (batchEntities != null)
      {
        builder.batchKeyEntityMap(batchEntities);
      }
      if (collectionMetadata != null)
      {
        builder.collectionCustomMetadata(collectionMetadata);
      }
      if (collectionPaging != null)
      {
        builder.collectionResponsePaging(collectionPaging);
      }
      AugmentedRestLiResponseData responseData = builder.build();
      if (expectException)
      {
        fail();
      }
      assertEquals(responseData.getStatus(), status);
      assertEquals(responseData.getHeaders(), headers);

      if (entity != null)
      {
        assertTrue(responseData.isEntityResponse());
        assertFalse(responseData.isErrorResponse());
        assertFalse(responseData.isBatchResponse());
        assertFalse(responseData.isCollectionResponse());
        assertEquals(responseData.getEntityResponse(), entity);
        assertNull(responseData.getServiceException());
        assertNull(responseData.getCollectionResponse());
        assertNull(responseData.getBatchResponseMap());
      }
      if (entities != null)
      {
        assertFalse(responseData.isEntityResponse());
        assertFalse(responseData.isErrorResponse());
        assertFalse(responseData.isBatchResponse());
        assertTrue(responseData.isCollectionResponse());
        assertEquals(responseData.getCollectionResponse(), entities);
        assertEquals(responseData.getCollectionResponseCustomMetadata(), collectionMetadata);
        assertEquals(responseData.getCollectionResponsePaging(), collectionPaging);
        assertNull(responseData.getServiceException());
        assertNull(responseData.getEntityResponse());
        assertNull(responseData.getBatchResponseMap());
      }
      if (batchEntities != null)
      {
        assertFalse(responseData.isEntityResponse());
        assertFalse(responseData.isErrorResponse());
        assertTrue(responseData.isBatchResponse());
        assertFalse(responseData.isCollectionResponse());
        assertEquals(responseData.getBatchResponseMap(), batchEntities);
        assertNull(responseData.getServiceException());
        assertNull(responseData.getEntityResponse());
        assertNull(responseData.getCollectionResponse());
      }
      if (exception != null)
      {
        assertFalse(responseData.isEntityResponse());
        assertTrue(responseData.isErrorResponse());
        assertFalse(responseData.isBatchResponse());
        assertFalse(responseData.isCollectionResponse());
        assertEquals(responseData.getServiceException(), exception);
        assertNull(responseData.getBatchResponseMap());
        assertNull(responseData.getEntityResponse());
        assertNull(responseData.getCollectionResponse());
      }
    }
    catch (IllegalArgumentException e)
    {
      if (!expectException)
      {
        throw e;
      }
    }
  }

  @DataProvider(name = "builderDataProvider")
  public Object[][] builderDataProvider()
  {
    List<List<?>> ret = new ArrayList<List<?>>();
    buildSimpleResponse(ret);
    buildCollectionResponseWithPagingAndCustomMetadata(ret);
    buildCollectionResponseWithoutPagingAndCustomMetadata(ret);
    buildBatchResponse(ret);
    buildExceptionResponse(ret);
    return listToArray(ret);
  }

  @DataProvider(name = "responseDataProvider")
  public Object[][] responseDataProvider()
  {
    List<List<?>> ret = new ArrayList<List<?>>();
    List<ResourceMethod> validEntityTypes = Arrays.asList(GET, ACTION, CREATE);
    List<ResourceMethod> validCollectionTypes = Arrays.asList(FINDER, GET_ALL, BATCH_CREATE);
    List<ResourceMethod> validBatchTypes = Arrays.asList(BATCH_DELETE, BATCH_GET, BATCH_PARTIAL_UPDATE, BATCH_UPDATE);
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.<Object>asList(type, !validEntityTypes.contains(type), !validCollectionTypes.contains(type),
                                    !validBatchTypes.contains(type)));
    }
    return listToArray(ret);
  }


  private void buildExceptionResponse(List<List<? extends Object>> ret)
  {
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.asList(type, null, new RestLiServiceException(HttpStatus.S_404_NOT_FOUND), null, null, null, null,
                            ImmutableMap.of("key", "value"), HttpStatus.S_404_NOT_FOUND, false));
    }
  }

  private void buildSimpleResponse(List<List<? extends Object>> ret)
  {
    List<ResourceMethod> validTypes = Arrays.asList(GET, ACTION, CREATE);
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.asList(type, Foo.createFoo("foo", "bar"), null, null, null, null, null,
                            ImmutableMap.of("key", "value"), HttpStatus.S_201_CREATED, !validTypes.contains(type)));
    }
  }

  private void buildCollectionResponseWithPagingAndCustomMetadata(List<List<? extends Object>> ret)
  {
    List<ResourceMethod> validTypes = Arrays.asList(FINDER, GET_ALL);
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.asList(type, null, null, Arrays.asList(Foo.createFoo("foo", "bar")), new CollectionMetadata(),
                            Foo.createFoo("md", "val"), null, ImmutableMap.of("key", "value"),
                            HttpStatus.S_202_ACCEPTED, !validTypes.contains(type)));
    }
  }

  private void buildCollectionResponseWithoutPagingAndCustomMetadata(List<List<? extends Object>> ret)
  {
    List<ResourceMethod> validTypes = Arrays.asList(FINDER, GET_ALL, BATCH_CREATE);
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.asList(type, null, null, Arrays.asList(Foo.createFoo("foo", "bar")), null,
                            null, null, ImmutableMap.of("key", "value"),
                            HttpStatus.S_202_ACCEPTED, !validTypes.contains(type)));
    }
  }

  private void buildBatchResponse(List<List<?>> ret)
  {
    List<ResourceMethod> validTypes = Arrays.asList(BATCH_DELETE, BATCH_GET, BATCH_PARTIAL_UPDATE, BATCH_UPDATE);
    for (ResourceMethod type : ResourceMethod.values())
    {
      ret.add(Arrays.asList(type, null, null, null, null, null, ImmutableMap.of("foo", Foo.createFoo("foo", "bar")),
                            ImmutableMap.of("key", "value"), HttpStatus.S_203_NON_AUTHORITATIVE_INFORMATION,
                            !validTypes.contains(type)));
    }
  }

  private Object[][] listToArray(List<List<?>> input)
  {

    Object[][] ret = new Object[input.size()][input.get(0).size()];
    for (int i = 0; i < input.size(); ++i)
    {
      ret[i] = input.get(i).toArray();
    }
    return ret;
  }

  private static class Foo extends RecordTemplate
  {
    private Foo(DataMap map)
    {
      super(map, null);
    }

    public static Foo createFoo(String key, String value)
    {
      DataMap dataMap = new DataMap();
      dataMap.put(key, value);
      return new Foo(dataMap);
    }
  }
}

<code block>


package com.linkedin.restli.internal.server;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.server.filter.FilterResponseContextInternal;
import com.linkedin.restli.internal.server.methods.response.PartialRestResponse;
import com.linkedin.restli.server.RequestExecutionCallback;
import com.linkedin.restli.server.RequestExecutionReport;
import com.linkedin.restli.server.RequestExecutionReportBuilder;
import com.linkedin.restli.server.RestLiResponseDataException;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.collect.Maps;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyMap;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertFalse;
import static org.testng.Assert.assertNotNull;
import static org.testng.Assert.assertNull;
import static org.testng.Assert.assertTrue;



public class TestRestLiCallback
{
  @Mock
  private RestRequest _restRequest;
  @Mock
  private RoutingResult _routingResult;
  @Mock
  private RestLiResponseHandler _responseHandler;
  @Mock
  private RequestExecutionCallback<RestResponse> _callback;

  private RestLiCallback<Object> _noFilterRestLiCallback;

  private RestLiCallback<Object> _twoFilterRestLiCallback;

  @Mock
  private FilterRequestContext _filterRequestContext;

  @Mock
  private ResponseFilter _filter;

  @BeforeTest
  protected void setUp() throws Exception
  {
    MockitoAnnotations.initMocks(this);
    _noFilterRestLiCallback =
        new RestLiCallback<Object>(_restRequest, _routingResult, _responseHandler, _callback, null, null);
    _twoFilterRestLiCallback =
        new RestLiCallback<Object>(_restRequest, _routingResult, _responseHandler, _callback, Arrays.asList(_filter,
                                                                                                            _filter),
                                   _filterRequestContext);
  }

  @AfterMethod
  protected void resetMocks()
  {
    reset(_filter, _filterRequestContext, _restRequest, _routingResult, _responseHandler, _callback);
  }

  @Test
  public void testOnSuccessNoFilters() throws Exception
  {
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    AugmentedRestLiResponseData responseData = new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    RestResponse restResponse = new RestResponseBuilder().build();
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);

    
    _noFilterRestLiCallback.onSuccess(result, executionReport);

    
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verifyZeroInteractions(_restRequest, _routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorRestLiServiceExceptionNoFilters() throws Exception
  {
    RestLiServiceException ex = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    Map<String, String> inputHeaders = Maps.newHashMap();
    inputHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION,
                     AllProtocolVersions.BASELINE_PROTOCOL_VERSION.toString());

    Map<String, String> restExceptionHeaders = Maps.newHashMap();
    restExceptionHeaders.put("foo", "bar");

    @SuppressWarnings("rawtypes")
    ArgumentCaptor<Map> augErrorHeadersCapture = ArgumentCaptor.forClass(Map.class);
    AugmentedRestLiResponseData responseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(ex.getStatus()).headers(restExceptionHeaders).build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    RestException restException = new RestException(new RestResponseBuilder().build());
    
    when(_restRequest.getHeaders()).thenReturn(inputHeaders);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), eq(ex),
             augErrorHeadersCapture.capture())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildRestException(ex, partialResponse)).thenReturn(restException);

    
    _noFilterRestLiCallback.onError(ex, executionReport);

    
    verify(_responseHandler).buildRestException(ex, partialResponse);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult), eq(ex),
        augErrorHeadersCapture.capture());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    Map<String, String> augErrorHeaders = augErrorHeadersCapture.getValue();
    assertNotNull(augErrorHeaders);
    assertFalse(augErrorHeaders.isEmpty());
    assertTrue(augErrorHeaders.containsKey(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION));
    assertEquals(augErrorHeaders.get(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION),
                 AllProtocolVersions.BASELINE_PROTOCOL_VERSION.toString());
    String errorHeaderName = HeaderUtil.getErrorResponseHeaderName(inputHeaders);
    assertTrue(augErrorHeaders.containsKey(errorHeaderName));
    assertEquals(augErrorHeaders.get(errorHeaderName), RestConstants.HEADER_VALUE_ERROR);
  }

  @DataProvider(name = "provideExceptions")
  private Object[][] provideExceptions()
  {
    return new Object[][] { { new RuntimeException("Test runtime exception") },
        { new RoutingException("Test routing exception", 404) },
        { new RestException(new RestResponseBuilder().setStatus(404).build()) },
        { new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Test service exception") },
        { new RestLiServiceException(HttpStatus.S_403_FORBIDDEN, "Wrapped runtime exception with custom status",
            new RuntimeException("Original cause")) } };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideExceptions")
  public void testOnErrorOtherExceptionNoFilters(Exception ex) throws Exception
  {
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    AugmentedRestLiResponseData responseData = new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).build();
    RestException restException = new RestException(new RestResponseBuilder().build());
    Map<String, String> inputHeaders = Maps.newHashMap();
    inputHeaders.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, "2.0.0");

    
    when(_restRequest.getHeaders()).thenReturn(inputHeaders);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);
    when(_responseHandler.buildRestException(ex, partialResponse)).thenReturn(restException);

    
    _noFilterRestLiCallback.onError(ex, executionReport);

    
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestException(ex, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    if (ex instanceof RoutingException)
    {
      assertEquals(HttpStatus.fromCode(((RoutingException) ex).getStatus()), restliEx.getStatus());
    }
    else if (ex instanceof RestLiServiceException)
    {
      assertEquals(((RestLiServiceException) ex).getStatus(), restliEx.getStatus());
    }
    else
    {
      assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    }
    assertEquals(ex.getMessage(), restliEx.getMessage());
    if (ex instanceof RestLiServiceException)
    {
      assertEquals(ex, restliEx);
    }
    else
    {
      assertEquals(ex, restliEx.getCause());
    }
  }

  @Test
  public void testOnSuccessWithFiltersSuccessful() throws Exception
  {
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "One");
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final RecordTemplate entityFromFilter1 = Foo.createFoo("Key", "Two");
    final RecordTemplate entityFromFilter2 = Foo.createFoo("Key", "Three");
    final Map<String, String> headersFromFilters = Maps.newHashMap();
    headersFromFilters.put("Key", "Output");
    AugmentedRestLiResponseData appResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_200_OK).headers(headersFromApp)
                                                    .entity(entityFromApp).build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();

    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(appResponseData);
    when(_responseHandler.buildPartialResponse(_routingResult, appResponseData)).thenReturn(partialResponse);
    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_200_OK, context.getHttpStatus());
        assertEquals(headersFromApp, context.getResponseHeaders());
        assertEquals(entityFromApp, context.getResponseData().getEntityResponse());
        
        context.setHttpStatus(HttpStatus.S_400_BAD_REQUEST);
        context.getResponseData().setEntityResponse(entityFromFilter1);
        context.getResponseHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getHttpStatus());
        assertTrue(context.getResponseHeaders().isEmpty());
        assertEquals(context.getResponseData().getEntityResponse(), entityFromFilter1);
        
        context.setHttpStatus(HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().setEntityResponse(entityFromFilter2);
        context.getResponseHeaders().putAll(headersFromFilters);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    RestResponse restResponse = new RestResponseBuilder().build();
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);

    
    _twoFilterRestLiCallback.onSuccess(result, executionReport);

    
    assertNotNull(appResponseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, appResponseData.getStatus());
    assertEquals(entityFromFilter2, appResponseData.getEntityResponse());
    assertEquals(headersFromFilters, appResponseData.getHeaders());
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildPartialResponse(_routingResult, appResponseData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verifyZeroInteractions(_restRequest, _routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromFirstFilterSecondFilterHandlesEx() throws Exception
  {
    
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "One");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    AugmentedRestLiResponseData appResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_200_OK).entity(entityFromApp)
                                                                   .build();

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    final RestLiServiceException exceptionFromFilter = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    AugmentedRestLiResponseData responseErrorData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR)
                                                                   .serviceException(exceptionFromFilter)
                                                                   .headers(headersFromFilter).build();
    final RecordTemplate entityFromFilter = Foo.createFoo("Key", "Two");
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Exception From Filter");
    
    RestResponse restResponse = new RestResponseBuilder().build();
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, entityFromApp)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(responseErrorData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseErrorData)).thenReturn(partialFilterErrorResponse);

    when(_responseHandler.buildResponse(_routingResult, partialFilterErrorResponse)).thenReturn(restResponse);
    
    doThrow(exFromFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getHttpStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getEntityResponse());
        assertEquals(context.getResponseHeaders(), headersFromFilter);
        assertEquals(context.getResponseData().getServiceException(), exceptionFromFilter);

        
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        context.getResponseData().setEntityResponse(entityFromFilter);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(entityFromApp, executionReport);

    
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, entityFromApp);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildResponse(_routingResult, partialFilterErrorResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    assertFalse(responseErrorData.isErrorResponse());
    assertEquals(responseErrorData.getEntityResponse(), entityFromFilter);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(responseErrorData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseErrorData.getStatus());
    assertEquals(responseErrorData.getHeaders(), headersFromFilter);
    assertNull(responseErrorData.getServiceException());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromFirstFilterSecondFilterDoesNotHandleEx() throws Exception
  {
    
    final RecordTemplate entityFromApp = Foo.createFoo("Key", "Two");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    AugmentedRestLiResponseData appResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_200_OK).entity(entityFromApp)
                                                                   .build();

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    RestLiServiceException exceptionFromFilter = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    AugmentedRestLiResponseData responseErrorData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR)
                                                                   .serviceException(exceptionFromFilter)
                                                                   .headers(headersFromFilter).build();
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Exception From Filter");

    
    RestException finalRestException = new RestException(new RestResponseBuilder().build());
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, entityFromApp)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(responseErrorData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseErrorData)).thenReturn(partialFilterErrorResponse);
    when(_responseHandler.buildRestException(exFromFilter, partialFilterErrorResponse)).thenReturn(finalRestException);    
    doThrow(exFromFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getHttpStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getEntityResponse());
        assertEquals(context.getResponseHeaders(), headersFromFilter);

        
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(entityFromApp, executionReport);

    
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, entityFromApp);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseErrorData);
    verify(_responseHandler).buildRestException(exFromFilter, partialFilterErrorResponse);
    verify(_callback).onError(finalRestException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(responseErrorData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseErrorData.getStatus());
    assertEquals(responseErrorData.getHeaders(), headersFromFilter);
    assertNull(responseErrorData.getEntityResponse());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnSuccessWithFiltersExceptionFromSecondFilter() throws Exception
  {
    
    String result = "foo";
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    AugmentedRestLiResponseData appResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_200_OK).build();

    
    ArgumentCaptor<RestLiServiceException> exFromFilterCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Error from filter");
    AugmentedRestLiResponseData filterResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR)
                                                    .headers(headersFromFilter).build();
    PartialRestResponse partialFilterErrorResponse = new PartialRestResponse.Builder().build();
    final Exception exFromFilter = new RuntimeException("Excepiton From Filter");

    
    RestException finalRestException = new RestException(new RestResponseBuilder().build());
    
    when(_responseHandler.buildRestLiResponseData(_restRequest, _routingResult, result)).thenReturn(appResponseData);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             exFromFilterCapture.capture(), anyMap())).thenReturn(filterResponseData);
    when(_responseHandler.buildPartialResponse(_routingResult, filterResponseData)).thenReturn(partialFilterErrorResponse);
    when(_responseHandler.buildRestException(exFromFilter, partialFilterErrorResponse)).thenReturn(finalRestException);
    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getHttpStatus(), HttpStatus.S_200_OK);
        assertNull(context.getResponseData().getEntityResponse());
        assertTrue(context.getResponseHeaders().isEmpty());
        
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        return null;
      }
    }).doThrow(exFromFilter).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onSuccess(result, executionReport);

    
    verify(_responseHandler).buildPartialResponse(_routingResult, filterResponseData);
    verify(_responseHandler).buildRestLiResponseData(_restRequest, _routingResult, result);
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exFromFilterCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, filterResponseData);
    verify(_responseHandler).buildRestException(exFromFilter, partialFilterErrorResponse);
    verify(_callback).onError(finalRestException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_responseHandler, _callback);
    RestLiServiceException restliEx = exFromFilterCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFilter, restliEx.getCause());
    assertNotNull(filterResponseData);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, filterResponseData.getStatus());
    assertEquals(filterResponseData.getHeaders(), headersFromFilter);
    assertNull(filterResponseData.getEntityResponse());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersNotHandlingAppEx() throws Exception
  {
    Exception exFromApp = new RuntimeException("Runtime exception from app");
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Output");

    AugmentedRestLiResponseData responseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_404_NOT_FOUND)
                                                                   .headers(headersFromApp)
                                                                   .serviceException(appException).build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_404_NOT_FOUND, context.getHttpStatus());
        assertEquals(headersFromApp, context.getResponseHeaders());
        assertNull(context.getResponseData().getEntityResponse());
        
        context.setHttpStatus(HttpStatus.S_400_BAD_REQUEST);
        context.getResponseHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getHttpStatus());
        assertTrue(context.getResponseHeaders().isEmpty());
        assertNull(context.getResponseData().getEntityResponse());
        
        context.setHttpStatus(HttpStatus.S_403_FORBIDDEN);
        context.getResponseHeaders().putAll(headersFromFilter);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));
    RestException restException = new RestException(new RestResponseBuilder().build());
    when(_responseHandler.buildRestException(exFromApp, partialResponse)).thenReturn(restException);
    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);
    
    assertNotNull(responseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, responseData.getStatus());
    assertNull(responseData.getEntityResponse());
    assertTrue(responseData.isErrorResponse());
    assertEquals(responseData.getServiceException(), appException);
    assertEquals(headersFromFilter, responseData.getHeaders());
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildRestException(exFromApp, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    assertEquals(exFromApp, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersSuccessfulyHandlingAppEx() throws Exception
  {
    Exception exFromApp = new RuntimeException("Runtime exception from app");
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    final Map<String, String> headersFromApp = Maps.newHashMap();
    headersFromApp.put("Key", "Input");
    final RecordTemplate entityFromFilter = Foo.createFoo("Key", "Two");
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put("Key", "Output");

    AugmentedRestLiResponseData responseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_404_NOT_FOUND)
                                                                   .headers(headersFromApp)
                                                                   .serviceException(appException).build();
    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> exCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exCapture.capture(),
             anyMap())).thenReturn(responseData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseData)).thenReturn(partialResponse);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_404_NOT_FOUND, context.getHttpStatus());
        assertEquals(headersFromApp, context.getResponseHeaders());
        assertNull(context.getResponseData().getEntityResponse());
        
        context.setHttpStatus(HttpStatus.S_400_BAD_REQUEST);
        context.getResponseHeaders().clear();
        return null;
      }
    }).doAnswer(new Answer<Object>()
    
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        assertEquals(HttpStatus.S_400_BAD_REQUEST, context.getHttpStatus());
        assertTrue(context.getResponseHeaders().isEmpty());
        assertNull(context.getResponseData().getEntityResponse());
        
        context.setHttpStatus(HttpStatus.S_403_FORBIDDEN);
        context.getResponseData().setEntityResponse(entityFromFilter);
        context.getResponseHeaders().putAll(headersFromFilter);
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    RestResponse restResponse = new RestResponseBuilder().build();
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);


    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);
    
    assertNotNull(responseData);
    assertEquals(HttpStatus.S_403_FORBIDDEN, responseData.getStatus());
    assertEquals(entityFromFilter, responseData.getEntityResponse());
    assertEquals(headersFromFilter, responseData.getHeaders());
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        exCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(1)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    RestLiServiceException restliEx = exCapture.getValue();
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    assertEquals(exFromApp, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersExceptionFromFirstFilterSecondFilterDoesNotHandle() throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    AugmentedRestLiResponseData responseAppData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_404_NOT_FOUND)
                                                                   .serviceException(appException).build();

    
    final Exception exFromFirstFilter = new RuntimeException("Runtime exception from first filter");
    RestLiServiceException filterException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    AugmentedRestLiResponseData responseFilterData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR)
                                                                   .serviceException(filterException).build();

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestException restException = new RestException(new RestResponseBuilder().build());

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(_responseHandler.buildRestException(exFromFirstFilter, partialResponse)).thenReturn(restException);

    
    doThrow(exFromFirstFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getHttpStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getEntityResponse());
        assertTrue(context.getResponseHeaders().isEmpty());
        assertTrue(context.getResponseData().isErrorResponse());

        
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildRestException(exFromFirstFilter, partialResponse);
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseFilterData.getStatus());
    assertTrue(responseFilterData.getHeaders().isEmpty());
    assertNull(responseFilterData.getEntityResponse());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFirstFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFirstFilter, restliEx.getCause());
  }

  @DataProvider(name = "provideResponseEntities")
  private Object[][] provideResponseEntities()
  {
    List<Foo> fooCollection = new ArrayList<Foo>();
    fooCollection.add(Foo.createFoo("Key", "One"));
    fooCollection.add(Foo.createFoo("Key", "Two"));
    fooCollection.add(Foo.createFoo("Key", "Three"));
    Map<String, Foo> fooBatch = new HashMap<String, Foo>();
    fooBatch.put("batchKey1", Foo.createFoo("Key", "One"));
    fooBatch.put("batchKey2", Foo.createFoo("Key", "Two"));
    return new Object[][] {
        { ResourceMethod.GET, Foo.createFoo("Key", "One") },
        { ResourceMethod.FINDER, fooCollection },
        { ResourceMethod.BATCH_GET, fooBatch }
    };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideResponseEntities")
  public void testOnErrorWithFiltersExceptionFromFirstFilterSecondFilterHandles(ResourceMethod resourceMethod, final Object entityFromFilter2) throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    RestLiServiceException appException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    AugmentedRestLiResponseData responseAppData =
        new AugmentedRestLiResponseData.Builder(resourceMethod).status(HttpStatus.S_404_NOT_FOUND)
                                                                   .serviceException(appException).build();

    
    final Exception exFromFirstFilter = new RuntimeException("Runtime exception from first filter");
    RestLiServiceException filterException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR);
    final Map<String, String> headersFromFilter = Maps.newHashMap();
    headersFromFilter.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, AllProtocolVersions.LATEST_PROTOCOL_VERSION.toString());
    String errorResponseHeaderName = HeaderUtil.getErrorResponseHeaderName(AllProtocolVersions.LATEST_PROTOCOL_VERSION);
    headersFromFilter.put(errorResponseHeaderName, RestConstants.HEADER_VALUE_ERROR);
    AugmentedRestLiResponseData responseFilterData =
        new AugmentedRestLiResponseData.Builder(resourceMethod).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR)
                                                                   .headers(headersFromFilter).serviceException(filterException).build();

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();
    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestResponse restResponse = new RestResponseBuilder().build();
    final String customHeader = "Custom-Header";
    final String customHeaderValue = "CustomValue";

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_responseHandler.buildResponse(_routingResult, partialResponse)).thenReturn(restResponse);
    when(_restRequest.getHeaders()).thenReturn(null);


    
    doThrow(exFromFirstFilter).doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        
        
        assertEquals(context.getHttpStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR);
        assertNull(context.getResponseData().getEntityResponse());
        assertEquals(context.getResponseHeaders(), headersFromFilter);
        assertTrue(context.getResponseData().isErrorResponse());

        
        context.getResponseHeaders().put(customHeader, customHeaderValue);
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        
        
        
        if (entityFromFilter2 instanceof RecordTemplate)
        {
          context.getResponseData().setEntityResponse((RecordTemplate) entityFromFilter2);
        }
        else if (entityFromFilter2 instanceof List)
        {
          context.getResponseData().setCollectionResponse((List<? extends RecordTemplate>) entityFromFilter2);
        }
        else
        {
          context.getResponseData().setBatchKeyResponseMap((Map<?, ? extends RecordTemplate>) entityFromFilter2);
        }
        return null;
      }
    }).when(_filter).onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_responseHandler).buildResponse(_routingResult, partialResponse);
    verify(_callback).onSuccess(restResponse, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_402_PAYMENT_REQUIRED, responseFilterData.getStatus());
    
    assertFalse(responseFilterData.getHeaders().containsKey(errorResponseHeaderName));
    assertEquals(responseFilterData.getHeaders().get(customHeader), customHeaderValue);
    if (entityFromFilter2 instanceof RecordTemplate)
    {
      assertTrue(responseFilterData.isEntityResponse());
      assertEquals(responseFilterData.getEntityResponse(), entityFromFilter2);
    }
    else if (entityFromFilter2 instanceof List)
    {
      assertTrue(responseFilterData.isCollectionResponse());
      assertEquals(responseFilterData.getCollectionResponse(), entityFromFilter2);
    }
    else
    {
      assertTrue(responseFilterData.isBatchResponse());
      assertEquals(responseFilterData.getBatchResponseMap(), entityFromFilter2);
    }
    assertFalse(responseFilterData.isErrorResponse());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromFirstFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromFirstFilter, restliEx.getCause());
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testOnErrorWithFiltersExceptionFromSecondFilter() throws Exception
  {
    
    RestLiServiceException exFromApp = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND, "App failure");
    RequestExecutionReport executionReport = new RequestExecutionReportBuilder().build();
    AugmentedRestLiResponseData responseAppData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_404_NOT_FOUND).build();
    
    final Exception exFromSecondFilter = new RuntimeException("Runtime exception from second filter");
    AugmentedRestLiResponseData responseFilterData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_500_INTERNAL_SERVER_ERROR).build();

    PartialRestResponse partialResponse = new PartialRestResponse.Builder().build();

    ArgumentCaptor<RestLiServiceException> wrappedExCapture = ArgumentCaptor.forClass(RestLiServiceException.class);
    RestException restException = new RestException(new RestResponseBuilder().build());

    
    when(
         _responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
             wrappedExCapture.capture(), anyMap())).thenReturn(responseAppData)
                                                                                       .thenReturn(responseFilterData);
    when(_responseHandler.buildPartialResponse(_routingResult, responseFilterData)).thenReturn(partialResponse);
    when(_restRequest.getHeaders()).thenReturn(null);
    when(_responseHandler.buildRestException(exFromSecondFilter, partialResponse)).thenReturn(restException);

    
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterResponseContext context = (FilterResponseContext) args[1];
        assertEquals(context.getHttpStatus(), HttpStatus.S_404_NOT_FOUND);
        assertNull(context.getResponseData().getEntityResponse());
        assertTrue(context.getResponseHeaders().isEmpty());

        
        context.setHttpStatus(HttpStatus.S_402_PAYMENT_REQUIRED);
        return null;
      }
    }).doThrow(exFromSecondFilter).when(_filter)
      .onResponse(eq(_filterRequestContext), any(FilterResponseContext.class));

    
    _twoFilterRestLiCallback.onError(exFromApp, executionReport);

    
    verify(_responseHandler, times(2)).buildExceptionResponseData(eq(_restRequest), eq(_routingResult),
        wrappedExCapture.capture(), anyMap());
    verify(_responseHandler).buildPartialResponse(_routingResult, responseFilterData);
    verify(_responseHandler).buildRestException(exFromSecondFilter, partialResponse);
    verify(_callback).onError(restException, executionReport);
    verify(_restRequest, times(2)).getHeaders();
    verifyZeroInteractions(_routingResult);
    verifyNoMoreInteractions(_restRequest, _responseHandler, _callback);
    assertNotNull(responseFilterData);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, responseFilterData.getStatus());
    assertTrue(responseFilterData.getHeaders().isEmpty());
    assertNull(responseFilterData.getEntityResponse());
    RestLiServiceException restliEx = wrappedExCapture.getAllValues().get(0);
    assertNotNull(restliEx);
    assertEquals(exFromApp.getStatus(), restliEx.getStatus());
    assertEquals(exFromApp.getMessage(), restliEx.getMessage());
    restliEx = wrappedExCapture.getAllValues().get(1);
    assertNotNull(restliEx);
    assertEquals(HttpStatus.S_500_INTERNAL_SERVER_ERROR, restliEx.getStatus());
    assertEquals(exFromSecondFilter.getMessage(), restliEx.getMessage());
    assertEquals(exFromSecondFilter, restliEx.getCause());
  }

  @Test
  public void testFilterResponseContextAdapter() throws RestLiResponseDataException
  {
    DataMap dataMap = new DataMap();
    dataMap.put("foo", "bar");
    Map<String, String> headers = Maps.newHashMap();
    headers.put("x", "y");
    RecordTemplate entity1 = new Foo(dataMap);
    AugmentedRestLiResponseData responseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).status(HttpStatus.S_200_OK).headers(headers).entity(entity1)
                                                    .build();
    AugmentedRestLiResponseData updatedResponseData =
        new AugmentedRestLiResponseData.Builder(ResourceMethod.GET).build();
    FilterResponseContext context = new RestLiCallback.FilterResponseContextAdapter(responseData);
    assertEquals(headers, context.getResponseHeaders());
    assertEquals(entity1, context.getResponseData().getEntityResponse());
    assertEquals(HttpStatus.S_200_OK, context.getHttpStatus());

    context.setHttpStatus(HttpStatus.S_404_NOT_FOUND);
    Foo entity2 = Foo.createFoo("boo", "bar");
    context.getResponseData().setEntityResponse(entity2);
    assertEquals(context.getResponseData().getEntityResponse(), entity2);
    assertEquals(HttpStatus.S_404_NOT_FOUND, context.getHttpStatus());
    assertEquals(HttpStatus.S_404_NOT_FOUND, responseData.getStatus());
    assertEquals(responseData, context.getResponseData());
    assertEquals(responseData, ((FilterResponseContextInternal) context).getAugmentedRestLiResponseData());
    ((FilterResponseContextInternal) context).setAugmentedRestLiResponseData(updatedResponseData);
    assertEquals(updatedResponseData, ((FilterResponseContextInternal) context).getAugmentedRestLiResponseData());
  }

  @DataProvider(name = "provideExceptionsAndStatuses")
  private Object[][] provideExceptionsAndStatuses()
  {
    return new Object[][] {
        { new RuntimeException("Test runtime exception"), HttpStatus.S_500_INTERNAL_SERVER_ERROR },
        { new RoutingException("Test routing exception", 404), HttpStatus.S_404_NOT_FOUND},
        { new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Test service exception"), HttpStatus.S_400_BAD_REQUEST },
        { new RestLiServiceException(HttpStatus.S_403_FORBIDDEN, "Wrapped runtime exception with custom status",
            new RuntimeException("Original cause")), HttpStatus.S_403_FORBIDDEN }
    };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "provideExceptionsAndStatuses")
  public void testConvertExceptionToRestLiResponseData(Exception e, HttpStatus status)
  {
    RestLiServiceException serviceException;
    if (e instanceof RestLiServiceException)
    {
      serviceException = (RestLiServiceException) e;
    }
    else
    {
      serviceException = new RestLiServiceException(status, e);
    }
    AugmentedRestLiResponseData responseData = new AugmentedRestLiResponseData.Builder(ResourceMethod.GET)
        .serviceException(serviceException).status(status).build();
    ArgumentCaptor<RestLiServiceException> exceptionArgumentCaptor = ArgumentCaptor.forClass(RestLiServiceException.class);

    
    when(_responseHandler.buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exceptionArgumentCaptor.capture(),
        anyMap())).thenReturn(responseData);
    when(_restRequest.getHeaders()).thenReturn(null);

    
    AugmentedRestLiResponseData resultData = _noFilterRestLiCallback.convertExceptionToRestLiResponseData(e);

    
    verify(_responseHandler).buildExceptionResponseData(eq(_restRequest), eq(_routingResult), exceptionArgumentCaptor.capture(),
        anyMap());
    verify(_restRequest).getHeaders();
    verifyNoMoreInteractions(_responseHandler, _restRequest);
    verifyZeroInteractions(_routingResult, _callback);
    
    RestLiServiceException exceptionArgument = exceptionArgumentCaptor.getValue();
    assertTrue(exceptionArgument.equals(e) || exceptionArgument.getCause().equals(e));
    assertEquals(exceptionArgument.getStatus(), status);
    
    assertTrue(resultData.isErrorResponse());
    assertTrue(resultData.getServiceException().equals(e) || resultData.getServiceException().getCause().equals(e));
    assertEquals(resultData.getServiceException().getStatus(), status);
  }

  private static class Foo extends RecordTemplate
  {
    private Foo(DataMap map)
    {
      super(map, null);
    }

    public static Foo createFoo(String key, String value)
    {
      DataMap dataMap = new DataMap();
      dataMap.put(key, value);
      return new Foo(dataMap);
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.pegasus.generator.examples.Fruits;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.GetResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;

import java.util.HashMap;
import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestGetResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    DataMap projectionDataMap = new DataMap();
    projectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree maskTree = new MaskTree(projectionDataMap);

    ProjectionMode manual = ProjectionMode.MANUAL;
    ProjectionMode auto = ProjectionMode.AUTOMATIC;

    return new Object[][]
        {
            
            {getRecord(), HttpStatus.S_200_OK, null, auto},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, null, auto},

            
            {getRecord(), HttpStatus.S_200_OK, null, manual},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, null, manual},

            
            {getRecord(), HttpStatus.S_200_OK, maskTree, manual},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, maskTree, manual},

            
            {getRecord(), HttpStatus.S_200_OK, maskTree, auto},
            {new GetResult<Foo>(getRecord(), HttpStatus.S_207_MULTI_STATUS),
                HttpStatus.S_207_MULTI_STATUS, maskTree, auto}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(Object record, HttpStatus expectedHttpStatus, MaskTree maskTree, ProjectionMode projectionMode)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceContext mockContext = getMockResourceContext(maskTree, projectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();

    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    GetResponseBuilder getResponseBuilder = new GetResponseBuilder();

    AugmentedRestLiResponseData responseData = getResponseBuilder.buildRestLiResponseData(null,
                                                                                          routingResult,
                                                                                          record,
                                                                                          headers);

    PartialRestResponse partialRestResponse = getResponseBuilder.buildResponse(null, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, headers);
    Assert.assertEquals(partialRestResponse.getStatus(), expectedHttpStatus);
    if (maskTree == null || projectionMode == ProjectionMode.MANUAL)
    {
      Assert.assertEquals(partialRestResponse.getEntity(), getRecord());
    }
    else
    {
      Assert.assertEquals(partialRestResponse.getEntity(), getProjectedRecord());
    }
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.GET).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ResourceContext getMockResourceContext(MaskTree maskTree, ProjectionMode projectionMode)
  {
    ResourceContext mockContext = EasyMock.createMock(ResourceContext.class);
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(projectionMode).once();
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(maskTree).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static Foo getRecord()
  {
    return new Foo().setStringField("foo").setBooleanField(false).setFruitsField(Fruits.ORANGE);
  }

  private static Foo getProjectedRecord()
  {
    return new Foo().setStringField("foo");
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.r2.message.Response;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.RestLiServiceException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchCreateResponseBuilder
{
  @Test
  @SuppressWarnings("unchecked")
  public void testBuilder()
  {
    List<CreateResponse> createResponses = Arrays.asList(new CreateResponse(1L), new CreateResponse(2L));
    BatchCreateResult<Long, Foo> results =
        new BatchCreateResult<Long, Foo>(createResponses);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    BatchCreateResponseBuilder responseBuilder = new BatchCreateResponseBuilder(null);
    AugmentedRestLiResponseData responseData = responseBuilder.buildRestLiResponseData(null,
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getEntity(),
                        new BatchCreateIdResponse<Long>((List<com.linkedin.restli.common.CreateIdStatus<Long>>) responseData.getCollectionResponse()));
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.BATCH_CREATE).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {new BatchCreateResult<Long, Foo>(Arrays.asList(new CreateResponse(1L), null)),
                "Unexpected null encountered. Null element inside of List inside of a BatchCreateResult returned by the resource method: "},
            {new BatchCreateResult<Long, Foo>(null),
                "Unexpected null encountered. Null List inside of a BatchCreateResult returned by the resource method: "}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilderExceptions(Object result, String expectedErrorMessage)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);
    BatchCreateResponseBuilder responseBuilder = new BatchCreateResponseBuilder(null);
    try
    {
      responseBuilder.buildRestLiResponseData(null, routingResult, result, headers);
      Assert.fail("buildRestLiResponseData should have thrown an exception because of null elements");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.pegasus.generator.examples.Fruits;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.BatchResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchGetResponseBuilder
{
  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "testData")
  public Object[][] dataProvider()
  {
    Map<CompoundKey, Foo> results = new HashMap<CompoundKey, Foo>();
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    CompoundKey c2 = new CompoundKey().append("a", "a2").append("b", 2);
    CompoundKey c3 = new CompoundKey().append("a", "a3").append("b", 3);
    Foo record1 = new Foo().setStringField("record1").setFruitsField(Fruits.APPLE);
    Foo projectedRecord1 = new Foo().setStringField("record1");
    Foo record2 = new Foo().setStringField("record2").setIntField(7);
    Foo projectedRecord2 = new Foo().setStringField("record2");
    results.put(c1, record1);
    results.put(c2, record2);

    DataMap projectionDataMap = new DataMap();
    projectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree maskTree = new MaskTree(projectionDataMap);

    Map<String, Foo> protocol1TransformedResults = new HashMap<String, Foo>();
    protocol1TransformedResults.put("a=a1&b=1", record1);
    protocol1TransformedResults.put("a=a2&b=2", record2);
    Map<String, Foo> protocol1TransformedResultsWithProjection = new HashMap<String, Foo>();
    protocol1TransformedResultsWithProjection.put("a=a1&b=1", projectedRecord1);
    protocol1TransformedResultsWithProjection.put("a=a2&b=2", projectedRecord2);

    Map<String, Foo> protocol2TransformedResults = new HashMap<String, Foo>();
    protocol2TransformedResults.put("(a:a1,b:1)", record1);
    protocol2TransformedResults.put("(a:a2,b:2)", record2);
    Map<String, Foo> protocol2TransformedResultsWithProjection = new HashMap<String, Foo>();
    protocol2TransformedResultsWithProjection.put("(a:a1,b:1)", projectedRecord1);
    protocol2TransformedResultsWithProjection.put("(a:a2,b:2)", projectedRecord2);

    Map<String, ErrorResponse> protocol1Errors = Collections.singletonMap("a=a3&b=3", new ErrorResponse().setStatus(404));
    Map<String, ErrorResponse> protocol2Errors = Collections.singletonMap("(a:a3,b:3)", new ErrorResponse().setStatus(404));

    Map<CompoundKey, HttpStatus> statuses = new HashMap<CompoundKey, HttpStatus>();
    statuses.put(c1, HttpStatus.S_200_OK);
    statuses.put(c2, HttpStatus.S_200_OK);
    Map<CompoundKey, RestLiServiceException> exceptions = new HashMap<CompoundKey, RestLiServiceException>();
    exceptions.put(c3, new RestLiServiceException(HttpStatus.S_404_NOT_FOUND));
    BatchResult<CompoundKey, Foo> batchResult = new BatchResult<CompoundKey, Foo>(results, statuses, exceptions);
    Map<Object, RestLiServiceException> exceptionsWithUntypedKey = new HashMap<Object, RestLiServiceException>(exceptions);

    ProtocolVersion protocolVersion1 = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    ProtocolVersion protocolVersion2 = AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion();

    ProjectionMode auto = ProjectionMode.AUTOMATIC;
    ProjectionMode manual = ProjectionMode.MANUAL;

    return new Object[][]
        {
            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, auto},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, auto},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, auto},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, auto},

            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, manual},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, manual},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, null, manual},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, null, manual},

            
            {results, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, maskTree, manual},
            {results, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, maskTree, manual},
            {batchResult, protocolVersion1, protocol1TransformedResults, protocol1Errors, exceptionsWithUntypedKey, maskTree, manual},
            {batchResult, protocolVersion2, protocol2TransformedResults, protocol2Errors, exceptionsWithUntypedKey, maskTree, manual},

            
            {results, protocolVersion1, protocol1TransformedResultsWithProjection, protocol1Errors, exceptionsWithUntypedKey, maskTree, auto},
            {results, protocolVersion2, protocol2TransformedResultsWithProjection, protocol2Errors, exceptionsWithUntypedKey, maskTree, auto},
            {batchResult, protocolVersion1, protocol1TransformedResultsWithProjection, protocol1Errors, exceptionsWithUntypedKey, maskTree, auto},
            {batchResult, protocolVersion2, protocol2TransformedResultsWithProjection, protocol2Errors, exceptionsWithUntypedKey, maskTree, auto},
        };
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "testData")
  @SuppressWarnings("unchecked")
  public void testBuilder(Object results,
                          ProtocolVersion protocolVersion,
                          Map<String, Foo> expectedTransformedResult,
                          Map<String, ErrorResponse> expectedErrors,
                          Map<Object, RestLiServiceException> expectedExceptionsWithUntypedKey,
                          MaskTree maskTree,
                          ProjectionMode projectionMode)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion,
                                                         expectedExceptionsWithUntypedKey,
                                                         maskTree,
                                                         projectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    AugmentedRestLiResponseData responseData = responseBuilder.buildRestLiResponseData(null,
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
    BatchResponse<Foo> entity = (BatchResponse<Foo>)restResponse.getEntity();
    Assert.assertEquals(entity.getResults(), expectedTransformedResult);
    if (results instanceof BatchResult)
    {
      Map<String, Integer> expectedStatuses = new HashMap<String, Integer>();
      for (String key: entity.getResults().keySet())
      {
        expectedStatuses.put(key, HttpStatus.S_200_OK.getCode());
      }
      Assert.assertEquals(entity.getStatuses(), expectedStatuses);
    }
    else
    {
      
      Assert.assertEquals(entity.getStatuses(), Collections.emptyMap());
    }
    Assert.assertEquals(entity.getErrors().size(), expectedErrors.size());
    for (Map.Entry<String, ErrorResponse> entry: entity.getErrors().entrySet())
    {
      String key = entry.getKey();
      ErrorResponse value = entry.getValue();
      Assert.assertEquals(value.getStatus(), expectedErrors.get(key).getStatus());
    }
  }

  @DataProvider(name = "exceptionTestData")
  public Object[][] exceptionDataProvider()
  {
    Map<Long, Foo> results = new HashMap<Long, Foo>();
    Foo f1 = new Foo().setStringField("f1");
    Foo f2 = new Foo().setStringField("f2");
    results.put(null, f1);
    results.put(1L, f2);

    BatchResult<Long, Foo> batchResult = new BatchResult<Long, Foo>(Collections.singletonMap(1L, f1),
                                                                    Collections.<Long, HttpStatus>singletonMap(null, HttpStatus.S_404_NOT_FOUND),
                                                                    null);
    final String expectedMessage = "Unexpected null encountered. Null key inside of a Map returned by the resource method: ";
    return new Object[][]
        {
            {results, expectedMessage},
            {batchResult, expectedMessage}
        };
  }

  @Test(dataProvider = "exceptionTestData")
  public void testBuilderExceptions(Object results, String expectedErrorMessage)
  {
    
    ResourceContext mockContext = getMockResourceContext(null, Collections.<Object, RestLiServiceException>emptyMap(),
        null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    try
    {
      responseBuilder.buildRestLiResponseData(null, routingResult, results, headers);
      Assert.fail("buildRestLiResponseData should have failed because of null elements!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }

 
  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "unsupportedNullKeyMapData")
  public Object[][] unsupportedNullKeyMapData()
  {
    Map<CompoundKey, Foo> results = new ConcurrentHashMap<CompoundKey, Foo>();
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    Foo record1 = new Foo().setStringField("record1").setFruitsField(Fruits.APPLE);
    results.put(c1, record1);

    Map<CompoundKey, HttpStatus> statuses = new ConcurrentHashMap<CompoundKey, HttpStatus>();
    statuses.put(c1, HttpStatus.S_200_OK);

    final BatchResult<CompoundKey, Foo> batchResult =
        new BatchResult<CompoundKey, Foo>(results, statuses, new ConcurrentHashMap<CompoundKey, RestLiServiceException>());

    final Map<String, Foo> protocol1TransformedResults = new ConcurrentHashMap<String, Foo>();
    protocol1TransformedResults.put("a=a1&b=1", record1);

    final Map<String, Foo> protocol2TransformedResults = new ConcurrentHashMap<String, Foo>();
    protocol2TransformedResults.put("(a:a1,b:1)", record1);

    ProtocolVersion protocolVersion1 = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    ProtocolVersion protocolVersion2 = AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion();

    return new Object[][]
        {
            {results, protocolVersion1, protocol1TransformedResults},
            {results, protocolVersion2, protocol2TransformedResults},
            {batchResult, protocolVersion1, protocol1TransformedResults},
            {batchResult, protocolVersion2, protocol2TransformedResults}
        };
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "unsupportedNullKeyMapData")
  @SuppressWarnings("unchecked")
  public void unsupportedNullKeyMapTest(Object results, ProtocolVersion protocolVersion, Map<String, Foo> expectedTransformedResult)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion,
        Collections.<Object, RestLiServiceException>emptyMap(), null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchGetResponseBuilder responseBuilder = new BatchGetResponseBuilder(new ErrorResponseBuilder());
    AugmentedRestLiResponseData responseData = responseBuilder.buildRestLiResponseData(null,
        routingResult,
        results,
        headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), HttpStatus.S_200_OK);
    BatchResponse<Foo> entity = (BatchResponse<Foo>)restResponse.getEntity();
    Assert.assertEquals(entity.getResults(), expectedTransformedResult);
    if (results instanceof BatchResult)
    {
      Map<String, Integer> expectedStatuses = new HashMap<String, Integer>();
      for (String key: entity.getResults().keySet())
      {
        expectedStatuses.put(key, HttpStatus.S_200_OK.getCode());
      }
      Assert.assertEquals(entity.getStatuses(), expectedStatuses);
    }
    else
    {
      
      Assert.assertEquals(entity.getStatuses(), Collections.emptyMap());
    }
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion,
                                                        Map<Object, RestLiServiceException> exceptions,
                                                        MaskTree maskTree,
                                                        ProjectionMode projectionMode)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getBatchKeyErrors()).andReturn(exceptions).once();
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(projectionMode).times(2);
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(maskTree).times(2);
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.BATCH_GET).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.transform.filter.request.MaskOperation;
import com.linkedin.data.transform.filter.request.MaskTree;
import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.LinkArray;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.Parameter;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.CollectionResult;
import com.linkedin.restli.server.ProjectionMode;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCollectionResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider() throws CloneNotSupportedException
  {
    Foo metadata = new Foo().setStringField("metadata").setIntField(7);
    Foo projectedMetadata = new Foo().setIntField(7);
    final List<Foo> generatedList = generateTestList();
    final List<Foo> testListWithProjection = generateTestListWithProjection();
    CollectionResult<Foo, Foo> collectionResult = new CollectionResult<Foo, Foo>(generatedList, generatedList.size(), metadata);

    DataMap dataProjectionDataMap = new DataMap();
    dataProjectionDataMap.put("stringField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree dataMaskTree = new MaskTree(dataProjectionDataMap);

    DataMap metadataProjectionDataMap = new DataMap();
    metadataProjectionDataMap.put("intField", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree metadataMaskTree = new MaskTree(metadataProjectionDataMap);

    DataMap pagingProjectDataMap = new DataMap();
    pagingProjectDataMap.put("count", MaskOperation.POSITIVE_MASK_OP.getRepresentation());
    MaskTree pagingMaskTree = new MaskTree(pagingProjectDataMap);

    CollectionMetadata collectionMetadata1 = new CollectionMetadata().setCount(10).setStart(0).setLinks(new LinkArray());
    CollectionMetadata collectionMetadata2 = collectionMetadata1.clone().setTotal(2);
    CollectionMetadata collectionMetadataWithProjection = new CollectionMetadata().setCount(10);

    ProjectionMode auto = ProjectionMode.AUTOMATIC;
    ProjectionMode manual = ProjectionMode.MANUAL;

    return new Object[][]
        {
            
            {generatedList, null, generatedList, collectionMetadata1, null, null, null, auto, auto},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadata2,
                null,
                null,
                null,
                auto,
                auto},

            
            {generatedList, null, generatedList, collectionMetadata1, null, null, null, manual, manual},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadata2,
                null,
                null,
                null,
                manual,
                manual},

            
            
            
            {generatedList,
                null,
                generatedList,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                manual,
                manual},
            {collectionResult,
                metadata.data(),
                collectionResult.getElements(),
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                manual,
                manual},

            
            {generatedList,
                null,
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                null,
                pagingMaskTree,
                auto,
                auto},

            
            {collectionResult,
                projectedMetadata.data(),
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                auto,
                auto},

            
            {collectionResult,
                metadata.data(),
                testListWithProjection,
                collectionMetadataWithProjection,
                dataMaskTree,
                metadataMaskTree,
                pagingMaskTree,
                auto,
                manual},
        };
  }

  @SuppressWarnings("unchecked")
  @Test(dataProvider = "testData")
  public void testBuilder(Object results,
                          DataMap expectedMetadata,
                          List<Foo> expectedElements,
                          CollectionMetadata expectedPaging,
                          MaskTree dataMaskTree,
                          MaskTree metaDataMaskTree,
                          MaskTree pagingMaskTree,
                          ProjectionMode dataProjectionMode,
                          ProjectionMode metadataProjectionMode)
      throws URISyntaxException
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceContext mockContext = getMockResourceContext(dataMaskTree,
                                                         metaDataMaskTree,
                                                         pagingMaskTree,
                                                         dataProjectionMode,
                                                         metadataProjectionMode);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CollectionResponseBuilder responseBuilder = new CollectionResponseBuilder();
    AugmentedRestLiResponseData responseData = responseBuilder.buildRestLiResponseData(getRestRequest(),
                                                                                       routingResult,
                                                                                       results,
                                                                                       headers);
    PartialRestResponse restResponse = responseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    CollectionResponse<Foo> actualResults = (CollectionResponse<Foo>) restResponse.getEntity();
    Assert.assertEquals(actualResults.getElements(), expectedElements);
    Assert.assertEquals(actualResults.getMetadataRaw(), expectedMetadata);
    Assert.assertEquals(actualResults.getPaging(), expectedPaging);
  }

  @DataProvider(name = "exceptionTestData")
  public Object[][] exceptionDataProvider()
  {
    Foo f1 = new Foo().setStringField("f1");

    return new Object[][]
        {
            {Arrays.asList(f1, null),
                "Unexpected null encountered. Null element inside of a List returned by the resource method: "},
            {new CollectionResult<Foo, Foo>(null),
                "Unexpected null encountered. Null elements List inside of CollectionResult returned by the resource method: "}
        };
  }

  @Test(dataProvider = "exceptionTestData")
  public void testBuilderExceptions(Object results, String expectedErrorMessage)
      throws URISyntaxException
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceContext mockContext = getMockResourceContext(null, null, null, null, null);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);
    CollectionResponseBuilder responseBuilder = new CollectionResponseBuilder();
    try
    {
      responseBuilder.buildRestLiResponseData(getRestRequest(), routingResult, results, headers);
      Assert.fail("An exception should have been thrown because of null elements!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains(expectedErrorMessage));
    }
  }

  private static ResourceContext getMockResourceContext(MaskTree dataMaskTree,
                                                        MaskTree metadataMaskTree,
                                                        MaskTree pagingMaskTree,
                                                        ProjectionMode dataProjectionMode,
                                                        ProjectionMode metadataProjectionMode)
      throws URISyntaxException
  {
    ResourceContext mockContext = EasyMock.createMock(ResourceContext.class);
    EasyMock.expect(mockContext.getParameter(EasyMock.<String>anyObject())).andReturn(null).times(2);
    EasyMock.expect(mockContext.getRequestHeaders()).andReturn(ResponseBuilderUtil.getHeaders()).once();
    EasyMock.expect(mockContext.getRawRequest()).andReturn(getRestRequest()).once();

    
    EasyMock.expect(mockContext.getProjectionMode()).andReturn(dataProjectionMode).times(generateTestList().size());
    EasyMock.expect(mockContext.getProjectionMask()).andReturn(dataMaskTree).times(generateTestList().size());

    
    EasyMock.expect(mockContext.getMetadataProjectionMode()).andReturn(metadataProjectionMode).anyTimes();
    EasyMock.expect(mockContext.getMetadataProjectionMask()).andReturn(metadataMaskTree).anyTimes();

    
    EasyMock.expect(mockContext.getPagingProjectionMask()).andReturn(pagingMaskTree).once();

    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.FINDER).once();
    EasyMock.expect(mockDescriptor.getParametersWithType(EasyMock.<Parameter.ParamType>anyObject())).andReturn(Collections.<Parameter<?>>emptyList()).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static List<Foo> generateTestList()
  {
    Foo f1 = new Foo().setStringField("f1").setIntField(1);
    Foo f2 = new Foo().setStringField("f2").setIntField(2);
    List<Foo> results = Arrays.asList(f1, f2);
    return results;
  }

  private static List<Foo> generateTestListWithProjection()
  {
    Foo f1 = new Foo().setStringField("f1");
    Foo f2 = new Foo().setStringField("f2");
    List<Foo> results = Arrays.asList(f1, f2);
    return results;
  }

  private static RestRequest getRestRequest()
      throws URISyntaxException
  {
    return new RestRequestBuilder(new URI("/?q=finder")).build();
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.data.DataMap;
import com.linkedin.data.template.FieldDef;
import com.linkedin.restli.common.ActionResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.ActionResult;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestActionResponseBuilder
{
  private static final FieldDef<Long> LONG_RETURN = new FieldDef<Long>("longReturn", Long.class);

  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {1L, HttpStatus.S_200_OK, 1L},
            {new ActionResult<Long>(1L, HttpStatus.S_202_ACCEPTED), HttpStatus.S_202_ACCEPTED, 1L}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(Object result, HttpStatus httpStatus, long returnValue)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    ActionResponseBuilder actionResponseBuilder = new ActionResponseBuilder();
    AugmentedRestLiResponseData responseData = actionResponseBuilder.buildRestLiResponseData(null,
                                                                                             routingResult,
                                                                                             result,
                                                                                             headers);
    PartialRestResponse restResponse = actionResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(restResponse.getStatus(), httpStatus);
    Assert.assertEquals((restResponse.getEntity()), getActionResponse(returnValue));
  }

  @SuppressWarnings("unchecked")
  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);

    EasyMock.expect(mockDescriptor.getActionReturnRecordDataSchema()).andReturn(LONG_RETURN.getField().getRecord()).once();
    EasyMock.expect(((FieldDef<Long>)mockDescriptor.getActionReturnFieldDef())).andReturn(LONG_RETURN).once();
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.ACTION).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ActionResponse<Long> getActionResponse(long returnValue)
  {
    DataMap dataMap = new DataMap();
    dataMap.put(LONG_RETURN.getName(), returnValue);
    return new ActionResponse<Long>(dataMap, LONG_RETURN, LONG_RETURN.getField().getRecord());
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCreateResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), "/foo/a=a&b=1", "a=a&b=1"},
            {AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), "/foo/(a:a,b:1)", "(a:a,b:1)"}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(ProtocolVersion protocolVersion, String location, String id)
      throws URISyntaxException
  {
    CompoundKey compoundKey = new CompoundKey().append("a", "a").append("b", 1);
    CreateResponse createResponse = new CreateResponse(compoundKey);
    IdResponse<CompoundKey> idResponse = new IdResponse<CompoundKey>(compoundKey);
    RestRequest restRequest = new RestRequestBuilder(new URI("/foo")).build();
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
    
    Map<String, String> expectedHeaders = new HashMap<String, String>(headers);

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CreateResponseBuilder createResponseBuilder = new CreateResponseBuilder();
    AugmentedRestLiResponseData responseData = createResponseBuilder.buildRestLiResponseData(restRequest,
                                                                                             routingResult,
                                                                                             createResponse,
                                                                                             headers);
    PartialRestResponse partialRestResponse = createResponseBuilder.buildResponse(routingResult, responseData);

    expectedHeaders.put(RestConstants.HEADER_LOCATION, location);
    if (protocolVersion.equals(AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()))
    {
      expectedHeaders.put(RestConstants.HEADER_ID, id);
    }
    else
    {
      expectedHeaders.put(RestConstants.HEADER_RESTLI_ID, id);
    }

    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, expectedHeaders);
    Assert.assertEquals(partialRestResponse.getStatus(), HttpStatus.S_201_CREATED);
    Assert.assertEquals(partialRestResponse.getEntity(), idResponse);
  }

  @Test
  public void testBuilderException()
      throws URISyntaxException
  {
    CompoundKey compoundKey = new CompoundKey().append("a", "a").append("b", 1);
    CreateResponse createResponse = new CreateResponse(compoundKey, null);
    RestRequest restRequest = new RestRequestBuilder(new URI("/foo")).build();
    ProtocolVersion protocolVersion = AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion();
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    CreateResponseBuilder createResponseBuilder = new CreateResponseBuilder();
    try
    {
      createResponseBuilder.buildRestLiResponseData(restRequest, routingResult, createResponse, headers);
      Assert.fail("buildRestLiResponseData should have thrown an exception because the status is null!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains("Unexpected null encountered. HttpStatus is null inside of a CreateResponse from the resource method: "));
    }
  }


  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.CREATE).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.r2.message.Response;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.Test;



public class TestUpdateResponseBuilder
{
  @Test
  public void testBuilder()
  {
    HttpStatus status = HttpStatus.S_200_OK;
    UpdateResponse updateResponse = new UpdateResponse(status);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    UpdateResponseBuilder updateResponseBuilder = new UpdateResponseBuilder();
    AugmentedRestLiResponseData responseData = updateResponseBuilder.buildRestLiResponseData(null,
                                                                                             routingResult,
                                                                                             updateResponse,
                                                                                             headers);
    PartialRestResponse partialRestResponse = updateResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ResponseBuilderUtil.validateHeaders(partialRestResponse, headers);
    Assert.assertEquals(partialRestResponse.getStatus(), status);
  }

  @Test
  public void testBuilderException()
  {
    UpdateResponse updateResponse = new UpdateResponse(null);
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    UpdateResponseBuilder updateResponseBuilder = new UpdateResponseBuilder();

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    try
    {
      updateResponseBuilder.buildRestLiResponseData(null, routingResult, updateResponse, headers);
      Assert.fail("buildRestLiResponseData should have failed because of a null HTTP status!");
    }
    catch (RestLiServiceException e)
    {
      Assert.assertTrue(e.getMessage().contains("Unexpected null encountered. HttpStatus is null inside of a UpdateResponse returned by the resource method: "));
    }
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.UPDATE).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>


package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.pegasus.generator.examples.Foo;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.ServerResourceContext;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.ResourceContext;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.UpdateResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.easymock.EasyMock;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestBatchUpdateResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    CompoundKey c2 = new CompoundKey().append("a", "a2").append("b", 2);
    CompoundKey c3 = new CompoundKey().append("a", "a3").append("b", 3);
    Map<CompoundKey, UpdateResponse> results = new HashMap<CompoundKey, UpdateResponse>();
    results.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    results.put(c2, new UpdateResponse(HttpStatus.S_202_ACCEPTED));

    RestLiServiceException restLiServiceException = new RestLiServiceException(HttpStatus.S_404_NOT_FOUND);
    Map<CompoundKey, RestLiServiceException> errors = Collections.singletonMap(c3, restLiServiceException);

    BatchUpdateResult<CompoundKey, Foo> batchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(results, errors);

    Map<CompoundKey, UpdateResponse> keyOverlapResults = new HashMap<CompoundKey, UpdateResponse>();
    keyOverlapResults.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    keyOverlapResults.put(c2, new UpdateResponse(HttpStatus.S_202_ACCEPTED));
    keyOverlapResults.put(c3, new UpdateResponse(HttpStatus.S_404_NOT_FOUND));
    BatchUpdateResult<CompoundKey, Foo> keyOverlapBatchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(keyOverlapResults, errors);

    UpdateStatus updateStatus = new UpdateStatus().setStatus(202);
    ErrorResponse errorResponse = new ErrorResponse().setStatus(404);

    Map<String, UpdateStatus> expectedProtocol1Results = new HashMap<String, UpdateStatus>();
    expectedProtocol1Results.put("a=a1&b=1", updateStatus);
    expectedProtocol1Results.put("a=a2&b=2", updateStatus);
    Map<String, ErrorResponse> expectedProtocol1Errors = new HashMap<String, ErrorResponse>();
    expectedProtocol1Errors.put("a=a3&b=3", errorResponse);

    Map<String, UpdateStatus> expectedProtocol2Results = new HashMap<String, UpdateStatus>();
    expectedProtocol2Results.put("(a:a1,b:1)", updateStatus);
    expectedProtocol2Results.put("(a:a2,b:2)", updateStatus);
    Map<String, ErrorResponse> expectedProtocol2Errors = new HashMap<String, ErrorResponse>();
    expectedProtocol2Errors.put("(a:a3,b:3)", errorResponse);

    return new Object[][]
        {
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), expectedProtocol1Results, expectedProtocol1Errors},
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results, expectedProtocol2Errors},
            {keyOverlapBatchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results, expectedProtocol2Errors}
        };
  }

  @Test(dataProvider = "testData")
  @SuppressWarnings("unchecked")
  public void testBuilder(Object results,
                          ProtocolVersion protocolVersion,
                          Map<String, UpdateStatus> expectedResults,
                          Map<String, ErrorResponse> expectedErrors)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchUpdateResponseBuilder batchUpdateResponseBuilder = new BatchUpdateResponseBuilder(new ErrorResponseBuilder());
    AugmentedRestLiResponseData responseData = batchUpdateResponseBuilder.buildRestLiResponseData(null,
                                                                                                  routingResult,
                                                                                                  results,
                                                                                                  headers);
    PartialRestResponse restResponse = batchUpdateResponseBuilder.buildResponse(routingResult, responseData);

    BatchResponse<UpdateStatus> batchResponse = (BatchResponse<UpdateStatus>) restResponse.getEntity();
    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(batchResponse.getResults(), expectedResults);
    Assert.assertEquals(batchResponse.getErrors().size(), expectedErrors.size());
    for (Map.Entry<String, ErrorResponse> entry: batchResponse.getErrors().entrySet())
    {
      String key = entry.getKey();
      ErrorResponse value = entry.getValue();
      Assert.assertEquals(value.getStatus(), expectedErrors.get(key).getStatus());
    }
  }

  @DataProvider(name = "unsupportedNullKeyMapData")
  public Object[][] unsupportedNullKeyMapData()
  {
    final CompoundKey c1 = new CompoundKey().append("a", "a1").append("b", 1);
    final Map<CompoundKey, UpdateResponse> results = new ConcurrentHashMap<CompoundKey, UpdateResponse>();
    results.put(c1, new UpdateResponse(HttpStatus.S_202_ACCEPTED));

    final BatchUpdateResult<CompoundKey, Foo> batchUpdateResult =
        new BatchUpdateResult<CompoundKey, Foo>(results, new ConcurrentHashMap<CompoundKey, RestLiServiceException>());
    final UpdateStatus updateStatus = new UpdateStatus().setStatus(202);

    final Map<String, UpdateStatus> expectedProtocol1Results = new HashMap<String, UpdateStatus>();
    expectedProtocol1Results.put("a=a1&b=1", updateStatus);
    final Map<String, UpdateStatus> expectedProtocol2Results = new HashMap<String, UpdateStatus>();
    expectedProtocol2Results.put("(a:a1,b:1)", updateStatus);

    return new Object[][]
        {
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(), expectedProtocol1Results},
            {batchUpdateResult, AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(), expectedProtocol2Results}
        };
  }

 
  @Test(dataProvider = "unsupportedNullKeyMapData")
  @SuppressWarnings("unchecked")
  public void unsupportedNullKeyMapTest(Object results, ProtocolVersion protocolVersion, Map<String, UpdateStatus> expectedResults)
  {
    ResourceContext mockContext = getMockResourceContext(protocolVersion);
    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(mockContext, mockDescriptor);

    Map<String, String> headers = ResponseBuilderUtil.getHeaders();

    BatchUpdateResponseBuilder batchUpdateResponseBuilder = new BatchUpdateResponseBuilder(new ErrorResponseBuilder());
    AugmentedRestLiResponseData responseData = batchUpdateResponseBuilder.buildRestLiResponseData(null,
        routingResult,
        results,
        headers);
    PartialRestResponse restResponse = batchUpdateResponseBuilder.buildResponse(routingResult, responseData);

    BatchResponse<UpdateStatus> batchResponse = (BatchResponse<UpdateStatus>) restResponse.getEntity();
    EasyMock.verify(mockContext, mockDescriptor);
    ResponseBuilderUtil.validateHeaders(restResponse, headers);
    Assert.assertEquals(batchResponse.getResults(), expectedResults);
  }

  private static ResourceContext getMockResourceContext(ProtocolVersion protocolVersion)
  {
    ServerResourceContext mockContext = EasyMock.createMock(ServerResourceContext.class);
    EasyMock.expect(mockContext.getBatchKeyErrors()).andReturn(Collections.<Object, RestLiServiceException>emptyMap()).once();
    EasyMock.expect(mockContext.getRestliProtocolVersion()).andReturn(protocolVersion).once();
    EasyMock.replay(mockContext);
    return mockContext;
  }

  private static ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);

    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.BATCH_UPDATE).once();
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>



package com.linkedin.restli.internal.server.methods.response;


import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.HeaderUtil;
import com.linkedin.restli.internal.server.AugmentedRestLiResponseData;
import com.linkedin.restli.internal.server.RoutingResult;
import com.linkedin.restli.internal.server.model.ResourceMethodDescriptor;
import com.linkedin.restli.server.RestLiServiceException;
import java.util.HashMap;
import java.util.Map;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestErrorResponseBuilder
{
  @DataProvider(name = "testData")
  public Object[][] dataProvider()
  {
    return new Object[][]
        {
            {AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()},
            {AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()}
        };
  }

  @Test(dataProvider = "testData")
  public void testBuilder(ProtocolVersion protocolVersion)
  {
    Map<String, String> headers = ResponseBuilderUtil.getHeaders();
    Map<String, String> expectedHeaders = new HashMap<String, String>(headers);
    expectedHeaders.put(HeaderUtil.getErrorResponseHeaderName(protocolVersion), RestConstants.HEADER_VALUE_ERROR);

    ResourceMethodDescriptor mockDescriptor = getMockResourceMethodDescriptor();
    RoutingResult routingResult = new RoutingResult(null, mockDescriptor);

    RuntimeException runtimeException = new RuntimeException("Internal server error!");
    RestLiServiceException serviceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,
                                                                         runtimeException);

    ErrorResponseBuilder errorResponseBuilder = new ErrorResponseBuilder();
    AugmentedRestLiResponseData responseData = errorResponseBuilder.buildRestLiResponseData(null,
                                                                                            routingResult,
                                                                                            serviceException,
                                                                                            headers);
    PartialRestResponse restResponse = errorResponseBuilder.buildResponse(routingResult, responseData);

    EasyMock.verify(mockDescriptor);
    ErrorResponse errorResponse = (ErrorResponse)restResponse.getEntity();
    Assert.assertEquals(errorResponse.getStatus(), new Integer(500));
    Assert.assertTrue(errorResponse.getMessage().contains(runtimeException.getMessage()));
  }

  private ResourceMethodDescriptor getMockResourceMethodDescriptor()
  {
    ResourceMethodDescriptor mockDescriptor = EasyMock.createMock(ResourceMethodDescriptor.class);
    EasyMock.expect(mockDescriptor.getMethodType()).andReturn(ResourceMethod.GET);
    EasyMock.replay(mockDescriptor);
    return mockDescriptor;
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.data.schema.validation.ValidateDataAgainstSchema;
import com.linkedin.data.schema.validation.ValidationOptions;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.restli.client.CreateIdRequest;
import com.linkedin.restli.client.CreateIdRequestBuilder;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.response.CreateResponse;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.IdResponse;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.GreetingsBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsCallbackBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsCallbackRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseCtxBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseCtxRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsPromiseRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsTaskBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsTaskRequestBuilders;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.RoutingException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Sets;

import static com.linkedin.restli.examples.TestConstants.FORCE_USE_NEXT_OPTIONS;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;



public class TestFilters extends RestLiIntegrationTest
{
  private static final String REQ_FILTER_ERROR_MESSAGE = "You are forbidden from creating an insulting greeting.";
  private static final HttpStatus REQ_FILTER_ERROR_STATUS = HttpStatus.S_403_FORBIDDEN;
  private static final String RESP_FILTER_ERROR_MESSAGE = "Thou shall not insult other";
  private static final HttpStatus RESP_FILTER_ERROR_STATUS = HttpStatus.S_400_BAD_REQUEST;
  private static final BiMap<Tone, Tone> toneMapper;
  static
  {
    toneMapper = HashBiMap.create();
    toneMapper.put(Tone.FRIENDLY, Tone.SINCERE);
    toneMapper.put(Tone.SINCERE, Tone.INSULTING);
  }

  @Mock
  private RequestFilter _requestFilter;
  @Mock
  private ResponseFilter _responseFilter;

  @BeforeClass
  public void initClass() throws Exception
  {
    MockitoAnnotations.initMocks(this);
  }

  @AfterMethod
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  
  @Test(dataProvider = "requestBuilderDataProvider")
  public void testGetOldBuilders(RootBuilderWrapper<Long, Greeting> builders, Tone tone, boolean responseFilter, Exception responseFilterException) throws Exception
  {
    setupFilters(responseFilter, responseFilterException);
    Greeting greeting = generateTestGreeting("Test greeting.....", tone);
    Long createdId = null;
    try
    {
      createdId = createTestData(builders, greeting);
    }
    catch (RestLiResponseException e)
    {
      if (tone != Tone.INSULTING)
      {
        fail();
      }
      if (responseFilter)
      {
        assertEquals(e.getServiceErrorMessage(), RESP_FILTER_ERROR_MESSAGE);
        assertEquals(e.getResponse().getStatus(), RESP_FILTER_ERROR_STATUS.getCode());
      }
      else
      {
        assertEquals(e.getServiceErrorMessage(), REQ_FILTER_ERROR_MESSAGE);
        assertEquals(e.getResponse().getStatus(), REQ_FILTER_ERROR_STATUS.getCode());
      }
      verifyFilters(tone, responseFilter);
      return;
    }
    if (tone == Tone.INSULTING)
    {
      fail();
    }
    if (!responseFilter)
    {
      greeting.setTone(mapToneForIncomingRequest(tone));
    }
    greeting.setId(createdId);
    Request<Greeting> getRequest = builders.get().id(createdId).build();
    Greeting getReturnedGreeting = getClient().sendRequest(getRequest).getResponse().getEntity();
    ValidateDataAgainstSchema.validate(getReturnedGreeting.data(), getReturnedGreeting.schema(),
                                       new ValidationOptions());
    assertEquals(getReturnedGreeting, greeting);
    deleteAndVerifyTestData(builders, createdId);
    verifyFilters(tone, responseFilter);
  }

  private Greeting generateTestGreeting(String message, Tone tone)
  {
    return new Greeting().setMessage(message).setTone(tone);
  }

  private void deleteAndVerifyTestData(RootBuilderWrapper<Long, Greeting> builders, Long id) throws RemoteInvocationException
  {
    Request<EmptyRecord> request = builders.delete().id(id).build();
    ResponseFuture<EmptyRecord> future = getClient().sendRequest(request);
    Response<EmptyRecord> response = future.getResponse();
    assertEquals(response.getStatus(), HttpStatus.S_204_NO_CONTENT.getCode());
  }

  private Long createTestData(RootBuilderWrapper<Long, Greeting> builders, Greeting greeting) throws RemoteInvocationException
  {
    RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> createBuilderWrapper = builders.create();
    Long createdId;
    if (createBuilderWrapper.isRestLi2Builder())
    {
      Object objBuilder = createBuilderWrapper.getBuilder();
      @SuppressWarnings("unchecked")
      CreateIdRequestBuilder<Long, Greeting> createIdRequestBuilder =
          (CreateIdRequestBuilder<Long, Greeting>) objBuilder;
      CreateIdRequest<Long, Greeting> request = createIdRequestBuilder.input(greeting).build();
      Response<IdResponse<Long>> response = getClient().sendRequest(request).getResponse();
      createdId = response.getEntity().getId();
    }
    else
    {
      Request<EmptyRecord> request = createBuilderWrapper.input(greeting).build();
      Response<EmptyRecord> response = getClient().sendRequest(request).getResponse();
      @SuppressWarnings("unchecked")
      CreateResponse<Long> createResponse = (CreateResponse<Long>) response.getEntity();
      createdId = createResponse.getId();
    }
    return createdId;

  }

  private void verifyFilters(Tone tone, boolean respFilter)
  {
    int count = tone == Tone.INSULTING ? 1 : 3;
    verify(_requestFilter, times(count)).onRequest(any(FilterRequestContext.class));
    verifyNoMoreInteractions(_requestFilter);
    if (respFilter)
    {
      verify(_responseFilter, times(count)).onResponse(any(FilterRequestContext.class),
                                                       any(FilterResponseContext.class));
      verifyNoMoreInteractions(_responseFilter);
    }
  }

  private void setupFilters(boolean responseFilter, final Exception responseFilterException) throws IOException
  {
    reset(_requestFilter);
    final Integer spValue = new Integer(100);
    final String spKey = "Counter";
    doAnswer(new Answer<Object>()
    {
      @Override
      public Object answer(InvocationOnMock invocation) throws Throwable
      {
        Object[] args = invocation.getArguments();
        FilterRequestContext requestContext = (FilterRequestContext) args[0];
        requestContext.getFilterScratchpad().put(spKey, spValue);
        if (requestContext.getMethodType() == ResourceMethod.CREATE)
        {
          RecordTemplate entity = requestContext.getRequestData().getEntity();
          if (entity != null && entity instanceof Greeting)
          {
            Greeting greeting = (Greeting) entity;
            if (greeting.hasTone())
            {
              Tone tone = greeting.getTone();
              if (tone == Tone.INSULTING)
              {
                throw new RestLiServiceException(REQ_FILTER_ERROR_STATUS, REQ_FILTER_ERROR_MESSAGE);
              }
              greeting.setTone(mapToneForIncomingRequest(tone));
            }
          }
        }
        return null;
      }
    }).when(_requestFilter).onRequest(any(FilterRequestContext.class));
    List<RequestFilter> reqFilters = Arrays.asList(_requestFilter);

    List<ResponseFilter> respFilters = null;
    if (responseFilter)
    {
      reset(_responseFilter);
      doAnswer(new Answer<Object>()
      {
        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable
        {
          Object[] args = invocation.getArguments();
          FilterRequestContext requestContext = (FilterRequestContext) args[0];
          FilterResponseContext responseContext = (FilterResponseContext) args[1];
          
          assertTrue(requestContext.getFilterScratchpad().get(spKey) == spValue);
          RecordTemplate entity = responseContext.getResponseData().getEntityResponse();
          if (entity != null && requestContext.getMethodType() == ResourceMethod.GET
              && responseContext.getHttpStatus() == HttpStatus.S_200_OK)
          {
            Greeting greeting = new Greeting(entity.data());
            if (greeting.hasTone())
            {
              greeting.setTone(mapToneForOutgoingResponse(greeting.getTone()));
              responseContext.getResponseData().setEntityResponse(greeting);
            }
          }
          if (responseContext.getResponseData().isErrorResponse() && requestContext.getMethodType() == ResourceMethod.CREATE
              && responseContext.getHttpStatus() == REQ_FILTER_ERROR_STATUS)
          {
            throw responseFilterException;
          }
          return null;
        }
      }).when(_responseFilter).onResponse(any(FilterRequestContext.class), any(FilterResponseContext.class));
      respFilters = Arrays.asList(_responseFilter);
    }
    init(reqFilters, respFilters);
  }

  private static Tone mapToneForIncomingRequest(Tone inputTone)
  {
    return toneMapper.get(inputTone);
  }

  private static Tone mapToneForOutgoingResponse(Tone outputTone)
  {
    return toneMapper.inverse().get(outputTone);
  }

  private Object[][] to2DArray(Set<List<Object>> objectSet)
  {
    Object[][] result = new Object[objectSet.size()][];
    int i = 0;
    for (List<Object> objects : objectSet)
    {
      result[i] = objects.toArray();
      i++;
    }
    return result;
  }

  @SuppressWarnings("unchecked")
  @DataProvider
  private Object[][] requestBuilderDataProvider()
  {
    Object[] builders = new Object[]{
        new GreetingsBuilders(),
        new GreetingsRequestBuilders(),
        new GreetingsPromiseBuilders(),
        new GreetingsPromiseRequestBuilders(),
        new GreetingsCallbackBuilders(),
        new GreetingsCallbackRequestBuilders(),
        new GreetingsPromiseCtxBuilders(),
        new GreetingsPromiseCtxRequestBuilders(),
        new GreetingsTaskBuilders(),
        new GreetingsTaskRequestBuilders(),
        new GreetingsBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsCallbackBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsCallbackRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseCtxBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsPromiseCtxRequestBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsTaskBuilders(FORCE_USE_NEXT_OPTIONS),
        new GreetingsTaskRequestBuilders(FORCE_USE_NEXT_OPTIONS)
    };
    Set<Object> builderWrapperSet = new HashSet<Object>();
    for (Object builder : builders)
    {
      builderWrapperSet.add(new RootBuilderWrapper<Long, Greeting>(builder));
    }
    Set<Tone> toneSet = new HashSet<Tone>(Arrays.asList(Tone.FRIENDLY, Tone.INSULTING));
    Set<Boolean> responseFilterSet = new HashSet<Boolean>(Arrays.asList(false, true));
    Set<Exception> exceptionSet = new HashSet<Exception>(Arrays.asList(
        new RestLiServiceException(RESP_FILTER_ERROR_STATUS, RESP_FILTER_ERROR_MESSAGE),
        new RestLiServiceException(RESP_FILTER_ERROR_STATUS, RESP_FILTER_ERROR_MESSAGE, new RuntimeException("Original cause")),
        new RoutingException(RESP_FILTER_ERROR_MESSAGE, RESP_FILTER_ERROR_STATUS.getCode())
    ));
    List<Set<? extends Object>> sets = Arrays.asList(builderWrapperSet, toneSet, responseFilterSet, exceptionSet);
    Object[][] dataSources = to2DArray(Sets.cartesianProduct(sets));
    
    assertEquals(dataSources.length, builderWrapperSet.size() * toneSet.size() * responseFilterSet.size() * exceptionSet.size());
    for (int i = 0; i < dataSources.length; i++)
    {
      assertEquals(dataSources[i].length, sets.size());
    }
    return dataSources;
  }
}

<code block>


package com.linkedin.restli.examples;


import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.restli.client.BatchGetEntityRequest;
import com.linkedin.restli.client.BatchGetEntityRequestBuilder;
import com.linkedin.restli.client.CreateIdRequest;
import com.linkedin.restli.client.CreateIdRequestBuilder;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.response.BatchKVResponse;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.NullGreetingBuilders;
import com.linkedin.restli.examples.greetings.client.NullGreetingRequestBuilders;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.FilterResponseContext;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.BatchCreateHelper;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestNullGreetingsClient extends RestLiIntegrationTest
{
  @BeforeClass
  public void initClass() throws Exception
  {
    super.init(Collections.<RequestFilter>emptyList(), ImmutableList.of(new ResponseFilter() {
      @Override
      public void onResponse(FilterRequestContext requestContext, FilterResponseContext responseContext) {
        
        
        responseContext.getResponseHeaders().put("X-Null-Greetings-Filter", "Ack");
      }
    }));
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullCreateResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper = builders.create();
    final Greeting illGreeting = new Greeting().setMessage("nullCreateResponse").setTone(Tone.INSULTING);
    createAndAssertNullMessages(methodBuilderWrapper, illGreeting);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullHttpStatusCreateResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper = builders.create();
    final Greeting illGreeting = new Greeting().setMessage("nullHttpStatus").setTone(Tone.INSULTING);
    createAndAssertNullMessages(methodBuilderWrapper, illGreeting);
  }

  private void createAndAssertNullMessages(
      final RootBuilderWrapper.MethodBuilderWrapper<Long, Greeting, EmptyRecord> methodBuilderWrapper,
      final Greeting illGreeting)
      throws RemoteInvocationException
  {
    if (methodBuilderWrapper.isRestLi2Builder())
    {
      final Object objBuilder = methodBuilderWrapper.getBuilder();
      @SuppressWarnings("unchecked")
      final CreateIdRequestBuilder<Long, Greeting> createIdRequestBuilder =
          (CreateIdRequestBuilder<Long, Greeting>) objBuilder;
      final CreateIdRequest<Long, Greeting> request = createIdRequestBuilder.input(illGreeting).build();
      try
      {
        getClient().sendRequest(request).getResponse();
        Assert.fail("We should not reach here!");
      }
      catch (final RestLiResponseException responseException)
      {
        assertCorrectInternalServerMessageForNull(responseException, "create");
      }
    }
    else
    {
      final Request<EmptyRecord> request = methodBuilderWrapper.input(illGreeting).build();
      try
      {
        getClient().sendRequest(request).getResponse();
        Assert.fail("We should not reach here!");
      }
      catch (final RestLiResponseException responseException)
      {
        assertCorrectInternalServerMessageForNull(responseException, "create");
      }
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("searchReturnNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("searchReturnNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testCallBackFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(
        builders.findBy("finderCallbackNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderCallbackNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testPromiseFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("finderPromiseNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderPromiseNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testTaskFinderNullListResponse(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(builders.findBy("finderTaskNullList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(builders.findBy("finderTaskNullList").setQueryParam("tone", Tone.SINCERE).build());
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullsInCollectionResult(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.INSULTING).build());

    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.SINCERE).build());

    
    
    finderAndAssertNullMessages(
        builders.findBy("searchReturnNullCollectionList").setQueryParam("tone", Tone.FRIENDLY).build());
  }

  private void finderAndAssertNullMessages(final Request<CollectionResponse<Greeting>> req)
      throws RemoteInvocationException
  {
    try
    {
      getClient().sendRequest(req).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "finder");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testGetNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.get().id(1l).build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 404, "We should have gotten a 404 back");
      Assert.assertNotNull(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "We should have" +
          " a header applied by the filter");
      Assert.assertEquals(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "Ack",
          "The value of the header applied by the response filter should be correct");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testGetAllNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.getAll().build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "get");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testUpdateNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendUpdateAndAssert(builders, 1l);

    
    sendUpdateAndAssert(builders, 2l);
  }

  private void sendUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
      getClient().sendRequest(builders.update().id(id).input(someGreeting).build()).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchUpdate(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendBatchUpdateAndAssert(builders, 1l);

    
    sendBatchUpdateAndAssert(builders, 2l);

    
    sendBatchUpdateAndAssert(builders, 3l);

    
    sendBatchUpdateAndAssert(builders, 4l);

    
    sendBatchUpdateAndAssert(builders, 5l);

    
    sendBatchUpdateAndAssert(builders, 6l);
  }

  private void sendBatchUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
      Request<BatchKVResponse<Long, UpdateStatus>> writeRequest =
          builders.batchUpdate().input(id, someGreeting).build();
      getClient().sendRequest(writeRequest).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchUpdateUnsupportedNullKeyMap(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    Greeting someGreeting = new Greeting().setMessage("Hello").setTone(Tone.INSULTING);
    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(7l, someGreeting).build();
    Response<BatchKVResponse<Long, UpdateStatus>> response = getClient().sendRequest(writeRequest).getResponse();

    Map<Long, ErrorResponse> actualErrors = response.getEntity().getErrors();
    Assert.assertEquals(actualErrors.size(), 0, "Errors map should be empty");

    Map<Long, UpdateStatus> actualResults = response.getEntity().getResults();
    Map<Long, UpdateStatus> expectedResults = new HashMap<Long, UpdateStatus>();
    UpdateStatus updateStatus = new UpdateStatus().setStatus(201);
    expectedResults.put(3l, updateStatus);
    Assert.assertEquals(actualResults, expectedResults, "The results map should be correct");
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchPartialUpdate(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    sendBatchPartialUpdateAndAssert(builders, 1l);

    
    sendBatchPartialUpdateAndAssert(builders, 2l);

    
    sendBatchPartialUpdateAndAssert(builders, 3l);

    
    sendBatchPartialUpdateAndAssert(builders, 4l);
  }

  private void sendBatchPartialUpdateAndAssert(final RootBuilderWrapper<Long, Greeting> builders, Long id)
      throws RemoteInvocationException
  {
    try
    {
      final Map<Long, PatchRequest<Greeting>> patchedGreetingsDiffs = new HashMap<Long, PatchRequest<Greeting>>();
      patchedGreetingsDiffs.put(id, new PatchRequest<Greeting>());
      final Request<BatchKVResponse<Long, UpdateStatus>> batchUpdateRequest =
          builders.batchPartialUpdate().patchInputs(patchedGreetingsDiffs).build();
      getClient().sendRequest(batchUpdateRequest).getResponse();
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_partial_update");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testDeleteNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      getClient().sendRequest(builders.delete().id(1l).build()).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "delete");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchDeleteNull(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<BatchKVResponse<Long, UpdateStatus>> deleteRequest =
          builders.batchDelete().ids(ImmutableList.of(1l)).build();
      getClient().sendRequest(deleteRequest).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_delete");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullStringArray(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final Request<Integer> request = builders.<Integer>action("returnNullStringArray").build();
    final Response<Integer> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 back");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testNullActionResult(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    
    final Request<Integer> request = builders.<Integer>action("returnNullActionResult").build();
    final Response<Integer> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 back");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testStringArrayNullElement(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnStringArrayWithNullElement").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
      Assert.assertTrue(responseException.getMessage().contains("Error in application code"), "The error message should be correct");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testActionResultNullValue(RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnActionResultWithNullValue").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
      Assert.assertTrue(
          responseException.getMessage().contains("Cannot set field value of com.linkedin.restli.common.ActionResponse to null"),
          "The error message should be correct");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testActionResultNullStatus(RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    try
    {
      
      final Request<Integer> request = builders.<Integer>action("returnActionResultWithNullStatus").build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "action");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  public void testBatchCreateNulls(final RootBuilderWrapper<Long, Greeting> builders)
      throws RemoteInvocationException
  {
    final Greeting firstGreeting = new Greeting().setMessage("first").setTone(Tone.INSULTING);
    final Greeting secondGreeting = new Greeting().setMessage("first").setTone(Tone.INSULTING);

    
    sendBatchCreateAndAssert(builders, Collections.<Greeting>emptyList());

    
    sendBatchCreateAndAssert(builders, ImmutableList.of(firstGreeting));

    
    sendBatchCreateAndAssert(builders, ImmutableList.of(firstGreeting, secondGreeting));
  }

  private void sendBatchCreateAndAssert(final RootBuilderWrapper<Long, Greeting> builders,
      final List<Greeting> greetingList)
      throws RemoteInvocationException
  {
    try
    {
      BatchCreateHelper.batchCreate(getClient(), builders, greetingList);
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_create");
    }
  }

  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "requestBuilderDataProvider")
  private static Object[][] requestBuilderDataProvider()
  {
    return new Object[][]
    {
        {
            new RootBuilderWrapper<Long, Greeting>(new NullGreetingBuilders())
        },
        {
            new RootBuilderWrapper<Long, Greeting>(new NullGreetingRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS))
        }
    };
  }

  private void assertCorrectInternalServerMessageForNull(final RestLiResponseException responseException, final String type)
  {
    Assert.assertEquals(responseException.getStatus(), 500, "We should have gotten a 500 back");
    Assert.assertTrue(responseException.getMessage().contains("Unexpected null encountered"), "The error message should be correct");
    Assert.assertTrue(responseException.getMessage().contains("type="+type.toLowerCase()), "The type should be correct");
    Assert.assertTrue(responseException.getMessage().contains("resourceName=nullGreeting"), "The resourceName should be correct");
    Assert.assertNotNull(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "We should have" +
        " a header applied by the filter");
    Assert.assertEquals(responseException.getResponse().getHeader("X-Null-Greetings-Filter"), "Ack", "The value" +
        " of the header applied by the response filter should be correct");
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullBatchResult(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    try
    {
      
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(1l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullBatchResultInternals(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    BatchGetEntityRequest<Long, Greeting> request =
        builder.ids(ImmutableSet.of(2l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> response = getClient().sendRequest(request).getResponse();
    Assert.assertEquals(response.getStatus(), 200, "We should have gotten a 200 here!");
    Assert.assertNotNull(response.getHeader("X-Null-Greetings-Filter"), "We should have" +
        " a header applied by the filter");
    Assert.assertEquals(response.getHeader("X-Null-Greetings-Filter"), "Ack", "The value" +
        " of the header applied by the response filter should be correct");
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullKeyBatchResultStatusMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    
    try
    {
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(3l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetNullKeyBatchResultMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException
  {
    
    try
    {
      BatchGetEntityRequest<Long, Greeting> request =
          builder.ids(ImmutableSet.of(4l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
      getClient().sendRequest(request).getResponse();
      Assert.fail("We should not reach here!");
    }
    catch (final RestLiResponseException responseException)
    {
      assertCorrectInternalServerMessageForNull(responseException, "batch_get");
    }
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  public void testBatchGetUnsupportedNullKeyMap(final BatchGetEntityRequestBuilder<Long, Greeting> builder)
      throws RemoteInvocationException, CloneNotSupportedException
  {
    BatchGetEntityRequest<Long, Greeting> request =
        builder.ids(ImmutableSet.of(5l)).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> response = getClient().sendRequest(request).getResponse();
    final Greeting actualGreeting = response.getEntity().getResults().get(0l).getEntity();
    Assert.assertEquals(actualGreeting.getMessage(), "Good morning!", "We should get the correct Greeting back");
  }

  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX
      + "batchGetRequestBuilderDataProvider")
  private static Object[][] batchGetRequestBuilderDataProvider()
  {
    return new Object[][]
    {
        {
            new NullGreetingRequestBuilders().batchGet()
        },
        {
            new NullGreetingRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS).batchGet()
        }
    };
  }
}
<code block>



package com.linkedin.r2.transport.http.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.util.None;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.compression.ClientCompressionFilter;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.filter.transport.ClientQueryTunnelFilter;
import com.linkedin.r2.filter.transport.FilterChainClient;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.TransportClientFactory;
import com.linkedin.r2.transport.common.bridge.client.TransportClient;
import com.linkedin.r2.transport.common.bridge.common.TransportCallback;
import com.linkedin.r2.util.ConfigValueExtractor;
import com.linkedin.r2.util.NamedThreadFactory;

import io.netty.channel.nio.NioEventLoopGroup;
import java.util.concurrent.ExecutorService;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class HttpClientFactory implements TransportClientFactory
{
  private static final Logger LOG = LoggerFactory.getLogger(HttpClientFactory.class);

  public static final String HTTP_QUERY_POST_THRESHOLD = "http.queryPostThreshold";
  public static final String HTTP_REQUEST_TIMEOUT = "http.requestTimeout";
  public static final String HTTP_MAX_RESPONSE_SIZE = "http.maxResponseSize";
  public static final String HTTP_POOL_SIZE = "http.poolSize";
  public static final String HTTP_POOL_WAITER_SIZE = "http.poolWaiterSize";
  public static final String HTTP_IDLE_TIMEOUT = "http.idleTimeout";
  public static final String HTTP_SHUTDOWN_TIMEOUT = "http.shutdownTimeout";
  public static final String HTTP_SSL_CONTEXT = "http.sslContext";
  public static final String HTTP_SSL_PARAMS = "http.sslParams";
  public static final String HTTP_RESPONSE_COMPRESSION_OPERATIONS = "http.responseCompressionOperations";
  public static final String HTTP_REQUEST_CONTENT_ENCODINGS = "http.requestContentEncodings";
  public static final String HTTP_USE_RESPONSE_COMPRESSION = "http.useResponseCompression";
  public static final String HTTP_SERVICE_NAME = "http.serviceName";
  public static final String HTTP_POOL_STRATEGY = "http.poolStrategy";
  public static final String HTTP_POOL_MIN_SIZE = "http.poolMinSize";
  public static final String HTTP_MAX_HEADER_SIZE = "http.maxHeaderSize";
  public static final String HTTP_MAX_CHUNK_SIZE = "http.maxChunkSize";
  public static final String HTTP_MAX_CONCURRENT_CONNECTIONS = "http.maxConcurrentConnections";

  public static final int DEFAULT_POOL_WAITER_SIZE = Integer.MAX_VALUE;
  public static final int DEFAULT_POOL_SIZE = 200;
  public static final int DEFAULT_REQUEST_TIMEOUT = 10000;
  public static final int DEFAULT_IDLE_TIMEOUT = 25000;
  public static final int DEFAULT_SHUTDOWN_TIMEOUT = 5000;
  public static final int DEFAULT_MAX_RESPONSE_SIZE = 1024 * 1024 * 2;
  public static final String DEFAULT_CLIENT_NAME = "noNameSpecifiedClient";
  public static final AsyncPoolImpl.Strategy DEFAULT_POOL_STRATEGY = AsyncPoolImpl.Strategy.MRU;
  public static final int DEFAULT_POOL_MIN_SIZE = 0;
  public static final int DEFAULT_MAX_HEADER_SIZE = 8 * 1024;
  public static final int DEFAULT_MAX_CHUNK_SIZE = 8 * 1024;


  private static final String LIST_SEPARATOR = ",";

  private final NioEventLoopGroup          _eventLoopGroup;
  private final ScheduledExecutorService   _executor;
  private final ExecutorService            _callbackExecutorGroup;
  private final boolean                    _shutdownFactory;
  private final boolean                    _shutdownExecutor;
  private final boolean                    _shutdownCallbackExecutor;
  private final FilterChain                _filters;

  private final AtomicBoolean              _finishingShutdown = new AtomicBoolean(false);
  private volatile ScheduledFuture<?>      _shutdownTimeoutTask;
  private final AbstractJmxManager         _jmxManager;

  
  private final CompressionConfig          _defaultRequestCompressionConfig;
  
  private final Map<String, CompressionConfig> _requestCompressionConfigs;
  
  private final Map<String, CompressionConfig> _responseCompressionConfigs;
  
  private final boolean                    _useClientCompression;

  
  private final Object                     _mutex               = new Object();
  private boolean                          _running             = true;
  private int                              _clientsOutstanding  = 0;
  private Callback<None>                   _factoryShutdownCallback;

  
  public HttpClientFactory()
  {
    this(FilterChains.empty());
  }

  
  public HttpClientFactory(ExecutorService callbackExecutor,
                           boolean shutdownCallbackExecutor)
  {
    this(FilterChains.empty(),
         new NioEventLoopGroup(0 , new NamedThreadFactory("R2 Nio Event Loop")),
         true,
         Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler")),
         true,
         callbackExecutor,
         shutdownCallbackExecutor);
  }

  
  public HttpClientFactory(FilterChain filters)
  {
    
    
    this(filters,
         new NioEventLoopGroup(0 , new NamedThreadFactory("R2 Nio Event Loop")),
         true,
         Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler")),
         true);
  }

  
  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor)
  {
    this(filters,
         eventLoopGroup,
         shutdownFactory,
         executor,
         shutdownExecutor,
         null,
         false);
  }

  
  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor)
  {
    this(filters,
         eventLoopGroup,
         shutdownFactory,
         executor,
         shutdownExecutor,
         callbackExecutorGroup,
         shutdownCallbackExecutor,
         AbstractJmxManager.NULL_JMX_MANAGER);
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager)
  {
    this(filters, eventLoopGroup, shutdownFactory, executor, shutdownExecutor, callbackExecutorGroup,
        shutdownCallbackExecutor, jmxManager, Integer.MAX_VALUE, Collections.<String, CompressionConfig>emptyMap());
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager,
                           int requestCompressionThresholdDefault,
                           Map<String, CompressionConfig> requestCompressionConfigs)
  {
    this(filters, eventLoopGroup, shutdownFactory, executor, shutdownExecutor, callbackExecutorGroup,
        shutdownCallbackExecutor, jmxManager, requestCompressionThresholdDefault, requestCompressionConfigs,
        true);
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager,
                           int requestCompressionThresholdDefault,
                           Map<String, CompressionConfig> requestCompressionConfigs,
                           boolean useClientCompression)
  {
    this(filters, eventLoopGroup, shutdownFactory, executor, shutdownExecutor, callbackExecutorGroup,
        shutdownCallbackExecutor, jmxManager, requestCompressionThresholdDefault, requestCompressionConfigs,
        Collections.<String, CompressionConfig>emptyMap(), useClientCompression);
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager,
                           final int requestCompressionThresholdDefault,
                           final Map<String, CompressionConfig> requestCompressionConfigs,
                           final Map<String, CompressionConfig> responseCompressionConfigs,
                           boolean useClientCompression)
  {
    _filters = filters;
    _eventLoopGroup = eventLoopGroup;
    _shutdownFactory = shutdownFactory;
    _executor = executor;
    _shutdownExecutor = shutdownExecutor;
    _callbackExecutorGroup = callbackExecutorGroup;
    _shutdownCallbackExecutor = shutdownCallbackExecutor;
    _jmxManager = jmxManager;
    _defaultRequestCompressionConfig = new CompressionConfig(requestCompressionThresholdDefault);
    if (requestCompressionConfigs == null)
    {
      throw new IllegalArgumentException("requestCompressionConfigs should not be null.");
    }
    _requestCompressionConfigs = Collections.unmodifiableMap(requestCompressionConfigs);
    if (responseCompressionConfigs == null)
    {
      throw new IllegalArgumentException("responseCompressionConfigs should not be null.");
    }
    _responseCompressionConfigs = Collections.unmodifiableMap(responseCompressionConfigs);
    _useClientCompression = useClientCompression;
  }

  @Override
  public TransportClient getClient(Map<String, ? extends Object> properties)
  {
    SSLContext sslContext;
    SSLParameters sslParameters;

    
    properties = new HashMap<String,Object>(properties);
    sslContext = coerceAndRemoveFromMap(HTTP_SSL_CONTEXT, properties, SSLContext.class);
    sslParameters = coerceAndRemoveFromMap(HTTP_SSL_PARAMS, properties, SSLParameters.class);

    return getClient(properties, sslContext, sslParameters);
  }

  HttpNettyClient getRawClient(Map<String, String> properties)
  {
    return getRawClient(properties, null, null);
  }

  private static <T> T coerceAndRemoveFromMap(String key, Map<String, ?> props, Class<T> valueClass)
  {
    return coerce(key, props.remove(key), valueClass);
  }

  private static <T> T coerce(String key, Object value, Class<T> valueClass)
  {
    if (value == null)
    {
      return null;
    }
    if (!valueClass.isInstance(value))
    {
      throw new IllegalArgumentException(
              "Property " + key + " is of type " + value.getClass().getName() +
              " but must be " + valueClass.getName());
    }
    return valueClass.cast(value);
  }

   CompressionConfig getRequestCompressionConfig(String httpServiceName, EncodingType requestContentEncoding)
  {
    if (_requestCompressionConfigs.containsKey(httpServiceName))
    {
      if (requestContentEncoding == EncodingType.IDENTITY)
      {
        
        
        
        
        
        LOG.warn("No request compression algorithm available but compression config specified for service {}", httpServiceName);
      }
      return _requestCompressionConfigs.get(httpServiceName);
    }
    return _defaultRequestCompressionConfig;
  }

  
  private TransportClient getClient(Map<String, ? extends Object> properties,
                                   SSLContext sslContext,
                                   SSLParameters sslParameters)
  {
    LOG.info("Getting a client with configuration {} and SSLContext {}",
             properties,
             sslContext);
    TransportClient client = getRawClient(properties, sslContext, sslParameters);

    List<String> httpRequestServerSupportedEncodings = ConfigValueExtractor.buildList(properties.remove(HTTP_REQUEST_CONTENT_ENCODINGS),
                                                                                      LIST_SEPARATOR);
    
    
    
    
    
    
    List<String> httpResponseCompressionOperations = ConfigValueExtractor.buildList(properties.remove(HTTP_RESPONSE_COMPRESSION_OPERATIONS),
                                                                                    LIST_SEPARATOR);
    String useResponseCompressionProperty = (String) properties.get(HTTP_USE_RESPONSE_COMPRESSION);
    if (useResponseCompressionProperty != null && Boolean.parseBoolean(useResponseCompressionProperty))
    {
      httpResponseCompressionOperations.add(ClientCompressionFilter.COMPRESS_ALL_RESPONSES_INDICATOR);
    }

    FilterChain filters;
    String httpServiceName = (String) properties.get(HTTP_SERVICE_NAME);
    EncodingType requestContentEncoding = getRequestContentEncoding(httpRequestServerSupportedEncodings);
    if (_useClientCompression && (requestContentEncoding != EncodingType.IDENTITY || !httpResponseCompressionOperations.isEmpty()))
    {
      filters = _filters.addLast(new ClientCompressionFilter(requestContentEncoding,
                                                             getRequestCompressionConfig(httpServiceName, requestContentEncoding),
                                                             buildAcceptEncodingSchemas(),
                                                             _responseCompressionConfigs.get(httpServiceName),
                                                             httpResponseCompressionOperations));
    }
    else
    {
      filters = _filters;
    }

    Integer queryPostThreshold = chooseNewOverDefault(getIntValue(properties, HTTP_QUERY_POST_THRESHOLD), Integer.MAX_VALUE);
    filters = filters.addLast(new ClientQueryTunnelFilter(queryPostThreshold));

    client = new FilterChainClient(client, filters);
    client = new FactoryClient(client);
    synchronized (_mutex)
    {
      if (!_running)
      {
        throw new IllegalStateException("Factory is shutting down");
      }
      _clientsOutstanding++;
      return client;
    }
  }

  
  private static EncodingType getRequestContentEncoding(List<String> serverSupportedEncodings)
  {
    for (String encoding: serverSupportedEncodings)
    {
      if (EncodingType.isSupported(encoding))
      {
        return EncodingType.get(encoding);
      }
    }
    return EncodingType.IDENTITY;
  }

  
  private EncodingType[] buildAcceptEncodingSchemas()
  {
    EncodingType[] schemas = new EncodingType[EncodingType.values().length - 2];
    int i = 0;
    for (EncodingType type : EncodingType.values())
    {
      if (!type.equals(EncodingType.IDENTITY) && !type.equals(EncodingType.ANY))
      {
        schemas[i++] = type;
      }
    }
    return schemas;
  }

  
  private Integer getIntValue(Map<String, ? extends Object> properties, String propertyKey)
  {
    if (properties == null)
    {
      LOG.warn("passed a null raw client properties");
      return null;
    }
    if (properties.containsKey(propertyKey))
    {
      
      
      return Integer.parseInt((String)properties.get(propertyKey));
    }
    else
    {
      return null;
    }
  }

  private AsyncPoolImpl.Strategy getStrategy(Map<String, ? extends Object> properties)
  {
    if (properties == null)
    {
      LOG.warn("passed a null raw client properties");
      return null;
    }
    if (properties.containsKey(HTTP_POOL_STRATEGY))
    {
      String strategyString = (String)properties.get(HTTP_POOL_STRATEGY);
      if (strategyString.equalsIgnoreCase("LRU"))
      {
        return AsyncPoolImpl.Strategy.LRU;
      }
      else if (strategyString.equalsIgnoreCase("MRU"))
      {
        return AsyncPoolImpl.Strategy.MRU;
      }
    }
    
    return null;
  }

  
  HttpNettyClient getRawClient(Map<String, ? extends Object> properties,
                               SSLContext sslContext,
                               SSLParameters sslParameters)
  {
    Integer poolSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_SIZE), DEFAULT_POOL_SIZE);
    Integer idleTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_IDLE_TIMEOUT), DEFAULT_IDLE_TIMEOUT);
    Integer shutdownTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_SHUTDOWN_TIMEOUT), DEFAULT_SHUTDOWN_TIMEOUT);
    Integer maxResponseSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_RESPONSE_SIZE), DEFAULT_MAX_RESPONSE_SIZE);
    Integer requestTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_REQUEST_TIMEOUT), DEFAULT_REQUEST_TIMEOUT);
    Integer poolWaiterSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_WAITER_SIZE), DEFAULT_POOL_WAITER_SIZE);
    String clientName = null;
    if (properties != null && properties.containsKey(HTTP_SERVICE_NAME))
    {
      clientName = (String)properties.get(HTTP_SERVICE_NAME) + "Client";
    }
    clientName = chooseNewOverDefault(clientName, DEFAULT_CLIENT_NAME);
    AsyncPoolImpl.Strategy strategy = chooseNewOverDefault(getStrategy(properties), DEFAULT_POOL_STRATEGY);
    Integer poolMinSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_MIN_SIZE), DEFAULT_POOL_MIN_SIZE);
    Integer maxHeaderSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_HEADER_SIZE), DEFAULT_MAX_HEADER_SIZE);
    Integer maxChunkSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_CHUNK_SIZE), DEFAULT_MAX_CHUNK_SIZE);
    Integer maxConcurrentConnections = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_CONCURRENT_CONNECTIONS), Integer.MAX_VALUE);

    return new HttpNettyClient(_eventLoopGroup,
                               _executor,
                               poolSize,
                               requestTimeout,
                               idleTimeout,
                               shutdownTimeout,
                               maxResponseSize,
                               sslContext,
                               sslParameters,
                               _callbackExecutorGroup,
                               poolWaiterSize,
                               clientName,
                               _jmxManager,
                               strategy,
                               poolMinSize,
                               maxHeaderSize,
                               maxChunkSize,
                               maxConcurrentConnections);
  }

  
  private <T> T chooseNewOverDefault(T newValue, T defaultValue)
  {
    if (newValue == null)
    {
      return defaultValue;
    }
    else
    {
      return newValue;
    }
  }


  
  @Override
  public void shutdown(final Callback<None> callback)
  {
    final int count;
    synchronized (_mutex)
    {
      _running = false;
      count = _clientsOutstanding;
      _factoryShutdownCallback = callback;
    }

    if (count == 0)
    {
      finishShutdown();
    }
    else
    {
      LOG.info("Awaiting shutdown of {} outstanding clients", count);
    }
  }

  
  public void shutdown(Callback<None> callback, long timeout, TimeUnit timeoutUnit)
  {
    
    _shutdownTimeoutTask = _executor.schedule(new Runnable()
    {
      @Override
      public void run()
      {
        LOG.warn("Shutdown timeout exceeded, proceeding with shutdown");
        finishShutdown();
      }
    }, timeout, timeoutUnit);

    
    shutdown(callback);
  }

  private void finishShutdown()
  {
    if (!_finishingShutdown.compareAndSet(false, true))
    {
      return;
    }
    if (_shutdownTimeoutTask != null)
    {
      _shutdownTimeoutTask.cancel(false);
    }

    if (_shutdownFactory)
    {
      LOG.info("Shutdown Netty Event Loop");
      _eventLoopGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS);
    }

    if (_shutdownExecutor)
    {
      
      
      
      
      
      _executor.shutdown();
      _executor.shutdownNow();
      LOG.info("Scheduler shutdown complete");
    }

    if (_shutdownCallbackExecutor)
    {
      LOG.info("Shutdown callback executor");
      _callbackExecutorGroup.shutdown();
      _callbackExecutorGroup.shutdownNow();
    }

    final Callback<None> callback;
    synchronized (_mutex)
    {
      callback = _factoryShutdownCallback;
    }

    LOG.info("Shutdown complete");
    callback.onSuccess(None.none());
  }

  private void clientShutdown()
  {
    final boolean done;
    synchronized (_mutex)
    {
      _clientsOutstanding--;
      done = !_running && _clientsOutstanding == 0;
    }
    if (done)
    {
      finishShutdown();
    }
  }

  
  private class FactoryClient implements TransportClient
  {
    private final TransportClient _client;
    private final AtomicBoolean _shutdown = new AtomicBoolean(false);

    private FactoryClient(TransportClient client)
    {
      _client = client;
    }

    @Override
    public void restRequest(RestRequest request, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            TransportCallback<RestResponse> callback)
    {
      _client.restRequest(request, requestContext, wireAttrs, callback);
    }

    @Override
    public void shutdown(final Callback<None> callback)
    {
      if (_shutdown.compareAndSet(false, true))
      {
        _client.shutdown(new Callback<None>()
        {
          @Override
          public void onSuccess(None none)
          {
            try
            {
              callback.onSuccess(none);
            }
            finally
            {
              clientShutdown();
            }
          }

          @Override
          public void onError(Throwable e)
          {
            try
            {
              callback.onError(e);
            }
            finally
            {
              clientShutdown();
            }
          }
        });
      }
      else
      {
        callback.onError(new IllegalStateException("shutdown has already been requested."));
      }
    }
  }
}

<code block>




package com.linkedin.r2.transport.http.client;

import com.linkedin.r2.transport.common.bridge.client.TransportClient;
import io.netty.channel.nio.NioEventLoopGroup;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.linkedin.common.callback.Callbacks;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;



public class TestHttpClientFactory
{
  private TestServer _testServer;

  @BeforeClass
  public void setup() throws IOException
  {
    _testServer = new TestServer();
  }

  @AfterClass
  public void tearDown() throws IOException, InterruptedException
  {
    _testServer.shutdown();
  }

  @Test
  public void testShutdownAfterClients() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    for (Client c : clients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      c.shutdown(callback);
      callback.get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);
    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testShutdownBeforeClients() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    for (Client c : clients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      c.shutdown(callback);
      callback.get(30, TimeUnit.SECONDS);
    }

    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testGetRawClient()
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    Map<String, String> properties = new HashMap<String, String>();

    String requestTimeout = "7000";
    String poolSize = "10";
    String maxResponse = "3000";
    String idleTimeout = "8000";
    String shutdownTimeout = "14000";
    HttpNettyClient client;

    
    client = factory.getRawClient(properties);
    Assert.assertEquals(client.getMaxResponseSize(), HttpClientFactory.DEFAULT_MAX_RESPONSE_SIZE);
    Assert.assertEquals(client.getRequestTimeout(), HttpClientFactory.DEFAULT_REQUEST_TIMEOUT);
    Assert.assertEquals(client.getShutdownTimeout(), HttpClientFactory.DEFAULT_SHUTDOWN_TIMEOUT);

    
    properties.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, requestTimeout);
    properties.put(HttpClientFactory.HTTP_POOL_SIZE, poolSize);
    properties.put(HttpClientFactory.HTTP_IDLE_TIMEOUT, idleTimeout);
    properties.put(HttpClientFactory.HTTP_MAX_RESPONSE_SIZE, maxResponse);
    properties.put(HttpClientFactory.HTTP_SHUTDOWN_TIMEOUT, shutdownTimeout);
    client = factory.getRawClient(properties);
    Assert.assertEquals(client.getMaxResponseSize(), Integer.parseInt(maxResponse));
    Assert.assertEquals(client.getRequestTimeout(), Integer.parseInt(requestTimeout));
    Assert.assertEquals(client.getShutdownTimeout(), Integer.parseInt(shutdownTimeout));
  }

  @Test
  public void testNewSSLProperties() throws Exception
  {
    HttpClientFactory factory = new HttpClientFactory();
    Map<String,Object> params = new HashMap<String, Object>();
    SSLParameters sslParameters = new SSLParameters();
    sslParameters.setProtocols(new String[]{ "Unsupported" });
    params.put(HttpClientFactory.HTTP_SSL_CONTEXT, SSLContext.getDefault());
    params.put(HttpClientFactory.HTTP_SSL_PARAMS, sslParameters);

    try
    {
      factory.getClient(Collections.unmodifiableMap(params));
      Assert.fail("Should have failed");
    }
    catch (IllegalArgumentException e)
    {
      Assert.assertTrue(e.getMessage().contains("None of the requested protocols: [Unsupported] are found in SSLContext"),
                        "Unexpected error message " + e.getMessage());
    }
  }

  @Test
  public void testSSLParams() throws Exception
  {
    HttpClientFactory factory = new HttpClientFactory();
    Map<String,Object> params = new HashMap<String, Object>();
    SSLParameters sslParameters = new SSLParameters();
    sslParameters.setProtocols(new String[]{ "Unsupported" });

    params.put(HttpClientFactory.HTTP_SSL_CONTEXT, SSLContext.getDefault());
    params.put(HttpClientFactory.HTTP_SSL_PARAMS, sslParameters);

    try
    {
      factory.getClient(Collections.unmodifiableMap(params));
      Assert.fail("Should have failed");
    }
    catch (IllegalArgumentException e)
    {
      Assert.assertTrue(e.getMessage().contains("None of the requested protocols: [Unsupported] are found in SSLContext"),
                        "Unexpected error message " + e.getMessage());
    }
  }

  @Test
  public void testShutdownTimeout() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown, 1, TimeUnit.SECONDS);

    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testShutdownNoTimeout() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    try
    {
      factoryShutdown.get(1, TimeUnit.SECONDS);
      Assert.fail("Factory shutdown should have timed out");
    }
    catch (TimeoutException e)
    {
      
    }

    Assert.assertFalse(eventLoop.isShutdown(), "Boss should not be shut down");
    Assert.assertFalse(scheduler.isShutdown(), "Scheduler should not be shut down");
  }

  @Test
  public void testShutdownIOThread() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    Client client = new TransportClientAdapter(factory.getClient(
            Collections.<String, Object>emptyMap()));

    Future<RestResponse> responseFuture = client.restRequest(new RestRequestBuilder(_testServer.resetResponseLatch(1)).build());


    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    FutureCallback<None> clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);

    
    
    
    _testServer.releaseResponseLatch();

    responseFuture.get(60, TimeUnit.SECONDS);
    clientShutdown.get(60, TimeUnit.SECONDS);
    factoryShutdown.get(60, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(60, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  
  @Test
  public void testShutdownTimeoutDoesNotOccupyExecutors()
          throws InterruptedException, ExecutionException, TimeoutException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, false, scheduler, false);

    FutureCallback<None> callback = new FutureCallback<None>();
    factory.shutdown(callback, 60, TimeUnit.MINUTES);
    callback.get(60, TimeUnit.SECONDS);
    scheduler.shutdown();
    eventLoop.shutdownGracefully();
    Assert.assertTrue(scheduler.awaitTermination(60, TimeUnit.SECONDS));
    Assert.assertTrue(eventLoop.awaitTermination(60, TimeUnit.SECONDS));
  }

  @Test
  public void testRequestTimeoutConfig()
  {
    HttpClientFactory factory = new HttpClientFactory();

    try
    {
      Map<String,String> config = new HashMap<String, String>();

      config.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, "999");
      HttpNettyClient client = factory.getRawClient(config);
      Assert.assertEquals(client.getRequestTimeout(), 999);


      config.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, "888");
      client = factory.getRawClient(config);
      Assert.assertEquals(client.getRequestTimeout(), 888);

    }
    finally
    {
      factory.shutdown(Callbacks.<None>empty());
    }

  }

  @Test
  public void testClientShutdownBeingCalledMultipleTimes()
      throws InterruptedException, ExecutionException, TimeoutException
  {
    HttpClientFactory factory = new HttpClientFactory();
    TransportClient client = factory.getClient(Collections.<String, Object>emptyMap());
    
    FutureCallback<None> clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);
    clientShutdown.get(30, TimeUnit.SECONDS);
    
    clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);
    try
    {
      clientShutdown.get(30, TimeUnit.SECONDS);
      Assert.fail("should have thrown exception on the second shutdown call.");
    }
    catch (ExecutionException ex)
    {
      Assert.assertTrue(ex.getCause() instanceof IllegalStateException);
    }

    FutureCallback<None> shutdownCallback = new FutureCallback<None>();
    factory.shutdown(shutdownCallback);
    shutdownCallback.get(30, TimeUnit.SECONDS);
  }

  @DataProvider(name = "compressionConfigsData")
  private Object[][] compressionConfigsData()
  {
    return new Object[][] {
        {"service1", 10000, new CompressionConfig(0)},
        {"service2", 10000, new CompressionConfig(Integer.MAX_VALUE)},
        {"service3", 10000, new CompressionConfig(111)},
        {"service4", 10000, new CompressionConfig(10000)},
        {"service1", 0, new CompressionConfig(0)},
        {"service2", 0, new CompressionConfig(Integer.MAX_VALUE)},
        {"service3", 0, new CompressionConfig(111)},
        {"service4", 0, new CompressionConfig(0)}
    };
  }

  @Test(dataProvider = "compressionConfigsData")
  public void testGetRequestCompressionConfig(String serviceName, int requestCompressionThresholdDefault, CompressionConfig expectedConfig)
  {
    Map<String, CompressionConfig> requestCompressionConfigs = new HashMap<String, CompressionConfig>();
    requestCompressionConfigs.put("service1", new CompressionConfig(0));
    requestCompressionConfigs.put("service2", new CompressionConfig(Integer.MAX_VALUE));
    requestCompressionConfigs.put("service3", new CompressionConfig(111));
    HttpClientFactory factory = new HttpClientFactory(null, null, true, null, true, null, true, null,
        requestCompressionThresholdDefault, requestCompressionConfigs);
    Assert.assertEquals(factory.getRequestCompressionConfig(serviceName, EncodingType.SNAPPY), expectedConfig);
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.parseq.Engine;
import com.linkedin.parseq.EngineBuilder;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.transport.common.bridge.server.TransportDispatcher;
import com.linkedin.r2.transport.http.server.HttpServer;
import com.linkedin.r2.transport.http.server.HttpServerFactory;
import com.linkedin.restli.docgen.DefaultDocumentationRequestHandler;
import com.linkedin.restli.examples.groups.server.api.GroupMembershipMgr;
import com.linkedin.restli.examples.groups.server.api.GroupMgr;
import com.linkedin.restli.examples.groups.server.impl.HashGroupMembershipMgr;
import com.linkedin.restli.examples.groups.server.impl.HashMapGroupMgr;
import com.linkedin.restli.examples.groups.server.rest.impl.GroupsRestApplication;
import com.linkedin.restli.server.DelegatingTransportDispatcher;
import com.linkedin.restli.server.ParseqTraceDebugRequestHandler;
import com.linkedin.restli.server.RestLiConfig;
import com.linkedin.restli.server.RestLiServer;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.server.mock.InjectMockResourceFactory;
import com.linkedin.restli.server.mock.SimpleBeanProvider;
import com.linkedin.restli.server.resources.ResourceFactory;

import java.io.IOException;
import java.net.URI;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;



public class RestLiIntTestServer
{
  public static final int      DEFAULT_PORT           = 1338;
  public static final int      NO_COMPRESSION_PORT    = 1339;
  public static final int      FILTERS_PORT           = 1340;
  public static final String   supportedCompression   = "gzip,snappy,bzip2,deflate";
  public static final String[] RESOURCE_PACKAGE_NAMES = {
      "com.linkedin.restli.examples.groups.server.rest.impl",
      "com.linkedin.restli.examples.greetings.server",
      "com.linkedin.restli.examples.typeref.server"  };

  public static void main(String[] args) throws IOException
  {
    final int numCores = Runtime.getRuntime().availableProcessors();
    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(numCores + 1);
    final Engine engine = new EngineBuilder()
        .setTaskExecutor(scheduler)
        .setTimerScheduler(scheduler)
        .build();

    HttpServer server = createServer(engine, DEFAULT_PORT, supportedCompression);
    server.start();

    System.out.println("HttpServer running on port " + DEFAULT_PORT + ". Press any key to stop server");
    System.in.read();

    server.stop();
    engine.shutdown();
  }

  public static HttpServer createServer(final Engine engine, int port, String supportedCompression)
  {
    return createServer(engine, port, supportedCompression, false, -1);
  }

  public static HttpServer createServer(final Engine engine,
                                        int port,
                                        String supportedCompression,
                                        boolean useAsyncServletApi,
                                        int asyncTimeOut)
  {
    final FilterChain fc = FilterChains.empty().addLast(new ServerCompressionFilter(supportedCompression, new CompressionConfig(0)))
        .addLast(new SimpleLoggingFilter());
    return createServer(engine, port, useAsyncServletApi, asyncTimeOut, null, null, fc);
  }

  public static HttpServer createServer(final Engine engine,
                                        int port,
                                        boolean useAsyncServletApi,
                                        int asyncTimeOut,
                                        List<? extends RequestFilter> requestFilters,
                                        List<? extends ResponseFilter> responseFilters,
                                        final FilterChain filterChain)
  {
    RestLiConfig config = new RestLiConfig();
    config.addResourcePackageNames(RESOURCE_PACKAGE_NAMES);
    config.setServerNodeUri(URI.create("http:
    config.setDocumentationRequestHandler(new DefaultDocumentationRequestHandler());
    config.addDebugRequestHandlers(new ParseqTraceDebugRequestHandler());
    config.setRequestFilters(requestFilters);
    config.setResponseFilters(responseFilters);

    GroupMembershipMgr membershipMgr = new HashGroupMembershipMgr();
    GroupMgr groupMgr = new HashMapGroupMgr(membershipMgr);
    GroupsRestApplication app = new GroupsRestApplication(groupMgr, membershipMgr);
    SimpleBeanProvider beanProvider = new SimpleBeanProvider();
    beanProvider.add("GroupsRestApplication", app);
    
    ResourceFactory factory = new InjectMockResourceFactory(beanProvider);

    TransportDispatcher dispatcher = new DelegatingTransportDispatcher(new RestLiServer(config, factory, engine));

    return new HttpServerFactory(filterChain).createServer(port,
                                                           HttpServerFactory.DEFAULT_CONTEXT_PATH,
                                                           HttpServerFactory.DEFAULT_THREAD_POOL_SIZE,
                                                           dispatcher,
                                                           useAsyncServletApi,
                                                           asyncTimeOut);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.r2.filter.CompressionOption;

import java.util.List;



public class RestliRequestOptions
{
  private final ProtocolVersionOption _protocolVersionOption;
  private final CompressionOption _requestCompressionOverride;
  private final CompressionOption _responseCompressionOverride;
  private final RestClient.ContentType _contentType;
  private final List<RestClient.AcceptType> _acceptTypes;

  public static final RestliRequestOptions DEFAULT_OPTIONS
      = new RestliRequestOptions(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE, null, null, null, null);

  public static final RestliRequestOptions FORCE_USE_NEXT_OPTION =
      new RestliRequestOptions(ProtocolVersionOption.FORCE_USE_NEXT, null, null, null, null);

  
  RestliRequestOptions(ProtocolVersionOption protocolVersionOption,
                       CompressionOption requestCompressionOverride,
                       CompressionOption responseCompressionOverride,
                       RestClient.ContentType contentType,
                       List<RestClient.AcceptType> acceptTypes)
  {
    _protocolVersionOption =
        (protocolVersionOption == null) ? ProtocolVersionOption.USE_LATEST_IF_AVAILABLE : protocolVersionOption;
    _requestCompressionOverride = requestCompressionOverride;
    _responseCompressionOverride = responseCompressionOverride;
    _contentType = contentType;
    _acceptTypes = acceptTypes;
  }

  public ProtocolVersionOption getProtocolVersionOption()
  {
    return _protocolVersionOption;
  }

  public CompressionOption getRequestCompressionOverride()
  {
    return _requestCompressionOverride;
  }

  public List<RestClient.AcceptType> getAcceptTypes()
  {
    return _acceptTypes;
  }

  public RestClient.ContentType getContentType()
  {
    return _contentType;
  }

  public CompressionOption getResponseCompressionOverride()
  {
    return _responseCompressionOverride;
  }

  @Override
  public boolean equals(Object o)
  {
    if (this == o)
    {
      return true;
    }
    if (o == null || getClass() != o.getClass())
    {
      return false;
    }

    RestliRequestOptions that = (RestliRequestOptions) o;

    if (_acceptTypes != null ? !_acceptTypes.equals(that._acceptTypes) : that._acceptTypes != null)
    {
      return false;
    }
    if (_contentType != that._contentType)
    {
      return false;
    }
    if (_protocolVersionOption != that._protocolVersionOption)
    {
      return false;
    }
    if (_requestCompressionOverride != that._requestCompressionOverride)
    {
      return false;
    }
    if (_responseCompressionOverride != that._responseCompressionOverride)
    {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode()
  {
    int result = _protocolVersionOption != null ? _protocolVersionOption.hashCode() : 0;
    result = 31 * result + (_requestCompressionOverride != null ? _requestCompressionOverride.hashCode() : 0);
    result = 31 * result + (_responseCompressionOverride != null ? _responseCompressionOverride.hashCode() : 0);
    result = 31 * result + (_contentType != null ? _contentType.hashCode() : 0);
    result = 31 * result + (_acceptTypes != null ? _acceptTypes.hashCode() : 0);
    return result;
  }

  @Override
  public String toString()
  {
    return "{_protocolVersionOption: " + _protocolVersionOption
        + ", _requestCompressionOverride: " + _requestCompressionOverride
        + ", _responseCompressionOverride: " + _responseCompressionOverride
        + ", _contentType: " + _contentType
        + ", _acceptTypes: " + _acceptTypes
        + "}";
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.r2.filter.CompressionOption;

import java.util.Collections;
import java.util.List;



public class RestliRequestOptionsBuilder
{
  private ProtocolVersionOption _protocolVersionOption;
  private CompressionOption _requestCompressionOverride;
  private RestClient.ContentType _contentType;
  private List<RestClient.AcceptType> _acceptTypes;
  private CompressionOption _responseCompressionOverride;

  public RestliRequestOptionsBuilder()
  {

  }

  public RestliRequestOptionsBuilder(RestliRequestOptions restliRequestOptions)
  {
    setProtocolVersionOption(restliRequestOptions.getProtocolVersionOption());
    setRequestCompressionOverride(restliRequestOptions.getRequestCompressionOverride());
    setResponseCompressionOverride(restliRequestOptions.getResponseCompressionOverride());
    setContentType(restliRequestOptions.getContentType());
    setAcceptTypes(restliRequestOptions.getAcceptTypes());
  }

  public RestliRequestOptionsBuilder setProtocolVersionOption(ProtocolVersionOption protocolVersionOption)
  {
    _protocolVersionOption = protocolVersionOption;
    return this;
  }

  public RestliRequestOptionsBuilder setRequestCompressionOverride(CompressionOption requestCompressionOverride)
  {
    _requestCompressionOverride = requestCompressionOverride;
    return this;
  }

  public RestliRequestOptionsBuilder setContentType(RestClient.ContentType contentType)
  {
    _contentType = contentType;
    return this;
  }

  public RestliRequestOptionsBuilder setAcceptTypes(List<RestClient.AcceptType> acceptTypes)
  {
    _acceptTypes = Collections.unmodifiableList(acceptTypes);
    return this;
  }

  public RestliRequestOptionsBuilder setResponseCompressionOverride(CompressionOption responseCompressionOverride)
  {
    _responseCompressionOverride = responseCompressionOverride;
    return this;
  }

  public RestliRequestOptions build()
  {
    return new RestliRequestOptions(_protocolVersionOption, _requestCompressionOverride, _responseCompressionOverride, _contentType, _acceptTypes);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.callback.CallbackAdapter;
import com.linkedin.common.callback.Callbacks;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.codec.PsonDataCodec;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.client.multiplexer.MultiplexedCallback;
import com.linkedin.restli.client.multiplexer.MultiplexedRequest;
import com.linkedin.restli.client.multiplexer.MultiplexedResponse;
import com.linkedin.restli.client.uribuilders.MultiplexerUriBuilder;
import com.linkedin.restli.client.uribuilders.RestliUriBuilderUtil;
import com.linkedin.restli.common.HttpMethod;
import com.linkedin.restli.common.OperationNameGenerator;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.client.ExceptionUtil;
import com.linkedin.restli.internal.client.RequestBodyTransformer;
import com.linkedin.restli.internal.client.ResponseFutureImpl;
import com.linkedin.restli.internal.client.RestResponseDecoder;
import com.linkedin.restli.internal.common.AllProtocolVersions;

import javax.mail.internet.ParseException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;



public class RestClient
{
  private static final JacksonDataCodec  JACKSON_DATA_CODEC = new JacksonDataCodec();
  private static final PsonDataCodec     PSON_DATA_CODEC    = new PsonDataCodec();
  private static final List<AcceptType>  DEFAULT_ACCEPT_TYPES = Collections.emptyList();
  private static final ContentType DEFAULT_CONTENT_TYPE = ContentType.JSON;
  private static final Random RANDOM_INSTANCE = new Random();
  private final Client _client;

  private final String _uriPrefix;
  private final List<AcceptType> _acceptTypes;
  private final ContentType _contentType;
  
  
  
  private final boolean _forceUseNextVersionOverride =
      "true".equalsIgnoreCase(System.getProperty(RestConstants.RESTLI_FORCE_USE_NEXT_VERSION_OVERRIDE));

  public RestClient(Client client, String uriPrefix)
  {
    this(client, uriPrefix, DEFAULT_CONTENT_TYPE, DEFAULT_ACCEPT_TYPES);
  }

  
  @Deprecated
  public RestClient(Client client, String uriPrefix, List<AcceptType> acceptTypes)
  {
    this(client, uriPrefix, DEFAULT_CONTENT_TYPE, acceptTypes);
  }

  
  @Deprecated
  public RestClient(Client client, String uriPrefix, ContentType contentType, List<AcceptType> acceptTypes)
  {
    _client = client;
    _uriPrefix = (uriPrefix == null) ? null : uriPrefix.trim();
    _acceptTypes = acceptTypes;
    _contentType = contentType;
  }

  
  public void shutdown(Callback<None> callback)
  {
    _client.shutdown(callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request,
                                           RequestContext requestContext)
  {
    FutureCallback<Response<T>> callback = new FutureCallback<Response<T>>();
    sendRequest(request, requestContext, callback);
    return new ResponseFutureImpl<T>(callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request,
                                           RequestContext requestContext,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    FutureCallback<Response<T>> callback = new FutureCallback<Response<T>>();
    sendRequest(request, requestContext, callback);
    return new ResponseFutureImpl<T>(callback, errorHandlingBehavior);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           RequestContext requestContext)
  {
    return sendRequest(requestBuilder.build(), requestContext);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           RequestContext requestContext,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(requestBuilder.build(), requestContext, errorHandlingBehavior);
  }

  
  public <T> void sendRequest(final Request<T> request,
                              RequestContext requestContext,
                              Callback<Response<T>> callback)
  {
    sendRestRequest(request, requestContext, new RestLiCallbackAdapter<T>(request.getResponseDecoder(), callback));
  }

  
  public <T> void sendRestRequest(final Request<T> request,
                                  RequestContext requestContext,
                                  Callback<RestResponse> callback)
  {
    RecordTemplate input = request.getInputRecord();
    ProtocolVersion protocolVersion = getProtocolVersionForService(request);
    URI requestUri = RestliUriBuilderUtil.createUriBuilder(request, _uriPrefix, protocolVersion).build();

    sendRequestImpl(requestContext,
                    requestUri,
                    request.getMethod(),
                    input != null ? RequestBodyTransformer.transform(request, protocolVersion) : null,
                    request.getHeaders(),
                    request.getMethodName(),
                    protocolVersion,
                    request.getRequestOptions(),
                    callback);
  }

  
  private ProtocolVersion getProtocolVersionForService(final Request<?> request)
  {
    try
    {
      return getProtocolVersion(AllProtocolVersions.BASELINE_PROTOCOL_VERSION,
                                AllProtocolVersions.LATEST_PROTOCOL_VERSION,
                                AllProtocolVersions.NEXT_PROTOCOL_VERSION,
                                getAnnouncedVersion(_client.getMetadata(new URI(_uriPrefix + request.getServiceName()))),
                                request.getRequestOptions().getProtocolVersionOption(),
                                _forceUseNextVersionOverride);
    }
    catch (URISyntaxException e)
    {
      throw new RuntimeException("Failed to create a valid URI to fetch properties for!");
    }
  }

  
   static ProtocolVersion getAnnouncedVersion(Map<String, Object> properties)
  {
    if(properties == null)
    {
      throw new RuntimeException("No valid properties found!");
    }
    Object potentialAnnouncedVersion = properties.get(RestConstants.RESTLI_PROTOCOL_VERSION_PROPERTY);
    
    if(potentialAnnouncedVersion == null)
    {
      return AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
    Object potentialAnnouncedVersionPercentage = properties.get(RestConstants.RESTLI_PROTOCOL_VERSION_PERCENTAGE_PROPERTY);
    
    if(potentialAnnouncedVersionPercentage == null)
    {
      return new ProtocolVersion(potentialAnnouncedVersion.toString());
    }
    try
    {
      int announceVersionPercentage = Integer.parseInt(potentialAnnouncedVersionPercentage.toString());
      
      return (announceVersionPercentage > 0 && announceVersionPercentage <= 100 && RANDOM_INSTANCE.nextInt(100) + 1 <= announceVersionPercentage) ?
          new ProtocolVersion(potentialAnnouncedVersion.toString()) : AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
    catch(NumberFormatException e)
    {
      
      return AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
  }

  
  static ProtocolVersion getProtocolVersion(ProtocolVersion baselineProtocolVersion,
                                                               ProtocolVersion latestVersion,
                                                               ProtocolVersion nextVersion,
                                                               ProtocolVersion announcedVersion,
                                                               ProtocolVersionOption versionOption,
                                                               boolean forceUseNextVersionOverride)
  {
    if (versionOption == null)
    {
      throw new IllegalArgumentException("versionOptions cannot be null!");
    }
    if (forceUseNextVersionOverride)
    {
      return nextVersion;
    }
    switch (versionOption)
    {
      case FORCE_USE_NEXT:
        return nextVersion;
      case FORCE_USE_LATEST:
        return latestVersion;
      case USE_LATEST_IF_AVAILABLE:
        if (announcedVersion.compareTo(baselineProtocolVersion) == -1)
        {
          
          throw new RuntimeException("Announced version is less than the default version!" +
            "Announced version: " + announcedVersion + ", default version: " + baselineProtocolVersion);
        }
        else if (announcedVersion.compareTo(baselineProtocolVersion) == 0)
        {
          
          return baselineProtocolVersion;
        }
        else if (announcedVersion.compareTo(latestVersion) == -1)
        {
          
          return announcedVersion;
        }
        
        return latestVersion;
      default:
        return baselineProtocolVersion;
    }
  }

  
  
  
  
  private void addAcceptHeaders(RestRequestBuilder builder, List<AcceptType> acceptTypes)
  {
    if (builder.getHeader(RestConstants.HEADER_ACCEPT) == null)
    {
      List<AcceptType> types = _acceptTypes;
      if (acceptTypes != null && !acceptTypes.isEmpty())
      {
        types = acceptTypes;
      }
      if (types != null && !types.isEmpty())
      {
        builder.setHeader(RestConstants.HEADER_ACCEPT, createAcceptHeader(types));
      }
    }
  }

  private String createAcceptHeader(List<AcceptType> acceptTypes)
  {
    if (acceptTypes.size() == 1)
    {
      return acceptTypes.get(0).getHeaderKey();
    }

    
    StringBuilder acceptHeader = new StringBuilder();
    double currQ = 1.0;
    Iterator<AcceptType> iterator = acceptTypes.iterator();
    while(iterator.hasNext())
    {
      acceptHeader.append(iterator.next().getHeaderKey());
      acceptHeader.append(";q=");
      acceptHeader.append(currQ);
      currQ -= .1;
      if (iterator.hasNext())
        acceptHeader.append(",");
    }

    return acceptHeader.toString();
  }


  
  
  
  
  private void addEntityAndContentTypeHeaders(RestRequestBuilder builder, DataMap dataMap, ContentType contentType)
    throws IOException
  {
    if (dataMap != null)
    {
      String header = builder.getHeader(RestConstants.HEADER_CONTENT_TYPE);

      ContentType type;
      if(header == null)
      {
        if (contentType != null)
        {
          type = contentType;
        }
        else if (_contentType != null)
        {
          type = _contentType;
        }
        else {
          type = DEFAULT_CONTENT_TYPE;
        }
        builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, type.getHeaderKey());
      }
      else
      {
        javax.mail.internet.ContentType headerContentType;
        try
        {
          headerContentType = new javax.mail.internet.ContentType(header);
        }
        catch (ParseException e)
        {
          throw new IllegalStateException("Unable to parse Content-Type: " + header);
        }

        if (headerContentType.getBaseType().equalsIgnoreCase(RestConstants.HEADER_VALUE_APPLICATION_JSON))
        {
          type = ContentType.JSON;
        }
        else if (headerContentType.getBaseType().equalsIgnoreCase(RestConstants.HEADER_VALUE_APPLICATION_PSON))
        {
          type = ContentType.PSON;
        }
        else
        {
          throw new IllegalStateException("Unknown Content-Type: " + headerContentType.toString());
        }
      }

      switch (type)
      {
        case PSON:
          builder.setEntity(PSON_DATA_CODEC.mapToBytes(dataMap));
          break;
        case JSON:
          builder.setEntity(JACKSON_DATA_CODEC.mapToBytes(dataMap));
          break;
        default:
          throw new IllegalStateException("Unknown ContentType:" + type);
      }
    }

  }

  
  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder,
                              RequestContext requestContext,
                              Callback<Response<T>> callback)
  {
    sendRequest(requestBuilder.build(), requestContext, callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request)
  {
    return sendRequest(request, new RequestContext());
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request, ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(request, new RequestContext(), errorHandlingBehavior);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder)
  {
    return sendRequest(requestBuilder.build(), new RequestContext());
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(requestBuilder.build(), new RequestContext(), errorHandlingBehavior);
  }

  
  public <T> void sendRequest(final Request<T> request, Callback<Response<T>> callback)
  {
    sendRequest(request, new RequestContext(), callback);
  }

  
  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder, Callback<Response<T>> callback)
  {
    sendRequest(requestBuilder.build(), new RequestContext(), callback);
  }

  
  public void sendRequest(MultiplexedRequest multiplexedRequest)
  {
    sendRequest(multiplexedRequest, Callbacks.<MultiplexedResponse>empty());
  }

  
  public void sendRequest(MultiplexedRequest multiplexedRequest, Callback<MultiplexedResponse> callback)
  {
    MultiplexedCallback muxCallback = new MultiplexedCallback(multiplexedRequest.getCallbacks(), callback);
    try
    {
      RestRequest restRequest = buildMultiplexedRequest(multiplexedRequest);
      RequestContext requestContext = new RequestContext();
      _client.restRequest(restRequest, requestContext, muxCallback);
    }
    catch (Exception e)
    {
      muxCallback.onError(e);
    }
  }

  private RestRequest buildMultiplexedRequest(MultiplexedRequest multiplexedRequest) throws IOException
  {
    URI requestUri = new MultiplexerUriBuilder(_uriPrefix).build();
    RestRequestBuilder requestBuilder = new RestRequestBuilder(requestUri).setMethod(HttpMethod.POST.toString());
    addAcceptHeaders(requestBuilder, Collections.singletonList(AcceptType.JSON));
    addEntityAndContentTypeHeaders(requestBuilder, multiplexedRequest.getContent().data(), ContentType.JSON);
    return requestBuilder.build();
  }

  
  private void sendRequestImpl(RequestContext requestContext,
                               URI uri,
                               ResourceMethod method,
                               DataMap dataMap,
                               Map<String, String> headers,
                               String methodName,
                               ProtocolVersion protocolVersion,
                               RestliRequestOptions requestOptions,
                               Callback<RestResponse> callback)
  {
    try
    {
      RestRequest request = buildRequest(uri, method, dataMap, headers, protocolVersion, requestOptions.getContentType(), requestOptions.getAcceptTypes());
      String operation = OperationNameGenerator.generate(method, methodName);
      requestContext.putLocalAttr(R2Constants.OPERATION, operation);
      requestContext.putLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE, requestOptions.getRequestCompressionOverride());
      requestContext.putLocalAttr(R2Constants.RESPONSE_COMPRESSION_OVERRIDE, requestOptions.getResponseCompressionOverride());
      _client.restRequest(request, requestContext, callback);
    }
    catch (Exception e)
    {
      
      callback.onError(e);
    }
  }

  
  
  private RestRequest buildRequest(URI uri,
                                   ResourceMethod method,
                                   DataMap dataMap,
                                   Map<String, String> headers,
                                   ProtocolVersion protocolVersion,
                                   ContentType contentType,
                                   List<AcceptType> acceptTypes) throws Exception
  {
    RestRequestBuilder requestBuilder = new RestRequestBuilder(uri).setMethod(
            method.getHttpMethod().toString());

    requestBuilder.setHeaders(headers);
    addAcceptHeaders(requestBuilder, acceptTypes);
    addEntityAndContentTypeHeaders(requestBuilder, dataMap, contentType);
    addProtocolVersionHeader(requestBuilder, protocolVersion);

    if (method.getHttpMethod() == HttpMethod.POST)
    {
      requestBuilder.setHeader(RestConstants.HEADER_RESTLI_REQUEST_METHOD, method.toString());
    }

    return requestBuilder.build();
  }

  
  private void addProtocolVersionHeader(RestRequestBuilder builder, ProtocolVersion protocolVersion)
  {
    builder.setHeader(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
  }

  public static enum AcceptType
  {
    PSON(RestConstants.HEADER_VALUE_APPLICATION_PSON),
    JSON(RestConstants.HEADER_VALUE_APPLICATION_JSON),
    ANY(RestConstants.HEADER_VALUE_ACCEPT_ANY);

    private String _headerKey;

    private AcceptType(String headerKey)
    {
      _headerKey = headerKey;
    }

    public String getHeaderKey()
    {
      return _headerKey;
    }
  }

  public static enum ContentType
  {
    PSON(RestConstants.HEADER_VALUE_APPLICATION_PSON),
    JSON(RestConstants.HEADER_VALUE_APPLICATION_JSON);

    private String _headerKey;

    private ContentType(String headerKey)
    {
      _headerKey = headerKey;
    }

    public String getHeaderKey()
    {
      return _headerKey;
    }
  }

}

<code block>


package com.linkedin.restli.client;


import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.restli.client.test.TestRecord;
import com.linkedin.restli.common.ComplexResourceKey;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.ResourceProperties;
import com.linkedin.restli.common.ResourceSpec;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.internal.client.EntityResponseDecoder;
import com.linkedin.restli.internal.common.ResourcePropertiesImpl;

import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.testng.Assert;
import org.testng.annotations.Test;


public class TestRequest
{
  @Test
  public void testToSecureString()
  {
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);

    Request<TestRecord> request = builder.id(5L).build();

    Assert.assertEquals(
        request.toSecureString(),
        "com.linkedin.restli.client.GetRequest{_method=get, _baseUriTemplate=abc, _methodName=null, " +
            "_requestOptions={_protocolVersionOption: USE_LATEST_IF_AVAILABLE, _requestCompressionOverride: null, _responseCompressionOverride: null, " +
            "_contentType: null, _acceptTypes: null}}");
  }

  @Test
  public void testHeadersCaseInsensitiveGet()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder.id(id).addHeader("header", "value").build();
    Assert.assertEquals(request.getHeaders().get("HEADER"), "value");
  }

  @Test
  public void testHeadersCaseInsensitiveAdd()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder
        .id(id)
        .addHeader("header", "value1")
        .addHeader("HEADER", "value2")
        .build();
    Assert.assertEquals(request.getHeaders().get("HEADER"), "value1,value2");
  }

  @Test
  public void testHeadersCaseInsensitiveSet()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder
        .id(id)
        .setHeader("header", "value1")
        .setHeader("HEADER", "value2")
        .build();
    Assert.assertEquals(request.getHeaders().get("header"), "value2");
  }

  @Test
  public void testResourceProperties()
  {
    Set<ResourceMethod> expectedSupportedMethods = new HashSet<ResourceMethod>();
    expectedSupportedMethods.add(ResourceMethod.GET);
    expectedSupportedMethods.add(ResourceMethod.BATCH_PARTIAL_UPDATE);

    ResourceSpec expectedResourceSpec = new ResourceSpecImpl(
                                          expectedSupportedMethods,
                                          null,
                                          null,
                                          ComplexResourceKey.class,
                                          TestRecord.class,
                                          TestRecord.class,
                                          TestRecord.class,
                                          Collections.<String, Object>emptyMap());

    Map<String, Object> pathKeys = new HashMap<String, Object>();
    pathKeys.put("id", new ComplexResourceKey<TestRecord, TestRecord>(new TestRecord(), new TestRecord()));


    Request<TestRecord> request = new Request<TestRecord>(ResourceMethod.GET,
                                                          null,
                                                          Collections.<String, String>emptyMap(),
                                                          new EntityResponseDecoder<TestRecord>(TestRecord.class),
                                                          expectedResourceSpec,
                                                          Collections.<String, Object>emptyMap(),
                                                          Collections.<String, Class<?>>emptyMap(),
                                                          null,
                                                          "testRecord",
                                                          pathKeys,
                                                          RestliRequestOptions.DEFAULT_OPTIONS);

    ResourceProperties expectedResourceProperties =
        new ResourcePropertiesImpl(expectedResourceSpec.getSupportedMethods(),
                                   expectedResourceSpec.getKeyType(),
                                   expectedResourceSpec.getComplexKeyType(),
                                   expectedResourceSpec.getValueType(),
                                   expectedResourceSpec.getKeyParts());

    Assert.assertEquals(request.getResourceProperties(), expectedResourceProperties);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.data.DataMap;
import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.common.CollectionRequest;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.ResourceSpec;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.common.TypeSpec;
import com.linkedin.restli.internal.client.RestResponseDecoder;
import com.linkedin.restli.internal.common.ResourcePropertiesImpl;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;




public class TestRestClientRequestBuilder
{

  private static final DataMap ENTITY_BODY = new DataMap();
  private static final String  JSON_ENTITY_BODY = "{\"testFieldName\":\"testValue\",\"testInteger\":1}";
  private static final String  PSON_ENTITY_BODY = "#!PSON1\n!\u0081testFieldName\u0000\n\n\u0000\u0000\u0000testValue\u0000\u0083testInteger\u0000\u0002\u0001\u0000\u0000\u0000\u0080";
  private static final String JSON_ENTITIES_BODY = "{\"entities\":{}}";
  private static final String PSON_ENTITIES_BODY = "#!PSON1\n" + "!\u0081entities\u0000 \u0080";
  private static final String  CONTENT_TYPE_HEADER = "Content-Type";
  private static final String  ACCEPT_TYPE_HEADER = "Accept";
  private static final String HOST = "host";
  private static final String SERVICE_NAME = "foo";
  private static final String BASE_URI_TEMPLATE = "/foo";

  static
  {
    ENTITY_BODY.put("testFieldName", "testValue");
    ENTITY_BODY.put("testInteger", 1);
  }

  @Test(dataProvider = "data")
  public void testGet(RestClient.ContentType contentType,
                      String expectedContentTypeHeader,
                      String expectedRequestBody,
                      String expectedEntitiesBody,
                      List<RestClient.AcceptType> acceptTypes,
                      String expectedAcceptHeader,
                      boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(GetRequest.class, ResourceMethod.GET, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchGetRequest.class, ResourceMethod.BATCH_GET, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestBatch.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestBatch.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

  }

  @Test(dataProvider = "data")
  public void testFinder(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(FindRequest.class, ResourceMethod.FINDER, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestAll = clientGeneratedRequest(GetAllRequest.class, ResourceMethod.GET_ALL, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestAll.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestAll.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testAction(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(ActionRequest.class,
                                                     ResourceMethod.ACTION,
                                                     ENTITY_BODY,
                                                     contentType,
                                                     acceptTypes,
                                                     acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestNoEntity = clientGeneratedRequest(ActionRequest.class, ResourceMethod.ACTION, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestNoEntity.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestNoEntity.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testUpdate(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(UpdateRequest.class, ResourceMethod.UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchUpdateRequest.class, ResourceMethod.BATCH_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatch.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatch.getEntity().asAvroString(), expectedEntitiesBody);
    Assert.assertEquals(restRequestBatch.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestPartial = clientGeneratedRequest(PartialUpdateRequest.class, ResourceMethod.PARTIAL_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestPartial.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestPartial.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequestPartial.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatchPartial = clientGeneratedRequest(BatchPartialUpdateRequest.class, ResourceMethod.BATCH_PARTIAL_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatchPartial.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatchPartial.getEntity().asAvroString(), expectedEntitiesBody);
    Assert.assertEquals(restRequestBatchPartial.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testCreate(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(CreateRequest.class, ResourceMethod.CREATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchCreateRequest.class, ResourceMethod.BATCH_CREATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatch.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatch.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testDelete(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(DeleteRequest.class, ResourceMethod.DELETE, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchDeleteRequest.class, ResourceMethod.BATCH_DELETE, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestBatch.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestBatch.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @DataProvider(name = "data")
  public Object[][] contentTypeData()
  {
    return new Object[][]
      {
        
        
        
        
        
        
        
        
        
        
        
        {
          null,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          null,
          null,
          true
        }, 
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.<RestClient.AcceptType>emptyList(),
          null,
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.<RestClient.AcceptType>emptyList(),
          null,
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.ANY),
          "**",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.JSON),
          "application/json",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.JSON),
          "application/json",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.PSON),
          "application/x-pson",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.PSON),
          "application/x-pson",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON),
          "application/json;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON),
          "application/json;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,**;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.JSON),
          "application/x-pson;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.JSON),
          "application/x-pson;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/x-pson;q=1.0,**;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.JSON),
          "**;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.PSON),
          "**;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,application/x-pson;q=0.9,**",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.ANY),
          "**;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,**;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/x-pson;q=1.0,**;q=1.0,application/json;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.JSON),
          "**;q=1.0,application/x-pson;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.PSON),
          "**;q=0.8",
          false
        }
      };
  }

  @SuppressWarnings("rawtypes")
  private void setCommonExpectations(Request mockRequest,
                                     ResourceMethod method,
                                     RestResponseDecoder mockResponseDecoder,
                                     RestliRequestOptions requestOptions)
  {
    EasyMock.expect(mockRequest.getMethod()).andReturn(method).anyTimes();
    EasyMock.expect(mockRequest.getPathKeys()).andReturn(Collections.<String, String>emptyMap()).once();
    EasyMock.expect(mockRequest.getQueryParamsObjects()).andReturn(Collections.emptyMap()).once();
    EasyMock.expect(mockRequest.getQueryParamClasses()).andReturn(Collections.<String, Class<?>>emptyMap()).once();
    EasyMock.expect(mockRequest.getBaseUriTemplate()).andReturn(BASE_URI_TEMPLATE).times(2);
    EasyMock.expect(mockRequest.getServiceName()).andReturn(SERVICE_NAME).once();
    EasyMock.expect(mockRequest.getResponseDecoder()).andReturn(mockResponseDecoder).once();
    EasyMock.expect(mockRequest.getHeaders()).andReturn(Collections.<String, String>emptyMap()).once();
    EasyMock.expect(mockRequest.getRequestOptions()).andReturn(requestOptions).anyTimes();
  }

  @SuppressWarnings({"rawtypes", "deprecation"})
  private void buildInputForBatchPatchAndUpdate(Request mockRequest)
  {
    CollectionRequest mockCollectionRequest = EasyMock.createMock(CollectionRequest.class);
    EasyMock.expect(mockCollectionRequest.getElements()).andReturn(Collections.emptyList()).once();
    EasyMock.expect(mockRequest.getInputRecord()).andReturn(mockCollectionRequest).times(2);
    EasyMock.replay(mockCollectionRequest);
    ResourceSpec resourceSpec = new ResourceSpecImpl(Collections.<ResourceMethod> emptySet(),
                                                     Collections.<String, DynamicRecordMetadata> emptyMap(),
                                                     Collections.<String, DynamicRecordMetadata> emptyMap(),
                                                     null,
                                                     null,
                                                     null,
                                                     EmptyRecord.class,
                                                     Collections.<String, CompoundKey.TypeInfo> emptyMap());
    EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
        new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                               null,
                               null,
                               TypeSpec.forClassMaybeNull(EmptyRecord.class),
                               Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
  }

  @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
  private <T extends Request> RestRequest clientGeneratedRequest(Class<T> requestClass,
                                                                 ResourceMethod method,
                                                                 DataMap entityBody,
                                                                 RestClient.ContentType contentType,
                                                                 List<RestClient.AcceptType> acceptTypes,
                                                                 boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    
    Client mockClient = EasyMock.createMock(Client.class);

    @SuppressWarnings({"rawtypes"})
    Request<?> mockRequest = EasyMock.createMock(requestClass);
    RecordTemplate mockRecordTemplate = EasyMock.createMock(RecordTemplate.class);
    @SuppressWarnings({"rawtypes"})
    RestResponseDecoder mockResponseDecoder = EasyMock.createMock(RestResponseDecoder.class);

    RestliRequestOptions requestOptions = RestliRequestOptions.DEFAULT_OPTIONS;
    if (!acceptContentTypePerClient)
    {
      requestOptions = new RestliRequestOptions(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE, null, null, contentType, acceptTypes);
    }
    setCommonExpectations(mockRequest, method, mockResponseDecoder, requestOptions);

    if (method == ResourceMethod.BATCH_PARTIAL_UPDATE || method == ResourceMethod.BATCH_UPDATE)
    {
      buildInputForBatchPatchAndUpdate(mockRequest);
    }
    else
    {
      EasyMock.expect(mockRequest.getInputRecord()).andReturn(mockRecordTemplate).times(2);
    }

    if (method == ResourceMethod.GET)
    {
      EasyMock.expect(((GetRequest)mockRequest).getObjectId()).andReturn(null).once();
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.BATCH_GET)
    {
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.ACTION)
    {
      EasyMock.expect(((ActionRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn("testAction");
    }
    else if (method == ResourceMethod.FINDER)
    {
      EasyMock.expect(((FindRequest)mockRequest).getAssocKey()).andReturn(new CompoundKey());
      EasyMock.expect(mockRequest.getMethodName()).andReturn("testFinder");
    }
    else if (method == ResourceMethod.GET_ALL)
    {
      EasyMock.expect(((GetAllRequest)mockRequest).getAssocKey()).andReturn(new CompoundKey());
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.UPDATE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                 null,
                                 null,
                                 null,
                                 Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((UpdateRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.PARTIAL_UPDATE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((PartialUpdateRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.DELETE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((DeleteRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else
    {
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }

    EasyMock.expect(mockRecordTemplate.data()).andReturn(entityBody).once();

    Capture<RestRequest> restRequestCapture = new Capture<RestRequest>();

    EasyMock.expect(mockClient.getMetadata(new URI(HOST + SERVICE_NAME)))
        .andReturn(Collections.<String, Object>emptyMap()).once();

    mockClient.restRequest(EasyMock.capture(restRequestCapture),
                           (RequestContext) EasyMock.anyObject(),
                           (Callback<RestResponse>) EasyMock.anyObject());
    EasyMock.expectLastCall().once();

    EasyMock.replay(mockClient, mockRequest, mockRecordTemplate);

    
    RestClient restClient;
    if (acceptContentTypePerClient)
    {
      
      restClient = new RestClient(mockClient, HOST, contentType, acceptTypes);
    }
    else
    {
      
      restClient = new RestClient(mockClient, HOST);
    }

    restClient.sendRequest(mockRequest);

    return restRequestCapture.getValue();
  }

}

<code block>




package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.ErrorDetails;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.client.EntityResponseDecoder;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class RestClientTest
{
  private static final RequestContext DEFAULT_REQUEST_CONTEXT = new RequestContext();
  static
  {
    DEFAULT_REQUEST_CONTEXT.putLocalAttr("__attr1", "1");
  }

  @Test
  public void testEmptyErrorResponse()
  {
    RestResponse response = new RestResponseBuilder().setStatus(200).build();
    RestLiResponseException e = new RestLiResponseException(response, null, new ErrorResponse());

    Assert.assertNull(e.getServiceErrorMessage());
    Assert.assertNull(e.getErrorDetails());
    Assert.assertNull(e.getErrorSource());
    Assert.assertFalse(e.hasServiceErrorCode());
    Assert.assertNull(e.getServiceErrorStackTrace());
    Assert.assertNull(e.getServiceExceptionClass());
  }

  @Test
  public void testShutdown()
  {
    Client client = EasyMock.createMock(Client.class);

    @SuppressWarnings("unchecked")
    Callback<None> callback = EasyMock.createMock(Callback.class);
    Capture<Callback<None>> callbackCapture = new Capture<Callback<None>>();

    
    client.shutdown(EasyMock.capture(callbackCapture));
    EasyMock.replay(client);

    
    EasyMock.replay(callback);

    RestClient restClient = new RestClient(client, "d2:
    restClient.shutdown(callback);

    EasyMock.verify(client);
    EasyMock.verify(callback);

    EasyMock.reset(callback);

    None none = None.none();
    callback.onSuccess(none);
    EasyMock.replay(callback);

    Callback<None> captured = callbackCapture.getValue();
    captured.onSuccess(none);

    EasyMock.verify(callback);

  }

  private enum SendRequestOption
  {
    REQUEST_NO_CONTEXT(false, false),
    REQUEST_WITH_CONTEXT(false, true),
    REQUESTBUILDER_NO_CONTEXT(true, false),
    REQUESTBUILDER_WITH_CONTEXT(true, true);

    private SendRequestOption(boolean requestBuilder, boolean context)
    {
      _requestBuilder = requestBuilder;
      _context = context;
    }

    private final boolean _requestBuilder;
    private final boolean _context;
  }

  private enum GetResponseOption
  {
    GET,
    GET_RESPONSE,
    GET_RESPONSE_EXPLICIT_NO_THROW,
    GET_RESPONSE_EXPLICIT_THROW,
    GET_RESPONSE_ENTITY,
    GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
    GET_RESPONSE_ENTITY_EXPLICIT_THROW,
  }

  private enum TimeoutOption
  {
    NO_TIMEOUT(null, null),
    THIRTY_SECONDS(30L, TimeUnit.SECONDS);

    private TimeoutOption(Long l, TimeUnit timeUnit)
    {
      _l = l;
      _timeUnit = timeUnit;
    }

    private final Long _l;
    private final TimeUnit _timeUnit;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestOptions")
  private Object[][] sendRequestOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length * TimeoutOption.values().length * 2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (TimeoutOption timeoutOption : TimeoutOption.values())
      {
        result[i++] = new Object[] {
            sendRequestOption,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
      }
    }
    return result;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  private Object[][] sendRequestAndGetResponseOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length *
                                   GetResponseOption.values().length *
                                   TimeoutOption.values().length *
                                   2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (GetResponseOption getResponseOption : GetResponseOption.values() )
      {
        for (TimeoutOption timeoutOption : TimeoutOption.values())
        {
          result[i++] = new Object[] {
              sendRequestOption,
              getResponseOption,
              timeoutOption,
              ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
              AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
              RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
          };
          result[i++] = new Object[] {
              sendRequestOption,
              getResponseOption,
              timeoutOption,
              ProtocolVersionOption.FORCE_USE_NEXT,
              AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
              RestConstants.HEADER_RESTLI_ERROR_RESPONSE
          };
        }
      }
    }
    return result;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndNoThrowGetResponseOptions")
  private Object[][] sendRequestAndNoThrowGetResponseOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length *
                                   2 *
                                   TimeoutOption.values().length *
                                   2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (TimeoutOption timeoutOption : TimeoutOption.values())
      {
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
      }
    }

    return result;
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  public void testRestLiResponseFuture(SendRequestOption sendRequestOption,
                                       GetResponseOption getResponseOption,
                                       TimeoutOption timeoutOption,
                                       ProtocolVersionOption versionOption,
                                       ProtocolVersion protocolVersion,
                                       String errorResponseHeaderName)
    throws ExecutionException, RemoteInvocationException,
           TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 200;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<ErrorResponse> request = mockRequest(ErrorResponse.class, versionOption);
    RequestBuilder<Request<ErrorResponse>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<ErrorResponse> future = sendRequest(sendRequestOption,
                                                       determineErrorHandlingBehavior(getResponseOption),
                                                       client,
                                                       request,
                                                       requestBuilder);
    Response<ErrorResponse> response = getOkResponse(getResponseOption, future, timeoutOption);
    ErrorResponse e = response.getEntity();

    Assert.assertNull(response.getError());
    Assert.assertFalse(response.hasError());
    Assert.assertEquals(HTTP_CODE, response.getStatus());
    Assert.assertEquals(ERR_VALUE, e.getErrorDetails().data().getString(ERR_KEY));
    Assert.assertEquals(APP_CODE, e.getServiceErrorCode().intValue());
    Assert.assertEquals(ERR_MSG, e.getMessage());
    verifyResponseHeader(sendRequestOption, response.getHeaders());
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  public void testRestLiResponseExceptionFuture(SendRequestOption sendRequestOption,
                                                GetResponseOption getResponseOption,
                                                TimeoutOption timeoutOption,
                                                ProtocolVersionOption versionOption,
                                                ProtocolVersion protocolVersion,
                                                String errorResponseHeaderName)
    throws RemoteInvocationException, TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<EmptyRecord> future = sendRequest(sendRequestOption,
                                                     determineErrorHandlingBehavior(getResponseOption),
                                                     client,
                                                     request,
                                                     requestBuilder);
    RestLiResponseException e = getErrorResponse(getResponseOption, future, timeoutOption);

    if (getResponseOption == GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW)
    {
      Assert.assertNull(e);
    }
    else
    {
      Assert.assertEquals(HTTP_CODE, e.getStatus());
      Assert.assertEquals(ERR_VALUE, e.getErrorDetails().get(ERR_KEY));
      Assert.assertEquals(APP_CODE, e.getServiceErrorCode());
      Assert.assertEquals(ERR_MSG, e.getServiceErrorMessage());

      verifyResponseHeader(sendRequestOption, e.getResponse().getHeaders());
    }
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndNoThrowGetResponseOptions")
  public void testRestLiResponseExceptionFutureNoThrow(SendRequestOption sendRequestOption,
                                                       GetResponseOption getResponseOption,
                                                       TimeoutOption timeoutOption,
                                                       ProtocolVersionOption versionOption,
                                                       ProtocolVersion protocolVersion,
                                                       String errorResponseHeaderName)
      throws RemoteInvocationException, ExecutionException, TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<EmptyRecord> future = sendRequest(sendRequestOption,
                                                     determineErrorHandlingBehavior(getResponseOption),
                                                     client,
                                                     request,
                                                     requestBuilder);

    Response<EmptyRecord> response = getOkResponse(getResponseOption, future, timeoutOption);
    Assert.assertTrue(response.hasError());
    RestLiResponseException e = response.getError();

    Assert.assertNotNull(e);
    Assert.assertEquals(HTTP_CODE, e.getStatus());
    Assert.assertEquals(ERR_VALUE, e.getErrorDetails().get(ERR_KEY));
    Assert.assertEquals(APP_CODE, e.getServiceErrorCode());
    Assert.assertEquals(ERR_MSG, e.getServiceErrorMessage());

    verifyResponseHeader(sendRequestOption, response.getHeaders());
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestOptions")
  public void testRestLiResponseExceptionCallback(SendRequestOption option,
                                                  TimeoutOption timeoutOption,
                                                  ProtocolVersionOption versionOption,
                                                  ProtocolVersion protocolVersion,
                                                  String errorResponseHeaderName)
          throws ExecutionException, TimeoutException, InterruptedException, RestLiDecodingException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    FutureCallback<Response<EmptyRecord>> callback = new FutureCallback<Response<EmptyRecord>>();
    try
    {
      sendRequest(option, client, request, requestBuilder, callback);
      Long l = timeoutOption._l;
      TimeUnit timeUnit = timeoutOption._timeUnit;
      Response<EmptyRecord> response = l == null ? callback.get() : callback.get(l, timeUnit);
      Assert.fail("Should have thrown");
    }
    catch (ExecutionException e)
    {
      

      Throwable cause = e.getCause();
      Assert.assertTrue(cause instanceof RestLiResponseException, "Expected RestLiResponseException not " + cause.getClass().getName());
      RestLiResponseException rlre = (RestLiResponseException)cause;
      Assert.assertEquals(HTTP_CODE, rlre.getStatus());
      Assert.assertEquals(ERR_VALUE, rlre.getErrorDetails().get(ERR_KEY));
      Assert.assertEquals(APP_CODE, rlre.getServiceErrorCode());
      Assert.assertEquals(ERR_MSG, rlre.getServiceErrorMessage());
      verifyResponseHeader(option, rlre.getResponse().getHeaders());

      

      Assert.assertTrue(cause instanceof RestException, "Expected RestException not " + cause.getClass().getName());
      RestException re = (RestException)cause;
      RestResponse r = re.getResponse();

      ErrorResponse er = new EntityResponseDecoder<ErrorResponse>(ErrorResponse.class).decodeResponse(r).getEntity();

      Assert.assertEquals(HTTP_CODE, r.getStatus());
      Assert.assertEquals(ERR_VALUE, er.getErrorDetails().data().getString(ERR_KEY));
      Assert.assertEquals(APP_CODE, er.getServiceErrorCode().intValue());
      Assert.assertEquals(ERR_MSG, er.getMessage());
      verifyResponseHeader(option, re.getResponse().getHeaders());
    }
  }

  private ErrorHandlingBehavior determineErrorHandlingBehavior(GetResponseOption getResponseOption)
  {
    switch (getResponseOption)
    {
      case GET:
      case GET_RESPONSE:
      case GET_RESPONSE_ENTITY:
        return null;
      case GET_RESPONSE_EXPLICIT_NO_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
        return ErrorHandlingBehavior.TREAT_SERVER_ERROR_AS_SUCCESS;
      case GET_RESPONSE_EXPLICIT_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        return ErrorHandlingBehavior.FAIL_ON_ERROR;
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> ResponseFuture<T> sendRequest(SendRequestOption option,
                                                                   ErrorHandlingBehavior errorHandlingBehavior,
                                                                   RestClient client,
                                                                   Request<T> request,
                                                                   RequestBuilder<Request<T>> requestBuilder)
  {
    switch (option)
    {
      case REQUEST_NO_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(request);
        }
        else
        {
          return client.sendRequest(request, errorHandlingBehavior);
        }
      case REQUEST_WITH_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(request, DEFAULT_REQUEST_CONTEXT);
        }
        else
        {
          return client.sendRequest(request, DEFAULT_REQUEST_CONTEXT, errorHandlingBehavior);
        }
      case REQUESTBUILDER_NO_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(requestBuilder);
        }
        else
        {
          return client.sendRequest(requestBuilder, errorHandlingBehavior);
        }
      case REQUESTBUILDER_WITH_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT);
        }
        else
        {
          return client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT, errorHandlingBehavior);
        }
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> void sendRequest(SendRequestOption option,
                                                      RestClient client,
                                                      Request<T> request,
                                                      RequestBuilder<Request<T>> requestBuilder,
                                                      Callback<Response<T>> callback)
  {
    switch (option)
    {
      case REQUEST_NO_CONTEXT:
        client.sendRequest(request, callback);
        break;
      case REQUEST_WITH_CONTEXT:
        client.sendRequest(request, DEFAULT_REQUEST_CONTEXT, callback);
        break;
      case REQUESTBUILDER_NO_CONTEXT:
        client.sendRequest(requestBuilder, callback);
        break;
      case REQUESTBUILDER_WITH_CONTEXT:
        client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT, callback);
        break;
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> Response<T> getOkResponse(GetResponseOption option,
                                                               ResponseFuture<T> future,
                                                               TimeoutOption timeoutOption)
    throws ExecutionException, InterruptedException, TimeoutException, RemoteInvocationException
  {
    Response<T> result = null;
    T entity;
    Long l = timeoutOption._l;
    TimeUnit timeUnit = timeoutOption._timeUnit;
    switch (option)
    {
      case GET:
        result = l == null ? future.get() : future.get(l, timeUnit);
        break;
      case GET_RESPONSE:
      case GET_RESPONSE_EXPLICIT_NO_THROW:
      case GET_RESPONSE_EXPLICIT_THROW:
        result = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
        break;
      case GET_RESPONSE_ENTITY:
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
        result = future.getResponse();
        Assert.assertSame(entity, result.getEntity());
        break;
      default:
        throw new IllegalStateException();
    }
    return result;
  }

  private <T extends RecordTemplate> RestLiResponseException getErrorResponse(GetResponseOption option,
                                                                              ResponseFuture<T> future,
                                                                              TimeoutOption timeoutOption)
    throws InterruptedException, TimeoutException, RemoteInvocationException
  {
    Response<T> response = null;
    T entity;
    RestLiResponseException result = null;
    Long l = timeoutOption._l;
    TimeUnit timeUnit = timeoutOption._timeUnit;
    switch (option)
    {
      case GET:
        try
        {
          response = l == null ? future.get() : future.get(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (ExecutionException e)
        {
          Throwable cause = e.getCause();
          Assert.assertTrue(cause instanceof RestException, "Expected RestLiResponseException not " + cause.getClass().getName());
          result = (RestLiResponseException) cause;
        }
        break;
      case GET_RESPONSE:
      case GET_RESPONSE_EXPLICIT_THROW:
        try
        {
          response = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (RestLiResponseException e)
        {
          result = e;
        }
        break;
      case GET_RESPONSE_EXPLICIT_NO_THROW:
        response = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
        result = response.getError();
        break;
      case GET_RESPONSE_ENTITY:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        try
        {
          entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (RestLiResponseException e)
        {
          result = e;
        }
        break;
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
        entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
        break;
      default:
        throw new IllegalStateException();
    }
    return result;
  }

  private void verifyResponseHeader(SendRequestOption option, Map<String, String> headers)
  {
    for (Map.Entry<String, Object> attr : DEFAULT_REQUEST_CONTEXT.getLocalAttrs().entrySet())
    {
      if (attr.getKey().equals(R2Constants.OPERATION) || attr.getKey().equals(R2Constants.REQUEST_COMPRESSION_OVERRIDE)
          || attr.getKey().equals(R2Constants.RESPONSE_COMPRESSION_OVERRIDE))
      {
        continue;
      }
      Assert.assertEquals(headers.get(attr.getKey()), option._context ? attr.getValue().toString() : null);
    }
  }

  private <T extends RecordTemplate> RequestBuilder<Request<T>> mockRequestBuilder(final Request<T> request)
  {
    return new RequestBuilder<Request<T>>()
    {
      @Override
      public Request<T> build()
      {
        return request;
      }
    };
  }

  private <T extends RecordTemplate> Request<T> mockRequest(Class<T> clazz, ProtocolVersionOption versionOption)
  {
    return new GetRequest<T>(Collections.<String, String> emptyMap(),
                             clazz,
                             null,
                             new DataMap(),
                             Collections.<String, Class<?>>emptyMap(),
                             new ResourceSpecImpl(),
                             "/foo",
                             Collections.<String, Object>emptyMap(),
                             new RestliRequestOptionsBuilder().setProtocolVersionOption(versionOption).build());
  }

  private static class MyMockClient extends MockClient
  {
    private RequestContext _requestContext;

    private MyMockClient(int httpCode, Map<String, String> headers, byte[] bytes)
    {
      super(httpCode, headers, bytes);
    }

    @Override
    public void restRequest(RestRequest request, RequestContext requestContext,
                            Callback<RestResponse> callback)
    {
      Assert.assertNotNull(requestContext);
      _requestContext = requestContext;
      super.restRequest(request, requestContext, callback);
    }

    @Override
    protected Map<String, String> headers()
    {
      Map<String, String> headers = new HashMap<String, String>(super.headers());
      for (Map.Entry<String, Object> attr : _requestContext.getLocalAttrs().entrySet())
      {
        if (!attr.getKey().startsWith("__attr"))
        {
          continue;
        }
        headers.put(attr.getKey(), attr.getValue().toString());
      }
      return headers;
    }
  }

  private RestClient mockClient(String errKey, String errValue, String errMsg, int httpCode, int appCode, ProtocolVersion protocolVersion, String errorResponseHeaderName)
  {
    ErrorResponse er = new ErrorResponse();

    DataMap errMap = new DataMap();
    errMap.put(errKey, errValue);
    er.setErrorDetails(new ErrorDetails(errMap));
    er.setStatus(httpCode);
    er.setMessage(errMsg);
    er.setServiceErrorCode(appCode);

    byte[] mapBytes;
    try
    {
      mapBytes = new JacksonDataCodec().mapToBytes(er.data());
    }
    catch (IOException e)
    {
      throw new RuntimeException(e);
    }

    Map<String,String> headers = new HashMap<String,String>();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
    headers.put(errorResponseHeaderName, RestConstants.HEADER_VALUE_ERROR);

    return new RestClient(new MyMockClient(httpCode, headers, mapBytes), "http:
  }
}

<code block>


package com.linkedin.r2.filter;



public class R2Constants
{
  public static final String OPERATION = "OPERATION";
  public static final String REMOTE_ADDR = "REMOTE_ADDR";
  public static final String IS_SECURE = "IS_SECURE";
  public static final String CLIENT_CERT = "CLIENT_CERT";
  public static final String REQUEST_COMPRESSION_OVERRIDE = "REQUEST_COMPRESSION_OVERRIDE";
  public static final String RESPONSE_COMPRESSION_OVERRIDE = "RESPONSE_COMPRESSION_OVERRIDE";
  public static final String IS_QUERY_TUNNELED = "IS_QUERY_TUNNELED";
  public static final String FORCE_QUERY_TUNNEL = "FORCE_QUERY_TUNNEL";
  public static final String RESPONSE_DECOMPRESSION_OFF = "RESPONSE_DECOMPRESSION_OFF";
}

<code block>


package com.linkedin.r2.filter;


import com.linkedin.r2.message.RequestContext;


public enum CompressionOption
{
  
  FORCE_ON,

  
  FORCE_OFF
}
<code block>
package com.linkedin.r2.transport.http.common;

public interface HttpConstants
{
  public static final String ACCEPT_ENCODING = "Accept-Encoding";
  public static final String CONTENT_ENCODING = "Content-Encoding";
  public static final String CONTENT_LENGTH = "Content-Length";
  public static final String TRANSFER_ENCODING = "Transfer-Encoding";
  
  public static final String HEADER_RESPONSE_COMPRESSION_THRESHOLD = "X-Response-Compression-Threshold";

  
  public static final String REQUEST_COOKIE_HEADER_NAME = "Cookie";

  
  public static final String RESPONSE_COOKIE_HEADER_NAME = "Set-Cookie";

  public static final int OK = 200;
  public static final int NOT_ACCEPTABLE = 406;
  public static final int UNSUPPORTED_MEDIA_TYPE = 415;
  public static final int INTERNAL_SERVER_ERROR = 500;
}
<code block>


package com.linkedin.restli.examples;


import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;
import com.linkedin.r2.transport.http.client.AbstractJmxManager;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.common.HttpConstants;
import com.linkedin.r2.util.NamedThreadFactory;
import com.linkedin.restli.client.BatchGetRequestBuilder;
import com.linkedin.restli.client.ProtocolVersionOption;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.client.RestliRequestOptions;
import com.linkedin.restli.client.RestliRequestOptionsBuilder;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.client.GreetingsBuilders;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.server.filter.FilterRequestContext;
import com.linkedin.restli.server.filter.RequestFilter;
import io.netty.channel.nio.NioEventLoopGroup;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;


public class TestResponseCompression extends RestLiIntegrationTest
{
  
  private static final String EXPECTED_ACCEPT_ENCODING = "Expected-Accept-Encoding";
  private static final String SHOULD_BE_PRESENT = "Should-Be-Present";
  private static final String SHOULD_NOT_BE_PRESENT = "Should-Not-Be-Present";
  private static final String EXPECTED_COMPRESSION_THRESHOLD = "Expected-Response-Compression-Threshold";
  private static final String SERVICE_NAME = "service1";

  @BeforeClass
  public void initClass() throws Exception
  {
    class TestHelperFilter implements RequestFilter
    {
      @Override
      public void onRequest(FilterRequestContext requestContext)
      {
        Map<String, String> requestHeaders = requestContext.getRequestHeaders();
        if (requestHeaders.get(EXPECTED_ACCEPT_ENCODING) == SHOULD_BE_PRESENT)
        {
          if (!requestHeaders.containsKey(HttpConstants.ACCEPT_ENCODING))
          {
            throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Accept-Encoding header should be present.");
          }
        }
        else if (requestHeaders.get(EXPECTED_ACCEPT_ENCODING) == SHOULD_NOT_BE_PRESENT)
        {
          if (requestHeaders.containsKey(HttpConstants.ACCEPT_ENCODING))
          {
            throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Accept-Encoding header should not be present.");
          }
        }
        if (requestHeaders.containsKey(EXPECTED_COMPRESSION_THRESHOLD))
        {
          if (!requestHeaders.get(EXPECTED_COMPRESSION_THRESHOLD).equals(requestHeaders.get(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD)))
          {
            throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Expected Response-Compression-Threshold " + requestHeaders.get(EXPECTED_COMPRESSION_THRESHOLD)
                + ", but received " + requestHeaders.get(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD));
          }
        }
      }
    }
    
    final FilterChain fc = FilterChains.empty().addLast(new TestCompressionServer.SaveContentEncodingHeaderFilter())
        .addLast(new ServerCompressionFilter("snappy,gzip", new CompressionConfig(10000)))
        .addLast(new SimpleLoggingFilter());
    super.init(Arrays.asList(new TestHelperFilter()), null, fc, false);
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  @DataProvider(name = "requestData")
  private Object[][] requestData()
  {
    Integer zero = 0;
    Integer tiny = 100;
    Integer huge = 1000000;
    Integer max = Integer.MAX_VALUE;

    int largeIdCount = 100;
    int smallIdCount = 1;

    RestliRequestOptions forceOnOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setResponseCompressionOverride(CompressionOption.FORCE_ON).build();
    RestliRequestOptions forceOffOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setResponseCompressionOverride(CompressionOption.FORCE_OFF).build();

    return new Object[][] {
        
        {true, null, RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_BE_PRESENT, null, true},
        {true, null, RestliRequestOptions.DEFAULT_OPTIONS, smallIdCount, SHOULD_BE_PRESENT, null, false},

        
        {true, new CompressionConfig(tiny), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_BE_PRESENT, tiny.toString(), true},
        {true, new CompressionConfig(tiny), RestliRequestOptions.DEFAULT_OPTIONS, smallIdCount, SHOULD_BE_PRESENT, tiny.toString(), true},

        
        {true, new CompressionConfig(huge), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_BE_PRESENT, huge.toString(), false},
        {true, new CompressionConfig(huge), RestliRequestOptions.DEFAULT_OPTIONS, smallIdCount, SHOULD_BE_PRESENT, huge.toString(), false},

        
        {true, null, forceOnOption, largeIdCount, SHOULD_BE_PRESENT, zero.toString(), true},
        {true, null, forceOnOption, smallIdCount, SHOULD_BE_PRESENT, zero.toString(), true},
        {true, new CompressionConfig(huge), forceOnOption, smallIdCount, SHOULD_BE_PRESENT, zero.toString(), true},
        {true, null, forceOffOption, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {true, null, forceOffOption, smallIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {true, new CompressionConfig(huge), forceOffOption, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},

        
        {true, new CompressionConfig(0), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_BE_PRESENT, zero.toString(), true},
        {true, new CompressionConfig(0), RestliRequestOptions.DEFAULT_OPTIONS, smallIdCount, SHOULD_BE_PRESENT, zero.toString(), true},
        {true, new CompressionConfig(Integer.MAX_VALUE), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_BE_PRESENT, max.toString(), false},
        {true, new CompressionConfig(Integer.MAX_VALUE), RestliRequestOptions.DEFAULT_OPTIONS, smallIdCount, SHOULD_BE_PRESENT, max.toString(), false},

        
        {true, new CompressionConfig(0), forceOffOption, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {true, new CompressionConfig(Integer.MAX_VALUE), forceOnOption, smallIdCount, SHOULD_BE_PRESENT, zero.toString(), true},

        
        {false, null, RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {false, new CompressionConfig(tiny), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {false, null, forceOnOption, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {null, new CompressionConfig(0), RestliRequestOptions.DEFAULT_OPTIONS, largeIdCount, SHOULD_NOT_BE_PRESENT, null, false},
        {null, new CompressionConfig(Integer.MAX_VALUE), forceOnOption, smallIdCount, SHOULD_NOT_BE_PRESENT, null, false}
    };
  }

  @Test(dataProvider = "requestData")
  public void testResponseCompression(Boolean useResponseCompression, CompressionConfig responseCompressionConfig,
                                      RestliRequestOptions restliRequestOptions, int idCount, String expectedAcceptEncoding,
                                      String expectedCompressionThreshold, boolean responseShouldBeCompressed)
      throws RemoteInvocationException, CloneNotSupportedException
  {
    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler"));
    Map<String, CompressionConfig> responseCompressionConfigs = new HashMap<String, CompressionConfig>();
    if (responseCompressionConfig != null)
    {
      responseCompressionConfigs.put(SERVICE_NAME, responseCompressionConfig);
    }
    HttpClientFactory httpClientFactory = new HttpClientFactory(FilterChains.empty(),
                                                                new NioEventLoopGroup(0 , new NamedThreadFactory("R2 Nio Event Loop")),
                                                                true,
                                                                executor,
                                                                true,
                                                                executor,
                                                                false,
                                                                AbstractJmxManager.NULL_JMX_MANAGER,
                                                                Integer.MAX_VALUE,
                                                                Collections.<String, CompressionConfig>emptyMap(),
                                                                responseCompressionConfigs,
                                                                true);
    Map<String, Object> properties = new HashMap<String, Object>();
    properties.put(HttpClientFactory.HTTP_SERVICE_NAME, SERVICE_NAME);
    if (useResponseCompression != null)
    {
      properties.put(HttpClientFactory.HTTP_USE_RESPONSE_COMPRESSION, String.valueOf(useResponseCompression));
    }
    TransportClientAdapter clientAdapter1 = new TransportClientAdapter(httpClientFactory.getClient(properties));
    RestClient client = new RestClient(clientAdapter1, FILTERS_URI_PREFIX);
    Long[] ids = new Long[idCount];
    for (int i = 0; i < ids.length; i++)
    {
      ids[i] = (long) i;
    }
    BatchGetRequestBuilder<Long, Greeting> builder = new GreetingsBuilders(restliRequestOptions).batchGet().ids(Arrays.asList(ids))
        .setHeader(EXPECTED_ACCEPT_ENCODING, expectedAcceptEncoding);
    if (expectedCompressionThreshold != null)
    {
      builder.setHeader(EXPECTED_COMPRESSION_THRESHOLD, expectedCompressionThreshold);
    }
    Request<BatchResponse<Greeting>> request = builder.build();
    Response<BatchResponse<Greeting>> response = client.sendRequest(request).getResponse();

    if (responseShouldBeCompressed)
    {
      Assert.assertEquals(response.getHeader(TestCompressionServer.CONTENT_ENCODING_SAVED), EncodingType.GZIP.getHttpName());
    }
    else
    {
      Assert.assertNull(response.getHeader(TestCompressionServer.CONTENT_ENCODING_SAVED));
    }
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.filter.message.rest.RestRequestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;
import com.linkedin.r2.transport.http.client.AbstractJmxManager;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.common.HttpConstants;
import com.linkedin.r2.util.NamedThreadFactory;
import com.linkedin.restli.client.ProtocolVersionOption;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.client.RestliRequestOptions;
import com.linkedin.restli.client.RestliRequestOptionsBuilder;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import io.netty.channel.nio.NioEventLoopGroup;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;


public class TestRequestCompression extends RestLiIntegrationTest
{
  
  private static final String TEST_HELP_HEADER = "Test-Help-Header";
  private static final String EXPECT_COMPRESSION = "Expect-Compression";
  private static final String EXPECT_NO_COMPRESSION = "Expect-No-Compression";
  private static final String SERVICE_NAME = "service1";

  @BeforeClass
  public void initClass() throws Exception
  {
    class CheckRequestCompressionFilter implements RestRequestFilter
    {
      @Override
      public void onRestRequest(RestRequest req,
                         RequestContext requestContext,
                         Map<String, String> wireAttrs,
                         NextFilter<RestRequest, RestResponse> nextFilter)
      {
        Map<String, String> requestHeaders = req.getHeaders();
        if (requestHeaders.containsKey(TEST_HELP_HEADER))
        {
          String contentEncodingHeader = requestHeaders.get(HttpConstants.CONTENT_ENCODING);
          if (requestHeaders.get(TEST_HELP_HEADER).equals(EXPECT_COMPRESSION))
          {
            if (contentEncodingHeader == null)
            {
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Request is not compressed when it should be.");
            }
            else if (!contentEncodingHeader.equals("snappy"))
            {
              
              
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST,
                  "Request is compressed with " + contentEncodingHeader + " instead of snappy.");
            }
          }
          else
          {
            if (contentEncodingHeader != null)
            {
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Request is compressed when it shouldn't be.");
            }
          }
        }
        nextFilter.onRequest(req, requestContext, wireAttrs);
      }
    }

    
    class CheckHeadersFilter implements RestRequestFilter
    {
      @Override
      public void onRestRequest(RestRequest req,
                                RequestContext requestContext,
                                Map<String, String> wireAttrs,
                                NextFilter<RestRequest, RestResponse> nextFilter)
      {
        if (req.getHeaders().containsKey(HttpConstants.CONTENT_ENCODING))
        {
          throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, "Content-Encoding header not removed.");
        }
        if (req.getEntity().length() != Integer.parseInt(req.getHeader(HttpConstants.CONTENT_LENGTH)))
        {
          throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, "Content-Length header incorrect.");
        }
        nextFilter.onRequest(req, requestContext, wireAttrs);
      }
    }

    final FilterChain fc = FilterChains.empty().addLast(new CheckRequestCompressionFilter())
        .addLast(new ServerCompressionFilter(RestLiIntTestServer.supportedCompression))
        .addLast(new CheckHeadersFilter())
        .addLast(new SimpleLoggingFilter());
    super.init(null, null, fc, false);
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  @DataProvider(name = "requestData")
  private Object[][] requestData()
  {
    int tiny = 10;
    int small = 100;
    int large = 1000;
    int huge = 10000;

    CompressionConfig tinyThresholdConfig = new CompressionConfig(tiny);
    CompressionConfig hugeThresholdConfig = new CompressionConfig(huge);

    String encodings = "unsupportedEncoding, snappy, gzip";

    RestliRequestOptions forceOnOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setRequestCompressionOverride(CompressionOption.FORCE_ON).build();
    RestliRequestOptions forceOffOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setRequestCompressionOverride(CompressionOption.FORCE_OFF).build();

    return new Object[][] {
        
        {null, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {null, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {tinyThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {tinyThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_COMPRESSION},

        
        {hugeThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {hugeThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {null, encodings, forceOnOption, large, EXPECT_COMPRESSION},
        {null, encodings, forceOnOption, small, EXPECT_COMPRESSION},
        {hugeThresholdConfig, encodings, forceOnOption, small, EXPECT_COMPRESSION},
        {null, encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},
        {null, encodings, forceOffOption, small, EXPECT_NO_COMPRESSION},
        {tinyThresholdConfig, encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},

        
        {new CompressionConfig(0), encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {new CompressionConfig(0), encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {new CompressionConfig(0), encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, forceOnOption, small, EXPECT_COMPRESSION},

        
        {null, "unsupportedEncoding", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {null, "", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(0), "unsupportedEncoding", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {null, "", forceOnOption, large, EXPECT_NO_COMPRESSION}
    };
  }

  @Test(dataProvider = "requestData")
  public void testUpdate(CompressionConfig requestCompressionConfig,
                         String supportedEncodings,
                         RestliRequestOptions restliRequestOptions,
                         int messageLength,
                         String testHelpHeader)
    throws RemoteInvocationException, CloneNotSupportedException, InterruptedException, ExecutionException,
           TimeoutException
  {
    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler"));
    Map<String, CompressionConfig> requestCompressionConfigs = new HashMap<String, CompressionConfig>();
    if (requestCompressionConfig != null)
    {
      requestCompressionConfigs.put(SERVICE_NAME, requestCompressionConfig);
    }
    HttpClientFactory httpClientFactory = new HttpClientFactory(FilterChains.empty(),
        new NioEventLoopGroup(),
        true,
        executor,
        true,
        null,
        false,
        AbstractJmxManager.NULL_JMX_MANAGER,
        500, 
        requestCompressionConfigs);
    Map<String, String> properties = new HashMap<String, String>();

    properties.put(HttpClientFactory.HTTP_REQUEST_CONTENT_ENCODINGS, supportedEncodings);
    properties.put(HttpClientFactory.HTTP_SERVICE_NAME, SERVICE_NAME);
    TransportClientAdapter clientAdapter1 = new TransportClientAdapter(httpClientFactory.getClient(properties));
    RestClient client = new RestClient(clientAdapter1, FILTERS_URI_PREFIX);
    RootBuilderWrapper<Long, Greeting> builders = new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(restliRequestOptions));

    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();
    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    char[] As = new char[messageLength];
    Arrays.fill(As, 'A');
    String message = new String(As);
    greeting.setMessage(message);

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).setHeader(TEST_HELP_HEADER, testHelpHeader).build();
    client.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, message);

    FutureCallback<None> callback1 = new FutureCallback<None>();
    client.shutdown(callback1);
    callback1.get(30, TimeUnit.SECONDS);

    FutureCallback<None> callback2 = new FutureCallback<None>();
    httpClientFactory.shutdown(callback2);
    callback2.get(30, TimeUnit.SECONDS);
  }
}

<code block>




package com.linkedin.restli.examples;

import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.parseq.Engine;
import com.linkedin.parseq.EngineBuilder;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.server.HttpServer;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;




public class RestLiIntegrationTest
{
  protected static final String URI_PREFIX = "http:
  protected static final String NO_COMPRESSION_PREFIX = "http:
  protected static final String FILTERS_URI_PREFIX = "http:

  private final int numCores = Runtime.getRuntime().availableProcessors();

  private ScheduledExecutorService _scheduler;
  private Engine                   _engine;
  private HttpServer               _server;
  private HttpServer               _serverWithoutCompression;
  private HttpServer               _serverWithFilters;

  private HttpClientFactory        _clientFactory;
  private List<Client>             _transportClients;
  private RestClient               _restClient;

  
  public void init() throws Exception
  {
    init(false);
  }

  public void init(boolean async) throws IOException
  {
    initSchedulerAndEngine();
    int asyncTimeout = async ? 5000 : -1;
    _server =
        RestLiIntTestServer.createServer(_engine,
                                         RestLiIntTestServer.DEFAULT_PORT,
                                         RestLiIntTestServer.supportedCompression,
                                         async,
                                         asyncTimeout);
    _server.start();
    initClient(URI_PREFIX);
  }

  public void init(List<? extends RequestFilter> requestFilters, List<? extends ResponseFilter> responseFilters) throws IOException
  {
    final FilterChain fc = FilterChains.empty().addLast(new ServerCompressionFilter(RestLiIntTestServer.supportedCompression, new CompressionConfig(0)))
        .addLast(new SimpleLoggingFilter());
    init(requestFilters, responseFilters, fc, false);
  }

  public void init(List<? extends RequestFilter> requestFilters, List<? extends ResponseFilter> responseFilters,
                   final FilterChain filterChain, boolean includeNoCompression) throws IOException
  {
    initSchedulerAndEngine();
    _serverWithFilters =
        RestLiIntTestServer.createServer(_engine,
                                         RestLiIntTestServer.FILTERS_PORT,
                                         false,
                                         -1,
                                         requestFilters,
                                         responseFilters,
                                         filterChain);
    _serverWithFilters.start();
    
    if (includeNoCompression)
    {
      _serverWithoutCompression =
          RestLiIntTestServer.createServer(_engine,
                                           RestLiIntTestServer.NO_COMPRESSION_PORT,
                                           "");
      _serverWithoutCompression.start();
    }
    initClient(FILTERS_URI_PREFIX);
  }

  private void initSchedulerAndEngine()
  {
    _scheduler = Executors.newScheduledThreadPool(numCores + 1);
    _engine = new EngineBuilder().setTaskExecutor(_scheduler).setTimerScheduler(_scheduler).build();
  }

  private void initClient(String uriPrefix)
  {
    _clientFactory = new HttpClientFactory();
    _transportClients = new ArrayList<Client>();
    Client client = newTransportClient(Collections.<String, String>emptyMap());
    _restClient = new RestClient(client, uriPrefix);
  }

  public void shutdown() throws Exception
  {
    if (_server != null)
    {
      _server.stop();
    }
    if (_serverWithoutCompression != null)
    {
      _serverWithoutCompression.stop();
    }
    if (_serverWithFilters != null)
    {
      _serverWithFilters.stop();
    }
    if (_engine != null)
    {
      _engine.shutdown();
    }
    if (_scheduler != null)
    {
      _scheduler.shutdownNow();
    }
    for (Client client : _transportClients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      client.shutdown(callback);
      callback.get();
    }
    if (_clientFactory != null)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      _clientFactory.shutdown(callback);
      callback.get();
    }
  }

  protected RestClient getClient()
  {
    return _restClient;
  }

  
  protected Client getDefaultTransportClient()
  {
    if (_transportClients.size() > 0)
    {
      return _transportClients.get(0);
    }
    else
    {
      return null;
    }
  }

  
  protected Client newTransportClient(Map<String, ? extends Object> properties)
  {
    Client client = new TransportClientAdapter(_clientFactory.getClient(properties));
    _transportClients.add(client);
    return client;
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.compression.Bzip2Compressor;
import com.linkedin.r2.filter.compression.CompressionException;
import com.linkedin.r2.filter.compression.Compressor;
import com.linkedin.r2.filter.compression.DeflateCompressor;
import com.linkedin.r2.filter.compression.GzipCompressor;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.compression.SnappyCompressor;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.filter.message.rest.RestResponseFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.common.HttpConstants;
import com.linkedin.r2.util.RequestContextUtil;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.RestliRequestOptions;
import com.linkedin.restli.client.response.BatchKVResponse;
import com.linkedin.restli.client.util.PatchGenerator;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.CreateStatus;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.Link;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.SearchMetadata;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.GreetingsBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.examples.greetings.server.CompressionResource;
import com.linkedin.restli.examples.groups.api.TransferOwnershipRequest;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.testutils.URIDetails;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCompressionServer extends RestLiIntegrationTest
{
  private static final String URI_PREFIX = RestLiIntegrationTest.FILTERS_URI_PREFIX;
  private static final String URI_PREFIX_WITHOUT_COMPRESSION = RestLiIntegrationTest.NO_COMPRESSION_PREFIX; 
  public static final String CONTENT_ENCODING_SAVED = "Content-Encoding-Saved";
  
  
  public static class SaveContentEncodingHeaderFilter implements RestResponseFilter
  {
    @Override
    public void onRestResponse(RestResponse res,
                               RequestContext requestContext,
                               Map<String, String> wireAttrs,
                               NextFilter<RestRequest, RestResponse> nextFilter)
    {
      String contentEncoding = res.getHeader(HttpConstants.CONTENT_ENCODING);
      if (contentEncoding != null)
      {
        res = res.builder().addHeaderValue(CONTENT_ENCODING_SAVED, contentEncoding).build();
      }
      nextFilter.onResponse(res, requestContext, wireAttrs);
    }

    @Override
    public void onRestError(Throwable ex,
                            RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            NextFilter<RestRequest, RestResponse> nextFilter)
    {
      nextFilter.onError(ex, requestContext, wireAttrs);
    }
  }

  @DataProvider
  public Object[][] compressorDataProvider()
  {
    return new Object[][]
      {
        { new SnappyCompressor() },
        { new Bzip2Compressor() },
        { new GzipCompressor() },
        { new DeflateCompressor()}
      };
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public Object[][] clientsCompressedResponsesBatchDataProvider()
  {
    
    String[] compressionOperations = {"*",
                                      "action:*",
                                      "finder:*",
                                      "finder:search",
                                      "get, batch_get, get_all",
                                      "get, batch_get, get_all, batch_create, batch_update, batch_partial_update"};
    int entries = compressionOperations.length;
    Object[][] result = new Object[entries * 4][];

    int index = entries * 4 - 1;
    for (String operation: compressionOperations)
    {
      Map<String, String> clientProperties = new HashMap<String, String>();
      clientProperties.put(HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS, operation);
      RestClient client = new RestClient(newTransportClient(clientProperties), URI_PREFIX);
      result[index--] = new Object[]{ client, operation, RestliRequestOptions.DEFAULT_OPTIONS, Arrays.asList(1000L, 2000L), 0 };
      result[index--] = new Object[]{ client, operation, TestConstants.FORCE_USE_NEXT_OPTIONS, Arrays.asList(1000L, 2000L), 0 };
      result[index--] = new Object[]{ client, operation, RestliRequestOptions.DEFAULT_OPTIONS, Arrays.asList(1L, 2L, 3L, 4L), 4 };
      result[index--] = new Object[]{ client, operation, TestConstants.FORCE_USE_NEXT_OPTIONS, Arrays.asList(1L, 2L, 3L, 4L), 4 };
    }

    return result;
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public Object[][] clientsCompressedResponsesBuilderDataProvider()
  {
    
    String[] compressionOperations = {"*",
                                      "action:*",
                                      "finder:*",
                                      "finder:search",
                                      "get, batch_get, get_all",
                                      "get, batch_get, get_all, batch_create, batch_update, batch_partial_update"};
    int entries = compressionOperations.length;
    Object[][] result = new Object[entries * 4][];

    int index = entries * 4 - 1;
    for (String operation: compressionOperations)
    {
      Map<String, String> clientProperties = new HashMap<String, String>();
      clientProperties.put(HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS, operation);
      RestClient client = new RestClient(newTransportClient(clientProperties), URI_PREFIX);
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders()),
          AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)),
          AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders()),
          AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)),
          AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()};
    }

    return result;
  }
  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public Object[][] clientsCookbookDataProvider()
  {
    return new Object[][]
      {
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), RestliRequestOptions.DEFAULT_OPTIONS },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), TestConstants.FORCE_USE_NEXT_OPTIONS },
      };
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public Object[][] clientsNoCompressedResponsesDataProvider()
  {
    return new Object[][]
      {
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders()) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders()) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)) }
      };
  }

  @DataProvider
  
  public Object[][] contentNegotiationDataProvider()
  {
    return new Object[][]
        {
        
        {"gzip", "gzip"},
        {"deflate", "deflate"},
        {"snappy", "snappy"},
        {"bzip2", "bzip2"},
        {"deflate, nonexistentcompression", "deflate"},
        {"blablabla, dEflate", "deflate"},

        
        {"gzip, deflate;q=0.5", "gzip"},
        {"deflate;q=0.5, gzip", "gzip"},
        {"gzip,trololol, deflate;q=0.5", "gzip"},
        {"trololo, gzip;q=0.5, deflate;q=1.0", "deflate"},
        {"*,gzip;q=0.5,identity;q=0","gzip"},

        {"  tRoLolo  ,  gZiP ;  q=0.5,  DeflAte ;  q=1.0  ", "deflate"}, 

        
        {"", null}, 
        {"*;q=0.5, gzip;q=1.0", "gzip"},
        {"*,gzip;q=0, snappy;q=0, bzip2;q=0 ", null},
        {"gzip;q=0, snappy;q=0, bzip2;q=0, deflate; q=0, *", null}
        };
  }

  
  @DataProvider
  public Object[][] error406DataProvider()
  {
    return new Object[][]
        {
        {"identity;q=0"},
        {"*;q=0.5, identity;q=0"},
        {"*;q=0, identity;q=0.0"},
        {"*;q=0"}
        };
  }

  @BeforeClass
  public void initClass() throws Exception
  {
    super.init(Collections.<RequestFilter>emptyList(),
               Collections.<ResponseFilter>emptyList(),
               FilterChains.empty().addLast(new SaveContentEncodingHeaderFilter())
                   .addLast(new ServerCompressionFilter(RestLiIntTestServer.supportedCompression, new CompressionConfig(0)))
                   .addLast(new SimpleLoggingFilter()),
               true);
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  public static void addCompressionHeaders(HttpGet getMessage, String acceptEncoding)
  {
    getMessage.addHeader(HttpConstants.ACCEPT_ENCODING, acceptEncoding);
    getMessage.addHeader(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD, "0");
  }

  @Test(dataProvider = "contentNegotiationDataProvider")
  
  public void testCompatibleDefault(String acceptEncoding, String contentEncoding) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX_WITHOUT_COMPRESSION + path + CompressionResource.getRedundantQueryExample());
    addCompressionHeaders(get, acceptEncoding);

    HttpResponse response = client.execute(get);

    Assert.assertNull(response.getFirstHeader(CONTENT_ENCODING_SAVED));
  }

  
  @Test(dataProvider = "compressorDataProvider")
  public void testCompressionBetter(Compressor compressor) throws RemoteInvocationException, HttpException, IOException, CompressionException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    
    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    HttpResponse response = client.execute(get);
    byte[] original = EntityUtils.toString(response.getEntity()).getBytes();

    get.releaseConnection();
    
    Assert.assertTrue(response.getFirstHeader(CONTENT_ENCODING_SAVED) == null);

    addCompressionHeaders(get, compressor.getContentEncodingName());
    response = client.execute(get);

    byte[] compressed = compressor.inflate(response.getEntity().getContent());
    Assert.assertEquals(compressor.getContentEncodingName(), response.getFirstHeader(CONTENT_ENCODING_SAVED).getValue());

    Assert.assertEquals(original, compressed);
    Assert.assertTrue(response.getEntity().getContentLength() < original.length);
  }

  
  @Test(dataProvider = "compressorDataProvider")
  public void testCompressionWorse(Compressor compressor) throws RemoteInvocationException, HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    
    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getNoRedundantQueryExample());
    HttpResponse response = client.execute(get);
    String original = EntityUtils.toString(response.getEntity());

    
    Assert.assertTrue(response.getFirstHeader(CONTENT_ENCODING_SAVED) == null);

    addCompressionHeaders(get, compressor.getContentEncodingName());
    response = client.execute(get);
    String compressed = EntityUtils.toString(response.getEntity());

    Assert.assertEquals(null, response.getFirstHeader(CONTENT_ENCODING_SAVED));

    
    Assert.assertEquals(original, compressed);
  }

  
  @Test(dataProvider = "contentNegotiationDataProvider")
  public void testAcceptEncoding(String acceptedEncoding, String contentEncoding) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    addCompressionHeaders(get, acceptedEncoding);

    HttpResponse response = client.execute(get);

    if(contentEncoding == null)
    {
      Assert.assertNull(response.getFirstHeader(CONTENT_ENCODING_SAVED));
    }
    else
    {
      Assert.assertEquals(contentEncoding, response.getFirstHeader(CONTENT_ENCODING_SAVED).getValue());
    }
  }

  @Test(dataProvider = "error406DataProvider")
  public void test406Error(String acceptContent) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    addCompressionHeaders(get, acceptContent);

    HttpResponse response = client.execute(get);

    Assert.assertEquals(response.getStatusLine().getStatusCode(), HttpConstants.NOT_ACCEPTABLE);
    Assert.assertEquals(response.getEntity().getContentLength(), 0);
  }

  private <T> void checkContentEncodingHeaderIsAbsent(Response<T> response)
  {
    Assert.assertFalse(response.getHeaders().containsKey(CONTENT_ENCODING_SAVED));
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testIntAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Integer> request = builders.<Integer>action("Purge").build();
    ResponseFuture<Integer> responseFuture = client.sendRequest(request);

    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    Assert.assertEquals(responseFuture.getResponse().getEntity().intValue(), 100);
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testRecordAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.<Greeting>action("SomeAction")
        .id(1L)
        .setActionParam("A", 1)
        .setActionParam("B", "")
        .setActionParam("C", new TransferOwnershipRequest())
        .setActionParam("D", new TransferOwnershipRequest())
        .setActionParam("E", 3)
        .build();
    ResponseFuture<Greeting> responseFuture = client.sendRequest(request);
    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    Assert.assertNotNull(responseFuture.getResponse().getEntity());
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testUpdateToneAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.<Greeting>action("UpdateTone")
        .id(1L)
        .setActionParam("NewTone", Tone.SINCERE)
        .setActionParam("DelOld", false)
        .build();
    ResponseFuture<Greeting> responseFuture = client.sendRequest(request);
    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    final Greeting newGreeting = responseFuture.getResponse().getEntity();
    Assert.assertNotNull(newGreeting);
    Assert.assertEquals(newGreeting.getId().longValue(), 1L);
    Assert.assertEquals(newGreeting.getTone(), Tone.SINCERE);
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testUpdate(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);
    checkContentEncodingHeaderIsAbsent(future.getResponse());

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    greeting.setMessage(response1 + "Again");

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, response1 + "Again");
    checkContentEncodingHeaderIsAbsent(future2.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testGet(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);
    checkContentEncodingHeaderIsAbsent(greetingResponse);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testPartialUpdate(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    Greeting original = greetingResponse.getEntity();
    checkContentEncodingHeaderIsAbsent(greetingResponse);

    
    Greeting greeting = new Greeting(original.data().copy());
    greeting.setMessage(original.getMessage() + " Again");

    PatchRequest<Greeting> patch = PatchGenerator.diff(original, greeting);

    Request<EmptyRecord> writeRequest = builders.partialUpdate().id(1L).input(patch).build();
    int status = client.sendRequest(writeRequest).getResponse().getStatus();
    Assert.assertEquals(status, HttpStatus.S_204_NO_CONTENT.getCode());

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, greeting.getMessage());
    checkContentEncodingHeaderIsAbsent(future2.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testCookbook(RestClient restClient, RootBuilderWrapper<Long, Greeting> builders) throws Exception
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = restClient.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    Assert.assertNotNull(greetingResponse.getEntity().getMessage());
    checkContentEncodingHeaderIsAbsent(greetingResponse);

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    final String NEW_MESSAGE = "This is a new message!";
    greeting.setMessage(NEW_MESSAGE);

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).build();
    restClient.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = restClient.sendRequest(request2);
    greetingResponse = future2.get();

    Assert.assertEquals(greetingResponse.getEntity().getMessage(), NEW_MESSAGE);
    checkContentEncodingHeaderIsAbsent(greetingResponse);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public void testOldCookbookInBatch(RestClient client, RestliRequestOptions requestOptions) throws Exception
  {
    final GreetingsBuilders builders = new GreetingsBuilders(requestOptions);

    
    Greeting greetingResult = getOldCookbookBatchGetResult(client, requestOptions);

    
    Greeting greeting = new Greeting(greetingResult.data().copy());
    greeting.setMessage("This is a new message!");

    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(1L, greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    getOldCookbookBatchGetResult(client, requestOptions);

    
    Greeting repeatedGreeting = new Greeting();
    repeatedGreeting.setMessage("Hello Hello");
    repeatedGreeting.setTone(Tone.SINCERE);
    List<Greeting> entities = Arrays.asList(repeatedGreeting, repeatedGreeting);
    Request<CollectionResponse<CreateStatus>> batchCreateRequest = builders.batchCreate().inputs(entities).build();
    List<CreateStatus> statuses = client.sendRequest(batchCreateRequest).getResponse().getEntity().getElements();
    for (CreateStatus status : statuses)
    {
      Assert.assertEquals(status.getStatus().intValue(), HttpStatus.S_201_CREATED.getCode());
      @SuppressWarnings("deprecation")
      String id = status.getId();
      Assert.assertNotNull(id);
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public void testNewCookbookInBatch(RestClient client, RestliRequestOptions requestOptions) throws Exception
  {
    final GreetingsRequestBuilders builders = new GreetingsRequestBuilders(requestOptions);

    
    Greeting greetingResult = getNewCookbookBatchGetResult(client, requestOptions);

    
    Greeting greeting = new Greeting(greetingResult.data().copy());
    greeting.setMessage("This is a new message!");

    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(1L, greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    getNewCookbookBatchGetResult(client, requestOptions);

    
    Greeting repeatedGreeting = new Greeting();
    repeatedGreeting.setMessage("Hello Hello");
    repeatedGreeting.setTone(Tone.SINCERE);
    List<Greeting> entities = Arrays.asList(repeatedGreeting, repeatedGreeting);
    Request<BatchCreateIdResponse<Long>> batchCreateRequest = builders.batchCreate().inputs(entities).build();
    List<CreateIdStatus<Long>> statuses = client.sendRequest(batchCreateRequest).getResponse().getEntity().getElements();
    for (CreateIdStatus<Long> status : statuses)
    {
      Assert.assertEquals(status.getStatus().intValue(), HttpStatus.S_201_CREATED.getCode());
      @SuppressWarnings("deprecation")
      String id = status.getId();
      Assert.assertEquals(status.getKey().longValue(), Long.parseLong(id));
      Assert.assertNotNull(status.getKey());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearch(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("Search").setQueryParam("tone", Tone.FRIENDLY).build();
    Response<CollectionResponse<Greeting>> response = client.sendRequest(findRequest).getResponse();

    checkHeaderForCompression(response, operationsForCompression, "finder:search");

    List<Greeting> greetings = client.sendRequest(findRequest).getResponse().getEntity().getElements();
    for (Greeting g : greetings)
    {
      Assert.assertEquals(g.getTone(), Tone.FRIENDLY);
      Assert.assertNotNull(g.getMessage());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithoutDecompression(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
                                             ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("Search").setQueryParam("tone", Tone.FRIENDLY).build();
    RequestContext requestContext = new RequestContext();
    RequestContextUtil.turnOffResponseDecompression(requestContext);

    Map<String, Set<String>> methodsAndFamilies = getCompressionMethods(operationsForCompression);
    Set<String> methods = methodsAndFamilies.get("methods");
    Set<String> families = methodsAndFamilies.get("families");

    if (shouldCompress(families, methods, "finder:search"))
    {
      
      try
      {
        client.sendRequest(findRequest, requestContext).getResponse();
        Assert.fail("Expected RemoteInvocationException, but getResponse() succeeded.");
      }
      catch (RemoteInvocationException e)
      {
        Assert.assertEquals(e.getCause().getMessage(), "Could not decode REST response");
      }
    }
    else
    {
      
      client.sendRequest(findRequest, requestContext).getResponse();
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithPostFilter(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("SearchWithPostFilter").paginate(0, 5).build();
    Response<CollectionResponse<Greeting>> response = client.sendRequest(findRequest).getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + findRequest.getMethodName());
    CollectionResponse<Greeting> entity = response.getEntity();
    CollectionMetadata paging = entity.getPaging();
    Assert.assertEquals(paging.getStart().intValue(), 0);
    Assert.assertEquals(paging.getCount().intValue(), 5);
    Assert.assertEquals(entity.getElements().size(), 4); 

    
    Link next = paging.getLinks().get(0);
    Assert.assertEquals(next.getRel(), "next");

    
    
    final Map<String, String> queryParamsMap = new HashMap<String, String>();
    queryParamsMap.put("count", "5");
    queryParamsMap.put("start", "5");
    queryParamsMap.put("q", "searchWithPostFilter");

    final URIDetails uriDetails = new URIDetails(protocolVersion, "/greetings", null, queryParamsMap, null);
    URIDetails.testUriGeneration(next.getHref(), uriDetails);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithTones(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> req =
        builders.findBy("SearchWithTones").setQueryParam("tones", Arrays.asList(Tone.SINCERE, Tone.INSULTING)).build();
    ResponseFuture<CollectionResponse<Greeting>> future = client.sendRequest(req);
    Response<CollectionResponse<Greeting>> response = future.getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + req.getMethodName());
    List<Greeting> greetings = response.getEntity().getElements();
    for (Greeting greeting : greetings)
    {
      Assert.assertTrue(greeting.hasTone());
      Tone tone = greeting.getTone();
      Assert.assertTrue(Tone.SINCERE.equals(tone) || Tone.INSULTING.equals(tone));
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchFacets(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> req = builders.findBy("SearchWithFacets").setQueryParam("tone", Tone.SINCERE).build();
    ResponseFuture<CollectionResponse<Greeting>> future = client.sendRequest(req);
    Response<CollectionResponse<Greeting>> response = future.getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + req.getMethodName());
    SearchMetadata metadata = new SearchMetadata(response.getEntity().getMetadataRaw());
    Assert.assertTrue(metadata.getFacets().size() > 0);
    
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGet(RestClient client,
                           String operationsForCompression,
                           RestliRequestOptions requestOptions,
                           List<Long> ids,
                           int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    @SuppressWarnings("unchecked")
    final BatchResponse<Greeting> response = (BatchResponse<Greeting>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size(), expectedSuccessSize);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGetKV(RestClient client,
                             String operationsForCompression,
                             RestliRequestOptions requestOptions,
                             List<Long> ids,
                             int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).buildKV();
    @SuppressWarnings("unchecked")
    final BatchKVResponse<Long, Greeting> response = (BatchKVResponse<Long, Greeting>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size(), expectedSuccessSize);

    for (Map.Entry<Long, Greeting> entry : response.getResults().entrySet())
    {
      Assert.assertEquals(entry.getKey(), entry.getValue().getId());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGetEntity(RestClient client,
                                 String operationsForCompression,
                                 RestliRequestOptions requestOptions,
                                 List<Long> ids,
                                 int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsRequestBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    @SuppressWarnings("unchecked")
    final BatchKVResponse<Long, EntityResponse<Greeting>> response = (BatchKVResponse<Long, EntityResponse<Greeting>>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size() - response.getErrors().size(), expectedSuccessSize);

    for (Map.Entry<Long, EntityResponse<Greeting>> entry : response.getResults().entrySet())
    {
      if (entry.getValue().hasEntry())
      {
        Assert.assertEquals(entry.getKey(), entry.getValue().getEntity().getId());
      }
    }
  }

  private Greeting getOldCookbookBatchGetResult(RestClient client, RestliRequestOptions requestOptions) throws RemoteInvocationException
  {
    Request<BatchResponse<Greeting>> request = new GreetingsBuilders(requestOptions).batchGet().ids(1L).build();
    ResponseFuture<BatchResponse<Greeting>> future = client.sendRequest(request);
    Response<BatchResponse<Greeting>> greetingResponse = future.getResponse();
    checkContentEncodingHeaderIsAbsent(greetingResponse);
    return greetingResponse.getEntity().getResults().get("1");
  }

  private Greeting getNewCookbookBatchGetResult(RestClient client, RestliRequestOptions requestOptions) throws RemoteInvocationException
  {
    Request<BatchKVResponse<Long, EntityResponse<Greeting>>> request = new GreetingsRequestBuilders(requestOptions).batchGet().ids(1L).build();
    ResponseFuture<BatchKVResponse<Long, EntityResponse<Greeting>>> future = client.sendRequest(request);
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> greetingResponse = future.getResponse();
    checkContentEncodingHeaderIsAbsent(greetingResponse);
    return greetingResponse.getEntity().getResults().get(1L).getEntity();
  }

  private Object getBatchGetResponse(RestClient client, String operationsForCompression, Request<?> request) throws RemoteInvocationException
  {
    final Response<?> response = client.sendRequest(request).getResponse();
    checkHeaderForCompression(response, operationsForCompression, "batch_get");
    return response.getEntity();
  }

  
  private <T> void checkHeaderForCompression(Response<T> response, String operationsConfig, String methodName)
  {
    String contentEncodingHeader = response.getHeader(CONTENT_ENCODING_SAVED);
    String allPossibleAcceptEncodings = "gzip, deflate, bzip2, snappy";

    Map<String, Set<String>> methodsAndFamilies = getCompressionMethods(operationsConfig);
    Set<String> methods = methodsAndFamilies.get("methods");
    Set<String> families = methodsAndFamilies.get("families");

    if (shouldCompress(families, methods, methodName))
    {
      if (contentEncodingHeader == null)
      {
        Assert.fail("Content-Encoding header absent");
      }
      Assert.assertTrue(allPossibleAcceptEncodings.contains(contentEncodingHeader));
    }
    else
    {
      Assert.assertNull(contentEncodingHeader);
    }
  }

  private boolean shouldCompress(Set<String> families, Set<String> methods, String methodName)
  {
    return families.contains("*") ||
           methods.contains(methodName) ||
           (methodName.contains(":") && families.contains(methodName.split(":")[0]));
  }

  
  private Map<String, Set<String>> getCompressionMethods(String operationsConfig)
  {
    Map<String, Set<String>> methodsAndFamilies = new HashMap<String, Set<String>>();
    methodsAndFamilies.put("methods", new HashSet<String>());
    methodsAndFamilies.put("families", new HashSet<String>());
    for (String operation: operationsConfig.split(","))
    {
      operation = operation.trim();
      if (operation.equals("*"))
      {
        
        methodsAndFamilies.get("families").add(operation);
      }
      else if (operation.endsWith(":*"))
      {
        
        methodsAndFamilies.get("families").add(operation.split(":")[0]);
      }
      else
      {
        
        methodsAndFamilies.get("methods").add(operation);
      }
    }
    return methodsAndFamilies;
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testMalformedPagination(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    expectPaginationError("-1", client, builders);
    expectPaginationError("abc", client, builders);
  }

  private void expectPaginationError(String count, RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    try
    {
      Request<CollectionResponse<Greeting>> request = builders.findBy("Search").name("search").setParam("count", count).build();
      client.sendRequest(request).getResponse();
      Assert.fail("expected exception");
    }
    catch (RestException e)
    {
      Assert.assertEquals(e.getResponse().getStatus(), HttpStatus.S_400_BAD_REQUEST.getCode(), "expected 400 status");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testException(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    try
    {
      Request<Void> request = builders.<Void>action("ExceptionTest").build();
      client.sendRequest(request).getResponse().getEntity();
      Assert.fail("expected exception");
    }
    catch (RestLiResponseException e)
    {
      Assert.assertEquals(e.getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR.getCode());
      Assert.assertTrue(e.getServiceErrorMessage().contains("Test Exception"));
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void test404(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.get().id(999L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    try
    {
      future.getResponse();
      Assert.fail("expected 404");
    }
    catch (RestLiResponseException e)
    {
      Assert.assertEquals(e.getStatus(), HttpStatus.S_404_NOT_FOUND.getCode());
    }
  }
}

<code block>


package com.linkedin.d2.balancer.properties;


import java.util.HashSet;
import java.util.Set;



public enum AllowedClientPropertyKeys
{
  
  HTTP_QUERY_POST_THRESHOLD(PropertyKeys.HTTP_QUERY_POST_THRESHOLD),
  HTTP_POOL_SIZE(PropertyKeys.HTTP_POOL_SIZE),
  HTTP_REQUEST_TIMEOUT(PropertyKeys.HTTP_REQUEST_TIMEOUT),
  HTTP_IDLE_TIMEOUT(PropertyKeys.HTTP_IDLE_TIMEOUT),
  HTTP_MAX_RESPONSE_SIZE(PropertyKeys.HTTP_MAX_RESPONSE_SIZE),
  HTTP_SHUTDOWN_TIMEOUT(PropertyKeys.HTTP_SHUTDOWN_TIMEOUT),
  HTTP_RESPONSE_COMPRESSION_OPERATIONS(PropertyKeys.HTTP_RESPONSE_COMPRESSION_OPERATIONS),
  HTTP_USE_RESPONSE_COMPRESSION(PropertyKeys.HTTP_USE_RESPONSE_COMPRESSION),
  HTTP_POOL_WAITER_SIZE(PropertyKeys.HTTP_POOL_WAITER_SIZE),
  HTTP_POOL_MIN_SIZE(PropertyKeys.HTTP_POOL_MIN_SIZE);

  private static final Set<String> _allowedKeys;
  static
  {
    _allowedKeys = new HashSet<String>();
    for (AllowedClientPropertyKeys propertyKey: AllowedClientPropertyKeys.values())
    {
      _allowedKeys.add(propertyKey._keyName);
    }
  }

  private final String _keyName;

  AllowedClientPropertyKeys(String keyName)
  {
    _keyName = keyName;
  }

  public String getKeyName()
  {
    return _keyName;
  }

  public static boolean isAllowedConfigKey(String key)
  {
    return _allowedKeys.contains(key);
  }
}

<code block>


package com.linkedin.d2.balancer.properties;


import com.linkedin.r2.transport.http.client.HttpClientFactory;



public class PropertyKeys
{
  
  
  
  public static final String DEGRADER_PROPERTIES = "degraderProperties";
  public static final String DEGRADER_NAME = "degrader.name";
  public static final String DEGRADER_LOG_ENABLED = "degrader.logEnabled";
  public static final String DEGRADER_LATENCY_TO_USE = "degrader.latencyToUse";
  public static final String DEGRADER_OVERRIDE_DROP_DATE = "degrader.overrideDropDate";
  public static final String DEGRADER_MAX_DROP_RATE = "degrader.maxDropRate";
  public static final String DEGRADER_MAX_DROP_DURATION = "degrader.maxDropDuration";
  public static final String DEGRADER_UP_STEP = "degrader.upStep";
  public static final String DEGRADER_DOWN_STEP = "degrader.downStep";
  public static final String DEGRADER_MIN_CALL_COUNT = "degrader.minCallCount";
  public static final String DEGRADER_HIGH_LATENCY = "degrader.highLatency";
  public static final String DEGRADER_LOW_LATENCY = "degrader.lowLatency";
  public static final String DEGRADER_HIGH_ERROR_RATE = "degrader.highErrorRate";
  public static final String DEGRADER_LOW_ERROR_RATE = "degrader.lowErrorRate";
  public static final String DEGRADER_HIGH_OUTSTANDING = "degrader.highOutstanding";
  public static final String DEGRADER_LOW_OUTSTANDING = "degrader.lowOutstanding";
  public static final String DEGRADER_MIN_OUTSTANDING_COUNT = "degrader.minOutstandingCount";
  public static final String DEGRADER_OVERRIDE_MIN_CALL_COUNT = "degrader.overrideMinCallCount";

  
  public static final String PATH = "path";
  public static final String SERVICE_NAME = "serviceName";
  public static final String CLOCK = "clock";
  public static final String SERVICES = "services";
  public static final String TRANSPORT_CLIENT_PROPERTIES = "transportClientProperties";
  public static final String PRIORITIZED_SCHEMES = "prioritizedSchemes";
  public static final String BANNED_URIS = "bannedUri";
  public static final String DEFAULT_ROUTING = "defaultRouting";
  public static final String ALLOWED_CLIENT_OVERRIDE_KEYS = "allowedClientOverrideKeys";
  public static final String SERVICE_METADATA_PROPERTIES = "serviceMetadataProperties";

  
  public static final String LB_STRATEGY_LIST = "loadBalancerStrategyList";
  public static final String LB_STRATEGY_PROPERTIES = "loadBalancerStrategyProperties";

  
  public static final String HTTP_LB_HASH_METHOD = "http.loadBalancer.hashMethod";
  public static final String HTTP_LB_HASH_CONFIG = "http.loadBalancer.hashConfig";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_UPDATE_INTERVAL_MS = "http.loadBalancer.updateIntervalMs";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_MAX_CLUSTER_LATENCY_WITHOUT_DEGRADING = "http.loadBalancer.maxClusterLatencyWithoutDegrading";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_DEFAULT_SUCCESSFUL_TRANSMISSION_WEIGHT = "http.loadBalancer.defaultSuccessfulTransmissionWeight";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_POINTS_PER_WEIGHT = "http.loadBalancer.pointsPerWeight";
  public static final String HTTP_LB_LOW_WATER_MARK = "http.loadBalancer.lowWaterMark";
  public static final String HTTP_LB_HIGH_WATER_MARK = "http.loadBalancer.highWaterMark";
  public static final String HTTP_LB_INITIAL_RECOVERY_LEVEL = "http.loadBalancer.initialRecoveryLevel";
  public static final String HTTP_LB_RING_RAMP_FACTOR = "http.loadBalancer.ringRampFactor";
  public static final String HTTP_LB_GLOBAL_STEP_UP = "http.loadBalancer.globalStepUp";
  public static final String HTTP_LB_GLOBAL_STEP_DOWN = "http.loadBalancer.globalStepDown";
  public static final String HTTP_LB_CLUSTER_MIN_CALL_COUNT_HIGH_WATER_MARK = "http.loadBalancer.clusterMinCallCount.highWaterMark";
  public static final String HTTP_LB_CLUSTER_MIN_CALL_COUNT_LOW_WATER_MARK = "http.loadBalancer.clusterMinCallCount.lowWaterMark";

  
  public static final String SERVICE_FOLLOW_REDIRECTION_MAX_HOP = "followRedirection.maxHop";

  
  public static final String CLUSTER_NAME = "clusterName";
  public static final String PARTITION_PROPERTIES = "partitionProperties";
  public static final String PARTITION_TYPE = "partitionType";
  public static final String KEY_RANGE_START = "keyRangeStart";
  public static final String PARTITION_SIZE = "partitionSize";
  public static final String PARTITION_COUNT = "partitionCount";
  public static final String PARTITION_KEY_REGEX = "partitionKeyRegex";
  public static final String HASH_ALGORITHM = "hashAlgorithm";
  public static final String CLUSTER_VARIANTS = "clusterVariants";
  public static final String TYPE = "type";
  public static final String CLUSTER_LIST = "clusterList";
  public static final String CLUSTER_VARIANTS_LIST = "clusterVariantsList";
  public static final String FULL_CLUSTER_LIST = "fullClusterList";

  
  public static final String HTTP_POOL_WAITER_SIZE = HttpClientFactory.HTTP_POOL_WAITER_SIZE;
  public static final String HTTP_REQUEST_TIMEOUT = HttpClientFactory.HTTP_REQUEST_TIMEOUT;
  public static final String HTTP_MAX_RESPONSE_SIZE = HttpClientFactory.HTTP_MAX_RESPONSE_SIZE;
  public static final String HTTP_POOL_SIZE = HttpClientFactory.HTTP_POOL_SIZE;
  public static final String HTTP_IDLE_TIMEOUT = HttpClientFactory.HTTP_IDLE_TIMEOUT;
  public static final String HTTP_SHUTDOWN_TIMEOUT = HttpClientFactory.HTTP_SHUTDOWN_TIMEOUT;
  public static final String HTTP_SSL_CONTEXT = HttpClientFactory.HTTP_SSL_CONTEXT;
  public static final String HTTP_SSL_PARAMS = HttpClientFactory.HTTP_SSL_PARAMS;
  public static final String HTTP_RESPONSE_COMPRESSION_OPERATIONS = HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS;
  public static final String HTTP_REQUEST_CONTENT_ENCODINGS = HttpClientFactory.HTTP_REQUEST_CONTENT_ENCODINGS;
  public static final String HTTP_USE_RESPONSE_COMPRESSION = HttpClientFactory.HTTP_USE_RESPONSE_COMPRESSION;
  public static final String HTTP_QUERY_POST_THRESHOLD = HttpClientFactory.HTTP_QUERY_POST_THRESHOLD;
  public static final String HTTP_POOL_STRATEGY = HttpClientFactory.HTTP_POOL_STRATEGY;
  public static final String HTTP_POOL_MIN_SIZE = HttpClientFactory.HTTP_POOL_MIN_SIZE;

  
  public static final String DEFAULT_COLO = "defaultColo";
  public static final String COLO_VARIANTS = "coloVariants";
  public static final String MASTER_COLO = "masterColo";
  public static final String MASTER_SUFFIX = "Master";
  public static final String HAS_COLO_VARIANTS = "hasColoVariants";
  
  public static final String IS_MASTER_SERVICE = "isMasterService";
  
  public static final String IS_DEFAULT_SERVICE = "isDefaultService";
  public static final String ENABLE_SYMLINK = "enableSymlink";

}

<code block>


package com.linkedin.r2.filter;


import com.linkedin.r2.filter.compression.ClientCompressionFilter;


public class CompressionConfig
{
  private final int _compressionThreshold;

  public CompressionConfig(int compressionThreshold)
  {
    if (compressionThreshold < 0)
    {
      throw new IllegalArgumentException("compressionThreshold should not be negative.");
    }
    _compressionThreshold = compressionThreshold;
  }

  @Override
  public boolean equals(Object o)
  {
    if (this == o)
    {
      return true;
    }
    if (o == null || getClass() != o.getClass())
    {
      return false;
    }

    CompressionConfig that = (CompressionConfig) o;

    if (_compressionThreshold != that._compressionThreshold)
    {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode()
  {
    return _compressionThreshold;
  }

  @Override
  public String toString()
  {
    return "CompressionConfig{" +
        "_compressionThreshold=" + _compressionThreshold +
        '}';
  }

  public int getCompressionThreshold()
  {
    return _compressionThreshold;
  }
}

<code block>
package com.linkedin.r2.filter.compression;

public class CompressionConstants
{
  protected static final int BUFFER_SIZE = 4*1024; 

  protected static final String DECODING_ERROR = "Cannot properly decode stream: ";
  protected static final String BAD_STREAM = "Bad input stream";

  protected static final String ILLEGAL_FORMAT = "Illegal format in Accept-Encoding: ";
  protected static final String NULL_COMPRESSOR_ERROR = "Request content encoding must be valid non-null, use \"identity\"/EncodingType.IDENTITY for no compression.";
  protected static final String NULL_ENCODING_ERROR = "Cannot use null encoding as an accept encoding value.";
  protected static final String NULL_CONFIG_ERROR = "Compression config should not be null.";

  protected static final String UNSUPPORTED_ENCODING = "Unsupported encoding referenced: ";
  protected static final String SERVER_ENCODING_ERROR = "Server returned unrecognized content encoding: ";
  protected static final String REQUEST_ANY_ERROR = "ANY may not be used as request encoding type: ";
  protected static final String INVALID_THRESHOLD = "Invalid compression threshold: ";

  protected static final String ENCODING_DELIMITER = ",";
  protected static final String QUALITY_DELIMITER = ";";
  protected static final String QUALITY_PREFIX = "q=";
}

<code block>


package com.linkedin.r2.filter.compression;


import com.linkedin.r2.filter.Filter;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.message.rest.RestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.common.HttpConstants;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ClientCompressionFilter implements Filter, RestFilter
{
  private static final Logger LOG = LoggerFactory.getLogger(ClientCompressionFilter.class);

  private final EncodingType _requestContentEncoding;
  private final CompressionConfig _requestCompressionConfig;
  private final CompressionConfig _responseCompressionConfig;
  private final String _acceptEncodingHeader;

  
  
  
  private Set<String> _responseCompressionMethods;

  private boolean _compressAllResponses;

  
  private Set<String> _responseCompressionFamilies;

  
  public static final String COMPRESS_ALL_RESPONSES_INDICATOR = "*";

  private static final String FAMILY_SEPARATOR = ":";
  private static final String COMPRESS_ALL_IN_FAMILY = FAMILY_SEPARATOR + COMPRESS_ALL_RESPONSES_INDICATOR;

  
  public ClientCompressionFilter(EncodingType requestContentEncoding,
                                 CompressionConfig requestCompressionConfig,
                                 EncodingType[] acceptedEncodings,
                                 CompressionConfig responseCompressionConfig,
                                 List<String> responseCompressionOperations)
  {
    if (requestContentEncoding == null)
    {
      throw new IllegalArgumentException(CompressionConstants.NULL_COMPRESSOR_ERROR);
    }
    else if (requestContentEncoding.equals(EncodingType.ANY))
    {
      throw new IllegalArgumentException(CompressionConstants.REQUEST_ANY_ERROR
          + requestContentEncoding.getHttpName());
    }

    if (acceptedEncodings == null)
    {
      acceptedEncodings = new EncodingType[0];
    }
    
    for (EncodingType type : acceptedEncodings)
    {
      if (type == null)
      {
        throw new IllegalArgumentException(CompressionConstants.NULL_ENCODING_ERROR);
      }
    }

    if (requestCompressionConfig == null)
    {
      throw new IllegalArgumentException(CompressionConstants.NULL_CONFIG_ERROR);
    }
    

    _requestContentEncoding = requestContentEncoding;
    _requestCompressionConfig = requestCompressionConfig;
    _acceptEncodingHeader = buildAcceptEncodingHeader(acceptedEncodings);
    _responseCompressionConfig = responseCompressionConfig;

    _responseCompressionMethods = new HashSet<String>();
    _responseCompressionFamilies = new HashSet<String>();
    buildResponseCompressionMethodsAndFamiliesSet(responseCompressionOperations);
    
    _compressAllResponses = _responseCompressionMethods.contains(COMPRESS_ALL_RESPONSES_INDICATOR);
  }

  
  public ClientCompressionFilter(String requestContentEncoding,
                                 CompressionConfig requestCompressionConfig,
                                 String acceptedEncodings,
                                 CompressionConfig responseCompressionConfig,
                                 List<String> responseCompressionOperations)
  {
    this(requestContentEncoding.trim().isEmpty() ? EncodingType.IDENTITY : EncodingType.get(requestContentEncoding.trim().toLowerCase()),
        requestCompressionConfig,
        AcceptEncoding.parseAcceptEncoding(acceptedEncodings),
        responseCompressionConfig,
        responseCompressionOperations);
  }

  
  private void buildResponseCompressionMethodsAndFamiliesSet(List<String> responseCompressionOperations)
  {
    for (String operation: responseCompressionOperations)
    {
      
      if (operation.endsWith(COMPRESS_ALL_IN_FAMILY))
      {
        String[] parts = operation.split(FAMILY_SEPARATOR);
        if (parts == null || parts.length != 2)
        {
          LOG.warn("Illegal compression operation family " + operation + " specified");
          return;
        }
        _responseCompressionFamilies.add(parts[0].trim());
      }
      else
      {
        _responseCompressionMethods.add(operation);
      }
    }
  }

  
   static String buildAcceptEncodingHeader(EncodingType[] acceptedEncodings)
  {
    
    float delta = 1.0f/(acceptedEncodings.length+1);
    float currentQuality = 1.0f;

    
    StringBuilder acceptEncodingValue = new StringBuilder();
    for(int i=0; i < acceptedEncodings.length; i++)
    {
      EncodingType t = acceptedEncodings[i];

      if(i > 0)
      {
        acceptEncodingValue.append(CompressionConstants.ENCODING_DELIMITER);
      }
      acceptEncodingValue.append(t.getHttpName());
      acceptEncodingValue.append(CompressionConstants.QUALITY_DELIMITER);
      acceptEncodingValue.append(CompressionConstants.QUALITY_PREFIX);
      acceptEncodingValue.append(String.format("%.2f", currentQuality));
      currentQuality = currentQuality - delta;
    }

    return acceptEncodingValue.toString();
  }

  
  private boolean shouldCompressRequest(int entityLength, CompressionOption requestCompressionOverride)
  {
    if (requestCompressionOverride != null)
    {
      return (requestCompressionOverride == CompressionOption.FORCE_ON);
    }
    return entityLength > _requestCompressionConfig.getCompressionThreshold();
  }

  
  public RestRequest addResponseCompressionHeaders(CompressionOption responseCompressionOverride, RestRequest req)
  {
    RestRequestBuilder builder = req.builder();
    if (responseCompressionOverride == null)
    {
      builder.addHeaderValue(HttpConstants.ACCEPT_ENCODING, _acceptEncodingHeader);
      if (_responseCompressionConfig != null)
      {
        builder.addHeaderValue(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD,
            Integer.toString(_responseCompressionConfig.getCompressionThreshold()));
      }
    }
    else if (responseCompressionOverride == CompressionOption.FORCE_ON)
    {
      builder.addHeaderValue(HttpConstants.ACCEPT_ENCODING, _acceptEncodingHeader)
             .addHeaderValue(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD, Integer.toString(0));
    }
    return builder.build();
  }

  
  @Override
  public void onRestRequest(RestRequest req, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      if (_requestContentEncoding.hasCompressor())
      {
        if (shouldCompressRequest(req.getEntity().length(),
            (CompressionOption) requestContext.getLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE)
        ))
        {
          Compressor compressor = _requestContentEncoding.getCompressor();
          byte[] compressed = compressor.deflate(req.getEntity().asInputStream());

          if (compressed.length < req.getEntity().length())
          {
            req = req.builder().setEntity(compressed).setHeader(HttpConstants.CONTENT_ENCODING,
                compressor.getContentEncodingName()).build();
          }
        }
      }

      String operation = (String) requestContext.getLocalAttr(R2Constants.OPERATION);
      if (!_acceptEncodingHeader.isEmpty() && operation != null && shouldCompressResponseForOperation(operation))
      {
        CompressionOption responseCompressionOverride =
            (CompressionOption) requestContext.getLocalAttr(R2Constants.RESPONSE_COMPRESSION_OVERRIDE);
        req = addResponseCompressionHeaders(responseCompressionOverride, req);
      }
    }
    catch (CompressionException e)
    {
      LOG.error(e.getMessage(), e.getCause());
    }

    
    nextFilter.onRequest(req, requestContext, wireAttrs);
  }

  
  private boolean shouldCompressResponseForOperation(String operation)
  {
    return _compressAllResponses ||
        _responseCompressionMethods.contains(operation) ||
        isMemberOfCompressionFamily(operation);
  }

  
  private boolean isMemberOfCompressionFamily(String operation)
  {
    if (operation.contains(FAMILY_SEPARATOR))
    {
      String[] parts = operation.split(FAMILY_SEPARATOR);
      if (parts == null || parts.length != 2)
      {
        return false;
      }
      String family = parts[0];
      return _responseCompressionFamilies.contains(family);
    }
    return false;
  }

  
  @Override
  public void onRestResponse(RestResponse res, RequestContext requestContext,
                             Map<String, String> wireAttrs,
                             NextFilter<RestRequest, RestResponse> nextFilter)
  {
    Boolean decompressionOff = (Boolean) requestContext.getLocalAttr(R2Constants.RESPONSE_DECOMPRESSION_OFF);
    if (decompressionOff == null || !decompressionOff)
    {
      try
      {
        
        String compressionHeader = res.getHeader(HttpConstants.CONTENT_ENCODING);

        
        if (compressionHeader != null && res.getEntity().length() > 0)
        {
          EncodingType encoding = null;
          try
          {
            encoding = EncodingType.get(compressionHeader.trim().toLowerCase());
          }
          catch (IllegalArgumentException e)
          {
            throw new CompressionException(CompressionConstants.SERVER_ENCODING_ERROR + compressionHeader);
          }
          if (!encoding.hasCompressor())
          {
            throw new CompressionException(CompressionConstants.SERVER_ENCODING_ERROR + compressionHeader);
          }
          byte[] inflated = encoding.getCompressor().inflate(res.getEntity().asInputStream());
          Map<String, String> headers = new HashMap<String, String>(res.getHeaders());
          headers.remove(HttpConstants.CONTENT_ENCODING);
          headers.put(HttpConstants.CONTENT_LENGTH, Integer.toString(inflated.length));
          res = res.builder().setEntity(inflated).setHeaders(headers).build();
        }
      }
      catch (CompressionException e)
      {
        nextFilter.onError(e, requestContext, wireAttrs);
        return;
      }
    }

    nextFilter.onResponse(res, requestContext, wireAttrs);
  }

  @Override
  public void onRestError(Throwable ex, RequestContext requestContext,
                          Map<String, String> wireAttrs,
                          NextFilter<RestRequest, RestResponse> nextFilter)
  {
    nextFilter.onError(ex, requestContext, wireAttrs);
  }

}

<code block>


package com.linkedin.r2.filter.compression;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.Filter;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.message.rest.RestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.r2.transport.http.common.HttpConstants;


public class ServerCompressionFilter implements Filter, RestFilter
{
  private static final Logger LOG = LoggerFactory.getLogger(ServerCompressionFilter.class);

  private final Set<EncodingType> _supportedEncoding;
  private final CompressionConfig _defaultResponseCompressionConfig;

  private static final String EMPTY = "";

  
  public ServerCompressionFilter()
  {
    this(EMPTY);
  }

  
  public ServerCompressionFilter(String acceptedFilters)
  {
    this(acceptedFilters, new CompressionConfig(Integer.MAX_VALUE));
  }

  public ServerCompressionFilter(String acceptedFilters, CompressionConfig responseCompressionConfig)
  {
    this(AcceptEncoding.parseAcceptEncoding(acceptedFilters), responseCompressionConfig);
  }

  
  public ServerCompressionFilter(EncodingType[] supportedEncoding, CompressionConfig defaultResponseCompressionConfig)
  {
    if (defaultResponseCompressionConfig == null)
    {
      throw new IllegalArgumentException(CompressionConstants.NULL_CONFIG_ERROR);
    }
    _supportedEncoding = new HashSet<EncodingType>(Arrays.asList(supportedEncoding));
    _supportedEncoding.add(EncodingType.IDENTITY);
    _supportedEncoding.add(EncodingType.ANY);
    _defaultResponseCompressionConfig = defaultResponseCompressionConfig;
  }

  
  @Override
  public void onRestRequest(RestRequest req, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      
      String requestContentEncoding = req.getHeader(HttpConstants.CONTENT_ENCODING);

      if (requestContentEncoding != null)
      {
        
        EncodingType encoding;
        try
        {
          encoding = EncodingType.get(requestContentEncoding.trim().toLowerCase());
        }
        catch (IllegalArgumentException ex)
        {
          throw new CompressionException(CompressionConstants.UNSUPPORTED_ENCODING
              + requestContentEncoding);
        }
        if (encoding == EncodingType.ANY)
        {
          throw new CompressionException(CompressionConstants.REQUEST_ANY_ERROR
              + requestContentEncoding);
        }

        
        if (encoding.hasCompressor())
        {
          byte[] decompressedContent = encoding.getCompressor().inflate(req.getEntity().asInputStream());
          Map<String, String> headers = new HashMap<String, String>(req.getHeaders());
          headers.remove(HttpConstants.CONTENT_ENCODING);
          headers.put(HttpConstants.CONTENT_LENGTH, Integer.toString(decompressedContent.length));
          req = req.builder().setEntity(decompressedContent).setHeaders(headers).build();
        }
      }

      
      String responseAcceptedEncodings = req.getHeader(HttpConstants.ACCEPT_ENCODING);
      if (responseAcceptedEncodings == null)
      {
        responseAcceptedEncodings = EMPTY; 
      }
      requestContext.putLocalAttr(HttpConstants.ACCEPT_ENCODING, responseAcceptedEncodings);

      if (!responseAcceptedEncodings.isEmpty())
      {
        requestContext.putLocalAttr(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD, getResponseCompressionThreshold(req));
      }
      nextFilter.onRequest(req, requestContext, wireAttrs);
    }
    catch (CompressionException e)
    {
      
      LOG.error(e.getMessage(), e.getCause());
      RestResponse restResponse = new RestResponseBuilder().setStatus(HttpConstants.UNSUPPORTED_MEDIA_TYPE).build();
      nextFilter.onError(new RestException(restResponse, e), requestContext, wireAttrs);
    }
  }

  private int getResponseCompressionThreshold(RestRequest request) throws CompressionException
  {
    String responseCompressionThreshold = request.getHeader(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD);
    
    if (responseCompressionThreshold != null)
    {
      try
      {
        return Integer.parseInt(responseCompressionThreshold);
      }
      catch (NumberFormatException e)
      {
        throw new CompressionException(CompressionConstants.INVALID_THRESHOLD + responseCompressionThreshold);
      }
    }
    return _defaultResponseCompressionConfig.getCompressionThreshold();
  }

  
  @Override
  public void onRestResponse(RestResponse res, RequestContext requestContext,
                             Map<String, String> wireAttrs,
                             NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      if (res.getEntity().length() > 0)
      {
        String responseAcceptedEncodings = (String) requestContext.getLocalAttr(HttpConstants.ACCEPT_ENCODING);
        if (responseAcceptedEncodings == null)
        {
          throw new CompressionException(HttpConstants.ACCEPT_ENCODING + " not in local attribute.");
        }

        List<AcceptEncoding> parsedEncodings = AcceptEncoding.parseAcceptEncodingHeader(responseAcceptedEncodings, _supportedEncoding);
        EncodingType selectedEncoding = AcceptEncoding.chooseBest(parsedEncodings);

        
        if (selectedEncoding != null)
        {
          if (selectedEncoding.hasCompressor() &&
              res.getEntity().length() > (Integer) requestContext.getLocalAttr(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD))
          {
            Compressor compressor = selectedEncoding.getCompressor();
            byte[] compressed = compressor.deflate(res.getEntity().asInputStream());

            if (compressed.length < res.getEntity().length())
            {
              RestResponseBuilder resCompress = res.builder();
              resCompress.addHeaderValue(HttpConstants.CONTENT_ENCODING, compressor.getContentEncodingName());
              resCompress.setEntity(compressed);
              res = resCompress.build();
            }
          }
        }
        else
        {
          
          res = res.builder().setStatus(HttpConstants.NOT_ACCEPTABLE).setEntity(new byte[0]).build();
        }
      }
    }
    catch (CompressionException e)
    {
      LOG.error(e.getMessage(), e.getCause());
    }

    nextFilter.onResponse(res, requestContext, wireAttrs);
  }


  @Override
  public void onRestError(Throwable ex, RequestContext requestContext,
                          Map<String, String> wireAttrs,
                          NextFilter<RestRequest, RestResponse> nextFilter)
  {
    nextFilter.onError(ex, requestContext, wireAttrs);
  }
}

<code block>


package com.linkedin.r2.filter.compression;

import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestMethod;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.common.HttpConstants;

import java.io.ByteArrayInputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;


public class TestClientCompressionFilter
{
  private static final String ACCEPT_COMPRESSIONS = "gzip, deflate, bzip2, snappy";
  private static final String ACCEPT_ENCODING_HEADER = "gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40";
  private static final String URI = "http:

  
  class HeaderCaptureFilter implements NextFilter<RestRequest, RestResponse>
  {
    private String _headerName;
    private String _expectedValue;
    private int _entityLength = 0;

    public HeaderCaptureFilter(String headerName, String expectedValue)
    {
      _headerName = headerName;
      _expectedValue = expectedValue;
    }

    public HeaderCaptureFilter(String headerName, String expectedValue, int entityLength)
    {
      this(headerName, expectedValue);
      _entityLength = entityLength;
    }

    @Override
    public void onRequest(RestRequest restRequest, RequestContext requestContext, Map<String, String> wireAttrs)
    {
      String header = restRequest.getHeader(_headerName);
      Assert.assertEquals(header, _expectedValue);
      if (_entityLength > 0)
      {
        Assert.assertEquals(restRequest.getEntity().length(), _entityLength);
      }
    }

    @Override
    public void onResponse(RestResponse restResponse, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }

    @Override
    public void onError(Throwable ex, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }
  }

  @DataProvider(name = "requestCompressionData")
  private Object[][] provideRequestCompressionData()
  {
    CompressionConfig smallThresholdConfig = new CompressionConfig(1);
    CompressionConfig largeThresholdConfig = new CompressionConfig(10000);

    return new Object[][] {
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_OFF, false},
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_ON, true},
        {new CompressionConfig(Integer.MAX_VALUE), null, false},
        {new CompressionConfig(0), CompressionOption.FORCE_OFF, false},
        {new CompressionConfig(0), CompressionOption.FORCE_ON, true},
        {new CompressionConfig(0), null, true},
        {smallThresholdConfig, CompressionOption.FORCE_OFF, false},
        {smallThresholdConfig, CompressionOption.FORCE_ON, true},
        {smallThresholdConfig, null, true},
        {largeThresholdConfig, CompressionOption.FORCE_OFF, false},
        {largeThresholdConfig, CompressionOption.FORCE_ON, true},
        {largeThresholdConfig, null, false}
    };
  }

  @Test(dataProvider = "requestCompressionData")
  public void testRequestCompressionRules(CompressionConfig requestCompressionConfig,
                                          CompressionOption requestCompressionOverride, boolean headerShouldBePresent)
      throws CompressionException, URISyntaxException
  {
    ClientCompressionFilter clientCompressionFilter = new ClientCompressionFilter(EncodingType.SNAPPY.getHttpName(),
                                                                                  requestCompressionConfig,
                                                                                  ACCEPT_COMPRESSIONS,
                                                                                  new CompressionConfig(Integer.MAX_VALUE),
                                                                                  Collections.<String>emptyList());
    
    int original = 100;
    byte[] entity = new byte[original];
    Arrays.fill(entity, (byte)'A');
    RestRequest restRequest = new RestRequestBuilder(new URI(URI)).setMethod(RestMethod.POST).setEntity(entity).build();
    int compressed = EncodingType.SNAPPY.getCompressor().deflate(new ByteArrayInputStream(entity)).length;
    RequestContext context = new RequestContext();
    context.putLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE, requestCompressionOverride);
    int entityLength = headerShouldBePresent ? compressed : original;
    String expectedContentEncoding = headerShouldBePresent ? EncodingType.SNAPPY.getHttpName() : null;
    clientCompressionFilter.onRestRequest(restRequest, context, Collections.<String, String>emptyMap(),
                                          new HeaderCaptureFilter(HttpConstants.CONTENT_ENCODING, expectedContentEncoding, entityLength));
  }

  @DataProvider(name = "responseCompressionData")
  private Object[][] provideResponseCompressionData()
  {
    CompressionConfig smallThresholdConfig = new CompressionConfig(1);
    CompressionConfig largeThresholdConfig = new CompressionConfig(10000);

    return new Object[][] {
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_OFF, null, null},
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_ON, ACCEPT_ENCODING_HEADER, Integer.toString(0)},
        {new CompressionConfig(Integer.MAX_VALUE), null, ACCEPT_ENCODING_HEADER, Integer.toString(Integer.MAX_VALUE)},
        {new CompressionConfig(0), CompressionOption.FORCE_OFF, null, null},
        {new CompressionConfig(0), CompressionOption.FORCE_ON, ACCEPT_ENCODING_HEADER, Integer.toString(0)},
        {new CompressionConfig(0), null, ACCEPT_ENCODING_HEADER, Integer.toString(0)},
        {smallThresholdConfig, CompressionOption.FORCE_OFF, null, null},
        {smallThresholdConfig, CompressionOption.FORCE_ON, ACCEPT_ENCODING_HEADER, Integer.toString(0)},
        {smallThresholdConfig, null, ACCEPT_ENCODING_HEADER, Integer.toString(1)},
        {largeThresholdConfig, CompressionOption.FORCE_OFF, null, null},
        {largeThresholdConfig, CompressionOption.FORCE_ON, ACCEPT_ENCODING_HEADER, Integer.toString(0)},
        {largeThresholdConfig, null, ACCEPT_ENCODING_HEADER, Integer.toString(10000)}
    };
  }

  @Test(dataProvider = "responseCompressionData")
  public void testResponseCompressionRules(CompressionConfig responseCompressionConfig,
                                           CompressionOption responseCompressionOverride,
                                           String expectedAcceptEncoding,
                                           String expectedCompressionThreshold)
      throws CompressionException, URISyntaxException
  {
    ClientCompressionFilter clientCompressionFilter = new ClientCompressionFilter(EncodingType.SNAPPY.getHttpName(),
                                                                                  new CompressionConfig(Integer.MAX_VALUE),
                                                                                  ACCEPT_COMPRESSIONS,
                                                                                  responseCompressionConfig,
                                                                                  Arrays.asList(ClientCompressionFilter.COMPRESS_ALL_RESPONSES_INDICATOR));
    RestRequest restRequest = new RestRequestBuilder(new URI(URI)).build();
    RequestContext context = new RequestContext();
    context.putLocalAttr(R2Constants.OPERATION, "get");
    context.putLocalAttr(R2Constants.RESPONSE_COMPRESSION_OVERRIDE, responseCompressionOverride);
    clientCompressionFilter.onRestRequest(restRequest, context, Collections.<String, String>emptyMap(),
                                          new HeaderCaptureFilter(HttpConstants.ACCEPT_ENCODING, expectedAcceptEncoding));
    clientCompressionFilter.onRestRequest(restRequest, context, Collections.<String, String>emptyMap(),
                                          new HeaderCaptureFilter(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD, expectedCompressionThreshold));

  }

  
  
  
  
  @DataProvider
  public Object[][] contentEncodingGeneratorDataProvider()
  {
    
    
    
    
    
    int current = 0;
    int length = 1 + EncodingType.values().length*EncodingType.values().length + 1;
    Object[][] encoding = new Object[length][];
    encoding[current++] = new Object[]{new EncodingType[]{}, ""};

    
    for(EncodingType type : EncodingType.values())
    {
      encoding[current++] = new Object[]{
          new EncodingType[]{type},
          type.getHttpName() + ";q=" + "1.00"};
    }

    
    for(EncodingType prev : EncodingType.values())
    {
      for(EncodingType next : EncodingType.values())
      {
        if (prev != next)
        {
          encoding[current++] = new Object[]{new EncodingType[]{prev, next},
              prev.getHttpName() + ";q=" + "1.00" + ","
                  + next.getHttpName() + ";q=" + "0.67"
          };
        }
      }
    }

    
    encoding[current++] = new Object[]{new EncodingType[]{
        EncodingType.DEFLATE, EncodingType.IDENTITY, EncodingType.GZIP},
        "deflate;q=1.00,identity;q=0.75,gzip;q=0.50"};

    return encoding;
  }

  @Test(dataProvider = "contentEncodingGeneratorDataProvider")
  public void testEncodingGeneration(EncodingType[] encoding, String acceptEncoding)
  {
    Assert.assertEquals(ClientCompressionFilter.buildAcceptEncodingHeader(encoding), acceptEncoding);
  }
}

<code block>


package com.linkedin.r2.filter.compression;

import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.r2.transport.http.common.HttpConstants;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.io.ByteArrayInputStream;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;


public class TestServerCompressionFilter
{
  private static final String ACCEPT_COMPRESSIONS = "gzip, deflate, bzip2, snappy";

  class HeaderCaptureFilter implements NextFilter<RestRequest, RestResponse>
  {
    private String _headerName;
    private String _expectedValue;
    private int _entityLength = 0;

    public HeaderCaptureFilter(String headerName, String expectedValue)
    {
      _headerName = headerName;
      _expectedValue = expectedValue;
    }

    public HeaderCaptureFilter(String headerName, String expectedValue, int entityLength)
    {
      this(headerName, expectedValue);
      _entityLength = entityLength;
    }

    @Override
    public void onRequest(RestRequest restRequest, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }

    @Override
    public void onResponse(RestResponse restResponse, RequestContext requestContext, Map<String, String> wireAttrs)
    {
      String header = restResponse.getHeader(_headerName);
      Assert.assertEquals(header, _expectedValue);
      if (_entityLength > 0)
      {
        Assert.assertEquals(restResponse.getEntity().length(), _entityLength);
      }
    }

    @Override
    public void onError(Throwable ex, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }
  }

  @DataProvider(name = "headersData")
  private Object[][] provideHeadersData()
  {
    return new Object[][] {
        {"gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40", 99, EncodingType.GZIP},
        {"snappy", 99, EncodingType.SNAPPY},
        {"unknown;q=1.00,bzip2;q=0.70", 99, EncodingType.BZIP2},
        {"gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40", 100, null},
        {"snappy", 100, null},
        {"unknown;q=1.00,bzip2;q=0.70", 100, null},
        {"gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40", Integer.MAX_VALUE, null},
        {"gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40", 0, EncodingType.GZIP},
        {"snappy", Integer.MAX_VALUE, null},
        {"snappy", 0, EncodingType.SNAPPY},
        {"unknown;q=1.00,bzip2;q=0.70", 0, EncodingType.BZIP2},
        {"gzip;q=1.00,deflate;q=0.80,bzip2;q=0.60,snappy;q=0.40", 1000, null},
        {"snappy", 1000, null},
        {"unknown;q=1.00,bzip2;q=0.70", 1000, null}
    };
  }

  
  @Test(dataProvider = "headersData")
  public void testResponseCompressionRules(String acceptEncoding, int compressionThreshold, EncodingType expectedContentEncoding)
      throws CompressionException, URISyntaxException
  {
    ServerCompressionFilter serverCompressionFilter = new ServerCompressionFilter(ACCEPT_COMPRESSIONS);
    RequestContext context = new RequestContext();
    context.putLocalAttr(HttpConstants.ACCEPT_ENCODING, acceptEncoding);
    context.putLocalAttr(HttpConstants.HEADER_RESPONSE_COMPRESSION_THRESHOLD, compressionThreshold);
    int originalLength = 100;
    byte[] entity = new byte[originalLength];
    Arrays.fill(entity, (byte) 'A');
    int compressedLength = (expectedContentEncoding == null) ? originalLength :
        expectedContentEncoding.getCompressor().deflate(new ByteArrayInputStream(entity)).length;
    String expectedContentEncodingName = (expectedContentEncoding == null) ? null : expectedContentEncoding.getHttpName();
    RestResponse restResponse = new RestResponseBuilder().setEntity(entity).build();
    serverCompressionFilter.onRestResponse(restResponse, context, Collections.<String, String>emptyMap(),
                                           new HeaderCaptureFilter(HttpConstants.CONTENT_ENCODING, expectedContentEncodingName, compressedLength));
  }
}

<code block>



package com.linkedin.r2.transport.http.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.util.None;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.compression.ClientCompressionFilter;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.filter.transport.ClientQueryTunnelFilter;
import com.linkedin.r2.filter.transport.FilterChainClient;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.TransportClientFactory;
import com.linkedin.r2.transport.common.bridge.client.TransportClient;
import com.linkedin.r2.transport.common.bridge.common.TransportCallback;
import com.linkedin.r2.util.ConfigValueExtractor;
import com.linkedin.r2.util.NamedThreadFactory;

import io.netty.channel.nio.NioEventLoopGroup;
import java.util.concurrent.ExecutorService;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class HttpClientFactory implements TransportClientFactory
{
  private static final Logger LOG = LoggerFactory.getLogger(HttpClientFactory.class);

  public static final String HTTP_QUERY_POST_THRESHOLD = "http.queryPostThreshold";
  public static final String HTTP_REQUEST_TIMEOUT = "http.requestTimeout";
  public static final String HTTP_MAX_RESPONSE_SIZE = "http.maxResponseSize";
  public static final String HTTP_POOL_SIZE = "http.poolSize";
  public static final String HTTP_POOL_WAITER_SIZE = "http.poolWaiterSize";
  public static final String HTTP_IDLE_TIMEOUT = "http.idleTimeout";
  public static final String HTTP_SHUTDOWN_TIMEOUT = "http.shutdownTimeout";
  public static final String HTTP_SSL_CONTEXT = "http.sslContext";
  public static final String HTTP_SSL_PARAMS = "http.sslParams";
  public static final String HTTP_RESPONSE_COMPRESSION_OPERATIONS = "http.responseCompressionOperations";
  public static final String HTTP_REQUEST_CONTENT_ENCODINGS = "http.requestContentEncodings";
  public static final String HTTP_SERVICE_NAME = "http.serviceName";
  public static final String HTTP_POOL_STRATEGY = "http.poolStrategy";
  public static final String HTTP_POOL_MIN_SIZE = "http.poolMinSize";
  public static final String HTTP_MAX_HEADER_SIZE = "http.maxHeaderSize";
  public static final String HTTP_MAX_CHUNK_SIZE = "http.maxChunkSize";
  public static final String HTTP_MAX_CONCURRENT_CONNECTIONS = "http.maxConcurrentConnections";

  public static final int DEFAULT_POOL_WAITER_SIZE = Integer.MAX_VALUE;
  public static final int DEFAULT_POOL_SIZE = 200;
  public static final int DEFAULT_REQUEST_TIMEOUT = 10000;
  public static final int DEFAULT_IDLE_TIMEOUT = 25000;
  public static final int DEFAULT_SHUTDOWN_TIMEOUT = 5000;
  public static final int DEFAULT_MAX_RESPONSE_SIZE = 1024 * 1024 * 2;
  public static final String DEFAULT_CLIENT_NAME = "noNameSpecifiedClient";
  public static final AsyncPoolImpl.Strategy DEFAULT_POOL_STRATEGY = AsyncPoolImpl.Strategy.MRU;
  public static final int DEFAULT_POOL_MIN_SIZE = 0;
  public static final int DEFAULT_MAX_HEADER_SIZE = 8 * 1024;
  public static final int DEFAULT_MAX_CHUNK_SIZE = 8 * 1024;


  private static final String LIST_SEPARATOR = ",";

  private final NioEventLoopGroup          _eventLoopGroup;
  private final ScheduledExecutorService   _executor;
  private final ExecutorService            _callbackExecutorGroup;
  private final boolean                    _shutdownFactory;
  private final boolean                    _shutdownExecutor;
  private final boolean                    _shutdownCallbackExecutor;
  private final FilterChain                _filters;

  private final AtomicBoolean              _finishingShutdown = new AtomicBoolean(false);
  private volatile ScheduledFuture<?>      _shutdownTimeoutTask;
  private final AbstractJmxManager         _jmxManager;

  
  private final CompressionConfig          _defaultRequestCompressionConfig;
  
  private final Map<String, CompressionConfig> _requestCompressionConfigs;
  private final boolean                    _useClientCompression;

  
  private final Object                     _mutex               = new Object();
  private boolean                          _running             = true;
  private int                              _clientsOutstanding  = 0;
  private Callback<None>                   _factoryShutdownCallback;

  
  public HttpClientFactory()
  {
    this(FilterChains.empty());
  }

  
  public HttpClientFactory(ExecutorService callbackExecutor,
                           boolean shutdownCallbackExecutor)
  {
    this(FilterChains.empty(),
         new NioEventLoopGroup(0 , new NamedThreadFactory("R2 Nio Event Loop")),
         true,
         Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler")),
         true,
         callbackExecutor,
         shutdownCallbackExecutor);
  }

  
  public HttpClientFactory(FilterChain filters)
  {
    
    
    this(filters,
         new NioEventLoopGroup(0 , new NamedThreadFactory("R2 Nio Event Loop")),
         true,
         Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler")),
         true);
  }

  
  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor)
  {
    this(filters,
         eventLoopGroup,
         shutdownFactory,
         executor,
         shutdownExecutor,
         null,
         false);
  }

  
  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor)
  {
    this(filters,
         eventLoopGroup,
         shutdownFactory,
         executor,
         shutdownExecutor,
         callbackExecutorGroup,
         shutdownCallbackExecutor,
         AbstractJmxManager.NULL_JMX_MANAGER);
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager)
  {
    this(filters, eventLoopGroup, shutdownFactory, executor, shutdownExecutor, callbackExecutorGroup,
        shutdownCallbackExecutor, jmxManager, Integer.MAX_VALUE, Collections.<String, CompressionConfig>emptyMap());
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager,
                           int requestCompressionThresholdDefault,
                           Map<String, CompressionConfig> requestCompressionConfigs)
  {
    this(filters, eventLoopGroup, shutdownFactory, executor, shutdownExecutor, callbackExecutorGroup,
        shutdownCallbackExecutor, jmxManager, requestCompressionThresholdDefault, requestCompressionConfigs,
        true);
  }

  public HttpClientFactory(FilterChain filters,
                           NioEventLoopGroup eventLoopGroup,
                           boolean shutdownFactory,
                           ScheduledExecutorService executor,
                           boolean shutdownExecutor,
                           ExecutorService callbackExecutorGroup,
                           boolean shutdownCallbackExecutor,
                           AbstractJmxManager jmxManager,
                           int requestCompressionThresholdDefault,
                           Map<String, CompressionConfig> requestCompressionConfigs,
                           boolean useClientCompression)
  {
    _filters = filters;
    _eventLoopGroup = eventLoopGroup;
    _shutdownFactory = shutdownFactory;
    _executor = executor;
    _shutdownExecutor = shutdownExecutor;
    _callbackExecutorGroup = callbackExecutorGroup;
    _shutdownCallbackExecutor = shutdownCallbackExecutor;
    _jmxManager = jmxManager;
    if (requestCompressionThresholdDefault < 0)
    {
      throw new IllegalArgumentException("requestCompressionThresholdDefault should not be negative.");
    }
    _defaultRequestCompressionConfig = new CompressionConfig(requestCompressionThresholdDefault);
    if (requestCompressionConfigs == null)
    {
      throw new IllegalArgumentException("requestCompressionConfigs should not be null.");
    }
    _requestCompressionConfigs = Collections.unmodifiableMap(requestCompressionConfigs);
    _useClientCompression = useClientCompression;
  }

  @Override
  public TransportClient getClient(Map<String, ? extends Object> properties)
  {
    SSLContext sslContext;
    SSLParameters sslParameters;

    
    properties = new HashMap<String,Object>(properties);
    sslContext = coerceAndRemoveFromMap(HTTP_SSL_CONTEXT, properties, SSLContext.class);
    sslParameters = coerceAndRemoveFromMap(HTTP_SSL_PARAMS, properties, SSLParameters.class);

    return getClient(properties, sslContext, sslParameters);
  }

  HttpNettyClient getRawClient(Map<String, String> properties)
  {
    return getRawClient(properties, null, null);
  }

  private static <T> T coerceAndRemoveFromMap(String key, Map<String, ?> props, Class<T> valueClass)
  {
    return coerce(key, props.remove(key), valueClass);
  }

  private static <T> T coerce(String key, Object value, Class<T> valueClass)
  {
    if (value == null)
    {
      return null;
    }
    if (!valueClass.isInstance(value))
    {
      throw new IllegalArgumentException(
              "Property " + key + " is of type " + value.getClass().getName() +
              " but must be " + valueClass.getName());
    }
    return valueClass.cast(value);
  }

   CompressionConfig getCompressionConfig(String httpServiceName, String requestContentEncodingName)
  {
    if (_requestCompressionConfigs.containsKey(httpServiceName))
    {
      if (requestContentEncodingName == EncodingType.IDENTITY.getHttpName())
      {
        
        
        
        
        
        LOG.warn("No request compression algorithm available but compression config specified for service {}", httpServiceName);
      }
      return _requestCompressionConfigs.get(httpServiceName);
    }
    return _defaultRequestCompressionConfig;
  }

  
  private TransportClient getClient(Map<String, ? extends Object> properties,
                                   SSLContext sslContext,
                                   SSLParameters sslParameters)
  {
    LOG.info("Getting a client with configuration {} and SSLContext {}",
             properties,
             sslContext);
    TransportClient client = getRawClient(properties, sslContext, sslParameters);

    List<String> httpResponseCompressionOperations = ConfigValueExtractor.buildList(properties.remove(HTTP_RESPONSE_COMPRESSION_OPERATIONS),
                                                                                    LIST_SEPARATOR);
    List<String> httpRequestServerSupportedEncodings = ConfigValueExtractor.buildList(properties.remove(HTTP_REQUEST_CONTENT_ENCODINGS),
                                                                                      LIST_SEPARATOR);
    FilterChain filters;

    if (_useClientCompression)
    {
      String httpServiceName = (String) properties.get(HTTP_SERVICE_NAME);
      String requestContentEncodingName = getRequestContentEncodingName(httpRequestServerSupportedEncodings);
      CompressionConfig compressionConfig = getCompressionConfig(httpServiceName, requestContentEncodingName);
      String responseCompressionSchemaName = httpResponseCompressionOperations.isEmpty() ? "" : buildAcceptEncodingSchemaNames();
      filters = _filters.addLast(new ClientCompressionFilter(requestContentEncodingName,
          compressionConfig,
          responseCompressionSchemaName,
          httpResponseCompressionOperations));
    }
    else
    {
      filters = _filters;
    }

    Integer queryPostThreshold = chooseNewOverDefault(getIntValue(properties, HTTP_QUERY_POST_THRESHOLD), Integer.MAX_VALUE);
    filters = filters.addLast(new ClientQueryTunnelFilter(queryPostThreshold));

    client = new FilterChainClient(client, filters);
    client = new FactoryClient(client);
    synchronized (_mutex)
    {
      if (!_running)
      {
        throw new IllegalStateException("Factory is shutting down");
      }
      _clientsOutstanding++;
      return client;
    }
  }

  
  private static String getRequestContentEncodingName(List<String> serverSupportedEncodings)
  {
    for (String encoding: serverSupportedEncodings)
    {
      if (EncodingType.isSupported(encoding))
      {
        return encoding;
      }
    }
    return EncodingType.IDENTITY.getHttpName();
  }

  
  private String buildAcceptEncodingSchemaNames()
  {
    List<String> schemaNames = new ArrayList<String>();
    for (EncodingType type: EncodingType.values())
    {
      
      
      if (!type.equals(EncodingType.IDENTITY) && !type.equals(EncodingType.ANY))
      {
        schemaNames.add(type.getHttpName());
      }
    }
    return StringUtils.join(schemaNames, ",");
  }

  
  private Integer getIntValue(Map<String, ? extends Object> properties, String propertyKey)
  {
    if (properties == null)
    {
      LOG.warn("passed a null raw client properties");
      return null;
    }
    if (properties.containsKey(propertyKey))
    {
      
      
      return Integer.parseInt((String)properties.get(propertyKey));
    }
    else
    {
      return null;
    }
  }

  private AsyncPoolImpl.Strategy getStrategy(Map<String, ? extends Object> properties)
  {
    if (properties == null)
    {
      LOG.warn("passed a null raw client properties");
      return null;
    }
    if (properties.containsKey(HTTP_POOL_STRATEGY))
    {
      String strategyString = (String)properties.get(HTTP_POOL_STRATEGY);
      if (strategyString.equalsIgnoreCase("LRU"))
      {
        return AsyncPoolImpl.Strategy.LRU;
      }
      else if (strategyString.equalsIgnoreCase("MRU"))
      {
        return AsyncPoolImpl.Strategy.MRU;
      }
    }
    
    return null;
  }

  
  HttpNettyClient getRawClient(Map<String, ? extends Object> properties,
                               SSLContext sslContext,
                               SSLParameters sslParameters)
  {
    Integer poolSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_SIZE), DEFAULT_POOL_SIZE);
    Integer idleTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_IDLE_TIMEOUT), DEFAULT_IDLE_TIMEOUT);
    Integer shutdownTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_SHUTDOWN_TIMEOUT), DEFAULT_SHUTDOWN_TIMEOUT);
    Integer maxResponseSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_RESPONSE_SIZE), DEFAULT_MAX_RESPONSE_SIZE);
    Integer requestTimeout = chooseNewOverDefault(getIntValue(properties, HTTP_REQUEST_TIMEOUT), DEFAULT_REQUEST_TIMEOUT);
    Integer poolWaiterSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_WAITER_SIZE), DEFAULT_POOL_WAITER_SIZE);
    String clientName = null;
    if (properties != null && properties.containsKey(HTTP_SERVICE_NAME))
    {
      clientName = (String)properties.get(HTTP_SERVICE_NAME) + "Client";
    }
    clientName = chooseNewOverDefault(clientName, DEFAULT_CLIENT_NAME);
    AsyncPoolImpl.Strategy strategy = chooseNewOverDefault(getStrategy(properties), DEFAULT_POOL_STRATEGY);
    Integer poolMinSize = chooseNewOverDefault(getIntValue(properties, HTTP_POOL_MIN_SIZE), DEFAULT_POOL_MIN_SIZE);
    Integer maxHeaderSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_HEADER_SIZE), DEFAULT_MAX_HEADER_SIZE);
    Integer maxChunkSize = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_CHUNK_SIZE), DEFAULT_MAX_CHUNK_SIZE);
    Integer maxConcurrentConnections = chooseNewOverDefault(getIntValue(properties, HTTP_MAX_CONCURRENT_CONNECTIONS), Integer.MAX_VALUE);

    return new HttpNettyClient(_eventLoopGroup,
                               _executor,
                               poolSize,
                               requestTimeout,
                               idleTimeout,
                               shutdownTimeout,
                               maxResponseSize,
                               sslContext,
                               sslParameters,
                               _callbackExecutorGroup,
                               poolWaiterSize,
                               clientName,
                               _jmxManager,
                               strategy,
                               poolMinSize,
                               maxHeaderSize,
                               maxChunkSize,
                               maxConcurrentConnections);
  }

  
  private <T> T chooseNewOverDefault(T newValue, T defaultValue)
  {
    if (newValue == null)
    {
      return defaultValue;
    }
    else
    {
      return newValue;
    }
  }


  
  @Override
  public void shutdown(final Callback<None> callback)
  {
    final int count;
    synchronized (_mutex)
    {
      _running = false;
      count = _clientsOutstanding;
      _factoryShutdownCallback = callback;
    }

    if (count == 0)
    {
      finishShutdown();
    }
    else
    {
      LOG.info("Awaiting shutdown of {} outstanding clients", count);
    }
  }

  
  public void shutdown(Callback<None> callback, long timeout, TimeUnit timeoutUnit)
  {
    
    _shutdownTimeoutTask = _executor.schedule(new Runnable()
    {
      @Override
      public void run()
      {
        LOG.warn("Shutdown timeout exceeded, proceeding with shutdown");
        finishShutdown();
      }
    }, timeout, timeoutUnit);

    
    shutdown(callback);
  }

  private void finishShutdown()
  {
    if (!_finishingShutdown.compareAndSet(false, true))
    {
      return;
    }
    if (_shutdownTimeoutTask != null)
    {
      _shutdownTimeoutTask.cancel(false);
    }

    if (_shutdownFactory)
    {
      LOG.info("Shutdown Netty Event Loop");
      _eventLoopGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS);
    }

    if (_shutdownExecutor)
    {
      
      
      
      
      
      _executor.shutdown();
      _executor.shutdownNow();
      LOG.info("Scheduler shutdown complete");
    }

    if (_shutdownCallbackExecutor)
    {
      LOG.info("Shutdown callback executor");
      _callbackExecutorGroup.shutdown();
      _callbackExecutorGroup.shutdownNow();
    }

    final Callback<None> callback;
    synchronized (_mutex)
    {
      callback = _factoryShutdownCallback;
    }

    LOG.info("Shutdown complete");
    callback.onSuccess(None.none());
  }

  private void clientShutdown()
  {
    final boolean done;
    synchronized (_mutex)
    {
      _clientsOutstanding--;
      done = !_running && _clientsOutstanding == 0;
    }
    if (done)
    {
      finishShutdown();
    }
  }

  
  private class FactoryClient implements TransportClient
  {
    private final TransportClient _client;
    private final AtomicBoolean _shutdown = new AtomicBoolean(false);

    private FactoryClient(TransportClient client)
    {
      _client = client;
    }

    @Override
    public void restRequest(RestRequest request, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            TransportCallback<RestResponse> callback)
    {
      _client.restRequest(request, requestContext, wireAttrs, callback);
    }

    @Override
    public void shutdown(final Callback<None> callback)
    {
      if (_shutdown.compareAndSet(false, true))
      {
        _client.shutdown(new Callback<None>()
        {
          @Override
          public void onSuccess(None none)
          {
            try
            {
              callback.onSuccess(none);
            }
            finally
            {
              clientShutdown();
            }
          }

          @Override
          public void onError(Throwable e)
          {
            try
            {
              callback.onError(e);
            }
            finally
            {
              clientShutdown();
            }
          }
        });
      }
      else
      {
        callback.onError(new IllegalStateException("shutdown has already been requested."));
      }
    }
  }
}

<code block>




package com.linkedin.r2.transport.http.client;

import com.linkedin.r2.transport.common.bridge.client.TransportClient;
import io.netty.channel.nio.NioEventLoopGroup;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import com.linkedin.common.callback.Callbacks;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;



public class TestHttpClientFactory
{
  private TestServer _testServer;

  @BeforeClass
  public void setup() throws IOException
  {
    _testServer = new TestServer();
  }

  @AfterClass
  public void tearDown() throws IOException, InterruptedException
  {
    _testServer.shutdown();
  }

  @Test
  public void testShutdownAfterClients() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    for (Client c : clients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      c.shutdown(callback);
      callback.get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);
    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testShutdownBeforeClients() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    for (Client c : clients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      c.shutdown(callback);
      callback.get(30, TimeUnit.SECONDS);
    }

    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testGetRawClient()
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    Map<String, String> properties = new HashMap<String, String>();

    String requestTimeout = "7000";
    String poolSize = "10";
    String maxResponse = "3000";
    String idleTimeout = "8000";
    String shutdownTimeout = "14000";
    HttpNettyClient client;

    
    client = factory.getRawClient(properties);
    Assert.assertEquals(client.getMaxResponseSize(), HttpClientFactory.DEFAULT_MAX_RESPONSE_SIZE);
    Assert.assertEquals(client.getRequestTimeout(), HttpClientFactory.DEFAULT_REQUEST_TIMEOUT);
    Assert.assertEquals(client.getShutdownTimeout(), HttpClientFactory.DEFAULT_SHUTDOWN_TIMEOUT);

    
    properties.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, requestTimeout);
    properties.put(HttpClientFactory.HTTP_POOL_SIZE, poolSize);
    properties.put(HttpClientFactory.HTTP_IDLE_TIMEOUT, idleTimeout);
    properties.put(HttpClientFactory.HTTP_MAX_RESPONSE_SIZE, maxResponse);
    properties.put(HttpClientFactory.HTTP_SHUTDOWN_TIMEOUT, shutdownTimeout);
    client = factory.getRawClient(properties);
    Assert.assertEquals(client.getMaxResponseSize(), Integer.parseInt(maxResponse));
    Assert.assertEquals(client.getRequestTimeout(), Integer.parseInt(requestTimeout));
    Assert.assertEquals(client.getShutdownTimeout(), Integer.parseInt(shutdownTimeout));
  }

  @Test
  public void testNewSSLProperties() throws Exception
  {
    HttpClientFactory factory = new HttpClientFactory();
    Map<String,Object> params = new HashMap<String, Object>();
    SSLParameters sslParameters = new SSLParameters();
    sslParameters.setProtocols(new String[]{ "Unsupported" });
    params.put(HttpClientFactory.HTTP_SSL_CONTEXT, SSLContext.getDefault());
    params.put(HttpClientFactory.HTTP_SSL_PARAMS, sslParameters);

    try
    {
      factory.getClient(Collections.unmodifiableMap(params));
      Assert.fail("Should have failed");
    }
    catch (IllegalArgumentException e)
    {
      Assert.assertTrue(e.getMessage().contains("None of the requested protocols: [Unsupported] are found in SSLContext"),
                        "Unexpected error message " + e.getMessage());
    }
  }

  @Test
  public void testSSLParams() throws Exception
  {
    HttpClientFactory factory = new HttpClientFactory();
    Map<String,Object> params = new HashMap<String, Object>();
    SSLParameters sslParameters = new SSLParameters();
    sslParameters.setProtocols(new String[]{ "Unsupported" });

    params.put(HttpClientFactory.HTTP_SSL_CONTEXT, SSLContext.getDefault());
    params.put(HttpClientFactory.HTTP_SSL_PARAMS, sslParameters);

    try
    {
      factory.getClient(Collections.unmodifiableMap(params));
      Assert.fail("Should have failed");
    }
    catch (IllegalArgumentException e)
    {
      Assert.assertTrue(e.getMessage().contains("None of the requested protocols: [Unsupported] are found in SSLContext"),
                        "Unexpected error message " + e.getMessage());
    }
  }

  @Test
  public void testShutdownTimeout() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown, 1, TimeUnit.SECONDS);

    factoryShutdown.get(30, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  @Test
  public void testShutdownNoTimeout() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    List<Client> clients = new ArrayList<Client>();
    for (int i = 0; i < 100; i++)
    {
      clients.add(new TransportClientAdapter(factory.getClient(Collections.<String, String>emptyMap())));
    }

    for (Client c : clients)
    {
      RestRequest r = new RestRequestBuilder(_testServer.getRequestURI()).build();
      c.restRequest(r).get(30, TimeUnit.SECONDS);
    }

    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    try
    {
      factoryShutdown.get(1, TimeUnit.SECONDS);
      Assert.fail("Factory shutdown should have timed out");
    }
    catch (TimeoutException e)
    {
      
    }

    Assert.assertFalse(eventLoop.isShutdown(), "Boss should not be shut down");
    Assert.assertFalse(scheduler.isShutdown(), "Scheduler should not be shut down");
  }

  @Test
  public void testShutdownIOThread() throws ExecutionException, TimeoutException, InterruptedException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, true, scheduler, true);

    Client client = new TransportClientAdapter(factory.getClient(
            Collections.<String, Object>emptyMap()));

    Future<RestResponse> responseFuture = client.restRequest(new RestRequestBuilder(_testServer.resetResponseLatch(1)).build());


    FutureCallback<None> factoryShutdown = new FutureCallback<None>();
    factory.shutdown(factoryShutdown);

    FutureCallback<None> clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);

    
    
    
    _testServer.releaseResponseLatch();

    responseFuture.get(60, TimeUnit.SECONDS);
    clientShutdown.get(60, TimeUnit.SECONDS);
    factoryShutdown.get(60, TimeUnit.SECONDS);

    Assert.assertTrue(eventLoop.awaitTermination(30, TimeUnit.SECONDS), "Failed to shut down event-loop");
    Assert.assertTrue(scheduler.awaitTermination(60, TimeUnit.SECONDS), "Failed to shut down scheduler");
  }

  
  @Test
  public void testShutdownTimeoutDoesNotOccupyExecutors()
          throws InterruptedException, ExecutionException, TimeoutException
  {
    NioEventLoopGroup eventLoop = new NioEventLoopGroup();
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    HttpClientFactory factory = new HttpClientFactory(FilterChains.empty(), eventLoop, false, scheduler, false);

    FutureCallback<None> callback = new FutureCallback<None>();
    factory.shutdown(callback, 60, TimeUnit.MINUTES);
    callback.get(60, TimeUnit.SECONDS);
    scheduler.shutdown();
    eventLoop.shutdownGracefully();
    Assert.assertTrue(scheduler.awaitTermination(60, TimeUnit.SECONDS));
    Assert.assertTrue(eventLoop.awaitTermination(60, TimeUnit.SECONDS));
  }

  @Test
  public void testRequestTimeoutConfig()
  {
    HttpClientFactory factory = new HttpClientFactory();

    try
    {
      Map<String,String> config = new HashMap<String, String>();

      config.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, "999");
      HttpNettyClient client = factory.getRawClient(config);
      Assert.assertEquals(client.getRequestTimeout(), 999);


      config.put(HttpClientFactory.HTTP_REQUEST_TIMEOUT, "888");
      client = factory.getRawClient(config);
      Assert.assertEquals(client.getRequestTimeout(), 888);

    }
    finally
    {
      factory.shutdown(Callbacks.<None>empty());
    }

  }

  @Test
  public void testClientShutdownBeingCalledMultipleTimes()
      throws InterruptedException, ExecutionException, TimeoutException
  {
    HttpClientFactory factory = new HttpClientFactory();
    TransportClient client = factory.getClient(Collections.<String, Object>emptyMap());
    
    FutureCallback<None> clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);
    clientShutdown.get(30, TimeUnit.SECONDS);
    
    clientShutdown = new FutureCallback<None>();
    client.shutdown(clientShutdown);
    try
    {
      clientShutdown.get(30, TimeUnit.SECONDS);
      Assert.fail("should have thrown exception on the second shutdown call.");
    }
    catch (ExecutionException ex)
    {
      Assert.assertTrue(ex.getCause() instanceof IllegalStateException);
    }

    FutureCallback<None> shutdownCallback = new FutureCallback<None>();
    factory.shutdown(shutdownCallback);
    shutdownCallback.get(30, TimeUnit.SECONDS);
  }

  @DataProvider(name = "compressionConfigsData")
  private Object[][] compressionConfigsData()
  {
    return new Object[][] {
        {"service1", 10000, new CompressionConfig(0)},
        {"service2", 10000, new CompressionConfig(Integer.MAX_VALUE)},
        {"service3", 10000, new CompressionConfig(111)},
        {"service4", 10000, new CompressionConfig(10000)},
        {"service1", 0, new CompressionConfig(0)},
        {"service2", 0, new CompressionConfig(Integer.MAX_VALUE)},
        {"service3", 0, new CompressionConfig(111)},
        {"service4", 0, new CompressionConfig(0)}
    };
  }

  @Test(dataProvider = "compressionConfigsData")
  public void testGetCompressionConfig(String serviceName, int requestCompressionThresholdDefault, CompressionConfig expectedConfig)
  {
    Map<String, CompressionConfig> requestCompressionConfigs = new HashMap<String, CompressionConfig>();
    requestCompressionConfigs.put("service1", new CompressionConfig(0));
    requestCompressionConfigs.put("service2", new CompressionConfig(Integer.MAX_VALUE));
    requestCompressionConfigs.put("service3", new CompressionConfig(111));
    HttpClientFactory factory = new HttpClientFactory(null, null, true, null, true, null, true, null,
        requestCompressionThresholdDefault, requestCompressionConfigs);
    Assert.assertEquals(factory.getCompressionConfig(serviceName, EncodingType.SNAPPY.getHttpName()), expectedConfig);
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.parseq.Engine;
import com.linkedin.parseq.EngineBuilder;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.transport.common.bridge.server.TransportDispatcher;
import com.linkedin.r2.transport.http.server.HttpServer;
import com.linkedin.r2.transport.http.server.HttpServerFactory;
import com.linkedin.restli.docgen.DefaultDocumentationRequestHandler;
import com.linkedin.restli.examples.groups.server.api.GroupMembershipMgr;
import com.linkedin.restli.examples.groups.server.api.GroupMgr;
import com.linkedin.restli.examples.groups.server.impl.HashGroupMembershipMgr;
import com.linkedin.restli.examples.groups.server.impl.HashMapGroupMgr;
import com.linkedin.restli.examples.groups.server.rest.impl.GroupsRestApplication;
import com.linkedin.restli.server.DelegatingTransportDispatcher;
import com.linkedin.restli.server.ParseqTraceDebugRequestHandler;
import com.linkedin.restli.server.RestLiConfig;
import com.linkedin.restli.server.RestLiServer;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.server.mock.InjectMockResourceFactory;
import com.linkedin.restli.server.mock.SimpleBeanProvider;
import com.linkedin.restli.server.resources.ResourceFactory;

import java.io.IOException;
import java.net.URI;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;



public class RestLiIntTestServer
{
  public static final int      DEFAULT_PORT           = 1338;
  public static final int      NO_COMPRESSION_PORT    = 1339;
  public static final int      FILTERS_PORT           = 1340;
  public static final String   supportedCompression   = "gzip,snappy,bzip2,deflate";
  public static final String[] RESOURCE_PACKAGE_NAMES = {
      "com.linkedin.restli.examples.groups.server.rest.impl",
      "com.linkedin.restli.examples.greetings.server",
      "com.linkedin.restli.examples.typeref.server"  };

  public static void main(String[] args) throws IOException
  {
    final int numCores = Runtime.getRuntime().availableProcessors();
    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(numCores + 1);
    final Engine engine = new EngineBuilder()
        .setTaskExecutor(scheduler)
        .setTimerScheduler(scheduler)
        .build();

    HttpServer server = createServer(engine, DEFAULT_PORT, supportedCompression);
    server.start();

    System.out.println("HttpServer running on port " + DEFAULT_PORT + ". Press any key to stop server");
    System.in.read();

    server.stop();
    engine.shutdown();
  }

  public static HttpServer createServer(final Engine engine, int port, String supportedCompression)
  {
    return createServer(engine, port, supportedCompression, false, -1);
  }

  public static HttpServer createServer(final Engine engine,
                                        int port,
                                        String supportedCompression,
                                        boolean useAsyncServletApi,
                                        int asyncTimeOut)
  {
    return createServer(engine, port, supportedCompression, useAsyncServletApi, asyncTimeOut, null, null);
  }

  public static HttpServer createServer(final Engine engine,
                                        int port,
                                        String supportedCompression,
                                        boolean useAsyncServletApi,
                                        int asyncTimeOut,
                                        List<? extends RequestFilter> requestFilters,
                                        List<? extends ResponseFilter> responseFilters)
  {
    final FilterChain fc = FilterChains.empty().addLast(new ServerCompressionFilter(supportedCompression))
        .addLast(new SimpleLoggingFilter());
    return createServer(engine, port, useAsyncServletApi, asyncTimeOut, requestFilters, responseFilters, fc);
  }

  public static HttpServer createServer(final Engine engine,
                                        int port,
                                        boolean useAsyncServletApi,
                                        int asyncTimeOut,
                                        List<? extends RequestFilter> requestFilters,
                                        List<? extends ResponseFilter> responseFilters,
                                        final FilterChain filterChain)
  {
    RestLiConfig config = new RestLiConfig();
    config.addResourcePackageNames(RESOURCE_PACKAGE_NAMES);
    config.setServerNodeUri(URI.create("http:
    config.setDocumentationRequestHandler(new DefaultDocumentationRequestHandler());
    config.addDebugRequestHandlers(new ParseqTraceDebugRequestHandler());
    config.setRequestFilters(requestFilters);
    config.setResponseFilters(responseFilters);

    GroupMembershipMgr membershipMgr = new HashGroupMembershipMgr();
    GroupMgr groupMgr = new HashMapGroupMgr(membershipMgr);
    GroupsRestApplication app = new GroupsRestApplication(groupMgr, membershipMgr);
    SimpleBeanProvider beanProvider = new SimpleBeanProvider();
    beanProvider.add("GroupsRestApplication", app);
    
    ResourceFactory factory = new InjectMockResourceFactory(beanProvider);

    TransportDispatcher dispatcher = new DelegatingTransportDispatcher(new RestLiServer(config, factory, engine));

    return new HttpServerFactory(filterChain).createServer(port,
                                                           HttpServerFactory.DEFAULT_CONTEXT_PATH,
                                                           HttpServerFactory.DEFAULT_THREAD_POOL_SIZE,
                                                           dispatcher,
                                                           useAsyncServletApi,
                                                           asyncTimeOut);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.r2.filter.CompressionOption;

import java.util.List;



public class RestliRequestOptions
{
  private final ProtocolVersionOption _protocolVersionOption;
  private final CompressionOption _requestCompressionOverride;
  private final RestClient.ContentType _contentType;
  private final List<RestClient.AcceptType> _acceptTypes;


  public static final RestliRequestOptions DEFAULT_OPTIONS
      = new RestliRequestOptions(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE, null);

  public static final RestliRequestOptions FORCE_USE_NEXT_OPTION =
      new RestliRequestOptions(ProtocolVersionOption.FORCE_USE_NEXT, null);

  
  RestliRequestOptions(ProtocolVersionOption protocolVersionOption, CompressionOption requestCompressionOverride)
  {
    this(protocolVersionOption, requestCompressionOverride, null, null);
  }

  
  RestliRequestOptions(ProtocolVersionOption protocolVersionOption,
                       CompressionOption requestCompressionOverride,
                       RestClient.ContentType contentType,
                       List<RestClient.AcceptType> acceptTypes)
  {
    _protocolVersionOption =
        (protocolVersionOption == null) ? ProtocolVersionOption.USE_LATEST_IF_AVAILABLE : protocolVersionOption;
    _requestCompressionOverride = requestCompressionOverride;
    _contentType = contentType;
    _acceptTypes = acceptTypes;
  }

  public ProtocolVersionOption getProtocolVersionOption()
  {
    return _protocolVersionOption;
  }

  public CompressionOption getRequestCompressionOverride()
  {
    return _requestCompressionOverride;
  }

  public List<RestClient.AcceptType> getAcceptTypes()
  {
    return _acceptTypes;
  }

  public RestClient.ContentType getContentType()
  {
    return _contentType;
  }

  @Override
  public int hashCode()
  {
    int result = _protocolVersionOption != null ? _protocolVersionOption.hashCode() : 0;
    result = 31 * result + (_requestCompressionOverride != null ? _requestCompressionOverride.hashCode() : 0);
    result = 31 * result + (_contentType != null ? _contentType.hashCode() : 0);
    result = 31 * result + (_acceptTypes != null ? _acceptTypes.hashCode() : 0);
    return result;
  }

  @Override
  public boolean equals(Object obj)
  {
    if (obj == this)
    {
      return true;
    }
    if (obj == null)
    {
      return false;
    }
    if (!(obj instanceof RestliRequestOptions))
    {
      return false;
    }
    RestliRequestOptions other = (RestliRequestOptions)obj;
    if (_protocolVersionOption != other._protocolVersionOption)
    {
      return false;
    }
    if (_requestCompressionOverride != other._requestCompressionOverride)
    {
      return false;
    }
    if (_contentType != other._contentType)
    {
      return false;
    }
    if (_acceptTypes != null ? !_acceptTypes.equals(other._acceptTypes) : other._acceptTypes != null)
    {
      return false;
    }
    return true;
  }

  @Override
  public String toString()
  {
    return "{_protocolVersionOption: "
        + _protocolVersionOption.toString()
        + ", _requestCompressionOverride: "
        + (_requestCompressionOverride != null ? _requestCompressionOverride.toString() : "null")
        + ", _contentType: "
        + (_contentType != null ? _contentType.toString() : "null")
        + ", _acceptTypes: "
        + (_acceptTypes != null ? _acceptTypes.toString() : "null")
        + "}";
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.r2.filter.CompressionOption;

import java.util.Collections;
import java.util.List;



public class RestliRequestOptionsBuilder
{
  private ProtocolVersionOption _protocolVersionOption;
  private CompressionOption _requestCompressionOverride;
  private RestClient.ContentType _contentType;
  private List<RestClient.AcceptType> _acceptTypes;

  public RestliRequestOptionsBuilder()
  {

  }

  public RestliRequestOptionsBuilder(RestliRequestOptions restliRequestOptions)
  {
    setProtocolVersionOption(restliRequestOptions.getProtocolVersionOption());
    setRequestCompressionOverride(restliRequestOptions.getRequestCompressionOverride());
    setContentType(restliRequestOptions.getContentType());
    setAcceptTypes(restliRequestOptions.getAcceptTypes());
  }

  public RestliRequestOptionsBuilder setProtocolVersionOption(ProtocolVersionOption protocolVersionOption)
  {
    _protocolVersionOption = protocolVersionOption;
    return this;
  }

  public RestliRequestOptionsBuilder setRequestCompressionOverride(CompressionOption requestCompressionOverride)
  {
    _requestCompressionOverride = requestCompressionOverride;
    return this;
  }

  public RestliRequestOptionsBuilder setContentType(RestClient.ContentType contentType)
  {
    _contentType = contentType;
    return this;
  }

  public RestliRequestOptionsBuilder setAcceptTypes(List<RestClient.AcceptType> acceptTypes)
  {
    _acceptTypes = Collections.unmodifiableList(acceptTypes);
    return this;
  }

  public RestliRequestOptions build()
  {
    return new RestliRequestOptions(_protocolVersionOption, _requestCompressionOverride, _contentType, _acceptTypes);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.callback.CallbackAdapter;
import com.linkedin.common.callback.Callbacks;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.codec.PsonDataCodec;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.client.multiplexer.MultiplexedCallback;
import com.linkedin.restli.client.multiplexer.MultiplexedRequest;
import com.linkedin.restli.client.multiplexer.MultiplexedResponse;
import com.linkedin.restli.client.uribuilders.MultiplexerUriBuilder;
import com.linkedin.restli.client.uribuilders.RestliUriBuilderUtil;
import com.linkedin.restli.common.HttpMethod;
import com.linkedin.restli.common.OperationNameGenerator;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.client.ExceptionUtil;
import com.linkedin.restli.internal.client.RequestBodyTransformer;
import com.linkedin.restli.internal.client.ResponseFutureImpl;
import com.linkedin.restli.internal.client.RestResponseDecoder;
import com.linkedin.restli.internal.common.AllProtocolVersions;

import javax.mail.internet.ParseException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;



public class RestClient
{
  private static final JacksonDataCodec  JACKSON_DATA_CODEC = new JacksonDataCodec();
  private static final PsonDataCodec     PSON_DATA_CODEC    = new PsonDataCodec();
  private static final List<AcceptType>  DEFAULT_ACCEPT_TYPES = Collections.emptyList();
  private static final ContentType DEFAULT_CONTENT_TYPE = ContentType.JSON;
  private static final Random RANDOM_INSTANCE = new Random();
  private final Client _client;

  private final String _uriPrefix;
  private final List<AcceptType> _acceptTypes;
  private final ContentType _contentType;
  
  
  
  private final boolean _forceUseNextVersionOverride =
      "true".equalsIgnoreCase(System.getProperty(RestConstants.RESTLI_FORCE_USE_NEXT_VERSION_OVERRIDE));

  public RestClient(Client client, String uriPrefix)
  {
    this(client, uriPrefix, DEFAULT_CONTENT_TYPE, DEFAULT_ACCEPT_TYPES);
  }

  
  @Deprecated
  public RestClient(Client client, String uriPrefix, List<AcceptType> acceptTypes)
  {
    this(client, uriPrefix, DEFAULT_CONTENT_TYPE, acceptTypes);
  }

  
  @Deprecated
  public RestClient(Client client, String uriPrefix, ContentType contentType, List<AcceptType> acceptTypes)
  {
    _client = client;
    _uriPrefix = (uriPrefix == null) ? null : uriPrefix.trim();
    _acceptTypes = acceptTypes;
    _contentType = contentType;
  }

  
  public void shutdown(Callback<None> callback)
  {
    _client.shutdown(callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request,
                                           RequestContext requestContext)
  {
    FutureCallback<Response<T>> callback = new FutureCallback<Response<T>>();
    sendRequest(request, requestContext, callback);
    return new ResponseFutureImpl<T>(callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request,
                                           RequestContext requestContext,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    FutureCallback<Response<T>> callback = new FutureCallback<Response<T>>();
    sendRequest(request, requestContext, callback);
    return new ResponseFutureImpl<T>(callback, errorHandlingBehavior);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           RequestContext requestContext)
  {
    return sendRequest(requestBuilder.build(), requestContext);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           RequestContext requestContext,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(requestBuilder.build(), requestContext, errorHandlingBehavior);
  }

  
  public <T> void sendRequest(final Request<T> request,
                              RequestContext requestContext,
                              Callback<Response<T>> callback)
  {
    sendRestRequest(request, requestContext, new RestLiCallbackAdapter<T>(request.getResponseDecoder(), callback));
  }

  
  public <T> void sendRestRequest(final Request<T> request,
                                  RequestContext requestContext,
                                  Callback<RestResponse> callback)
  {
    RecordTemplate input = request.getInputRecord();
    ProtocolVersion protocolVersion = getProtocolVersionForService(request);
    URI requestUri = RestliUriBuilderUtil.createUriBuilder(request, _uriPrefix, protocolVersion).build();

    sendRequestImpl(requestContext,
                    requestUri,
                    request.getMethod(),
                    input != null ? RequestBodyTransformer.transform(request, protocolVersion) : null,
                    request.getHeaders(),
                    request.getMethodName(),
                    protocolVersion,
                    request.getRequestOptions().getRequestCompressionOverride(),
                    request.getRequestOptions().getContentType(),
                    request.getRequestOptions().getAcceptTypes(),
                    callback);
  }

  
  private ProtocolVersion getProtocolVersionForService(final Request<?> request)
  {
    try
    {
      return getProtocolVersion(AllProtocolVersions.BASELINE_PROTOCOL_VERSION,
                                AllProtocolVersions.LATEST_PROTOCOL_VERSION,
                                AllProtocolVersions.NEXT_PROTOCOL_VERSION,
                                getAnnouncedVersion(_client.getMetadata(new URI(_uriPrefix + request.getServiceName()))),
                                request.getRequestOptions().getProtocolVersionOption(),
                                _forceUseNextVersionOverride);
    }
    catch (URISyntaxException e)
    {
      throw new RuntimeException("Failed to create a valid URI to fetch properties for!");
    }
  }

  
   static ProtocolVersion getAnnouncedVersion(Map<String, Object> properties)
  {
    if(properties == null)
    {
      throw new RuntimeException("No valid properties found!");
    }
    Object potentialAnnouncedVersion = properties.get(RestConstants.RESTLI_PROTOCOL_VERSION_PROPERTY);
    
    if(potentialAnnouncedVersion == null)
    {
      return AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
    Object potentialAnnouncedVersionPercentage = properties.get(RestConstants.RESTLI_PROTOCOL_VERSION_PERCENTAGE_PROPERTY);
    
    if(potentialAnnouncedVersionPercentage == null)
    {
      return new ProtocolVersion(potentialAnnouncedVersion.toString());
    }
    try
    {
      int announceVersionPercentage = Integer.parseInt(potentialAnnouncedVersionPercentage.toString());
      
      return (announceVersionPercentage > 0 && announceVersionPercentage <= 100 && RANDOM_INSTANCE.nextInt(100) + 1 <= announceVersionPercentage) ?
          new ProtocolVersion(potentialAnnouncedVersion.toString()) : AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
    catch(NumberFormatException e)
    {
      
      return AllProtocolVersions.BASELINE_PROTOCOL_VERSION;
    }
  }

  
  static ProtocolVersion getProtocolVersion(ProtocolVersion baselineProtocolVersion,
                                                               ProtocolVersion latestVersion,
                                                               ProtocolVersion nextVersion,
                                                               ProtocolVersion announcedVersion,
                                                               ProtocolVersionOption versionOption,
                                                               boolean forceUseNextVersionOverride)
  {
    if (versionOption == null)
    {
      throw new IllegalArgumentException("versionOptions cannot be null!");
    }
    if (forceUseNextVersionOverride)
    {
      return nextVersion;
    }
    switch (versionOption)
    {
      case FORCE_USE_NEXT:
        return nextVersion;
      case FORCE_USE_LATEST:
        return latestVersion;
      case USE_LATEST_IF_AVAILABLE:
        if (announcedVersion.compareTo(baselineProtocolVersion) == -1)
        {
          
          throw new RuntimeException("Announced version is less than the default version!" +
            "Announced version: " + announcedVersion + ", default version: " + baselineProtocolVersion);
        }
        else if (announcedVersion.compareTo(baselineProtocolVersion) == 0)
        {
          
          return baselineProtocolVersion;
        }
        else if (announcedVersion.compareTo(latestVersion) == -1)
        {
          
          return announcedVersion;
        }
        
        return latestVersion;
      default:
        return baselineProtocolVersion;
    }
  }

  
  
  
  
  private void addAcceptHeaders(RestRequestBuilder builder, List<AcceptType> acceptTypes)
  {
    if (builder.getHeader(RestConstants.HEADER_ACCEPT) == null)
    {
      List<AcceptType> types = _acceptTypes;
      if (acceptTypes != null && !acceptTypes.isEmpty())
      {
        types = acceptTypes;
      }
      if (types != null && !types.isEmpty())
      {
        builder.setHeader(RestConstants.HEADER_ACCEPT, createAcceptHeader(types));
      }
    }
  }

  private String createAcceptHeader(List<AcceptType> acceptTypes)
  {
    if (acceptTypes.size() == 1)
    {
      return acceptTypes.get(0).getHeaderKey();
    }

    
    StringBuilder acceptHeader = new StringBuilder();
    double currQ = 1.0;
    Iterator<AcceptType> iterator = acceptTypes.iterator();
    while(iterator.hasNext())
    {
      acceptHeader.append(iterator.next().getHeaderKey());
      acceptHeader.append(";q=");
      acceptHeader.append(currQ);
      currQ -= .1;
      if (iterator.hasNext())
        acceptHeader.append(",");
    }

    return acceptHeader.toString();
  }


  
  
  
  
  private void addEntityAndContentTypeHeaders(RestRequestBuilder builder, DataMap dataMap, ContentType contentType)
    throws IOException
  {
    if (dataMap != null)
    {
      String header = builder.getHeader(RestConstants.HEADER_CONTENT_TYPE);

      ContentType type;
      if(header == null)
      {
        if (contentType != null)
        {
          type = contentType;
        }
        else if (_contentType != null)
        {
          type = _contentType;
        }
        else {
          type = DEFAULT_CONTENT_TYPE;
        }
        builder.setHeader(RestConstants.HEADER_CONTENT_TYPE, type.getHeaderKey());
      }
      else
      {
        javax.mail.internet.ContentType headerContentType;
        try
        {
          headerContentType = new javax.mail.internet.ContentType(header);
        }
        catch (ParseException e)
        {
          throw new IllegalStateException("Unable to parse Content-Type: " + header);
        }

        if (headerContentType.getBaseType().equalsIgnoreCase(RestConstants.HEADER_VALUE_APPLICATION_JSON))
        {
          type = ContentType.JSON;
        }
        else if (headerContentType.getBaseType().equalsIgnoreCase(RestConstants.HEADER_VALUE_APPLICATION_PSON))
        {
          type = ContentType.PSON;
        }
        else
        {
          throw new IllegalStateException("Unknown Content-Type: " + headerContentType.toString());
        }
      }

      switch (type)
      {
        case PSON:
          builder.setEntity(PSON_DATA_CODEC.mapToBytes(dataMap));
          break;
        case JSON:
          builder.setEntity(JACKSON_DATA_CODEC.mapToBytes(dataMap));
          break;
        default:
          throw new IllegalStateException("Unknown ContentType:" + type);
      }
    }

  }

  
  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder,
                              RequestContext requestContext,
                              Callback<Response<T>> callback)
  {
    sendRequest(requestBuilder.build(), requestContext, callback);
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request)
  {
    return sendRequest(request, new RequestContext());
  }

  
  public <T> ResponseFuture<T> sendRequest(Request<T> request, ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(request, new RequestContext(), errorHandlingBehavior);
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder)
  {
    return sendRequest(requestBuilder.build(), new RequestContext());
  }

  
  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,
                                           ErrorHandlingBehavior errorHandlingBehavior)
  {
    return sendRequest(requestBuilder.build(), new RequestContext(), errorHandlingBehavior);
  }

  
  public <T> void sendRequest(final Request<T> request, Callback<Response<T>> callback)
  {
    sendRequest(request, new RequestContext(), callback);
  }

  
  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder, Callback<Response<T>> callback)
  {
    sendRequest(requestBuilder.build(), new RequestContext(), callback);
  }

  
  public void sendRequest(MultiplexedRequest multiplexedRequest)
  {
    sendRequest(multiplexedRequest, Callbacks.<MultiplexedResponse>empty());
  }

  
  public void sendRequest(MultiplexedRequest multiplexedRequest, Callback<MultiplexedResponse> callback)
  {
    MultiplexedCallback muxCallback = new MultiplexedCallback(multiplexedRequest.getCallbacks(), callback);
    try
    {
      RestRequest restRequest = buildMultiplexedRequest(multiplexedRequest);
      RequestContext requestContext = new RequestContext();
      _client.restRequest(restRequest, requestContext, muxCallback);
    }
    catch (Exception e)
    {
      muxCallback.onError(e);
    }
  }

  private RestRequest buildMultiplexedRequest(MultiplexedRequest multiplexedRequest) throws IOException
  {
    URI requestUri = new MultiplexerUriBuilder(_uriPrefix).build();
    RestRequestBuilder requestBuilder = new RestRequestBuilder(requestUri).setMethod(HttpMethod.POST.toString());
    addAcceptHeaders(requestBuilder, Collections.singletonList(AcceptType.JSON));
    addEntityAndContentTypeHeaders(requestBuilder, multiplexedRequest.getContent().data(), ContentType.JSON);
    return requestBuilder.build();
  }

  
  private void sendRequestImpl(RequestContext requestContext,
                               URI uri,
                               ResourceMethod method,
                               DataMap dataMap,
                               Map<String, String> headers,
                               String methodName,
                               ProtocolVersion protocolVersion,
                               CompressionOption requestCompressionOverride,
                               ContentType contentType,
                               List<AcceptType> acceptTypes,
                               Callback<RestResponse> callback)
  {
    try
    {
      RestRequest request = buildRequest(uri, method, dataMap, headers, protocolVersion, contentType, acceptTypes);
      String operation = OperationNameGenerator.generate(method, methodName);
      requestContext.putLocalAttr(R2Constants.OPERATION, operation);
      requestContext.putLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE, requestCompressionOverride);
      _client.restRequest(request, requestContext, callback);
    }
    catch (Exception e)
    {
      
      callback.onError(e);
    }
  }

  
  
  private RestRequest buildRequest(URI uri,
                                   ResourceMethod method,
                                   DataMap dataMap,
                                   Map<String, String> headers,
                                   ProtocolVersion protocolVersion,
                                   ContentType contentType,
                                   List<AcceptType> acceptTypes) throws Exception
  {
    RestRequestBuilder requestBuilder = new RestRequestBuilder(uri).setMethod(
            method.getHttpMethod().toString());

    requestBuilder.setHeaders(headers);
    addAcceptHeaders(requestBuilder, acceptTypes);
    addEntityAndContentTypeHeaders(requestBuilder, dataMap, contentType);
    addProtocolVersionHeader(requestBuilder, protocolVersion);

    if (method.getHttpMethod() == HttpMethod.POST)
    {
      requestBuilder.setHeader(RestConstants.HEADER_RESTLI_REQUEST_METHOD, method.toString());
    }

    return requestBuilder.build();
  }

  
  private void addProtocolVersionHeader(RestRequestBuilder builder, ProtocolVersion protocolVersion)
  {
    builder.setHeader(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
  }

  public static enum AcceptType
  {
    PSON(RestConstants.HEADER_VALUE_APPLICATION_PSON),
    JSON(RestConstants.HEADER_VALUE_APPLICATION_JSON),
    ANY(RestConstants.HEADER_VALUE_ACCEPT_ANY);

    private String _headerKey;

    private AcceptType(String headerKey)
    {
      _headerKey = headerKey;
    }

    public String getHeaderKey()
    {
      return _headerKey;
    }
  }

  public static enum ContentType
  {
    PSON(RestConstants.HEADER_VALUE_APPLICATION_PSON),
    JSON(RestConstants.HEADER_VALUE_APPLICATION_JSON);

    private String _headerKey;

    private ContentType(String headerKey)
    {
      _headerKey = headerKey;
    }

    public String getHeaderKey()
    {
      return _headerKey;
    }
  }

}

<code block>


package com.linkedin.restli.client;


import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.restli.client.test.TestRecord;
import com.linkedin.restli.common.ComplexResourceKey;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.ResourceProperties;
import com.linkedin.restli.common.ResourceSpec;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.internal.client.EntityResponseDecoder;
import com.linkedin.restli.internal.common.ResourcePropertiesImpl;

import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.testng.Assert;
import org.testng.annotations.Test;


public class TestRequest
{
  @Test
  public void testToSecureString()
  {
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);

    Request<TestRecord> request = builder.id(5L).build();

    Assert.assertEquals(
        request.toSecureString(),
        "com.linkedin.restli.client.GetRequest{_method=get, _baseUriTemplate=abc, _methodName=null, _requestOptions={_protocolVersionOption: USE_LATEST_IF_AVAILABLE, _requestCompressionOverride: null, _contentType: null, _acceptTypes: null}}");
  }

  @Test
  public void testHeadersCaseInsensitiveGet()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder.id(id).addHeader("header", "value").build();
    Assert.assertEquals(request.getHeaders().get("HEADER"), "value");
  }

  @Test
  public void testHeadersCaseInsensitiveAdd()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder
        .id(id)
        .addHeader("header", "value1")
        .addHeader("HEADER", "value2")
        .build();
    Assert.assertEquals(request.getHeaders().get("HEADER"), "value1,value2");
  }

  @Test
  public void testHeadersCaseInsensitiveSet()
  {
    final long id = 42l;
    final ResourceSpec spec = new ResourceSpecImpl(
        EnumSet.allOf(ResourceMethod.class),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Collections.<String, DynamicRecordMetadata> emptyMap(),
        Long.class,
        null,
        null,
        TestRecord.class,
        Collections.<String, Class<?>> emptyMap());
    GetRequestBuilder<Long, TestRecord> builder = new GetRequestBuilder<Long, TestRecord>(
        "abc",
        TestRecord.class,
        spec,
        RestliRequestOptions.DEFAULT_OPTIONS);
    Request<TestRecord> request = builder
        .id(id)
        .setHeader("header", "value1")
        .setHeader("HEADER", "value2")
        .build();
    Assert.assertEquals(request.getHeaders().get("header"), "value2");
  }

  @Test
  public void testResourceProperties()
  {
    Set<ResourceMethod> expectedSupportedMethods = new HashSet<ResourceMethod>();
    expectedSupportedMethods.add(ResourceMethod.GET);
    expectedSupportedMethods.add(ResourceMethod.BATCH_PARTIAL_UPDATE);

    ResourceSpec expectedResourceSpec = new ResourceSpecImpl(
                                          expectedSupportedMethods,
                                          null,
                                          null,
                                          ComplexResourceKey.class,
                                          TestRecord.class,
                                          TestRecord.class,
                                          TestRecord.class,
                                          Collections.<String, Object>emptyMap());

    Map<String, Object> pathKeys = new HashMap<String, Object>();
    pathKeys.put("id", new ComplexResourceKey<TestRecord, TestRecord>(new TestRecord(), new TestRecord()));


    Request<TestRecord> request = new Request<TestRecord>(ResourceMethod.GET,
                                                          null,
                                                          Collections.<String, String>emptyMap(),
                                                          new EntityResponseDecoder<TestRecord>(TestRecord.class),
                                                          expectedResourceSpec,
                                                          Collections.<String, Object>emptyMap(),
                                                          Collections.<String, Class<?>>emptyMap(),
                                                          null,
                                                          "testRecord",
                                                          pathKeys,
                                                          RestliRequestOptions.DEFAULT_OPTIONS);

    ResourceProperties expectedResourceProperties =
        new ResourcePropertiesImpl(expectedResourceSpec.getSupportedMethods(),
                                   expectedResourceSpec.getKeyType(),
                                   expectedResourceSpec.getComplexKeyType(),
                                   expectedResourceSpec.getValueType(),
                                   expectedResourceSpec.getKeyParts());

    Assert.assertEquals(request.getResourceProperties(), expectedResourceProperties);
  }
}

<code block>


package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.data.DataMap;
import com.linkedin.data.template.DynamicRecordMetadata;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.common.CollectionRequest;
import com.linkedin.restli.common.CompoundKey;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.ResourceMethod;
import com.linkedin.restli.common.ResourceSpec;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.common.TypeSpec;
import com.linkedin.restli.internal.client.RestResponseDecoder;
import com.linkedin.restli.internal.common.ResourcePropertiesImpl;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;




public class TestRestClientRequestBuilder
{

  private static final DataMap ENTITY_BODY = new DataMap();
  private static final String  JSON_ENTITY_BODY = "{\"testFieldName\":\"testValue\",\"testInteger\":1}";
  private static final String  PSON_ENTITY_BODY = "#!PSON1\n!\u0081testFieldName\u0000\n\n\u0000\u0000\u0000testValue\u0000\u0083testInteger\u0000\u0002\u0001\u0000\u0000\u0000\u0080";
  private static final String JSON_ENTITIES_BODY = "{\"entities\":{}}";
  private static final String PSON_ENTITIES_BODY = "#!PSON1\n" + "!\u0081entities\u0000 \u0080";
  private static final String  CONTENT_TYPE_HEADER = "Content-Type";
  private static final String  ACCEPT_TYPE_HEADER = "Accept";
  private static final String HOST = "host";
  private static final String SERVICE_NAME = "foo";
  private static final String BASE_URI_TEMPLATE = "/foo";

  static
  {
    ENTITY_BODY.put("testFieldName", "testValue");
    ENTITY_BODY.put("testInteger", 1);
  }

  @Test(dataProvider = "data")
  public void testGet(RestClient.ContentType contentType,
                      String expectedContentTypeHeader,
                      String expectedRequestBody,
                      String expectedEntitiesBody,
                      List<RestClient.AcceptType> acceptTypes,
                      String expectedAcceptHeader,
                      boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(GetRequest.class, ResourceMethod.GET, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchGetRequest.class, ResourceMethod.BATCH_GET, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestBatch.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestBatch.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

  }

  @Test(dataProvider = "data")
  public void testFinder(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(FindRequest.class, ResourceMethod.FINDER, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestAll = clientGeneratedRequest(GetAllRequest.class, ResourceMethod.GET_ALL, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestAll.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestAll.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testAction(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(ActionRequest.class,
                                                     ResourceMethod.ACTION,
                                                     ENTITY_BODY,
                                                     contentType,
                                                     acceptTypes,
                                                     acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestNoEntity = clientGeneratedRequest(ActionRequest.class, ResourceMethod.ACTION, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestNoEntity.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestNoEntity.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testUpdate(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(UpdateRequest.class, ResourceMethod.UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchUpdateRequest.class, ResourceMethod.BATCH_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatch.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatch.getEntity().asAvroString(), expectedEntitiesBody);
    Assert.assertEquals(restRequestBatch.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestPartial = clientGeneratedRequest(PartialUpdateRequest.class, ResourceMethod.PARTIAL_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestPartial.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestPartial.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequestPartial.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatchPartial = clientGeneratedRequest(BatchPartialUpdateRequest.class, ResourceMethod.BATCH_PARTIAL_UPDATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatchPartial.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatchPartial.getEntity().asAvroString(), expectedEntitiesBody);
    Assert.assertEquals(restRequestBatchPartial.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testCreate(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(CreateRequest.class, ResourceMethod.CREATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequest.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequest.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchCreateRequest.class, ResourceMethod.BATCH_CREATE, ENTITY_BODY, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertEquals(restRequestBatch.getHeader(CONTENT_TYPE_HEADER), expectedContentTypeHeader);
    Assert.assertEquals(restRequestBatch.getEntity().asAvroString(), expectedRequestBody);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @Test(dataProvider = "data")
  public void testDelete(RestClient.ContentType contentType,
                         String expectedContentTypeHeader,
                         String expectedRequestBody,
                         String expectedEntitiesBody,
                         List<RestClient.AcceptType> acceptTypes,
                         String expectedAcceptHeader,
                         boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    RestRequest restRequest = clientGeneratedRequest(DeleteRequest.class, ResourceMethod.DELETE, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequest.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequest.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);

    RestRequest restRequestBatch = clientGeneratedRequest(BatchDeleteRequest.class, ResourceMethod.BATCH_DELETE, null, contentType, acceptTypes, acceptContentTypePerClient);
    Assert.assertNull(restRequestBatch.getHeader(CONTENT_TYPE_HEADER));
    Assert.assertEquals(restRequestBatch.getEntity().length(), 0);
    Assert.assertEquals(restRequest.getHeader(ACCEPT_TYPE_HEADER), expectedAcceptHeader);
  }

  @DataProvider(name = "data")
  public Object[][] contentTypeData()
  {
    return new Object[][]
      {
        
        
        
        
        
        
        
        
        
        
        
        {
          null,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          null,
          null,
          true
        }, 
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.<RestClient.AcceptType>emptyList(),
          null,
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.<RestClient.AcceptType>emptyList(),
          null,
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.ANY),
          "**",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.JSON),
          "application/json",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.JSON),
          "application/json",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.PSON),
          "application/x-pson",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.PSON),
          "application/x-pson",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON),
          "application/json;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON),
          "application/json;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,**;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.JSON),
          "application/x-pson;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.JSON),
          "application/x-pson;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/x-pson;q=1.0,**;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.JSON),
          "**;q=1.0,application/json;q=0.9",
          true
        },
        {
          RestClient.ContentType.JSON,
          "application/json",
          JSON_ENTITY_BODY,
          JSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.PSON),
          "**;q=1.0,application/x-pson;q=0.9",
          true
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,application/x-pson;q=0.9,**",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Collections.singletonList(RestClient.AcceptType.ANY),
          "**;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.JSON, RestClient.AcceptType.ANY),
          "application/json;q=1.0,**;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.PSON, RestClient.AcceptType.ANY),
          "application/x-pson;q=1.0,**;q=1.0,application/json;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.JSON),
          "**;q=1.0,application/x-pson;q=0.9",
          false
        },
        {
          RestClient.ContentType.PSON,
          "application/x-pson",
          PSON_ENTITY_BODY,
          PSON_ENTITIES_BODY,
          Arrays.asList(RestClient.AcceptType.ANY, RestClient.AcceptType.PSON),
          "**;q=0.8",
          false
        }
      };
  }

  @SuppressWarnings("rawtypes")
  private void setCommonExpectations(Request mockRequest,
                                     ResourceMethod method,
                                     RestResponseDecoder mockResponseDecoder,
                                     RestliRequestOptions requestOptions)
  {
    EasyMock.expect(mockRequest.getMethod()).andReturn(method).anyTimes();
    EasyMock.expect(mockRequest.getPathKeys()).andReturn(Collections.<String, String>emptyMap()).once();
    EasyMock.expect(mockRequest.getQueryParamsObjects()).andReturn(Collections.emptyMap()).once();
    EasyMock.expect(mockRequest.getQueryParamClasses()).andReturn(Collections.<String, Class<?>>emptyMap()).once();
    EasyMock.expect(mockRequest.getBaseUriTemplate()).andReturn(BASE_URI_TEMPLATE).times(2);
    EasyMock.expect(mockRequest.getServiceName()).andReturn(SERVICE_NAME).once();
    EasyMock.expect(mockRequest.getResponseDecoder()).andReturn(mockResponseDecoder).once();
    EasyMock.expect(mockRequest.getHeaders()).andReturn(Collections.<String, String>emptyMap()).once();
    EasyMock.expect(mockRequest.getRequestOptions()).andReturn(requestOptions).anyTimes();
  }

  @SuppressWarnings({"rawtypes", "deprecation"})
  private void buildInputForBatchPatchAndUpdate(Request mockRequest)
  {
    CollectionRequest mockCollectionRequest = EasyMock.createMock(CollectionRequest.class);
    EasyMock.expect(mockCollectionRequest.getElements()).andReturn(Collections.emptyList()).once();
    EasyMock.expect(mockRequest.getInputRecord()).andReturn(mockCollectionRequest).times(2);
    EasyMock.replay(mockCollectionRequest);
    ResourceSpec resourceSpec = new ResourceSpecImpl(Collections.<ResourceMethod> emptySet(),
                                                     Collections.<String, DynamicRecordMetadata> emptyMap(),
                                                     Collections.<String, DynamicRecordMetadata> emptyMap(),
                                                     null,
                                                     null,
                                                     null,
                                                     EmptyRecord.class,
                                                     Collections.<String, CompoundKey.TypeInfo> emptyMap());
    EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
        new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                               null,
                               null,
                               TypeSpec.forClassMaybeNull(EmptyRecord.class),
                               Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
  }

  @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
  private <T extends Request> RestRequest clientGeneratedRequest(Class<T> requestClass,
                                                                 ResourceMethod method,
                                                                 DataMap entityBody,
                                                                 RestClient.ContentType contentType,
                                                                 List<RestClient.AcceptType> acceptTypes,
                                                                 boolean acceptContentTypePerClient)
    throws URISyntaxException
  {
    
    Client mockClient = EasyMock.createMock(Client.class);

    @SuppressWarnings({"rawtypes"})
    Request<?> mockRequest = EasyMock.createMock(requestClass);
    RecordTemplate mockRecordTemplate = EasyMock.createMock(RecordTemplate.class);
    @SuppressWarnings({"rawtypes"})
    RestResponseDecoder mockResponseDecoder = EasyMock.createMock(RestResponseDecoder.class);

    RestliRequestOptions requestOptions = RestliRequestOptions.DEFAULT_OPTIONS;
    if (!acceptContentTypePerClient)
    {
      requestOptions = new RestliRequestOptions(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE, null, contentType, acceptTypes);
    }
    setCommonExpectations(mockRequest, method, mockResponseDecoder, requestOptions);

    if (method == ResourceMethod.BATCH_PARTIAL_UPDATE || method == ResourceMethod.BATCH_UPDATE)
    {
      buildInputForBatchPatchAndUpdate(mockRequest);
    }
    else
    {
      EasyMock.expect(mockRequest.getInputRecord()).andReturn(mockRecordTemplate).times(2);
    }

    if (method == ResourceMethod.GET)
    {
      EasyMock.expect(((GetRequest)mockRequest).getObjectId()).andReturn(null).once();
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.BATCH_GET)
    {
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.ACTION)
    {
      EasyMock.expect(((ActionRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn("testAction");
    }
    else if (method == ResourceMethod.FINDER)
    {
      EasyMock.expect(((FindRequest)mockRequest).getAssocKey()).andReturn(new CompoundKey());
      EasyMock.expect(mockRequest.getMethodName()).andReturn("testFinder");
    }
    else if (method == ResourceMethod.GET_ALL)
    {
      EasyMock.expect(((GetAllRequest)mockRequest).getAssocKey()).andReturn(new CompoundKey());
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.UPDATE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                 null,
                                 null,
                                 null,
                                 Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((UpdateRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.PARTIAL_UPDATE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((PartialUpdateRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else if (method == ResourceMethod.DELETE)
    {
      EasyMock.expect(mockRequest.getResourceProperties()).andReturn(
          new ResourcePropertiesImpl(Collections.<ResourceMethod> emptySet(),
                                     null,
                                     null,
                                     null,
                                     Collections.<String, CompoundKey.TypeInfo> emptyMap())).once();
      EasyMock.expect(((DeleteRequest)mockRequest).getId()).andReturn(null);
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }
    else
    {
      EasyMock.expect(mockRequest.getMethodName()).andReturn(null);
    }

    EasyMock.expect(mockRecordTemplate.data()).andReturn(entityBody).once();

    Capture<RestRequest> restRequestCapture = new Capture<RestRequest>();

    EasyMock.expect(mockClient.getMetadata(new URI(HOST + SERVICE_NAME)))
        .andReturn(Collections.<String, Object>emptyMap()).once();

    mockClient.restRequest(EasyMock.capture(restRequestCapture),
                           (RequestContext) EasyMock.anyObject(),
                           (Callback<RestResponse>) EasyMock.anyObject());
    EasyMock.expectLastCall().once();

    EasyMock.replay(mockClient, mockRequest, mockRecordTemplate);

    
    RestClient restClient;
    if (acceptContentTypePerClient)
    {
      
      restClient = new RestClient(mockClient, HOST, contentType, acceptTypes);
    }
    else
    {
      
      restClient = new RestClient(mockClient, HOST);
    }

    restClient.sendRequest(mockRequest);

    return restRequestCapture.getValue();
  }

}

<code block>




package com.linkedin.restli.client;


import com.linkedin.common.callback.Callback;
import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.data.DataMap;
import com.linkedin.data.codec.JacksonDataCodec;
import com.linkedin.data.template.RecordTemplate;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.ErrorDetails;
import com.linkedin.restli.common.ErrorResponse;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.ResourceSpecImpl;
import com.linkedin.restli.common.RestConstants;
import com.linkedin.restli.internal.client.EntityResponseDecoder;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.common.TestConstants;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class RestClientTest
{
  private static final RequestContext DEFAULT_REQUEST_CONTEXT = new RequestContext();
  static
  {
    DEFAULT_REQUEST_CONTEXT.putLocalAttr("__attr1", "1");
  }

  @Test
  public void testEmptyErrorResponse()
  {
    RestResponse response = new RestResponseBuilder().setStatus(200).build();
    RestLiResponseException e = new RestLiResponseException(response, null, new ErrorResponse());

    Assert.assertNull(e.getServiceErrorMessage());
    Assert.assertNull(e.getErrorDetails());
    Assert.assertNull(e.getErrorSource());
    Assert.assertFalse(e.hasServiceErrorCode());
    Assert.assertNull(e.getServiceErrorStackTrace());
    Assert.assertNull(e.getServiceExceptionClass());
  }

  @Test
  public void testShutdown()
  {
    Client client = EasyMock.createMock(Client.class);

    @SuppressWarnings("unchecked")
    Callback<None> callback = EasyMock.createMock(Callback.class);
    Capture<Callback<None>> callbackCapture = new Capture<Callback<None>>();

    
    client.shutdown(EasyMock.capture(callbackCapture));
    EasyMock.replay(client);

    
    EasyMock.replay(callback);

    RestClient restClient = new RestClient(client, "d2:
    restClient.shutdown(callback);

    EasyMock.verify(client);
    EasyMock.verify(callback);

    EasyMock.reset(callback);

    None none = None.none();
    callback.onSuccess(none);
    EasyMock.replay(callback);

    Callback<None> captured = callbackCapture.getValue();
    captured.onSuccess(none);

    EasyMock.verify(callback);

  }

  private enum SendRequestOption
  {
    REQUEST_NO_CONTEXT(false, false),
    REQUEST_WITH_CONTEXT(false, true),
    REQUESTBUILDER_NO_CONTEXT(true, false),
    REQUESTBUILDER_WITH_CONTEXT(true, true);

    private SendRequestOption(boolean requestBuilder, boolean context)
    {
      _requestBuilder = requestBuilder;
      _context = context;
    }

    private final boolean _requestBuilder;
    private final boolean _context;
  }

  private enum GetResponseOption
  {
    GET,
    GET_RESPONSE,
    GET_RESPONSE_EXPLICIT_NO_THROW,
    GET_RESPONSE_EXPLICIT_THROW,
    GET_RESPONSE_ENTITY,
    GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
    GET_RESPONSE_ENTITY_EXPLICIT_THROW,
  }

  private enum TimeoutOption
  {
    NO_TIMEOUT(null, null),
    THIRTY_SECONDS(30L, TimeUnit.SECONDS);

    private TimeoutOption(Long l, TimeUnit timeUnit)
    {
      _l = l;
      _timeUnit = timeUnit;
    }

    private final Long _l;
    private final TimeUnit _timeUnit;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestOptions")
  private Object[][] sendRequestOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length * TimeoutOption.values().length * 2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (TimeoutOption timeoutOption : TimeoutOption.values())
      {
        result[i++] = new Object[] {
            sendRequestOption,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
      }
    }
    return result;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  private Object[][] sendRequestAndGetResponseOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length *
                                   GetResponseOption.values().length *
                                   TimeoutOption.values().length *
                                   2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (GetResponseOption getResponseOption : GetResponseOption.values() )
      {
        for (TimeoutOption timeoutOption : TimeoutOption.values())
        {
          result[i++] = new Object[] {
              sendRequestOption,
              getResponseOption,
              timeoutOption,
              ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
              AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
              RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
          };
          result[i++] = new Object[] {
              sendRequestOption,
              getResponseOption,
              timeoutOption,
              ProtocolVersionOption.FORCE_USE_NEXT,
              AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
              RestConstants.HEADER_RESTLI_ERROR_RESPONSE
          };
        }
      }
    }
    return result;
  }

  @DataProvider(name = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndNoThrowGetResponseOptions")
  private Object[][] sendRequestAndNoThrowGetResponseOptions()
  {
    Object[][] result = new Object[SendRequestOption.values().length *
                                   2 *
                                   TimeoutOption.values().length *
                                   2][];
    int i = 0;
    for (SendRequestOption sendRequestOption : SendRequestOption.values())
    {
      for (TimeoutOption timeoutOption : TimeoutOption.values())
      {
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.USE_LATEST_IF_AVAILABLE,
            AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion(),
            RestConstants.HEADER_LINKEDIN_ERROR_RESPONSE
        };
        result[i++] = new Object[] {
            sendRequestOption,
            GetResponseOption.GET_RESPONSE_EXPLICIT_NO_THROW,
            timeoutOption,
            ProtocolVersionOption.FORCE_USE_NEXT,
            AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion(),
            RestConstants.HEADER_RESTLI_ERROR_RESPONSE
        };
      }
    }

    return result;
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  public void testRestLiResponseFuture(SendRequestOption sendRequestOption,
                                       GetResponseOption getResponseOption,
                                       TimeoutOption timeoutOption,
                                       ProtocolVersionOption versionOption,
                                       ProtocolVersion protocolVersion,
                                       String errorResponseHeaderName)
    throws ExecutionException, RemoteInvocationException,
           TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 200;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<ErrorResponse> request = mockRequest(ErrorResponse.class, versionOption);
    RequestBuilder<Request<ErrorResponse>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<ErrorResponse> future = sendRequest(sendRequestOption,
                                                       determineErrorHandlingBehavior(getResponseOption),
                                                       client,
                                                       request,
                                                       requestBuilder);
    Response<ErrorResponse> response = getOkResponse(getResponseOption, future, timeoutOption);
    ErrorResponse e = response.getEntity();

    Assert.assertNull(response.getError());
    Assert.assertFalse(response.hasError());
    Assert.assertEquals(HTTP_CODE, response.getStatus());
    Assert.assertEquals(ERR_VALUE, e.getErrorDetails().data().getString(ERR_KEY));
    Assert.assertEquals(APP_CODE, e.getServiceErrorCode().intValue());
    Assert.assertEquals(ERR_MSG, e.getMessage());
    verifyResponseHeader(sendRequestOption, response.getHeaders());
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndGetResponseOptions")
  public void testRestLiResponseExceptionFuture(SendRequestOption sendRequestOption,
                                                GetResponseOption getResponseOption,
                                                TimeoutOption timeoutOption,
                                                ProtocolVersionOption versionOption,
                                                ProtocolVersion protocolVersion,
                                                String errorResponseHeaderName)
    throws RemoteInvocationException, TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<EmptyRecord> future = sendRequest(sendRequestOption,
                                                     determineErrorHandlingBehavior(getResponseOption),
                                                     client,
                                                     request,
                                                     requestBuilder);
    RestLiResponseException e = getErrorResponse(getResponseOption, future, timeoutOption);

    if (getResponseOption == GetResponseOption.GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW)
    {
      Assert.assertNull(e);
    }
    else
    {
      Assert.assertEquals(HTTP_CODE, e.getStatus());
      Assert.assertEquals(ERR_VALUE, e.getErrorDetails().get(ERR_KEY));
      Assert.assertEquals(APP_CODE, e.getServiceErrorCode());
      Assert.assertEquals(ERR_MSG, e.getServiceErrorMessage());

      verifyResponseHeader(sendRequestOption, e.getResponse().getHeaders());
    }
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestAndNoThrowGetResponseOptions")
  public void testRestLiResponseExceptionFutureNoThrow(SendRequestOption sendRequestOption,
                                                       GetResponseOption getResponseOption,
                                                       TimeoutOption timeoutOption,
                                                       ProtocolVersionOption versionOption,
                                                       ProtocolVersion protocolVersion,
                                                       String errorResponseHeaderName)
      throws RemoteInvocationException, ExecutionException, TimeoutException, InterruptedException, IOException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    ResponseFuture<EmptyRecord> future = sendRequest(sendRequestOption,
                                                     determineErrorHandlingBehavior(getResponseOption),
                                                     client,
                                                     request,
                                                     requestBuilder);

    Response<EmptyRecord> response = getOkResponse(getResponseOption, future, timeoutOption);
    Assert.assertTrue(response.hasError());
    RestLiResponseException e = response.getError();

    Assert.assertNotNull(e);
    Assert.assertEquals(HTTP_CODE, e.getStatus());
    Assert.assertEquals(ERR_VALUE, e.getErrorDetails().get(ERR_KEY));
    Assert.assertEquals(APP_CODE, e.getServiceErrorCode());
    Assert.assertEquals(ERR_MSG, e.getServiceErrorMessage());

    verifyResponseHeader(sendRequestOption, response.getHeaders());
  }

  @Test(dataProvider = TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "sendRequestOptions")
  public void testRestLiResponseExceptionCallback(SendRequestOption option,
                                                  TimeoutOption timeoutOption,
                                                  ProtocolVersionOption versionOption,
                                                  ProtocolVersion protocolVersion,
                                                  String errorResponseHeaderName)
          throws ExecutionException, TimeoutException, InterruptedException, RestLiDecodingException
  {
    final String ERR_KEY = "someErr";
    final String ERR_VALUE = "WHOOPS!";
    final String ERR_MSG = "whoops2";
    final int HTTP_CODE = 400;
    final int APP_CODE = 666;

    RestClient client = mockClient(ERR_KEY, ERR_VALUE, ERR_MSG, HTTP_CODE, APP_CODE, protocolVersion, errorResponseHeaderName);
    Request<EmptyRecord> request = mockRequest(EmptyRecord.class, versionOption);
    RequestBuilder<Request<EmptyRecord>> requestBuilder = mockRequestBuilder(request);

    FutureCallback<Response<EmptyRecord>> callback = new FutureCallback<Response<EmptyRecord>>();
    try
    {
      sendRequest(option, client, request, requestBuilder, callback);
      Long l = timeoutOption._l;
      TimeUnit timeUnit = timeoutOption._timeUnit;
      Response<EmptyRecord> response = l == null ? callback.get() : callback.get(l, timeUnit);
      Assert.fail("Should have thrown");
    }
    catch (ExecutionException e)
    {
      

      Throwable cause = e.getCause();
      Assert.assertTrue(cause instanceof RestLiResponseException, "Expected RestLiResponseException not " + cause.getClass().getName());
      RestLiResponseException rlre = (RestLiResponseException)cause;
      Assert.assertEquals(HTTP_CODE, rlre.getStatus());
      Assert.assertEquals(ERR_VALUE, rlre.getErrorDetails().get(ERR_KEY));
      Assert.assertEquals(APP_CODE, rlre.getServiceErrorCode());
      Assert.assertEquals(ERR_MSG, rlre.getServiceErrorMessage());
      verifyResponseHeader(option, rlre.getResponse().getHeaders());

      

      Assert.assertTrue(cause instanceof RestException, "Expected RestException not " + cause.getClass().getName());
      RestException re = (RestException)cause;
      RestResponse r = re.getResponse();

      ErrorResponse er = new EntityResponseDecoder<ErrorResponse>(ErrorResponse.class).decodeResponse(r).getEntity();

      Assert.assertEquals(HTTP_CODE, r.getStatus());
      Assert.assertEquals(ERR_VALUE, er.getErrorDetails().data().getString(ERR_KEY));
      Assert.assertEquals(APP_CODE, er.getServiceErrorCode().intValue());
      Assert.assertEquals(ERR_MSG, er.getMessage());
      verifyResponseHeader(option, re.getResponse().getHeaders());
    }
  }

  private ErrorHandlingBehavior determineErrorHandlingBehavior(GetResponseOption getResponseOption)
  {
    switch (getResponseOption)
    {
      case GET:
      case GET_RESPONSE:
      case GET_RESPONSE_ENTITY:
        return null;
      case GET_RESPONSE_EXPLICIT_NO_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
        return ErrorHandlingBehavior.TREAT_SERVER_ERROR_AS_SUCCESS;
      case GET_RESPONSE_EXPLICIT_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        return ErrorHandlingBehavior.FAIL_ON_ERROR;
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> ResponseFuture<T> sendRequest(SendRequestOption option,
                                                                   ErrorHandlingBehavior errorHandlingBehavior,
                                                                   RestClient client,
                                                                   Request<T> request,
                                                                   RequestBuilder<Request<T>> requestBuilder)
  {
    switch (option)
    {
      case REQUEST_NO_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(request);
        }
        else
        {
          return client.sendRequest(request, errorHandlingBehavior);
        }
      case REQUEST_WITH_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(request, DEFAULT_REQUEST_CONTEXT);
        }
        else
        {
          return client.sendRequest(request, DEFAULT_REQUEST_CONTEXT, errorHandlingBehavior);
        }
      case REQUESTBUILDER_NO_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(requestBuilder);
        }
        else
        {
          return client.sendRequest(requestBuilder, errorHandlingBehavior);
        }
      case REQUESTBUILDER_WITH_CONTEXT:
        if (errorHandlingBehavior == null)
        {
          return client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT);
        }
        else
        {
          return client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT, errorHandlingBehavior);
        }
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> void sendRequest(SendRequestOption option,
                                                      RestClient client,
                                                      Request<T> request,
                                                      RequestBuilder<Request<T>> requestBuilder,
                                                      Callback<Response<T>> callback)
  {
    switch (option)
    {
      case REQUEST_NO_CONTEXT:
        client.sendRequest(request, callback);
        break;
      case REQUEST_WITH_CONTEXT:
        client.sendRequest(request, DEFAULT_REQUEST_CONTEXT, callback);
        break;
      case REQUESTBUILDER_NO_CONTEXT:
        client.sendRequest(requestBuilder, callback);
        break;
      case REQUESTBUILDER_WITH_CONTEXT:
        client.sendRequest(requestBuilder, DEFAULT_REQUEST_CONTEXT, callback);
        break;
      default:
        throw new IllegalStateException();
    }
  }

  private <T extends RecordTemplate> Response<T> getOkResponse(GetResponseOption option,
                                                               ResponseFuture<T> future,
                                                               TimeoutOption timeoutOption)
    throws ExecutionException, InterruptedException, TimeoutException, RemoteInvocationException
  {
    Response<T> result = null;
    T entity;
    Long l = timeoutOption._l;
    TimeUnit timeUnit = timeoutOption._timeUnit;
    switch (option)
    {
      case GET:
        result = l == null ? future.get() : future.get(l, timeUnit);
        break;
      case GET_RESPONSE:
      case GET_RESPONSE_EXPLICIT_NO_THROW:
      case GET_RESPONSE_EXPLICIT_THROW:
        result = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
        break;
      case GET_RESPONSE_ENTITY:
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
        result = future.getResponse();
        Assert.assertSame(entity, result.getEntity());
        break;
      default:
        throw new IllegalStateException();
    }
    return result;
  }

  private <T extends RecordTemplate> RestLiResponseException getErrorResponse(GetResponseOption option,
                                                                              ResponseFuture<T> future,
                                                                              TimeoutOption timeoutOption)
    throws InterruptedException, TimeoutException, RemoteInvocationException
  {
    Response<T> response = null;
    T entity;
    RestLiResponseException result = null;
    Long l = timeoutOption._l;
    TimeUnit timeUnit = timeoutOption._timeUnit;
    switch (option)
    {
      case GET:
        try
        {
          response = l == null ? future.get() : future.get(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (ExecutionException e)
        {
          Throwable cause = e.getCause();
          Assert.assertTrue(cause instanceof RestException, "Expected RestLiResponseException not " + cause.getClass().getName());
          result = (RestLiResponseException) cause;
        }
        break;
      case GET_RESPONSE:
      case GET_RESPONSE_EXPLICIT_THROW:
        try
        {
          response = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (RestLiResponseException e)
        {
          result = e;
        }
        break;
      case GET_RESPONSE_EXPLICIT_NO_THROW:
        response = l == null ? future.getResponse() : future.getResponse(l, timeUnit);
        result = response.getError();
        break;
      case GET_RESPONSE_ENTITY:
      case GET_RESPONSE_ENTITY_EXPLICIT_THROW:
        try
        {
          entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
          Assert.fail("Should have thrown");
        }
        catch (RestLiResponseException e)
        {
          result = e;
        }
        break;
      case GET_RESPONSE_ENTITY_EXPLICIT_NO_THROW:
        entity = l == null ? future.getResponseEntity() : future.getResponseEntity(l, timeUnit);
        break;
      default:
        throw new IllegalStateException();
    }
    return result;
  }

  private void verifyResponseHeader(SendRequestOption option, Map<String, String> headers)
  {
    for (Map.Entry<String, Object> attr : DEFAULT_REQUEST_CONTEXT.getLocalAttrs().entrySet())
    {
      if (attr.getKey().equals(R2Constants.OPERATION) || attr.getKey().equals(R2Constants.REQUEST_COMPRESSION_OVERRIDE))
      {
        continue;
      }
      Assert.assertEquals(headers.get(attr.getKey()), option._context ? attr.getValue().toString() : null);
    }
  }

  private <T extends RecordTemplate> RequestBuilder<Request<T>> mockRequestBuilder(final Request<T> request)
  {
    return new RequestBuilder<Request<T>>()
    {
      @Override
      public Request<T> build()
      {
        return request;
      }
    };
  }

  private <T extends RecordTemplate> Request<T> mockRequest(Class<T> clazz, ProtocolVersionOption versionOption)
  {
    return new GetRequest<T>(Collections.<String, String> emptyMap(),
                             clazz,
                             null,
                             new DataMap(),
                             Collections.<String, Class<?>>emptyMap(),
                             new ResourceSpecImpl(),
                             "/foo",
                             Collections.<String, Object>emptyMap(),
                             new RestliRequestOptionsBuilder().setProtocolVersionOption(versionOption).build());
  }

  private static class MyMockClient extends MockClient
  {
    private RequestContext _requestContext;

    private MyMockClient(int httpCode, Map<String, String> headers, byte[] bytes)
    {
      super(httpCode, headers, bytes);
    }

    @Override
    public void restRequest(RestRequest request, RequestContext requestContext,
                            Callback<RestResponse> callback)
    {
      Assert.assertNotNull(requestContext);
      _requestContext = requestContext;
      super.restRequest(request, requestContext, callback);
    }

    @Override
    protected Map<String, String> headers()
    {
      Map<String, String> headers = new HashMap<String, String>(super.headers());
      for (Map.Entry<String, Object> attr : _requestContext.getLocalAttrs().entrySet())
      {
        if (!attr.getKey().startsWith("__attr"))
        {
          continue;
        }
        headers.put(attr.getKey(), attr.getValue().toString());
      }
      return headers;
    }
  }

  private RestClient mockClient(String errKey, String errValue, String errMsg, int httpCode, int appCode, ProtocolVersion protocolVersion, String errorResponseHeaderName)
  {
    ErrorResponse er = new ErrorResponse();

    DataMap errMap = new DataMap();
    errMap.put(errKey, errValue);
    er.setErrorDetails(new ErrorDetails(errMap));
    er.setStatus(httpCode);
    er.setMessage(errMsg);
    er.setServiceErrorCode(appCode);

    byte[] mapBytes;
    try
    {
      mapBytes = new JacksonDataCodec().mapToBytes(er.data());
    }
    catch (IOException e)
    {
      throw new RuntimeException(e);
    }

    Map<String,String> headers = new HashMap<String,String>();
    headers.put(RestConstants.HEADER_RESTLI_PROTOCOL_VERSION, protocolVersion.toString());
    headers.put(errorResponseHeaderName, RestConstants.HEADER_VALUE_ERROR);

    return new RestClient(new MyMockClient(httpCode, headers, mapBytes), "http:
  }
}

<code block>


package com.linkedin.r2.filter;



public class R2Constants
{
  public static final String OPERATION = "OPERATION";
  public static final String REMOTE_ADDR = "REMOTE_ADDR";
  public static final String IS_SECURE = "IS_SECURE";
  public static final String CLIENT_CERT = "CLIENT_CERT";
  public static final String REQUEST_COMPRESSION_OVERRIDE = "REQUEST_COMPRESSION_OVERRIDE";
  public static final String IS_QUERY_TUNNELED = "IS_QUERY_TUNNELED";
  public static final String FORCE_QUERY_TUNNEL = "FORCE_QUERY_TUNNEL";
  public static final String RESPONSE_DECOMPRESSION_OFF = "RESPONSE_DECOMPRESSION_OFF";
}

<code block>


package com.linkedin.r2.filter;


import com.linkedin.r2.message.RequestContext;


public enum CompressionOption
{
  
  FORCE_ON,

  
  FORCE_OFF
}
<code block>
package com.linkedin.r2.transport.http.common;

public interface HttpConstants
{
  public static final String ACCEPT_ENCODING = "Accept-Encoding";
  public static final String CONTENT_ENCODING = "Content-Encoding";
  public static final String CONTENT_LENGTH = "Content-Length";
  public static final String TRANSFER_ENCODING = "Transfer-Encoding";

  
  public static final String REQUEST_COOKIE_HEADER_NAME = "Cookie";

  
  public static final String RESPONSE_COOKIE_HEADER_NAME = "Set-Cookie";

  public static final int NOT_ACCEPTABLE = 406;
  public static final int OK = 200;
  public static final int UNSUPPORTED_MEDIA_TYPE = 415;
  public static final int INTERNAL_SERVER_ERROR = 500;
  public static final String ACCEPT = "Accept";
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.filter.message.rest.RestRequestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;
import com.linkedin.r2.transport.http.client.AbstractJmxManager;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.common.HttpConstants;
import com.linkedin.r2.util.NamedThreadFactory;
import com.linkedin.restli.client.ProtocolVersionOption;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.client.RestliRequestOptions;
import com.linkedin.restli.client.RestliRequestOptionsBuilder;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.server.RestLiServiceException;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import io.netty.channel.nio.NioEventLoopGroup;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;


public class TestRequestCompression extends RestLiIntegrationTest
{
  
  private static final String TEST_HELP_HEADER = "Test-Help-Header";
  private static final String EXPECT_COMPRESSION = "Expect-Compression";
  private static final String EXPECT_NO_COMPRESSION = "Expect-No-Compression";
  private static final String SERVICE_NAME = "service1";

  @BeforeClass
  public void initClass() throws Exception
  {
    class CheckRequestCompressionFilter implements RestRequestFilter
    {
      @Override
      public void onRestRequest(RestRequest req,
                         RequestContext requestContext,
                         Map<String, String> wireAttrs,
                         NextFilter<RestRequest, RestResponse> nextFilter)
      {
        Map<String, String> requestHeaders = req.getHeaders();
        if (requestHeaders.containsKey(TEST_HELP_HEADER))
        {
          String contentEncodingHeader = requestHeaders.get(HttpConstants.CONTENT_ENCODING);
          if (requestHeaders.get(TEST_HELP_HEADER).equals(EXPECT_COMPRESSION))
          {
            if (contentEncodingHeader == null)
            {
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Request is not compressed when it should be.");
            }
            else if (!contentEncodingHeader.equals("snappy"))
            {
              
              
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST,
                  "Request is compressed with " + contentEncodingHeader + " instead of snappy.");
            }
          }
          else
          {
            if (contentEncodingHeader != null)
            {
              throw new RestLiServiceException(HttpStatus.S_400_BAD_REQUEST, "Request is compressed when it shouldn't be.");
            }
          }
        }
        nextFilter.onRequest(req, requestContext, wireAttrs);
      }
    }

    
    class CheckHeadersFilter implements RestRequestFilter
    {
      @Override
      public void onRestRequest(RestRequest req,
                                RequestContext requestContext,
                                Map<String, String> wireAttrs,
                                NextFilter<RestRequest, RestResponse> nextFilter)
      {
        if (req.getHeaders().containsKey(HttpConstants.CONTENT_ENCODING))
        {
          throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, "Content-Encoding header not removed.");
        }
        if (req.getEntity().length() != Integer.parseInt(req.getHeader(HttpConstants.CONTENT_LENGTH)))
        {
          throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, "Content-Length header incorrect.");
        }
        nextFilter.onRequest(req, requestContext, wireAttrs);
      }
    }

    final FilterChain fc = FilterChains.empty().addLast(new CheckRequestCompressionFilter())
        .addLast(new ServerCompressionFilter(RestLiIntTestServer.supportedCompression))
        .addLast(new CheckHeadersFilter())
        .addLast(new SimpleLoggingFilter());
    super.init(null, null, fc);
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  @DataProvider(name = "requestData")
  private Object[][] requestData()
  {
    int tiny = 10;
    int small = 100;
    int large = 1000;
    int huge = 10000;

    CompressionConfig tinyThresholdConfig = new CompressionConfig(tiny);
    CompressionConfig hugeThresholdConfig = new CompressionConfig(huge);

    String encodings = "unsupportedEncoding, snappy, gzip";

    RestliRequestOptions forceOnOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setRequestCompressionOverride(CompressionOption.FORCE_ON).build();
    RestliRequestOptions forceOffOption = new RestliRequestOptionsBuilder().setProtocolVersionOption(ProtocolVersionOption.USE_LATEST_IF_AVAILABLE)
        .setRequestCompressionOverride(CompressionOption.FORCE_OFF).build();

    return new Object[][] {
        
        {null, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {null, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {tinyThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {tinyThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_COMPRESSION},

        
        {hugeThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {hugeThresholdConfig, encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {null, encodings, forceOnOption, large, EXPECT_COMPRESSION},
        {null, encodings, forceOnOption, small, EXPECT_COMPRESSION},
        {hugeThresholdConfig, encodings, forceOnOption, small, EXPECT_COMPRESSION},
        {null, encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},
        {null, encodings, forceOffOption, small, EXPECT_NO_COMPRESSION},
        {tinyThresholdConfig, encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},

        
        {new CompressionConfig(0), encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_COMPRESSION},
        {new CompressionConfig(0), encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, RestliRequestOptions.DEFAULT_OPTIONS, small, EXPECT_NO_COMPRESSION},

        
        {new CompressionConfig(0), encodings, forceOffOption, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(Integer.MAX_VALUE), encodings, forceOnOption, small, EXPECT_COMPRESSION},

        
        {null, "unsupportedEncoding", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {null, "", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {new CompressionConfig(0), "unsupportedEncoding", RestliRequestOptions.DEFAULT_OPTIONS, large, EXPECT_NO_COMPRESSION},
        {null, "", forceOnOption, large, EXPECT_NO_COMPRESSION}
    };
  }

  @Test(dataProvider = "requestData")
  public void testUpdate(CompressionConfig requestCompressionConfig,
                         String supportedEncodings,
                         RestliRequestOptions restliRequestOptions,
                         int messageLength,
                         String testHelpHeader)
    throws RemoteInvocationException, CloneNotSupportedException, InterruptedException, ExecutionException,
           TimeoutException
  {
    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("R2 Netty Scheduler"));
    Map<String, CompressionConfig> requestCompressionConfigs = new HashMap<String, CompressionConfig>();
    if (requestCompressionConfig != null)
    {
      requestCompressionConfigs.put(SERVICE_NAME, requestCompressionConfig);
    }
    HttpClientFactory httpClientFactory = new HttpClientFactory(FilterChains.empty(),
        new NioEventLoopGroup(),
        true,
        executor,
        true,
        null,
        false,
        AbstractJmxManager.NULL_JMX_MANAGER,
        500, 
        requestCompressionConfigs);
    Map<String, String> properties = new HashMap<String, String>();

    properties.put(HttpClientFactory.HTTP_REQUEST_CONTENT_ENCODINGS, supportedEncodings);
    properties.put(HttpClientFactory.HTTP_SERVICE_NAME, SERVICE_NAME);
    TransportClientAdapter clientAdapter1 = new TransportClientAdapter(httpClientFactory.getClient(properties));
    RestClient client = new RestClient(clientAdapter1, FILTERS_URI_PREFIX);
    RootBuilderWrapper<Long, Greeting> builders = new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(restliRequestOptions));

    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();
    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    char[] As = new char[messageLength];
    Arrays.fill(As, 'A');
    String message = new String(As);
    greeting.setMessage(message);

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).setHeader(TEST_HELP_HEADER, testHelpHeader).build();
    client.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, message);

    FutureCallback<None> callback1 = new FutureCallback<None>();
    client.shutdown(callback1);
    callback1.get(30, TimeUnit.SECONDS);

    FutureCallback<None> callback2 = new FutureCallback<None>();
    httpClientFactory.shutdown(callback2);
    callback2.get(30, TimeUnit.SECONDS);
  }
}

<code block>




package com.linkedin.restli.examples;

import com.linkedin.common.callback.FutureCallback;
import com.linkedin.common.util.None;
import com.linkedin.parseq.Engine;
import com.linkedin.parseq.EngineBuilder;
import com.linkedin.r2.filter.FilterChain;
import com.linkedin.r2.transport.common.Client;
import com.linkedin.r2.transport.common.bridge.client.TransportClientAdapter;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.server.HttpServer;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;




public class RestLiIntegrationTest
{
  protected static final String URI_PREFIX = "http:
  protected static final String NO_COMPRESSION_PREFIX = "http:
  protected static final String FILTERS_URI_PREFIX = "http:

  private final int numCores = Runtime.getRuntime().availableProcessors();

  private ScheduledExecutorService _scheduler;
  private Engine                   _engine;
  private HttpServer               _server;
  private HttpServer               _serverWithoutCompression;
  private HttpServer               _serverWithFilters;

  private HttpClientFactory        _clientFactory;
  private List<Client>             _transportClients;
  private RestClient               _restClient;

  
  public void init() throws Exception
  {
    init(false);
  }

  public void init(boolean async) throws IOException
  {
    initSchedulerAndEngine();
    int asyncTimeout = async ? 5000 : -1;
    _server =
        RestLiIntTestServer.createServer(_engine,
                                         RestLiIntTestServer.DEFAULT_PORT,
                                         RestLiIntTestServer.supportedCompression,
                                         async,
                                         asyncTimeout);
    _server.start();
    initClient(URI_PREFIX);
  }

  public void init(List<? extends RequestFilter> requestFilters, List<? extends ResponseFilter> responseFilters) throws IOException
  {
    initSchedulerAndEngine();
    _serverWithFilters =
        RestLiIntTestServer.createServer(_engine,
                                         RestLiIntTestServer.FILTERS_PORT,
                                         RestLiIntTestServer.supportedCompression,
                                         false,
                                         -1,
                                         requestFilters,
                                         responseFilters);
    _serverWithFilters.start();
    initClient(FILTERS_URI_PREFIX);
  }

  public void init(List<? extends RequestFilter> requestFilters, List<? extends ResponseFilter> responseFilters,
                   final FilterChain filterChain) throws IOException
  {
    init(requestFilters, responseFilters, filterChain, false);
  }

  public void init(List<? extends RequestFilter> requestFilters, List<? extends ResponseFilter> responseFilters,
                   final FilterChain filterChain, boolean includeNoCompression) throws IOException
  {
    initSchedulerAndEngine();
    _serverWithFilters =
        RestLiIntTestServer.createServer(_engine,
                                         RestLiIntTestServer.FILTERS_PORT,
                                         false,
                                         -1,
                                         requestFilters,
                                         responseFilters,
                                         filterChain);
    _serverWithFilters.start();
    
    if (includeNoCompression)
    {
      _serverWithoutCompression =
          RestLiIntTestServer.createServer(_engine,
                                           RestLiIntTestServer.NO_COMPRESSION_PORT,
                                           "");
      _serverWithoutCompression.start();
    }
    initClient(FILTERS_URI_PREFIX);
  }

  private void initSchedulerAndEngine()
  {
    _scheduler = Executors.newScheduledThreadPool(numCores + 1);
    _engine = new EngineBuilder().setTaskExecutor(_scheduler).setTimerScheduler(_scheduler).build();
  }

  private void initClient(String uriPrefix)
  {
    _clientFactory = new HttpClientFactory();
    _transportClients = new ArrayList<Client>();
    Client client = newTransportClient(Collections.<String, String>emptyMap());
    _restClient = new RestClient(client, uriPrefix);
  }

  public void shutdown() throws Exception
  {
    if (_server != null)
    {
      _server.stop();
    }
    if (_serverWithoutCompression != null)
    {
      _serverWithoutCompression.stop();
    }
    if (_serverWithFilters != null)
    {
      _serverWithFilters.stop();
    }
    if (_engine != null)
    {
      _engine.shutdown();
    }
    if (_scheduler != null)
    {
      _scheduler.shutdownNow();
    }
    for (Client client : _transportClients)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      client.shutdown(callback);
      callback.get();
    }
    if (_clientFactory != null)
    {
      FutureCallback<None> callback = new FutureCallback<None>();
      _clientFactory.shutdown(callback);
      callback.get();
    }
  }

  protected RestClient getClient()
  {
    return _restClient;
  }

  
  protected Client getDefaultTransportClient()
  {
    if (_transportClients.size() > 0)
    {
      return _transportClients.get(0);
    }
    else
    {
      return null;
    }
  }

  
  protected Client newTransportClient(Map<String, ? extends Object> properties)
  {
    Client client = new TransportClientAdapter(_clientFactory.getClient(properties));
    _transportClients.add(client);
    return client;
  }
}

<code block>


package com.linkedin.restli.examples;


import com.linkedin.r2.RemoteInvocationException;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.FilterChains;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.compression.Bzip2Compressor;
import com.linkedin.r2.filter.compression.ClientCompressionFilter;
import com.linkedin.r2.filter.compression.CompressionException;
import com.linkedin.r2.filter.compression.Compressor;
import com.linkedin.r2.filter.compression.DeflateCompressor;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.filter.compression.GzipCompressor;
import com.linkedin.r2.filter.compression.ServerCompressionFilter;
import com.linkedin.r2.filter.compression.SnappyCompressor;
import com.linkedin.r2.filter.logging.SimpleLoggingFilter;
import com.linkedin.r2.filter.message.rest.RestResponseFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.client.HttpClientFactory;
import com.linkedin.r2.transport.http.common.HttpConstants;
import com.linkedin.r2.util.RequestContextUtil;
import com.linkedin.restli.client.Request;
import com.linkedin.restli.client.Response;
import com.linkedin.restli.client.ResponseFuture;
import com.linkedin.restli.client.RestClient;
import com.linkedin.restli.client.RestLiResponseException;
import com.linkedin.restli.client.RestliRequestOptions;
import com.linkedin.restli.client.response.BatchKVResponse;
import com.linkedin.restli.client.util.PatchGenerator;
import com.linkedin.restli.common.BatchCreateIdResponse;
import com.linkedin.restli.common.BatchResponse;
import com.linkedin.restli.common.CollectionMetadata;
import com.linkedin.restli.common.CollectionResponse;
import com.linkedin.restli.common.CreateIdStatus;
import com.linkedin.restli.common.CreateStatus;
import com.linkedin.restli.common.EmptyRecord;
import com.linkedin.restli.common.EntityResponse;
import com.linkedin.restli.common.HttpStatus;
import com.linkedin.restli.common.Link;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.ProtocolVersion;
import com.linkedin.restli.common.UpdateStatus;
import com.linkedin.restli.examples.greetings.api.Greeting;
import com.linkedin.restli.examples.greetings.api.SearchMetadata;
import com.linkedin.restli.examples.greetings.api.Tone;
import com.linkedin.restli.examples.greetings.client.GreetingsBuilders;
import com.linkedin.restli.examples.greetings.client.GreetingsRequestBuilders;
import com.linkedin.restli.examples.greetings.server.CompressionResource;
import com.linkedin.restli.examples.groups.api.TransferOwnershipRequest;
import com.linkedin.restli.internal.common.AllProtocolVersions;
import com.linkedin.restli.internal.testutils.URIDetails;
import com.linkedin.restli.server.filter.RequestFilter;
import com.linkedin.restli.server.filter.ResponseFilter;
import com.linkedin.restli.test.util.RootBuilderWrapper;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;



public class TestCompressionServer extends RestLiIntegrationTest
{
  private static final String URI_PREFIX = RestLiIntegrationTest.FILTERS_URI_PREFIX;
  private static final String URI_PREFIX_WITHOUT_COMPRESSION = RestLiIntegrationTest.NO_COMPRESSION_PREFIX; 
  private static final String CONTENT_ENCODING_SAVED = "Content-Encoding-Saved";

  @DataProvider
  public Object[][] compressorDataProvider()
  {
    return new Object[][]
      {
        { new SnappyCompressor() },
        { new Bzip2Compressor() },
        { new GzipCompressor() },
        { new DeflateCompressor()}
      };
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public Object[][] clientsCompressedResponsesBatchDataProvider()
  {
    
    String[] compressionOperations = {"*",
                                      "action:*",
                                      "finder:*",
                                      "finder:search",
                                      "get, batch_get, get_all",
                                      "get, batch_get, get_all, batch_create, batch_update, batch_partial_update"};
    int entries = compressionOperations.length;
    Object[][] result = new Object[entries * 4][];

    int index = entries * 4 - 1;
    for (String operation: compressionOperations)
    {
      Map<String, String> clientProperties = new HashMap<String, String>();
      clientProperties.put(HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS, operation);
      RestClient client = new RestClient(newTransportClient(clientProperties), URI_PREFIX);
      result[index--] = new Object[]{ client, operation, RestliRequestOptions.DEFAULT_OPTIONS, Arrays.asList(1000L, 2000L), 0 };
      result[index--] = new Object[]{ client, operation, TestConstants.FORCE_USE_NEXT_OPTIONS, Arrays.asList(1000L, 2000L), 0 };
      result[index--] = new Object[]{ client, operation, RestliRequestOptions.DEFAULT_OPTIONS, Arrays.asList(1L, 2L, 3L, 4L), 4 };
      result[index--] = new Object[]{ client, operation, TestConstants.FORCE_USE_NEXT_OPTIONS, Arrays.asList(1L, 2L, 3L, 4L), 4 };
    }

    return result;
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public Object[][] clientsCompressedResponsesBuilderDataProvider()
  {
    
    String[] compressionOperations = {"*",
                                      "action:*",
                                      "finder:*",
                                      "finder:search",
                                      "get, batch_get, get_all",
                                      "get, batch_get, get_all, batch_create, batch_update, batch_partial_update"};
    int entries = compressionOperations.length;
    Object[][] result = new Object[entries * 4][];

    int index = entries * 4 - 1;
    for (String operation: compressionOperations)
    {
      Map<String, String> clientProperties = new HashMap<String, String>();
      clientProperties.put(HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS, operation);
      RestClient client = new RestClient(newTransportClient(clientProperties), URI_PREFIX);
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders()),
          AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)),
          AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders()),
          AllProtocolVersions.RESTLI_PROTOCOL_1_0_0.getProtocolVersion()};
      result[index--] = new Object[]{ client, operation, new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)),
          AllProtocolVersions.RESTLI_PROTOCOL_2_0_0.getProtocolVersion()};
    }

    return result;
  }
  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public Object[][] clientsCookbookDataProvider()
  {
    return new Object[][]
      {
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), RestliRequestOptions.DEFAULT_OPTIONS },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), TestConstants.FORCE_USE_NEXT_OPTIONS },
      };
  }

  
  @DataProvider(name = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public Object[][] clientsNoCompressedResponsesDataProvider()
  {
    return new Object[][]
      {
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders()) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders()) },
        { new RestClient(getDefaultTransportClient(), URI_PREFIX), new RootBuilderWrapper<Long, Greeting>(new GreetingsRequestBuilders(TestConstants.FORCE_USE_NEXT_OPTIONS)) }
      };
  }

  @DataProvider
  
  public Object[][] contentNegotiationDataProvider()
  {
    return new Object[][]
        {
        
        {"gzip", "gzip"},
        {"deflate", "deflate"},
        {"snappy", "snappy"},
        {"bzip2", "bzip2"},
        {"deflate, nonexistentcompression", "deflate"},
        {"blablabla, dEflate", "deflate"},

        
        {"gzip, deflate;q=0.5", "gzip"},
        {"deflate;q=0.5, gzip", "gzip"},
        {"gzip,trololol, deflate;q=0.5", "gzip"},
        {"trololo, gzip;q=0.5, deflate;q=1.0", "deflate"},
        {"*,gzip;q=0.5,identity;q=0","gzip"},

        {"  tRoLolo  ,  gZiP ;  q=0.5,  DeflAte ;  q=1.0  ", "deflate"}, 

        
        {"", null}, 
        {"*;q=0.5, gzip;q=1.0", "gzip"},
        {"*,gzip;q=0, snappy;q=0, bzip2;q=0 ", null},
        {"gzip;q=0, snappy;q=0, bzip2;q=0, deflate; q=0, *", null}
        };
  }

  
  @DataProvider
  public Object[][] error406DataProvider()
  {
    return new Object[][]
        {
        {"identity;q=0"},
        {"*;q=0.5, identity;q=0"},
        {"*;q=0, identity;q=0.0"},
        {"*;q=0"}
        };
  }

  
  
  
  
  @DataProvider
  public Object[][] contentEncodingGeneratorDataProvider()
  {
    
    
    
    
    
    int current = 0;
    int length = 1 + EncodingType.values().length*EncodingType.values().length + 1;
    Object[][] encoding = new Object[length][];
    encoding[current++] = new Object[]{new EncodingType[]{}, ""};

    
    for(EncodingType type : EncodingType.values())
    {
      encoding[current++] = new Object[]{
          new EncodingType[]{type},
          type.getHttpName() + ";q=" + "1.00"};
    }

    
    for(EncodingType prev : EncodingType.values())
    {
      for(EncodingType next : EncodingType.values())
      {
        if (prev != next)
        {
          encoding[current++] = new Object[]{new EncodingType[]{prev, next},
              prev.getHttpName() + ";q=" + "1.00" + ","
              + next.getHttpName() + ";q=" + "0.67"
          };
        }
      }
    }

    
    encoding[current++] = new Object[]{new EncodingType[]{
        EncodingType.DEFLATE, EncodingType.IDENTITY, EncodingType.GZIP},
        "deflate;q=1.00,identity;q=0.75,gzip;q=0.50"};

    return encoding;
  }

  @BeforeClass
  public void initClass() throws Exception
  {
    
    
    class SaveContentEncodingHeaderFilter implements RestResponseFilter
    {
      @Override
      public void onRestResponse(RestResponse res,
                          RequestContext requestContext,
                          Map<String, String> wireAttrs,
                          NextFilter<RestRequest, RestResponse> nextFilter)
      {
        String contentEncoding = res.getHeader(HttpConstants.CONTENT_ENCODING);
        if (contentEncoding != null)
        {
          res = res.builder().addHeaderValue(CONTENT_ENCODING_SAVED, contentEncoding).build();
        }
        nextFilter.onResponse(res, requestContext, wireAttrs);
      }

      @Override
      public void onRestError(Throwable ex,
                              RequestContext requestContext,
                              Map<String, String> wireAttrs,
                              NextFilter<RestRequest, RestResponse> nextFilter)
      {
        nextFilter.onError(ex, requestContext, wireAttrs);
      }
    }
    super.init(Collections.<RequestFilter>emptyList(),
               Collections.<ResponseFilter>emptyList(),
               FilterChains.empty().addLast(new SaveContentEncodingHeaderFilter())
                   .addLast(new ServerCompressionFilter(RestLiIntTestServer.supportedCompression))
                   .addLast(new SimpleLoggingFilter()),
               true);
  }

  @AfterClass
  public void shutDown() throws Exception
  {
    super.shutdown();
  }

  @Test(dataProvider = "contentNegotiationDataProvider")
  
  public void testCompatibleDefault(String acceptEncoding, String contentEncoding) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX_WITHOUT_COMPRESSION + path + CompressionResource.getRedundantQueryExample());
    get.addHeader(HttpConstants.ACCEPT_ENCODING, acceptEncoding);

    HttpResponse response = client.execute(get);

    Assert.assertNull(response.getFirstHeader(CONTENT_ENCODING_SAVED));
  }

  @Test(dataProvider = "contentEncodingGeneratorDataProvider")
  public void testEncodingGeneration(EncodingType[] encoding, String acceptEncoding)
  {
    ClientCompressionFilter cf = new ClientCompressionFilter(EncodingType.IDENTITY,
                                                             new CompressionConfig(Integer.MAX_VALUE),
                                                             encoding,
                                                             Arrays.asList(new String[]{"*"}));
    Assert.assertEquals(cf.buildAcceptEncodingHeader(), acceptEncoding);
  }

  
  @Test(dataProvider = "compressorDataProvider")
  public void testCompressionBetter(Compressor compressor) throws RemoteInvocationException, HttpException, IOException, CompressionException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    
    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    HttpResponse response = client.execute(get);
    byte[] original = EntityUtils.toString(response.getEntity()).getBytes();

    get.releaseConnection();
    
    Assert.assertTrue(response.getFirstHeader(CONTENT_ENCODING_SAVED) == null);

    get.addHeader(HttpConstants.ACCEPT_ENCODING, compressor.getContentEncodingName());
    response = client.execute(get);

    byte[] compressed = compressor.inflate(response.getEntity().getContent());
    Assert.assertEquals(compressor.getContentEncodingName(), response.getFirstHeader(CONTENT_ENCODING_SAVED).getValue());

    Assert.assertEquals(original, compressed);
    Assert.assertTrue(response.getEntity().getContentLength() < original.length);
  }

  
  @Test(dataProvider = "compressorDataProvider")
  public void testCompressionWorse(Compressor compressor) throws RemoteInvocationException, HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    
    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getNoRedundantQueryExample());
    HttpResponse response = client.execute(get);
    String original = EntityUtils.toString(response.getEntity());

    
    Assert.assertTrue(response.getFirstHeader(CONTENT_ENCODING_SAVED) == null);

    get.addHeader(HttpConstants.ACCEPT_ENCODING, compressor.getContentEncodingName());
    response = client.execute(get);
    String compressed = EntityUtils.toString(response.getEntity());

    Assert.assertEquals(null, response.getFirstHeader(CONTENT_ENCODING_SAVED));

    
    Assert.assertEquals(original, compressed);
  }

  
  @Test(dataProvider = "contentNegotiationDataProvider")
  public void testAcceptEncoding(String acceptedEncoding, String contentEncoding) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    get.addHeader(HttpConstants.ACCEPT_ENCODING, acceptedEncoding);

    HttpResponse response = client.execute(get);

    if(contentEncoding == null)
    {
      Assert.assertNull(response.getFirstHeader(CONTENT_ENCODING_SAVED));
    }
    else
    {
      Assert.assertEquals(contentEncoding, response.getFirstHeader(CONTENT_ENCODING_SAVED).getValue());
    }
  }

  @Test(dataProvider = "error406DataProvider")
  public void test406Error(String acceptContent) throws HttpException, IOException, URISyntaxException
  {
    String path = CompressionResource.getPath();
    HttpClient client = HttpClientBuilder.create()
            .disableContentCompression()
            .build();

    HttpGet get = new HttpGet(URI_PREFIX + path + CompressionResource.getRedundantQueryExample());
    get.addHeader(HttpConstants.ACCEPT_ENCODING, acceptContent);

    HttpResponse response = client.execute(get);

    Assert.assertEquals(response.getStatusLine().getStatusCode(), HttpConstants.NOT_ACCEPTABLE);
    Assert.assertEquals(response.getEntity().getContentLength(), 0);
  }

  private <T> void checkContentEncodingHeaderIsAbsent(Response<T> response)
  {
    Assert.assertFalse(response.getHeaders().containsKey(CONTENT_ENCODING_SAVED));
  }

  
  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testIntAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Integer> request = builders.<Integer>action("Purge").build();
    ResponseFuture<Integer> responseFuture = client.sendRequest(request);

    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    Assert.assertEquals(responseFuture.getResponse().getEntity().intValue(), 100);
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testRecordAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.<Greeting>action("SomeAction")
        .id(1L)
        .setActionParam("A", 1)
        .setActionParam("B", "")
        .setActionParam("C", new TransferOwnershipRequest())
        .setActionParam("D", new TransferOwnershipRequest())
        .setActionParam("E", 3)
        .build();
    ResponseFuture<Greeting> responseFuture = client.sendRequest(request);
    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    Assert.assertNotNull(responseFuture.getResponse().getEntity());
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testUpdateToneAction(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.<Greeting>action("UpdateTone")
        .id(1L)
        .setActionParam("NewTone", Tone.SINCERE)
        .setActionParam("DelOld", false)
        .build();
    ResponseFuture<Greeting> responseFuture = client.sendRequest(request);
    Assert.assertEquals(responseFuture.getResponse().getStatus(), 200);
    final Greeting newGreeting = responseFuture.getResponse().getEntity();
    Assert.assertNotNull(newGreeting);
    Assert.assertEquals(newGreeting.getId().longValue(), 1L);
    Assert.assertEquals(newGreeting.getTone(), Tone.SINCERE);
    checkContentEncodingHeaderIsAbsent(responseFuture.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testUpdate(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);
    checkContentEncodingHeaderIsAbsent(future.getResponse());

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    greeting.setMessage(response1 + "Again");

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, response1 + "Again");
    checkContentEncodingHeaderIsAbsent(future2.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testGet(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    String response1 = greetingResponse.getEntity().getMessage();
    Assert.assertNotNull(response1);
    checkContentEncodingHeaderIsAbsent(greetingResponse);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testPartialUpdate(RestClient client, RootBuilderWrapper<Long, Greeting> builders)
    throws RemoteInvocationException, CloneNotSupportedException, URISyntaxException
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    Greeting original = greetingResponse.getEntity();
    checkContentEncodingHeaderIsAbsent(greetingResponse);

    
    Greeting greeting = new Greeting(original.data().copy());
    greeting.setMessage(original.getMessage() + " Again");

    PatchRequest<Greeting> patch = PatchGenerator.diff(original, greeting);

    Request<EmptyRecord> writeRequest = builders.partialUpdate().id(1L).input(patch).build();
    int status = client.sendRequest(writeRequest).getResponse().getStatus();
    Assert.assertEquals(status, HttpStatus.S_204_NO_CONTENT.getCode());

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = client.sendRequest(request2);
    String response2 = future2.getResponse().getEntity().getMessage();

    Assert.assertEquals(response2, greeting.getMessage());
    checkContentEncodingHeaderIsAbsent(future2.getResponse());
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  
  public void testCookbook(RestClient restClient, RootBuilderWrapper<Long, Greeting> builders) throws Exception
  {
    
    Request<Greeting> request = builders.get().id(1L).build();
    ResponseFuture<Greeting> future = restClient.sendRequest(request);
    Response<Greeting> greetingResponse = future.getResponse();

    Assert.assertNotNull(greetingResponse.getEntity().getMessage());
    checkContentEncodingHeaderIsAbsent(greetingResponse);

    
    Greeting greeting = new Greeting(greetingResponse.getEntity().data().copy());
    final String NEW_MESSAGE = "This is a new message!";
    greeting.setMessage(NEW_MESSAGE);

    Request<EmptyRecord> writeRequest = builders.update().id(1L).input(greeting).build();
    restClient.sendRequest(writeRequest).getResponse();

    
    Request<Greeting> request2 = builders.get().id(1L).build();
    ResponseFuture<Greeting> future2 = restClient.sendRequest(request2);
    greetingResponse = future2.get();

    Assert.assertEquals(greetingResponse.getEntity().getMessage(), NEW_MESSAGE);
    checkContentEncodingHeaderIsAbsent(greetingResponse);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public void testOldCookbookInBatch(RestClient client, RestliRequestOptions requestOptions) throws Exception
  {
    final GreetingsBuilders builders = new GreetingsBuilders(requestOptions);

    
    Greeting greetingResult = getOldCookbookBatchGetResult(client, requestOptions);

    
    Greeting greeting = new Greeting(greetingResult.data().copy());
    greeting.setMessage("This is a new message!");

    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(1L, greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    getOldCookbookBatchGetResult(client, requestOptions);

    
    Greeting repeatedGreeting = new Greeting();
    repeatedGreeting.setMessage("Hello Hello");
    repeatedGreeting.setTone(Tone.SINCERE);
    List<Greeting> entities = Arrays.asList(repeatedGreeting, repeatedGreeting);
    Request<CollectionResponse<CreateStatus>> batchCreateRequest = builders.batchCreate().inputs(entities).build();
    List<CreateStatus> statuses = client.sendRequest(batchCreateRequest).getResponse().getEntity().getElements();
    for (CreateStatus status : statuses)
    {
      Assert.assertEquals(status.getStatus().intValue(), HttpStatus.S_201_CREATED.getCode());
      @SuppressWarnings("deprecation")
      String id = status.getId();
      Assert.assertNotNull(id);
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCookbookDataProvider")
  public void testNewCookbookInBatch(RestClient client, RestliRequestOptions requestOptions) throws Exception
  {
    final GreetingsRequestBuilders builders = new GreetingsRequestBuilders(requestOptions);

    
    Greeting greetingResult = getNewCookbookBatchGetResult(client, requestOptions);

    
    Greeting greeting = new Greeting(greetingResult.data().copy());
    greeting.setMessage("This is a new message!");

    Request<BatchKVResponse<Long, UpdateStatus>> writeRequest = builders.batchUpdate().input(1L, greeting).build();
    client.sendRequest(writeRequest).getResponse();

    
    getNewCookbookBatchGetResult(client, requestOptions);

    
    Greeting repeatedGreeting = new Greeting();
    repeatedGreeting.setMessage("Hello Hello");
    repeatedGreeting.setTone(Tone.SINCERE);
    List<Greeting> entities = Arrays.asList(repeatedGreeting, repeatedGreeting);
    Request<BatchCreateIdResponse<Long>> batchCreateRequest = builders.batchCreate().inputs(entities).build();
    List<CreateIdStatus<Long>> statuses = client.sendRequest(batchCreateRequest).getResponse().getEntity().getElements();
    for (CreateIdStatus<Long> status : statuses)
    {
      Assert.assertEquals(status.getStatus().intValue(), HttpStatus.S_201_CREATED.getCode());
      @SuppressWarnings("deprecation")
      String id = status.getId();
      Assert.assertEquals(status.getKey().longValue(), Long.parseLong(id));
      Assert.assertNotNull(status.getKey());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearch(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("Search").setQueryParam("tone", Tone.FRIENDLY).build();
    Response<CollectionResponse<Greeting>> response = client.sendRequest(findRequest).getResponse();

    checkHeaderForCompression(response, operationsForCompression, "finder:search");

    List<Greeting> greetings = client.sendRequest(findRequest).getResponse().getEntity().getElements();
    for (Greeting g : greetings)
    {
      Assert.assertEquals(g.getTone(), Tone.FRIENDLY);
      Assert.assertNotNull(g.getMessage());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithoutDecompression(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
                                             ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("Search").setQueryParam("tone", Tone.FRIENDLY).build();
    RequestContext requestContext = new RequestContext();
    RequestContextUtil.turnOffResponseDecompression(requestContext);

    Map<String, Set<String>> methodsAndFamilies = getCompressionMethods(operationsForCompression);
    Set<String> methods = methodsAndFamilies.get("methods");
    Set<String> families = methodsAndFamilies.get("families");

    if (shouldCompress(families, methods, "finder:search"))
    {
      
      try
      {
        client.sendRequest(findRequest, requestContext).getResponse();
        Assert.fail("Expected RemoteInvocationException, but getResponse() succeeded.");
      }
      catch (RemoteInvocationException e)
      {
        Assert.assertEquals(e.getCause().getMessage(), "Could not decode REST response");
      }
    }
    else
    {
      
      client.sendRequest(findRequest, requestContext).getResponse();
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithPostFilter(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> findRequest = builders.findBy("SearchWithPostFilter").paginate(0, 5).build();
    Response<CollectionResponse<Greeting>> response = client.sendRequest(findRequest).getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + findRequest.getMethodName());
    CollectionResponse<Greeting> entity = response.getEntity();
    CollectionMetadata paging = entity.getPaging();
    Assert.assertEquals(paging.getStart().intValue(), 0);
    Assert.assertEquals(paging.getCount().intValue(), 5);
    Assert.assertEquals(entity.getElements().size(), 4); 

    
    Link next = paging.getLinks().get(0);
    Assert.assertEquals(next.getRel(), "next");

    
    
    final Map<String, String> queryParamsMap = new HashMap<String, String>();
    queryParamsMap.put("count", "5");
    queryParamsMap.put("start", "5");
    queryParamsMap.put("q", "searchWithPostFilter");

    final URIDetails uriDetails = new URIDetails(protocolVersion, "/greetings", null, queryParamsMap, null);
    URIDetails.testUriGeneration(next.getHref(), uriDetails);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchWithTones(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> req =
        builders.findBy("SearchWithTones").setQueryParam("tones", Arrays.asList(Tone.SINCERE, Tone.INSULTING)).build();
    ResponseFuture<CollectionResponse<Greeting>> future = client.sendRequest(req);
    Response<CollectionResponse<Greeting>> response = future.getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + req.getMethodName());
    List<Greeting> greetings = response.getEntity().getElements();
    for (Greeting greeting : greetings)
    {
      Assert.assertTrue(greeting.hasTone());
      Tone tone = greeting.getTone();
      Assert.assertTrue(Tone.SINCERE.equals(tone) || Tone.INSULTING.equals(tone));
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBuilderDataProvider")
  public void testSearchFacets(RestClient client, String operationsForCompression, RootBuilderWrapper<Long, Greeting> builders,
      ProtocolVersion protocolVersion) throws RemoteInvocationException
  {
    Request<CollectionResponse<Greeting>> req = builders.findBy("SearchWithFacets").setQueryParam("tone", Tone.SINCERE).build();
    ResponseFuture<CollectionResponse<Greeting>> future = client.sendRequest(req);
    Response<CollectionResponse<Greeting>> response = future.getResponse();
    checkHeaderForCompression(response, operationsForCompression, "finder:" + req.getMethodName());
    SearchMetadata metadata = new SearchMetadata(response.getEntity().getMetadataRaw());
    Assert.assertTrue(metadata.getFacets().size() > 0);
    
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGet(RestClient client,
                           String operationsForCompression,
                           RestliRequestOptions requestOptions,
                           List<Long> ids,
                           int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    @SuppressWarnings("unchecked")
    final BatchResponse<Greeting> response = (BatchResponse<Greeting>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size(), expectedSuccessSize);
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGetKV(RestClient client,
                             String operationsForCompression,
                             RestliRequestOptions requestOptions,
                             List<Long> ids,
                             int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).buildKV();
    @SuppressWarnings("unchecked")
    final BatchKVResponse<Long, Greeting> response = (BatchKVResponse<Long, Greeting>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size(), expectedSuccessSize);

    for (Map.Entry<Long, Greeting> entry : response.getResults().entrySet())
    {
      Assert.assertEquals(entry.getKey(), entry.getValue().getId());
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsCompressedResponsesBatchDataProvider")
  public void testBatchGetEntity(RestClient client,
                                 String operationsForCompression,
                                 RestliRequestOptions requestOptions,
                                 List<Long> ids,
                                 int expectedSuccessSize) throws RemoteInvocationException
  {
    final Request<?> request = new GreetingsRequestBuilders(requestOptions).batchGet().ids(ids).fields(Greeting.fields().id(), Greeting.fields().message()).build();
    @SuppressWarnings("unchecked")
    final BatchKVResponse<Long, EntityResponse<Greeting>> response = (BatchKVResponse<Long, EntityResponse<Greeting>>) getBatchGetResponse(client, operationsForCompression, request);
    Assert.assertEquals(response.getResults().size() - response.getErrors().size(), expectedSuccessSize);

    for (Map.Entry<Long, EntityResponse<Greeting>> entry : response.getResults().entrySet())
    {
      if (entry.getValue().hasEntry())
      {
        Assert.assertEquals(entry.getKey(), entry.getValue().getEntity().getId());
      }
    }
  }

  private Greeting getOldCookbookBatchGetResult(RestClient client, RestliRequestOptions requestOptions) throws RemoteInvocationException
  {
    Request<BatchResponse<Greeting>> request = new GreetingsBuilders(requestOptions).batchGet().ids(1L).build();
    ResponseFuture<BatchResponse<Greeting>> future = client.sendRequest(request);
    Response<BatchResponse<Greeting>> greetingResponse = future.getResponse();
    checkContentEncodingHeaderIsAbsent(greetingResponse);
    return greetingResponse.getEntity().getResults().get("1");
  }

  private Greeting getNewCookbookBatchGetResult(RestClient client, RestliRequestOptions requestOptions) throws RemoteInvocationException
  {
    Request<BatchKVResponse<Long, EntityResponse<Greeting>>> request = new GreetingsRequestBuilders(requestOptions).batchGet().ids(1L).build();
    ResponseFuture<BatchKVResponse<Long, EntityResponse<Greeting>>> future = client.sendRequest(request);
    Response<BatchKVResponse<Long, EntityResponse<Greeting>>> greetingResponse = future.getResponse();
    checkContentEncodingHeaderIsAbsent(greetingResponse);
    return greetingResponse.getEntity().getResults().get(1L).getEntity();
  }

  private Object getBatchGetResponse(RestClient client, String operationsForCompression, Request<?> request) throws RemoteInvocationException
  {
    final Response<?> response = client.sendRequest(request).getResponse();
    checkHeaderForCompression(response, operationsForCompression, "batch_get");
    return response.getEntity();
  }

  
  private <T> void checkHeaderForCompression(Response<T> response, String operationsConfig, String methodName)
  {
    String contentEncodingHeader = response.getHeader(CONTENT_ENCODING_SAVED);
    String allPossibleAcceptEncodings = "gzip, deflate, bzip2, snappy";

    Map<String, Set<String>> methodsAndFamilies = getCompressionMethods(operationsConfig);
    Set<String> methods = methodsAndFamilies.get("methods");
    Set<String> families = methodsAndFamilies.get("families");

    if (shouldCompress(families, methods, methodName))
    {
      if (contentEncodingHeader == null)
      {
        Assert.fail("Content-Encoding header absent");
      }
      Assert.assertTrue(allPossibleAcceptEncodings.contains(contentEncodingHeader));
    }
    else
    {
      Assert.assertNull(contentEncodingHeader);
    }
  }

  private boolean shouldCompress(Set<String> families, Set<String> methods, String methodName)
  {
    return families.contains("*") ||
           methods.contains(methodName) ||
           (methodName.contains(":") && families.contains(methodName.split(":")[0]));
  }

  
  private Map<String, Set<String>> getCompressionMethods(String operationsConfig)
  {
    Map<String, Set<String>> methodsAndFamilies = new HashMap<String, Set<String>>();
    methodsAndFamilies.put("methods", new HashSet<String>());
    methodsAndFamilies.put("families", new HashSet<String>());
    for (String operation: operationsConfig.split(","))
    {
      operation = operation.trim();
      if (operation.equals("*"))
      {
        
        methodsAndFamilies.get("families").add(operation);
      }
      else if (operation.endsWith(":*"))
      {
        
        methodsAndFamilies.get("families").add(operation.split(":")[0]);
      }
      else
      {
        
        methodsAndFamilies.get("methods").add(operation);
      }
    }
    return methodsAndFamilies;
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testMalformedPagination(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    expectPaginationError("-1", client, builders);
    expectPaginationError("abc", client, builders);
  }

  private void expectPaginationError(String count, RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    try
    {
      Request<CollectionResponse<Greeting>> request = builders.findBy("Search").name("search").setParam("count", count).build();
      client.sendRequest(request).getResponse();
      Assert.fail("expected exception");
    }
    catch (RestException e)
    {
      Assert.assertEquals(e.getResponse().getStatus(), HttpStatus.S_400_BAD_REQUEST.getCode(), "expected 400 status");
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void testException(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    try
    {
      Request<Void> request = builders.<Void>action("ExceptionTest").build();
      client.sendRequest(request).getResponse().getEntity();
      Assert.fail("expected exception");
    }
    catch (RestLiResponseException e)
    {
      Assert.assertEquals(e.getStatus(), HttpStatus.S_500_INTERNAL_SERVER_ERROR.getCode());
      Assert.assertTrue(e.getServiceErrorMessage().contains("Test Exception"));
    }
  }

  @Test(dataProvider = com.linkedin.restli.internal.common.TestConstants.RESTLI_PROTOCOL_1_2_PREFIX + "clientsNoCompressedResponsesDataProvider")
  public void test404(RestClient client, RootBuilderWrapper<Long, Greeting> builders) throws RemoteInvocationException
  {
    Request<Greeting> request = builders.get().id(999L).build();
    ResponseFuture<Greeting> future = client.sendRequest(request);
    try
    {
      future.getResponse();
      Assert.fail("expected 404");
    }
    catch (RestLiResponseException e)
    {
      Assert.assertEquals(e.getStatus(), HttpStatus.S_404_NOT_FOUND.getCode());
    }
  }
}

<code block>


package com.linkedin.d2.balancer.properties;


import java.util.HashSet;
import java.util.Set;



public enum AllowedClientPropertyKeys
{
  
  HTTP_QUERY_POST_THRESHOLD(PropertyKeys.HTTP_QUERY_POST_THRESHOLD),
  HTTP_POOL_SIZE(PropertyKeys.HTTP_POOL_SIZE),
  HTTP_REQUEST_TIMEOUT(PropertyKeys.HTTP_REQUEST_TIMEOUT),
  HTTP_IDLE_TIMEOUT(PropertyKeys.HTTP_IDLE_TIMEOUT),
  HTTP_MAX_RESPONSE_SIZE(PropertyKeys.HTTP_MAX_RESPONSE_SIZE),
  HTTP_SHUTDOWN_TIMEOUT(PropertyKeys.HTTP_SHUTDOWN_TIMEOUT),
  HTTP_RESPONSE_COMPRESSION_OPERATIONS(PropertyKeys.HTTP_RESPONSE_COMPRESSION_OPERATIONS),
  HTTP_POOL_WAITER_SIZE(PropertyKeys.HTTP_POOL_WAITER_SIZE),
  HTTP_POOL_MIN_SIZE(PropertyKeys.HTTP_POOL_MIN_SIZE);

  private static final Set<String> _allowedKeys;
  static
  {
    _allowedKeys = new HashSet<String>();
    for (AllowedClientPropertyKeys propertyKey: AllowedClientPropertyKeys.values())
    {
      _allowedKeys.add(propertyKey._keyName);
    }
  }

  private final String _keyName;

  AllowedClientPropertyKeys(String keyName)
  {
    _keyName = keyName;
  }

  public String getKeyName()
  {
    return _keyName;
  }

  public static boolean isAllowedConfigKey(String key)
  {
    return _allowedKeys.contains(key);
  }
}

<code block>


package com.linkedin.d2.balancer.properties;


import com.linkedin.r2.transport.http.client.HttpClientFactory;



public class PropertyKeys
{
  
  
  
  public static final String DEGRADER_PROPERTIES = "degraderProperties";
  public static final String DEGRADER_NAME = "degrader.name";
  public static final String DEGRADER_LOG_ENABLED = "degrader.logEnabled";
  public static final String DEGRADER_LATENCY_TO_USE = "degrader.latencyToUse";
  public static final String DEGRADER_OVERRIDE_DROP_DATE = "degrader.overrideDropDate";
  public static final String DEGRADER_MAX_DROP_RATE = "degrader.maxDropRate";
  public static final String DEGRADER_MAX_DROP_DURATION = "degrader.maxDropDuration";
  public static final String DEGRADER_UP_STEP = "degrader.upStep";
  public static final String DEGRADER_DOWN_STEP = "degrader.downStep";
  public static final String DEGRADER_MIN_CALL_COUNT = "degrader.minCallCount";
  public static final String DEGRADER_HIGH_LATENCY = "degrader.highLatency";
  public static final String DEGRADER_LOW_LATENCY = "degrader.lowLatency";
  public static final String DEGRADER_HIGH_ERROR_RATE = "degrader.highErrorRate";
  public static final String DEGRADER_LOW_ERROR_RATE = "degrader.lowErrorRate";
  public static final String DEGRADER_HIGH_OUTSTANDING = "degrader.highOutstanding";
  public static final String DEGRADER_LOW_OUTSTANDING = "degrader.lowOutstanding";
  public static final String DEGRADER_MIN_OUTSTANDING_COUNT = "degrader.minOutstandingCount";
  public static final String DEGRADER_OVERRIDE_MIN_CALL_COUNT = "degrader.overrideMinCallCount";

  
  public static final String PATH = "path";
  public static final String SERVICE_NAME = "serviceName";
  public static final String CLOCK = "clock";
  public static final String SERVICES = "services";
  public static final String TRANSPORT_CLIENT_PROPERTIES = "transportClientProperties";
  public static final String PRIORITIZED_SCHEMES = "prioritizedSchemes";
  public static final String BANNED_URIS = "bannedUri";
  public static final String DEFAULT_ROUTING = "defaultRouting";
  public static final String ALLOWED_CLIENT_OVERRIDE_KEYS = "allowedClientOverrideKeys";
  public static final String SERVICE_METADATA_PROPERTIES = "serviceMetadataProperties";

  
  public static final String LB_STRATEGY_LIST = "loadBalancerStrategyList";
  public static final String LB_STRATEGY_PROPERTIES = "loadBalancerStrategyProperties";

  
  public static final String HTTP_LB_HASH_METHOD = "http.loadBalancer.hashMethod";
  public static final String HTTP_LB_HASH_CONFIG = "http.loadBalancer.hashConfig";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_UPDATE_INTERVAL_MS = "http.loadBalancer.updateIntervalMs";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_MAX_CLUSTER_LATENCY_WITHOUT_DEGRADING = "http.loadBalancer.maxClusterLatencyWithoutDegrading";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_DEFAULT_SUCCESSFUL_TRANSMISSION_WEIGHT = "http.loadBalancer.defaultSuccessfulTransmissionWeight";
  public static final String HTTP_LB_STRATEGY_PROPERTIES_POINTS_PER_WEIGHT = "http.loadBalancer.pointsPerWeight";
  public static final String HTTP_LB_LOW_WATER_MARK = "http.loadBalancer.lowWaterMark";
  public static final String HTTP_LB_HIGH_WATER_MARK = "http.loadBalancer.highWaterMark";
  public static final String HTTP_LB_INITIAL_RECOVERY_LEVEL = "http.loadBalancer.initialRecoveryLevel";
  public static final String HTTP_LB_RING_RAMP_FACTOR = "http.loadBalancer.ringRampFactor";
  public static final String HTTP_LB_GLOBAL_STEP_UP = "http.loadBalancer.globalStepUp";
  public static final String HTTP_LB_GLOBAL_STEP_DOWN = "http.loadBalancer.globalStepDown";
  public static final String HTTP_LB_CLUSTER_MIN_CALL_COUNT_HIGH_WATER_MARK = "http.loadBalancer.clusterMinCallCount.highWaterMark";
  public static final String HTTP_LB_CLUSTER_MIN_CALL_COUNT_LOW_WATER_MARK = "http.loadBalancer.clusterMinCallCount.lowWaterMark";

  
  public static final String SERVICE_FOLLOW_REDIRECTION_MAX_HOP = "followRedirection.maxHop";

  
  public static final String CLUSTER_NAME = "clusterName";
  public static final String PARTITION_PROPERTIES = "partitionProperties";
  public static final String PARTITION_TYPE = "partitionType";
  public static final String KEY_RANGE_START = "keyRangeStart";
  public static final String PARTITION_SIZE = "partitionSize";
  public static final String PARTITION_COUNT = "partitionCount";
  public static final String PARTITION_KEY_REGEX = "partitionKeyRegex";
  public static final String HASH_ALGORITHM = "hashAlgorithm";
  public static final String CLUSTER_VARIANTS = "clusterVariants";
  public static final String TYPE = "type";
  public static final String CLUSTER_LIST = "clusterList";
  public static final String CLUSTER_VARIANTS_LIST = "clusterVariantsList";
  public static final String FULL_CLUSTER_LIST = "fullClusterList";

  
  public static final String HTTP_POOL_WAITER_SIZE = HttpClientFactory.HTTP_POOL_WAITER_SIZE;
  public static final String HTTP_REQUEST_TIMEOUT = HttpClientFactory.HTTP_REQUEST_TIMEOUT;
  public static final String HTTP_MAX_RESPONSE_SIZE = HttpClientFactory.HTTP_MAX_RESPONSE_SIZE;
  public static final String HTTP_POOL_SIZE = HttpClientFactory.HTTP_POOL_SIZE;
  public static final String HTTP_IDLE_TIMEOUT = HttpClientFactory.HTTP_IDLE_TIMEOUT;
  public static final String HTTP_SHUTDOWN_TIMEOUT = HttpClientFactory.HTTP_SHUTDOWN_TIMEOUT;
  public static final String HTTP_SSL_CONTEXT = HttpClientFactory.HTTP_SSL_CONTEXT;
  public static final String HTTP_SSL_PARAMS = HttpClientFactory.HTTP_SSL_PARAMS;
  public static final String HTTP_RESPONSE_COMPRESSION_OPERATIONS = HttpClientFactory.HTTP_RESPONSE_COMPRESSION_OPERATIONS;
  public static final String HTTP_REQUEST_CONTENT_ENCODINGS = HttpClientFactory.HTTP_REQUEST_CONTENT_ENCODINGS;
  public static final String HTTP_QUERY_POST_THRESHOLD = HttpClientFactory.HTTP_QUERY_POST_THRESHOLD;
  public static final String HTTP_POOL_STRATEGY = HttpClientFactory.HTTP_POOL_STRATEGY;
  public static final String HTTP_POOL_MIN_SIZE = HttpClientFactory.HTTP_POOL_MIN_SIZE;

  
  public static final String DEFAULT_COLO = "defaultColo";
  public static final String COLO_VARIANTS = "coloVariants";
  public static final String MASTER_COLO = "masterColo";
  public static final String MASTER_SUFFIX = "Master";
  public static final String HAS_COLO_VARIANTS = "hasColoVariants";
  
  public static final String IS_MASTER_SERVICE = "isMasterService";
  
  public static final String IS_DEFAULT_SERVICE = "isDefaultService";
  public static final String ENABLE_SYMLINK = "enableSymlink";

}

<code block>


package com.linkedin.r2.filter;


import com.linkedin.r2.filter.compression.ClientCompressionFilter;


public class CompressionConfig
{
  private final int _compressionThreshold;

  public CompressionConfig(int compressionThreshold)
  {
    if (compressionThreshold < 0)
    {
      throw new IllegalArgumentException("compressionThreshold should not be negative.");
    }
    _compressionThreshold = compressionThreshold;
  }

  @Override
  public boolean equals(Object o)
  {
    if (this == o)
    {
      return true;
    }
    if (o == null || getClass() != o.getClass())
    {
      return false;
    }

    CompressionConfig that = (CompressionConfig) o;

    if (_compressionThreshold != that._compressionThreshold)
    {
      return false;
    }

    return true;
  }

  @Override
  public int hashCode()
  {
    return _compressionThreshold;
  }

  @Override
  public String toString()
  {
    return "CompressionConfig{" +
        "_compressionThreshold=" + _compressionThreshold +
        '}';
  }

  
  public boolean shouldCompressRequest(int entityLength, CompressionOption requestCompressionOverride)
  {
    if (requestCompressionOverride != null)
    {
      return (requestCompressionOverride == CompressionOption.FORCE_ON);
    }
    return entityLength >= _compressionThreshold;
  }
}

<code block>
package com.linkedin.r2.filter.compression;

public class CompressionConstants
{
  protected static final int BUFFER_SIZE = 4*1024; 

  protected static final String DECODING_ERROR = "Cannot properly decode stream: ";
  protected static final String BAD_STREAM = "Bad input stream";

  protected static final String ILLEGAL_FORMAT = "Illegal format in Accept-Encoding: ";
  protected static final String NULL_COMPRESSOR_ERROR = "Request compression encoding must be valid non-null, use \"identity\"/EncodingType.IDENTITY for no compression.";

  protected static final String UNSUPPORTED_ENCODING = "Unsupported encoding referenced: ";
  protected static final String SERVER_ENCODING_ERROR = "Server returned unrecognized content encoding: ";
  protected static final String REQUEST_ANY_ERROR = "ANY may not be used as request encoding type: ";
  protected static final String UNKNOWN_ENCODING = "Unknown client encoding. ";
  protected static final String UNSUPPORTED_SERVER_ENCODING = "Bad encoding used for server compression constructor: ";

  protected static final String ENCODING_DELIMITER = ",";
  protected static final String QUALITY_DELIMITER = ";";
  protected static final String QUALITY_PREFIX = "q=";
}

<code block>


package com.linkedin.r2.filter.compression;


import com.linkedin.r2.filter.Filter;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.message.rest.RestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.common.HttpConstants;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ClientCompressionFilter implements Filter, RestFilter
{
  private static final Logger LOG = LoggerFactory.getLogger(ClientCompressionFilter.class);

  private final EncodingType _requestContentEncoding;
  private final CompressionConfig _requestCompressionConfig;
  
  private final EncodingType[] _acceptedEncodings;
  private final String _acceptEncodingHeader;

  
  private Set<String> _responseCompressionMethods;

  private boolean _compressAllResponses;

  
  private Set<String> _responseCompressionFamilies;

  
  private static final String COMPRESS_ALL_RESPONSES_INDICATOR = "*";

  private static final String FAMILY_SEPARATOR = ":";
  private static final String COMPRESS_ALL_IN_FAMILY = FAMILY_SEPARATOR + COMPRESS_ALL_RESPONSES_INDICATOR;


  
  public ClientCompressionFilter(EncodingType requestContentEncoding,
                                 CompressionConfig requestCompressionConfig,
                                 EncodingType[] acceptedEncodings,
                                 List<String> responseCompressionOperations)
  {
    if (requestContentEncoding == null)
    {
      throw new IllegalArgumentException(CompressionConstants.NULL_COMPRESSOR_ERROR);
    }

    if (acceptedEncodings == null)
    {
      acceptedEncodings = new EncodingType[0];
    }

    
    for (EncodingType type : acceptedEncodings)
    {
      if (type == null)
      {
        throw new IllegalArgumentException(CompressionConstants.NULL_COMPRESSOR_ERROR);
      }
    }

    if (requestContentEncoding.equals(EncodingType.ANY))
    {
      throw new IllegalArgumentException(CompressionConstants.REQUEST_ANY_ERROR
                                         + requestContentEncoding.getHttpName());
    }

    _requestContentEncoding = requestContentEncoding;
    _requestCompressionConfig = requestCompressionConfig;
    _acceptedEncodings = acceptedEncodings;

    _acceptEncodingHeader = buildAcceptEncodingHeader();
    _responseCompressionMethods = new HashSet<String>();
    _responseCompressionFamilies = new HashSet<String>();
    buildResponseCompressionMethodsAndFamiliesSet(responseCompressionOperations);
    
    _compressAllResponses = _responseCompressionMethods.contains(COMPRESS_ALL_RESPONSES_INDICATOR);
  }

  
  public ClientCompressionFilter(String requestContentEncoding,
                                 CompressionConfig requestCompressionConfig,
                                 String acceptedEncodings,
                                 List<String> responseCompressionOperations)
  {
    this(requestContentEncoding.trim().isEmpty() ? EncodingType.IDENTITY : EncodingType.get(requestContentEncoding.trim().toLowerCase()),
        requestCompressionConfig,
        AcceptEncoding.parseAcceptEncoding(acceptedEncodings),
        responseCompressionOperations);
  }

  
  private void buildResponseCompressionMethodsAndFamiliesSet(List<String> responseCompressionOperations)
  {
    for (String operation: responseCompressionOperations)
    {
      
      if (operation.endsWith(COMPRESS_ALL_IN_FAMILY))
      {
        String[] parts = operation.split(FAMILY_SEPARATOR);
        if (parts == null || parts.length != 2)
        {
          LOG.warn("Illegal compression operation family " + operation + " specified");
          return;
        }
        _responseCompressionFamilies.add(parts[0].trim());
      }
      else
      {
        _responseCompressionMethods.add(operation);
      }
    }
  }

  
  public String buildAcceptEncodingHeader()
  {
    
    float delta = 1.0f/(_acceptedEncodings.length+1);
    float currentQuality = 1.0f;

    
    StringBuilder acceptEncodingValue = new StringBuilder();
    for(int i=0; i < _acceptedEncodings.length; i++)
    {
      EncodingType t = _acceptedEncodings[i];

      if(i > 0)
      {
        acceptEncodingValue.append(CompressionConstants.ENCODING_DELIMITER);
      }
      acceptEncodingValue.append(t.getHttpName());
      acceptEncodingValue.append(CompressionConstants.QUALITY_DELIMITER);
      acceptEncodingValue.append(CompressionConstants.QUALITY_PREFIX);
      acceptEncodingValue.append(String.format("%.2f", currentQuality));
      currentQuality = currentQuality - delta;
    }

    return acceptEncodingValue.toString();
  }

  
  @Override
  public void onRestRequest(RestRequest req, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      if (_requestContentEncoding.hasCompressor())
      {
        if (_requestCompressionConfig.shouldCompressRequest(
            req.getEntity().length(),
            (CompressionOption) requestContext.getLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE)
        ))
        {
          Compressor compressor = _requestContentEncoding.getCompressor();
          byte[] compressed = compressor.deflate(req.getEntity().asInputStream());

          if (compressed.length < req.getEntity().length())
          {
            req = req.builder().setEntity(compressed).setHeader(HttpConstants.CONTENT_ENCODING,
                compressor.getContentEncodingName()).build();
          }
        }
      }

      
      String operation = (String) requestContext.getLocalAttr(R2Constants.OPERATION);
      if (operation != null && _acceptedEncodings.length > 0 && shouldCompressResponse(operation))
      {
        req = req.builder().addHeaderValue(HttpConstants.ACCEPT_ENCODING, _acceptEncodingHeader).build();
      }
    }
    catch (CompressionException e)
    {
      LOG.error(e.getMessage(), e.getCause());
    }

    
    nextFilter.onRequest(req, requestContext, wireAttrs);
  }

  
  private boolean shouldCompressResponse(String operation)
  {
    return _compressAllResponses ||
           _responseCompressionMethods.contains(operation) ||
           isMemberOfCompressionFamily(operation);
  }

  
  private boolean isMemberOfCompressionFamily(String operation)
  {
    if (operation.contains(FAMILY_SEPARATOR))
    {
      String[] parts = operation.split(FAMILY_SEPARATOR);
      if (parts == null || parts.length != 2)
      {
        return false;
      }
      String family = parts[0];
      return _responseCompressionFamilies.contains(family);
    }
    return false;
  }

  
  @Override
  public void onRestResponse(RestResponse res, RequestContext requestContext,
                             Map<String, String> wireAttrs,
                             NextFilter<RestRequest, RestResponse> nextFilter)
  {
    Boolean decompressionOff = (Boolean) requestContext.getLocalAttr(R2Constants.RESPONSE_DECOMPRESSION_OFF);
    if (decompressionOff == null || !decompressionOff)
    {
      try
      {
        
        String compressionHeader = res.getHeader(HttpConstants.CONTENT_ENCODING);

        
        if (compressionHeader != null && res.getEntity().length() > 0)
        {
          EncodingType encoding = null;
          try
          {
            encoding = EncodingType.get(compressionHeader.trim().toLowerCase());
          }
          catch (IllegalArgumentException e)
          {
            throw new CompressionException(CompressionConstants.SERVER_ENCODING_ERROR + compressionHeader);
          }
          if (!encoding.hasCompressor())
          {
            throw new CompressionException(CompressionConstants.SERVER_ENCODING_ERROR + compressionHeader);
          }
          byte[] inflated = encoding.getCompressor().inflate(res.getEntity().asInputStream());
          Map<String, String> headers = new HashMap<String, String>(res.getHeaders());
          headers.remove(HttpConstants.CONTENT_ENCODING);
          headers.put(HttpConstants.CONTENT_LENGTH, Integer.toString(inflated.length));
          res = res.builder().setEntity(inflated).setHeaders(headers).build();
        }
      }
      catch (CompressionException e)
      {
        nextFilter.onError(e, requestContext, wireAttrs);
        return;
      }
    }

    nextFilter.onResponse(res, requestContext, wireAttrs);
  }

  @Override
  public void onRestError(Throwable ex, RequestContext requestContext,
                          Map<String, String> wireAttrs,
                          NextFilter<RestRequest, RestResponse> nextFilter)
  {
    nextFilter.onError(ex, requestContext, wireAttrs);
  }

}

<code block>


package com.linkedin.r2.filter.compression;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.linkedin.r2.filter.Filter;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.message.rest.RestFilter;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestException;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.message.rest.RestResponseBuilder;
import com.linkedin.r2.transport.http.common.HttpConstants;


public class ServerCompressionFilter implements Filter, RestFilter
{
  private static final Logger LOG = LoggerFactory.getLogger(ServerCompressionFilter.class);

  private final Set<EncodingType> _supportedEncoding;

  
  public ServerCompressionFilter()
  {
    this(new EncodingType[0]);
  }

  
  public ServerCompressionFilter(String acceptedFilters)
  {
    this(AcceptEncoding.parseAcceptEncoding(acceptedFilters));
  }

  
  public ServerCompressionFilter(EncodingType[] supportedEncoding)
  {
    _supportedEncoding = new HashSet<EncodingType>(Arrays.asList(supportedEncoding));
    _supportedEncoding.add(EncodingType.IDENTITY);
    _supportedEncoding.add(EncodingType.ANY);
  }

  
  @Override
  public void onRestRequest(RestRequest req, RequestContext requestContext,
                            Map<String, String> wireAttrs,
                            NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      
      String requestContentEncoding = req.getHeader(HttpConstants.CONTENT_ENCODING);

      if (requestContentEncoding != null)
      {
        
        EncodingType encoding;
        try
        {
          encoding = EncodingType.get(requestContentEncoding.trim().toLowerCase());
        }
        catch (IllegalArgumentException ex)
        {
          throw new CompressionException(CompressionConstants.UNSUPPORTED_ENCODING
              + requestContentEncoding);
        }
        if (encoding == EncodingType.ANY)
        {
          throw new CompressionException(CompressionConstants.REQUEST_ANY_ERROR
              + requestContentEncoding);
        }

        
        if (encoding.hasCompressor())
        {
          byte[] decompressedContent = encoding.getCompressor().inflate(req.getEntity().asInputStream());
          Map<String, String> headers = new HashMap<String, String>(req.getHeaders());
          headers.remove(HttpConstants.CONTENT_ENCODING);
          headers.put(HttpConstants.CONTENT_LENGTH, Integer.toString(decompressedContent.length));
          req = req.builder().setEntity(decompressedContent).setHeaders(headers).build();
        }
      }

      
      String responseCompression = req.getHeader(HttpConstants.ACCEPT_ENCODING);
      if (responseCompression == null)
      {
        responseCompression = ""; 
      }

      requestContext.putLocalAttr(HttpConstants.ACCEPT_ENCODING, responseCompression);
      nextFilter.onRequest(req, requestContext, wireAttrs);
    }
    catch (CompressionException e)
    {
      
      LOG.error(e.getMessage(), e.getCause());
      RestResponse restResponse = new RestResponseBuilder().setStatus(HttpConstants.UNSUPPORTED_MEDIA_TYPE).build();
      nextFilter.onError(new RestException(restResponse, e), requestContext, wireAttrs);
    }
  }

  
  @Override
  public void onRestResponse(RestResponse res, RequestContext requestContext,
                             Map<String, String> wireAttrs,
                             NextFilter<RestRequest, RestResponse> nextFilter)
  {
    try
    {
      if (res.getEntity().length() > 0)
      {
        String responseCompression = (String) requestContext.getLocalAttr(HttpConstants.ACCEPT_ENCODING);
        if (responseCompression == null)
        {
          throw new CompressionException(CompressionConstants.UNKNOWN_ENCODING);
        }

        List<AcceptEncoding> parsedEncodings = AcceptEncoding.parseAcceptEncodingHeader(responseCompression, _supportedEncoding);
        EncodingType selectedEncoding = AcceptEncoding.chooseBest(parsedEncodings);

        
        if (selectedEncoding != null)
        {
          
          
          
          if (selectedEncoding.hasCompressor())
          {
            Compressor compressor = selectedEncoding.getCompressor();
            byte[] compressed = compressor.deflate(res.getEntity().asInputStream());

            if (compressed.length < res.getEntity().length())
            {
              RestResponseBuilder resCompress = res.builder();
              resCompress.addHeaderValue(HttpConstants.CONTENT_ENCODING, compressor.getContentEncodingName());
              resCompress.setEntity(compressed);
              res = resCompress.build();
            }
          }
        }
        else
        {
          
          res = res.builder().setStatus(HttpConstants.NOT_ACCEPTABLE).setEntity(new byte[0]).build();
        }
      }
    }
    catch (CompressionException e)
    {
      LOG.error(e.getMessage(), e.getCause());
    }

    nextFilter.onResponse(res, requestContext, wireAttrs);
  }


  @Override
  public void onRestError(Throwable ex, RequestContext requestContext,
                          Map<String, String> wireAttrs,
                          NextFilter<RestRequest, RestResponse> nextFilter)
  {
    nextFilter.onError(ex, requestContext, wireAttrs);
  }
}

<code block>


package com.linkedin.r2.filter.compression;

import com.linkedin.r2.filter.R2Constants;
import com.linkedin.r2.filter.NextFilter;
import com.linkedin.r2.filter.CompressionConfig;
import com.linkedin.r2.filter.CompressionOption;
import com.linkedin.r2.filter.compression.ClientCompressionFilter;
import com.linkedin.r2.filter.compression.CompressionException;
import com.linkedin.r2.filter.compression.EncodingType;
import com.linkedin.r2.message.RequestContext;
import com.linkedin.r2.message.rest.RestMethod;
import com.linkedin.r2.message.rest.RestRequest;
import com.linkedin.r2.message.rest.RestRequestBuilder;
import com.linkedin.r2.message.rest.RestResponse;
import com.linkedin.r2.transport.http.common.HttpConstants;

import java.io.ByteArrayInputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;


public class TestClientCompressionFilter
{

  private static final String ACCEPT_COMPRESSIONS = "gzip, deflate, bzip2, snappy";
  private static final String URI = "http:

  
  class HeaderCaptureFilter implements NextFilter<RestRequest, RestResponse>
  {

    private boolean _shouldBePresent;
    private String _headerName;
    private int _entityLength = 0;

    public HeaderCaptureFilter(String headerName, boolean shouldBePresent)
    {
      _shouldBePresent = shouldBePresent;
      _headerName = headerName;
    }

    public HeaderCaptureFilter(String headerName, boolean shouldBePresent, int entityLength)
    {
      this(headerName, shouldBePresent);
      _entityLength = entityLength;
    }

    @Override
    public void onRequest(RestRequest restRequest, RequestContext requestContext, Map<String, String> wireAttrs)
    {
      String header = restRequest.getHeader(_headerName);
      if (_shouldBePresent)
      {
        Assert.assertNotNull(header);
      }
      else
      {
        Assert.assertNull(header);
      }
      if (_entityLength > 0)
      {
        Assert.assertEquals(restRequest.getEntity().length(), _entityLength);
      }
    }

    @Override
    public void onResponse(RestResponse restResponse, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }

    @Override
    public void onError(Throwable ex, RequestContext requestContext, Map<String, String> wireAttrs)
    {

    }
  }

  @DataProvider(name = "operationsData")
  public Object[][] provideOperationsData()
  {
    return new Object[][] {
        {"*", new String[]{"foo", "bar", "foo:bar"}, true},

        {"foo", new String[]{"foo"}, true},
        {"foo", new String[]{"bar", "foo:bar"}, false},

        {"foo,bar,foobar", new String[]{"foo", "bar", "foobar"}, true},
        {"foo,bar,foobar", new String[]{"baz", "foo:bar", "bar:foo"}, false},

        {"foo:*", new String[]{"foo:foo", "foo:bar", "foo:baz"}, true},
        {"foo:*", new String[]{"foo", "bar"}, false},

        {"foo:*,bar:*", new String[]{"foo:foo", "foo:bar", "bar:bar", "bar:foo"}, true},
        {"foo:*,bar:*", new String[]{"baz", "baz:foo", "foo", "bar"}, false},

        {"foo:*,bar:*,baz,foo", new String[]{"foo:foo", "foo:bar", "bar:bar", "bar:foo", "baz", "foo"}, true},
        {"foo:*,bar:*,baz,foo", new String[]{"bar", "foobar", "foobarbaz", "baz:bar", "foobar:bazbar"}, false}
    };
  }

  @Test(dataProvider = "operationsData")
  public void testCompressionOperations(String compressionConfig, String[] operations, boolean headerShouldBePresent)
      throws URISyntaxException
  {
    RestRequest restRequest = new RestRequestBuilder(new URI(URI)).build();
    ClientCompressionFilter clientCompressionFilter = new ClientCompressionFilter(EncodingType.IDENTITY.getHttpName(),
                                                                                  new CompressionConfig(Integer.MAX_VALUE),
                                                                                  ACCEPT_COMPRESSIONS,
                                                                                  Arrays.asList(compressionConfig.split(",")));

    for (String operation: operations)
    {
      RequestContext context = new RequestContext();
      context.putLocalAttr(R2Constants.OPERATION, operation);

      clientCompressionFilter.onRestRequest(restRequest,
                                            context,
                                            Collections.<String, String>emptyMap(),
                                            new HeaderCaptureFilter(HttpConstants.ACCEPT_ENCODING, headerShouldBePresent));
    }
  }

  @DataProvider(name = "requestData")
  private Object[][] provideRequestData()
  {
    CompressionConfig smallThresholdConfig = new CompressionConfig(1);
    CompressionConfig largeThresholdConfig = new CompressionConfig(10000);

    return new Object[][] {
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_OFF, false},
        {new CompressionConfig(Integer.MAX_VALUE), CompressionOption.FORCE_ON, true},
        {new CompressionConfig(Integer.MAX_VALUE), null, false},
        {new CompressionConfig(0), CompressionOption.FORCE_OFF, false},
        {new CompressionConfig(0), CompressionOption.FORCE_ON, true},
        {new CompressionConfig(0), null, true},
        {smallThresholdConfig, CompressionOption.FORCE_OFF, false},
        {smallThresholdConfig, CompressionOption.FORCE_ON, true},
        {smallThresholdConfig, null, true},
        {largeThresholdConfig, CompressionOption.FORCE_OFF, false},
        {largeThresholdConfig, CompressionOption.FORCE_ON, true},
        {largeThresholdConfig, null, false}
    };
  }

  @Test(dataProvider = "requestData")
  public void testRequestCompressionRules(CompressionConfig requestCompressionConfig,
                                          CompressionOption requestCompressionOverride, boolean headerShouldBePresent)
      throws CompressionException, URISyntaxException
  {
    ClientCompressionFilter clientCompressionFilter = new ClientCompressionFilter(EncodingType.SNAPPY.getHttpName(),
        requestCompressionConfig,
        ACCEPT_COMPRESSIONS,
        Collections.<String>emptyList());
    
    int original = 100;
    byte[] entity = new byte[original];
    Arrays.fill(entity, (byte)'A');
    RestRequest restRequest = new RestRequestBuilder(new URI(URI)).setMethod(RestMethod.POST).setEntity(entity).build();
    int compressed = EncodingType.SNAPPY.getCompressor().deflate(new ByteArrayInputStream(entity)).length;
    RequestContext context = new RequestContext();
    context.putLocalAttr(R2Constants.OPERATION, "");
    context.putLocalAttr(R2Constants.REQUEST_COMPRESSION_OVERRIDE, requestCompressionOverride);
    int entityLength = headerShouldBePresent ? compressed : original;
    clientCompressionFilter.onRestRequest(restRequest, context, Collections.<String, String>emptyMap(),
        new HeaderCaptureFilter(HttpConstants.CONTENT_ENCODING, headerShouldBePresent, entityLength));
  }
}
