

package org.intellij.erlang.compilation;

import com.intellij.compiler.server.BuildManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.CompileContext;
import com.intellij.openapi.compiler.CompileTask;
import com.intellij.openapi.compiler.CompilerMessageCategory;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.util.JDOMUtil;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.util.Function;
import com.intellij.util.SystemProperties;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.graph.DFSTBuilder;
import com.intellij.util.graph.GraphGenerator;
import com.intellij.util.xmlb.SkipDefaultValuesSerializationFilters;
import com.intellij.util.xmlb.XmlSerializationException;
import com.intellij.util.xmlb.XmlSerializer;
import org.intellij.erlang.configuration.ErlangCompilerSettings;
import org.intellij.erlang.facet.ErlangFacet;
import org.intellij.erlang.jps.builder.ErlangBuilder;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrderDescriptor;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrders;
import org.intellij.erlang.jps.builder.ErlangFileDescriptor;
import org.intellij.erlang.psi.ErlangFile;
import org.intellij.erlang.psi.impl.ErlangPsiImplUtil;
import org.intellij.erlang.utils.ErlangModulesUtil;
import org.jdom.Document;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.TestOnly;

import java.io.File;
import java.io.IOException;
import java.util.*;


public class ErlangPrepareDependenciesCompileTask implements CompileTask {
  @Override
  public boolean execute(final CompileContext context) {
    Project project = context.getProject();
    if (ErlangCompilerSettings.getInstance(project).isUseRebarCompilerEnabled()) {

      return true;
    }

    File projectSystemDirectory = BuildManager.getInstance().getProjectSystemDirectory(project);
    if (projectSystemDirectory == null) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }

    ErlangModuleBuildOrders buildOrders = ApplicationManager.getApplication().runReadAction(new Computable<ErlangModuleBuildOrders>() {
      @Nullable
      @Override
      public ErlangModuleBuildOrders compute() {
        return getModuleBuildOrders(context);
      }
    });
    if (buildOrders == null) {
      return false; 
    }
    try {
      Document serializedBuildOrders = new Document(XmlSerializer.serialize(buildOrders, new SkipDefaultValuesSerializationFilters()));
      File file = new File(projectSystemDirectory, ErlangBuilder.DEPENDENCIES_CONFIG_FILE_PATH);

      file.getParentFile().mkdirs();
      JDOMUtil.writeDocument(serializedBuildOrders, file, SystemProperties.getLineSeparator());
    }
    catch (XmlSerializationException e) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }
    catch (IOException e) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }

    return true;
  }

  public static void addPrepareDependenciesFailedMessage(CompileContext context) {
    context.addMessage(CompilerMessageCategory.WARNING, "Failed to submit dependencies info to compiler. Parse transform failures may occur.", null, -1, -1);
  }

  @TestOnly
  static ErlangModuleBuildOrderDescriptor getModuleBuildOrder(Module module) throws CyclicDependencyFoundException {
    return getModuleBuildOrderInner(module);
  }

  @Nullable
  private static ErlangModuleBuildOrders getModuleBuildOrders(CompileContext context) {
    Module[] modulesToCompile = context.getCompileScope().getAffectedModules();
    ErlangModuleBuildOrders buildOrders = new ErlangModuleBuildOrders(modulesToCompile.length);
    try {
      for (Module module : modulesToCompile) {
        buildOrders.myModuleBuildOrderDescriptors.add(getModuleBuildOrderInner(module));
      }
    }
    catch (CyclicDependencyFoundException e) {
      context.addMessage(CompilerMessageCategory.ERROR, "Cyclic erlang module dependency detected. Check parse_transform usages.", null, -1, -1);
      return null;
    }
    return buildOrders;
  }

  private static ErlangModuleBuildOrderDescriptor getModuleBuildOrderInner(Module module) throws CyclicDependencyFoundException {
    ErlangModuleBuildOrderDescriptor buildOrder = new ErlangModuleBuildOrderDescriptor();
    ErlangFacet erlangFacet = ErlangFacet.getFacet(module);
    List<String> globalParseTransforms = erlangFacet != null ? erlangFacet.getConfiguration().getParseTransforms() : ContainerUtil.<String>emptyList();
    buildOrder.myModuleName = module.getName();
    buildOrder.myOrderedErlangModulePaths = getTopologicallySortedErlangModulePaths(ErlangModulesUtil.getErlangModules(module, false), globalParseTransforms);
    buildOrder.myOrderedErlangTestModulePaths = getTopologicallySortedErlangModulePaths(ErlangModulesUtil.getErlangModules(module, true), ContainerUtil.<String>emptyList());
    return buildOrder;
  }

  private static List<ErlangFileDescriptor> getTopologicallySortedErlangModulePaths(Collection<ErlangFile> erlangModules,
                                                                                    List<String> globalParseTransforms) throws CyclicDependencyFoundException {
    return ErlangModulesSorter.sort(erlangModules, globalParseTransforms);
  }

  private static class ErlangModulesSorter {
    private final Collection<ErlangFile> myModules;
    private final List<String> myGlobalParseTransforms;

    private ErlangModulesSorter(Collection<ErlangFile> modules, List<String> globalParseTransforms) {
      myModules = modules;
      myGlobalParseTransforms = globalParseTransforms;
    }

    public static List<ErlangFileDescriptor> sort(Collection<ErlangFile> erlangModules,
                                                  List<String> globalParseTransforms) throws CyclicDependencyFoundException {
      ErlangModulesSorter sorter = new ErlangModulesSorter(erlangModules, globalParseTransforms);
      return sorter.getSortedModules();
    }

    private GraphGenerator<Node> createModulesGraph() {
      return GraphGenerator.create(new ErlangModulesDependencyGraph(myModules, myGlobalParseTransforms));
    }

    private List<ErlangFileDescriptor> getSortedModules() throws CyclicDependencyFoundException {
      GraphGenerator<Node> graph = createModulesGraph();
      DFSTBuilder<Node> builder = new DFSTBuilder<Node>(graph);
      builder.buildDFST();
      if (!builder.isAcyclic()) {
        throw new CyclicDependencyFoundException();
      }
      return ContainerUtil.map(builder.getSortedNodes(), new Function<Node, ErlangFileDescriptor>() {
        @Override
        public ErlangFileDescriptor fun(Node node) {
          return getModuleDescriptor(node);
        }
      });
    }

    @NotNull
    private static ErlangFileDescriptor getModuleDescriptor(Node node) {
      ErlangFileDescriptor result = new ErlangFileDescriptor();
      result.myErlangModulePath = getErlangFilePath(node);
      result.myDependencies = ContainerUtil.map(node.getDependencies(), new Function<Node, String>() {
        @Nullable
        @Override
        public String fun(Node node) {
          return getErlangFilePath(node);
        }
      });
      return result;
    }

    @Nullable
    private static String getErlangFilePath(Node node) {
      VirtualFile virtualFile = node.getModuleFile().getVirtualFile();
      return virtualFile != null ? virtualFile.getPath() : null;
    }

    private static class ErlangModulesDependencyGraph implements GraphGenerator.SemiGraph<Node> {
      private final HashMap<String, Node> myNamesToNodesMap;

      public ErlangModulesDependencyGraph(Collection<ErlangFile> modules, List<String> globalParseTransforms) {
        myNamesToNodesMap = ContainerUtil.newHashMap();
        for (ErlangFile moduleFile : modules) {
          Node node = new Node(moduleFile);
          myNamesToNodesMap.put(node.getModuleName(), node);
        }
        buildDependencies(globalParseTransforms);
      }

      @Override
      public Collection<Node> getNodes() {
        return myNamesToNodesMap.values();
      }

      @Override
      public Iterator<Node> getIn(Node node) {
        return node.getDependencies().iterator();
      }

      private void buildDependencies(List<String> globalParseTransforms) {
        List<Node> globalPtNodes = getModuleNodes(globalParseTransforms);
        for (Node module : myNamesToNodesMap.values()) {
          Set<String> moduleNames = ContainerUtil.newHashSet();
          moduleNames.addAll(ErlangPsiImplUtil.getAppliedParseTransformModuleNames(module.getModuleFile()));
          moduleNames.addAll(ErlangPsiImplUtil.getImplementedBehaviourModuleNames(module.getModuleFile()));
          List<Node> dependencies = getModuleNodes(moduleNames);
          module.addDependencies(dependencies);
          module.addDependencies(globalPtNodes);
        }
      }

      private List<Node> getModuleNodes(Collection<String> nodesName) {
        return ContainerUtil.mapNotNull(nodesName, new Function<String, Node>() {
          @Override
          public Node fun(String pt) {
            return myNamesToNodesMap.get(pt);
          }
        });
      }
    }

    private static class Node {
      private final ErlangFile myModuleFile;
      private final List<Node> myDependencies = ContainerUtil.newArrayList();

      Node(ErlangFile moduleFile) {
        myModuleFile = moduleFile;
      }

      @Override
      public int hashCode() {
        return myModuleFile.getName().hashCode();
      }

      @Override
      public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Node node = (Node) o;

        return myModuleFile.getName().equals(node.myModuleFile.getName());
      }

      public void addDependencies(@NotNull Collection<Node> deps) {
        for (Node dep : deps) {
          addDependency(dep);
        }
      }

      ErlangFile getModuleFile() {
        return myModuleFile;
      }

      String getModuleName() {
        return FileUtil.getNameWithoutExtension(myModuleFile.getName());
      }

      void addDependency(@Nullable Node dep) {
        if (dep != null && dep != this) {
          myDependencies.add(dep);
        }
      }

      @NotNull
      List<Node> getDependencies() {
        return myDependencies;
      }
    }
  }

  static class CyclicDependencyFoundException extends Exception {
    CyclicDependencyFoundException() {
    }
  }
}
<code block>


package org.intellij.erlang.utils;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.ModuleFileIndex;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.Processor;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.Convertor;
import org.intellij.erlang.ErlangFileType;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.psi.ErlangFile;
import org.intellij.erlang.psi.ErlangModule;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public final class ErlangModulesUtil {
  private ErlangModulesUtil() {
  }

  @NotNull
  public static GlobalSearchScope getModuleWithDependenciesScope(@NotNull Module module, boolean includeTests) {
    return GlobalSearchScope
      .moduleWithDependenciesAndLibrariesScope(module, includeTests)
      .intersectWith(GlobalSearchScope.moduleWithDependenciesScope(module));
  }

  @Nullable
  public static ErlangModule getErlangModule(@NotNull final Project project,
                                             @NotNull final String moduleName,
                                             @NotNull final GlobalSearchScope scope) {
    return ApplicationManager.getApplication().runReadAction(new Computable<ErlangModule>() {
      @Nullable
      @Override
      public ErlangModule compute() {
        return doGetErlangModule(project, moduleName, scope);
      }
    });
  }

  @Nullable
  public static ErlangFile getErlangModuleFile(@NotNull final Project project,
                                               @NotNull final String moduleName,
                                               @NotNull final GlobalSearchScope scope) {
    return ApplicationManager.getApplication().runReadAction(new Computable<ErlangFile>() {
      @Nullable
      @Override
      public ErlangFile compute() {
        ErlangModule module = doGetErlangModule(project, moduleName, scope);
        PsiFile containingFile = module != null ? module.getContainingFile() : null;
        return containingFile instanceof ErlangFile ? (ErlangFile) containingFile : null;
      }
    });
  }

  @Nullable
  private static ErlangModule doGetErlangModule(@NotNull Project project,
                                                @NotNull String moduleName,
                                                @NotNull GlobalSearchScope scope) {
    List<ErlangModule> modules = ErlangModuleIndex.getModulesByName(project, moduleName, scope);
    return ContainerUtil.getFirstItem(modules);
  }

  @NotNull
  public static Collection<ErlangFile> getErlangModules(@NotNull Project project) {
    HashSet<ErlangFile> erlangModules = new HashSet<ErlangFile>();
    for (Module module : ModuleManager.getInstance(project).getModules()) {
      addErlangModules(module, false, erlangModules);
    }
    return erlangModules;
  }

  @NotNull
  public static Collection<ErlangFile> getErlangModules(@NotNull Module module, boolean onlyTestModules) {
    return addErlangModules(module, onlyTestModules, new HashSet<ErlangFile>());
  }

  @NotNull
  private static Collection<ErlangFile> addErlangModules(@NotNull Module module, boolean onlyTestModules, @NotNull Collection<ErlangFile> erlangModules) {
    ModuleRootManager rootManager = ModuleRootManager.getInstance(module);
    ModuleFileIndex moduleFileIndex = rootManager.getFileIndex();
    Processor<VirtualFile> modulesCollector = getErlangModulesCollector(PsiManager.getInstance(module.getProject()), erlangModules);
    Convertor<VirtualFile, Boolean> sourceDirectoriesFilter = onlyTestModules ? getTestDirectoriesFilter(moduleFileIndex) : getSourceDirectoriesFilter(moduleFileIndex);

    for (VirtualFile sourceRoot : rootManager.getSourceRoots(onlyTestModules)) {
      VfsUtilCore.processFilesRecursively(sourceRoot, modulesCollector, sourceDirectoriesFilter);
    }

    return erlangModules;
  }

  @NotNull
  private static Convertor<VirtualFile, Boolean> getSourceDirectoriesFilter(@NotNull final ModuleFileIndex moduleFileIndex) {
    return new Convertor<VirtualFile, Boolean>() {
      @Override
      public Boolean convert(@NotNull VirtualFile dir) {
        return moduleFileIndex.isInSourceContent(dir);
      }
    };
  }

  @NotNull
  private static Convertor<VirtualFile, Boolean> getTestDirectoriesFilter(@NotNull final ModuleFileIndex moduleFileIndex) {
    return new Convertor<VirtualFile, Boolean>() {
      @Override
      public Boolean convert(@NotNull VirtualFile dir) {
        return moduleFileIndex.isInTestSourceContent(dir);
      }
    };
  }

  @Nullable
  private static Processor<VirtualFile> getErlangModulesCollector(@NotNull final PsiManager psiManager, @NotNull final Collection<ErlangFile> erlangFiles) {
    return new Processor<VirtualFile>() {
      @Override
      public boolean process(@NotNull VirtualFile virtualFile) {
        if (virtualFile.getFileType() == ErlangFileType.MODULE) {
          PsiFile psiFile = psiManager.findFile(virtualFile);
          if (psiFile instanceof ErlangFile) {
            erlangFiles.add((ErlangFile) psiFile);
          }
        }
        return true;
      }
    };
  }
}

<code block>


package org.intellij.erlang.psi.impl;

import com.intellij.codeInsight.completion.BasicInsertHandler;
import com.intellij.codeInsight.completion.InsertHandler;
import com.intellij.codeInsight.completion.InsertionContext;
import com.intellij.codeInsight.completion.PrioritizedLookupElement;
import com.intellij.codeInsight.completion.util.ParenthesesInsertHandler;
import com.intellij.codeInsight.lookup.LookupElement;
import com.intellij.codeInsight.lookup.LookupElementBuilder;
import com.intellij.execution.console.LanguageConsoleImpl;
import com.intellij.lang.ASTNode;
import com.intellij.navigation.ItemPresentation;
import com.intellij.openapi.application.AccessToken;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleUtilCore;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.patterns.PatternCondition;
import com.intellij.patterns.PsiElementPattern;
import com.intellij.psi.*;
import com.intellij.psi.formatter.FormatterUtil;
import com.intellij.psi.impl.ResolveScopeManager;
import com.intellij.psi.impl.source.resolve.reference.ReferenceProvidersRegistry;
import com.intellij.psi.impl.source.resolve.reference.impl.PsiMultiReference;
import com.intellij.psi.scope.PsiScopeProcessor;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.LocalSearchScope;
import com.intellij.psi.search.SearchScope;
import com.intellij.psi.search.searches.ReferencesSearch;
import com.intellij.psi.stubs.NamedStubBase;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.*;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.ErlangParserDefinition;
import org.intellij.erlang.ErlangStringLiteralEscaper;
import org.intellij.erlang.ErlangTypes;
import org.intellij.erlang.bif.ErlangBifDescriptor;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.completion.ErlangCompletionContributor;
import org.intellij.erlang.completion.QuoteInsertHandler;
import org.intellij.erlang.icons.ErlangIcons;
import org.intellij.erlang.index.ErlangApplicationIndex;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.parser.ErlangParserUtil;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.rebar.util.RebarConfigUtil;
import org.intellij.erlang.roots.ErlangIncludeDirectoryUtil;
import org.intellij.erlang.sdk.ErlangSdkRelease;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.intellij.erlang.sdk.ErlangSystemUtil;
import org.intellij.erlang.stubs.ErlangFunctionStub;
import org.intellij.erlang.stubs.ErlangIncludeLibStub;
import org.intellij.erlang.stubs.ErlangIncludeStub;
import org.intellij.erlang.stubs.ErlangTypeDefinitionStub;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.intellij.patterns.PlatformPatterns.psiElement;

public class ErlangPsiImplUtil {
  public static final Set<String> KNOWN_MACROS = ContainerUtil.set("MODULE", "MODULE_STRING", "FILE", "LINE", "MACHINE");
  public static final Set<String> BUILT_IN_TYPES = ContainerUtil.set(
    "any", "atom", "boolean", "byte", "char", "float", "integer", "iolist", "list", "maybe_improper_list", "mfa",
    "module", "neg_integer", "no_return", "node", "non_neg_integer", "none", "nonempty_string", "number", "pid", "port",
    "pos_integer", "ref", "string", "term", "timeout"
  );
  public static final Key<LanguageConsoleImpl> ERLANG_CONSOLE = Key.create("ERLANG_CONSOLE");

  private static Pattern ATOM_PATTERN = Pattern.compile("[a-z][a-zA-Z_@0-9]*");
  private static Pattern QUOTED_ATOM_NAME = Pattern.compile("(\\\\\\^.|\\\\.|[^'])*"); 

  private ErlangPsiImplUtil() {
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangQVar o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processor.execute(o, state);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangQVar o) {
    return new ErlangVariableReferenceImpl(o, TextRange.from(0, o.getTextLength()));
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangQAtom o) { 
    PsiReference[] referencesFromProviders = ReferenceProvidersRegistry.getReferencesFromProviders(o);
    PsiReference atomReference = createAtomReference(o);
    PsiReference[] psiReferences = atomReference == null ? referencesFromProviders : ArrayUtil.append(referencesFromProviders, atomReference);
    if (psiReferences.length == 0) return null;
    return new PsiMultiReference(psiReferences, o);
  }

  @Nullable
  private static PsiReference createAtomReference(@NotNull final ErlangQAtom o) {
    if (!standaloneAtom(o)) return null;
    return new PsiPolyVariantReferenceBase<ErlangQAtom>(o, TextRange.create(0, o.getTextLength())) {
      @NotNull
      @Override
      public ResolveResult[] multiResolve(boolean b) {
        return new ResolveResult[]{};
      }

      @Override
      public boolean isReferenceTo(PsiElement element) {
        return element instanceof ErlangQAtom && standaloneAtom(o) && Comparing.equal(element.getText(), getElement().getText());
      }

      @Override
      public PsiElement handleElementRename(String newName) throws IncorrectOperationException {
        renameQAtom(o, newName);
        return getElement();
      }

      @NotNull
      @Override
      public Object[] getVariants() { 
        return ArrayUtil.EMPTY_OBJECT_ARRAY;
      }
    };
  }

  public static boolean standaloneAtom(@NotNull ErlangQAtom o) {
    if (o.getAtom() == null) return false;
    PsiElement parent = o.getParent();
    return parent instanceof ErlangMaxExpression || parent instanceof ErlangAtomWithArityExpression ||
      (parent instanceof ErlangTypeRef || parent instanceof ErlangBitType) && !FormatterUtil.isFollowedBy(parent.getNode(), ErlangTypes.ERL_PAR_LEFT);
  }

  @NotNull
  public static Pair<List<ErlangTypedExpr>, List<ErlangQAtom>> getRecordFields(PsiElement element) {
    List<ErlangTypedExpr> result = ContainerUtil.newArrayListWithCapacity(0);
    List<ErlangQAtom> atoms = ContainerUtil.newArrayListWithCapacity(0);
    ErlangRecordExpression recordExpression = PsiTreeUtil.getParentOfType(element, ErlangRecordExpression.class);
    PsiReference reference = recordExpression != null ? recordExpression.getReferenceInternal() : null;
    PsiElement resolve = reference != null ? reference.resolve() : null;

    if (resolve == null && recordExpression != null) {
      ErlangMacros macros = recordExpression.getMacros();
      PsiReference macrosReference = macros != null ? macros.getReference() : null;
      PsiElement macroDefinition = macrosReference != null ? macrosReference.resolve() : null;
      if (macroDefinition instanceof ErlangMacrosDefinition) {
        ErlangMacrosBody body = ((ErlangMacrosDefinition) macroDefinition).getMacrosBody();
        final Ref<ErlangRecordRef> ref = Ref.create();
        if (body != null) {
          body.accept(new ErlangRecursiveVisitor() {
            @Override
            public void visitRecordRef(@NotNull ErlangRecordRef o) {
              ref.setIfNull(o);
            }
          });
        }

        if (!ref.isNull()) {
          PsiReference r = ref.get().getReference();
          PsiElement rr = r != null ? r.resolve() : null;
          if (rr instanceof ErlangRecordDefinition) {
            resolve = rr;
          }
        }
      }
    }

    if (resolve instanceof ErlangRecordDefinition) {
      ErlangTypedRecordFields typedRecordFields = ((ErlangRecordDefinition) resolve).getTypedRecordFields();
      if (typedRecordFields != null) {
        for (ErlangTypedExpr e : typedRecordFields.getTypedExprList()) {
          ErlangMacros macros = e.getQAtom().getMacros();
          if (macros == null) {
            result.add(e);
          }
          else {
            processRecordFields(macros, atoms);
          }
        }
        for (ErlangGenericFunctionCallExpression gc : typedRecordFields.getGenericFunctionCallExpressionList()) {
          ErlangQAtom qAtom = ContainerUtil.getFirstItem(gc.getQAtomList());
          ErlangMacros macros = qAtom == null ? null : qAtom.getMacros();
          if (macros != null) {
            processRecordFields(macros, atoms);
          }
        }
      }
    }

    return Pair.create(result, atoms);
  }


  private static void processRecordFields(@NotNull ErlangMacros macros, @NotNull List<ErlangQAtom> atoms) {
    PsiReference psiReference = macros.getReference();
    PsiElement macrosDefinition = psiReference != null ? psiReference.resolve() : null;
    if (macrosDefinition instanceof ErlangMacrosDefinition) {
      ErlangMacrosBody macrosBody = ((ErlangMacrosDefinition) macrosDefinition).getMacrosBody();
      List<ErlangExpression> expressionList = macrosBody != null ? macrosBody.getExpressionList() : ContainerUtil.<ErlangExpression>emptyList();
      for (ErlangExpression ee : expressionList) {
        if (ee instanceof ErlangMaxExpression) {
          ErlangQAtom qAtom = ((ErlangMaxExpression) ee).getQAtom();
          ContainerUtil.addIfNotNull(atoms, qAtom);
        }
        else if (ee instanceof ErlangAssignmentExpression) {
          ErlangExpression left = ((ErlangAssignmentExpression) ee).getLeft();
          if (left instanceof ErlangMaxExpression) {
            ErlangQAtom qAtom = ((ErlangMaxExpression) left).getQAtom();
            ContainerUtil.addIfNotNull(atoms, qAtom);
          }
        }
        else if (ee instanceof ErlangFunctionCallExpression) {
          ErlangMacros m = ((ErlangFunctionCallExpression) ee).getQAtom().getMacros();
          if (m != null) {
            processRecordFields(m, atoms);
          }
        }
      }
    }
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangRecordField o) {
    return getRecordFieldReference(o.getFieldNameAtom());
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFieldType o) {
    return getRecordFieldReference(o.getQAtom());
  }

  @Nullable
  private static PsiReference getRecordFieldReference(@Nullable ErlangQAtom atom) {
    if (atom == null) return null;
    return new ErlangQAtomBasedReferenceImpl<ErlangQAtom>(atom, getTextRangeForReference(atom), getNameIdentifier(atom).getText()) {
      @Override
      public PsiElement resolve() {
        Pair<List<ErlangTypedExpr>, List<ErlangQAtom>> recordFields = getRecordFields(myElement);
        for (ErlangTypedExpr field : recordFields.first) {
          if (field.getName().equals(myReferenceName)) return field;
        }
        for (ErlangQAtom qAtom : recordFields.second) {
          ErlangAtom aa = qAtom.getAtom();
          if (aa != null) {
            if (myReferenceName.equals(aa.getName())) return qAtom;
          }
        }
        return null;
      }

      @NotNull
      @Override
      public Object[] getVariants() {
        return ArrayUtil.EMPTY_OBJECT_ARRAY;
      }
    };
  }

  @Nullable
  public static PsiReference getReference(@NotNull final ErlangIncludeString o) {
    final PsiElement parent = o.getParent();
    if (o.getTextLength() >= 2) {
      return new PsiReferenceBase<PsiElement>(o, TextRange.from(1, o.getTextLength() - 2)) {
        @Override
        public PsiElement resolve() {
          ErlangFile file = (ErlangFile) o.getContainingFile();
          List<ErlangFile> files = parent instanceof ErlangInclude ? getDirectlyIncludedFiles((ErlangInclude) parent, file) : getDirectlyIncludedFiles((ErlangIncludeLib) parent, file);
          return ContainerUtil.getFirstItem(files);
        }

        @NotNull
        @Override
        public PsiElement handleElementRename(@NotNull String newName) throws IncorrectOperationException {
          PsiElement resolve = resolve();
          if (resolve instanceof ErlangFile) {
            PsiElement st;
            try {
              String fileName = ((ErlangFile) resolve).getName();
              String newIncludeString = StringUtil.unquoteString(o.getString().getText()).replace(fileName, newName);
              st = ErlangElementFactory.createStringFromText(o.getProject(), newIncludeString);
            } catch (Exception e) {
              st = null;
            }

            if (st != null) {
              o.getString().replace(st);
            }
          }
          return o;
        }

        @NotNull
        @Override
        public Object[] getVariants() {
          return ArrayUtil.EMPTY_OBJECT_ARRAY;
        }
      };
    }
    return null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFunctionCallExpression o) {
    PsiElement parent = o.getParent();
    ErlangModuleRef moduleReference = null;
    if (parent instanceof ErlangGlobalFunctionCallExpression) {
      moduleReference = ((ErlangGlobalFunctionCallExpression) parent).getModuleRef();
    }
    ErlangQAtom moduleAtom = moduleReference == null ? null : moduleReference.getQAtom();
    ErlangQAtom nameAtom = o.getQAtom();

    return new ErlangFunctionReferenceImpl<ErlangQAtom>(nameAtom, moduleAtom, o.getArgumentList().getExpressionList().size());
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFunctionWithArity o) {
    ErlangQVar prevVar = PsiTreeUtil.getPrevSiblingOfType(o, ErlangQVar.class);
    if (prevVar != null) return null;
    ErlangModuleRef moduleReference = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    boolean isModule = isModule(moduleReference);
    if (moduleReference != null && moduleReference.getQAtom().getMacros() != null && !isModule) return null;
    ErlangQAtom moduleAtom = moduleReference == null ? null : moduleReference.getQAtom();

    ErlangQAtom nameAtom = o.getQAtom();
    PsiElement arity = o.getInteger();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(nameAtom, isModule ? null : moduleAtom, getArity(arity));
  }

  private static boolean isModule(@Nullable ErlangModuleRef moduleReference) {
    if (moduleReference == null) return false;
    return moduleReference.getQAtom().getText().equals("?MODULE");
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangExportFunction o) {
    PsiElement arity = o.getInteger();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(o.getQAtom(), null, getArity(arity));
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangImportFunction o) {
    ErlangImportDirective importDirective = PsiTreeUtil.getParentOfType(o, ErlangImportDirective.class);
    ErlangModuleRef moduleRef = importDirective != null ? importDirective.getModuleRef() : null;
    ErlangQAtom moduleRefQAtom = moduleRef != null ? moduleRef.getQAtom() : null;
    int arity = getArity(o);
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(o.getQAtom(), moduleRefQAtom, arity);
  }

  public static int getArity(@Nullable PsiElement arity) {
    return StringUtil.parseInt(arity == null ? "" : arity.getText(), -1);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangMacros o) {
    return getReference(o.getMacrosName());
  }

  @Nullable
  public static PsiReference getReference(@Nullable ErlangMacrosName o) {
    return o != null ? new ErlangMacrosReferenceImpl<ErlangMacrosName>(o) : null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangTypeRef o) {
    return getModuleReference(o, o.getQAtom());
  }

  @NotNull
  private static PsiReference getModuleReference(ErlangCompositeElement o, @NotNull ErlangQAtom atom) {
    ErlangModuleRef moduleRef = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    return new ErlangTypeReferenceImpl<ErlangQAtom>(atom, moduleRef);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangExportType o) {
    return getModuleReference(o, o.getQAtom());
  }

  @SuppressWarnings("unchecked")
  public static boolean inDefinitionBeforeArgumentList(PsiElement psiElement) {
    return inArgumentDefinition(psiElement) && inArgumentList(psiElement) && PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentDefinition.class, ErlangArgumentList.class) instanceof ErlangArgumentDefinition;
  }

  public static boolean inArgumentDefinition(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentDefinition.class) != null;
  }

  @SuppressWarnings("unchecked")
  public static boolean inArgumentList(PsiElement psiElement) {
    ErlangArgumentList argList = PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentList.class, true,
      ErlangFunctionCallExpression.class, ErlangFunClause.class, ErlangListComprehension.class);
    PsiElement parent = argList != null ? argList.getParent() : null;
    return parent instanceof ErlangFunctionCallExpression && ((ErlangFunctionCallExpression) parent).getQAtom().getMacros() == null;
  }

  public static boolean inFunctionTypeArgument(PsiElement psiElement) {
    ErlangType topType = PsiTreeUtil.getParentOfType(psiElement, ErlangType.class);
    return PsiTreeUtil.getParentOfType(topType, ErlangFunTypeArguments.class) != null;
  }

  public static boolean inDefine(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangMacrosDefinition.class) != null;
  }

  public static boolean inMacroCallArguments(PsiElement psiElement) {
    PsiElement child = psiElement;
    ErlangFunctionCallExpression functionCall;
    while ((functionCall = PsiTreeUtil.getParentOfType(child, ErlangFunctionCallExpression.class, true)) != null) {
      boolean isMacroCall = functionCall.getQAtom().getMacros() != null;
      if (isMacroCall && PsiTreeUtil.isAncestor(functionCall.getArgumentList(), psiElement, true)) {
        return true;
      }
      child = functionCall;
    }
    return false;
  }

  public static boolean inCallback(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangCallbackSpec.class) != null;
  }

  public static boolean inRecordDefinition(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangRecordDefinition.class) != null;
  }

  public static boolean inAtomAttribute(PsiElement psiElement) {

    return PsiTreeUtil.getParentOfType(psiElement, ErlangAtomAttribute.class, ErlangTypeDefinition.class) != null;
  }

  public static boolean inSpecification(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangSpecification.class) != null;
  }

  public static boolean inColonQualified(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangColonQualifiedExpression.class) != null;
  }

  public static boolean inLeftPartOfAssignment(@NotNull PsiElement psiElement) {
    return inLeftPartOfAssignment(psiElement, true);
  }

  public static boolean inLeftPartOfAssignment(@NotNull PsiElement psiElement, boolean strict) {
    ErlangAssignmentExpression assignment = PsiTreeUtil.getParentOfType(psiElement, ErlangAssignmentExpression.class, true);
    while (assignment != null) {
      if (PsiTreeUtil.isAncestor(assignment.getLeft(), psiElement, strict)) {
        return true;
      }
      assignment = PsiTreeUtil.getParentOfType(assignment, ErlangAssignmentExpression.class, true);
    }
    return false;
  }

  public static boolean isForceSkipped(@NotNull ErlangQVar o) {
    return o.getName().startsWith("_");
  }

  @NotNull
  public static List<LookupElement> getFunctionLookupElements(@NotNull PsiFile containingFile, boolean withArity, @Nullable ErlangQAtom moduleAtom) {
    if (containingFile instanceof ErlangFile && !ErlangParserUtil.isApplicationConfigFileType(containingFile)) {
      List<ErlangFunction> functions = ContainerUtil.newArrayList();
      List<LookupElement> lookupElements = ContainerUtil.newArrayList();

      ErlangSdkRelease release = ErlangSdkType.getRelease(containingFile);
      if (moduleAtom != null) {
        String moduleName = getName(moduleAtom);
        functions.addAll(getExternalFunctionForCompletion(containingFile.getProject(), moduleName));

        if (release == null || release.needBifCompletion(moduleName)) {
          addBifs(lookupElements, ErlangBifTable.getBifs(moduleName), withArity);
        }
        addBifs(lookupElements, ErlangBifTable.getBifs("", ErlangBifTable.MODULE_INFO), withArity);
      }
      else {
        ErlangFile erlangFile = (ErlangFile) containingFile;
        functions.addAll(erlangFile.getFunctions());
        functions.addAll(getExternalFunctionForCompletion(containingFile.getProject(), "erlang"));

        List<ErlangImportFunction> directlyImported = erlangFile.getImportedFunctions();
        List<ErlangImportFunction> importsFromIncludes = getImportsFromIncludes(erlangFile, true, "", 0);
        for (ErlangImportFunction importFunction : ContainerUtil.concat(directlyImported, importsFromIncludes)) {
          LookupElement element = createFunctionLookupElement(getName(importFunction), getArity(importFunction), withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY);
          lookupElements.add(element);
        }

        if (!withArity && (release == null || release.needBifCompletion("erlang"))) {
          addBifs(lookupElements, ErlangBifTable.getBifs("erlang"));
        }
        if (!withArity && (release == null || release.needBifCompletion(""))) {
          addBifs(lookupElements, ErlangBifTable.getBifs(""));
        }
      }

      functions.addAll(getErlangFunctionsFromIncludes((ErlangFile) containingFile, true, "", 0));
      lookupElements.addAll(createFunctionLookupElements(functions, withArity));
      return lookupElements;
    }
    return Collections.emptyList();
  }

  private static void addBifs(@NotNull List<LookupElement> lookupElements, @NotNull Collection<ErlangBifDescriptor> bifs) {
    for (ErlangBifDescriptor bif : bifs) {
      lookupElements.add(createFunctionLookupElement(bif.getName(), bif.getArity(), false, ErlangCompletionContributor.BIF_PRIORITY));
    }
  }

  @NotNull
  public static Collection<LookupElement> getAllExportedFunctionsWithModuleLookupElements(@NotNull Project project,
                                                                                          boolean withArity,
                                                                                          @Nullable String exclude) {
    List<LookupElement> lookupElements = ContainerUtil.newArrayList();
    for (String moduleName : ErlangModuleIndex.getNames(project)) {
      if (exclude != null && moduleName.equals(exclude)) continue;
      for (ErlangFunction function : getExternalFunctionForCompletion(project, moduleName)) {
        String functionName = function.getName();
        String fullName = moduleName + ":" + functionName;
        int arity = function.getArity();
        lookupElements.add(
          PrioritizedLookupElement.withPriority(
            LookupElementBuilder.create(function, fullName)
              .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
              .withInsertHandler(getInsertHandler(functionName, moduleName, arity, withArity)),
            ErlangCompletionContributor.EXTERNAL_FUNCTIONS_PRIORITY));
      }
    }
    return lookupElements;
  }

  private static void addBifs(@NotNull List<LookupElement> lookupElements, @NotNull Collection<ErlangBifDescriptor> bifs, boolean withArity) {
    for (ErlangBifDescriptor bif : bifs) {
      lookupElements.add(createFunctionLookupElement(bif.getName(), bif.getArity(), withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY));
    }
  }

  @NotNull
  public static List<LookupElement> createFunctionLookupElements(@NotNull List<ErlangFunction> functions, final boolean withArity) {
    return ContainerUtil.map(functions, new Function<ErlangFunction, LookupElement>() {
      @NotNull
      @Override
      public LookupElement fun(@NotNull ErlangFunction function) {
        return createFunctionsLookupElement(function, withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY);
      }
    });
  }

  @NotNull
  private static LookupElement createFunctionsLookupElement(@NotNull ErlangFunction function, boolean withArity, double priority) {
    int arity = function.getArity();
    return PrioritizedLookupElement.withPriority(LookupElementBuilder.create(function)
      .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
      .withInsertHandler(getInsertHandler(function.getName(), arity, withArity)), priority);
  }

  @NotNull
  private static LookupElement createFunctionLookupElement(@NotNull String name, int arity, boolean withArity, int priority) {
    return PrioritizedLookupElement.withPriority(LookupElementBuilder.create(name + arity, name)
      .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
      .withInsertHandler(getInsertHandler(name, arity, withArity)), (double) priority);
  }

  @NotNull
  private static InsertHandler<LookupElement> getInsertHandler(final String name, final int arity, boolean withArity) {
    return getInsertHandler(name, null, arity, withArity);
  }

  @NotNull
  private static InsertHandler<LookupElement> getInsertHandler(@NotNull final String name, @Nullable final String moduleName, final int arity, boolean withArity) {
    return withArity ?
      new BasicInsertHandler<LookupElement>() {
        @Override
        public void handleInsert(@NotNull InsertionContext context, LookupElement item) {
          QuoteInsertHandler.process(context.getProject(), name, moduleName, context);
          Editor editor = context.getEditor();
          Document document = editor.getDocument();
          context.commitDocument();
          PsiElement next = findNextToken(context);
          ASTNode intNode = FormatterUtil.getNextNonWhitespaceSibling(next != null ? next.getNode() : null);

          if (next != null && "/".equals(next.getText())) {
            next.delete();
          }
          if (intNode != null && intNode.getElementType() == ErlangTypes.ERL_INTEGER) {
            intNode.getPsi().delete();
          }
          PsiDocumentManager.getInstance(context.getProject()).doPostponedOperationsAndUnblockDocument(document);
          document.insertString(context.getTailOffset(), "/" + arity);
          editor.getCaretModel().moveToOffset(context.getTailOffset());
        }

        @Nullable
        private PsiElement findNextToken(@NotNull InsertionContext context) {
          PsiFile file = context.getFile();
          PsiElement element = file.findElementAt(context.getTailOffset());
          if (element instanceof PsiWhiteSpace) {
            element = file.findElementAt(element.getTextRange().getEndOffset());
          }
          return element;
        }
      } :
      new ParenthesesInsertHandler<LookupElement>() {
        @Override
        public void handleInsert(@NotNull InsertionContext context, LookupElement item) {
          QuoteInsertHandler.process(context.getProject(), name, moduleName, context);
          super.handleInsert(context, item);
        }

        @Override
        protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {
          return arity > 0;
        }
      };
  }

  @NotNull
  public static List<LookupElement> getMacrosLookupElements(@NotNull PsiFile containingFile) {
    if (containingFile instanceof ErlangFile) {
      List<ErlangMacrosDefinition> concat = ContainerUtil.concat(((ErlangFile) containingFile).getMacroses(), getErlangMacrosFromIncludes((ErlangFile) containingFile, true, ""));
      List<LookupElement> fromFile = ContainerUtil.map(
        concat,
        new Function<ErlangMacrosDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangMacrosDefinition md) {
            return LookupElementBuilder.create(md).withIcon(ErlangIcons.MACROS);
          }
        });
      List<LookupElement> stdMacros = ContainerUtil.newArrayList();
      for (String m : KNOWN_MACROS) {
        stdMacros.add(LookupElementBuilder.create(m).withIcon(ErlangIcons.MACROS));
      }
      return ContainerUtil.concat(fromFile, stdMacros);
    }
    return Collections.emptyList();
  }

  @NotNull
  public static List<LookupElement> getRecordLookupElements(@NotNull PsiFile containingFile) {
    if (containingFile instanceof ErlangFile) {
      List<ErlangRecordDefinition> concat = ContainerUtil.concat(((ErlangFile) containingFile).getRecords(), getErlangRecordFromIncludes((ErlangFile) containingFile, true, ""));
      return ContainerUtil.map(
        concat,
        new Function<ErlangRecordDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangRecordDefinition rd) {
            return LookupElementBuilder.create(rd).withIcon(ErlangIcons.RECORD);
          }
        });
    }
    return Collections.emptyList();
  }

  @NotNull
  public static List<LookupElement> getTypeLookupElements(@NotNull PsiFile containingFile, boolean addBuiltInTypes, final boolean withArity) {
    if (containingFile instanceof ErlangFile) {
      ErlangFile erlangFile = (ErlangFile) containingFile;
      List<ErlangTypeDefinition> types = ContainerUtil.concat(erlangFile.getTypes(), getErlangTypeFromIncludes(erlangFile, true, ""));

      final ParenthesesInsertHandler<LookupElement> handler = new ParenthesesInsertHandler<LookupElement>() {
        @Override
        protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {
          return false;
        }
      };

      List<LookupElement> builtInTypes = addBuiltInTypes ? ContainerUtil.map(BUILT_IN_TYPES, new Function<String, LookupElement>() {
        @NotNull
        @Override
        public LookupElement fun(@NotNull String s) {
          return PrioritizedLookupElement.withPriority(
            LookupElementBuilder.create(s).withIcon(ErlangIcons.TYPE).withInsertHandler(handler),
            ErlangCompletionContributor.TYPE_PRIORITY);
        }
      }) : ContainerUtil.<LookupElement>emptyList();

      List<LookupElement> foundedTypes = ContainerUtil.map(
        types,
        new Function<ErlangTypeDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangTypeDefinition rd) {
            return PrioritizedLookupElement.withPriority(
              LookupElementBuilder.create(rd).withIcon(ErlangIcons.TYPE).withInsertHandler(getInsertHandler(rd.getName(), getArity(rd), withArity)),
              ErlangCompletionContributor.TYPE_PRIORITY);
          }
        });
      return ContainerUtil.concat(foundedTypes, builtInTypes);
    }
    return Collections.emptyList();
  }

  public static int getArity(@NotNull ErlangTypeDefinition o) {
    ErlangTypeDefinitionStub stub = o.getStub();
    if (stub != null) return stub.getArity();
    ErlangArgumentDefinitionList argumentDefinitionList = o.getArgumentDefinitionList();
    if (argumentDefinitionList == null) return 0;
    return argumentDefinitionList.getArgumentDefinitionList().size();
  }

  private static int calculateFunctionClauseArity(@NotNull ErlangFunctionClause clause) {
    ErlangArgumentDefinitionList argumentDefinitionList = clause.getArgumentDefinitionList();
    return argumentDefinitionList.getArgumentDefinitionList().size();
  }

  @NotNull
  public static String getName(@NotNull ErlangFunction o) {
    return getNameImpl(o);
  }

  @NotNull
  public static String getName(@NotNull ErlangImportFunction o) {
    return getName(o.getQAtom());
  }

  @NotNull
  public static String getName(@NotNull ErlangQVar o) {
    return o.getText();
  }

  public static int getArity(@NotNull ErlangFunction o) {
    ErlangFunctionStub stub = o.getStub();
    if (stub != null) return stub.getArity();
    return o.getFirstClause().getArgumentDefinitionList().getArgumentDefinitionList().size();
  }

  public static int getArity(@NotNull ErlangImportFunction o) {
    return getArity(o.getInteger());
  }

  @NotNull
  public static String getName(@NotNull ErlangRecordDefinition o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangRecordDefinition o) {
    ErlangQAtom atom = o.getQAtom();
    return atom != null ? getNameIdentifier(atom) : o;
  }

  public static int getTextOffset(@NotNull ErlangRecordDefinition o) {
    if (o.getNameIdentifier() == o) return 0;
    return o.getNameIdentifier().getTextOffset();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangQVar o) {
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangQAtom o) {
    ErlangAtom atom = o.getAtom();
    return atom != null ? getNameIdentifier(atom) : o;
  }

  @NotNull
  public static String getName(@NotNull ErlangQAtom o) {
    return getNameIdentifier(o).getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangMacrosName o) {
    ErlangAtom atom = o.getAtom();
    if (atom != null) {
      return getNameIdentifier(atom);
    }
    return ObjectUtils.notNull(o.getVar(), o);
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangFunction o) {
    return getNameIdentifier(o.getAtomName());
  }

  @Nullable
  public static PsiReference getReferenceInternal(@NotNull ErlangRecordExpression o) {
    ErlangRecordRef recordRef = o.getRecordRef();
    return recordRef != null ? recordRef.getReference() : null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangRecordRef o) {
    return createRecordRef(o.getQAtom());
  }

  @NotNull
  public static ErlangRecordReferenceImpl<ErlangQAtom> createRecordRef(@NotNull ErlangQAtom atom) {
    return new ErlangRecordReferenceImpl<ErlangQAtom>(atom);
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangModuleRef o) {
    return createModuleReference(o.getQAtom());
  }

  @NotNull
  public static PsiReference createModuleReference(@NotNull ErlangQAtom atom) {
    return new ErlangModuleReferenceImpl<ErlangQAtom>(atom);
  }

  @Nullable
  @Contract("null->null")
  public static ErlangFile resolveToFile(@Nullable ErlangModuleRef ref) {
    PsiReference reference = ref != null ? ref.getReference() : null;
    PsiElement resolved = reference != null ? reference.resolve() : null;
    return ObjectUtils.tryCast(resolved != null ? resolved.getContainingFile() : null, ErlangFile.class);
  }

  public static boolean renameQAtom(@Nullable ErlangQAtom qAtom, String newName) {
    return renameAtom(qAtom != null ? qAtom.getAtom() : null, newName);
  }

  public static boolean renameAtom(@Nullable ErlangAtom atom, String newName) {
    if (atom != null) {
      atom.setName(newName);
      return true;
    }
    return false;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangFunction o, @NotNull String newName) {
    for (ErlangFunctionClause clause : o.getFunctionClauseList()) {
      renameQAtom(clause.getQAtom(), newName);
    }
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangQVar o, @NotNull String newName) {
    o.replace(ErlangElementFactory.createQVarFromText(o.getProject(), newName));
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangRecordDefinition o, @NotNull String newName) {
    renameQAtom(o.getQAtom(), newName);
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangTypeDefinition o, @NotNull String newName) {
    renameQAtom(o.getQAtom(), newName);
    return o;
  }

  @NotNull
  public static String getName(@NotNull ErlangModule o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangModule o, @NotNull String newName) {
    VirtualFile virtualFile = o.getContainingFile().getVirtualFile();
    if (virtualFile != null) {
      try {
        String ext = FileUtilRt.getExtension(virtualFile.getName());
        virtualFile.rename(o, StringUtil.replace(newName, "'", "") + "." + ext);
        renameQAtom(o.getQAtom(), newName);
      } catch (Exception ignored) {
      }
    }
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangModule o) {
    ErlangQAtom qAtom = o.getQAtom();
    return qAtom != null ? getNameIdentifier(qAtom) : o;
  }

  public static int getTextOffset(@NotNull ErlangModule o) {
    if (o.getNameIdentifier() == o) return 0; 
    return o.getNameIdentifier().getTextOffset();
  }

  @NotNull
  public static String getName(@NotNull ErlangFunctionCallExpression o) {
    return o.getNameIdentifier().getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangFunctionCallExpression o) {
    return getNameIdentifier(o.getQAtom());
  }

  public static int getTextOffset(@NotNull ErlangFunctionCallExpression o) {
    return o.getQAtom().getTextOffset();
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangListComprehension o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processDeclarationRecursive(o, processor, state);
  }
  
  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangCaseExpression o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    List<ErlangCrClause> crClauseList = o.getCrClauseList();
    boolean result = true;
    for (ErlangCrClause c : crClauseList) {
      ErlangClauseBody clauseBody = c.getClauseBody();
      if (clauseBody != null) result &= processDeclarationRecursive(clauseBody, processor, state);
    }
    return result;
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangModule o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processDeclarationRecursive(o, processor, state);
  }

  private static boolean processDeclarationRecursive(ErlangCompositeElement o, @NotNull PsiScopeProcessor processor, ResolveState state) {
    Queue<ErlangCompositeElement> queue = new LinkedList<ErlangCompositeElement>();
    queue.add(o);
    while (!queue.isEmpty()) {
      ErlangCompositeElement top = queue.remove();
      if (!processor.execute(top, state)) return false;
      queue.addAll(PsiTreeUtil.getChildrenOfTypeAsList(top, ErlangCompositeElement.class));
    }
    return true;
  }

  static boolean inModule(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangModule.class) != null;
  }

  @NotNull
  public static Collection<ErlangFile> getIncludedFiles(@NotNull ErlangFile file) {
    HashSet<ErlangFile> includedFiles = new HashSet<ErlangFile>();
    addIncludedFiles(file, includedFiles);
    return includedFiles;
  }

  private static void addIncludedFiles(@NotNull ErlangFile erlangFile, @NotNull Set<ErlangFile> alreadyAdded) {
    List<ErlangFile> directlyIncludedFiles = getDirectlyIncludedFiles(erlangFile);
    boolean added = false;
    for (ErlangFile f : directlyIncludedFiles) {
      added |= alreadyAdded.add(f);
    }
    if (added) {
      for (ErlangFile f : directlyIncludedFiles) {
        addIncludedFiles(f, alreadyAdded);
      }
    }
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangFile erlangFile) {
    List<ErlangFile> files = ContainerUtil.newArrayList();
    for (ErlangInclude include : erlangFile.getIncludes()) {
      files.addAll(getDirectlyIncludedFiles(include, erlangFile));
    }
    for (ErlangIncludeLib includeLib : erlangFile.getIncludeLibs()) {
      files.addAll(getDirectlyIncludedFiles(includeLib, erlangFile));
    }
    return files;
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangIncludeLib includeLib, @NotNull ErlangFile erlangFile) {
    ErlangIncludeString includeString = includeLib.getIncludeStringSafe();
    String[] split = includeString != null ? StringUtil.unquoteString(includeString.getText()).split("/") : null;

    if (split != null && split.length >= 2) {
      String libName = split[0];
      String relativePath = StringUtil.join(split, 1, split.length, "/");
      Project project = includeLib.getProject();
      VirtualFile appDir = ErlangApplicationIndex.getApplicationDirectoryByName(libName, GlobalSearchScope.allScope(project));
      ErlangFile includedFile = getRelativeErlangFile(project, relativePath, appDir);
      if (includedFile != null) {
        return ContainerUtil.newSmartList(includedFile);
      }
    }

    return getDirectlyIncludedFiles(includeString, erlangFile);
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangInclude include, @NotNull ErlangFile erlangFile) {
    ErlangIncludeString includeString = include.getIncludeStringSafe();
    return getDirectlyIncludedFiles(includeString, erlangFile);
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@Nullable ErlangIncludeString includeString, @NotNull ErlangFile erlangFile) {
    if (includeString == null) return ContainerUtil.emptyList();
    VirtualFile containingVirtualFile = erlangFile.getOriginalFile().getVirtualFile();
    VirtualFile parent = containingVirtualFile != null ? containingVirtualFile.getParent() : null;
    String relativePath = StringUtil.unquoteString(includeString.getText());
    Project project = erlangFile.getProject();
    ErlangFile relativeToDirectParent = getRelativeErlangFile(project, relativePath, parent);
    if (relativeToDirectParent != null) return ContainerUtil.newSmartList(relativeToDirectParent);


    if (containingVirtualFile != null) {
      Module module = ModuleUtilCore.findModuleForFile(containingVirtualFile, project);
      for (VirtualFile includeDir : ErlangIncludeDirectoryUtil.getIncludeDirectories(module)) {
        ErlangFile includedFile = getRelativeErlangFile(project, relativePath, includeDir);
        if (includedFile != null) return ContainerUtil.newSmartList(includedFile);
      }
    }

    if (ErlangSystemUtil.isSmallIde()) {
      VirtualFile appRoot = getContainingOtpAppRoot(project, parent);
      return getDirectlyIncludedFilesForSmallIde(project, relativePath, appRoot);
    }
    return ContainerUtil.emptyList();
  }

  @NotNull
  private static List<ErlangFile> getDirectlyIncludedFilesForSmallIde(@NotNull Project project, @NotNull String includeStringPath, @Nullable VirtualFile otpAppRoot) {
    if (otpAppRoot == null) return ContainerUtil.emptyList();
    VirtualFile otpIncludeDirectory = otpAppRoot.findChild("include");
    ErlangFile relativeToOtpIncludeDirectory = getRelativeErlangFile(project, includeStringPath, otpIncludeDirectory);
    if (relativeToOtpIncludeDirectory != null) return ContainerUtil.newSmartList(relativeToOtpIncludeDirectory);

    ErlangFile rebarConfigPsi = RebarConfigUtil.getRebarConfig(project, otpAppRoot);
    if (rebarConfigPsi != null) {
      for(String includePath : ContainerUtil.reverse(RebarConfigUtil.getIncludePaths(rebarConfigPsi))) {
        VirtualFile includePathVirtualFile = VfsUtilCore.findRelativeFile(includePath, otpAppRoot);
        ErlangFile includedFile = getRelativeErlangFile(project, includeStringPath, includePathVirtualFile);
        if (includedFile != null) return ContainerUtil.newSmartList(includedFile);
      }
    }
    return ContainerUtil.emptyList();
  }

  @Nullable
  public static VirtualFile getContainingOtpAppRoot(@NotNull Project project, @Nullable final VirtualFile file) {
    if (file == null) return null;
    List<VirtualFile> allOtpAppRoots = ErlangApplicationIndex.getAllApplicationDirectories(project, GlobalSearchScope.allScope(project));
    List<VirtualFile> containingOtpAppRoots = ContainerUtil.filter(allOtpAppRoots, new Condition<VirtualFile>() {
      @Override
      public boolean value(@NotNull VirtualFile appRoot) {
        return VfsUtilCore.isAncestor(appRoot, file, true);
      }
    });

    ContainerUtil.sort(containingOtpAppRoots, new Comparator<VirtualFile>() {
      @Override
      public int compare(@NotNull VirtualFile o1, @NotNull VirtualFile o2) {
        return o2.getPath().length() - o1.getPath().length();
      }
    });
    return ContainerUtil.getFirstItem(containingOtpAppRoots);
  }

  @NotNull
  public static Set<String> getImplementedBehaviourModuleNames(@NotNull ErlangFile file) {
    Set<String> behaviours = new HashSet<String>();
    addDeclaredBehaviourModuleNames(file, behaviours);
    for (ErlangFile erlangFile : getIncludedFiles(file)) {
      addDeclaredBehaviourModuleNames(erlangFile, behaviours);
    }
    return behaviours;
  }

  private static void addDeclaredBehaviourModuleNames(@NotNull ErlangFile file, @NotNull Set<String> behaviourNames) {
    for (ErlangBehaviour behaviour : file.getBehaviours()) {
      ContainerUtil.addIfNotNull(getName(behaviour), behaviourNames);
    }
  }

  @NotNull
  public static Set<String> getAppliedParseTransformModuleNames(@NotNull ErlangFile file) {
    Set<String> parseTransforms = new HashSet<String>();
    file.addDeclaredParseTransforms(parseTransforms);
    for (ErlangFile f : getIncludedFiles(file)) {
      f.addDeclaredParseTransforms(parseTransforms);
    }
    return parseTransforms;
  }

  public static void extractParseTransforms(@NotNull ErlangListExpression list, @NotNull Set<String> parseTransforms) {
    for (ErlangExpression expr : list.getExpressionList()) {
      if (expr instanceof ErlangTupleExpression) {
        extractParseTransforms((ErlangTupleExpression) expr, parseTransforms);
      }
    }
  }

  public static void extractParseTransforms(@NotNull ErlangTupleExpression tuple, @NotNull Set<String> parseTransforms) {
    List<ErlangExpression> expressionList = tuple.getExpressionList();
    if (expressionList.size() != 2) return;
    ErlangExpression first = expressionList.get(0);
    if (!"parse_transform".equals(getAtomName(first instanceof ErlangMaxExpression ? (ErlangMaxExpression) first : null))) return;
    ErlangExpression second = expressionList.get(1);
    String parseTransformModuleName = getAtomName(second instanceof ErlangMaxExpression ? (ErlangMaxExpression) second : null);
    ContainerUtil.addIfNotNull(parseTransformModuleName, parseTransforms);
  }

  @Nullable
  public static String getAtomName(@Nullable ErlangMaxExpression expression) {
    return expression != null ? getAtomName(expression.getQAtom()) : null;
  }

  @Nullable
  private static String getAtomName(@Nullable ErlangQAtom qAtom) {
    ErlangAtom atom = qAtom != null ? qAtom.getAtom() : null;
    return atom != null ? atom.getName() : null;
  }

  @Nullable
  private static ErlangFile getRelativeErlangFile(@NotNull Project project, @NotNull String relativePath, @Nullable VirtualFile parent) {
    VirtualFile relativeFile = VfsUtilCore.findRelativeFile(relativePath, parent);
    if (relativeFile == null) return null;
    PsiFile file = PsiManager.getInstance(project).findFile(relativeFile);
    return file instanceof ErlangFile ? (ErlangFile) file : null;
  }

  @NotNull
  static List<ErlangRecordDefinition> getErlangRecordFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, String name) {
    List<ErlangRecordDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getRecord(name));
      }
      else {
        fromIncludes.addAll(file.getRecords());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangFunction> getErlangFunctionsFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name, int arity) {
    List<ErlangFunction> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getFunction(name, arity));
      }
      else {
        fromIncludes.addAll(file.getFunctions());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangImportFunction> getImportsFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name, int arity) {
    List<ErlangImportFunction> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getImportedFunction(name, arity));
      }
      else {
        fromIncludes.addAll(file.getImportedFunctions());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangMacrosDefinition> getErlangMacrosFromIncludes(@NotNull ErlangFile containingFile,
                                                                  boolean forCompletion,
                                                                  @NotNull String name) {
    List<ErlangMacrosDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getMacros(name));
      }
      else {
        fromIncludes.addAll(file.getMacroses());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangTypeDefinition> getErlangTypeFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name) {
    List<ErlangTypeDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getType(name));
      }
      else {
        fromIncludes.addAll(file.getTypes());
      }
    }
    return fromIncludes;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangAtom atom) {
    PsiElement name = atom.getAtomName();
    return name != null ? name : atom;
  }

  @NotNull
  public static ErlangAtom setName(@NotNull ErlangAtom atom, @NotNull String newName) {
    String text = toAtomName(newName);
    assert text != null;
    ErlangAtom newAtom = ErlangElementFactory.createAtomFromText(atom.getProject(), text);
    return (ErlangAtom) atom.replace(newAtom);
  }

  @Nullable
  public static String toAtomName(@NotNull String maybeUnquotedAtomName) {
    ThreeState t = atomNameRequiresQuotes(maybeUnquotedAtomName);
    return t == ThreeState.YES ? '\'' + maybeUnquotedAtomName + '\'' : t == ThreeState.NO ? maybeUnquotedAtomName : null;
  }

  @NotNull
  private static ThreeState atomNameRequiresQuotes(@NotNull String atomName) {

    Matcher matcher = ATOM_PATTERN.matcher(atomName);
    if (matcher.matches()) {
      return ThreeState.NO;
    }

    matcher = QUOTED_ATOM_NAME.matcher(atomName);
    if (matcher.matches()) {
      return ThreeState.YES;
    }

    matcher = QUOTED_ATOM_NAME.matcher(StringUtil.unquoteString(atomName, '\''));
    if (matcher.matches()) {
      return ThreeState.NO;
    }
    return ThreeState.UNSURE;
  }

  @NotNull
  public static String getName(@NotNull ErlangAtom atom) {
    return atom.getNameIdentifier().getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangMacrosDefinition o) {
    ErlangMacrosName macrosName = o.getMacrosName();
    return macrosName != null ? getNameIdentifier(macrosName) : o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangTypeDefinition o) {
    ErlangQAtom qAtom = o.getQAtom();
    return qAtom != null ? getNameIdentifier(qAtom) : o;
  }

  public static int getTextOffset(@NotNull ErlangTypeDefinition o) {
    if (o.getQAtom() == null) return 0;
    return getNameIdentifier(o).getTextOffset();
  }

  public static int getTextOffset(@NotNull ErlangMacrosDefinition o) {
    if (o.getMacrosName() == null) return 0;
    return getNameIdentifier(o).getTextOffset();
  }

  @NotNull
  public static String getName(@NotNull ErlangMacrosDefinition o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangMacrosDefinition o, @NotNull String newName) {
    ErlangMacrosName macrosName = o.getMacrosName();
    if (macrosName != null) {
      setName(macrosName, newName);
    }
    return o;
  }

  public static void setName(@NotNull ErlangMacrosName macroName, @NotNull String newName) {
    PsiElement replacement = createMacroNameReplacement(macroName.getProject(), newName);
    if (macroName.getAtom() != null) {
      macroName.getAtom().replace(replacement);
    }
    else if (macroName.getVar() != null) {
      macroName.getVar().replace(replacement);
    }
    else {
      throw new AssertionError("Unexpected PSI structure");
    }
  }

  @NotNull
  private static PsiElement createMacroNameReplacement(@NotNull Project project, @NotNull String newName) {
    ErlangMacrosName macroName = null;
    try {
      macroName = (ErlangMacrosName) ErlangElementFactory.createMacrosFromText(project, newName);
    } catch (Exception ignore) {
    }
    if (macroName == null) {
      try {
        macroName = (ErlangMacrosName) ErlangElementFactory.createMacrosFromText(project, '\'' + newName + '\'');
      } catch (Exception ignore) {
      }
    }
    if (macroName != null) {
      if (macroName.getAtom() != null) {
        return macroName.getAtom();
      }
      else if (macroName.getVar() != null) {
        return macroName.getVar();
      }
    }
    throw new AssertionError("Cannot create macro name replacement");
  }

  @NotNull
  public static String getName(@NotNull ErlangBehaviour o) {
    String fromStub = getNameFromStub(o);
    if (fromStub != null) return fromStub;

    ErlangModuleRef moduleRef = o.getModuleRef();
    ErlangQAtom atom = moduleRef != null ? moduleRef.getQAtom() : null;
    return atom == null ? "" : getName(atom);
  }

  @NotNull
  public static List<ErlangFunction> getExternalFunctionForCompletion(@NotNull Project project, @NotNull String moduleName) {
    List<ErlangFunction> result = ContainerUtil.newArrayList();
    List<ErlangFile> erlangModules = ErlangModuleIndex.getFilesByName(project, moduleName, GlobalSearchScope.allScope(project));
    for (ErlangFile file : erlangModules) {
      result.addAll(file.getExportedFunctions());
    }
    return result;
  }

  public static boolean inFunction(@Nullable PsiElement position) {
    return PsiTreeUtil.getParentOfType(position, ErlangFunction.class) != null;
  }

  @NotNull
  public static String getName(@NotNull ErlangTypedExpr o) {
    return getNameIdentifier(o).getText();
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangTypedExpr o, String newName) {
    ErlangQAtom qAtom = o.getQAtom();
    renameQAtom(qAtom, newName);
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangTypedExpr o) {
    return getNameIdentifier(o.getQAtom());
  }

  @NotNull
  public static String getName(@NotNull ErlangAtomAttribute o) {
    return o.getAtomName().getText();
  }

  public static int getTextOffset(@NotNull ErlangTypedExpr o) {
    return o.getNameIdentifier().getTextOffset();
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangSpecFun o) {
    ErlangQAtom atom = o.getQAtom();
    ErlangModuleRef moduleRef = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    Integer arity = getArity(o);

    if (arity != null) {
      return new ErlangFunctionReferenceImpl<ErlangQAtom>(atom, moduleRef == null ? null : moduleRef.getQAtom(), arity);
    }
    return null;
  }

  @Nullable
  public static Integer getArity(@NotNull ErlangSpecFun o) {
    PsiElement integer = o.getInteger();
    Integer arity = null;
    if (integer != null) arity = getArity(integer);
    ErlangTypeSig sigs = PsiTreeUtil.getNextSiblingOfType(o, ErlangTypeSig.class);
    if (arity == null && sigs != null) arity = sigs.getFunType().getFunTypeArguments().getTypeList().size();
    return arity;
  }

  @Nullable
  public static ErlangFunTypeSigs getSignature(@Nullable ErlangSpecification o) {
    if (o == null) return null;
    ErlangFunTypeSigsBraces sigsBraces = o.getFunTypeSigsBraces();
    if (sigsBraces != null) {
      return sigsBraces.getFunTypeSigs();
    }
    return o.getFunTypeSigs();
  }

  @NotNull
  public static ItemPresentation getPresentation(@NotNull final ErlangFunction o) {
    return new ItemPresentation() {
      @Nullable
      @Override
      public String getPresentableText() {
        return createFunctionPresentation(o);
      }

      @Nullable
      @Override
      public String getLocationString() {
        return o.getContainingFile().getName();
      }

      @Nullable
      @Override
      public Icon getIcon(boolean b) {
        return o.getIcon(0);
      }
    };
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangAtomWithArityExpression function) {
    return createFunctionPresentation(getName(function.getQAtom()), getArity(function.getInteger()));
  }

  @NotNull
  public static String createFunctionClausePresentation(@NotNull ErlangFunctionClause clause) {
    return createFunctionPresentation(getName(clause.getQAtom()), calculateFunctionClauseArity(clause));
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangFunction function) {
    return createFunctionPresentation(function.getName(), function.getArity());
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangImportFunction function) {
    return createFunctionPresentation(getName(function), getArity(function));
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull String functionName, int arity) {
    return toAtomName(functionName) + "/" + arity;
  }

  @NotNull
  public static String getQualifiedFunctionName(@NotNull ErlangFunction function) {
    PsiFile file = function.getContainingFile();
    ErlangFile erlangFile = file instanceof ErlangFile ? (ErlangFile) file : null;
    ErlangModule module = erlangFile != null ? erlangFile.getModule() : null;
    return module != null ? module.getName() + ":" + function.getName() : function.getName();
  }

  @NotNull
  public static String createFunctionPresentationFromCallbackSpec(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    String funName = getCallbackSpecName(spec);

    List<ErlangTypeSig> typeSigList = funTypeSigs != null ? funTypeSigs.getTypeSigList() : null;
    ErlangTypeSig first = ContainerUtil.getFirstItem(typeSigList);
    int arity = first != null ? first.getFunType().getFunTypeArguments().getTypeList().size() : 0;

    return funName + "/" + arity;
  }

  @NotNull
  public static String createTypePresentation(@NotNull ErlangTypeDefinition type) {
    return type.getName() + "/" + getArity(type);
  }

  @NotNull
  @SuppressWarnings("UnusedParameters")
  public static Icon getIcon(@NotNull ErlangFunction o, int flags) {
    return ErlangIcons.FUNCTION;
  }

  public static boolean isRecursiveCall(PsiElement element, ErlangFunction function) {
    return Comparing.equal(PsiTreeUtil.getParentOfType(element, ErlangFunction.class), function);
  }

  public static boolean isEunitTestFile(@NotNull ErlangFile file) {
    VirtualFile virtualFile = file.getVirtualFile();
    String withoutExtension = virtualFile != null ? virtualFile.getNameWithoutExtension() : "";
    return (StringUtil.endsWith(withoutExtension, "_test") || StringUtil.endsWith(withoutExtension, "_tests")) && isEunitImported(file);
  }

  public static boolean isEunitTestFunction(@NotNull ErlangFunction function) {
    String name = function.getName();
    return isEunitTestFunctionName(name) || isEunitTestGeneratorFunctionName(name);
  }

  public static boolean isEunitTestFunctionName(@NotNull String functionName) {
    return StringUtil.endsWith(functionName, "_test");
  }

  public static boolean isEunitTestGeneratorFunctionName(@NotNull String functionName) {
    return StringUtil.endsWith(functionName, "_test_");
  }

  public static boolean isEunitImported(@NotNull ErlangFile file) {
    return isEunitDirectlyImported(file) ||
      ContainerUtil.find(getIncludedFiles(file), new Condition<ErlangFile>() {
        @Override
        public boolean value(@NotNull ErlangFile includedFile) {
          return isEunitDirectlyImported(includedFile);
        }
      }) != null;
  }

  private static boolean isEunitDirectlyImported(@NotNull ErlangFile file) {
    List<ErlangIncludeLib> includes = file.getIncludeLibs();
    for (ErlangIncludeLib include : includes) {
      ErlangIncludeString string = include.getIncludeStringSafe();
      if (string != null) {
        String includeFilePath = StringUtil.unquoteString(string.getText());
        return StringUtil.equals(includeFilePath, "eunit/include/eunit.hrl");
      }
    }
    return false;
  }

  @NotNull
  public static SearchScope getUseScope(@NotNull ErlangQVarImpl o) {
    ErlangFunction function = PsiTreeUtil.getParentOfType(o, ErlangFunction.class, true);
    if (function != null) {
      return new LocalSearchScope(function);
    }
    return ResolveScopeManager.getElementUseScope(o);
  }

  @NotNull
  public static String getName(@NotNull ErlangTypeDefinition o) {
    return getNameImpl(o);
  }

  @Nullable
  public static ErlangSpecification findSpecification(@Nullable ErlangFunction function) {
    if (function == null) return null;
    PsiFile file = function.getContainingFile();
    if (!(file instanceof ErlangFile)) return null;
    List<ErlangSpecification> specifications = ((ErlangFile) file).getSpecifications();
    LocalSearchScope scope = new LocalSearchScope(ArrayUtil.toObjectArray(specifications, ErlangSpecification.class));
    AccessToken token = ApplicationManager.getApplication().acquireReadActionLock();
    try {
      Query<PsiReference> search = ReferencesSearch.search(function, scope);
      PsiReference first = search.findFirst();
      return PsiTreeUtil.getParentOfType(first != null ? first.getElement() : null, ErlangSpecification.class);
    } finally {
      token.finish();
    }
  }

  public static boolean notFromPreviousFunction(@NotNull PsiElement spec, @Nullable ErlangFunction prevFunction) {
    return prevFunction == null || spec.getTextOffset() > prevFunction.getTextOffset();
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean isValidHost(@NotNull ErlangStringLiteral o) {
    return true;
  }

  @NotNull
  public static ErlangStringLiteral updateText(@NotNull ErlangStringLiteral o, @NotNull String text) {
    ErlangExpression expression = ErlangElementFactory.createExpressionFromText(o.getProject(), text);
    return (ErlangStringLiteralImpl)o.replace(expression);
  }

  @NotNull
  public static ErlangStringLiteralEscaper createLiteralTextEscaper(@NotNull ErlangStringLiteral o) {
    return new ErlangStringLiteralEscaper(o);
  }

  @Nullable
  public static ErlangQAtom getQAtom(@Nullable ErlangColonQualifiedExpression colonQualifier) {
    ErlangExpression firstExpression = colonQualifier == null ? null : ContainerUtil.getFirstItem(colonQualifier.getExpressionList());
    return firstExpression instanceof ErlangMaxExpression ? ((ErlangMaxExpression) firstExpression).getQAtom() : null;
  }

  @Nullable
  public static String getCallbackSpecName(@NotNull ErlangCallbackSpec spec) {
    ErlangQAtom atom = getCallbackAtom(spec);
    return atom != null ? atom.getText() : null;
  }

  public static int getCallbackSpecArity(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs sigs = spec.getFunTypeSigs();
    ErlangSpecFun fun = sigs != null ? sigs.getSpecFun() : null;
    Integer arity = fun != null ? getArity(fun) : null;
    return arity != null ? arity : -1;
  }

  @NotNull
  public static String getExportFunctionName(@NotNull ErlangExportFunction exportFunction) {
    return getNameIdentifier(exportFunction.getQAtom()).getText();
  }

  @Nullable
  private static ErlangQAtom getCallbackAtom(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    ErlangSpecFun specFun = funTypeSigs != null ? funTypeSigs.getSpecFun() : null;
    return specFun != null ? specFun.getQAtom() : null;
  }

  @Nullable
  public static ErlangFunTypeSigs getFunTypeSigs(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = spec.getFunTypeSigs();
    if (funTypeSigs == null) {
      ErlangFunTypeSigsBraces braces = spec.getFunTypeSigsBraces();
      funTypeSigs = braces != null ? braces.getFunTypeSigs() : null;
    }
    return funTypeSigs;
  }

  @NotNull
  public static List<ErlangType> getCallBackSpecArguments(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    List<ErlangTypeSig> typeSigList = funTypeSigs != null ? funTypeSigs.getTypeSigList() : ContainerUtil.<ErlangTypeSig>emptyList();
    ErlangTypeSig typeSig = ContainerUtil.getFirstItem(typeSigList);
    ErlangFunType funType = typeSig != null ? typeSig.getFunType() : null;
    ErlangFunTypeArguments arguments = funType != null ? funType.getFunTypeArguments() : null;
    return arguments != null ? arguments.getTypeList() : ContainerUtil.<ErlangType>emptyList();
  }

  public static boolean isPrivateFunction(@NotNull PsiFile containingFile, @NotNull ErlangFunction function) {
    boolean exportAll = containingFile instanceof ErlangFile && ((ErlangFile) containingFile).isExportedAll();
    if (exportAll) return false;
    return containingFile instanceof ErlangFile && !((ErlangFile) containingFile).getExportedFunctions().contains(function);
  }

  public static int getExpressionPrecedence(@Nullable PsiElement element) {
    if (element instanceof ErlangCatchExpression) return 0;
    if (element instanceof ErlangAssignmentExpression) return 1;
    if (element instanceof ErlangSendExpression) return 2;
    if (element instanceof ErlangOrelseExpression) return 3;
    if (element instanceof ErlangAndalsoExpression) return 4;
    if (element instanceof ErlangCompOpExpression) return 5;
    if (element instanceof ErlangListOpExpression) return 6;
    if (element instanceof ErlangAdditiveExpression) return 7;
    if (element instanceof ErlangMultiplicativeExpression) return 8;
    if (element instanceof ErlangPrefixExpression) return 9;
    if (element instanceof ErlangColonQualifiedExpression) return 10;
    if (element instanceof ErlangFunctionCallExpression
      || element instanceof ErlangGlobalFunctionCallExpression
      || element instanceof ErlangGenericFunctionCallExpression
      || element instanceof ErlangAnonymousCallExpression
      || element instanceof ErlangRecordExpression
      || element instanceof ErlangQualifiedExpression) return 11;
    if (element instanceof ErlangMaxExpression
      || element instanceof ErlangTupleExpression
      || element instanceof ErlangListExpression
      || element instanceof ErlangCaseExpression
      || element instanceof ErlangIfExpression
      || element instanceof ErlangListComprehension
      || element instanceof ErlangReceiveExpression
      || element instanceof ErlangFunExpression
      || element instanceof ErlangTryExpression
      || element instanceof ErlangBinaryExpression
      || element instanceof ErlangBeginEndExpression
      ) return 12;
    if (element instanceof ErlangParenthesizedExpression) return 13;
    return -1;
  }

  @NotNull
  public static ErlangExpression getOutermostParenthesizedExpression(@NotNull ErlangExpression expression) {
    while (expression.getParent() instanceof ErlangParenthesizedExpression) {
      ErlangParenthesizedExpression parent = (ErlangParenthesizedExpression) expression.getParent();
      if (!expression.isEquivalentTo(parent.getExpression())) break;
      expression = parent;
    }

    return expression;
  }

  @Nullable
  public static ErlangExpression getNotParenthesizedExpression(@Nullable ErlangExpression expression) {
    while (expression instanceof ErlangParenthesizedExpression) {
      expression = ((ErlangParenthesizedExpression) expression).getExpression();
    }
    return expression;
  }

  @NotNull
  public static ErlangExpression wrapWithParentheses(@NotNull ErlangExpression expression) {
    return ErlangElementFactory.createExpressionFromText(expression.getProject(), "(" + expression.getText() + ")");
  }

  @Nullable
  public static ErlangFunExpression findFunExpression(@NotNull ErlangFunction function, final int funExpressionNumber) {
    final Ref<ErlangFunExpression> result = new Ref<ErlangFunExpression>();
    final Ref<Integer> currentFunExpressionNumber = new Ref<Integer>(0);
    function.accept(new ErlangRecursiveVisitor() {
      @Override
      public void visitFunExpression(@NotNull ErlangFunExpression funExpression) {
        if (funExpressionNumber == currentFunExpressionNumber.get()) {
          result.set(funExpression);
        }
        currentFunExpressionNumber.set(currentFunExpressionNumber.get() + 1);
        super.visitFunExpression(funExpression);
      }
    });
    return result.get();
  }

  public static PsiElementPattern.Capture<ErlangQAtom> secondAtomInIsRecord() {
    return psiElement(ErlangQAtom.class).with(inIsRecord(1));
  }

  @NotNull
  public static <T extends PsiElement >ErlangFunctionCallParameter<T> inIsRecord(int position) {
    return new ErlangFunctionCallParameter<T>("is_record", "erlang", 2, position);
  }

  public static boolean isExported(@NotNull ErlangFunction o) {
    ErlangFunctionStub stub = o.getStub();
    if (stub != null) return stub.isExported();

    PsiFile file = o.getContainingFile();
    String signature = o.getName() + "/" + o.getArity();
    return file instanceof ErlangFile && ((ErlangFile) file).isExported(signature);
  }

  @Nullable
  public static ErlangIncludeString getIncludeStringSafe(@NotNull ErlangInclude o) {
    ErlangIncludeStub stub = o.getStub();
    if (stub != null) return stub.getIncludeString();
    return o.getIncludeString();
  }

  @Nullable
  public static ErlangIncludeString getIncludeStringSafe(@NotNull ErlangIncludeLib o) {
    ErlangIncludeLibStub stub = o.getStub();
    if (stub != null) return stub.getIncludeString();
    return o.getIncludeString();
  }

  @NotNull
  public static ErlangFunctionReferenceImpl<ErlangQAtom> createFunctionReference(@NotNull ErlangQAtom atom) {
    PsiElement parent = atom.getParent();
    ErlangMaxExpression moduleExpression = PsiTreeUtil.getPrevSiblingOfType(parent, ErlangMaxExpression.class);
    ErlangListExpression list = PsiTreeUtil.getNextSiblingOfType(parent, ErlangListExpression.class);
    ErlangQAtom module = moduleExpression == null ? null : moduleExpression.getQAtom();
    int arity = list == null ? -1 : list.getExpressionList().size();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(atom, module, arity);
  }

  public static boolean isWhitespaceOrComment(@NotNull PsiElement element) {
    return isWhitespaceOrComment(element.getNode());
  }

  public static boolean isWhitespaceOrComment(@NotNull ASTNode node) {
    IElementType elementType = node.getElementType();
    return ErlangParserDefinition.WS.contains(elementType) ||
      ErlangParserDefinition.COMMENTS.contains(elementType);
  }

  public static boolean is(@Nullable PsiElement element, IElementType type) {
    return element != null && element.getNode().getElementType() == type;
  }

  @NotNull
  public static TextRange getTextRangeForReference(@NotNull ErlangQAtom qAtom) {
    return rangeInParent(qAtom.getTextRange(), getNameIdentifier(qAtom).getTextRange());
  }

  @NotNull
  public static TextRange getTextRangeForReference(@NotNull ErlangMacrosName macroName) {
    return rangeInParent(macroName.getTextRange(), getNameIdentifier(macroName).getTextRange());
  }

  @NotNull
  private static TextRange rangeInParent(@NotNull TextRange parent, @NotNull TextRange child) {
    int start = child.getStartOffset() - parent.getStartOffset();
    return TextRange.create(start, start + child.getLength());
  }

  @NotNull
  private static String getNameImpl(@NotNull ErlangNamedElement namedElement) {
    if (namedElement instanceof StubBasedPsiElement) {
      String fromStub = getNameFromStub((StubBasedPsiElement)namedElement);
      if (fromStub != null) return fromStub;
    }
    PsiElement nameIdentifier = namedElement.getNameIdentifier();
    return nameIdentifier != null ? nameIdentifier.getText() : "";
  }

  @Nullable
  private static String getNameFromStub(StubBasedPsiElement element) {
    NamedStubBase<?> stub = ObjectUtils.tryCast(element.getStub(), NamedStubBase.class);
    return stub != null ? StringUtil.notNullize(stub.getName()) : null;
  }

  public static boolean fromTheSameCaseExpression(@NotNull PsiElement origin, @NotNull PsiElement element) {
    if (element instanceof ErlangQVar && Comparing.equal(element.getText(), element.getText())) {
      ErlangCompositeElement cr2 = PsiTreeUtil.getParentOfType(element, ErlangCrClause.class);
      ErlangCompositeElement cr1 = PsiTreeUtil.getParentOfType(origin, ErlangCrClause.class);
      if (cr1 != null && cr2 != null) {
        ErlangCaseExpression ce1 = PsiTreeUtil.getParentOfType(element, ErlangCaseExpression.class);
        ErlangCaseExpression ce2 = PsiTreeUtil.getParentOfType(origin, ErlangCaseExpression.class);
        if (Comparing.equal(ce1, ce2)) return true;
      }
    }
    return false;
  }

  public static class ErlangFunctionCallParameter<T extends PsiElement> extends PatternCondition<T> {
    @NotNull
    private final String myFunName;
    @NotNull
    private final String myModule;
    private final int myArity;
    private final int myPosition;

    public ErlangFunctionCallParameter(@NotNull String funName, @NotNull String module, int arity, int position) {
      super("functionCallParameter");
      myFunName = funName;
      myModule = module;
      myArity = arity;
      myPosition = position;
    }

    @Override
    public boolean accepts(@NotNull T element, ProcessingContext context) {
      ErlangExpression expr = PsiTreeUtil.getParentOfType(element, ErlangExpression.class, false);
      if (expr == null) return false;
      PsiElement list = expr.getParent();
      if (list instanceof ErlangArgumentList) {
        PsiElement funCall = list.getParent();
        List<ErlangExpression> expressions = ((ErlangArgumentList) list).getExpressionList();
        if (!(expressions.size() > myPosition && expressions.get(myPosition) == expr)) return false;
        if (funCall instanceof ErlangFunctionCallExpression) {
          PsiReference reference = funCall.getReference();

          ResolveResult[] results = reference instanceof PsiPolyVariantReference ?
            ((PsiPolyVariantReference) reference).multiResolve(true) : ResolveResult.EMPTY_ARRAY;
          for (ResolveResult r : results) {
            if (expectedFunction(r.getElement())) return true;
          }
        }
      }
      return false;
    }

    private boolean expectedFunction(@Nullable PsiElement resolve) {
      if (!(resolve instanceof ErlangFunction)) return false;
      String name = ((ErlangFunction) resolve).getName();
      if (!name.equals(myFunName)) return false;
      PsiFile containingFile = resolve.getContainingFile();
      if (!(containingFile instanceof ErlangFile)) return false;
      ErlangModule module = ((ErlangFile) containingFile).getModule();
      String moduleName = module != null ? module.getName() : null;
      if (!myModule.equals(moduleName)) return false;
      int arity = getArity((ErlangFunction) resolve);
      if (arity != myArity) return false;
      return true;
    }
  }
}
<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.execution.ExecutionException;
import com.intellij.execution.configurations.GeneralCommandLine;
import com.intellij.execution.process.BaseOSProcessHandler;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.JDOMUtil;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.util.CommonProcessors;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.graph.GraphGenerator;
import com.intellij.util.xmlb.XmlSerializationException;
import com.intellij.util.xmlb.XmlSerializer;
import org.intellij.erlang.jps.model.*;
import org.jdom.Document;
import org.jdom.JDOMException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.builders.BuildOutputConsumer;
import org.jetbrains.jps.builders.DirtyFilesHolder;
import org.jetbrains.jps.builders.FileProcessor;
import org.jetbrains.jps.incremental.CompileContext;
import org.jetbrains.jps.incremental.ProjectBuildException;
import org.jetbrains.jps.incremental.TargetBuilder;
import org.jetbrains.jps.incremental.messages.BuildMessage;
import org.jetbrains.jps.incremental.messages.CompilerMessage;
import org.jetbrains.jps.incremental.resources.ResourcesBuilder;
import org.jetbrains.jps.incremental.resources.StandardResourceBuilderEnabler;
import org.jetbrains.jps.model.JpsDummyElement;
import org.jetbrains.jps.model.JpsProject;
import org.jetbrains.jps.model.java.JavaSourceRootType;
import org.jetbrains.jps.model.java.JpsJavaExtensionService;
import org.jetbrains.jps.model.library.sdk.JpsSdk;
import org.jetbrains.jps.model.module.*;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.*;

public class ErlangBuilder extends TargetBuilder<ErlangSourceRootDescriptor, ErlangTarget> {
  public static final String DEPENDENCIES_CONFIG_FILE_PATH = "erlang-builder/deps-config.xml";
  public static final String NAME = "erlc";
  private static final Logger LOG = Logger.getInstance(ErlangBuilder.class);

  public ErlangBuilder() {
    super(Collections.singletonList(ErlangTargetType.INSTANCE));



    ResourcesBuilder.registerEnabler(new StandardResourceBuilderEnabler() {
      @Override
      public boolean isResourceProcessingEnabled(@NotNull JpsModule module) {
        return !(module.getModuleType() instanceof JpsErlangModuleType);
      }
    });
  }

  @Override
  public void build(@NotNull ErlangTarget target,
                    @NotNull DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                    @NotNull BuildOutputConsumer outputConsumer,
                    @NotNull CompileContext context) throws ProjectBuildException, IOException {
    LOG.debug(target.getPresentableName());
    if (!holder.hasDirtyFiles() && !holder.hasRemovedFiles()) return;

    JpsModule module = target.getModule();
    JpsProject project = module.getProject();
    ErlangCompilerOptions compilerOptions = JpsErlangCompilerOptionsExtension.getOrCreateExtension(project).getOptions();
    if (compilerOptions.myUseRebarCompiler) return;

    File sourceOutput = getBuildOutputDirectory(module, false, context);
    File testOutput = getBuildOutputDirectory(module, true, context);

    buildSources(target, context, compilerOptions, holder, outputConsumer, sourceOutput, false);
    buildSources(target, context, compilerOptions, holder, outputConsumer, testOutput, true);

    processAppConfigFiles(holder, outputConsumer, context, sourceOutput, testOutput);
  }

  @NotNull
  @Override
  public String getPresentableName() {
    return NAME;
  }

  private static void reportProgress(@NotNull CompileContext context, String message) {
    context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.PROGRESS, message));
  }

  private static void buildSources(ErlangTarget target,
                                   CompileContext context,
                                   ErlangCompilerOptions compilerOptions,
                                   DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                                   BuildOutputConsumer outputConsumer,
                                   File outputDir,
                                   final boolean isTests) throws IOException, ProjectBuildException {
    List<String> dirtyErlangModulePaths = new DirtyFileProcessor<String>() {
      @Nullable
      @Override
      protected String getDirtyElement(@NotNull ErlangTarget target,
                                       @NotNull File file,
                                       @NotNull ErlangSourceRootDescriptor root) throws IOException {
        return (isTests || !root.isTests()) && file.getName().endsWith(".erl") ? file.getAbsolutePath() : null;
      }
    }.collectDirtyElements(holder);

    List<String> erlangModulePathsToCompile = getErlangModulePaths(target, context, dirtyErlangModulePaths, isTests);
    if (erlangModulePathsToCompile.isEmpty()) {
      reportProgress(context, "Source is up to date");
      return;
    }
    String message = isTests ? "Compile tests for module " : "Compile source code for module ";
    reportProgress(context, message + target.getModule().getName());
    runErlc(target, context, compilerOptions, erlangModulePathsToCompile, outputConsumer, outputDir, isTests);
  }

  @NotNull
  private static File getBuildOutputDirectory(@NotNull JpsModule module,
                                              boolean forTests,
                                              @NotNull CompileContext context) throws ProjectBuildException {
    JpsJavaExtensionService instance = JpsJavaExtensionService.getInstance();
    File outputDirectory = instance.getOutputDirectory(module, forTests);
    if (outputDirectory == null) {
      String errorMessage = "No output dir for module " + module.getName();
      context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.ERROR, errorMessage));
      throw new ProjectBuildException(errorMessage);
    }
    if (!outputDirectory.exists()) {
      FileUtil.createDirectory(outputDirectory);
    }
    return outputDirectory;
  }

  private static void processAppConfigFiles(DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                                            BuildOutputConsumer outputConsumer,
                                            CompileContext context,
                                            File... outputDirectories) throws IOException {
    List<File> appConfigFiles = new DirtyFileProcessor<File>() {
      @Nullable
      @Override
      protected File getDirtyElement(@NotNull ErlangTarget target,
                                     @NotNull File file,
                                     @NotNull ErlangSourceRootDescriptor root) throws IOException {
        return isAppConfigFileName(file.getName()) ? file : null;
      }
    }.collectDirtyElements(holder);

    for (File appConfigSrc : appConfigFiles) {
      for (File outputDir : outputDirectories) {
        File appConfigDst = new File(outputDir, getAppConfigDestinationFileName(appConfigSrc.getName()));
        FileUtil.copy(appConfigSrc, appConfigDst);
        reportProgress(context, String.format("Copy %s to %s",appConfigDst.getAbsolutePath(),outputDir.getAbsolutePath()));
        outputConsumer.registerOutputFile(appConfigDst, Collections.singletonList(appConfigSrc.getAbsolutePath()));
      }
    }
  }

  private static boolean isAppConfigFileName(String fileName) {
    return fileName.endsWith(".app") || fileName.endsWith(".app.src");
  }

  private static String getAppConfigDestinationFileName(String sourceFileName) {
    return StringUtil.trimEnd(sourceFileName, ".src");
  }

  private static void runErlc(ErlangTarget target,
                              CompileContext context,
                              ErlangCompilerOptions compilerOptions,
                              List<String> erlangModulePathsToCompile,
                              BuildOutputConsumer outputConsumer,
                              File outputDirectory,
                              boolean isTest) throws ProjectBuildException, IOException {
    GeneralCommandLine commandLine = getErlcCommandLine(target, context, compilerOptions, outputDirectory, erlangModulePathsToCompile, isTest);
    Process process;
    try {
      process = commandLine.createProcess();
    }
    catch (ExecutionException e) {
      throw new ProjectBuildException("Failed to launch erlang compiler", e);
    }
    BaseOSProcessHandler handler = new BaseOSProcessHandler(process, commandLine.getCommandLineString(), Charset.defaultCharset());
    ProcessAdapter adapter = new ErlangCompilerProcessAdapter(context, NAME, "");
    handler.addProcessListener(adapter);
    handler.startNotify();
    handler.waitFor();
    consumeFiles(outputConsumer, getOutputErlangModuleFiles(erlangModulePathsToCompile, outputDirectory));
  }

  private static GeneralCommandLine getErlcCommandLine(ErlangTarget target,
                                                       CompileContext context,
                                                       ErlangCompilerOptions compilerOptions,
                                                       File outputDirectory,
                                                       List<String> erlangModulePaths,
                                                       boolean isTest) throws ProjectBuildException {
    GeneralCommandLine commandLine = new GeneralCommandLine();
    JpsModule module = target.getModule();
    JpsSdk<JpsDummyElement> sdk = ErlangTargetBuilderUtil.getSdk(context, module);
    File executable = JpsErlangSdkType.getByteCodeCompilerExecutable(sdk.getHomePath());
    commandLine.withWorkDirectory(outputDirectory);
    commandLine.setExePath(executable.getAbsolutePath());
    addCodePath(commandLine, module, target, context);
    addParseTransforms(commandLine, module);
    addDebugInfo(commandLine, compilerOptions.myAddDebugInfoEnabled);
    addIncludePaths(commandLine, module);
    addMacroDefinitions(commandLine, isTest);
    commandLine.addParameters(erlangModulePaths);
    return commandLine;
  }

  private static void addMacroDefinitions(GeneralCommandLine commandLine, boolean isTests) {
    if (isTests) {
      commandLine.addParameters("-DTEST");
    }
  }

  private static void addDebugInfo(@NotNull GeneralCommandLine commandLine, boolean addDebugInfoEnabled) {
    if (addDebugInfoEnabled) {
      commandLine.addParameter("+debug_info");
    }
  }

  private static void addIncludePaths(@NotNull GeneralCommandLine commandLine, @Nullable JpsModule module) {
    if (module == null) return;
    for (JpsTypedModuleSourceRoot<JpsDummyElement> includeDirectory : module.getSourceRoots(ErlangIncludeSourceRootType.INSTANCE)) {
      commandLine.addParameters("-I", includeDirectory.getFile().getPath());
    }
  }

  @NotNull
  private static List<String> getErlangModulePaths(@NotNull ErlangTarget target,
                                                   @NotNull CompileContext context,
                                                   @NotNull List<String> dirtyFilePaths,
                                                   boolean isTest) {
    List<ErlangFileDescriptor> moduleDescriptors = getErlangModuleDescriptorFromConfig(target, context, isTest);
    return moduleDescriptors != null ?
           getSortedErlangModulePathsToCompile(moduleDescriptors, dirtyFilePaths) :
           getErlangModulePathsDefault(target, isTest);
  }

  private static List<String> getSortedErlangModulePathsToCompile(@NotNull List<ErlangFileDescriptor> sortedModuleDescriptors,
                                                                  @NotNull List<String> dirtyModules) {
    SortedModuleDependencyGraph semiGraph = new SortedModuleDependencyGraph(sortedModuleDescriptors);
    GraphGenerator<Node> graph = GraphGenerator.create(semiGraph);
    markDirtyNodes(semiGraph.getNodesByName(dirtyModules), graph);
    return ContainerUtil.mapNotNull(semiGraph.getNodes(), new Function<Node, String>() {
      @Nullable
      @Override
      public String fun(Node node) {
        return node.myDirty ? node.myErlangModulePath : null;
      }
    });
  }

  @NotNull
  private static List<String> getErlangModulePathsDefault(@NotNull ErlangTarget target, boolean isTests) {
    CommonProcessors.CollectProcessor<File> erlFilesCollector = new CommonProcessors.CollectProcessor<File>() {
      @Override
      protected boolean accept(@NotNull File file) {
        return !file.isDirectory() && FileUtilRt.extensionEquals(file.getName(), "erl");
      }
    };
    List<JpsModuleSourceRoot> sourceRoots = ContainerUtil.newArrayList();
    JpsModule module = target.getModule();
    ContainerUtil.addAll(sourceRoots, module.getSourceRoots(JavaSourceRootType.SOURCE));
    if (isTests) {
      ContainerUtil.addAll(sourceRoots, module.getSourceRoots(JavaSourceRootType.TEST_SOURCE));
    }
    for (JpsModuleSourceRoot root : sourceRoots) {
      FileUtil.processFilesRecursively(root.getFile(), erlFilesCollector);
    }
    return ContainerUtil.map(erlFilesCollector.getResults(), new Function<File, String>() {
      @NotNull
      @Override
      public String fun(@NotNull File file) {
        return file.getAbsolutePath();
      }
    });
  }

  @Nullable
  private static List<ErlangFileDescriptor> getErlangModuleDescriptorFromConfig(@NotNull ErlangTarget target,
                                                                                @NotNull CompileContext context,
                                                                                boolean isTests) {
    File dataStorageRoot = context.getProjectDescriptor().dataManager.getDataPaths().getDataStorageRoot();
    File depsConfigFile = new File(dataStorageRoot, DEPENDENCIES_CONFIG_FILE_PATH);
    if (!depsConfigFile.exists()) return null;
    ErlangModuleBuildOrders buildOrders;
    try {
      Document document = JDOMUtil.loadDocument(depsConfigFile);
      buildOrders = XmlSerializer.deserialize(document, ErlangModuleBuildOrders.class);
    }
    catch (XmlSerializationException e) {
      return null;
    }
    catch (JDOMException e) {
      return null;
    }
    catch (IOException e) {
      return null;
    }
    if (buildOrders == null) return null;
    for (ErlangModuleBuildOrderDescriptor buildOrder : buildOrders.myModuleBuildOrderDescriptors) {
      if (StringUtil.equals(buildOrder.myModuleName, target.getModule().getName())) {
        List<ErlangFileDescriptor> modules = buildOrder.myOrderedErlangModulePaths;
        if (isTests) {
          modules = ContainerUtil.concat(modules, buildOrder.myOrderedErlangTestModulePaths);
        }
        return modules;
      }
    }
    return null;
  }

  private static void addParseTransforms(@NotNull GeneralCommandLine commandLine,
                                         @Nullable JpsModule module) throws ProjectBuildException {
    JpsErlangModuleExtension extension = JpsErlangModuleExtension.getExtension(module);
    List<String> parseTransforms = extension != null ? extension.getParseTransforms() : Collections.<String>emptyList();
    if (parseTransforms.isEmpty()) return;
    for (String ptModule : parseTransforms) {
      commandLine.addParameter("+{parse_transform, " + ptModule + "}");
    }
  }

  private static void addCodePath(@NotNull GeneralCommandLine commandLine,
                                  @NotNull JpsModule module,
                                  @NotNull ErlangTarget target,
                                  @NotNull CompileContext context) throws ProjectBuildException {
    List<JpsModule> codePathModules = ContainerUtil.newArrayList();
    collectDependentModules(module, codePathModules, ContainerUtil.<String>newHashSet());
    addModuleToCodePath(commandLine, module, target.isTests(), context);
    for (JpsModule codePathModule : codePathModules) {
      if (codePathModule != module) {
        addModuleToCodePath(commandLine, codePathModule, false, context);
      }
    }
  }

  private static void collectDependentModules(@NotNull JpsModule module,
                                              @NotNull Collection<JpsModule> addedModules,
                                              @NotNull Set<String> addedModuleNames) {
    String moduleName = module.getName();
    if (addedModuleNames.contains(moduleName)) return;
    addedModuleNames.add(moduleName);
    addedModules.add(module);
    for (JpsDependencyElement dependency : module.getDependenciesList().getDependencies()) {
      if (!(dependency instanceof JpsModuleDependency)) continue;
      JpsModuleDependency moduleDependency = (JpsModuleDependency) dependency;
      JpsModule depModule = moduleDependency.getModule();
      if (depModule != null) {
        collectDependentModules(depModule, addedModules, addedModuleNames);
      }
    }
  }

  private static void addModuleToCodePath(@NotNull GeneralCommandLine commandLine,
                                          @NotNull JpsModule module,
                                          boolean forTests,
                                          @NotNull CompileContext context) throws ProjectBuildException {
    File outputDirectory = getBuildOutputDirectory(module, forTests, context);
    commandLine.addParameters("-pa", outputDirectory.getPath());
    for (String rootUrl : module.getContentRootsList().getUrls()) {
      try {
        String path = new URL(rootUrl).getPath();
        commandLine.addParameters("-pa", path);
      }
      catch (MalformedURLException e) {
        context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.ERROR, "Failed to find content root for module: " + module.getName()));
      }
    }
  }

  private static void markDirtyNodes(@NotNull List<Node> dirtyModules,
                                     @NotNull GraphGenerator<Node> graph) {
    for (Node node : dirtyModules) {
      if (node != null) {
        markDirtyNodes(node, graph);
      }
    }
  }

  private static void markDirtyNodes(@NotNull Node node, @NotNull GraphGenerator<Node> graph) {
    if (node.myDirty) return;
    node.myDirty = true;
    Iterator<Node> childIterator = graph.getOut(node);
    while (childIterator.hasNext()) {
      markDirtyNodes(childIterator.next(), graph);
    }
  }

  private static List<File> getOutputErlangModuleFiles(@NotNull List<String> erlangModulePathsToCompile,
                                                       @NotNull final File outputDirectory) {
    return ContainerUtil.map(erlangModulePathsToCompile, new Function<String, File>() {
      @Override
      public File fun(String filePath) {
        String name = FileUtil.getNameWithoutExtension(filePath);
        return new File(outputDirectory.getAbsolutePath() + name + ".beam");
      }
    });
  }

  private static void consumeFiles(@NotNull BuildOutputConsumer outputConsumer,
                                   @NotNull List<File> dirtyFilePaths) throws IOException {
    for (File outputFile : dirtyFilePaths) {
      if (outputFile.exists()) {
        outputConsumer.registerOutputFile(outputFile, Collections.singletonList(outputFile.getAbsolutePath()));
      }
    }
  }

  private static abstract class DirtyFileProcessor<T> implements FileProcessor<ErlangSourceRootDescriptor, ErlangTarget> {
    private final List<T> myDirtyElements = ContainerUtil.newArrayList();

    public List<T> collectDirtyElements(@NotNull DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder) throws IOException {
      holder.processDirtyFiles(this);
      return myDirtyElements;
    }

    @Override
    public boolean apply(ErlangTarget erlangTarget,
                         File file,
                         ErlangSourceRootDescriptor erlangSourceRootDescriptor) throws IOException {
      ContainerUtil.addIfNotNull(myDirtyElements, getDirtyElement(erlangTarget, file, erlangSourceRootDescriptor));
      return true;
    }

    @Nullable
    protected abstract T getDirtyElement(@NotNull ErlangTarget target,
                                         @NotNull File file,
                                         @NotNull ErlangSourceRootDescriptor root) throws IOException;
  }

  private static class Node {
    final String myErlangModulePath;
    final List<Node> myDependencies = ContainerUtil.newArrayList();
    public boolean myDirty = false;

    Node(String nodeName) {
      myErlangModulePath = nodeName;
    }
  }

  private static class SortedModuleDependencyGraph implements GraphGenerator.SemiGraph<Node> {
    private final LinkedHashMap<String, Node> myNodePathsMap;

    public SortedModuleDependencyGraph(List<ErlangFileDescriptor> moduleDescriptors) {
      myNodePathsMap = getPathsMap(moduleDescriptors);
      addDependencies(moduleDescriptors);
    }

    @Override
    public Collection<Node> getNodes() {
      return myNodePathsMap.values();
    }

    @Override
    public Iterator<Node> getIn(Node node) {
      return node.myDependencies.iterator();
    }

    @Nullable
    public Node getNode(@NotNull String moduleName) {
      return myNodePathsMap.get(moduleName);
    }

    private void addDependencies(List<ErlangFileDescriptor> moduleDescriptors) {
      for (ErlangFileDescriptor descriptor : moduleDescriptors) {
        Node node = myNodePathsMap.get(descriptor.myErlangModulePath);
        node.myDependencies.addAll(getNodesByName(descriptor.myDependencies));
      }
    }

    @NotNull
    private List<Node> getNodesByName(List<String> nodes) {
      return ContainerUtil.mapNotNull(nodes, new Function<String, Node>() {
        @Override
        public Node fun(String dependencyName) {
          return myNodePathsMap.get(dependencyName);
        }
      });
    }

    private static LinkedHashMap<String, Node> getPathsMap(List<ErlangFileDescriptor> moduleDescriptors) {
      LinkedHashMap<String, Node> nodePathsMap = ContainerUtil.newLinkedHashMap();
      for (ErlangFileDescriptor descriptor : moduleDescriptors) {
        nodePathsMap.put(descriptor.myErlangModulePath, new Node(descriptor.myErlangModulePath));
      }
      return nodePathsMap;
    }
  }
}

<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.xmlb.annotations.AbstractCollection;
import com.intellij.util.xmlb.annotations.Attribute;
import com.intellij.util.xmlb.annotations.Tag;

import java.util.List;

@Tag("module")
public class ErlangModuleBuildOrderDescriptor {
  @Attribute("name")
  public String myModuleName = "";

  @Tag("erlangModules")
  @AbstractCollection(surroundWithTag = false)
  public List<ErlangFileDescriptor> myOrderedErlangModulePaths = ContainerUtil.newArrayList();

  @Tag("testErlangModules")
  @AbstractCollection(surroundWithTag = false)
  public List<ErlangFileDescriptor> myOrderedErlangTestModulePaths = ContainerUtil.newArrayList();
}

<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.jps.model.JpsErlangModuleType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.builders.*;
import org.jetbrains.jps.builders.storage.BuildDataPaths;
import org.jetbrains.jps.incremental.CompileContext;
import org.jetbrains.jps.indices.IgnoredFileIndex;
import org.jetbrains.jps.indices.ModuleExcludeIndex;
import org.jetbrains.jps.model.JpsModel;
import org.jetbrains.jps.model.java.JavaSourceRootProperties;
import org.jetbrains.jps.model.java.JavaSourceRootType;
import org.jetbrains.jps.model.java.JpsJavaClasspathKind;
import org.jetbrains.jps.model.java.JpsJavaExtensionService;
import org.jetbrains.jps.model.module.JpsModule;
import org.jetbrains.jps.model.module.JpsTypedModuleSourceRoot;

import java.io.File;
import java.util.*;

public class ErlangTarget extends ModuleBasedTarget<ErlangSourceRootDescriptor> {
  public ErlangTarget(@NotNull JpsModule module, ErlangTargetType targetType) {
    super(targetType, module);
  }

  @Override
  public String getId() {
    return myModule.getName();
  }

  @Override
  public Collection<BuildTarget<?>> computeDependencies(BuildTargetRegistry targetRegistry, TargetOutputIndex outputIndex) {
    return computeDependencies();
  }

  public Collection<BuildTarget<?>> computeDependencies() {
    List<BuildTarget<?>> dependencies = new ArrayList<BuildTarget<?>>();
    Set<JpsModule> modules = JpsJavaExtensionService.dependencies(myModule).includedIn(JpsJavaClasspathKind.compile(isTests())).getModules();
    for (JpsModule module : modules) {
      if (module.getModuleType().equals(JpsErlangModuleType.INSTANCE)) {
        dependencies.add(new ErlangTarget(module, getErlangTargetType()));
      }
    }
    return dependencies;
  }

  @NotNull
  @Override
  public List<ErlangSourceRootDescriptor> computeRootDescriptors(JpsModel model, ModuleExcludeIndex index, IgnoredFileIndex ignoredFileIndex, BuildDataPaths dataPaths) {
    List<ErlangSourceRootDescriptor> result = new ArrayList<ErlangSourceRootDescriptor>();
    for (JpsTypedModuleSourceRoot<JavaSourceRootProperties> root : myModule.getSourceRoots(JavaSourceRootType.SOURCE)) {
      result.add(new ErlangSourceRootDescriptor(root.getFile(), this, false));
    }
    for (JpsTypedModuleSourceRoot<JavaSourceRootProperties> root : myModule.getSourceRoots(JavaSourceRootType.TEST_SOURCE)) {
      result.add(new ErlangSourceRootDescriptor(root.getFile(), this, true));
    }
    return result;
  }

  @Nullable
  @Override
  public ErlangSourceRootDescriptor findRootDescriptor(String rootId, BuildRootIndex rootIndex) {
    return ContainerUtil.getFirstItem(rootIndex.getRootDescriptors(new File(rootId), Collections.singletonList(getErlangTargetType()), null));
  }

  @NotNull
  @Override
  public String getPresentableName() {
    return "Erlang '" + myModule.getName() + "'";
  }

  @NotNull
  @Override
  public Collection<File> getOutputRoots(CompileContext context) {
    return ContainerUtil.newArrayList(JpsJavaExtensionService.getInstance().getOutputDirectory(myModule, false),
                                      JpsJavaExtensionService.getInstance().getOutputDirectory(myModule, true));
  }

  @Override
  public boolean isTests() {
    return false;
  }

  public ErlangTargetType getErlangTargetType() {
    return (ErlangTargetType) getTargetType();
  }
}

<code block>


package org.intellij.erlang.jps.builder;


import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.xmlb.annotations.AbstractCollection;
import com.intellij.util.xmlb.annotations.Attribute;
import com.intellij.util.xmlb.annotations.Tag;

import java.util.List;

@Tag("module")
public class ErlangFileDescriptor {
  @Attribute("path")
  public String myErlangModulePath;
  @Tag("dependencies")
  @AbstractCollection(surroundWithTag = false, elementTag = "dependency")
  public List<String> myDependencies = ContainerUtil.newArrayList();
}

<code block>


package org.intellij.erlang.jps.builder;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.jps.builders.BuildRootDescriptor;
import org.jetbrains.jps.builders.BuildTarget;

import java.io.File;
import java.io.FileFilter;

public class ErlangSourceRootDescriptor extends BuildRootDescriptor {
  private File myRoot;
  private final ErlangTarget myErlangTarget;
  private boolean myTests;

  public ErlangSourceRootDescriptor(File root, ErlangTarget erlangTarget, boolean isTests) {
    myRoot = root;
    myErlangTarget = erlangTarget;
    myTests = isTests;
  }

  @Override
  public String getRootId() {
    return myRoot.getAbsolutePath();
  }

  @Override
  public File getRootFile() {
    return myRoot;
  }

  @Override
  public BuildTarget<?> getTarget() {
    return myErlangTarget;
  }

  @NotNull
  @Override
  public FileFilter createFileFilter() {
    return new FileFilter() {
      @Override
      public boolean accept(@NotNull File file) {
        String name = file.getName();
        return name.endsWith(".erl") ||
          name.endsWith(".app") ||
          name.endsWith(".app.src");
      }
    };
  }

  public boolean isTests() {
    return myTests;
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.compiler.impl.ModuleCompileScope;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.CompileScope;
import com.intellij.openapi.compiler.CompilerMessage;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleManager;
import com.intellij.openapi.module.ModuleType;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.projectRoots.impl.SdkConfigurationUtil;
import com.intellij.openapi.roots.CompilerModuleExtension;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.openapi.roots.ProjectRootManager;
import com.intellij.openapi.util.SystemInfo;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.testFramework.CompilerTester;
import com.intellij.testFramework.PlatformTestCase;
import com.intellij.testFramework.PsiTestUtil;
import com.intellij.util.ArrayUtil;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.facet.ErlangFacet;
import org.intellij.erlang.module.ErlangModuleType;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.model.java.JavaSourceRootType;

import java.io.File;
import java.io.IOException;
import java.util.*;


public abstract class ErlangCompilationTestBase extends PlatformTestCase {
  public static final String SDK_PATH = "/usr/lib/erlang/";
  protected CompilationRunner myCompilationRunner;

  public ErlangCompilationTestBase() {
    assertTrue("Unsupported OS.", SystemInfo.isLinux);
  }

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    myCompilationRunner = new CompilationRunner(myModule);
    ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Object, Exception>() {
      @Nullable
      @Override
      public Object compute() throws Exception {
        Sdk sdk = SdkConfigurationUtil.createAndAddSDK(SDK_PATH, ErlangSdkType.getInstance());
        ProjectRootManager.getInstance(myProject).setProjectSdk(sdk);
        addSourceRoot(myModule, "src", false);
        addSourceRoot(myModule, "tests", true);
        ErlangFacet.createFacet(myModule);
        return null;
      }
    });
  }

  @Override
  protected ModuleType getModuleType() {
    return ErlangModuleType.getInstance();
  }

  @Override
  protected void tearDown() throws Exception {
    myCompilationRunner.tearDown();
    super.tearDown();
  }

  @Override
  protected boolean isRunInWriteAction() {
    return false;
  }

  protected Module createModuleInOwnDirectoryWithSourceAndTestRoot(final String moduleName) throws Exception {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Module, IOException>() {
      @Override
      public Module compute() throws IOException {
        Module module = createModuleInDirectory(moduleName);
        ErlangFacet.createFacet(module);
        addSourceRoot(module, "src", false);
        addSourceRoot(module, "tests", true);
        return module;
      }
    });
  }

  @NotNull
  private Module createModuleInDirectory(String moduleName) throws IOException {
    VirtualFile baseDir = VfsUtil.createDirectoryIfMissing(myProject.getBaseDir(), moduleName);
    File moduleFile = new File(FileUtil.toSystemDependentName(baseDir.getPath()), moduleName + ".iml");
    FileUtil.createIfDoesntExist(moduleFile);
    myFilesToDelete.add(moduleFile);
    VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(moduleFile);
    assertNotNull(virtualFile);
    return ModuleManager.getInstance(myProject).newModule(virtualFile.getPath(), ErlangModuleType.getInstance().getId());
  }

  private CompileScope createModulesCompileScope(Module[] modules) {
    return new ModuleCompileScope(myProject, modules, false);
  }

  protected static VirtualFile addTestFile(Module module, String relativePath, String content) throws IOException {
    return addFile(module, relativePath, content, true);
  }

  protected static VirtualFile addSourceFile(Module module, String relativePath, String content) throws IOException {
    return addFile(module, relativePath, content, false);
  }

  protected static VirtualFile addFile(final Module module,
                                       final String relativePath,
                                       final String content,
                                       final boolean toTests) throws IOException {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        JavaSourceRootType rootType = toTests ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE;
        List<VirtualFile> sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots(rootType);
        VirtualFile sourceDir = ContainerUtil.getFirstItem(sourceRoots);
        assertNotNull(sourceDir);
        VirtualFile sourceFile = sourceDir.createChildData(ErlangCompilationTestBase.class, relativePath);
        VfsUtil.saveText(sourceFile, content);
        return sourceFile;
      }
    });
  }

  protected static void addGlobalParseTransform(final Module module, final Collection<String> parseTransform) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
      @Override
      public void run() {
        ErlangFacet erlangFacet = ErlangFacet.getFacet(module);
        assertNotNull(erlangFacet);
        erlangFacet.getConfiguration().addParseTransforms(parseTransform);
      }
    });
  }

  protected static void assertSourcesCompiled(@NotNull Module module, boolean tests) {
    String[] sources = getSourceFiles(module, tests);
    assertContains(getOutputDirectory(module, tests), ContainerUtil.map2Array(sources, String.class, new Function<String, String>() {
      @Override
      public String fun(String source) {
        return getExpectedOutputFileName(source);
      }
    }));
  }

  protected static void assertContains(@Nullable VirtualFile parentPath, String... fileNames) {
    assertNotNull(parentPath);
    List<String> actual = getChildrenNames(parentPath);
    assertUnorderedElementsAreEqual(actual, fileNames);
  }

  protected static <T> void assertUnorderedElementsAreEqual(Collection<T> actual, T... expected) {
    assertUnorderedElementsAreEqual(actual, Arrays.asList(expected));
  }

  protected static <T> void assertUnorderedElementsAreEqual(Collection<T> actual, Collection<T> expected) {
    assertEquals(ContainerUtil.newHashSet(expected), ContainerUtil.newHashSet(actual));
  }

  protected static File getOutputFile(Module module, VirtualFile sourceFile, boolean isTest) {
    VirtualFile outputDirectory = getOutputDirectory(module, isTest);
    assertNotNull(outputDirectory);
    return new File(outputDirectory.getCanonicalPath(), getExpectedOutputFileName(sourceFile.getName()));
  }

  @NotNull
  private static VirtualFile addSourceRoot(@NotNull Module module,
                                           @NotNull String sourceRootName,
                                           boolean isTestSourceRoot) throws IOException {
    VirtualFile moduleFile = module.getModuleFile();
    assertNotNull(moduleFile);
    PsiTestUtil.addContentRoot(module, moduleFile.getParent());
    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();
    assertSize(1, contentRoots);

    VirtualFile sourceDir = contentRoots[0].createChildDirectory(ErlangCompilationTestBase.class, sourceRootName);
    PsiTestUtil.addSourceRoot(module, sourceDir, isTestSourceRoot);
    return sourceDir;
  }

  @NotNull
  private static String[] getSourceFiles(@NotNull Module module, boolean isTestSources) {
    List<VirtualFile> sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots(JavaSourceRootType.SOURCE);
    if (isTestSources) {
      List<VirtualFile> testRoots = ModuleRootManager.getInstance(module).getSourceRoots(JavaSourceRootType.TEST_SOURCE);
      sourceRoots = ContainerUtil.concat(sourceRoots, testRoots);
    }
    List<String> result = ContainerUtil.concat(ContainerUtil.mapNotNull(sourceRoots, new Function<VirtualFile, List<String>>() {
      @Override
      public List<String> fun(VirtualFile root) {
        return getChildrenNames(root);
      }
    }));
    return ArrayUtil.toStringArray(result);
  }

  @Nullable
  private static VirtualFile getOutputDirectory(@NotNull Module module, boolean isTest) {
    CompilerModuleExtension instance = CompilerModuleExtension.getInstance(module);
    assertNotNull(instance);
    return isTest ? instance.getCompilerOutputPathForTests() : instance.getCompilerOutputPath();
  }

  @NotNull
  private static String getExpectedOutputFileName(@NotNull String relativePath) {
    String name = FileUtil.getNameWithoutExtension(new File(relativePath));
    CharSequence extension = FileUtilRt.getExtension(relativePath);
    if ("erl".equals(extension)) {
      return name + ".beam";
    }
    if ("app".equals(extension) || "app.src".equals(extension)) {
      return name + ".app";
    }
    return relativePath;
  }

  @NotNull
  private static List<String> getChildrenNames(VirtualFile root) {
    return ContainerUtil.mapNotNull(root.getChildren(), new Function<VirtualFile, String>() {
      @Override
      public String fun(VirtualFile virtualFile) {
        return virtualFile.getName();
      }
    });
  }

  protected class CompilationRunner {
    private CompileScope myScope;
    private CompilerTester myTester;

    CompilationRunner(@NotNull Module... moduleNames) throws Exception {
      this(createModulesCompileScope(moduleNames));
    }

    CompilationRunner(@NotNull CompileScope scope) throws Exception {
      myScope = scope;
      myTester = new CompilerTester(myProject, Arrays.asList(scope.getAffectedModules()));
    }

    public void compile() {
      List<CompilerMessage> messages = myTester.make(myScope);
      for (CompilerMessage message : messages) {
        switch (message.getCategory()) {
          case ERROR:
            fail(message.getMessage());
            break;
          case WARNING:
            LOG.warn(message.getMessage());
            break;
          case INFORMATION:
            LOG.info(message.getMessage());
            break;
          case STATISTICS:
            LOG.info(message.getMessage());
            break;
          default:
            throw new AssertionError();
        }
      }
    }

    public void touch(@NotNull VirtualFile file) throws IOException {
      myTester.touch(file);
    }

    public void tearDown() {
      myTester.tearDown();
    }
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.module.ModuleType;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.testFramework.ModuleTestCase;
import com.intellij.testFramework.PsiTestUtil;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.jps.builder.ErlangFileDescriptor;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrderDescriptor;
import org.intellij.erlang.module.ErlangModuleType;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.io.IOException;
import java.util.List;

public class ErlangDependenciesResolutionTest extends ModuleTestCase {
  @Override
  protected void setUp() throws Exception {
    super.setUp();
    setUpModule();
    String sourceDirectoryPath = getSourceDirectoryPath();
    if (directoryExists(sourceDirectoryPath)) {
      setUpSourcePath(sourceDirectoryPath);
    }
    String testsDirectoryPath = getTestsDirectoryPath();
    if (directoryExists(testsDirectoryPath)) {
      setUpTestsPath(testsDirectoryPath);
    }
  }

  @Override
  protected ModuleType getModuleType() {
    return ErlangModuleType.getInstance();
  }

  private void setUpSourcePath(String sourcePath) throws IOException {
    doSetUpSourcePath(sourcePath, false);
  }

  private void setUpTestsPath(String sourcePath) throws IOException {
    doSetUpSourcePath(sourcePath, true);
  }

  private void doSetUpSourcePath(final String sourcePath, boolean isTestSource) throws IOException {
    final String sourceDirectoryName = isTestSource ? "test" : "src";
    final VirtualFile moduleFile = myModule.getModuleFile();
    assertNotNull(moduleFile);
    VirtualFile moduleSourceDir = ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        VirtualFile moduleSourceDir = VfsUtil.createDirectoryIfMissing(moduleFile.getParent(), sourceDirectoryName);
        FileUtil.copyDirContent(new File(sourcePath), new File(moduleSourceDir.getPath()));
        VfsUtil.markDirtyAndRefresh(false, true, true, moduleSourceDir);
        return moduleSourceDir;
      }
    });
    PsiTestUtil.addSourceRoot(myModule, moduleSourceDir, isTestSource);
  }

  private String getSourceDirectoryPath() {
    return getTestDataRoot() + "src";
  }

  private String getTestsDirectoryPath() {
    return getTestDataRoot() + "test";
  }

  private String getTestDataRoot() {
    return "testData/compilation/" + getTestName(false) + "/";
  }

  private static boolean directoryExists(String dirPath) {
    File dir = new File(dirPath);
    return dir.exists() && dir.isDirectory();
  }

  public void testCyclicDependency() {
    try {
      ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
      fail("Expected a cyclic dependency exception to be thrown.");
    } catch (ErlangPrepareDependenciesCompileTask.CyclicDependencyFoundException ignored) {
    }
  }

  public void testDependenciesAreCompiledFirst() throws Exception {
    ErlangModuleBuildOrderDescriptor moduleBuildOrder = ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
    assertSameErlangModules(moduleBuildOrder.myOrderedErlangModulePaths, "parse_transform1", "parse_transform2", "behaviour1", "module1");
  }

  public void testTestsDependency() throws Exception {
    ErlangModuleBuildOrderDescriptor moduleBuildOrder = ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
    assertSameErlangModules(moduleBuildOrder.myOrderedErlangModulePaths, "src_parse_transform");
    assertSameErlangModules(moduleBuildOrder.myOrderedErlangTestModulePaths, "test_parse_transform", "test");
  }

  private static void assertSameErlangModules(List<ErlangFileDescriptor> moduleDescriptors, String... expectedModules) {
    List<String> actualModules = ContainerUtil.map(getModulePaths(moduleDescriptors), new Function<String, String>() {
      @Override
      public String fun(String path) {
        return FileUtil.getNameWithoutExtension(new File(path));
      }
    });
    assertOrderedEquals(actualModules, expectedModules);
  }
  @NotNull
  private static List<String> getModulePaths(List<ErlangFileDescriptor> buildOrder) {
    return ContainerUtil.mapNotNull(buildOrder, new Function<ErlangFileDescriptor, String>() {
      @Override
      public String fun(ErlangFileDescriptor erlangFileDescriptor) {
        return erlangFileDescriptor.myErlangModulePath;
      }
    });
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.util.Pair;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;

import java.util.List;

class ErlangModuleTextGenerator {
  private ErlangModuleTextGenerator() {
  }

  @NotNull
  public static ErlangModuleTextBuilder module(@NotNull String moduleName) {
    return new ErlangModuleTextBuilder(moduleName);
  }

  @NotNull
  public static ParseTransformBuilder pt(@NotNull String moduleName) {
    return new ParseTransformBuilder(moduleName);
  }

  @NotNull
  public static BehaviourBuilder behaviour(@NotNull String moduleName) {
    return new BehaviourBuilder(moduleName);
  }

  static class ErlangModuleTextBuilder {
    private final String myModuleName;
    private final List<Pair<String, Integer>> myExports = ContainerUtil.newArrayList();
    private final List<BehaviourBuilder> myBehaviours = ContainerUtil.newArrayList();
    private final List<String> myParseTransforms = ContainerUtil.newArrayList();

    public ErlangModuleTextBuilder(@NotNull String moduleName) {
      myModuleName = moduleName;
    }

    public String getModuleName() {
      return myModuleName;
    }

    public ErlangModuleTextBuilder pt(@NotNull String moduleName) {
      myParseTransforms.add(moduleName);
      return this;
    }

    public ErlangModuleTextBuilder behaviour(@NotNull BehaviourBuilder behaviour) {
      myBehaviours.add(behaviour);
      myExports.addAll(behaviour.myCallbacks);
      return this;
    }

    @NotNull
    public String build() {
      StringBuilder builder = new StringBuilder();
      appendModule(builder);
      appendBehaviour(builder);
      appendParseTransforms(builder);
      appendExports(builder);
      build(builder);
      return builder.toString();
    }

    protected void build(@NotNull StringBuilder builder) {
      appendFunctions(builder);
    }

    @NotNull
    protected static <T> StringBuilder commaSeparated(@NotNull StringBuilder sb,
                                                      @NotNull List<T> items,
                                                      @NotNull ItemFormatter<T> formatter) {
      String separator = ", ";
      for (T item : items) {
        formatter.format(sb, item).append(separator);
      }
      sb.setLength(items.isEmpty() ? sb.length() : sb.length() - separator.length());
      return sb;
    }

    private void appendFunctions(@NotNull StringBuilder builder) {
      for (Pair<String, Integer> functionEntry : myExports) {
        appendFunction(builder, functionEntry.first, functionEntry.second);
      }
    }

    private void appendExports(@NotNull StringBuilder builder) {
      if (myExports.isEmpty()) return;

      builder.append("-export([");
      commaSeparated(builder, myExports, new ItemFormatter<Pair<String, Integer>>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Pair<String, Integer> export) {
          return sb.append(export.first).append("/").append(export.second);
        }
      });
      builder.append("]).\n");
    }

    private void appendModule(@NotNull StringBuilder builder) {
      builder.append("-module(").append(myModuleName).append(").\n");
    }

    private void appendBehaviour(@NotNull StringBuilder builder) {
      for (BehaviourBuilder behaviour : myBehaviours) {
        builder.append("-behaviour(").append(behaviour.getModuleName()).append(").\n");
      }
    }

    private static void appendFunction(@NotNull StringBuilder builder, @NotNull String functionName, int arity) {
      List<Integer> argumentIndices = ContainerUtil.newArrayListWithCapacity(arity);
      for (int i = 0; i < arity; i++) {
        argumentIndices.add(i);
      }

      builder.append(functionName).append("(");
      commaSeparated(builder, argumentIndices, new ItemFormatter<Integer>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Integer argumentIdx) {
          return sb.append("_Arg").append(argumentIdx);
        }
      });
      builder.append(") -> ok.\n");
    }

    private void appendParseTransforms(@NotNull StringBuilder builder) {
      if (myParseTransforms.isEmpty()) return;

      builder.append("-compile([");
      commaSeparated(builder, myParseTransforms, new ItemFormatter<String>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull String pt) {
          return sb.append("{parse_transform, ").append(pt).append("}");
        }
      });
      builder.append("]).\n");
    }

    protected interface ItemFormatter<T> {
      @NotNull
      StringBuilder format(@NotNull StringBuilder sb, @NotNull T item);
    }
  }

  static class ParseTransformBuilder extends ErlangModuleTextBuilder {
    public ParseTransformBuilder(@NotNull String moduleName) {
      super(moduleName);
    }

    @Override
    protected void build(@NotNull StringBuilder builder) {
      createTransform(builder);
      super.build(builder);
    }

    private static void createTransform(@NotNull StringBuilder builder) {
      builder.append("-export([parse_transform/2]).\n");
      builder.append("parse_transform(Forms, _Options) -> Forms.\n");
    }
  }

  static class BehaviourBuilder extends ErlangModuleTextBuilder {
    private final List<Pair<String, Integer>> myCallbacks = ContainerUtil.newArrayList();

    public BehaviourBuilder(@NotNull String moduleName) {
      super(moduleName);
    }

    public BehaviourBuilder callback(@NotNull String name, int arity) {
      myCallbacks.add(Pair.createNonNull(name, arity));
      return this;
    }

    @Override
    protected void build(@NotNull StringBuilder builder) {
      builder.append("-export([behaviour_info/1]).\n");
      builder.append("behaviour_info(callbacks) ->[");
      commaSeparated(builder, myCallbacks, new ItemFormatter<Pair<String, Integer>>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Pair<String, Integer> callback) {
          return sb.append("{").append(callback.first).append(", ").append(callback.second).append("}");
        }
      });
      builder.append("].\n");
      super.build(builder);
    }
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.module.Module;
import com.intellij.openapi.roots.ModuleRootModificationUtil;
import com.intellij.openapi.vfs.VirtualFile;

import java.io.File;
import java.util.Collections;

import static org.intellij.erlang.compilation.ErlangModuleTextGenerator.*;

public class ErlangModuleCompilationTest extends ErlangCompilationTestBase {
  public void testBuildSingleFile() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithBehaviourInSingleModule() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithParseTransformInDifferentModule() throws Exception {
    Module otherModule = createModuleInOwnDirectoryWithSourceAndTestRoot("other");
    ModuleRootModificationUtil.addDependency(myModule, otherModule);
    addSourceFile(otherModule, "parse_transform1.erl", pt("parse_transform1").build());
    addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    compileAndAssertOutput(myModule, otherModule);
  }

  public void testBuildWithParseTransformInSingleModule() throws Exception {
    addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testRebuildWithNewFile() throws Exception {
    final VirtualFile sourceFile = addSourceFile(myModule, "module1.erl", module("module1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    final File outputFile = getOutputFile(myModule, sourceFile, false);
    long modificationTime = outputFile.lastModified();
    addSourceFile(myModule, "module2.erl", module("module2").build());
    myCompilationRunner.compile();
    assertEquals(modificationTime, outputFile.lastModified());
  }

  public void testRebuildWithModificationWithoutDependencies() throws Exception {
    final VirtualFile sourceFile1 = addSourceFile(myModule, "module1.erl", module("module1").build());
    VirtualFile sourceFile2 = addSourceFile(myModule, "module2.erl", module("module2").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long lastModificationTime1 = lastOutputModificationTime(myModule, sourceFile1);
    long lastModificationTime2 = lastOutputModificationTime(myModule, sourceFile2);
    myCompilationRunner.touch(sourceFile2);
    myCompilationRunner.compile();
    assertEquals(lastModificationTime1, lastOutputModificationTime(myModule, sourceFile1));
    assertTrue(lastModificationTime2 != lastOutputModificationTime(myModule, sourceFile2));
  }

  public void testRebuildWithModificationParseTransform() throws Exception {
    VirtualFile parseTransformSourceFile = addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long parseTransformModificationTime = lastOutputModificationTime(myModule, parseTransformSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(parseTransformSourceFile);
    myCompilationRunner.compile();
    assertTrue(parseTransformModificationTime != lastOutputModificationTime(myModule, parseTransformSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testRebuildWithModificationBehaviour() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    VirtualFile behaviourSourceFile = addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long behaviourModificationTime = lastOutputModificationTime(myModule, behaviourSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(behaviourSourceFile);
    myCompilationRunner.compile();
    assertTrue(behaviourModificationTime != lastOutputModificationTime(myModule, behaviourSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testRebuildWithModificationBehaviourAndUnchangeableParseTransform() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    VirtualFile behaviourSourceFile = addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    VirtualFile parseTransformSourceFile = addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long behaviourModificationTime = lastOutputModificationTime(myModule, behaviourSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    long parseTransformModificationTime = lastOutputModificationTime(myModule, parseTransformSourceFile);
    myCompilationRunner.touch(behaviourSourceFile);
    myCompilationRunner.compile();
    assertEquals(parseTransformModificationTime, lastOutputModificationTime(myModule, parseTransformSourceFile));
    assertTrue(behaviourModificationTime != lastOutputModificationTime(myModule, behaviourSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testBuildWithTestSource() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    addTestFile(myModule, "test1.erl", module("test1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, true);
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithGlobalParseTransform() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    Module otherModule = createModuleInOwnDirectoryWithSourceAndTestRoot("other");
    addSourceFile(otherModule, "parse_transform1.erl", pt("parse_transform1").build());
    addGlobalParseTransform(myModule, Collections.singleton("parse_transform1"));
    ModuleRootModificationUtil.addDependency(myModule, otherModule);
    compileAndAssertOutput(myModule, otherModule);
  }

  private void compileAndAssertOutput(Module... modules) throws Exception {
    CompilationRunner compilationRunner = new CompilationRunner(modules);
    try {
      compilationRunner.compile();
      for (Module module : modules) {
        assertSourcesCompiled(module, false);
      }
    }
    finally {
      compilationRunner.tearDown();
    }
  }

  private static long lastOutputModificationTime(Module module, VirtualFile sourceFile) {
    return getOutputFile(module, sourceFile, false).lastModified();
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.compiler.server.BuildManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.CompileContext;
import com.intellij.openapi.compiler.CompileTask;
import com.intellij.openapi.compiler.CompilerMessageCategory;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.util.JDOMUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.util.Function;
import com.intellij.util.ObjectUtils;
import com.intellij.util.SystemProperties;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.graph.DFSTBuilder;
import com.intellij.util.graph.GraphGenerator;
import com.intellij.util.xmlb.SkipDefaultValuesSerializationFilters;
import com.intellij.util.xmlb.XmlSerializationException;
import com.intellij.util.xmlb.XmlSerializer;
import org.intellij.erlang.configuration.ErlangCompilerSettings;
import org.intellij.erlang.facet.ErlangFacet;
import org.intellij.erlang.jps.builder.ErlangBuilder;
import org.intellij.erlang.jps.builder.ErlangFileDescriptor;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrderDescriptor;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrders;
import org.intellij.erlang.psi.ErlangFile;
import org.intellij.erlang.psi.impl.ErlangPsiImplUtil;
import org.intellij.erlang.utils.ErlangModulesUtil;
import org.jdom.Document;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.TestOnly;

import java.io.File;
import java.io.IOException;
import java.util.*;


public class ErlangPrepareDependenciesCompileTask implements CompileTask {
  @Override
  public boolean execute(final CompileContext context) {
    Project project = context.getProject();
    if (ErlangCompilerSettings.getInstance(project).isUseRebarCompilerEnabled()) {

      return true;
    }

    File projectSystemDirectory = BuildManager.getInstance().getProjectSystemDirectory(project);
    if (projectSystemDirectory == null) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }

    ErlangModuleBuildOrders buildOrders = ApplicationManager.getApplication().runReadAction(new Computable<ErlangModuleBuildOrders>() {
      @Nullable
      @Override
      public ErlangModuleBuildOrders compute() {
        return getModuleBuildOrders(context);
      }
    });
    if (buildOrders == null) {
      return false; 
    }
    try {
      Document serializedBuildOrders = new Document(XmlSerializer.serialize(buildOrders, new SkipDefaultValuesSerializationFilters()));
      File file = new File(projectSystemDirectory, ErlangBuilder.DEPENDENCIES_CONFIG_FILE_PATH);

      file.getParentFile().mkdirs();
      JDOMUtil.writeDocument(serializedBuildOrders, file, SystemProperties.getLineSeparator());
    }
    catch (XmlSerializationException e) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }
    catch (IOException e) {
      addPrepareDependenciesFailedMessage(context);
      return true;
    }

    return true;
  }

  public static void addPrepareDependenciesFailedMessage(CompileContext context) {
    context.addMessage(CompilerMessageCategory.WARNING, "Failed to submit dependencies info to compiler. Parse transform failures may occur.", null, -1, -1);
  }

  @TestOnly
  static ErlangModuleBuildOrderDescriptor getModuleBuildOrder(Module module) throws CyclicDependencyFoundException {
    return getModuleBuildOrderInner(module);
  }

  @Nullable
  private static ErlangModuleBuildOrders getModuleBuildOrders(CompileContext context) {
    Module[] modulesToCompile = context.getCompileScope().getAffectedModules();
    ErlangModuleBuildOrders buildOrders = new ErlangModuleBuildOrders(modulesToCompile.length);
    try {
      for (Module module : modulesToCompile) {
        buildOrders.myModuleBuildOrderDescriptors.add(getModuleBuildOrderInner(module));
      }
    }
    catch (CyclicDependencyFoundException e) {
      context.addMessage(CompilerMessageCategory.ERROR, "Cyclic erlang module dependency detected. Check parse_transform usages.", null, -1, -1);
      return null;
    }
    return buildOrders;
  }

  private static ErlangModuleBuildOrderDescriptor getModuleBuildOrderInner(Module module) throws CyclicDependencyFoundException {
    ErlangModuleBuildOrderDescriptor buildOrder = new ErlangModuleBuildOrderDescriptor();
    buildOrder.myModuleName = module.getName();
    buildOrder.myOrderedErlangFilePaths = getTopologicallySortedErlangFilesPaths(module, false);
    buildOrder.myOrderedErlangTestFilePaths = getTopologicallySortedErlangFilesPaths(module, true);
    return buildOrder;
  }

  @NotNull
  private static List<String> getGlobalParseTransform(@NotNull Module module) {
    ErlangFacet erlangFacet = ErlangFacet.getFacet(module);
    return erlangFacet != null ? erlangFacet.getConfiguration().getParseTransforms() : ContainerUtil.<String>emptyList();
  }

  @NotNull
  private static List<ErlangFileDescriptor> getTopologicallySortedErlangFilesPaths(@NotNull Module module,
                                                                                   boolean onlyTestModules) throws CyclicDependencyFoundException {
    final ErlangFilesDependencyGraph semiGraph = ErlangFilesDependencyGraph.createSemiGraph(module, onlyTestModules);
    DFSTBuilder<String> builder = new DFSTBuilder<String>(GraphGenerator.create(semiGraph));
    builder.buildDFST();
    if (!builder.isAcyclic()) {
      throw new CyclicDependencyFoundException();
    }
    return ContainerUtil.map(builder.getSortedNodes(), new Function<String, ErlangFileDescriptor>() {
      @Override
      public ErlangFileDescriptor fun(String filePath) {
        List<String> dependencies = semiGraph.getDependencies(filePath);
        return new ErlangFileDescriptor(filePath, dependencies);
      }
    });
  }

  private static class ErlangFilesDependencyGraph implements GraphGenerator.SemiGraph<String> {

    private final Map<String, String> myNamesToPathsMap = ContainerUtil.newHashMap();
    private final Map<String, List<String>> myPathsToDependenciesMap = ContainerUtil.newHashMap();
    private final PsiManager myPsiManager;

    private ErlangFilesDependencyGraph(@NotNull Collection<VirtualFile> erlangModules,
                                       @NotNull Collection<VirtualFile> erlangHeaders,
                                       @NotNull List<String> globalParseTransforms,
                                       @NotNull PsiManager psiManager) {
      myPsiManager = psiManager;
      buildNamesMap(erlangModules);
      buildForHeaders(erlangHeaders);
      buildForModules(erlangModules, globalParseTransforms);
    }

    @NotNull
    public static ErlangFilesDependencyGraph createSemiGraph(@NotNull Module module,
                                                             boolean onlyTestModules) {
      Collection<VirtualFile> erlangModules = ErlangModulesUtil.getErlangModuleFiles(module, onlyTestModules);
      Collection<VirtualFile> erlangHeaders = ErlangModulesUtil.getErlangHeaderFiles(module, onlyTestModules);

      return new ErlangFilesDependencyGraph(erlangModules, erlangHeaders, getGlobalParseTransform(module), PsiManager.getInstance(module.getProject()));
    }

    private void buildForModules(@NotNull Collection<VirtualFile> erlangModules,
                                 @NotNull List<String> globalParseTransforms) {
      for (VirtualFile erlangModule : erlangModules) {
        Set<String> dependencies = ContainerUtil.newHashSet();
        ErlangFile erlangFile = getErlangFile(erlangModule);
        addDeclaredDependencies(erlangFile, dependencies);
        dependencies.addAll(getPathsFromNames(globalParseTransforms));
        myPathsToDependenciesMap.put(erlangModule.getPath(), ContainerUtil.newArrayList(dependencies));
      }
    }

    @NotNull
    private ErlangFile getErlangFile(@NotNull VirtualFile virtualFile) {
      PsiFile psiFile = myPsiManager.findFile(virtualFile);
      ErlangFile erlangFile = ObjectUtils.tryCast(psiFile, ErlangFile.class);
      assert erlangFile != null;
      return erlangFile;
    }

    private void buildForHeaders(@NotNull Collection<VirtualFile> erlangHeaders) {
      for (VirtualFile header : erlangHeaders) {
        Set<String> dependencies = ContainerUtil.newHashSet();
        ErlangFile erlangFile = getErlangFile(header);
        addDeclaredDependencies(erlangFile, dependencies);
        myPathsToDependenciesMap.put(header.getPath(), ContainerUtil.newArrayList(dependencies));
      }
    }

    private void addDeclaredDependencies(@NotNull ErlangFile erlangModule, @NotNull Set<String> dependencies) {
      dependencies.addAll(getDeclaredParseTransformPaths(erlangModule));
      dependencies.addAll(getDeclaredBehaviourPaths(erlangModule));
      dependencies.addAll(getDeclaredIncludePaths(erlangModule));
    }

    @NotNull
    private static List<String> getDeclaredIncludePaths(@NotNull ErlangFile file) {
      return ContainerUtil.mapNotNull(ErlangPsiImplUtil.getDirectlyIncludedFiles(file), new Function<ErlangFile, String>() {
        @Nullable
        @Override
        public String fun(ErlangFile erlangFile) {
          VirtualFile virtualFile = erlangFile.getVirtualFile();
          return virtualFile != null ? virtualFile.getPath() : null;
        }
      });
    }

    @NotNull
    private List<String> getDeclaredBehaviourPaths(@NotNull ErlangFile erlangModule) {
      Set<String> behaviours = ContainerUtil.newHashSet();
      ErlangPsiImplUtil.addDeclaredBehaviourModuleNames(erlangModule, behaviours);
      return getPathsFromNames(behaviours);
    }

    @NotNull
    private List<String> getDeclaredParseTransformPaths(@NotNull ErlangFile erlangModule) {
      Set<String> pt = ContainerUtil.newHashSet();
      erlangModule.addDeclaredParseTransforms(pt);
      return getPathsFromNames(pt);
    }

    private void buildNamesMap(@NotNull Collection<VirtualFile> erlangModules) {
      for (VirtualFile erlangModule : erlangModules) {
        myNamesToPathsMap.put(erlangModule.getNameWithoutExtension(), erlangModule.getPath());
      }
    }

    @NotNull
    private List<String> getPathsFromNames(@NotNull Collection<String> erlangModuleNames) {
      return ContainerUtil.mapNotNull(erlangModuleNames, new Function<String, String>() {
        @Override
        public String fun(String name) {
          return myNamesToPathsMap.get(name);
        }
      });
    }

    @Override
    public Collection<String> getNodes() {
      return myPathsToDependenciesMap.keySet();
    }

    @Override
    public Iterator<String> getIn(String filePath) {
      return myPathsToDependenciesMap.get(filePath).iterator();
    }

    @NotNull
    public List<String> getDependencies(@NotNull String filePath) {
      List<String> dependencies = myPathsToDependenciesMap.get(filePath);
      assert dependencies != null;
      return dependencies;
    }
  }

  static class CyclicDependencyFoundException extends Exception {
    CyclicDependencyFoundException() {
    }
  }
}
<code block>


package org.intellij.erlang.utils;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.ModuleFileIndex;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.Processor;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.Convertor;
import org.intellij.erlang.ErlangFileType;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.psi.ErlangFile;
import org.intellij.erlang.psi.ErlangModule;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public final class ErlangModulesUtil {
  private ErlangModulesUtil() {
  }

  @NotNull
  public static GlobalSearchScope getModuleWithDependenciesScope(@NotNull Module module, boolean includeTests) {
    return GlobalSearchScope
      .moduleWithDependenciesAndLibrariesScope(module, includeTests)
      .intersectWith(GlobalSearchScope.moduleWithDependenciesScope(module));
  }

  @Nullable
  public static ErlangModule getErlangModule(@NotNull final Project project,
                                             @NotNull final String moduleName,
                                             @NotNull final GlobalSearchScope scope) {
    return ApplicationManager.getApplication().runReadAction(new Computable<ErlangModule>() {
      @Nullable
      @Override
      public ErlangModule compute() {
        return doGetErlangModule(project, moduleName, scope);
      }
    });
  }

  @Nullable
  public static ErlangFile getErlangModuleFile(@NotNull final Project project,
                                               @NotNull final String moduleName,
                                               @NotNull final GlobalSearchScope scope) {
    return ApplicationManager.getApplication().runReadAction(new Computable<ErlangFile>() {
      @Nullable
      @Override
      public ErlangFile compute() {
        ErlangModule module = doGetErlangModule(project, moduleName, scope);
        PsiFile containingFile = module != null ? module.getContainingFile() : null;
        return containingFile instanceof ErlangFile ? (ErlangFile) containingFile : null;
      }
    });
  }

  @Nullable
  private static ErlangModule doGetErlangModule(@NotNull Project project,
                                                @NotNull String moduleName,
                                                @NotNull GlobalSearchScope scope) {
    List<ErlangModule> modules = ErlangModuleIndex.getModulesByName(project, moduleName, scope);
    return ContainerUtil.getFirstItem(modules);
  }

  @NotNull
  public static Collection<ErlangFile> getErlangModules(@NotNull Project project) {
    HashSet<ErlangFile> erlangModules = new HashSet<ErlangFile>();
    for (Module module : ModuleManager.getInstance(project).getModules()) {
      addErlangFiles(module, false, erlangModules, ErlangFileType.MODULE);
    }
    return erlangModules;
  }

  @NotNull
  public static Collection<ErlangFile> getErlangModules(@NotNull Module module, boolean onlyTestModules) {
    return addErlangFiles(module, onlyTestModules, new HashSet<ErlangFile>(), ErlangFileType.MODULE);
  }

  @NotNull
  public static Collection<VirtualFile> getErlangHeaderFiles(@NotNull Module module, boolean onlyTestModules) {
    return addFiles(module, onlyTestModules, ContainerUtil.<VirtualFile>newHashSet(), ErlangFileType.HEADER);
  }

  @NotNull
  public static Collection<VirtualFile> getErlangModuleFiles(@NotNull Module module, boolean onlyTestModules) {
    return addFiles(module, onlyTestModules, ContainerUtil.<VirtualFile>newHashSet(), ErlangFileType.MODULE);
  }

  @NotNull
  private static Collection<ErlangFile> addErlangFiles(@NotNull Module module,
                                                       boolean onlyTestModules,
                                                       @NotNull Collection<ErlangFile> erlangModules,
                                                       @NotNull ErlangFileType type) {
    Processor<VirtualFile> filesCollector = getErlangModulesCollector(PsiManager.getInstance(module.getProject()), erlangModules, type);
    collectFiles(module, onlyTestModules, filesCollector);
    return erlangModules;
  }

  @NotNull
  private static Collection<VirtualFile> addFiles(@NotNull Module module,
                                                  boolean onlyTest,
                                                  @NotNull final Collection<VirtualFile> files,
                                                  @NotNull final ErlangFileType type) {
    Processor<VirtualFile> modulesCollector = new Processor<VirtualFile>() {
      @Override
      public boolean process(VirtualFile virtualFile) {
        if (virtualFile.getFileType() == type) {
          files.add(virtualFile);
        }
        return true;
      }
    };
    collectFiles(module, onlyTest, modulesCollector);
    return files;
  }

  private static void collectFiles(@NotNull Module module,
                                   boolean onlyTestModules,
                                   @NotNull Processor<VirtualFile> filesCollector) {
    ModuleRootManager rootManager = ModuleRootManager.getInstance(module);
    ModuleFileIndex moduleFileIndex = rootManager.getFileIndex();
    Convertor<VirtualFile, Boolean> sourceDirectoriesFilter = onlyTestModules ? getTestDirectoriesFilter(moduleFileIndex)
                                                                              : getSourceDirectoriesFilter(moduleFileIndex);

    for (VirtualFile sourceRoot : rootManager.getSourceRoots(onlyTestModules)) {
      VfsUtilCore.processFilesRecursively(sourceRoot, filesCollector, sourceDirectoriesFilter);
    }
  }
  @NotNull
  private static Convertor<VirtualFile, Boolean> getSourceDirectoriesFilter(@NotNull final ModuleFileIndex moduleFileIndex) {
    return new Convertor<VirtualFile, Boolean>() {
      @Override
      public Boolean convert(@NotNull VirtualFile dir) {
        return moduleFileIndex.isInSourceContent(dir);
      }
    };
  }

  @NotNull
  private static Convertor<VirtualFile, Boolean> getTestDirectoriesFilter(@NotNull final ModuleFileIndex moduleFileIndex) {
    return new Convertor<VirtualFile, Boolean>() {
      @Override
      public Boolean convert(@NotNull VirtualFile dir) {
        return moduleFileIndex.isInTestSourceContent(dir);
      }
    };
  }

  @Nullable
  private static Processor<VirtualFile> getErlangModulesCollector(@NotNull final PsiManager psiManager,
                                                                  @NotNull final Collection<ErlangFile> erlangFiles,
                                                                  @NotNull final ErlangFileType type) {
    return new Processor<VirtualFile>() {
      @Override
      public boolean process(@NotNull VirtualFile virtualFile) {
        if (virtualFile.getFileType() == type) {
          PsiFile psiFile = psiManager.findFile(virtualFile);
          if (psiFile instanceof ErlangFile) {
            erlangFiles.add((ErlangFile) psiFile);
          }
        }
        return true;
      }
    };
  }
}

<code block>


package org.intellij.erlang.psi.impl;

import com.intellij.codeInsight.completion.BasicInsertHandler;
import com.intellij.codeInsight.completion.InsertHandler;
import com.intellij.codeInsight.completion.InsertionContext;
import com.intellij.codeInsight.completion.PrioritizedLookupElement;
import com.intellij.codeInsight.completion.util.ParenthesesInsertHandler;
import com.intellij.codeInsight.lookup.LookupElement;
import com.intellij.codeInsight.lookup.LookupElementBuilder;
import com.intellij.execution.console.LanguageConsoleImpl;
import com.intellij.lang.ASTNode;
import com.intellij.navigation.ItemPresentation;
import com.intellij.openapi.application.AccessToken;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleUtilCore;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.patterns.PatternCondition;
import com.intellij.patterns.PsiElementPattern;
import com.intellij.psi.*;
import com.intellij.psi.formatter.FormatterUtil;
import com.intellij.psi.impl.ResolveScopeManager;
import com.intellij.psi.impl.source.resolve.reference.ReferenceProvidersRegistry;
import com.intellij.psi.impl.source.resolve.reference.impl.PsiMultiReference;
import com.intellij.psi.scope.PsiScopeProcessor;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.LocalSearchScope;
import com.intellij.psi.search.SearchScope;
import com.intellij.psi.search.searches.ReferencesSearch;
import com.intellij.psi.stubs.NamedStubBase;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.*;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.ErlangParserDefinition;
import org.intellij.erlang.ErlangStringLiteralEscaper;
import org.intellij.erlang.ErlangTypes;
import org.intellij.erlang.bif.ErlangBifDescriptor;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.completion.ErlangCompletionContributor;
import org.intellij.erlang.completion.QuoteInsertHandler;
import org.intellij.erlang.icons.ErlangIcons;
import org.intellij.erlang.index.ErlangApplicationIndex;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.parser.ErlangParserUtil;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.rebar.util.RebarConfigUtil;
import org.intellij.erlang.roots.ErlangIncludeDirectoryUtil;
import org.intellij.erlang.sdk.ErlangSdkRelease;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.intellij.erlang.sdk.ErlangSystemUtil;
import org.intellij.erlang.stubs.ErlangFunctionStub;
import org.intellij.erlang.stubs.ErlangIncludeLibStub;
import org.intellij.erlang.stubs.ErlangIncludeStub;
import org.intellij.erlang.stubs.ErlangTypeDefinitionStub;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.intellij.patterns.PlatformPatterns.psiElement;

public class ErlangPsiImplUtil {
  public static final Set<String> KNOWN_MACROS = ContainerUtil.set("MODULE", "MODULE_STRING", "FILE", "LINE", "MACHINE");
  public static final Set<String> BUILT_IN_TYPES = ContainerUtil.set(
    "any", "atom", "boolean", "byte", "char", "float", "integer", "iolist", "list", "maybe_improper_list", "mfa",
    "module", "neg_integer", "no_return", "node", "non_neg_integer", "none", "nonempty_string", "number", "pid", "port",
    "pos_integer", "ref", "string", "term", "timeout"
  );
  public static final Key<LanguageConsoleImpl> ERLANG_CONSOLE = Key.create("ERLANG_CONSOLE");

  private static Pattern ATOM_PATTERN = Pattern.compile("[a-z][a-zA-Z_@0-9]*");
  private static Pattern QUOTED_ATOM_NAME = Pattern.compile("(\\\\\\^.|\\\\.|[^'])*"); 

  private ErlangPsiImplUtil() {
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangQVar o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processor.execute(o, state);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangQVar o) {
    return new ErlangVariableReferenceImpl(o, TextRange.from(0, o.getTextLength()));
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangQAtom o) { 
    PsiReference[] referencesFromProviders = ReferenceProvidersRegistry.getReferencesFromProviders(o);
    PsiReference atomReference = createAtomReference(o);
    PsiReference[] psiReferences = atomReference == null ? referencesFromProviders : ArrayUtil.append(referencesFromProviders, atomReference);
    if (psiReferences.length == 0) return null;
    return new PsiMultiReference(psiReferences, o);
  }

  @Nullable
  private static PsiReference createAtomReference(@NotNull final ErlangQAtom o) {
    if (!standaloneAtom(o)) return null;
    return new PsiPolyVariantReferenceBase<ErlangQAtom>(o, TextRange.create(0, o.getTextLength())) {
      @NotNull
      @Override
      public ResolveResult[] multiResolve(boolean b) {
        return new ResolveResult[]{};
      }

      @Override
      public boolean isReferenceTo(PsiElement element) {
        return element instanceof ErlangQAtom && standaloneAtom(o) && Comparing.equal(element.getText(), getElement().getText());
      }

      @Override
      public PsiElement handleElementRename(String newName) throws IncorrectOperationException {
        renameQAtom(o, newName);
        return getElement();
      }

      @NotNull
      @Override
      public Object[] getVariants() { 
        return ArrayUtil.EMPTY_OBJECT_ARRAY;
      }
    };
  }

  public static boolean standaloneAtom(@NotNull ErlangQAtom o) {
    if (o.getAtom() == null) return false;
    PsiElement parent = o.getParent();
    return parent instanceof ErlangMaxExpression || parent instanceof ErlangAtomWithArityExpression ||
      (parent instanceof ErlangTypeRef || parent instanceof ErlangBitType) && !FormatterUtil.isFollowedBy(parent.getNode(), ErlangTypes.ERL_PAR_LEFT);
  }

  @NotNull
  public static Pair<List<ErlangTypedExpr>, List<ErlangQAtom>> getRecordFields(PsiElement element) {
    List<ErlangTypedExpr> result = ContainerUtil.newArrayListWithCapacity(0);
    List<ErlangQAtom> atoms = ContainerUtil.newArrayListWithCapacity(0);
    ErlangRecordExpression recordExpression = PsiTreeUtil.getParentOfType(element, ErlangRecordExpression.class);
    PsiReference reference = recordExpression != null ? recordExpression.getReferenceInternal() : null;
    PsiElement resolve = reference != null ? reference.resolve() : null;

    if (resolve == null && recordExpression != null) {
      ErlangMacros macros = recordExpression.getMacros();
      PsiReference macrosReference = macros != null ? macros.getReference() : null;
      PsiElement macroDefinition = macrosReference != null ? macrosReference.resolve() : null;
      if (macroDefinition instanceof ErlangMacrosDefinition) {
        ErlangMacrosBody body = ((ErlangMacrosDefinition) macroDefinition).getMacrosBody();
        final Ref<ErlangRecordRef> ref = Ref.create();
        if (body != null) {
          body.accept(new ErlangRecursiveVisitor() {
            @Override
            public void visitRecordRef(@NotNull ErlangRecordRef o) {
              ref.setIfNull(o);
            }
          });
        }

        if (!ref.isNull()) {
          PsiReference r = ref.get().getReference();
          PsiElement rr = r != null ? r.resolve() : null;
          if (rr instanceof ErlangRecordDefinition) {
            resolve = rr;
          }
        }
      }
    }

    if (resolve instanceof ErlangRecordDefinition) {
      ErlangTypedRecordFields typedRecordFields = ((ErlangRecordDefinition) resolve).getTypedRecordFields();
      if (typedRecordFields != null) {
        for (ErlangTypedExpr e : typedRecordFields.getTypedExprList()) {
          ErlangMacros macros = e.getQAtom().getMacros();
          if (macros == null) {
            result.add(e);
          }
          else {
            processRecordFields(macros, atoms);
          }
        }
        for (ErlangGenericFunctionCallExpression gc : typedRecordFields.getGenericFunctionCallExpressionList()) {
          ErlangQAtom qAtom = ContainerUtil.getFirstItem(gc.getQAtomList());
          ErlangMacros macros = qAtom == null ? null : qAtom.getMacros();
          if (macros != null) {
            processRecordFields(macros, atoms);
          }
        }
      }
    }

    return Pair.create(result, atoms);
  }


  private static void processRecordFields(@NotNull ErlangMacros macros, @NotNull List<ErlangQAtom> atoms) {
    PsiReference psiReference = macros.getReference();
    PsiElement macrosDefinition = psiReference != null ? psiReference.resolve() : null;
    if (macrosDefinition instanceof ErlangMacrosDefinition) {
      ErlangMacrosBody macrosBody = ((ErlangMacrosDefinition) macrosDefinition).getMacrosBody();
      List<ErlangExpression> expressionList = macrosBody != null ? macrosBody.getExpressionList() : ContainerUtil.<ErlangExpression>emptyList();
      for (ErlangExpression ee : expressionList) {
        if (ee instanceof ErlangMaxExpression) {
          ErlangQAtom qAtom = ((ErlangMaxExpression) ee).getQAtom();
          ContainerUtil.addIfNotNull(atoms, qAtom);
        }
        else if (ee instanceof ErlangAssignmentExpression) {
          ErlangExpression left = ((ErlangAssignmentExpression) ee).getLeft();
          if (left instanceof ErlangMaxExpression) {
            ErlangQAtom qAtom = ((ErlangMaxExpression) left).getQAtom();
            ContainerUtil.addIfNotNull(atoms, qAtom);
          }
        }
        else if (ee instanceof ErlangFunctionCallExpression) {
          ErlangMacros m = ((ErlangFunctionCallExpression) ee).getQAtom().getMacros();
          if (m != null) {
            processRecordFields(m, atoms);
          }
        }
      }
    }
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangRecordField o) {
    return getRecordFieldReference(o.getFieldNameAtom());
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFieldType o) {
    return getRecordFieldReference(o.getQAtom());
  }

  @Nullable
  private static PsiReference getRecordFieldReference(@Nullable ErlangQAtom atom) {
    if (atom == null) return null;
    return new ErlangQAtomBasedReferenceImpl<ErlangQAtom>(atom, getTextRangeForReference(atom), getNameIdentifier(atom).getText()) {
      @Override
      public PsiElement resolve() {
        Pair<List<ErlangTypedExpr>, List<ErlangQAtom>> recordFields = getRecordFields(myElement);
        for (ErlangTypedExpr field : recordFields.first) {
          if (field.getName().equals(myReferenceName)) return field;
        }
        for (ErlangQAtom qAtom : recordFields.second) {
          ErlangAtom aa = qAtom.getAtom();
          if (aa != null) {
            if (myReferenceName.equals(aa.getName())) return qAtom;
          }
        }
        return null;
      }

      @NotNull
      @Override
      public Object[] getVariants() {
        return ArrayUtil.EMPTY_OBJECT_ARRAY;
      }
    };
  }

  @Nullable
  public static PsiReference getReference(@NotNull final ErlangIncludeString o) {
    final PsiElement parent = o.getParent();
    if (o.getTextLength() >= 2) {
      return new PsiReferenceBase<PsiElement>(o, TextRange.from(1, o.getTextLength() - 2)) {
        @Override
        public PsiElement resolve() {
          ErlangFile file = (ErlangFile) o.getContainingFile();
          List<ErlangFile> files = parent instanceof ErlangInclude ? getDirectlyIncludedFiles((ErlangInclude) parent, file) : getDirectlyIncludedFiles((ErlangIncludeLib) parent, file);
          return ContainerUtil.getFirstItem(files);
        }

        @NotNull
        @Override
        public PsiElement handleElementRename(@NotNull String newName) throws IncorrectOperationException {
          PsiElement resolve = resolve();
          if (resolve instanceof ErlangFile) {
            PsiElement st;
            try {
              String fileName = ((ErlangFile) resolve).getName();
              String newIncludeString = StringUtil.unquoteString(o.getString().getText()).replace(fileName, newName);
              st = ErlangElementFactory.createStringFromText(o.getProject(), newIncludeString);
            } catch (Exception e) {
              st = null;
            }

            if (st != null) {
              o.getString().replace(st);
            }
          }
          return o;
        }

        @NotNull
        @Override
        public Object[] getVariants() {
          return ArrayUtil.EMPTY_OBJECT_ARRAY;
        }
      };
    }
    return null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFunctionCallExpression o) {
    PsiElement parent = o.getParent();
    ErlangModuleRef moduleReference = null;
    if (parent instanceof ErlangGlobalFunctionCallExpression) {
      moduleReference = ((ErlangGlobalFunctionCallExpression) parent).getModuleRef();
    }
    ErlangQAtom moduleAtom = moduleReference == null ? null : moduleReference.getQAtom();
    ErlangQAtom nameAtom = o.getQAtom();

    return new ErlangFunctionReferenceImpl<ErlangQAtom>(nameAtom, moduleAtom, o.getArgumentList().getExpressionList().size());
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangFunctionWithArity o) {
    ErlangQVar prevVar = PsiTreeUtil.getPrevSiblingOfType(o, ErlangQVar.class);
    if (prevVar != null) return null;
    ErlangModuleRef moduleReference = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    boolean isModule = isModule(moduleReference);
    if (moduleReference != null && moduleReference.getQAtom().getMacros() != null && !isModule) return null;
    ErlangQAtom moduleAtom = moduleReference == null ? null : moduleReference.getQAtom();

    ErlangQAtom nameAtom = o.getQAtom();
    PsiElement arity = o.getInteger();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(nameAtom, isModule ? null : moduleAtom, getArity(arity));
  }

  private static boolean isModule(@Nullable ErlangModuleRef moduleReference) {
    if (moduleReference == null) return false;
    return moduleReference.getQAtom().getText().equals("?MODULE");
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangExportFunction o) {
    PsiElement arity = o.getInteger();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(o.getQAtom(), null, getArity(arity));
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangImportFunction o) {
    ErlangImportDirective importDirective = PsiTreeUtil.getParentOfType(o, ErlangImportDirective.class);
    ErlangModuleRef moduleRef = importDirective != null ? importDirective.getModuleRef() : null;
    ErlangQAtom moduleRefQAtom = moduleRef != null ? moduleRef.getQAtom() : null;
    int arity = getArity(o);
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(o.getQAtom(), moduleRefQAtom, arity);
  }

  public static int getArity(@Nullable PsiElement arity) {
    return StringUtil.parseInt(arity == null ? "" : arity.getText(), -1);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangMacros o) {
    return getReference(o.getMacrosName());
  }

  @Nullable
  public static PsiReference getReference(@Nullable ErlangMacrosName o) {
    return o != null ? new ErlangMacrosReferenceImpl<ErlangMacrosName>(o) : null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangTypeRef o) {
    return getModuleReference(o, o.getQAtom());
  }

  @NotNull
  private static PsiReference getModuleReference(ErlangCompositeElement o, @NotNull ErlangQAtom atom) {
    ErlangModuleRef moduleRef = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    return new ErlangTypeReferenceImpl<ErlangQAtom>(atom, moduleRef);
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangExportType o) {
    return getModuleReference(o, o.getQAtom());
  }

  @SuppressWarnings("unchecked")
  public static boolean inDefinitionBeforeArgumentList(PsiElement psiElement) {
    return inArgumentDefinition(psiElement) && inArgumentList(psiElement) && PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentDefinition.class, ErlangArgumentList.class) instanceof ErlangArgumentDefinition;
  }

  public static boolean inArgumentDefinition(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentDefinition.class) != null;
  }

  @SuppressWarnings("unchecked")
  public static boolean inArgumentList(PsiElement psiElement) {
    ErlangArgumentList argList = PsiTreeUtil.getParentOfType(psiElement, ErlangArgumentList.class, true,
      ErlangFunctionCallExpression.class, ErlangFunClause.class, ErlangListComprehension.class);
    PsiElement parent = argList != null ? argList.getParent() : null;
    return parent instanceof ErlangFunctionCallExpression && ((ErlangFunctionCallExpression) parent).getQAtom().getMacros() == null;
  }

  public static boolean inFunctionTypeArgument(PsiElement psiElement) {
    ErlangType topType = PsiTreeUtil.getParentOfType(psiElement, ErlangType.class);
    return PsiTreeUtil.getParentOfType(topType, ErlangFunTypeArguments.class) != null;
  }

  public static boolean inDefine(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangMacrosDefinition.class) != null;
  }

  public static boolean inMacroCallArguments(PsiElement psiElement) {
    PsiElement child = psiElement;
    ErlangFunctionCallExpression functionCall;
    while ((functionCall = PsiTreeUtil.getParentOfType(child, ErlangFunctionCallExpression.class, true)) != null) {
      boolean isMacroCall = functionCall.getQAtom().getMacros() != null;
      if (isMacroCall && PsiTreeUtil.isAncestor(functionCall.getArgumentList(), psiElement, true)) {
        return true;
      }
      child = functionCall;
    }
    return false;
  }

  public static boolean inCallback(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangCallbackSpec.class) != null;
  }

  public static boolean inRecordDefinition(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangRecordDefinition.class) != null;
  }

  public static boolean inAtomAttribute(PsiElement psiElement) {

    return PsiTreeUtil.getParentOfType(psiElement, ErlangAtomAttribute.class, ErlangTypeDefinition.class) != null;
  }

  public static boolean inSpecification(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangSpecification.class) != null;
  }

  public static boolean inColonQualified(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangColonQualifiedExpression.class) != null;
  }

  public static boolean inLeftPartOfAssignment(@NotNull PsiElement psiElement) {
    return inLeftPartOfAssignment(psiElement, true);
  }

  public static boolean inLeftPartOfAssignment(@NotNull PsiElement psiElement, boolean strict) {
    ErlangAssignmentExpression assignment = PsiTreeUtil.getParentOfType(psiElement, ErlangAssignmentExpression.class, true);
    while (assignment != null) {
      if (PsiTreeUtil.isAncestor(assignment.getLeft(), psiElement, strict)) {
        return true;
      }
      assignment = PsiTreeUtil.getParentOfType(assignment, ErlangAssignmentExpression.class, true);
    }
    return false;
  }

  public static boolean isForceSkipped(@NotNull ErlangQVar o) {
    return o.getName().startsWith("_");
  }

  @NotNull
  public static List<LookupElement> getFunctionLookupElements(@NotNull PsiFile containingFile, boolean withArity, @Nullable ErlangQAtom moduleAtom) {
    if (containingFile instanceof ErlangFile && !ErlangParserUtil.isApplicationConfigFileType(containingFile)) {
      List<ErlangFunction> functions = ContainerUtil.newArrayList();
      List<LookupElement> lookupElements = ContainerUtil.newArrayList();

      ErlangSdkRelease release = ErlangSdkType.getRelease(containingFile);
      if (moduleAtom != null) {
        String moduleName = getName(moduleAtom);
        functions.addAll(getExternalFunctionForCompletion(containingFile.getProject(), moduleName));

        if (release == null || release.needBifCompletion(moduleName)) {
          addBifs(lookupElements, ErlangBifTable.getBifs(moduleName), withArity);
        }
        addBifs(lookupElements, ErlangBifTable.getBifs("", ErlangBifTable.MODULE_INFO), withArity);
      }
      else {
        ErlangFile erlangFile = (ErlangFile) containingFile;
        functions.addAll(erlangFile.getFunctions());
        functions.addAll(getExternalFunctionForCompletion(containingFile.getProject(), "erlang"));

        List<ErlangImportFunction> directlyImported = erlangFile.getImportedFunctions();
        List<ErlangImportFunction> importsFromIncludes = getImportsFromIncludes(erlangFile, true, "", 0);
        for (ErlangImportFunction importFunction : ContainerUtil.concat(directlyImported, importsFromIncludes)) {
          LookupElement element = createFunctionLookupElement(getName(importFunction), getArity(importFunction), withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY);
          lookupElements.add(element);
        }

        if (!withArity && (release == null || release.needBifCompletion("erlang"))) {
          addBifs(lookupElements, ErlangBifTable.getBifs("erlang"));
        }
        if (!withArity && (release == null || release.needBifCompletion(""))) {
          addBifs(lookupElements, ErlangBifTable.getBifs(""));
        }
      }

      functions.addAll(getErlangFunctionsFromIncludes((ErlangFile) containingFile, true, "", 0));
      lookupElements.addAll(createFunctionLookupElements(functions, withArity));
      return lookupElements;
    }
    return Collections.emptyList();
  }

  private static void addBifs(@NotNull List<LookupElement> lookupElements, @NotNull Collection<ErlangBifDescriptor> bifs) {
    for (ErlangBifDescriptor bif : bifs) {
      lookupElements.add(createFunctionLookupElement(bif.getName(), bif.getArity(), false, ErlangCompletionContributor.BIF_PRIORITY));
    }
  }

  @NotNull
  public static Collection<LookupElement> getAllExportedFunctionsWithModuleLookupElements(@NotNull Project project,
                                                                                          boolean withArity,
                                                                                          @Nullable String exclude) {
    List<LookupElement> lookupElements = ContainerUtil.newArrayList();
    for (String moduleName : ErlangModuleIndex.getNames(project)) {
      if (exclude != null && moduleName.equals(exclude)) continue;
      for (ErlangFunction function : getExternalFunctionForCompletion(project, moduleName)) {
        String functionName = function.getName();
        String fullName = moduleName + ":" + functionName;
        int arity = function.getArity();
        lookupElements.add(
          PrioritizedLookupElement.withPriority(
            LookupElementBuilder.create(function, fullName)
              .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
              .withInsertHandler(getInsertHandler(functionName, moduleName, arity, withArity)),
            ErlangCompletionContributor.EXTERNAL_FUNCTIONS_PRIORITY));
      }
    }
    return lookupElements;
  }

  private static void addBifs(@NotNull List<LookupElement> lookupElements, @NotNull Collection<ErlangBifDescriptor> bifs, boolean withArity) {
    for (ErlangBifDescriptor bif : bifs) {
      lookupElements.add(createFunctionLookupElement(bif.getName(), bif.getArity(), withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY));
    }
  }

  @NotNull
  public static List<LookupElement> createFunctionLookupElements(@NotNull List<ErlangFunction> functions, final boolean withArity) {
    return ContainerUtil.map(functions, new Function<ErlangFunction, LookupElement>() {
      @NotNull
      @Override
      public LookupElement fun(@NotNull ErlangFunction function) {
        return createFunctionsLookupElement(function, withArity, ErlangCompletionContributor.MODULE_FUNCTIONS_PRIORITY);
      }
    });
  }

  @NotNull
  private static LookupElement createFunctionsLookupElement(@NotNull ErlangFunction function, boolean withArity, double priority) {
    int arity = function.getArity();
    return PrioritizedLookupElement.withPriority(LookupElementBuilder.create(function)
      .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
      .withInsertHandler(getInsertHandler(function.getName(), arity, withArity)), priority);
  }

  @NotNull
  private static LookupElement createFunctionLookupElement(@NotNull String name, int arity, boolean withArity, int priority) {
    return PrioritizedLookupElement.withPriority(LookupElementBuilder.create(name + arity, name)
      .withIcon(ErlangIcons.FUNCTION).withTailText("/" + arity)
      .withInsertHandler(getInsertHandler(name, arity, withArity)), (double) priority);
  }

  @NotNull
  private static InsertHandler<LookupElement> getInsertHandler(final String name, final int arity, boolean withArity) {
    return getInsertHandler(name, null, arity, withArity);
  }

  @NotNull
  private static InsertHandler<LookupElement> getInsertHandler(@NotNull final String name, @Nullable final String moduleName, final int arity, boolean withArity) {
    return withArity ?
      new BasicInsertHandler<LookupElement>() {
        @Override
        public void handleInsert(@NotNull InsertionContext context, LookupElement item) {
          QuoteInsertHandler.process(context.getProject(), name, moduleName, context);
          Editor editor = context.getEditor();
          Document document = editor.getDocument();
          context.commitDocument();
          PsiElement next = findNextToken(context);
          ASTNode intNode = FormatterUtil.getNextNonWhitespaceSibling(next != null ? next.getNode() : null);

          if (next != null && "/".equals(next.getText())) {
            next.delete();
          }
          if (intNode != null && intNode.getElementType() == ErlangTypes.ERL_INTEGER) {
            intNode.getPsi().delete();
          }
          PsiDocumentManager.getInstance(context.getProject()).doPostponedOperationsAndUnblockDocument(document);
          document.insertString(context.getTailOffset(), "/" + arity);
          editor.getCaretModel().moveToOffset(context.getTailOffset());
        }

        @Nullable
        private PsiElement findNextToken(@NotNull InsertionContext context) {
          PsiFile file = context.getFile();
          PsiElement element = file.findElementAt(context.getTailOffset());
          if (element instanceof PsiWhiteSpace) {
            element = file.findElementAt(element.getTextRange().getEndOffset());
          }
          return element;
        }
      } :
      new ParenthesesInsertHandler<LookupElement>() {
        @Override
        public void handleInsert(@NotNull InsertionContext context, LookupElement item) {
          QuoteInsertHandler.process(context.getProject(), name, moduleName, context);
          super.handleInsert(context, item);
        }

        @Override
        protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {
          return arity > 0;
        }
      };
  }

  @NotNull
  public static List<LookupElement> getMacrosLookupElements(@NotNull PsiFile containingFile) {
    if (containingFile instanceof ErlangFile) {
      List<ErlangMacrosDefinition> concat = ContainerUtil.concat(((ErlangFile) containingFile).getMacroses(), getErlangMacrosFromIncludes((ErlangFile) containingFile, true, ""));
      List<LookupElement> fromFile = ContainerUtil.map(
        concat,
        new Function<ErlangMacrosDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangMacrosDefinition md) {
            return LookupElementBuilder.create(md).withIcon(ErlangIcons.MACROS);
          }
        });
      List<LookupElement> stdMacros = ContainerUtil.newArrayList();
      for (String m : KNOWN_MACROS) {
        stdMacros.add(LookupElementBuilder.create(m).withIcon(ErlangIcons.MACROS));
      }
      return ContainerUtil.concat(fromFile, stdMacros);
    }
    return Collections.emptyList();
  }

  @NotNull
  public static List<LookupElement> getRecordLookupElements(@NotNull PsiFile containingFile) {
    if (containingFile instanceof ErlangFile) {
      List<ErlangRecordDefinition> concat = ContainerUtil.concat(((ErlangFile) containingFile).getRecords(), getErlangRecordFromIncludes((ErlangFile) containingFile, true, ""));
      return ContainerUtil.map(
        concat,
        new Function<ErlangRecordDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangRecordDefinition rd) {
            return LookupElementBuilder.create(rd).withIcon(ErlangIcons.RECORD);
          }
        });
    }
    return Collections.emptyList();
  }

  @NotNull
  public static List<LookupElement> getTypeLookupElements(@NotNull PsiFile containingFile, boolean addBuiltInTypes, final boolean withArity) {
    if (containingFile instanceof ErlangFile) {
      ErlangFile erlangFile = (ErlangFile) containingFile;
      List<ErlangTypeDefinition> types = ContainerUtil.concat(erlangFile.getTypes(), getErlangTypeFromIncludes(erlangFile, true, ""));

      final ParenthesesInsertHandler<LookupElement> handler = new ParenthesesInsertHandler<LookupElement>() {
        @Override
        protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {
          return false;
        }
      };

      List<LookupElement> builtInTypes = addBuiltInTypes ? ContainerUtil.map(BUILT_IN_TYPES, new Function<String, LookupElement>() {
        @NotNull
        @Override
        public LookupElement fun(@NotNull String s) {
          return PrioritizedLookupElement.withPriority(
            LookupElementBuilder.create(s).withIcon(ErlangIcons.TYPE).withInsertHandler(handler),
            ErlangCompletionContributor.TYPE_PRIORITY);
        }
      }) : ContainerUtil.<LookupElement>emptyList();

      List<LookupElement> foundedTypes = ContainerUtil.map(
        types,
        new Function<ErlangTypeDefinition, LookupElement>() {
          @NotNull
          @Override
          public LookupElement fun(@NotNull ErlangTypeDefinition rd) {
            return PrioritizedLookupElement.withPriority(
              LookupElementBuilder.create(rd).withIcon(ErlangIcons.TYPE).withInsertHandler(getInsertHandler(rd.getName(), getArity(rd), withArity)),
              ErlangCompletionContributor.TYPE_PRIORITY);
          }
        });
      return ContainerUtil.concat(foundedTypes, builtInTypes);
    }
    return Collections.emptyList();
  }

  public static int getArity(@NotNull ErlangTypeDefinition o) {
    ErlangTypeDefinitionStub stub = o.getStub();
    if (stub != null) return stub.getArity();
    ErlangArgumentDefinitionList argumentDefinitionList = o.getArgumentDefinitionList();
    if (argumentDefinitionList == null) return 0;
    return argumentDefinitionList.getArgumentDefinitionList().size();
  }

  private static int calculateFunctionClauseArity(@NotNull ErlangFunctionClause clause) {
    ErlangArgumentDefinitionList argumentDefinitionList = clause.getArgumentDefinitionList();
    return argumentDefinitionList.getArgumentDefinitionList().size();
  }

  @NotNull
  public static String getName(@NotNull ErlangFunction o) {
    return getNameImpl(o);
  }

  @NotNull
  public static String getName(@NotNull ErlangImportFunction o) {
    return getName(o.getQAtom());
  }

  @NotNull
  public static String getName(@NotNull ErlangQVar o) {
    return o.getText();
  }

  public static int getArity(@NotNull ErlangFunction o) {
    ErlangFunctionStub stub = o.getStub();
    if (stub != null) return stub.getArity();
    return o.getFirstClause().getArgumentDefinitionList().getArgumentDefinitionList().size();
  }

  public static int getArity(@NotNull ErlangImportFunction o) {
    return getArity(o.getInteger());
  }

  @NotNull
  public static String getName(@NotNull ErlangRecordDefinition o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangRecordDefinition o) {
    ErlangQAtom atom = o.getQAtom();
    return atom != null ? getNameIdentifier(atom) : o;
  }

  public static int getTextOffset(@NotNull ErlangRecordDefinition o) {
    if (o.getNameIdentifier() == o) return 0;
    return o.getNameIdentifier().getTextOffset();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangQVar o) {
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangQAtom o) {
    ErlangAtom atom = o.getAtom();
    return atom != null ? getNameIdentifier(atom) : o;
  }

  @NotNull
  public static String getName(@NotNull ErlangQAtom o) {
    return getNameIdentifier(o).getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangMacrosName o) {
    ErlangAtom atom = o.getAtom();
    if (atom != null) {
      return getNameIdentifier(atom);
    }
    return ObjectUtils.notNull(o.getVar(), o);
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangFunction o) {
    return getNameIdentifier(o.getAtomName());
  }

  @Nullable
  public static PsiReference getReferenceInternal(@NotNull ErlangRecordExpression o) {
    ErlangRecordRef recordRef = o.getRecordRef();
    return recordRef != null ? recordRef.getReference() : null;
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangRecordRef o) {
    return createRecordRef(o.getQAtom());
  }

  @NotNull
  public static ErlangRecordReferenceImpl<ErlangQAtom> createRecordRef(@NotNull ErlangQAtom atom) {
    return new ErlangRecordReferenceImpl<ErlangQAtom>(atom);
  }

  @NotNull
  public static PsiReference getReference(@NotNull ErlangModuleRef o) {
    return createModuleReference(o.getQAtom());
  }

  @NotNull
  public static PsiReference createModuleReference(@NotNull ErlangQAtom atom) {
    return new ErlangModuleReferenceImpl<ErlangQAtom>(atom);
  }

  @Nullable
  @Contract("null->null")
  public static ErlangFile resolveToFile(@Nullable ErlangModuleRef ref) {
    PsiReference reference = ref != null ? ref.getReference() : null;
    PsiElement resolved = reference != null ? reference.resolve() : null;
    return ObjectUtils.tryCast(resolved != null ? resolved.getContainingFile() : null, ErlangFile.class);
  }

  public static boolean renameQAtom(@Nullable ErlangQAtom qAtom, String newName) {
    return renameAtom(qAtom != null ? qAtom.getAtom() : null, newName);
  }

  public static boolean renameAtom(@Nullable ErlangAtom atom, String newName) {
    if (atom != null) {
      atom.setName(newName);
      return true;
    }
    return false;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangFunction o, @NotNull String newName) {
    for (ErlangFunctionClause clause : o.getFunctionClauseList()) {
      renameQAtom(clause.getQAtom(), newName);
    }
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangQVar o, @NotNull String newName) {
    o.replace(ErlangElementFactory.createQVarFromText(o.getProject(), newName));
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangRecordDefinition o, @NotNull String newName) {
    renameQAtom(o.getQAtom(), newName);
    return o;
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangTypeDefinition o, @NotNull String newName) {
    renameQAtom(o.getQAtom(), newName);
    return o;
  }

  @NotNull
  public static String getName(@NotNull ErlangModule o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangModule o, @NotNull String newName) {
    VirtualFile virtualFile = o.getContainingFile().getVirtualFile();
    if (virtualFile != null) {
      try {
        String ext = FileUtilRt.getExtension(virtualFile.getName());
        virtualFile.rename(o, StringUtil.replace(newName, "'", "") + "." + ext);
        renameQAtom(o.getQAtom(), newName);
      } catch (Exception ignored) {
      }
    }
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangModule o) {
    ErlangQAtom qAtom = o.getQAtom();
    return qAtom != null ? getNameIdentifier(qAtom) : o;
  }

  public static int getTextOffset(@NotNull ErlangModule o) {
    if (o.getNameIdentifier() == o) return 0; 
    return o.getNameIdentifier().getTextOffset();
  }

  @NotNull
  public static String getName(@NotNull ErlangFunctionCallExpression o) {
    return o.getNameIdentifier().getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangFunctionCallExpression o) {
    return getNameIdentifier(o.getQAtom());
  }

  public static int getTextOffset(@NotNull ErlangFunctionCallExpression o) {
    return o.getQAtom().getTextOffset();
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangListComprehension o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processDeclarationRecursive(o, processor, state);
  }
  
  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangCaseExpression o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    List<ErlangCrClause> crClauseList = o.getCrClauseList();
    boolean result = true;
    for (ErlangCrClause c : crClauseList) {
      ErlangClauseBody clauseBody = c.getClauseBody();
      if (clauseBody != null) result &= processDeclarationRecursive(clauseBody, processor, state);
    }
    return result;
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean processDeclarations(@NotNull ErlangModule o, @NotNull PsiScopeProcessor processor, @NotNull ResolveState state, PsiElement lastParent, @NotNull PsiElement place) {
    return processDeclarationRecursive(o, processor, state);
  }

  private static boolean processDeclarationRecursive(ErlangCompositeElement o, @NotNull PsiScopeProcessor processor, ResolveState state) {
    Queue<ErlangCompositeElement> queue = new LinkedList<ErlangCompositeElement>();
    queue.add(o);
    while (!queue.isEmpty()) {
      ErlangCompositeElement top = queue.remove();
      if (!processor.execute(top, state)) return false;
      queue.addAll(PsiTreeUtil.getChildrenOfTypeAsList(top, ErlangCompositeElement.class));
    }
    return true;
  }

  static boolean inModule(PsiElement psiElement) {
    return PsiTreeUtil.getParentOfType(psiElement, ErlangModule.class) != null;
  }

  @NotNull
  public static Collection<ErlangFile> getIncludedFiles(@NotNull ErlangFile file) {
    HashSet<ErlangFile> includedFiles = new HashSet<ErlangFile>();
    addIncludedFiles(file, includedFiles);
    return includedFiles;
  }

  private static void addIncludedFiles(@NotNull ErlangFile erlangFile, @NotNull Set<ErlangFile> alreadyAdded) {
    List<ErlangFile> directlyIncludedFiles = getDirectlyIncludedFiles(erlangFile);
    boolean added = false;
    for (ErlangFile f : directlyIncludedFiles) {
      added |= alreadyAdded.add(f);
    }
    if (added) {
      for (ErlangFile f : directlyIncludedFiles) {
        addIncludedFiles(f, alreadyAdded);
      }
    }
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangFile erlangFile) {
    List<ErlangFile> files = ContainerUtil.newArrayList();
    for (ErlangInclude include : erlangFile.getIncludes()) {
      files.addAll(getDirectlyIncludedFiles(include, erlangFile));
    }
    for (ErlangIncludeLib includeLib : erlangFile.getIncludeLibs()) {
      files.addAll(getDirectlyIncludedFiles(includeLib, erlangFile));
    }
    return files;
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangIncludeLib includeLib, @NotNull ErlangFile erlangFile) {
    ErlangIncludeString includeString = includeLib.getIncludeStringSafe();
    String[] split = includeString != null ? StringUtil.unquoteString(includeString.getText()).split("/") : null;

    if (split != null && split.length >= 2) {
      String libName = split[0];
      String relativePath = StringUtil.join(split, 1, split.length, "/");
      Project project = includeLib.getProject();
      VirtualFile appDir = ErlangApplicationIndex.getApplicationDirectoryByName(libName, GlobalSearchScope.allScope(project));
      ErlangFile includedFile = getRelativeErlangFile(project, relativePath, appDir);
      if (includedFile != null) {
        return ContainerUtil.newSmartList(includedFile);
      }
    }

    return getDirectlyIncludedFiles(includeString, erlangFile);
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@NotNull ErlangInclude include, @NotNull ErlangFile erlangFile) {
    ErlangIncludeString includeString = include.getIncludeStringSafe();
    return getDirectlyIncludedFiles(includeString, erlangFile);
  }

  @NotNull
  public static List<ErlangFile> getDirectlyIncludedFiles(@Nullable ErlangIncludeString includeString, @NotNull ErlangFile erlangFile) {
    if (includeString == null) return ContainerUtil.emptyList();
    VirtualFile containingVirtualFile = erlangFile.getOriginalFile().getVirtualFile();
    VirtualFile parent = containingVirtualFile != null ? containingVirtualFile.getParent() : null;
    String relativePath = StringUtil.unquoteString(includeString.getText());
    Project project = erlangFile.getProject();
    ErlangFile relativeToDirectParent = getRelativeErlangFile(project, relativePath, parent);
    if (relativeToDirectParent != null) return ContainerUtil.newSmartList(relativeToDirectParent);


    if (containingVirtualFile != null) {
      Module module = ModuleUtilCore.findModuleForFile(containingVirtualFile, project);
      for (VirtualFile includeDir : ErlangIncludeDirectoryUtil.getIncludeDirectories(module)) {
        ErlangFile includedFile = getRelativeErlangFile(project, relativePath, includeDir);
        if (includedFile != null) return ContainerUtil.newSmartList(includedFile);
      }
    }

    if (ErlangSystemUtil.isSmallIde()) {
      VirtualFile appRoot = getContainingOtpAppRoot(project, parent);
      return getDirectlyIncludedFilesForSmallIde(project, relativePath, appRoot);
    }
    return ContainerUtil.emptyList();
  }

  @NotNull
  private static List<ErlangFile> getDirectlyIncludedFilesForSmallIde(@NotNull Project project, @NotNull String includeStringPath, @Nullable VirtualFile otpAppRoot) {
    if (otpAppRoot == null) return ContainerUtil.emptyList();
    VirtualFile otpIncludeDirectory = otpAppRoot.findChild("include");
    ErlangFile relativeToOtpIncludeDirectory = getRelativeErlangFile(project, includeStringPath, otpIncludeDirectory);
    if (relativeToOtpIncludeDirectory != null) return ContainerUtil.newSmartList(relativeToOtpIncludeDirectory);

    ErlangFile rebarConfigPsi = RebarConfigUtil.getRebarConfig(project, otpAppRoot);
    if (rebarConfigPsi != null) {
      for(String includePath : ContainerUtil.reverse(RebarConfigUtil.getIncludePaths(rebarConfigPsi))) {
        VirtualFile includePathVirtualFile = VfsUtilCore.findRelativeFile(includePath, otpAppRoot);
        ErlangFile includedFile = getRelativeErlangFile(project, includeStringPath, includePathVirtualFile);
        if (includedFile != null) return ContainerUtil.newSmartList(includedFile);
      }
    }
    return ContainerUtil.emptyList();
  }

  @Nullable
  public static VirtualFile getContainingOtpAppRoot(@NotNull Project project, @Nullable final VirtualFile file) {
    if (file == null) return null;
    List<VirtualFile> allOtpAppRoots = ErlangApplicationIndex.getAllApplicationDirectories(project, GlobalSearchScope.allScope(project));
    List<VirtualFile> containingOtpAppRoots = ContainerUtil.filter(allOtpAppRoots, new Condition<VirtualFile>() {
      @Override
      public boolean value(@NotNull VirtualFile appRoot) {
        return VfsUtilCore.isAncestor(appRoot, file, true);
      }
    });

    ContainerUtil.sort(containingOtpAppRoots, new Comparator<VirtualFile>() {
      @Override
      public int compare(@NotNull VirtualFile o1, @NotNull VirtualFile o2) {
        return o2.getPath().length() - o1.getPath().length();
      }
    });
    return ContainerUtil.getFirstItem(containingOtpAppRoots);
  }

  public static void addDeclaredBehaviourModuleNames(@NotNull ErlangFile file, @NotNull Set<String> behaviourNames) {
    for (ErlangBehaviour behaviour : file.getBehaviours()) {
      ContainerUtil.addIfNotNull(getName(behaviour), behaviourNames);
    }
  }

  public static void extractParseTransforms(@NotNull ErlangListExpression list, @NotNull Set<String> parseTransforms) {
    for (ErlangExpression expr : list.getExpressionList()) {
      if (expr instanceof ErlangTupleExpression) {
        extractParseTransforms((ErlangTupleExpression) expr, parseTransforms);
      }
    }
  }

  public static void extractParseTransforms(@NotNull ErlangTupleExpression tuple, @NotNull Set<String> parseTransforms) {
    List<ErlangExpression> expressionList = tuple.getExpressionList();
    if (expressionList.size() != 2) return;
    ErlangExpression first = expressionList.get(0);
    if (!"parse_transform".equals(getAtomName(first instanceof ErlangMaxExpression ? (ErlangMaxExpression) first : null))) return;
    ErlangExpression second = expressionList.get(1);
    String parseTransformModuleName = getAtomName(second instanceof ErlangMaxExpression ? (ErlangMaxExpression) second : null);
    ContainerUtil.addIfNotNull(parseTransformModuleName, parseTransforms);
  }

  @Nullable
  public static String getAtomName(@Nullable ErlangMaxExpression expression) {
    return expression != null ? getAtomName(expression.getQAtom()) : null;
  }

  @Nullable
  private static String getAtomName(@Nullable ErlangQAtom qAtom) {
    ErlangAtom atom = qAtom != null ? qAtom.getAtom() : null;
    return atom != null ? atom.getName() : null;
  }

  @Nullable
  private static ErlangFile getRelativeErlangFile(@NotNull Project project, @NotNull String relativePath, @Nullable VirtualFile parent) {
    VirtualFile relativeFile = VfsUtilCore.findRelativeFile(relativePath, parent);
    if (relativeFile == null) return null;
    PsiFile file = PsiManager.getInstance(project).findFile(relativeFile);
    return file instanceof ErlangFile ? (ErlangFile) file : null;
  }

  @NotNull
  static List<ErlangRecordDefinition> getErlangRecordFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, String name) {
    List<ErlangRecordDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getRecord(name));
      }
      else {
        fromIncludes.addAll(file.getRecords());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangFunction> getErlangFunctionsFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name, int arity) {
    List<ErlangFunction> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getFunction(name, arity));
      }
      else {
        fromIncludes.addAll(file.getFunctions());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangImportFunction> getImportsFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name, int arity) {
    List<ErlangImportFunction> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getImportedFunction(name, arity));
      }
      else {
        fromIncludes.addAll(file.getImportedFunctions());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangMacrosDefinition> getErlangMacrosFromIncludes(@NotNull ErlangFile containingFile,
                                                                  boolean forCompletion,
                                                                  @NotNull String name) {
    List<ErlangMacrosDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getMacros(name));
      }
      else {
        fromIncludes.addAll(file.getMacroses());
      }
    }
    return fromIncludes;
  }

  @NotNull
  static List<ErlangTypeDefinition> getErlangTypeFromIncludes(@NotNull ErlangFile containingFile, boolean forCompletion, @NotNull String name) {
    List<ErlangTypeDefinition> fromIncludes = ContainerUtil.newArrayList();
    for (ErlangFile file : getIncludedFiles(containingFile)) {
      if (!forCompletion) {
        ContainerUtil.addIfNotNull(fromIncludes, file.getType(name));
      }
      else {
        fromIncludes.addAll(file.getTypes());
      }
    }
    return fromIncludes;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangAtom atom) {
    PsiElement name = atom.getAtomName();
    return name != null ? name : atom;
  }

  @NotNull
  public static ErlangAtom setName(@NotNull ErlangAtom atom, @NotNull String newName) {
    String text = toAtomName(newName);
    assert text != null;
    ErlangAtom newAtom = ErlangElementFactory.createAtomFromText(atom.getProject(), text);
    return (ErlangAtom) atom.replace(newAtom);
  }

  @Nullable
  public static String toAtomName(@NotNull String maybeUnquotedAtomName) {
    ThreeState t = atomNameRequiresQuotes(maybeUnquotedAtomName);
    return t == ThreeState.YES ? '\'' + maybeUnquotedAtomName + '\'' : t == ThreeState.NO ? maybeUnquotedAtomName : null;
  }

  @NotNull
  private static ThreeState atomNameRequiresQuotes(@NotNull String atomName) {

    Matcher matcher = ATOM_PATTERN.matcher(atomName);
    if (matcher.matches()) {
      return ThreeState.NO;
    }

    matcher = QUOTED_ATOM_NAME.matcher(atomName);
    if (matcher.matches()) {
      return ThreeState.YES;
    }

    matcher = QUOTED_ATOM_NAME.matcher(StringUtil.unquoteString(atomName, '\''));
    if (matcher.matches()) {
      return ThreeState.NO;
    }
    return ThreeState.UNSURE;
  }

  @NotNull
  public static String getName(@NotNull ErlangAtom atom) {
    return atom.getNameIdentifier().getText();
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangMacrosDefinition o) {
    ErlangMacrosName macrosName = o.getMacrosName();
    return macrosName != null ? getNameIdentifier(macrosName) : o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangTypeDefinition o) {
    ErlangQAtom qAtom = o.getQAtom();
    return qAtom != null ? getNameIdentifier(qAtom) : o;
  }

  public static int getTextOffset(@NotNull ErlangTypeDefinition o) {
    if (o.getQAtom() == null) return 0;
    return getNameIdentifier(o).getTextOffset();
  }

  public static int getTextOffset(@NotNull ErlangMacrosDefinition o) {
    if (o.getMacrosName() == null) return 0;
    return getNameIdentifier(o).getTextOffset();
  }

  @NotNull
  public static String getName(@NotNull ErlangMacrosDefinition o) {
    return getNameImpl(o);
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangMacrosDefinition o, @NotNull String newName) {
    ErlangMacrosName macrosName = o.getMacrosName();
    if (macrosName != null) {
      setName(macrosName, newName);
    }
    return o;
  }

  public static void setName(@NotNull ErlangMacrosName macroName, @NotNull String newName) {
    PsiElement replacement = createMacroNameReplacement(macroName.getProject(), newName);
    if (macroName.getAtom() != null) {
      macroName.getAtom().replace(replacement);
    }
    else if (macroName.getVar() != null) {
      macroName.getVar().replace(replacement);
    }
    else {
      throw new AssertionError("Unexpected PSI structure");
    }
  }

  @NotNull
  private static PsiElement createMacroNameReplacement(@NotNull Project project, @NotNull String newName) {
    ErlangMacrosName macroName = null;
    try {
      macroName = (ErlangMacrosName) ErlangElementFactory.createMacrosFromText(project, newName);
    } catch (Exception ignore) {
    }
    if (macroName == null) {
      try {
        macroName = (ErlangMacrosName) ErlangElementFactory.createMacrosFromText(project, '\'' + newName + '\'');
      } catch (Exception ignore) {
      }
    }
    if (macroName != null) {
      if (macroName.getAtom() != null) {
        return macroName.getAtom();
      }
      else if (macroName.getVar() != null) {
        return macroName.getVar();
      }
    }
    throw new AssertionError("Cannot create macro name replacement");
  }

  @NotNull
  public static String getName(@NotNull ErlangBehaviour o) {
    String fromStub = getNameFromStub(o);
    if (fromStub != null) return fromStub;

    ErlangModuleRef moduleRef = o.getModuleRef();
    ErlangQAtom atom = moduleRef != null ? moduleRef.getQAtom() : null;
    return atom == null ? "" : getName(atom);
  }

  @NotNull
  public static List<ErlangFunction> getExternalFunctionForCompletion(@NotNull Project project, @NotNull String moduleName) {
    List<ErlangFunction> result = ContainerUtil.newArrayList();
    List<ErlangFile> erlangModules = ErlangModuleIndex.getFilesByName(project, moduleName, GlobalSearchScope.allScope(project));
    for (ErlangFile file : erlangModules) {
      result.addAll(file.getExportedFunctions());
    }
    return result;
  }

  public static boolean inFunction(@Nullable PsiElement position) {
    return PsiTreeUtil.getParentOfType(position, ErlangFunction.class) != null;
  }

  @NotNull
  public static String getName(@NotNull ErlangTypedExpr o) {
    return getNameIdentifier(o).getText();
  }

  @NotNull
  public static PsiElement setName(@NotNull ErlangTypedExpr o, String newName) {
    ErlangQAtom qAtom = o.getQAtom();
    renameQAtom(qAtom, newName);
    return o;
  }

  @NotNull
  public static PsiElement getNameIdentifier(@NotNull ErlangTypedExpr o) {
    return getNameIdentifier(o.getQAtom());
  }

  @NotNull
  public static String getName(@NotNull ErlangAtomAttribute o) {
    return o.getAtomName().getText();
  }

  public static int getTextOffset(@NotNull ErlangTypedExpr o) {
    return o.getNameIdentifier().getTextOffset();
  }

  @Nullable
  public static PsiReference getReference(@NotNull ErlangSpecFun o) {
    ErlangQAtom atom = o.getQAtom();
    ErlangModuleRef moduleRef = PsiTreeUtil.getPrevSiblingOfType(o, ErlangModuleRef.class);
    Integer arity = getArity(o);

    if (arity != null) {
      return new ErlangFunctionReferenceImpl<ErlangQAtom>(atom, moduleRef == null ? null : moduleRef.getQAtom(), arity);
    }
    return null;
  }

  @Nullable
  public static Integer getArity(@NotNull ErlangSpecFun o) {
    PsiElement integer = o.getInteger();
    Integer arity = null;
    if (integer != null) arity = getArity(integer);
    ErlangTypeSig sigs = PsiTreeUtil.getNextSiblingOfType(o, ErlangTypeSig.class);
    if (arity == null && sigs != null) arity = sigs.getFunType().getFunTypeArguments().getTypeList().size();
    return arity;
  }

  @Nullable
  public static ErlangFunTypeSigs getSignature(@Nullable ErlangSpecification o) {
    if (o == null) return null;
    ErlangFunTypeSigsBraces sigsBraces = o.getFunTypeSigsBraces();
    if (sigsBraces != null) {
      return sigsBraces.getFunTypeSigs();
    }
    return o.getFunTypeSigs();
  }

  @NotNull
  public static ItemPresentation getPresentation(@NotNull final ErlangFunction o) {
    return new ItemPresentation() {
      @Nullable
      @Override
      public String getPresentableText() {
        return createFunctionPresentation(o);
      }

      @Nullable
      @Override
      public String getLocationString() {
        return o.getContainingFile().getName();
      }

      @Nullable
      @Override
      public Icon getIcon(boolean b) {
        return o.getIcon(0);
      }
    };
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangAtomWithArityExpression function) {
    return createFunctionPresentation(getName(function.getQAtom()), getArity(function.getInteger()));
  }

  @NotNull
  public static String createFunctionClausePresentation(@NotNull ErlangFunctionClause clause) {
    return createFunctionPresentation(getName(clause.getQAtom()), calculateFunctionClauseArity(clause));
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangFunction function) {
    return createFunctionPresentation(function.getName(), function.getArity());
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull ErlangImportFunction function) {
    return createFunctionPresentation(getName(function), getArity(function));
  }

  @NotNull
  public static String createFunctionPresentation(@NotNull String functionName, int arity) {
    return toAtomName(functionName) + "/" + arity;
  }

  @NotNull
  public static String getQualifiedFunctionName(@NotNull ErlangFunction function) {
    PsiFile file = function.getContainingFile();
    ErlangFile erlangFile = file instanceof ErlangFile ? (ErlangFile) file : null;
    ErlangModule module = erlangFile != null ? erlangFile.getModule() : null;
    return module != null ? module.getName() + ":" + function.getName() : function.getName();
  }

  @NotNull
  public static String createFunctionPresentationFromCallbackSpec(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    String funName = getCallbackSpecName(spec);

    List<ErlangTypeSig> typeSigList = funTypeSigs != null ? funTypeSigs.getTypeSigList() : null;
    ErlangTypeSig first = ContainerUtil.getFirstItem(typeSigList);
    int arity = first != null ? first.getFunType().getFunTypeArguments().getTypeList().size() : 0;

    return funName + "/" + arity;
  }

  @NotNull
  public static String createTypePresentation(@NotNull ErlangTypeDefinition type) {
    return type.getName() + "/" + getArity(type);
  }

  @NotNull
  @SuppressWarnings("UnusedParameters")
  public static Icon getIcon(@NotNull ErlangFunction o, int flags) {
    return ErlangIcons.FUNCTION;
  }

  public static boolean isRecursiveCall(PsiElement element, ErlangFunction function) {
    return Comparing.equal(PsiTreeUtil.getParentOfType(element, ErlangFunction.class), function);
  }

  public static boolean isEunitTestFile(@NotNull ErlangFile file) {
    VirtualFile virtualFile = file.getVirtualFile();
    String withoutExtension = virtualFile != null ? virtualFile.getNameWithoutExtension() : "";
    return (StringUtil.endsWith(withoutExtension, "_test") || StringUtil.endsWith(withoutExtension, "_tests")) && isEunitImported(file);
  }

  public static boolean isEunitTestFunction(@NotNull ErlangFunction function) {
    String name = function.getName();
    return isEunitTestFunctionName(name) || isEunitTestGeneratorFunctionName(name);
  }

  public static boolean isEunitTestFunctionName(@NotNull String functionName) {
    return StringUtil.endsWith(functionName, "_test");
  }

  public static boolean isEunitTestGeneratorFunctionName(@NotNull String functionName) {
    return StringUtil.endsWith(functionName, "_test_");
  }

  public static boolean isEunitImported(@NotNull ErlangFile file) {
    return isEunitDirectlyImported(file) ||
      ContainerUtil.find(getIncludedFiles(file), new Condition<ErlangFile>() {
        @Override
        public boolean value(@NotNull ErlangFile includedFile) {
          return isEunitDirectlyImported(includedFile);
        }
      }) != null;
  }

  private static boolean isEunitDirectlyImported(@NotNull ErlangFile file) {
    List<ErlangIncludeLib> includes = file.getIncludeLibs();
    for (ErlangIncludeLib include : includes) {
      ErlangIncludeString string = include.getIncludeStringSafe();
      if (string != null) {
        String includeFilePath = StringUtil.unquoteString(string.getText());
        return StringUtil.equals(includeFilePath, "eunit/include/eunit.hrl");
      }
    }
    return false;
  }

  @NotNull
  public static SearchScope getUseScope(@NotNull ErlangQVarImpl o) {
    ErlangFunction function = PsiTreeUtil.getParentOfType(o, ErlangFunction.class, true);
    if (function != null) {
      return new LocalSearchScope(function);
    }
    return ResolveScopeManager.getElementUseScope(o);
  }

  @NotNull
  public static String getName(@NotNull ErlangTypeDefinition o) {
    return getNameImpl(o);
  }

  @Nullable
  public static ErlangSpecification findSpecification(@Nullable ErlangFunction function) {
    if (function == null) return null;
    PsiFile file = function.getContainingFile();
    if (!(file instanceof ErlangFile)) return null;
    List<ErlangSpecification> specifications = ((ErlangFile) file).getSpecifications();
    LocalSearchScope scope = new LocalSearchScope(ArrayUtil.toObjectArray(specifications, ErlangSpecification.class));
    AccessToken token = ApplicationManager.getApplication().acquireReadActionLock();
    try {
      Query<PsiReference> search = ReferencesSearch.search(function, scope);
      PsiReference first = search.findFirst();
      return PsiTreeUtil.getParentOfType(first != null ? first.getElement() : null, ErlangSpecification.class);
    } finally {
      token.finish();
    }
  }

  public static boolean notFromPreviousFunction(@NotNull PsiElement spec, @Nullable ErlangFunction prevFunction) {
    return prevFunction == null || spec.getTextOffset() > prevFunction.getTextOffset();
  }

  @SuppressWarnings("UnusedParameters")
  public static boolean isValidHost(@NotNull ErlangStringLiteral o) {
    return true;
  }

  @NotNull
  public static ErlangStringLiteral updateText(@NotNull ErlangStringLiteral o, @NotNull String text) {
    ErlangExpression expression = ErlangElementFactory.createExpressionFromText(o.getProject(), text);
    return (ErlangStringLiteralImpl)o.replace(expression);
  }

  @NotNull
  public static ErlangStringLiteralEscaper createLiteralTextEscaper(@NotNull ErlangStringLiteral o) {
    return new ErlangStringLiteralEscaper(o);
  }

  @Nullable
  public static ErlangQAtom getQAtom(@Nullable ErlangColonQualifiedExpression colonQualifier) {
    ErlangExpression firstExpression = colonQualifier == null ? null : ContainerUtil.getFirstItem(colonQualifier.getExpressionList());
    return firstExpression instanceof ErlangMaxExpression ? ((ErlangMaxExpression) firstExpression).getQAtom() : null;
  }

  @Nullable
  public static String getCallbackSpecName(@NotNull ErlangCallbackSpec spec) {
    ErlangQAtom atom = getCallbackAtom(spec);
    return atom != null ? atom.getText() : null;
  }

  public static int getCallbackSpecArity(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs sigs = spec.getFunTypeSigs();
    ErlangSpecFun fun = sigs != null ? sigs.getSpecFun() : null;
    Integer arity = fun != null ? getArity(fun) : null;
    return arity != null ? arity : -1;
  }

  @NotNull
  public static String getExportFunctionName(@NotNull ErlangExportFunction exportFunction) {
    return getNameIdentifier(exportFunction.getQAtom()).getText();
  }

  @Nullable
  private static ErlangQAtom getCallbackAtom(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    ErlangSpecFun specFun = funTypeSigs != null ? funTypeSigs.getSpecFun() : null;
    return specFun != null ? specFun.getQAtom() : null;
  }

  @Nullable
  public static ErlangFunTypeSigs getFunTypeSigs(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = spec.getFunTypeSigs();
    if (funTypeSigs == null) {
      ErlangFunTypeSigsBraces braces = spec.getFunTypeSigsBraces();
      funTypeSigs = braces != null ? braces.getFunTypeSigs() : null;
    }
    return funTypeSigs;
  }

  @NotNull
  public static List<ErlangType> getCallBackSpecArguments(@NotNull ErlangCallbackSpec spec) {
    ErlangFunTypeSigs funTypeSigs = getFunTypeSigs(spec);
    List<ErlangTypeSig> typeSigList = funTypeSigs != null ? funTypeSigs.getTypeSigList() : ContainerUtil.<ErlangTypeSig>emptyList();
    ErlangTypeSig typeSig = ContainerUtil.getFirstItem(typeSigList);
    ErlangFunType funType = typeSig != null ? typeSig.getFunType() : null;
    ErlangFunTypeArguments arguments = funType != null ? funType.getFunTypeArguments() : null;
    return arguments != null ? arguments.getTypeList() : ContainerUtil.<ErlangType>emptyList();
  }

  public static boolean isPrivateFunction(@NotNull PsiFile containingFile, @NotNull ErlangFunction function) {
    boolean exportAll = containingFile instanceof ErlangFile && ((ErlangFile) containingFile).isExportedAll();
    if (exportAll) return false;
    return containingFile instanceof ErlangFile && !((ErlangFile) containingFile).getExportedFunctions().contains(function);
  }

  public static int getExpressionPrecedence(@Nullable PsiElement element) {
    if (element instanceof ErlangCatchExpression) return 0;
    if (element instanceof ErlangAssignmentExpression) return 1;
    if (element instanceof ErlangSendExpression) return 2;
    if (element instanceof ErlangOrelseExpression) return 3;
    if (element instanceof ErlangAndalsoExpression) return 4;
    if (element instanceof ErlangCompOpExpression) return 5;
    if (element instanceof ErlangListOpExpression) return 6;
    if (element instanceof ErlangAdditiveExpression) return 7;
    if (element instanceof ErlangMultiplicativeExpression) return 8;
    if (element instanceof ErlangPrefixExpression) return 9;
    if (element instanceof ErlangColonQualifiedExpression) return 10;
    if (element instanceof ErlangFunctionCallExpression
      || element instanceof ErlangGlobalFunctionCallExpression
      || element instanceof ErlangGenericFunctionCallExpression
      || element instanceof ErlangAnonymousCallExpression
      || element instanceof ErlangRecordExpression
      || element instanceof ErlangQualifiedExpression) return 11;
    if (element instanceof ErlangMaxExpression
      || element instanceof ErlangTupleExpression
      || element instanceof ErlangListExpression
      || element instanceof ErlangCaseExpression
      || element instanceof ErlangIfExpression
      || element instanceof ErlangListComprehension
      || element instanceof ErlangReceiveExpression
      || element instanceof ErlangFunExpression
      || element instanceof ErlangTryExpression
      || element instanceof ErlangBinaryExpression
      || element instanceof ErlangBeginEndExpression
      ) return 12;
    if (element instanceof ErlangParenthesizedExpression) return 13;
    return -1;
  }

  @NotNull
  public static ErlangExpression getOutermostParenthesizedExpression(@NotNull ErlangExpression expression) {
    while (expression.getParent() instanceof ErlangParenthesizedExpression) {
      ErlangParenthesizedExpression parent = (ErlangParenthesizedExpression) expression.getParent();
      if (!expression.isEquivalentTo(parent.getExpression())) break;
      expression = parent;
    }

    return expression;
  }

  @Nullable
  public static ErlangExpression getNotParenthesizedExpression(@Nullable ErlangExpression expression) {
    while (expression instanceof ErlangParenthesizedExpression) {
      expression = ((ErlangParenthesizedExpression) expression).getExpression();
    }
    return expression;
  }

  @NotNull
  public static ErlangExpression wrapWithParentheses(@NotNull ErlangExpression expression) {
    return ErlangElementFactory.createExpressionFromText(expression.getProject(), "(" + expression.getText() + ")");
  }

  @Nullable
  public static ErlangFunExpression findFunExpression(@NotNull ErlangFunction function, final int funExpressionNumber) {
    final Ref<ErlangFunExpression> result = new Ref<ErlangFunExpression>();
    final Ref<Integer> currentFunExpressionNumber = new Ref<Integer>(0);
    function.accept(new ErlangRecursiveVisitor() {
      @Override
      public void visitFunExpression(@NotNull ErlangFunExpression funExpression) {
        if (funExpressionNumber == currentFunExpressionNumber.get()) {
          result.set(funExpression);
        }
        currentFunExpressionNumber.set(currentFunExpressionNumber.get() + 1);
        super.visitFunExpression(funExpression);
      }
    });
    return result.get();
  }

  public static PsiElementPattern.Capture<ErlangQAtom> secondAtomInIsRecord() {
    return psiElement(ErlangQAtom.class).with(inIsRecord(1));
  }

  @NotNull
  public static <T extends PsiElement >ErlangFunctionCallParameter<T> inIsRecord(int position) {
    return new ErlangFunctionCallParameter<T>("is_record", "erlang", 2, position);
  }

  public static boolean isExported(@NotNull ErlangFunction o) {
    ErlangFunctionStub stub = o.getStub();
    if (stub != null) return stub.isExported();

    PsiFile file = o.getContainingFile();
    String signature = o.getName() + "/" + o.getArity();
    return file instanceof ErlangFile && ((ErlangFile) file).isExported(signature);
  }

  @Nullable
  public static ErlangIncludeString getIncludeStringSafe(@NotNull ErlangInclude o) {
    ErlangIncludeStub stub = o.getStub();
    if (stub != null) return stub.getIncludeString();
    return o.getIncludeString();
  }

  @Nullable
  public static ErlangIncludeString getIncludeStringSafe(@NotNull ErlangIncludeLib o) {
    ErlangIncludeLibStub stub = o.getStub();
    if (stub != null) return stub.getIncludeString();
    return o.getIncludeString();
  }

  @NotNull
  public static ErlangFunctionReferenceImpl<ErlangQAtom> createFunctionReference(@NotNull ErlangQAtom atom) {
    PsiElement parent = atom.getParent();
    ErlangMaxExpression moduleExpression = PsiTreeUtil.getPrevSiblingOfType(parent, ErlangMaxExpression.class);
    ErlangListExpression list = PsiTreeUtil.getNextSiblingOfType(parent, ErlangListExpression.class);
    ErlangQAtom module = moduleExpression == null ? null : moduleExpression.getQAtom();
    int arity = list == null ? -1 : list.getExpressionList().size();
    return new ErlangFunctionReferenceImpl<ErlangQAtom>(atom, module, arity);
  }

  public static boolean isWhitespaceOrComment(@NotNull PsiElement element) {
    return isWhitespaceOrComment(element.getNode());
  }

  public static boolean isWhitespaceOrComment(@NotNull ASTNode node) {
    IElementType elementType = node.getElementType();
    return ErlangParserDefinition.WS.contains(elementType) ||
      ErlangParserDefinition.COMMENTS.contains(elementType);
  }

  public static boolean is(@Nullable PsiElement element, IElementType type) {
    return element != null && element.getNode().getElementType() == type;
  }

  @NotNull
  public static TextRange getTextRangeForReference(@NotNull ErlangQAtom qAtom) {
    return rangeInParent(qAtom.getTextRange(), getNameIdentifier(qAtom).getTextRange());
  }

  @NotNull
  public static TextRange getTextRangeForReference(@NotNull ErlangMacrosName macroName) {
    return rangeInParent(macroName.getTextRange(), getNameIdentifier(macroName).getTextRange());
  }

  @NotNull
  private static TextRange rangeInParent(@NotNull TextRange parent, @NotNull TextRange child) {
    int start = child.getStartOffset() - parent.getStartOffset();
    return TextRange.create(start, start + child.getLength());
  }

  @NotNull
  private static String getNameImpl(@NotNull ErlangNamedElement namedElement) {
    if (namedElement instanceof StubBasedPsiElement) {
      String fromStub = getNameFromStub((StubBasedPsiElement)namedElement);
      if (fromStub != null) return fromStub;
    }
    PsiElement nameIdentifier = namedElement.getNameIdentifier();
    return nameIdentifier != null ? nameIdentifier.getText() : "";
  }

  @Nullable
  private static String getNameFromStub(StubBasedPsiElement element) {
    NamedStubBase<?> stub = ObjectUtils.tryCast(element.getStub(), NamedStubBase.class);
    return stub != null ? StringUtil.notNullize(stub.getName()) : null;
  }

  public static boolean fromTheSameCaseExpression(@NotNull PsiElement origin, @NotNull PsiElement element) {
    if (element instanceof ErlangQVar && Comparing.equal(element.getText(), element.getText())) {
      ErlangCompositeElement cr2 = PsiTreeUtil.getParentOfType(element, ErlangCrClause.class);
      ErlangCompositeElement cr1 = PsiTreeUtil.getParentOfType(origin, ErlangCrClause.class);
      if (cr1 != null && cr2 != null) {
        ErlangCaseExpression ce1 = PsiTreeUtil.getParentOfType(element, ErlangCaseExpression.class);
        ErlangCaseExpression ce2 = PsiTreeUtil.getParentOfType(origin, ErlangCaseExpression.class);
        if (Comparing.equal(ce1, ce2)) return true;
      }
    }
    return false;
  }

  public static class ErlangFunctionCallParameter<T extends PsiElement> extends PatternCondition<T> {
    @NotNull
    private final String myFunName;
    @NotNull
    private final String myModule;
    private final int myArity;
    private final int myPosition;

    public ErlangFunctionCallParameter(@NotNull String funName, @NotNull String module, int arity, int position) {
      super("functionCallParameter");
      myFunName = funName;
      myModule = module;
      myArity = arity;
      myPosition = position;
    }

    @Override
    public boolean accepts(@NotNull T element, ProcessingContext context) {
      ErlangExpression expr = PsiTreeUtil.getParentOfType(element, ErlangExpression.class, false);
      if (expr == null) return false;
      PsiElement list = expr.getParent();
      if (list instanceof ErlangArgumentList) {
        PsiElement funCall = list.getParent();
        List<ErlangExpression> expressions = ((ErlangArgumentList) list).getExpressionList();
        if (!(expressions.size() > myPosition && expressions.get(myPosition) == expr)) return false;
        if (funCall instanceof ErlangFunctionCallExpression) {
          PsiReference reference = funCall.getReference();

          ResolveResult[] results = reference instanceof PsiPolyVariantReference ?
            ((PsiPolyVariantReference) reference).multiResolve(true) : ResolveResult.EMPTY_ARRAY;
          for (ResolveResult r : results) {
            if (expectedFunction(r.getElement())) return true;
          }
        }
      }
      return false;
    }

    private boolean expectedFunction(@Nullable PsiElement resolve) {
      if (!(resolve instanceof ErlangFunction)) return false;
      String name = ((ErlangFunction) resolve).getName();
      if (!name.equals(myFunName)) return false;
      PsiFile containingFile = resolve.getContainingFile();
      if (!(containingFile instanceof ErlangFile)) return false;
      ErlangModule module = ((ErlangFile) containingFile).getModule();
      String moduleName = module != null ? module.getName() : null;
      if (!myModule.equals(moduleName)) return false;
      int arity = getArity((ErlangFunction) resolve);
      if (arity != myArity) return false;
      return true;
    }
  }
}
<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.execution.ExecutionException;
import com.intellij.execution.configurations.GeneralCommandLine;
import com.intellij.execution.process.BaseOSProcessHandler;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.JDOMUtil;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.util.CommonProcessors;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.graph.GraphGenerator;
import com.intellij.util.xmlb.XmlSerializationException;
import com.intellij.util.xmlb.XmlSerializer;
import org.intellij.erlang.jps.model.*;
import org.jdom.Document;
import org.jdom.JDOMException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.builders.BuildOutputConsumer;
import org.jetbrains.jps.builders.DirtyFilesHolder;
import org.jetbrains.jps.builders.FileProcessor;
import org.jetbrains.jps.incremental.CompileContext;
import org.jetbrains.jps.incremental.ProjectBuildException;
import org.jetbrains.jps.incremental.TargetBuilder;
import org.jetbrains.jps.incremental.messages.BuildMessage;
import org.jetbrains.jps.incremental.messages.CompilerMessage;
import org.jetbrains.jps.incremental.resources.ResourcesBuilder;
import org.jetbrains.jps.incremental.resources.StandardResourceBuilderEnabler;
import org.jetbrains.jps.model.JpsDummyElement;
import org.jetbrains.jps.model.JpsProject;
import org.jetbrains.jps.model.java.JavaSourceRootType;
import org.jetbrains.jps.model.java.JpsJavaExtensionService;
import org.jetbrains.jps.model.library.sdk.JpsSdk;
import org.jetbrains.jps.model.module.*;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.*;

public class ErlangBuilder extends TargetBuilder<ErlangSourceRootDescriptor, ErlangTarget> {
  public static final String DEPENDENCIES_CONFIG_FILE_PATH = "erlang-builder/deps-config.xml";
  public static final String NAME = "erlc";
  private static final Logger LOG = Logger.getInstance(ErlangBuilder.class);

  public ErlangBuilder() {
    super(Collections.singletonList(ErlangTargetType.INSTANCE));



    ResourcesBuilder.registerEnabler(new StandardResourceBuilderEnabler() {
      @Override
      public boolean isResourceProcessingEnabled(@NotNull JpsModule module) {
        return !(module.getModuleType() instanceof JpsErlangModuleType);
      }
    });
  }

  @Override
  public void build(@NotNull ErlangTarget target,
                    @NotNull DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                    @NotNull BuildOutputConsumer outputConsumer,
                    @NotNull CompileContext context) throws ProjectBuildException, IOException {
    LOG.debug(target.getPresentableName());
    if (!holder.hasDirtyFiles() && !holder.hasRemovedFiles()) return;

    JpsModule module = target.getModule();
    JpsProject project = module.getProject();
    ErlangCompilerOptions compilerOptions = JpsErlangCompilerOptionsExtension.getOrCreateExtension(project).getOptions();
    if (compilerOptions.myUseRebarCompiler) return;

    File sourceOutput = getBuildOutputDirectory(module, false, context);
    File testOutput = getBuildOutputDirectory(module, true, context);

    buildSources(target, context, compilerOptions, holder, outputConsumer, sourceOutput, false);
    buildSources(target, context, compilerOptions, holder, outputConsumer, testOutput, true);

    processAppConfigFiles(holder, outputConsumer, context, sourceOutput, testOutput);
  }

  @NotNull
  @Override
  public String getPresentableName() {
    return NAME;
  }

  private static void reportProgress(@NotNull CompileContext context, String message) {
    context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.PROGRESS, message));
  }

  private static void buildSources(ErlangTarget target,
                                   CompileContext context,
                                   ErlangCompilerOptions compilerOptions,
                                   DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                                   BuildOutputConsumer outputConsumer,
                                   File outputDir,
                                   final boolean isTests) throws IOException, ProjectBuildException {
    List<String> dirtyErlangFilePaths = new DirtyFileProcessor<String>() {
      @Nullable
      @Override
      protected String getDirtyElement(@NotNull ErlangTarget target,
                                       @NotNull File file,
                                       @NotNull ErlangSourceRootDescriptor root) throws IOException {
        return (isTests || !root.isTests()) && isSourceOrHeader(file) ? file.getAbsolutePath() : null;
      }
    }.collectDirtyElements(holder);

    List<String> erlangModulePathsToCompile = getErlangModulePaths(target, context, dirtyErlangFilePaths, isTests);
    if (erlangModulePathsToCompile.isEmpty()) {
      reportProgress(context, "Source is up to date");
      return;
    }
    String message = isTests ? "Compile tests for module " : "Compile source code for module ";
    reportProgress(context, message + target.getModule().getName());
    runErlc(target, context, compilerOptions, erlangModulePathsToCompile, outputConsumer, outputDir, isTests);
  }

  private static boolean isSourceOrHeader(@NotNull File file) {
    return file.getName().endsWith(".erl") || file.getName().endsWith(".hrl");
  }

  @NotNull
  private static File getBuildOutputDirectory(@NotNull JpsModule module,
                                              boolean forTests,
                                              @NotNull CompileContext context) throws ProjectBuildException {
    JpsJavaExtensionService instance = JpsJavaExtensionService.getInstance();
    File outputDirectory = instance.getOutputDirectory(module, forTests);
    if (outputDirectory == null) {
      String errorMessage = "No output dir for module " + module.getName();
      context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.ERROR, errorMessage));
      throw new ProjectBuildException(errorMessage);
    }
    if (!outputDirectory.exists()) {
      FileUtil.createDirectory(outputDirectory);
    }
    return outputDirectory;
  }

  private static void processAppConfigFiles(DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder,
                                            BuildOutputConsumer outputConsumer,
                                            CompileContext context,
                                            File... outputDirectories) throws IOException {
    List<File> appConfigFiles = new DirtyFileProcessor<File>() {
      @Nullable
      @Override
      protected File getDirtyElement(@NotNull ErlangTarget target,
                                     @NotNull File file,
                                     @NotNull ErlangSourceRootDescriptor root) throws IOException {
        return isAppConfigFileName(file.getName()) ? file : null;
      }
    }.collectDirtyElements(holder);

    for (File appConfigSrc : appConfigFiles) {
      for (File outputDir : outputDirectories) {
        File appConfigDst = new File(outputDir, getAppConfigDestinationFileName(appConfigSrc.getName()));
        FileUtil.copy(appConfigSrc, appConfigDst);
        reportProgress(context, String.format("Copy %s to %s",appConfigDst.getAbsolutePath(),outputDir.getAbsolutePath()));
        outputConsumer.registerOutputFile(appConfigDst, Collections.singletonList(appConfigSrc.getAbsolutePath()));
      }
    }
  }

  private static boolean isAppConfigFileName(String fileName) {
    return fileName.endsWith(".app") || fileName.endsWith(".app.src");
  }

  @NotNull
  private static String getAppConfigDestinationFileName(String sourceFileName) {
    return StringUtil.trimEnd(sourceFileName, ".src");
  }

  private static void runErlc(ErlangTarget target,
                              CompileContext context,
                              ErlangCompilerOptions compilerOptions,
                              List<String> erlangModulePathsToCompile,
                              BuildOutputConsumer outputConsumer,
                              File outputDirectory,
                              boolean isTest) throws ProjectBuildException, IOException {
    GeneralCommandLine commandLine = getErlcCommandLine(target, context, compilerOptions, outputDirectory, erlangModulePathsToCompile, isTest);
    Process process;
    try {
      process = commandLine.createProcess();
    }
    catch (ExecutionException e) {
      throw new ProjectBuildException("Failed to launch erlang compiler", e);
    }
    BaseOSProcessHandler handler = new BaseOSProcessHandler(process, commandLine.getCommandLineString(), Charset.defaultCharset());
    ProcessAdapter adapter = new ErlangCompilerProcessAdapter(context, NAME, "");
    handler.addProcessListener(adapter);
    handler.startNotify();
    handler.waitFor();
    consumeFiles(outputConsumer, getOutputErlangModuleFiles(erlangModulePathsToCompile, outputDirectory));
  }

  private static GeneralCommandLine getErlcCommandLine(ErlangTarget target,
                                                       CompileContext context,
                                                       ErlangCompilerOptions compilerOptions,
                                                       File outputDirectory,
                                                       List<String> erlangModulePaths,
                                                       boolean isTest) throws ProjectBuildException {
    GeneralCommandLine commandLine = new GeneralCommandLine();
    JpsModule module = target.getModule();
    JpsSdk<JpsDummyElement> sdk = ErlangTargetBuilderUtil.getSdk(context, module);
    File executable = JpsErlangSdkType.getByteCodeCompilerExecutable(sdk.getHomePath());
    commandLine.withWorkDirectory(outputDirectory);
    commandLine.setExePath(executable.getAbsolutePath());
    addCodePath(commandLine, module, target, context);
    addParseTransforms(commandLine, module);
    addDebugInfo(commandLine, compilerOptions.myAddDebugInfoEnabled);
    addIncludePaths(commandLine, module);
    addMacroDefinitions(commandLine, isTest);
    commandLine.addParameters(erlangModulePaths);
    return commandLine;
  }

  private static void addMacroDefinitions(GeneralCommandLine commandLine, boolean isTests) {
    if (isTests) {
      commandLine.addParameters("-DTEST");
    }
  }

  private static void addDebugInfo(@NotNull GeneralCommandLine commandLine, boolean addDebugInfoEnabled) {
    if (addDebugInfoEnabled) {
      commandLine.addParameter("+debug_info");
    }
  }

  private static void addIncludePaths(@NotNull GeneralCommandLine commandLine, @Nullable JpsModule module) {
    if (module == null) return;
    for (JpsTypedModuleSourceRoot<JpsDummyElement> includeDirectory : module.getSourceRoots(ErlangIncludeSourceRootType.INSTANCE)) {
      commandLine.addParameters("-I", includeDirectory.getFile().getPath());
    }
  }

  @NotNull
  private static List<String> getErlangModulePaths(@NotNull ErlangTarget target,
                                                   @NotNull CompileContext context,
                                                   @NotNull List<String> dirtyFilePaths,
                                                   boolean isTest) {
    List<ErlangFileDescriptor> fileDescriptors = getErlangFileDescriptorFromConfig(target, context, isTest);
    return fileDescriptors != null ?
           getSortedErlangModulePathsToCompile(fileDescriptors, dirtyFilePaths) :
           getErlangModulePathsDefault(target, isTest);
  }

  @NotNull
  private static List<String> getSortedErlangModulePathsToCompile(@NotNull List<ErlangFileDescriptor> sortedModuleDescriptors,
                                                                  @NotNull List<String> dirtyModules) {
    SortedModuleDependencyGraph semiGraph = new SortedModuleDependencyGraph(sortedModuleDescriptors);
    GraphGenerator<Node> graph = GraphGenerator.create(semiGraph);
    markDirtyNodes(semiGraph.getNodesByName(dirtyModules), graph);
    return ContainerUtil.mapNotNull(semiGraph.getNodes(), new Function<Node, String>() {
      @Nullable
      @Override
      public String fun(Node node) {
        return node.myDirty && FileUtilRt.extensionEquals(node.myErlangModulePath, "erl") ? node.myErlangModulePath : null;
      }
    });
  }

  @NotNull
  private static List<String> getErlangModulePathsDefault(@NotNull ErlangTarget target, boolean isTests) {
    CommonProcessors.CollectProcessor<File> erlFilesCollector = new CommonProcessors.CollectProcessor<File>() {
      @Override
      protected boolean accept(@NotNull File file) {
        return !file.isDirectory() && FileUtilRt.extensionEquals(file.getName(), "erl");
      }
    };
    List<JpsModuleSourceRoot> sourceRoots = ContainerUtil.newArrayList();
    JpsModule module = target.getModule();
    ContainerUtil.addAll(sourceRoots, module.getSourceRoots(JavaSourceRootType.SOURCE));
    if (isTests) {
      ContainerUtil.addAll(sourceRoots, module.getSourceRoots(JavaSourceRootType.TEST_SOURCE));
    }
    for (JpsModuleSourceRoot root : sourceRoots) {
      FileUtil.processFilesRecursively(root.getFile(), erlFilesCollector);
    }
    return ContainerUtil.map(erlFilesCollector.getResults(), new Function<File, String>() {
      @NotNull
      @Override
      public String fun(@NotNull File file) {
        return file.getAbsolutePath();
      }
    });
  }

  @Nullable
  private static List<ErlangFileDescriptor> getErlangFileDescriptorFromConfig(@NotNull ErlangTarget target,
                                                                              @NotNull CompileContext context,
                                                                              boolean isTests) {
    File dataStorageRoot = context.getProjectDescriptor().dataManager.getDataPaths().getDataStorageRoot();
    File depsConfigFile = new File(dataStorageRoot, DEPENDENCIES_CONFIG_FILE_PATH);
    if (!depsConfigFile.exists()) return null;
    ErlangModuleBuildOrders buildOrders;
    try {
      Document document = JDOMUtil.loadDocument(depsConfigFile);
      buildOrders = XmlSerializer.deserialize(document, ErlangModuleBuildOrders.class);
    }
    catch (XmlSerializationException e) {
      return null;
    }
    catch (JDOMException e) {
      return null;
    }
    catch (IOException e) {
      return null;
    }
    if (buildOrders == null) return null;
    for (ErlangModuleBuildOrderDescriptor buildOrder : buildOrders.myModuleBuildOrderDescriptors) {
      if (StringUtil.equals(buildOrder.myModuleName, target.getModule().getName())) {
        List<ErlangFileDescriptor> modules = buildOrder.myOrderedErlangFilePaths;
        if (isTests) {
          modules = ContainerUtil.concat(modules, buildOrder.myOrderedErlangTestFilePaths);
        }
        return modules;
      }
    }
    return null;
  }

  private static void addParseTransforms(@NotNull GeneralCommandLine commandLine,
                                         @Nullable JpsModule module) throws ProjectBuildException {
    JpsErlangModuleExtension extension = JpsErlangModuleExtension.getExtension(module);
    List<String> parseTransforms = extension != null ? extension.getParseTransforms() : Collections.<String>emptyList();
    if (parseTransforms.isEmpty()) return;
    for (String ptModule : parseTransforms) {
      commandLine.addParameter("+{parse_transform, " + ptModule + "}");
    }
  }

  private static void addCodePath(@NotNull GeneralCommandLine commandLine,
                                  @NotNull JpsModule module,
                                  @NotNull ErlangTarget target,
                                  @NotNull CompileContext context) throws ProjectBuildException {
    List<JpsModule> codePathModules = ContainerUtil.newArrayList();
    collectDependentModules(module, codePathModules, ContainerUtil.<String>newHashSet());
    addModuleToCodePath(commandLine, module, target.isTests(), context);
    for (JpsModule codePathModule : codePathModules) {
      if (codePathModule != module) {
        addModuleToCodePath(commandLine, codePathModule, false, context);
      }
    }
  }

  private static void collectDependentModules(@NotNull JpsModule module,
                                              @NotNull Collection<JpsModule> addedModules,
                                              @NotNull Set<String> addedModuleNames) {
    String moduleName = module.getName();
    if (addedModuleNames.contains(moduleName)) return;
    addedModuleNames.add(moduleName);
    addedModules.add(module);
    for (JpsDependencyElement dependency : module.getDependenciesList().getDependencies()) {
      if (!(dependency instanceof JpsModuleDependency)) continue;
      JpsModuleDependency moduleDependency = (JpsModuleDependency) dependency;
      JpsModule depModule = moduleDependency.getModule();
      if (depModule != null) {
        collectDependentModules(depModule, addedModules, addedModuleNames);
      }
    }
  }

  private static void addModuleToCodePath(@NotNull GeneralCommandLine commandLine,
                                          @NotNull JpsModule module,
                                          boolean forTests,
                                          @NotNull CompileContext context) throws ProjectBuildException {
    File outputDirectory = getBuildOutputDirectory(module, forTests, context);
    commandLine.addParameters("-pa", outputDirectory.getPath());
    for (String rootUrl : module.getContentRootsList().getUrls()) {
      try {
        String path = new URL(rootUrl).getPath();
        commandLine.addParameters("-pa", path);
      }
      catch (MalformedURLException e) {
        context.processMessage(new CompilerMessage(NAME, BuildMessage.Kind.ERROR, "Failed to find content root for module: " + module.getName()));
      }
    }
  }

  private static void markDirtyNodes(@NotNull List<Node> dirtyModules,
                                     @NotNull GraphGenerator<Node> graph) {
    for (Node node : dirtyModules) {
      if (node != null) {
        markDirtyNodes(node, graph);
      }
    }
  }

  private static void markDirtyNodes(@NotNull Node node, @NotNull GraphGenerator<Node> graph) {
    if (node.myDirty) return;
    node.myDirty = true;
    Iterator<Node> childIterator = graph.getOut(node);
    while (childIterator.hasNext()) {
      markDirtyNodes(childIterator.next(), graph);
    }
  }

  @NotNull
  private static List<File> getOutputErlangModuleFiles(@NotNull List<String> erlangModulePathsToCompile,
                                                       @NotNull final File outputDirectory) {
    return ContainerUtil.map(erlangModulePathsToCompile, new Function<String, File>() {
      @Override
      public File fun(String filePath) {
        String name = FileUtil.getNameWithoutExtension(filePath);
        return new File(outputDirectory.getAbsolutePath() + name + ".beam");
      }
    });
  }

  private static void consumeFiles(@NotNull BuildOutputConsumer outputConsumer,
                                   @NotNull List<File> dirtyFilePaths) throws IOException {
    for (File outputFile : dirtyFilePaths) {
      if (outputFile.exists()) {
        outputConsumer.registerOutputFile(outputFile, Collections.singletonList(outputFile.getAbsolutePath()));
      }
    }
  }

  private static abstract class DirtyFileProcessor<T> implements FileProcessor<ErlangSourceRootDescriptor, ErlangTarget> {
    private final List<T> myDirtyElements = ContainerUtil.newArrayList();

    public List<T> collectDirtyElements(@NotNull DirtyFilesHolder<ErlangSourceRootDescriptor, ErlangTarget> holder) throws IOException {
      holder.processDirtyFiles(this);
      return myDirtyElements;
    }

    @Override
    public boolean apply(ErlangTarget erlangTarget,
                         File file,
                         ErlangSourceRootDescriptor erlangSourceRootDescriptor) throws IOException {
      ContainerUtil.addIfNotNull(myDirtyElements, getDirtyElement(erlangTarget, file, erlangSourceRootDescriptor));
      return true;
    }

    @Nullable
    protected abstract T getDirtyElement(@NotNull ErlangTarget target,
                                         @NotNull File file,
                                         @NotNull ErlangSourceRootDescriptor root) throws IOException;
  }

  private static class Node {
    final String myErlangModulePath;
    final List<Node> myDependencies = ContainerUtil.newArrayList();
    public boolean myDirty = false;

    Node(String nodeName) {
      myErlangModulePath = nodeName;
    }
  }

  private static class SortedModuleDependencyGraph implements GraphGenerator.SemiGraph<Node> {
    private final LinkedHashMap<String, Node> myNodePathsMap;

    public SortedModuleDependencyGraph(List<ErlangFileDescriptor> moduleDescriptors) {
      myNodePathsMap = getPathsMap(moduleDescriptors);
      addDependencies(moduleDescriptors);
    }

    @Override
    public Collection<Node> getNodes() {
      return myNodePathsMap.values();
    }

    @Override
    public Iterator<Node> getIn(Node node) {
      return node.myDependencies.iterator();
    }

    @Nullable
    public Node getNode(@NotNull String moduleName) {
      return myNodePathsMap.get(moduleName);
    }

    private void addDependencies(List<ErlangFileDescriptor> moduleDescriptors) {
      for (ErlangFileDescriptor descriptor : moduleDescriptors) {
        Node node = myNodePathsMap.get(descriptor.myErlangModulePath);
        node.myDependencies.addAll(getNodesByName(descriptor.myDependencies));
      }
    }

    @NotNull
    private List<Node> getNodesByName(@NotNull Collection<String> nodes) {
      return ContainerUtil.mapNotNull(nodes, new Function<String, Node>() {
        @Override
        public Node fun(String dependencyName) {
          return myNodePathsMap.get(dependencyName);
        }
      });
    }

    private static LinkedHashMap<String, Node> getPathsMap(List<ErlangFileDescriptor> moduleDescriptors) {
      LinkedHashMap<String, Node> nodePathsMap = ContainerUtil.newLinkedHashMap();
      for (ErlangFileDescriptor descriptor : moduleDescriptors) {
        nodePathsMap.put(descriptor.myErlangModulePath, new Node(descriptor.myErlangModulePath));
      }
      return nodePathsMap;
    }
  }
}

<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.xmlb.annotations.AbstractCollection;
import com.intellij.util.xmlb.annotations.Attribute;
import com.intellij.util.xmlb.annotations.Tag;

import java.util.List;

@Tag("module")
public class ErlangModuleBuildOrderDescriptor {
  @Attribute("name")
  public String myModuleName = "";

  @Tag("erlangModules")
  @AbstractCollection(surroundWithTag = false)
  public List<ErlangFileDescriptor> myOrderedErlangFilePaths = ContainerUtil.newArrayList();

  @Tag("testErlangModules")
  @AbstractCollection(surroundWithTag = false)
  public List<ErlangFileDescriptor> myOrderedErlangTestFilePaths = ContainerUtil.newArrayList();
}

<code block>


package org.intellij.erlang.jps.builder;

import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.jps.model.ErlangIncludeSourceRootType;
import org.intellij.erlang.jps.model.JpsErlangModuleType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.builders.*;
import org.jetbrains.jps.builders.storage.BuildDataPaths;
import org.jetbrains.jps.incremental.CompileContext;
import org.jetbrains.jps.indices.IgnoredFileIndex;
import org.jetbrains.jps.indices.ModuleExcludeIndex;
import org.jetbrains.jps.model.JpsDummyElement;
import org.jetbrains.jps.model.JpsModel;
import org.jetbrains.jps.model.java.JavaSourceRootProperties;
import org.jetbrains.jps.model.java.JavaSourceRootType;
import org.jetbrains.jps.model.java.JpsJavaClasspathKind;
import org.jetbrains.jps.model.java.JpsJavaExtensionService;
import org.jetbrains.jps.model.module.JpsModule;
import org.jetbrains.jps.model.module.JpsTypedModuleSourceRoot;

import java.io.File;
import java.util.*;

public class ErlangTarget extends ModuleBasedTarget<ErlangSourceRootDescriptor> {
  public ErlangTarget(@NotNull JpsModule module, ErlangTargetType targetType) {
    super(targetType, module);
  }

  @Override
  public String getId() {
    return myModule.getName();
  }

  @Override
  public Collection<BuildTarget<?>> computeDependencies(BuildTargetRegistry targetRegistry, TargetOutputIndex outputIndex) {
    return computeDependencies();
  }

  public Collection<BuildTarget<?>> computeDependencies() {
    List<BuildTarget<?>> dependencies = new ArrayList<BuildTarget<?>>();
    Set<JpsModule> modules = JpsJavaExtensionService.dependencies(myModule).includedIn(JpsJavaClasspathKind.compile(isTests())).getModules();
    for (JpsModule module : modules) {
      if (module.getModuleType().equals(JpsErlangModuleType.INSTANCE)) {
        dependencies.add(new ErlangTarget(module, getErlangTargetType()));
      }
    }
    return dependencies;
  }

  @NotNull
  @Override
  public List<ErlangSourceRootDescriptor> computeRootDescriptors(JpsModel model, ModuleExcludeIndex index, IgnoredFileIndex ignoredFileIndex, BuildDataPaths dataPaths) {
    List<ErlangSourceRootDescriptor> result = new ArrayList<ErlangSourceRootDescriptor>();
    for (JpsTypedModuleSourceRoot<JavaSourceRootProperties> root : myModule.getSourceRoots(JavaSourceRootType.SOURCE)) {
      result.add(new ErlangSourceRootDescriptor(root.getFile(), this, false));
    }
    for (JpsTypedModuleSourceRoot<JavaSourceRootProperties> root : myModule.getSourceRoots(JavaSourceRootType.TEST_SOURCE)) {
      result.add(new ErlangSourceRootDescriptor(root.getFile(), this, true));
    }
    for (JpsTypedModuleSourceRoot<JpsDummyElement> root : myModule.getSourceRoots(ErlangIncludeSourceRootType.INSTANCE)) {
      result.add(new ErlangSourceRootDescriptor(root.getFile(), this, false));
    }
    return result;
  }

  @Nullable
  @Override
  public ErlangSourceRootDescriptor findRootDescriptor(String rootId, BuildRootIndex rootIndex) {
    return ContainerUtil.getFirstItem(rootIndex.getRootDescriptors(new File(rootId), Collections.singletonList(getErlangTargetType()), null));
  }

  @NotNull
  @Override
  public String getPresentableName() {
    return "Erlang '" + myModule.getName() + "'";
  }

  @NotNull
  @Override
  public Collection<File> getOutputRoots(CompileContext context) {
    return ContainerUtil.newArrayList(JpsJavaExtensionService.getInstance().getOutputDirectory(myModule, false),
                                      JpsJavaExtensionService.getInstance().getOutputDirectory(myModule, true));
  }

  @Override
  public boolean isTests() {
    return false;
  }

  public ErlangTargetType getErlangTargetType() {
    return (ErlangTargetType) getTargetType();
  }
}

<code block>


package org.intellij.erlang.jps.builder;


import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.xmlb.annotations.AbstractCollection;
import com.intellij.util.xmlb.annotations.Attribute;
import com.intellij.util.xmlb.annotations.Tag;
import org.jetbrains.annotations.NotNull;

import java.util.List;

@Tag("module")
public class ErlangFileDescriptor {
  @Attribute("path")
  public String myErlangModulePath;

  @Tag("dependencies")
  @AbstractCollection(surroundWithTag = false, elementTag = "dependency")
  public List<String> myDependencies;

  @SuppressWarnings("unused") 
  public ErlangFileDescriptor() {
    myDependencies = ContainerUtil.newArrayList();
  }

  public ErlangFileDescriptor(@NotNull String erlangModulePath, @NotNull List<String> dependencies) {
    myErlangModulePath = erlangModulePath;
    myDependencies = dependencies;
  }
}

<code block>


package org.intellij.erlang.jps.builder;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.jps.builders.BuildRootDescriptor;
import org.jetbrains.jps.builders.BuildTarget;

import java.io.File;
import java.io.FileFilter;

public class ErlangSourceRootDescriptor extends BuildRootDescriptor {
  private File myRoot;
  private final ErlangTarget myErlangTarget;
  private boolean myTests;

  public ErlangSourceRootDescriptor(File root, ErlangTarget erlangTarget, boolean isTests) {
    myRoot = root;
    myErlangTarget = erlangTarget;
    myTests = isTests;
  }

  @Override
  public String getRootId() {
    return myRoot.getAbsolutePath();
  }

  @Override
  public File getRootFile() {
    return myRoot;
  }

  @Override
  public BuildTarget<?> getTarget() {
    return myErlangTarget;
  }

  @NotNull
  @Override
  public FileFilter createFileFilter() {
    return new FileFilter() {
      @Override
      public boolean accept(@NotNull File file) {
        String name = file.getName();
        return name.endsWith(".erl") ||
               name.endsWith(".app") ||
               name.endsWith(".app.src") ||
               name.endsWith(".hrl");
      }
    };
  }

  public boolean isTests() {
    return myTests;
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.compiler.impl.ModuleCompileScope;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.CompileScope;
import com.intellij.openapi.compiler.CompilerMessage;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleManager;
import com.intellij.openapi.module.ModuleType;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.projectRoots.impl.SdkConfigurationUtil;
import com.intellij.openapi.roots.CompilerModuleExtension;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.openapi.roots.ProjectRootManager;
import com.intellij.openapi.util.SystemInfo;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.io.FileUtilRt;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.testFramework.CompilerTester;
import com.intellij.testFramework.PlatformTestCase;
import com.intellij.testFramework.PsiTestUtil;
import com.intellij.util.ArrayUtil;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.facet.ErlangFacet;
import org.intellij.erlang.jps.model.ErlangIncludeSourceRootType;
import org.intellij.erlang.module.ErlangModuleType;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.model.java.JavaSourceRootType;
import org.jetbrains.jps.model.module.JpsModuleSourceRootType;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;


public abstract class ErlangCompilationTestBase extends PlatformTestCase {
  public static final String SDK_PATH = "/usr/lib/erlang/";
  protected CompilationRunner myCompilationRunner;

  public ErlangCompilationTestBase() {
    assertTrue("Unsupported OS.", SystemInfo.isLinux);
  }

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    myCompilationRunner = new CompilationRunner(myModule);
    ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Object, Exception>() {
      @Nullable
      @Override
      public Object compute() throws Exception {
        Sdk sdk = SdkConfigurationUtil.createAndAddSDK(SDK_PATH, ErlangSdkType.getInstance());
        ProjectRootManager.getInstance(myProject).setProjectSdk(sdk);
        addSourceRoot(myModule, "src", false);
        addSourceRoot(myModule, "tests", true);
        ErlangFacet.createFacet(myModule);
        return null;
      }
    });
  }

  @Override
  protected ModuleType getModuleType() {
    return ErlangModuleType.getInstance();
  }

  @Override
  protected void tearDown() throws Exception {
    myCompilationRunner.tearDown();
    super.tearDown();
  }

  @Override
  protected boolean isRunInWriteAction() {
    return false;
  }

  protected Module createModuleInOwnDirectoryWithSourceAndTestRoot(final String moduleName) throws Exception {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<Module, IOException>() {
      @Override
      public Module compute() throws IOException {
        Module module = createModuleInDirectory(moduleName);
        ErlangFacet.createFacet(module);
        addSourceRoot(module, "src", false);
        addSourceRoot(module, "tests", true);
        return module;
      }
    });
  }

  @NotNull
  private Module createModuleInDirectory(String moduleName) throws IOException {
    VirtualFile baseDir = VfsUtil.createDirectoryIfMissing(myProject.getBaseDir(), moduleName);
    File moduleFile = new File(FileUtil.toSystemDependentName(baseDir.getPath()), moduleName + ".iml");
    FileUtil.createIfDoesntExist(moduleFile);
    myFilesToDelete.add(moduleFile);
    VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(moduleFile);
    assertNotNull(virtualFile);
    return ModuleManager.getInstance(myProject).newModule(virtualFile.getPath(), ErlangModuleType.getInstance().getId());
  }

  private CompileScope createModulesCompileScope(Module[] modules) {
    return new ModuleCompileScope(myProject, modules, false);
  }

  protected static VirtualFile addTestFile(Module module, String relativePath, String content) throws IOException {
    return addFile(module, relativePath, content, true);
  }

  protected static VirtualFile addSourceFile(Module module, String relativePath, String content) throws IOException {
    return addFile(module, relativePath, content, false);
  }

  protected static VirtualFile addFile(final @NotNull Module module,
                                       final @NotNull String relativePath,
                                       final @NotNull String content,
                                       final boolean toTests) throws IOException {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        JavaSourceRootType rootType = toTests ? JavaSourceRootType.TEST_SOURCE : JavaSourceRootType.SOURCE;
        List<VirtualFile> sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots(rootType);
        VirtualFile sourceDir = ContainerUtil.getFirstItem(sourceRoots);
        assertNotNull(sourceDir);
        return addFile(sourceDir, relativePath, content);
      }
    });
  }
  protected static VirtualFile addFileToDirectory(final @NotNull VirtualFile sourceDir,
                                                  final @NotNull String relativePath,
                                                  final @NotNull String content) throws IOException {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        return addFile(sourceDir, relativePath, content);
      }
    });
  }
  protected static VirtualFile addIncludeRoot(@NotNull final Module module,
                                              @NotNull final String sourceRootName) throws IOException {
    return ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        return addSourceRoot(module, sourceRootName, ErlangIncludeSourceRootType.INSTANCE);
      }
    });

  }

  protected static void addGlobalParseTransform(final Module module, final Collection<String> parseTransform) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
      @Override
      public void run() {
        ErlangFacet erlangFacet = ErlangFacet.getFacet(module);
        assertNotNull(erlangFacet);
        erlangFacet.getConfiguration().addParseTransforms(parseTransform);
      }
    });
  }

  protected static void assertSourcesCompiled(@NotNull Module module, boolean tests) {
    String[] sources = getSourceFiles(module, tests);
    assertContains(getOutputDirectory(module, tests), ContainerUtil.mapNotNull(sources, new Function<String, String>() {
      @Nullable
      @Override
      public String fun(String source) {
        return getExpectedOutputFileName(source);
      }
    }));
  }

  protected static void assertContains(@Nullable VirtualFile parentPath, List<String> fileNames) {
    assertNotNull(parentPath);
    List<String> actual = getChildrenNames(parentPath);
    assertUnorderedElementsAreEqual(actual, fileNames);
  }

  protected static <T> void assertUnorderedElementsAreEqual(Collection<T> actual, Collection<T> expected) {
    assertEquals(ContainerUtil.newHashSet(expected), ContainerUtil.newHashSet(actual));
  }

  @Nullable
  protected static File getOutputFile(Module module, VirtualFile sourceFile, boolean isTest) {
    VirtualFile outputDirectory = getOutputDirectory(module, isTest);
    assertNotNull(outputDirectory);
    String expectedOutputFileName = getExpectedOutputFileName(sourceFile.getName());
    return expectedOutputFileName == null ? null : new File(outputDirectory.getCanonicalPath(), expectedOutputFileName);
  }

  @NotNull
  private static VirtualFile addFile(VirtualFile sourceDir, String relativePath, String content) throws IOException {
    VirtualFile sourceFile = sourceDir.createChildData(ErlangCompilationTestBase.class, relativePath);
    VfsUtil.saveText(sourceFile, content);
    return sourceFile;
  }

  @NotNull
  private static VirtualFile addSourceRoot(@NotNull Module module,
                                           @NotNull String sourceRootName,
                                           @NotNull JpsModuleSourceRootType<?> rootType) throws IOException {
    VirtualFile moduleFile = module.getModuleFile();
    assertNotNull(moduleFile);
    PsiTestUtil.addContentRoot(module, moduleFile.getParent());
    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();
    assertSize(1, contentRoots);

    VirtualFile sourceDir = contentRoots[0].createChildDirectory(ErlangCompilationTestBase.class, sourceRootName);
    PsiTestUtil.addSourceRoot(module, sourceDir, rootType);
    return sourceDir;
  }

  @NotNull
  private static VirtualFile addSourceRoot(@NotNull Module module,
                                           @NotNull String sourceRootName,
                                           boolean isTestSourceRoot) throws IOException {
    JavaSourceRootType rootType = isTestSourceRoot? JavaSourceRootType.TEST_SOURCE:JavaSourceRootType.SOURCE;
    return addSourceRoot(module, sourceRootName,rootType);
  }

  @NotNull
  private static String[] getSourceFiles(@NotNull Module module, boolean isTestSources) {
    List<VirtualFile> sourceRoots = ModuleRootManager.getInstance(module).getSourceRoots(JavaSourceRootType.SOURCE);
    if (isTestSources) {
      List<VirtualFile> testRoots = ModuleRootManager.getInstance(module).getSourceRoots(JavaSourceRootType.TEST_SOURCE);
      sourceRoots = ContainerUtil.concat(sourceRoots, testRoots);
    }
    List<String> result = ContainerUtil.concat(ContainerUtil.mapNotNull(sourceRoots, new Function<VirtualFile, List<String>>() {
      @Override
      public List<String> fun(VirtualFile root) {
        return getChildrenNames(root);
      }
    }));
    return ArrayUtil.toStringArray(result);
  }

  @Nullable
  private static VirtualFile getOutputDirectory(@NotNull Module module, boolean isTest) {
    CompilerModuleExtension instance = CompilerModuleExtension.getInstance(module);
    assertNotNull(instance);
    return isTest ? instance.getCompilerOutputPathForTests() : instance.getCompilerOutputPath();
  }

  @Nullable
  private static String getExpectedOutputFileName(@NotNull String relativePath) {
    File file = new File(relativePath);
    String name = FileUtil.getNameWithoutExtension(file);
    CharSequence extension = FileUtilRt.getExtension(relativePath);
    if ("erl".equals(extension)) {
      return name + ".beam";
    }
    if ("app".equals(extension) || "app.src".equals(extension)) {
      return name + ".app";
    }
    return null;
  }

  @NotNull
  private static List<String> getChildrenNames(VirtualFile root) {
    return ContainerUtil.mapNotNull(root.getChildren(), new Function<VirtualFile, String>() {
      @Override
      public String fun(VirtualFile virtualFile) {
        return virtualFile.getName();
      }
    });
  }

  protected class CompilationRunner {
    private CompileScope myScope;
    private CompilerTester myTester;

    CompilationRunner(@NotNull Module... moduleNames) throws Exception {
      this(createModulesCompileScope(moduleNames));
    }

    CompilationRunner(@NotNull CompileScope scope) throws Exception {
      myScope = scope;
      myTester = new CompilerTester(myProject, Arrays.asList(scope.getAffectedModules()));
    }

    public void compile() {
      List<CompilerMessage> messages = myTester.make(myScope);
      for (CompilerMessage message : messages) {
        switch (message.getCategory()) {
          case ERROR:
            fail(message.getMessage());
            break;
          case WARNING:
            LOG.warn(message.getMessage());
            break;
          case INFORMATION:
            LOG.info(message.getMessage());
            break;
          case STATISTICS:
            LOG.info(message.getMessage());
            break;
          default:
            throw new AssertionError();
        }
      }
    }

    public void touch(@NotNull VirtualFile file) throws IOException {
      myTester.touch(file);
    }

    public void tearDown() {
      myTester.tearDown();
    }
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.module.ModuleType;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.vfs.VfsUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.testFramework.ModuleTestCase;
import com.intellij.testFramework.PsiTestUtil;
import com.intellij.util.Function;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.jps.builder.ErlangFileDescriptor;
import org.intellij.erlang.jps.builder.ErlangModuleBuildOrderDescriptor;
import org.intellij.erlang.module.ErlangModuleType;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.io.IOException;
import java.util.List;

public class ErlangDependenciesResolutionTest extends ModuleTestCase {
  @Override
  protected void setUp() throws Exception {
    super.setUp();
    setUpModule();
    String sourceDirectoryPath = getSourceDirectoryPath();
    if (directoryExists(sourceDirectoryPath)) {
      setUpSourcePath(sourceDirectoryPath);
    }
    String testsDirectoryPath = getTestsDirectoryPath();
    if (directoryExists(testsDirectoryPath)) {
      setUpTestsPath(testsDirectoryPath);
    }
  }

  @Override
  protected ModuleType getModuleType() {
    return ErlangModuleType.getInstance();
  }

  private void setUpSourcePath(String sourcePath) throws IOException {
    doSetUpSourcePath(sourcePath, false);
  }

  private void setUpTestsPath(String sourcePath) throws IOException {
    doSetUpSourcePath(sourcePath, true);
  }

  private void doSetUpSourcePath(final String sourcePath, boolean isTestSource) throws IOException {
    final String sourceDirectoryName = isTestSource ? "test" : "src";
    final VirtualFile moduleFile = myModule.getModuleFile();
    assertNotNull(moduleFile);
    VirtualFile moduleSourceDir = ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {
      @Override
      public VirtualFile compute() throws IOException {
        VirtualFile moduleSourceDir = VfsUtil.createDirectoryIfMissing(moduleFile.getParent(), sourceDirectoryName);
        FileUtil.copyDirContent(new File(sourcePath), new File(moduleSourceDir.getPath()));
        VfsUtil.markDirtyAndRefresh(false, true, true, moduleSourceDir);
        return moduleSourceDir;
      }
    });
    PsiTestUtil.addSourceRoot(myModule, moduleSourceDir, isTestSource);
  }

  private String getSourceDirectoryPath() {
    return getTestDataRoot() + "src";
  }

  private String getTestsDirectoryPath() {
    return getTestDataRoot() + "test";
  }

  private String getTestDataRoot() {
    return "testData/compilation/" + getTestName(false) + "/";
  }

  private static boolean directoryExists(String dirPath) {
    File dir = new File(dirPath);
    return dir.exists() && dir.isDirectory();
  }

  public void testCyclicDependency() {
    try {
      ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
      fail("Expected a cyclic dependency exception to be thrown.");
    } catch (ErlangPrepareDependenciesCompileTask.CyclicDependencyFoundException ignored) {
    }
  }

  public void testDependenciesAreCompiledFirst() throws Exception {
    ErlangModuleBuildOrderDescriptor moduleBuildOrder = ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
    assertSameErlangFiles(moduleBuildOrder.myOrderedErlangFilePaths, "parse_transform1", "parse_transform2", "behaviour1", "module1");
  }

  public void testDependenciesWithIncludes() throws Exception {
    ErlangModuleBuildOrderDescriptor moduleBuildOrder = ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
    assertSameErlangFiles(moduleBuildOrder.myOrderedErlangFilePaths, "parse_transform1", "header1", "behaviour1", "header2", "module1");
  }

  public void testTestsDependency() throws Exception {
    ErlangModuleBuildOrderDescriptor moduleBuildOrder = ErlangPrepareDependenciesCompileTask.getModuleBuildOrder(myModule);
    assertSameErlangFiles(moduleBuildOrder.myOrderedErlangFilePaths, "src_parse_transform");
    assertSameErlangFiles(moduleBuildOrder.myOrderedErlangTestFilePaths, "test_parse_transform", "test");
  }

  private static void assertSameErlangFiles(List<ErlangFileDescriptor> moduleDescriptors, String... expectedModules) {
    List<String> actualModules = ContainerUtil.map(getModulePaths(moduleDescriptors), new Function<String, String>() {
      @Override
      public String fun(String path) {
        return FileUtil.getNameWithoutExtension(new File(path));
      }
    });
    assertOrderedEquals(actualModules, expectedModules);
  }
  @NotNull
  private static List<String> getModulePaths(List<ErlangFileDescriptor> buildOrder) {
    return ContainerUtil.mapNotNull(buildOrder, new Function<ErlangFileDescriptor, String>() {
      @Override
      public String fun(ErlangFileDescriptor erlangFileDescriptor) {
        return erlangFileDescriptor.myErlangModulePath;
      }
    });
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.util.Pair;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;

import java.util.List;

class ErlangModuleTextGenerator {
  private ErlangModuleTextGenerator() {
  }

  @NotNull
  public static ErlangModuleTextBuilder module(@NotNull String moduleName) {
    return new ErlangModuleTextBuilder(moduleName);
  }

  @NotNull
  public static ParseTransformBuilder pt(@NotNull String moduleName) {
    return new ParseTransformBuilder(moduleName);
  }

  @NotNull
  public static BehaviourBuilder behaviour(@NotNull String moduleName) {
    return new BehaviourBuilder(moduleName);
  }

  static class ErlangModuleTextBuilder {
    private final String myModuleName;
    private final List<Pair<String, Integer>> myExports = ContainerUtil.newArrayList();
    private final List<BehaviourBuilder> myBehaviours = ContainerUtil.newArrayList();
    private final List<String> myParseTransforms = ContainerUtil.newArrayList();
    private final List<String> myIncludes = ContainerUtil.newArrayList();

    public ErlangModuleTextBuilder(@NotNull String moduleName) {
      myModuleName = moduleName;
    }

    public String getModuleName() {
      return myModuleName;
    }

    public ErlangModuleTextBuilder pt(@NotNull String moduleName) {
      myParseTransforms.add(moduleName);
      return this;
    }

    public ErlangModuleTextBuilder behaviour(@NotNull BehaviourBuilder behaviour) {
      myBehaviours.add(behaviour);
      myExports.addAll(behaviour.myCallbacks);
      return this;
    }

    public ErlangModuleTextBuilder include(@NotNull String modulePath) {
      myIncludes.add(modulePath);
      return this;
    }

    @NotNull
    public String build() {
      StringBuilder builder = new StringBuilder();
      appendModule(builder);
      appendIncludes(builder);
      appendBehaviour(builder);
      appendParseTransforms(builder);
      appendExports(builder);
      build(builder);
      return builder.toString();
    }

    private void appendIncludes(StringBuilder builder) {
      for (String include : myIncludes) {
        builder.append("-include(\"").append(include).append("\").\n");
      }
    }

    protected void build(@NotNull StringBuilder builder) {
      appendFunctions(builder);
    }

    @NotNull
    protected static <T> StringBuilder commaSeparated(@NotNull StringBuilder sb,
                                                      @NotNull List<T> items,
                                                      @NotNull ItemFormatter<T> formatter) {
      String separator = ", ";
      for (T item : items) {
        formatter.format(sb, item).append(separator);
      }
      sb.setLength(items.isEmpty() ? sb.length() : sb.length() - separator.length());
      return sb;
    }

    private void appendFunctions(@NotNull StringBuilder builder) {
      for (Pair<String, Integer> functionEntry : myExports) {
        appendFunction(builder, functionEntry.first, functionEntry.second);
      }
    }

    private void appendExports(@NotNull StringBuilder builder) {
      if (myExports.isEmpty()) return;

      builder.append("-export([");
      commaSeparated(builder, myExports, new ItemFormatter<Pair<String, Integer>>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Pair<String, Integer> export) {
          return sb.append(export.first).append("/").append(export.second);
        }
      });
      builder.append("]).\n");
    }

    private void appendModule(@NotNull StringBuilder builder) {
      builder.append("-module(").append(myModuleName).append(").\n");
    }

    private void appendBehaviour(@NotNull StringBuilder builder) {
      for (BehaviourBuilder behaviour : myBehaviours) {
        builder.append("-behaviour(").append(behaviour.getModuleName()).append(").\n");
      }
    }

    private static void appendFunction(@NotNull StringBuilder builder, @NotNull String functionName, int arity) {
      List<Integer> argumentIndices = ContainerUtil.newArrayListWithCapacity(arity);
      for (int i = 0; i < arity; i++) {
        argumentIndices.add(i);
      }

      builder.append(functionName).append("(");
      commaSeparated(builder, argumentIndices, new ItemFormatter<Integer>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Integer argumentIdx) {
          return sb.append("_Arg").append(argumentIdx);
        }
      });
      builder.append(") -> ok.\n");
    }

    private void appendParseTransforms(@NotNull StringBuilder builder) {
      if (myParseTransforms.isEmpty()) return;

      builder.append("-compile([");
      commaSeparated(builder, myParseTransforms, new ItemFormatter<String>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull String pt) {
          return sb.append("{parse_transform, ").append(pt).append("}");
        }
      });
      builder.append("]).\n");
    }

    protected interface ItemFormatter<T> {
      @NotNull
      StringBuilder format(@NotNull StringBuilder sb, @NotNull T item);
    }
  }

  static class ParseTransformBuilder extends ErlangModuleTextBuilder {
    public ParseTransformBuilder(@NotNull String moduleName) {
      super(moduleName);
    }

    @Override
    protected void build(@NotNull StringBuilder builder) {
      createTransform(builder);
      super.build(builder);
    }

    private static void createTransform(@NotNull StringBuilder builder) {
      builder.append("-export([parse_transform/2]).\n");
      builder.append("parse_transform(Forms, _Options) -> Forms.\n");
    }
  }

  static class BehaviourBuilder extends ErlangModuleTextBuilder {
    private final List<Pair<String, Integer>> myCallbacks = ContainerUtil.newArrayList();

    public BehaviourBuilder(@NotNull String moduleName) {
      super(moduleName);
    }

    public BehaviourBuilder callback(@NotNull String name, int arity) {
      myCallbacks.add(Pair.createNonNull(name, arity));
      return this;
    }

    @Override
    protected void build(@NotNull StringBuilder builder) {
      builder.append("-export([behaviour_info/1]).\n");
      builder.append("behaviour_info(callbacks) ->[");
      commaSeparated(builder, myCallbacks, new ItemFormatter<Pair<String, Integer>>() {
        @NotNull
        @Override
        public StringBuilder format(@NotNull StringBuilder sb, @NotNull Pair<String, Integer> callback) {
          return sb.append("{").append(callback.first).append(", ").append(callback.second).append("}");
        }
      });
      builder.append("].\n");
      super.build(builder);
    }
  }
}

<code block>


package org.intellij.erlang.compilation;

import com.intellij.openapi.module.Module;
import com.intellij.openapi.roots.ModuleRootModificationUtil;
import com.intellij.openapi.vfs.VirtualFile;

import java.io.File;
import java.util.Collections;

import static org.intellij.erlang.compilation.ErlangModuleTextGenerator.*;

public class ErlangModuleCompilationTest extends ErlangCompilationTestBase {
  public void testBuildSingleFile() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithBehaviourInSingleModule() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithParseTransformInDifferentModule() throws Exception {
    Module otherModule = createModuleInOwnDirectoryWithSourceAndTestRoot("other");
    ModuleRootModificationUtil.addDependency(myModule, otherModule);
    addSourceFile(otherModule, "parse_transform1.erl", pt("parse_transform1").build());
    addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    compileAndAssertOutput(myModule, otherModule);
  }

  public void testBuildWithParseTransformInSingleModule() throws Exception {
    addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testRebuildWithNewFile() throws Exception {
    final VirtualFile sourceFile = addSourceFile(myModule, "module1.erl", module("module1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long modificationTime = lastOutputModificationTime(myModule, sourceFile);
    addSourceFile(myModule, "module2.erl", module("module2").build());
    myCompilationRunner.compile();
    assertEquals(modificationTime, lastOutputModificationTime(myModule, sourceFile));
  }

  public void testRebuildWithModificationWithoutDependencies() throws Exception {
    final VirtualFile sourceFile1 = addSourceFile(myModule, "module1.erl", module("module1").build());
    VirtualFile sourceFile2 = addSourceFile(myModule, "module2.erl", module("module2").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long lastModificationTime1 = lastOutputModificationTime(myModule, sourceFile1);
    long lastModificationTime2 = lastOutputModificationTime(myModule, sourceFile2);
    myCompilationRunner.touch(sourceFile2);
    myCompilationRunner.compile();
    assertEquals(lastModificationTime1, lastOutputModificationTime(myModule, sourceFile1));
    assertTrue(lastModificationTime2 != lastOutputModificationTime(myModule, sourceFile2));
  }

  public void testRebuildWithModificationParseTransform() throws Exception {
    VirtualFile parseTransformSourceFile = addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long parseTransformModificationTime = lastOutputModificationTime(myModule, parseTransformSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(parseTransformSourceFile);
    myCompilationRunner.compile();
    assertTrue(parseTransformModificationTime != lastOutputModificationTime(myModule, parseTransformSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testRebuildWithModificationBehaviour() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    VirtualFile behaviourSourceFile = addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long behaviourModificationTime = lastOutputModificationTime(myModule, behaviourSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(behaviourSourceFile);
    myCompilationRunner.compile();
    assertTrue(behaviourModificationTime != lastOutputModificationTime(myModule, behaviourSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testRebuildWithModificationBehaviourAndUnchangeableParseTransform() throws Exception {
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    VirtualFile behaviourSourceFile = addSourceFile(myModule, "behaviour1.erl", behaviour.build());
    VirtualFile parseTransformSourceFile = addSourceFile(myModule, "parse_transform1.erl", pt("parse_transform1").build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).pt("parse_transform1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long behaviourModificationTime = lastOutputModificationTime(myModule, behaviourSourceFile);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    long parseTransformModificationTime = lastOutputModificationTime(myModule, parseTransformSourceFile);
    myCompilationRunner.touch(behaviourSourceFile);
    myCompilationRunner.compile();
    assertEquals(parseTransformModificationTime, lastOutputModificationTime(myModule, parseTransformSourceFile));
    assertTrue(behaviourModificationTime != lastOutputModificationTime(myModule, behaviourSourceFile));
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testBuildWithIncludes() throws Exception {
    addSourceFile(myModule, "header.hrl", "");
    addSourceFile(myModule, "module2.erl", module("module2").include("header.hrl").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
  }

  public void testRebuildWithInclude() throws Exception {
    VirtualFile headerFile = addSourceFile(myModule, "header.hrl", "");
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").include("header.hrl").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(headerFile);
    myCompilationRunner.compile();
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testRebuildWithIncludesDirectory() throws Exception {
    VirtualFile includeSourceRoot = addIncludeRoot(myModule, "include");
    VirtualFile headerFile = addFileToDirectory(includeSourceRoot, "header.hrl", "");
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").include("header.hrl").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(headerFile);
    myCompilationRunner.compile();
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }
  public void testRebuildWithTransitiveDependencies() throws Exception {
    VirtualFile headerFile = addSourceFile(myModule, "header.hrl", "");
    BehaviourBuilder behaviour = behaviour("behaviour1").callback("foo", 0);
    addSourceFile(myModule, "behaviour1.erl", behaviour.include("header.hrl").build());
    VirtualFile sourceFileWithDependency = addSourceFile(myModule, "module1.erl", module("module1").behaviour(behaviour).build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, false);
    long sourceModificationTime = lastOutputModificationTime(myModule, sourceFileWithDependency);
    myCompilationRunner.touch(headerFile);
    myCompilationRunner.compile();
    assertTrue(sourceModificationTime != lastOutputModificationTime(myModule, sourceFileWithDependency));
  }

  public void testBuildWithTestSource() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    addTestFile(myModule, "test1.erl", module("test1").build());
    myCompilationRunner.compile();
    assertSourcesCompiled(myModule, true);
    assertSourcesCompiled(myModule, false);
  }

  public void testBuildWithGlobalParseTransform() throws Exception {
    addSourceFile(myModule, "module1.erl", module("module1").build());
    Module otherModule = createModuleInOwnDirectoryWithSourceAndTestRoot("other");
    addSourceFile(otherModule, "parse_transform1.erl", pt("parse_transform1").build());
    addGlobalParseTransform(myModule, Collections.singleton("parse_transform1"));
    ModuleRootModificationUtil.addDependency(myModule, otherModule);
    compileAndAssertOutput(myModule, otherModule);
  }

  private void compileAndAssertOutput(Module... modules) throws Exception {
    CompilationRunner compilationRunner = new CompilationRunner(modules);
    try {
      compilationRunner.compile();
      for (Module module : modules) {
        assertSourcesCompiled(module, false);
      }
    }
    finally {
      compilationRunner.tearDown();
    }
  }

  private static long lastOutputModificationTime(Module module, VirtualFile sourceFile) {
    File outputFile = getOutputFile(module, sourceFile, false);
    assertNotNull(outputFile);
    return outputFile.lastModified();
  }
}

<code block>


package org.intellij.erlang.inspection;

import com.intellij.codeInspection.LocalInspectionToolSession;
import com.intellij.codeInspection.LocalQuickFix;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiReference;
import com.intellij.psi.util.PsiTreeUtil;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.quickfixes.ErlangCreateFunctionQuickFix;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class ErlangUnresolvedFunctionInspection extends ErlangInspectionBase {
  @NotNull
  @Override
  protected ErlangVisitor buildErlangVisitor(@NotNull final ProblemsHolder holder,
                                             @NotNull LocalInspectionToolSession session) {
    return new ErlangVisitor() {
      @Override
      public void visitFunctionCallExpression(@NotNull ErlangFunctionCallExpression o) {
        PsiReference reference = o.getReference();
        if (reference instanceof ErlangFunctionReference && reference.resolve() == null) {
          if (o.getQAtom().getMacros() != null) return;
          ErlangFunctionReference r = (ErlangFunctionReference) reference;

          String name = r.getName();
          int arity = r.getArity();

          if (arity < 0) return;
          if (ErlangBifTable.isBif("erlang", name, arity)) return;

          String signature = r.getSignature();

          PsiElement parent = o.getParent();
          if (parent instanceof ErlangGlobalFunctionCallExpression) {
            ErlangModuleRef moduleRef = ((ErlangGlobalFunctionCallExpression) parent).getModuleRef();
            if (moduleRef.getQAtom().getMacros() != null) return;
            String moduleName = moduleRef.getText();
            if (ErlangBifTable.isBif(moduleName, name, arity)) return;
            signature = moduleName + ":" + signature;
          }

          LocalQuickFix[] qfs = parent instanceof ErlangGenericFunctionCallExpression || parent instanceof ErlangGlobalFunctionCallExpression ?
            new LocalQuickFix[]{} :
            new LocalQuickFix[]{new ErlangCreateFunctionQuickFix(name, arity)};

          registerProblem(holder, o.getNameIdentifier(), "Unresolved function " + "'" + signature + "'", qfs);
        }
      }

      @Override
      public void visitSpecFun(@NotNull ErlangSpecFun o) {
        inspect(o, o.getQAtom(), o.getReference());
      }

      @Override
      public void visitFunctionWithArity(@NotNull ErlangFunctionWithArity o) {
        inspect(o, o.getQAtom(), o.getReference());
      }

      private void inspect(PsiElement what, ErlangQAtom target, @Nullable PsiReference reference) {
        if (PsiTreeUtil.getParentOfType(what, ErlangCallbackSpec.class) != null || target.getMacros() != null ||
          !(reference instanceof ErlangFunctionReference) || reference.resolve() != null) {
          return;
        }

        ErlangFunctionReference r = (ErlangFunctionReference) reference;
        if (r.getArity() < 0) return; 
        LocalQuickFix[] qfs = PsiTreeUtil.getNextSiblingOfType(what, ErlangModuleRef.class) != null ?
          new LocalQuickFix[]{} : new LocalQuickFix[]{new ErlangCreateFunctionQuickFix(r.getName(), r.getArity())};
        registerProblem(holder, target, "Unresolved function " + "'" + r.getSignature() + "'", qfs);
      }
    };
  }
}

<code block>


package org.intellij.erlang.inspection;

import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.psi.PsiReference;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.psi.impl.ErlangPsiImplUtil;
import org.jetbrains.annotations.NotNull;

import java.util.Set;

public class ErlangIllegalGuardInspection extends ErlangInspectionBase {
  private static final String ERROR = "Illegal guard expression";

  private static final Set<String> BIFS_ALLOWED_IN_GUARDS = ContainerUtil.immutableSet(
    "abs/1", "bit_size/1", "binary_part/3",
    "byte_size/1", "binary_part/2", "element/2",
    "float/1", "hd/1", "is_atom/1", "is_binary/1",
    "is_bitstring/1", "is_boolean/1", "is_float/1",
    "is_function/1", "is_function/2", "is_integer/1",
    "is_list/1", "is_map/1", "is_number/1",
    "is_pid/1", "is_port/1", "is_record/2",
    "is_record/3", "is_reference/1", "is_tuple/1",
    "length/1", "map_size/1", "node/1",
    "node/0", "round/1", "self/0",
    "size/1", "tl/1", "trunc/1", "tuple_size/1");

  @Override
  protected void checkFile(@NotNull ErlangFile file, @NotNull ProblemsHolder holder) {
    for (ErlangFunction function : file.getFunctions()) {
      for (ErlangFunctionClause clause : function.getFunctionClauseList()) {
        ErlangClauseGuard guard = clause.getClauseGuard();
        if (guard != null) {
          guard.accept(new GuardInspector(holder));
        }
        ErlangClauseBody clauseBody = clause.getClauseBody();
        if (clauseBody != null) {
          clauseBody.accept(new GuardDetector(holder));
        }
      }
    }
  }

  private class GuardDetector extends ErlangRecursiveVisitor {
    private final ProblemsHolder myHolder;

    public GuardDetector(ProblemsHolder holder) {
      this.myHolder = holder;
    }

    @Override
    public void visitClauseGuard(@NotNull ErlangClauseGuard o) {
      ErlangGuard guard = o.getGuard();
      if (guard != null) {
        guard.accept(new GuardInspector(myHolder));
      }
    }

    @Override
    public void visitGuard(@NotNull ErlangGuard o) {
      o.accept(new GuardInspector(myHolder));
    }
  }

  private class GuardInspector extends ErlangRecursiveVisitor {
    private final ProblemsHolder myHolder;

    public GuardInspector(ProblemsHolder holder) {
      this.myHolder = holder;
    }

    @Override
    public void visitAssignmentExpression(@NotNull ErlangAssignmentExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitCaseExpression(@NotNull ErlangCaseExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitReceiveExpression(@NotNull ErlangReceiveExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitTryExpression(@NotNull ErlangTryExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitListComprehension(@NotNull ErlangListComprehension o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitBeginEndExpression(@NotNull ErlangBeginEndExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitSendExpression(@NotNull ErlangSendExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitListOpExpression(@NotNull ErlangListOpExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitCatchExpression(@NotNull ErlangCatchExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitFunExpression(@NotNull ErlangFunExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitAnonymousCallExpression(@NotNull ErlangAnonymousCallExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitIfExpression(@NotNull ErlangIfExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitGenericFunctionCallExpression(@NotNull ErlangGenericFunctionCallExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitFunctionCallExpression(@NotNull ErlangFunctionCallExpression o) {
      String functionName = o.getName();
      int functionArity = o.getArgumentList().getExpressionList().size();
      String functionPresentation = ErlangPsiImplUtil.createFunctionPresentation(functionName, functionArity);
      boolean needToCheckRecursively = false;

      if (o.getQAtom().getMacros() != null) {
        return;
      }
      if (o.getParent() instanceof ErlangGlobalFunctionCallExpression) {
        PsiReference reference = ((ErlangGlobalFunctionCallExpression) o.getParent()).getModuleRef().getReference();
        if (!reference.getCanonicalText().equals("erlang")) {
          registerProblem(myHolder, o.getParent(), ERROR);
        }
        else if (!BIFS_ALLOWED_IN_GUARDS.contains(functionPresentation)) {
          registerProblem(myHolder, o, ERROR);
        }
        else {
          needToCheckRecursively = true;
        }
      }
      else if (((ErlangFile) o.getContainingFile()).getFunction(functionName, functionArity) != null) {
        registerProblem(myHolder, o, "Call to local/imported function " + functionPresentation + " is illegal in guard");
      }
      else if (!BIFS_ALLOWED_IN_GUARDS.contains(functionPresentation)) {
        registerProblem(myHolder, o, ERROR);
      }
      else {
        needToCheckRecursively = true;
      }

      if (needToCheckRecursively) {
        o.getArgumentList().accept(this);
      }
    }
  }
}

<code block>


package org.intellij.erlang.psi.impl;

import com.intellij.openapi.project.Project;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.ArrayUtil;
import com.intellij.util.IncorrectOperationException;
import com.intellij.util.ObjectUtils;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.sdk.ErlangSdkRelease;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class ErlangFunctionReferenceImpl<T extends ErlangQAtom> extends PsiPolyVariantReferenceBase<T> implements ErlangFunctionReference {
  @Nullable
  private final ErlangQAtom myModuleAtom;
  protected final String myReferenceName;
  private final int myArity;

  public ErlangFunctionReferenceImpl(@NotNull T element, @Nullable ErlangQAtom moduleAtom, int arity) {
    super(element, ErlangPsiImplUtil.getTextRangeForReference(element));
    myReferenceName = ErlangPsiImplUtil.getNameIdentifier(element).getText();
    myModuleAtom = moduleAtom;
    myArity = arity;
  }

  @Override
  public PsiElement resolve() {
    if (suppressResolve()) return null; 

    if (myModuleAtom != null) {
      ErlangFunction explicitFunction = getExternalFunction(getModuleFileName());
      if (explicitFunction != null) {
        return explicitFunction;
      }
      else if (ErlangBifTable.isBif(myModuleAtom.getText(), myReferenceName, myArity) || 
        myReferenceName.equals(ErlangBifTable.MODULE_INFO) && (myArity == 1 || myArity == 0)) {
        return getElement();
      }
      return null;
    }

    ErlangFile file = ObjectUtils.tryCast(getElement().getContainingFile(), ErlangFile.class);
    if (file == null) return null;

    ErlangFunction declaredFunction = file.getFunction(myReferenceName, myArity);
    if (declaredFunction != null) return declaredFunction;

    ErlangFunction implicitFunction = getExternalFunction("erlang");
    if (implicitFunction != null) return implicitFunction;

    ErlangSdkRelease release = ErlangSdkType.getRelease(file);
    if ((release == null || release.needBifCompletion("erlang")) &&
      ErlangBifTable.isBif("erlang", myReferenceName, myArity) ||
      ErlangBifTable.isBif("", myReferenceName, myArity)) return getElement();

    ErlangFunction fromImport = resolveImport(file.getImportedFunction(myReferenceName, myArity));
    if (fromImport != null) return fromImport;

    List<ErlangFunction> declaredInIncludes =
      ErlangPsiImplUtil.getErlangFunctionsFromIncludes(file, false, myReferenceName, myArity);
    if (!declaredInIncludes.isEmpty()) return ContainerUtil.getFirstItem(declaredInIncludes);

    List<ErlangImportFunction> importedInIncludes =
      ErlangPsiImplUtil.getImportsFromIncludes(file, false, myReferenceName, myArity);
    for (ErlangImportFunction importFromInclude : importedInIncludes) {
      ErlangFunction importedFunction = resolveImport(importFromInclude);
      if (importedFunction != null) return importedFunction;
    }

    return null;
  }

  @NotNull
  @Override
  public ResolveResult[] multiResolve(boolean incompleteCode) {
    if (suppressResolve()) return ResolveResult.EMPTY_ARRAY; 


    if (resolve() != null && !incompleteCode) return ResolveResult.EMPTY_ARRAY;

    Collection<ErlangFunction> result;
    if (myModuleAtom != null) {
      result = getErlangFunctionsFromModule(getModuleFileName());
    }
    else {
      PsiFile containingFile = getElement().getContainingFile();
      if (containingFile instanceof ErlangFile) {
        ErlangFile erlangFile = (ErlangFile) containingFile;
        result = new ArrayList<ErlangFunction>();

        for (ErlangImportFunction importFunction : erlangFile.getImportedFunctions()) {
          if (myReferenceName.equals(ErlangPsiImplUtil.getName(importFunction))) {
            ContainerUtil.addIfNotNull(result, resolveImport(importFunction));
          }
        }

        result.addAll(erlangFile.getFunctionsByName(myReferenceName));
        result.addAll(getErlangFunctionsFromModule("erlang"));
      }
      else {
        result = ContainerUtil.emptyList();
      }
    }
    return PsiElementResolveResult.createResults(result);
  }

  private Collection<ErlangFunction> getErlangFunctionsFromModule(String moduleFileName) {
    Project project = getElement().getProject();
    Collection<ErlangFunction> result = new ArrayList<ErlangFunction>();
    for (ErlangFile file : ErlangModuleIndex.getFilesByName(project, moduleFileName, GlobalSearchScope.allScope(project))) {
      result.addAll(file.getFunctionsByName(myReferenceName));
    }
    return result;
  }

  private boolean suppressResolve() {
    return PsiTreeUtil.getParentOfType(myElement, ErlangCallbackSpec.class) != null;
  }

  @NotNull
  private String getModuleFileName() {
    return myModuleAtom != null ? ErlangPsiImplUtil.getName(myModuleAtom) : "";
  }

  @Override
  public boolean isReferenceTo(PsiElement element) {
    return getElement().getManager().areElementsEquivalent(resolve(), element);
  }

  @Nullable
  private ErlangFunction getExternalFunction(@NotNull String moduleFileName) {
    Project project = getElement().getProject();
    List<ErlangFunction> result = new ArrayList<ErlangFunction>();
    for (ErlangFile file : ErlangModuleIndex.getFilesByName(project, moduleFileName, GlobalSearchScope.allScope(project))) {
      ContainerUtil.addAllNotNull(result, file.getFunction(myReferenceName, myArity));
      ContainerUtil.addAllNotNull(result, ErlangPsiImplUtil.getErlangFunctionsFromIncludes(file, false, myReferenceName, myArity));
    }
    return ContainerUtil.getFirstItem(result);
  }

  @NotNull
  @Override
  public Object[] getVariants() {
    if (PsiTreeUtil.getParentOfType(myElement, ErlangExportFunction.class) != null) return EMPTY_ARRAY;
    return ArrayUtil.toObjectArray(ErlangPsiImplUtil.getFunctionLookupElements(getElement().getContainingFile(), true, myModuleAtom));
  }

  @Override
  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {
    ErlangPsiImplUtil.renameAtom(getElement().getAtom(), newElementName);
    return getElement();
  }

  @Override
  public String getSignature() {
    return myReferenceName + "/" + myArity;
  }

  @Override
  public String getName() {
    return myReferenceName;
  }

  @Override
  public int getArity() {
    return myArity;
  }

  @Nullable
  private static ErlangFunction resolveImport(@Nullable ErlangImportFunction importFunction) {
    PsiReference reference = importFunction != null ? importFunction.getReference() : null;
    PsiElement resolve = reference != null ? reference.resolve() : null;
    return ObjectUtils.tryCast(resolve, ErlangFunction.class);
  }
}

<code block>


package org.intellij.erlang.inspection;

import com.intellij.codeInspection.LocalInspectionToolSession;
import com.intellij.codeInspection.LocalQuickFix;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiReference;
import com.intellij.psi.util.PsiTreeUtil;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.quickfixes.ErlangCreateFunctionQuickFix;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class ErlangUnresolvedFunctionInspection extends ErlangInspectionBase {
  @NotNull
  @Override
  protected ErlangVisitor buildErlangVisitor(@NotNull final ProblemsHolder holder,
                                             @NotNull LocalInspectionToolSession session) {
    return new ErlangVisitor() {
      @Override
      public void visitFunctionCallExpression(@NotNull ErlangFunctionCallExpression o) {
        PsiReference reference = o.getReference();
        if (reference instanceof ErlangFunctionReference && reference.resolve() == null) {
          if (o.getQAtom().getMacros() != null) return;
          ErlangFunctionReference r = (ErlangFunctionReference) reference;

          String name = r.getName();
          int arity = r.getArity();

          if (arity < 0) return;

          String signature = r.getSignature();

          PsiElement parent = o.getParent();
          if (parent instanceof ErlangGlobalFunctionCallExpression) {
            ErlangModuleRef moduleRef = ((ErlangGlobalFunctionCallExpression) parent).getModuleRef();
            if (moduleRef.getQAtom().getMacros() != null) return;
            signature = moduleRef.getText() + ":" + signature;
          }

          LocalQuickFix[] qfs = parent instanceof ErlangGenericFunctionCallExpression || parent instanceof ErlangGlobalFunctionCallExpression ?
            new LocalQuickFix[]{} :
            new LocalQuickFix[]{new ErlangCreateFunctionQuickFix(name, arity)};

          registerProblem(holder, o.getNameIdentifier(), "Unresolved function " + "'" + signature + "'", qfs);
        }
      }

      @Override
      public void visitSpecFun(@NotNull ErlangSpecFun o) {
        inspect(o, o.getQAtom(), o.getReference());
      }

      @Override
      public void visitFunctionWithArity(@NotNull ErlangFunctionWithArity o) {
        inspect(o, o.getQAtom(), o.getReference());
      }

      private void inspect(PsiElement what, ErlangQAtom target, @Nullable PsiReference reference) {
        if (PsiTreeUtil.getParentOfType(what, ErlangCallbackSpec.class) != null || target.getMacros() != null ||
          !(reference instanceof ErlangFunctionReference) || reference.resolve() != null) {
          return;
        }

        ErlangFunctionReference r = (ErlangFunctionReference) reference;
        if (r.getArity() < 0) return; 
        LocalQuickFix[] qfs = PsiTreeUtil.getNextSiblingOfType(what, ErlangModuleRef.class) != null ?
          new LocalQuickFix[]{} : new LocalQuickFix[]{new ErlangCreateFunctionQuickFix(r.getName(), r.getArity())};
        registerProblem(holder, target, "Unresolved function " + "'" + r.getSignature() + "'", qfs);
      }
    };
  }
}
<code block>


package org.intellij.erlang.inspection;

import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.bif.ErlangOperatorTable;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.psi.impl.ErlangPsiImplUtil;
import org.jetbrains.annotations.NotNull;

import java.util.Set;

public class ErlangIllegalGuardInspection extends ErlangInspectionBase {
  private static final String ERROR = "Illegal guard expression";

  private static final Set<String> BIFS_ALLOWED_IN_GUARDS = ContainerUtil.immutableSet(
    "abs/1", "bit_size/1", "binary_part/3",
    "byte_size/1", "binary_part/2", "element/2",
    "float/1", "hd/1", "is_atom/1", "is_binary/1",
    "is_bitstring/1", "is_boolean/1", "is_float/1",
    "is_function/1", "is_function/2", "is_integer/1",
    "is_list/1", "is_map/1", "is_number/1",
    "is_pid/1", "is_port/1", "is_record/2",
    "is_record/3", "is_reference/1", "is_tuple/1",
    "length/1", "map_size/1", "node/1",
    "node/0", "round/1", "self/0",
    "size/1", "tl/1", "trunc/1", "tuple_size/1");

  @Override
  protected void checkFile(@NotNull ErlangFile file, @NotNull ProblemsHolder holder) {
    for (ErlangFunction function : file.getFunctions()) {
      for (ErlangFunctionClause clause : function.getFunctionClauseList()) {
        ErlangClauseGuard guard = clause.getClauseGuard();
        if (guard != null) {
          guard.accept(new GuardInspector(holder));
        }
        ErlangClauseBody clauseBody = clause.getClauseBody();
        if (clauseBody != null) {
          clauseBody.accept(new GuardDetector(holder));
        }
      }
    }
  }

  private class GuardDetector extends ErlangRecursiveVisitor {
    private final ProblemsHolder myHolder;

    public GuardDetector(ProblemsHolder holder) {
      this.myHolder = holder;
    }

    @Override
    public void visitClauseGuard(@NotNull ErlangClauseGuard o) {
      ErlangGuard guard = o.getGuard();
      if (guard != null) {
        guard.accept(new GuardInspector(myHolder));
      }
    }

    @Override
    public void visitGuard(@NotNull ErlangGuard o) {
      o.accept(new GuardInspector(myHolder));
    }
  }

  private class GuardInspector extends ErlangRecursiveVisitor {
    private final ProblemsHolder myHolder;

    public GuardInspector(ProblemsHolder holder) {
      this.myHolder = holder;
    }

    @Override
    public void visitAssignmentExpression(@NotNull ErlangAssignmentExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitCaseExpression(@NotNull ErlangCaseExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitReceiveExpression(@NotNull ErlangReceiveExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitTryExpression(@NotNull ErlangTryExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitListComprehension(@NotNull ErlangListComprehension o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitBeginEndExpression(@NotNull ErlangBeginEndExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitSendExpression(@NotNull ErlangSendExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitListOpExpression(@NotNull ErlangListOpExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitCatchExpression(@NotNull ErlangCatchExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitFunExpression(@NotNull ErlangFunExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitAnonymousCallExpression(@NotNull ErlangAnonymousCallExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitIfExpression(@NotNull ErlangIfExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitGenericFunctionCallExpression(@NotNull ErlangGenericFunctionCallExpression o) {
      registerProblem(myHolder, o, ERROR);
    }

    @Override
    public void visitGlobalFunctionCallExpression(@NotNull ErlangGlobalFunctionCallExpression o) {
      String moduleName = ErlangPsiImplUtil.getName(o.getModuleRef().getQAtom());
      ErlangFunctionCallExpression function = o.getFunctionCallExpression();
      String functionName = function.getName();
      int functionArity = function.getArgumentList().getExpressionList().size();
      String functionPresentation = ErlangPsiImplUtil.createFunctionPresentation(functionName, functionArity);

      if (!"erlang".equals(moduleName)) {
        registerProblem(myHolder, o, ERROR);
      }
      else if (!BIFS_ALLOWED_IN_GUARDS.contains(functionPresentation) &&
               !ErlangOperatorTable.canBeInvokedAsFunction(moduleName, functionPresentation)) {
        registerProblem(myHolder, function, ERROR);
      }
      else {
        function.getArgumentList().accept(this);
      }
    }

    @Override
    public void visitFunctionCallExpression(@NotNull ErlangFunctionCallExpression o) {
      if (o.getQAtom().getMacros() != null) {
        return;
      }
      String functionName = o.getName();
      int functionArity = o.getArgumentList().getExpressionList().size();
      String functionPresentation = ErlangPsiImplUtil.createFunctionPresentation(functionName, functionArity);

      if (((ErlangFile) o.getContainingFile()).getFunction(functionName, functionArity) != null) {
        registerProblem(myHolder, o, "Call to local/imported function " + functionPresentation + " is illegal in guard");
      }
      else if (!BIFS_ALLOWED_IN_GUARDS.contains(functionPresentation)) {
        registerProblem(myHolder, o, ERROR);
      }
      else {
        o.getArgumentList().accept(this);
      }
    }
  }
}
<code block>


package org.intellij.erlang.bif;

import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.psi.impl.ErlangPsiImplUtil;
import org.jetbrains.annotations.NotNull;

import java.util.Set;

public class ErlangOperatorTable {


  private static final Set<String> OPERATORS_ALLOWED_INVOKING_AS_FUNCTION = ContainerUtil.immutableSet(
    "'!'/2",
    "'=='/2",
    "'/='/2",
    "'=<'/2",
    "'<'/2",
    "'>='/2",
    "'>'/2",
    "'=:='/2",
    "'=/='/2",
    "'+'/1",
    "'-'/1",
    "'+'/2",
    "'-'/2",
    "'*'/2",
    "'/'/2",
    "bnot/2",
    "div/2",
    "rem/2",
    "band/2",
    "bor/2",
    "bxor/2",
    "bsl/2",
    "bsr/2",
    "not/1",
    "and/2",
    "or/2",
    "xor/2",
    "'++'/2",
    "'--'/2"
  );

  public static boolean canBeInvokedAsFunction(@NotNull String moduleName, @NotNull String name, int arity) {
    return canBeInvokedAsFunction(moduleName, ErlangPsiImplUtil.createFunctionPresentation(name, arity));
  }

  public static boolean canBeInvokedAsFunction(@NotNull String moduleName, @NotNull String functionPresentation) {
    return moduleName.equals("erlang") &&
           OPERATORS_ALLOWED_INVOKING_AS_FUNCTION.contains(functionPresentation);
  }

  private ErlangOperatorTable() {
  }
}

<code block>


package org.intellij.erlang.psi.impl;

import com.intellij.openapi.project.Project;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.ArrayUtil;
import com.intellij.util.IncorrectOperationException;
import com.intellij.util.ObjectUtils;
import com.intellij.util.containers.ContainerUtil;
import org.intellij.erlang.bif.ErlangBifTable;
import org.intellij.erlang.bif.ErlangOperatorTable;
import org.intellij.erlang.index.ErlangModuleIndex;
import org.intellij.erlang.psi.*;
import org.intellij.erlang.sdk.ErlangSdkRelease;
import org.intellij.erlang.sdk.ErlangSdkType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class ErlangFunctionReferenceImpl<T extends ErlangQAtom> extends PsiPolyVariantReferenceBase<T> implements ErlangFunctionReference {
  @Nullable
  private final ErlangQAtom myModuleAtom;
  protected final String myReferenceName;
  private final int myArity;

  public ErlangFunctionReferenceImpl(@NotNull T element, @Nullable ErlangQAtom moduleAtom, int arity) {
    super(element, ErlangPsiImplUtil.getTextRangeForReference(element));
    myReferenceName = ErlangPsiImplUtil.getNameIdentifier(element).getText();
    myModuleAtom = moduleAtom;
    myArity = arity;
  }

  @Override
  public PsiElement resolve() {
    if (suppressResolve()) return null; 

    if (myModuleAtom != null) {
      String moduleName = ErlangPsiImplUtil.getName(myModuleAtom);
      ErlangFunction explicitFunction = getExternalFunction(moduleName);
      boolean resolveToCallSite = explicitFunction == null && (
        ErlangBifTable.isBif(moduleName, myReferenceName, myArity) ||
        ErlangOperatorTable.canBeInvokedAsFunction(moduleName, myReferenceName, myArity) ||
        myReferenceName.equals(ErlangBifTable.MODULE_INFO) && (myArity == 1 || myArity == 0)
      );
      return resolveToCallSite ? getElement() : explicitFunction;
    }

    ErlangFile file = ObjectUtils.tryCast(getElement().getContainingFile(), ErlangFile.class);
    if (file == null) return null;

    ErlangFunction declaredFunction = file.getFunction(myReferenceName, myArity);
    if (declaredFunction != null) return declaredFunction;

    ErlangFunction implicitFunction = getExternalFunction("erlang");
    if (implicitFunction != null) return implicitFunction;

    ErlangSdkRelease release = ErlangSdkType.getRelease(file);
    if ((release == null || release.needBifCompletion("erlang")) &&
        ErlangBifTable.isBif("erlang", myReferenceName, myArity) ||
        ErlangBifTable.isBif("", myReferenceName, myArity)) return getElement();

    ErlangFunction fromImport = resolveImport(file.getImportedFunction(myReferenceName, myArity));
    if (fromImport != null) return fromImport;

    List<ErlangFunction> declaredInIncludes =
      ErlangPsiImplUtil.getErlangFunctionsFromIncludes(file, false, myReferenceName, myArity);
    if (!declaredInIncludes.isEmpty()) return ContainerUtil.getFirstItem(declaredInIncludes);

    List<ErlangImportFunction> importedInIncludes =
      ErlangPsiImplUtil.getImportsFromIncludes(file, false, myReferenceName, myArity);
    for (ErlangImportFunction importFromInclude : importedInIncludes) {
      ErlangFunction importedFunction = resolveImport(importFromInclude);
      if (importedFunction != null) return importedFunction;
    }

    return null;
  }

  @NotNull
  @Override
  public ResolveResult[] multiResolve(boolean incompleteCode) {
    if (suppressResolve()) return ResolveResult.EMPTY_ARRAY; 


    if (resolve() != null && !incompleteCode) return ResolveResult.EMPTY_ARRAY;

    Collection<ErlangFunction> result;
    if (myModuleAtom != null) {
      result = getErlangFunctionsFromModule(ErlangPsiImplUtil.getName(myModuleAtom));
    }
    else {
      PsiFile containingFile = getElement().getContainingFile();
      if (containingFile instanceof ErlangFile) {
        ErlangFile erlangFile = (ErlangFile) containingFile;
        result = new ArrayList<ErlangFunction>();

        for (ErlangImportFunction importFunction : erlangFile.getImportedFunctions()) {
          if (myReferenceName.equals(ErlangPsiImplUtil.getName(importFunction))) {
            ContainerUtil.addIfNotNull(result, resolveImport(importFunction));
          }
        }

        result.addAll(erlangFile.getFunctionsByName(myReferenceName));
        result.addAll(getErlangFunctionsFromModule("erlang"));
      }
      else {
        result = ContainerUtil.emptyList();
      }
    }
    return PsiElementResolveResult.createResults(result);
  }

  private Collection<ErlangFunction> getErlangFunctionsFromModule(String moduleFileName) {
    Project project = getElement().getProject();
    Collection<ErlangFunction> result = new ArrayList<ErlangFunction>();
    for (ErlangFile file : ErlangModuleIndex.getFilesByName(project, moduleFileName, GlobalSearchScope.allScope(project))) {
      result.addAll(file.getFunctionsByName(myReferenceName));
    }
    return result;
  }

  private boolean suppressResolve() {
    return PsiTreeUtil.getParentOfType(myElement, ErlangCallbackSpec.class) != null;
  }

  @Override
  public boolean isReferenceTo(PsiElement element) {
    return getElement().getManager().areElementsEquivalent(resolve(), element);
  }

  @Nullable
  private ErlangFunction getExternalFunction(@NotNull String moduleFileName) {
    Project project = getElement().getProject();
    List<ErlangFunction> result = new ArrayList<ErlangFunction>();
    for (ErlangFile file : ErlangModuleIndex.getFilesByName(project, moduleFileName, GlobalSearchScope.allScope(project))) {
      ContainerUtil.addAllNotNull(result, file.getFunction(myReferenceName, myArity));
      ContainerUtil.addAllNotNull(result, ErlangPsiImplUtil.getErlangFunctionsFromIncludes(file, false, myReferenceName, myArity));
    }
    return ContainerUtil.getFirstItem(result);
  }

  @NotNull
  @Override
  public Object[] getVariants() {
    if (PsiTreeUtil.getParentOfType(myElement, ErlangExportFunction.class) != null) return EMPTY_ARRAY;
    return ArrayUtil.toObjectArray(ErlangPsiImplUtil.getFunctionLookupElements(getElement().getContainingFile(), true, myModuleAtom));
  }

  @Override
  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {
    ErlangPsiImplUtil.renameAtom(getElement().getAtom(), newElementName);
    return getElement();
  }

  @Override
  public String getSignature() {
    return ErlangPsiImplUtil.createFunctionPresentation(myReferenceName, myArity);
  }

  @Override
  public String getName() {
    return myReferenceName;
  }

  @Override
  public int getArity() {
    return myArity;
  }

  @Nullable
  private static ErlangFunction resolveImport(@Nullable ErlangImportFunction importFunction) {
    PsiReference reference = importFunction != null ? importFunction.getReference() : null;
    PsiElement resolve = reference != null ? reference.resolve() : null;
    return ObjectUtils.tryCast(resolve, ErlangFunction.class);
  }
}
