
package org.docx4j.jaxb;


import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;

import org.apache.commons.io.IOUtils;
import org.docx4j.utils.ResourceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Context {
	
	public static final JAXBContext jc;
	
	




	@Deprecated
	public static JAXBContext jcThemePart;
	
	public static JAXBContext jcDocPropsCore;
	public static JAXBContext jcDocPropsCustom;
	public static JAXBContext jcDocPropsExtended;
	public static JAXBContext jcRelationships;
	public static JAXBContext jcCustomXmlProperties;
	public static JAXBContext jcContentTypes;

	public static JAXBContext jcXmlPackage;
	
	private static JAXBContext jcXslFo;
	public static JAXBContext jcSectionModel;

	public static JAXBContext jcEncryption;

	
	public static JAXBContext jcMCE;
	
	private static Logger log = LoggerFactory.getLogger(Context.class);
		
	static {
		JAXBContext tempContext = null;

		
		log.info("java.vendor="+System.getProperty("java.vendor"));
		log.info("java.version="+System.getProperty("java.version"));
		
		
		try {
			searchManifestsForJAXBImplementationInfo( ClassLoader.getSystemClassLoader());
			if (Thread.currentThread().getContextClassLoader()==null) {
				log.warn("ContextClassLoader is null for current thread");
				
			} else if (ClassLoader.getSystemClassLoader()!=Thread.currentThread().getContextClassLoader()) {
				searchManifestsForJAXBImplementationInfo(Thread.currentThread().getContextClassLoader());
			}
		} catch ( java.security.AccessControlException e) {
			
			log.warn("Caught/ignored " + e.getMessage());
		}
		
		
		InputStream jaxbPropsIS=null;
		try {
			
			jaxbPropsIS = ResourceUtils.getResource("org/docx4j/wml/jaxb.properties");
			log.info("MOXy JAXB implementation intended..");
		} catch (Exception e3) {
			log.info("No MOXy JAXB config found; assume not intended..");
			log.debug(e3.getMessage());
		}
		if (jaxbPropsIS==null) {
			
			try {
				Object namespacePrefixMapper = NamespacePrefixMapperUtils.getPrefixMapper();
				if ( namespacePrefixMapper.getClass().getName().equals("org.docx4j.jaxb.NamespacePrefixMapperSunInternal") ) {
					
					log.info("Using Java 6/7 JAXB implementation");
				} else {
					log.info("Using JAXB Reference Implementation");			
				}
				
			} catch (JAXBException e) {
				log.error("PANIC! No suitable JAXB implementation available");
				log.error(e.getMessage(), e);
				e.printStackTrace();
			}
		}
      
      try { 
			
			
			
			
			
    	  	
    	  	
    	  	
    	  	
			
			java.lang.ClassLoader classLoader = Context.class.getClassLoader();

			tempContext = JAXBContext.newInstance("org.docx4j.wml:org.docx4j.w14:org.docx4j.w15:" +
					"org.docx4j.com.microsoft.schemas.office.word.x2006.wordml:" +
					"org.docx4j.dml:org.docx4j.dml.chart:org.docx4j.dml.chartDrawing:org.docx4j.dml.compatibility:org.docx4j.dml.diagram:org.docx4j.dml.lockedCanvas:org.docx4j.dml.picture:org.docx4j.dml.wordprocessingDrawing:org.docx4j.dml.spreadsheetdrawing:org.docx4j.dml.diagram2008:" +
					
					"org.docx4j.vml:org.docx4j.vml.officedrawing:org.docx4j.vml.wordprocessingDrawing:org.docx4j.vml.presentationDrawing:org.docx4j.vml.spreadsheetDrawing:org.docx4j.vml.root:" +
					"org.docx4j.docProps.coverPageProps:" +
					"org.opendope.xpaths:org.opendope.conditions:org.opendope.questions:org.opendope.answers:org.opendope.components:org.opendope.SmartArt.dataHierarchy:" +
					"org.docx4j.math:" +
					"org.docx4j.sharedtypes:org.docx4j.bibliography:" +
					"org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingDrawing", classLoader );
			
			if (tempContext.getClass().getName().equals("org.eclipse.persistence.jaxb.JAXBContext")) {
				log.info("MOXy JAXB implementation is in use!");
			} else {
				log.info("Not using MOXy; using " + tempContext.getClass().getName());				
			}
			
			jcThemePart = tempContext; 
			jcDocPropsCore = JAXBContext.newInstance("org.docx4j.docProps.core:org.docx4j.docProps.core.dc.elements:org.docx4j.docProps.core.dc.terms",classLoader );
			jcDocPropsCustom = JAXBContext.newInstance("org.docx4j.docProps.custom",classLoader );
			jcDocPropsExtended = JAXBContext.newInstance("org.docx4j.docProps.extended",classLoader );
			jcXmlPackage = JAXBContext.newInstance("org.docx4j.xmlPackage",classLoader );
			jcRelationships = JAXBContext.newInstance("org.docx4j.relationships",classLoader );
			jcCustomXmlProperties = JAXBContext.newInstance("org.docx4j.customXmlProperties",classLoader );
			jcContentTypes = JAXBContext.newInstance("org.docx4j.openpackaging.contenttype",classLoader );
			
			jcSectionModel = JAXBContext.newInstance("org.docx4j.model.structure.jaxb",classLoader );
			
			try {
				
				jcEncryption = JAXBContext.newInstance(
						 "org.docx4j.com.microsoft.schemas.office.x2006.encryption:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password:"
						,classLoader );
			} catch (javax.xml.bind.JAXBException e) {
				log.error(e.getMessage());
			}

			jcMCE = JAXBContext.newInstance("org.docx4j.mce",classLoader );
			
			log.debug(".. other contexts loaded ..");
										
			
		} catch (Exception ex) {
			log.error("Cannot initialize context", ex);
		}				
      jc = tempContext;
	}
	
	private static org.docx4j.wml.ObjectFactory wmlObjectFactory;
	
	public static org.docx4j.wml.ObjectFactory getWmlObjectFactory() {
		
		if (wmlObjectFactory==null) {
			wmlObjectFactory = new org.docx4j.wml.ObjectFactory();
		}
		return wmlObjectFactory;
		
	}

	public static JAXBContext getXslFoContext() {
		if (jcXslFo==null) {
			try {	
				Context tmp = new Context();
				java.lang.ClassLoader classLoader = tmp.getClass().getClassLoader();

				jcXslFo = JAXBContext.newInstance("org.plutext.jaxb.xslfo",classLoader );
				
			} catch (JAXBException ex) {
	      log.error("Cannot determine XSL-FO context", ex);
			}						
		}
		return jcXslFo;		
	}
	
	public static void searchManifestsForJAXBImplementationInfo(ClassLoader loader) {
	    Enumeration resEnum;
	    try {
	        resEnum = loader.getResources(JarFile.MANIFEST_NAME);
	        while (resEnum.hasMoreElements()) {
	        	InputStream is = null;
	            try {
	                URL url = (URL)resEnum.nextElement();

	                is = url.openStream();
	                if (is != null) {
	                    Manifest manifest = new Manifest(is);

                    	Attributes mainAttribs = manifest.getMainAttributes();
                    	String impTitle = mainAttribs.getValue("Implementation-Title");
                    	if (impTitle!=null
                    			&& impTitle.contains("JAXB Reference Implementation")
                    					|| impTitle.contains("org.eclipse.persistence") ) {
	                    
        	                log.info("\n" + url);
		                    for(Object key2  : mainAttribs.keySet() ) {
		                    	
		                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
		                    }
                    	}
                    	
	                    
	                    for(String key  :  manifest.getEntries().keySet() ) {
	    	                
	    	                if (key.equals("com.sun.xml.bind.v2.runtime")) {
		    	                log.info("Found JAXB reference implementation in " + url);
		                    	mainAttribs = manifest.getAttributes((String)key);
		                    
			                    for(Object key2  : mainAttribs.keySet() ) {
			                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
			                    }
		                    }
	                    }
	                    
	                }
	            }
	            catch (Exception e) {
	                

	            } finally {
	            	IOUtils.closeQuietly(is);
	            }
	        }
	    } catch (IOException e1) {
	        

	    }
	     
	}	
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;


import javax.xml.bind.JAXBElement;

import org.docx4j.com.microsoft.schemas.office.word.x2006.wordml.CTVbaSuppData;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPart;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;



public final class VbaDataPart extends JaxbXmlPart<JAXBElement<CTVbaSuppData>> {
	
	
	
	public VbaDataPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}		

	public VbaDataPart() throws InvalidFormatException {
		super( new PartName("/word/vbaData.xml") );
		init();
	}		
	
	
	public void init() {

		
		setContentType(new org.docx4j.openpackaging.contenttype.ContentType(
				org.docx4j.openpackaging.contenttype.ContentTypes.OFFICEDOCUMENT_VBA_DATA));

		
		setRelationshipType(Namespaces.VBA_DATA_WORD);
	}
	
}

<code block>
@javax.xml.bind.annotation.XmlSchema(namespace = "http:
package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

<code block>

package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_DocEvents", propOrder = {
    "eventDocNew",
    "eventDocOpen",
    "eventDocClose",
    "eventDocSync",
    "eventDocXmlAfterInsert",
    "eventDocXmlBeforeDelete",
    "eventDocContentControlAfterInsert",
    "eventDocContentControlBeforeDelete",
    "eventDocContentControlOnExit",
    "eventDocContentControlOnEnter",
    "eventDocStoreUpdate",
    "eventDocContentControlContentUpdate",
    "eventDocBuildingBlockAfterInsert"
})
public class CTDocEvents
    implements Child
{

    protected Object eventDocNew;
    protected Object eventDocOpen;
    protected Object eventDocClose;
    protected Object eventDocSync;
    protected Object eventDocXmlAfterInsert;
    protected Object eventDocXmlBeforeDelete;
    protected Object eventDocContentControlAfterInsert;
    protected Object eventDocContentControlBeforeDelete;
    protected Object eventDocContentControlOnExit;
    protected Object eventDocContentControlOnEnter;
    protected Object eventDocStoreUpdate;
    protected Object eventDocContentControlContentUpdate;
    protected Object eventDocBuildingBlockAfterInsert;
    @XmlTransient
    private Object parent;

    
    public Object getEventDocNew() {
        return eventDocNew;
    }

    
    public void setEventDocNew(Object value) {
        this.eventDocNew = value;
    }

    
    public Object getEventDocOpen() {
        return eventDocOpen;
    }

    
    public void setEventDocOpen(Object value) {
        this.eventDocOpen = value;
    }

    
    public Object getEventDocClose() {
        return eventDocClose;
    }

    
    public void setEventDocClose(Object value) {
        this.eventDocClose = value;
    }

    
    public Object getEventDocSync() {
        return eventDocSync;
    }

    
    public void setEventDocSync(Object value) {
        this.eventDocSync = value;
    }

    
    public Object getEventDocXmlAfterInsert() {
        return eventDocXmlAfterInsert;
    }

    
    public void setEventDocXmlAfterInsert(Object value) {
        this.eventDocXmlAfterInsert = value;
    }

    
    public Object getEventDocXmlBeforeDelete() {
        return eventDocXmlBeforeDelete;
    }

    
    public void setEventDocXmlBeforeDelete(Object value) {
        this.eventDocXmlBeforeDelete = value;
    }

    
    public Object getEventDocContentControlAfterInsert() {
        return eventDocContentControlAfterInsert;
    }

    
    public void setEventDocContentControlAfterInsert(Object value) {
        this.eventDocContentControlAfterInsert = value;
    }

    
    public Object getEventDocContentControlBeforeDelete() {
        return eventDocContentControlBeforeDelete;
    }

    
    public void setEventDocContentControlBeforeDelete(Object value) {
        this.eventDocContentControlBeforeDelete = value;
    }

    
    public Object getEventDocContentControlOnExit() {
        return eventDocContentControlOnExit;
    }

    
    public void setEventDocContentControlOnExit(Object value) {
        this.eventDocContentControlOnExit = value;
    }

    
    public Object getEventDocContentControlOnEnter() {
        return eventDocContentControlOnEnter;
    }

    
    public void setEventDocContentControlOnEnter(Object value) {
        this.eventDocContentControlOnEnter = value;
    }

    
    public Object getEventDocStoreUpdate() {
        return eventDocStoreUpdate;
    }

    
    public void setEventDocStoreUpdate(Object value) {
        this.eventDocStoreUpdate = value;
    }

    
    public Object getEventDocContentControlContentUpdate() {
        return eventDocContentControlContentUpdate;
    }

    
    public void setEventDocContentControlContentUpdate(Object value) {
        this.eventDocContentControlContentUpdate = value;
    }

    
    public Object getEventDocBuildingBlockAfterInsert() {
        return eventDocBuildingBlockAfterInsert;
    }

    
    public void setEventDocBuildingBlockAfterInsert(Object value) {
        this.eventDocBuildingBlockAfterInsert = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_Mcds", propOrder = {
    "mcd"
})
public class CTMcds
    implements Child
{

    protected List<CTMcd> mcd;
    @XmlTransient
    private Object parent;

    
    public List<CTMcd> getMcd() {
        if (mcd == null) {
            mcd = new ArrayList<CTMcd>();
        }
        return this.mcd;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_VbaSuppData", propOrder = {
    "docEvents",
    "mcds"
})
@XmlRootElement(name = "vbaSuppData")
public class CTVbaSuppData
    implements Child
{

    protected CTDocEvents docEvents;
    protected CTMcds mcds;
    @XmlTransient
    private Object parent;

    
    public CTDocEvents getDocEvents() {
        return docEvents;
    }

    
    public void setDocEvents(CTDocEvents value) {
        this.docEvents = value;
    }

    
    public CTMcds getMcds() {
        return mcds;
    }

    
    public void setMcds(CTMcds value) {
        this.mcds = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_Mcd")
public class CTMcd
    implements Child
{

    @XmlAttribute(name = "macroName", namespace = "http:
    protected String macroName;
    @XmlAttribute(name = "name", namespace = "http:
    protected String name;
    @XmlAttribute(name = "menuHelp", namespace = "http:
    protected String menuHelp;
    @XmlAttribute(name = "bEncrypt", namespace = "http:
    protected String bEncrypt;
    @XmlAttribute(name = "cmg", namespace = "http:
    protected String cmg;
    @XmlTransient
    private Object parent;

    
    public String getMacroName() {
        return macroName;
    }

    
    public void setMacroName(String value) {
        this.macroName = value;
    }

    
    public String getName() {
        return name;
    }

    
    public void setName(String value) {
        this.name = value;
    }

    
    public String getMenuHelp() {
        return menuHelp;
    }

    
    public void setMenuHelp(String value) {
        this.menuHelp = value;
    }

    
    public String getBEncrypt() {
        return bEncrypt;
    }

    
    public void setBEncrypt(String value) {
        this.bEncrypt = value;
    }

    
    public String getCmg() {
        return cmg;
    }

    
    public void setCmg(String value) {
        this.cmg = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.word.x2006.wordml;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.namespace.QName;



@XmlRegistry
public class ObjectFactory {

    private final static QName _VbaSuppData_QNAME = new QName("http:

    
    public ObjectFactory() {
    }

    
    public CTVbaSuppData createCTVbaSuppData() {
        return new CTVbaSuppData();
    }

    
    public CTMcd createCTMcd() {
        return new CTMcd();
    }

    
    public CTDocEvents createCTDocEvents() {
        return new CTDocEvents();
    }

    
    public CTMcds createCTMcds() {
        return new CTMcds();
    }

    
    @XmlElementDecl(namespace = "http:
    public JAXBElement<CTVbaSuppData> createVbaSuppData(CTVbaSuppData value) {
        return new JAXBElement<CTVbaSuppData>(_VbaSuppData_QNAME, CTVbaSuppData.class, null, value);
    }

}

<code block>

package org.docx4j.jaxb;


import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;

import org.apache.commons.io.IOUtils;
import org.docx4j.utils.ResourceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Context {
	
	public static final JAXBContext jc;
	
	




	@Deprecated
	public static JAXBContext jcThemePart;
	
	public static JAXBContext jcDocPropsCore;
	public static JAXBContext jcDocPropsCustom;
	public static JAXBContext jcDocPropsExtended;
	public static JAXBContext jcRelationships;
	public static JAXBContext jcCustomXmlProperties;
	public static JAXBContext jcContentTypes;

	public static JAXBContext jcXmlPackage;
	
	private static JAXBContext jcXslFo;
	public static JAXBContext jcSectionModel;

	public static JAXBContext jcEncryption;

	
	public static JAXBContext jcMCE;
	
	private static Logger log = LoggerFactory.getLogger(Context.class);
		
	static {
		JAXBContext tempContext = null;

		
		log.info("java.vendor="+System.getProperty("java.vendor"));
		log.info("java.version="+System.getProperty("java.version"));
		
		
		try {
			searchManifestsForJAXBImplementationInfo( ClassLoader.getSystemClassLoader());
			if (Thread.currentThread().getContextClassLoader()==null) {
				log.warn("ContextClassLoader is null for current thread");
				
			} else if (ClassLoader.getSystemClassLoader()!=Thread.currentThread().getContextClassLoader()) {
				searchManifestsForJAXBImplementationInfo(Thread.currentThread().getContextClassLoader());
			}
		} catch ( java.security.AccessControlException e) {
			
			log.warn("Caught/ignored " + e.getMessage());
		}
		
		
		InputStream jaxbPropsIS=null;
		try {
			
			jaxbPropsIS = ResourceUtils.getResource("org/docx4j/wml/jaxb.properties");
			log.info("MOXy JAXB implementation intended..");
		} catch (Exception e3) {
			log.info("No MOXy JAXB config found; assume not intended..");
			log.debug(e3.getMessage());
		}
		if (jaxbPropsIS==null) {
			
			try {
				Object namespacePrefixMapper = NamespacePrefixMapperUtils.getPrefixMapper();
				if ( namespacePrefixMapper.getClass().getName().equals("org.docx4j.jaxb.NamespacePrefixMapperSunInternal") ) {
					
					log.info("Using Java 6/7 JAXB implementation");
				} else {
					log.info("Using JAXB Reference Implementation");			
				}
				
			} catch (JAXBException e) {
				log.error("PANIC! No suitable JAXB implementation available");
				log.error(e.getMessage(), e);
				e.printStackTrace();
			}
		}
      
      try { 
			
			
			
			
			
    	  	
    	  	
    	  	
    	  	
			
			java.lang.ClassLoader classLoader = Context.class.getClassLoader();

			tempContext = JAXBContext.newInstance("org.docx4j.wml:org.docx4j.w14:org.docx4j.w15:" +
					"org.docx4j.schemas.microsoft.com.office.word_2006.wordml:" +
					"org.docx4j.dml:org.docx4j.dml.chart:org.docx4j.dml.chartDrawing:org.docx4j.dml.compatibility:org.docx4j.dml.diagram:org.docx4j.dml.lockedCanvas:org.docx4j.dml.picture:org.docx4j.dml.wordprocessingDrawing:org.docx4j.dml.spreadsheetdrawing:org.docx4j.dml.diagram2008:" +
					
					"org.docx4j.vml:org.docx4j.vml.officedrawing:org.docx4j.vml.wordprocessingDrawing:org.docx4j.vml.presentationDrawing:org.docx4j.vml.spreadsheetDrawing:org.docx4j.vml.root:" +
					"org.docx4j.docProps.coverPageProps:" +
					"org.opendope.xpaths:org.opendope.conditions:org.opendope.questions:org.opendope.answers:org.opendope.components:org.opendope.SmartArt.dataHierarchy:" +
					"org.docx4j.math:" +
					"org.docx4j.sharedtypes:org.docx4j.bibliography:" +
					"org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingDrawing", classLoader );
			
			if (tempContext.getClass().getName().equals("org.eclipse.persistence.jaxb.JAXBContext")) {
				log.info("MOXy JAXB implementation is in use!");
			} else {
				log.info("Not using MOXy; using " + tempContext.getClass().getName());				
			}
			
			jcThemePart = tempContext; 
			jcDocPropsCore = JAXBContext.newInstance("org.docx4j.docProps.core:org.docx4j.docProps.core.dc.elements:org.docx4j.docProps.core.dc.terms",classLoader );
			jcDocPropsCustom = JAXBContext.newInstance("org.docx4j.docProps.custom",classLoader );
			jcDocPropsExtended = JAXBContext.newInstance("org.docx4j.docProps.extended",classLoader );
			jcXmlPackage = JAXBContext.newInstance("org.docx4j.xmlPackage",classLoader );
			jcRelationships = JAXBContext.newInstance("org.docx4j.relationships",classLoader );
			jcCustomXmlProperties = JAXBContext.newInstance("org.docx4j.customXmlProperties",classLoader );
			jcContentTypes = JAXBContext.newInstance("org.docx4j.openpackaging.contenttype",classLoader );
			
			jcSectionModel = JAXBContext.newInstance("org.docx4j.model.structure.jaxb",classLoader );
			
			try {
				
				jcEncryption = JAXBContext.newInstance(
						 "org.docx4j.com.microsoft.schemas.office.x2006.encryption:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password:"
						,classLoader );
			} catch (javax.xml.bind.JAXBException e) {
				log.error(e.getMessage());
			}

			jcMCE = JAXBContext.newInstance("org.docx4j.mce",classLoader );
			
			log.debug(".. other contexts loaded ..");
										
			
		} catch (Exception ex) {
			log.error("Cannot initialize context", ex);
		}				
      jc = tempContext;
	}
	
	private static org.docx4j.wml.ObjectFactory wmlObjectFactory;
	
	public static org.docx4j.wml.ObjectFactory getWmlObjectFactory() {
		
		if (wmlObjectFactory==null) {
			wmlObjectFactory = new org.docx4j.wml.ObjectFactory();
		}
		return wmlObjectFactory;
		
	}

	public static JAXBContext getXslFoContext() {
		if (jcXslFo==null) {
			try {	
				Context tmp = new Context();
				java.lang.ClassLoader classLoader = tmp.getClass().getClassLoader();

				jcXslFo = JAXBContext.newInstance("org.plutext.jaxb.xslfo",classLoader );
				
			} catch (JAXBException ex) {
	      log.error("Cannot determine XSL-FO context", ex);
			}						
		}
		return jcXslFo;		
	}
	
	public static void searchManifestsForJAXBImplementationInfo(ClassLoader loader) {
	    Enumeration resEnum;
	    try {
	        resEnum = loader.getResources(JarFile.MANIFEST_NAME);
	        while (resEnum.hasMoreElements()) {
	        	InputStream is = null;
	            try {
	                URL url = (URL)resEnum.nextElement();

	                is = url.openStream();
	                if (is != null) {
	                    Manifest manifest = new Manifest(is);

                    	Attributes mainAttribs = manifest.getMainAttributes();
                    	String impTitle = mainAttribs.getValue("Implementation-Title");
                    	if (impTitle!=null
                    			&& impTitle.contains("JAXB Reference Implementation")
                    					|| impTitle.contains("org.eclipse.persistence") ) {
	                    
        	                log.info("\n" + url);
		                    for(Object key2  : mainAttribs.keySet() ) {
		                    	
		                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
		                    }
                    	}
                    	
	                    
	                    for(String key  :  manifest.getEntries().keySet() ) {
	    	                
	    	                if (key.equals("com.sun.xml.bind.v2.runtime")) {
		    	                log.info("Found JAXB reference implementation in " + url);
		                    	mainAttribs = manifest.getAttributes((String)key);
		                    
			                    for(Object key2  : mainAttribs.keySet() ) {
			                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
			                    }
		                    }
	                    }
	                    
	                }
	            }
	            catch (Exception e) {
	                

	            } finally {
	            	IOUtils.closeQuietly(is);
	            }
	        }
	    } catch (IOException e1) {
	        

	    }
	     
	}	
}

<code block>
@javax.xml.bind.annotation.XmlSchema(namespace = "http:
package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

<code block>

package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_DocEvents", propOrder = {
    "eventDocNew",
    "eventDocOpen",
    "eventDocClose",
    "eventDocSync",
    "eventDocXmlAfterInsert",
    "eventDocXmlBeforeDelete",
    "eventDocContentControlAfterInsert",
    "eventDocContentControlBeforeDelete",
    "eventDocContentControlOnExit",
    "eventDocContentControlOnEnter",
    "eventDocStoreUpdate",
    "eventDocContentControlContentUpdate",
    "eventDocBuildingBlockAfterInsert"
})
public class CTDocEvents
    implements Child
{

    protected Object eventDocNew;
    protected Object eventDocOpen;
    protected Object eventDocClose;
    protected Object eventDocSync;
    protected Object eventDocXmlAfterInsert;
    protected Object eventDocXmlBeforeDelete;
    protected Object eventDocContentControlAfterInsert;
    protected Object eventDocContentControlBeforeDelete;
    protected Object eventDocContentControlOnExit;
    protected Object eventDocContentControlOnEnter;
    protected Object eventDocStoreUpdate;
    protected Object eventDocContentControlContentUpdate;
    protected Object eventDocBuildingBlockAfterInsert;
    @XmlTransient
    private Object parent;

    
    public Object getEventDocNew() {
        return eventDocNew;
    }

    
    public void setEventDocNew(Object value) {
        this.eventDocNew = value;
    }

    
    public Object getEventDocOpen() {
        return eventDocOpen;
    }

    
    public void setEventDocOpen(Object value) {
        this.eventDocOpen = value;
    }

    
    public Object getEventDocClose() {
        return eventDocClose;
    }

    
    public void setEventDocClose(Object value) {
        this.eventDocClose = value;
    }

    
    public Object getEventDocSync() {
        return eventDocSync;
    }

    
    public void setEventDocSync(Object value) {
        this.eventDocSync = value;
    }

    
    public Object getEventDocXmlAfterInsert() {
        return eventDocXmlAfterInsert;
    }

    
    public void setEventDocXmlAfterInsert(Object value) {
        this.eventDocXmlAfterInsert = value;
    }

    
    public Object getEventDocXmlBeforeDelete() {
        return eventDocXmlBeforeDelete;
    }

    
    public void setEventDocXmlBeforeDelete(Object value) {
        this.eventDocXmlBeforeDelete = value;
    }

    
    public Object getEventDocContentControlAfterInsert() {
        return eventDocContentControlAfterInsert;
    }

    
    public void setEventDocContentControlAfterInsert(Object value) {
        this.eventDocContentControlAfterInsert = value;
    }

    
    public Object getEventDocContentControlBeforeDelete() {
        return eventDocContentControlBeforeDelete;
    }

    
    public void setEventDocContentControlBeforeDelete(Object value) {
        this.eventDocContentControlBeforeDelete = value;
    }

    
    public Object getEventDocContentControlOnExit() {
        return eventDocContentControlOnExit;
    }

    
    public void setEventDocContentControlOnExit(Object value) {
        this.eventDocContentControlOnExit = value;
    }

    
    public Object getEventDocContentControlOnEnter() {
        return eventDocContentControlOnEnter;
    }

    
    public void setEventDocContentControlOnEnter(Object value) {
        this.eventDocContentControlOnEnter = value;
    }

    
    public Object getEventDocStoreUpdate() {
        return eventDocStoreUpdate;
    }

    
    public void setEventDocStoreUpdate(Object value) {
        this.eventDocStoreUpdate = value;
    }

    
    public Object getEventDocContentControlContentUpdate() {
        return eventDocContentControlContentUpdate;
    }

    
    public void setEventDocContentControlContentUpdate(Object value) {
        this.eventDocContentControlContentUpdate = value;
    }

    
    public Object getEventDocBuildingBlockAfterInsert() {
        return eventDocBuildingBlockAfterInsert;
    }

    
    public void setEventDocBuildingBlockAfterInsert(Object value) {
        this.eventDocBuildingBlockAfterInsert = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_Mcds", propOrder = {
    "mcd"
})
public class CTMcds
    implements Child
{

    protected List<CTMcd> mcd;
    @XmlTransient
    private Object parent;

    
    public List<CTMcd> getMcd() {
        if (mcd == null) {
            mcd = new ArrayList<CTMcd>();
        }
        return this.mcd;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_VbaSuppData", propOrder = {
    "docEvents",
    "mcds"
})
@XmlRootElement(name = "vbaSuppData")
public class CTVbaSuppData
    implements Child
{

    protected CTDocEvents docEvents;
    protected CTMcds mcds;
    @XmlTransient
    private Object parent;

    
    public CTDocEvents getDocEvents() {
        return docEvents;
    }

    
    public void setDocEvents(CTDocEvents value) {
        this.docEvents = value;
    }

    
    public CTMcds getMcds() {
        return mcds;
    }

    
    public void setMcds(CTMcds value) {
        this.mcds = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.ppp.Child;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_Mcd")
public class CTMcd
    implements Child
{

    @XmlAttribute(name = "macroName", namespace = "http:
    protected String macroName;
    @XmlAttribute(name = "name", namespace = "http:
    protected String name;
    @XmlAttribute(name = "menuHelp", namespace = "http:
    protected String menuHelp;
    @XmlAttribute(name = "bEncrypt", namespace = "http:
    protected String bEncrypt;
    @XmlAttribute(name = "cmg", namespace = "http:
    protected String cmg;
    @XmlTransient
    private Object parent;

    
    public String getMacroName() {
        return macroName;
    }

    
    public void setMacroName(String value) {
        this.macroName = value;
    }

    
    public String getName() {
        return name;
    }

    
    public void setName(String value) {
        this.name = value;
    }

    
    public String getMenuHelp() {
        return menuHelp;
    }

    
    public void setMenuHelp(String value) {
        this.menuHelp = value;
    }

    
    public String getBEncrypt() {
        return bEncrypt;
    }

    
    public void setBEncrypt(String value) {
        this.bEncrypt = value;
    }

    
    public String getCmg() {
        return cmg;
    }

    
    public void setCmg(String value) {
        this.cmg = value;
    }

    
    public Object getParent() {
        return this.parent;
    }

    public void setParent(Object parent) {
        this.parent = parent;
    }

    
    public void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
        setParent(parent);
    }

}

<code block>

package org.docx4j.schemas.microsoft.com.office.word_2006.wordml;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.namespace.QName;



@XmlRegistry
public class ObjectFactory {

    private final static QName _VbaSuppData_QNAME = new QName("http:

    
    public ObjectFactory() {
    }

    
    public CTVbaSuppData createCTVbaSuppData() {
        return new CTVbaSuppData();
    }

    
    public CTMcd createCTMcd() {
        return new CTMcd();
    }

    
    public CTDocEvents createCTDocEvents() {
        return new CTDocEvents();
    }

    
    public CTMcds createCTMcds() {
        return new CTMcds();
    }

    
    @XmlElementDecl(namespace = "http:
    public JAXBElement<CTVbaSuppData> createVbaSuppData(CTVbaSuppData value) {
        return new JAXBElement<CTVbaSuppData>(_VbaSuppData_QNAME, CTVbaSuppData.class, null, value);
    }

}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;


import javax.xml.bind.JAXBElement;

import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPart;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.schemas.microsoft.com.office.word_2006.wordml.CTVbaSuppData;



public final class VbaDataPart extends JaxbXmlPart<JAXBElement<CTVbaSuppData>> {
	
	
	
	public VbaDataPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}		

	public VbaDataPart() throws InvalidFormatException {
		super( new PartName("/word/vbaData.xml") );
		init();
	}		
	
	
	public void init() {

		
		setContentType(new org.docx4j.openpackaging.contenttype.ContentType(
				org.docx4j.openpackaging.contenttype.ContentTypes.OFFICEDOCUMENT_VBA_DATA));

		
		setRelationshipType(Namespaces.VBA_DATA_WORD);
	}
	
}

<code block>

package org.docx4j;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicInteger;

import net.engio.mbassy.bus.MBassador;

import org.docx4j.convert.out.FOSettings;
import org.docx4j.convert.out.HTMLSettings;
import org.docx4j.convert.out.common.Exporter;
import org.docx4j.convert.out.common.preprocess.PartialDeepCopy;
import org.docx4j.convert.out.fo.FOExporterVisitor;
import org.docx4j.convert.out.fo.FOExporterXslt;
import org.docx4j.convert.out.html.HTMLExporterVisitor;
import org.docx4j.convert.out.html.HTMLExporterXslt;
import org.docx4j.events.Docx4jEvent;
import org.docx4j.events.EventFinished;
import org.docx4j.events.PackageIdentifier;
import org.docx4j.events.StartEvent;
import org.docx4j.events.WellKnownJobTypes;
import org.docx4j.events.WellKnownProcessSteps;
import org.docx4j.model.datastorage.BindingHandler;
import org.docx4j.model.datastorage.CustomXmlDataStoragePartSelector;
import org.docx4j.model.datastorage.OpenDoPEHandler;
import org.docx4j.model.datastorage.RemovalHandler;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.packages.OpcPackage;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
import org.docx4j.openpackaging.parts.CustomXmlDataStoragePart;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.WordprocessingML.FooterPart;
import org.docx4j.openpackaging.parts.WordprocessingML.HeaderPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.openpackaging.parts.relationships.RelationshipsPart;
import org.docx4j.relationships.Relationship;
import org.docx4j.utils.TraversalUtilVisitor;
import org.docx4j.wml.SdtElement;
import org.docx4j.wml.SdtPr;
import org.w3c.dom.Document;



public class Docx4J {
	
	public static final String MIME_PDF = FOSettings.MIME_PDF;
	public static final String MIME_FO = FOSettings.INTERNAL_FO_MIME;
	
	
	public static final int FLAG_NONE = 0;
	
	
	public static final int FLAG_EXPORT_PREFER_XSL = 1;
	
	
	public static final int FLAG_EXPORT_PREFER_NONXSL = 2;

	
	public static final int FLAG_SAVE_ZIP_FILE = 1;
	
	
	public static final int FLAG_SAVE_FLAT_XML = 2;
	

	
	public static final int FLAG_SAVE_ENCRYPTED_BINARYRC4 = 3;
			
	
	public static final int FLAG_SAVE_ENCRYPTED_STANDARD = 4;
	
	
	public static final int FLAG_SAVE_ENCRYPTED_AGILE = 5;
	
	
	public static final int FLAG_BIND_INSERT_XML = 1;
	
	
	public static final int FLAG_BIND_BIND_XML = 2;
	
	
	public static final int FLAG_BIND_REMOVE_SDT = 4;
	
	
	public static final int FLAG_BIND_REMOVE_XML = 8;
	
	private static MBassador<Docx4jEvent> bus;
	public static void setEventNotifier(MBassador<Docx4jEvent> eventbus) {
		bus = eventbus;
	}
	
	protected static class FindContentControlsVisitor extends TraversalUtilVisitor<SdtElement> {
		public static class BreakException extends RuntimeException {
		}
		
		protected Set<String> definedStoreItemIds = null;
		protected String storeItemId = null;
		public FindContentControlsVisitor(Set<String> definedStoreItemIds) {
			this.definedStoreItemIds = definedStoreItemIds;
		}
		
		@Override
		public void apply(SdtElement element) {
		SdtPr sdtPr = element.getSdtPr();
			
			if ((sdtPr.getDataBinding() != null) &&
				(sdtPr.getDataBinding().getStoreItemID() != null)) {
				String tmp = sdtPr.getDataBinding().getStoreItemID().toLowerCase();
				if (definedStoreItemIds.contains(tmp)) {
					storeItemId = tmp;
					throw new BreakException();
				}
			}
		}
		
		public String getdefinedStoreItemId() {
			return storeItemId;
		}
	}
	
	protected static final String NS_CONDITIONS = "http:
	protected static final String NS_XPATHS = "http:
	protected static final String NS_QUESTIONS = "http:
	protected static final String NS_COMPONENTS = "http:
	protected static final Set<String> PART_TO_REMOVE_SCHEMA_TYPES = new TreeSet<String>();
	
	static {
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_CONDITIONS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_XPATHS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_QUESTIONS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_COMPONENTS);
	}


		
	public static WordprocessingMLPackage load(File inFile) throws Docx4JException {
		
		return WordprocessingMLPackage.load(inFile);
	}

		
	public static WordprocessingMLPackage load(PackageIdentifier pkgIdentifier, File inFile) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(pkgIdentifier, inFile);
	}
	
		
	public static WordprocessingMLPackage load(InputStream inStream) throws Docx4JException {
		return WordprocessingMLPackage.load(inStream);
	}

		
	public static WordprocessingMLPackage load(PackageIdentifier pkgIdentifier, InputStream inStream) throws Docx4JException {
		return (WordprocessingMLPackage)OpcPackage.load(pkgIdentifier, inStream);
	}
	
	
		
	public static void save(WordprocessingMLPackage wmlPackage, File outFile, int flags) throws Docx4JException {
		
		wmlPackage.save(outFile, flags);
	}
	
		
	public static void save(WordprocessingMLPackage wmlPackage, OutputStream outStream, int flags) throws Docx4JException {
		
		wmlPackage.save(outStream, flags);
		
	}

		
	public static void save(WordprocessingMLPackage wmlPackage, File outFile, int flags, String password) throws Docx4JException {
		
		wmlPackage.save(outFile, flags, password);
	}
	
		
	public static void save(WordprocessingMLPackage wmlPackage, OutputStream outStream, int flags, String password) throws Docx4JException {
		
		wmlPackage.save(outStream, flags, password);
		
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, String xmlDocument, int flags) throws Docx4JException {
		
		ByteArrayInputStream xmlStream = null;
		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
			try {
				xmlStream = new ByteArrayInputStream(xmlDocument.getBytes("UTF-8"));
			} catch (UnsupportedEncodingException e1) {
				xmlStream = new ByteArrayInputStream(xmlDocument.getBytes());
			}
		}
        bind(wmlPackage, xmlStream, flags);
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, InputStream xmlDocument, int flags) throws Docx4JException {
		
		StartEvent bindJobStartEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage );
		bindJobStartEvent.publish();
		
		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
	    Document xmlDoc = null;
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
				try {
		            xmlDoc = XmlUtils.getNewDocumentBuilder().parse(xmlDocument);
				} catch (Exception e) {
					throw new Docx4JException("Problems creating a org.w3c.dom.Document for the passed input stream.", e);
				}
		}
        bind(wmlPackage, xmlDoc, flags);
        
		new EventFinished(bindJobStartEvent).publish();
        
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, Document xmlDocument, int flags) throws Docx4JException {
		
		OpenDoPEHandler	openDoPEHandler = null;
		CustomXmlDataStoragePart customXmlDataStoragePart = null;
		RemovalHandler removalHandler = null;
		
		
		AtomicInteger bookmarkId = null;

		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
		
		customXmlDataStoragePart 
			= CustomXmlDataStoragePartSelector.getCustomXmlDataStoragePart(wmlPackage);
		if (customXmlDataStoragePart==null) {
			throw new Docx4JException("Couldn't find CustomXmlDataStoragePart! exiting..");
		}
	
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_INSERT_XML );
			startEvent.publish();
			
			insertXMLData(customXmlDataStoragePart, xmlDocument);
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_BIND_XML) == FLAG_BIND_BIND_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_BIND_XML );
			startEvent.publish();
			
			
			
			openDoPEHandler = new OpenDoPEHandler(wmlPackage);
			openDoPEHandler.preprocess();
			
			BindingHandler bh = new BindingHandler(wmlPackage);
			bh.setStartingIdForNewBookmarks(openDoPEHandler.getNextBookmarkId());
			bh.applyBindings();
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_REMOVE_SDT) == FLAG_BIND_REMOVE_SDT) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_REMOVE_SDT );
			startEvent.publish();

			removeSDTs(wmlPackage);
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_REMOVE_XML) == FLAG_BIND_REMOVE_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_REMOVE_XML );
			startEvent.publish();
			
			removeDefinedCustomXmlParts(wmlPackage, customXmlDataStoragePart);
			
			new EventFinished(startEvent).publish();
		}
	}

	protected static void insertXMLData(CustomXmlDataStoragePart customXmlDataStoragePart, Document xmlDocument) throws Docx4JException {
		
		customXmlDataStoragePart.getData().setDocument(xmlDocument);
	}


	protected static String findXPathStorageItemIdInContentControls(WordprocessingMLPackage wmlPackage) {
	FindContentControlsVisitor visitor = null;
		if ((wmlPackage.getCustomXmlDataStorageParts() != null) && 
			(!wmlPackage.getCustomXmlDataStorageParts().isEmpty())) {
			try {
				visitor = new FindContentControlsVisitor(wmlPackage.getCustomXmlDataStorageParts().keySet());
				TraversalUtil.visit(wmlPackage, false, visitor);
			}
			catch (FindContentControlsVisitor.BreakException be) {
			}
		}
		return (visitor != null ? visitor.getdefinedStoreItemId() : null);
	}

	protected static void removeSDTs(WordprocessingMLPackage wmlPackage)throws Docx4JException {
	RemovalHandler removalHandler;
	removalHandler = new RemovalHandler();
	removalHandler.removeSDTs(wmlPackage.getMainDocumentPart(), RemovalHandler.Quantifier.ALL, (String[])null);
		for (Part part:wmlPackage.getParts().getParts().values()) {
			if (part instanceof HeaderPart) {
				removalHandler.removeSDTs((HeaderPart)part, RemovalHandler.Quantifier.ALL, (String[])null);
			}
			else if (part instanceof FooterPart) {
				removalHandler.removeSDTs((FooterPart)part, RemovalHandler.Quantifier.ALL, (String[])null);
			}
		}
	}

	protected static void removeDefinedCustomXmlParts(WordprocessingMLPackage wmlPackage, CustomXmlDataStoragePart customXmlDataStoragePart) {
	List<PartName> partsToRemove = new ArrayList<PartName>();
	RelationshipsPart relationshipsPart = wmlPackage.getMainDocumentPart().getRelationshipsPart();
	List<Relationship> relationshipsList = ((relationshipsPart != null) && 
										    (relationshipsPart.getRelationships() != null) ?
										    relationshipsPart.getRelationships().getRelationship() : null);
	Part part = null;
		if (relationshipsList != null) {
			for (Relationship relationship : relationshipsList) {
				if (Namespaces.CUSTOM_XML_DATA_STORAGE.equals(relationship.getType())) {
					part = relationshipsPart.getPart(relationship);
					if (part==customXmlDataStoragePart) {
						partsToRemove.add(part.getPartName());
					}
				}
			}
		}
		if (!partsToRemove.isEmpty()) {
			for (int i=0; i<partsToRemove.size(); i++) {
				relationshipsPart.removePart(partsToRemove.get(i));
			}
		}
	}







































	
		
	public static WordprocessingMLPackage clone(WordprocessingMLPackage wmlPackage) throws Docx4JException {
		
		return (WordprocessingMLPackage)PartialDeepCopy.process(wmlPackage, null);
	}
	
		
	public static FOSettings createFOSettings() {
		return new FOSettings();
	}
	
		
	public static void toFO(FOSettings settings, OutputStream outputStream, int flags) throws Docx4JException {
		
		Exporter<FOSettings> exporter = getFOExporter(flags);
		exporter.export(settings, outputStream);
	}
	
		
	public static void toPDF(WordprocessingMLPackage wmlPackage, OutputStream outputStream) throws Docx4JException {
		
		StartEvent startEvent = new StartEvent( wmlPackage, WellKnownProcessSteps.PDF );
		startEvent.publish();
		
		FOSettings settings = createFOSettings();
		settings.setWmlPackage(wmlPackage);
		settings.setApacheFopMime("application/pdf");
		toFO(settings, outputStream, FLAG_NONE);
		
		new EventFinished(startEvent).publish();
	}
	
	protected static Exporter<FOSettings> getFOExporter(int flags) {
		switch (flags) {
			case FLAG_EXPORT_PREFER_NONXSL:
				return FOExporterVisitor.getInstance();
			case FLAG_EXPORT_PREFER_XSL:
			default:
				return FOExporterXslt.getInstance();
		}
	}

		
	public static HTMLSettings createHTMLSettings() {
		return new HTMLSettings();
	}
	
		
	public static void toHTML(HTMLSettings settings, OutputStream outputStream, int flags) throws Docx4JException {

		StartEvent startEvent = new StartEvent( settings.getWmlPackage(), WellKnownProcessSteps.HTML_OUT );
		startEvent.publish();
		
		Exporter<HTMLSettings> exporter = getHTMLExporter(flags);
		exporter.export(settings, outputStream);
		
		new EventFinished(startEvent).publish();
	}
	
		
	public static void toHTML(WordprocessingMLPackage wmlPackage, String imageDirPath, String imageTargetUri, OutputStream outputStream) throws Docx4JException {

		StartEvent startEvent = new StartEvent( wmlPackage, WellKnownProcessSteps.HTML_OUT );
		startEvent.publish();
		
		HTMLSettings settings = createHTMLSettings();
		settings.setWmlPackage(wmlPackage);
		if (imageDirPath != null) {
			settings.setImageDirPath(imageDirPath);
		}
		if (imageTargetUri != null) {
			settings.setImageTargetUri(imageTargetUri);
		}
		toHTML(settings, outputStream, FLAG_NONE);
		
		new EventFinished(startEvent).publish();
	}
	
	protected static Exporter<HTMLSettings> getHTMLExporter(int flags) {
		switch (flags) {
			case FLAG_EXPORT_PREFER_NONXSL:
				return HTMLExporterVisitor.getInstance();
			case FLAG_EXPORT_PREFER_XSL:
			default:
				return HTMLExporterXslt.getInstance();
		}
	}
}

<code block>

package org.docx4j.jaxb;


import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;

import org.apache.commons.io.IOUtils;
import org.docx4j.utils.ResourceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Context {
	
	public static final JAXBContext jc;
	
	




	@Deprecated
	public static JAXBContext jcThemePart;
	
	public static JAXBContext jcDocPropsCore;
	public static JAXBContext jcDocPropsCustom;
	public static JAXBContext jcDocPropsExtended;
	public static JAXBContext jcRelationships;
	public static JAXBContext jcCustomXmlProperties;
	public static JAXBContext jcContentTypes;

	public static JAXBContext jcXmlPackage;
	
	private static JAXBContext jcXslFo;
	public static JAXBContext jcSectionModel;

	public static JAXBContext jcEncryption;

	
	public static JAXBContext jcMCE;
	
	private static Logger log = LoggerFactory.getLogger(Context.class);
		
	static {
		JAXBContext tempContext = null;

		
		log.info("java.vendor="+System.getProperty("java.vendor"));
		log.info("java.version="+System.getProperty("java.version"));
		
		
		try {
			searchManifestsForJAXBImplementationInfo( ClassLoader.getSystemClassLoader());
			if (Thread.currentThread().getContextClassLoader()==null) {
				log.warn("ContextClassLoader is null for current thread");
				
			} else if (ClassLoader.getSystemClassLoader()!=Thread.currentThread().getContextClassLoader()) {
				searchManifestsForJAXBImplementationInfo(Thread.currentThread().getContextClassLoader());
			}
		} catch ( java.security.AccessControlException e) {
			
			log.warn("Caught/ignored " + e.getMessage());
		}
		
		
		InputStream jaxbPropsIS=null;
		try {
			
			jaxbPropsIS = ResourceUtils.getResource("org/docx4j/wml/jaxb.properties");
			log.info("MOXy JAXB implementation intended..");
		} catch (Exception e3) {
			log.info("No MOXy JAXB config found; assume not intended..");
			log.debug(e3.getMessage());
		}
		if (jaxbPropsIS==null) {
			
			try {
				Object namespacePrefixMapper = NamespacePrefixMapperUtils.getPrefixMapper();
				if ( namespacePrefixMapper.getClass().getName().equals("org.docx4j.jaxb.NamespacePrefixMapperSunInternal") ) {
					
					log.info("Using Java 6/7 JAXB implementation");
				} else {
					log.info("Using JAXB Reference Implementation");			
				}
				
			} catch (JAXBException e) {
				log.error("PANIC! No suitable JAXB implementation available");
				log.error(e.getMessage(), e);
				e.printStackTrace();
			}
		}
      
      try { 
			
			
			
			
			
    	  	
    	  	
    	  	
    	  	
			
			java.lang.ClassLoader classLoader = Context.class.getClassLoader();

			tempContext = JAXBContext.newInstance("org.docx4j.wml:org.docx4j.w14:org.docx4j.w15:" +
					"org.docx4j.schemas.microsoft.com.office.word_2006.wordml:" +
					"org.docx4j.dml:org.docx4j.dml.chart:org.docx4j.dml.chartDrawing:org.docx4j.dml.compatibility:org.docx4j.dml.diagram:org.docx4j.dml.lockedCanvas:org.docx4j.dml.picture:org.docx4j.dml.wordprocessingDrawing:org.docx4j.dml.spreadsheetdrawing:org.docx4j.dml.diagram2008:" +
					
					"org.docx4j.vml:org.docx4j.vml.officedrawing:org.docx4j.vml.wordprocessingDrawing:org.docx4j.vml.presentationDrawing:org.docx4j.vml.spreadsheetDrawing:org.docx4j.vml.root:" +
					"org.docx4j.docProps.coverPageProps:" +
					"org.opendope.xpaths:org.opendope.conditions:org.opendope.questions:org.opendope.answers:org.opendope.components:org.opendope.SmartArt.dataHierarchy:" +
					"org.docx4j.math:" +
					"org.docx4j.sharedtypes:org.docx4j.bibliography:" +
					"org.docx4j.com.microsoft.schemas.office.word.x2010.wordprocessingDrawing", classLoader );
			
			if (tempContext.getClass().getName().equals("org.eclipse.persistence.jaxb.JAXBContext")) {
				log.info("MOXy JAXB implementation is in use!");
			} else {
				log.info("Not using MOXy; using " + tempContext.getClass().getName());				
			}
			
			jcThemePart = tempContext; 
			jcDocPropsCore = JAXBContext.newInstance("org.docx4j.docProps.core:org.docx4j.docProps.core.dc.elements:org.docx4j.docProps.core.dc.terms",classLoader );
			jcDocPropsCustom = JAXBContext.newInstance("org.docx4j.docProps.custom",classLoader );
			jcDocPropsExtended = JAXBContext.newInstance("org.docx4j.docProps.extended",classLoader );
			jcXmlPackage = JAXBContext.newInstance("org.docx4j.xmlPackage",classLoader );
			jcRelationships = JAXBContext.newInstance("org.docx4j.relationships",classLoader );
			jcCustomXmlProperties = JAXBContext.newInstance("org.docx4j.customXmlProperties",classLoader );
			jcContentTypes = JAXBContext.newInstance("org.docx4j.openpackaging.contenttype",classLoader );
			
			jcSectionModel = JAXBContext.newInstance("org.docx4j.model.structure.jaxb",classLoader );
			
			try {
				
				jcEncryption = JAXBContext.newInstance(
						 "org.docx4j.com.microsoft.schemas.office.x2006.encryption:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate:"
						+ "org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password:"
						,classLoader );
			} catch (javax.xml.bind.JAXBException e) {
				log.error(e.getMessage());
			}

			jcMCE = JAXBContext.newInstance("org.docx4j.mce",classLoader );
			
			log.debug(".. other contexts loaded ..");
										
			
		} catch (Exception ex) {
			log.error("Cannot initialize context", ex);
		}				
      jc = tempContext;
	}
	
	private static org.docx4j.wml.ObjectFactory wmlObjectFactory;
	
	public static org.docx4j.wml.ObjectFactory getWmlObjectFactory() {
		
		if (wmlObjectFactory==null) {
			wmlObjectFactory = new org.docx4j.wml.ObjectFactory();
		}
		return wmlObjectFactory;
		
	}

	public static JAXBContext getXslFoContext() {
		if (jcXslFo==null) {
			try {	
				Context tmp = new Context();
				java.lang.ClassLoader classLoader = tmp.getClass().getClassLoader();

				jcXslFo = JAXBContext.newInstance("org.plutext.jaxb.xslfo",classLoader );
				
			} catch (JAXBException ex) {
	      log.error("Cannot determine XSL-FO context", ex);
			}						
		}
		return jcXslFo;		
	}
	
	public static void searchManifestsForJAXBImplementationInfo(ClassLoader loader) {
	    Enumeration resEnum;
	    try {
	        resEnum = loader.getResources(JarFile.MANIFEST_NAME);
	        while (resEnum.hasMoreElements()) {
	        	InputStream is = null;
	            try {
	                URL url = (URL)resEnum.nextElement();

	                is = url.openStream();
	                if (is != null) {
	                    Manifest manifest = new Manifest(is);

                    	Attributes mainAttribs = manifest.getMainAttributes();
                    	String impTitle = mainAttribs.getValue("Implementation-Title");
                    	if (impTitle!=null
                    			&& impTitle.contains("JAXB Reference Implementation")
                    					|| impTitle.contains("org.eclipse.persistence") ) {
	                    
        	                log.info("\n" + url);
		                    for(Object key2  : mainAttribs.keySet() ) {
		                    	
		                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
		                    }
                    	}
                    	
	                    
	                    for(String key  :  manifest.getEntries().keySet() ) {
	    	                
	    	                if (key.equals("com.sun.xml.bind.v2.runtime")) {
		    	                log.info("Found JAXB reference implementation in " + url);
		                    	mainAttribs = manifest.getAttributes((String)key);
		                    
			                    for(Object key2  : mainAttribs.keySet() ) {
			                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
			                    }
		                    }
	                    }
	                    
	                }
	            }
	            catch (Exception e) {
	                

	            } finally {
	            	IOUtils.closeQuietly(is);
	            }
	        }
	    } catch (IOException e1) {
	        

	    }
	     
	}	
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewEngine;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentNode;
import org.docx4j.org.apache.poi.poifs.filesystem.Entry;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;



public class OleObjectBinaryPart extends BinaryPart {

	private static Logger log = LoggerFactory.getLogger(OleObjectBinaryPart.class);		
	
	public OleObjectBinaryPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();				
	}

	
	public OleObjectBinaryPart() throws InvalidFormatException {
		super( new PartName("/word/embeddings/oleObject1.bin") );
		init();				
	}
	
	public void init() {
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.OFFICEDOCUMENT_OLE_OBJECT));
			

		
		setRelationshipType(Namespaces.OLE_OBJECT);
		
		
	}

	POIFSFileSystem fs;
	public POIFSFileSystem getFs() throws IOException {
		if (fs==null) {
			initPOIFSFileSystem();
		}
		return fs;
	}
	
	public void initPOIFSFileSystem() throws IOException {
		
		if (getBuffer()!=null) {

			
			
			

			log.info("initing POIFSFileSystem from existing data");
			ByteArrayInputStream bais = new ByteArrayInputStream(this.getBytes());
			fs = new POIFSFileSystem(bais);
			
		} else {

			log.info("creating new empty POIFSFileSystem");
			fs = new POIFSFileSystem();
			writePOIFSFileSystem();
		}
	}
	
	
	public void writePOIFSFileSystem() throws IOException {
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream(); 

		getFs().writeFilesystem(baos);
		
		
		byte[] bytes = baos.toByteArray();
		
		
		setBinaryData( ByteBuffer.wrap(bytes) );
		
	}
	
	
    
    
    public void viewFile(boolean verbose) throws IOException
    {
    	viewFile(System.out, verbose);
    }

    
    public void viewFile(OutputStream os, boolean verbose) throws IOException
    {
    	String indent="";
    	boolean withSizes = true;    	
    	displayDirectory(getFs().getRoot(), os, indent, withSizes);
    	
    	if (verbose) {
	        List strings = POIFSViewEngine.inspectViewable(fs, true, 0, "  ");
			Iterator iter = strings.iterator();
	
			while (iter.hasNext()) {
				os.write( ((String)iter.next()).getBytes());
			}
    	}
    }
    
    
    private void displayDirectory(DirectoryNode dir, OutputStream os, String indent, boolean withSizes) throws IOException {
        System.out.println(indent + dir.getName() + " -");
        String newIndent = indent + "  ";

        boolean hadChildren = false;
        for(Iterator<Entry> it = dir.getEntries(); it.hasNext();) {
           hadChildren = true;
           Entry entry = it.next();
           if (entry instanceof DirectoryNode) {
              displayDirectory((DirectoryNode) entry, os, newIndent, withSizes);
           } else {
              DocumentNode doc = (DocumentNode) entry;
              String name = doc.getName();
              String size = "";
              if (name.charAt(0) < 10) {
                 String altname = "(0x0" + (int) name.charAt(0) + ")" + name.substring(1);
                 name = name.substring(1) + " <" + altname + ">";
              }
              if (withSizes) {
                 size = " [" + doc.getSize() + " / 0x" + 
                        Integer.toHexString(doc.getSize()) + "]";
              }
              os.write((newIndent + name + size + "\n").getBytes() );
           }
        }
        if (!hadChildren) {
        	os.write((newIndent + "(no children)").getBytes());
        }
     }
	
}

<code block>



package org.docx4j.openpackaging.packages;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.util.HashMap;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.docx4j.Docx4J;
import org.docx4j.TextUtils;
import org.docx4j.convert.in.FlatOpcXmlImporter;
import org.docx4j.convert.out.flatOpcXml.FlatOpcXmlCreator;
import org.docx4j.docProps.core.dc.elements.SimpleLiteral;
import org.docx4j.events.EventFinished;
import org.docx4j.events.PackageIdentifier;
import org.docx4j.events.PackageIdentifierTransient;
import org.docx4j.events.StartEvent;
import org.docx4j.events.WellKnownProcessSteps;
import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.NamespacePrefixMapperUtils;
import org.docx4j.openpackaging.Base;
import org.docx4j.openpackaging.contenttype.ContentTypeManager;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.io.LoadFromZipNG;
import org.docx4j.openpackaging.io.SaveToZipFile;
import org.docx4j.openpackaging.io3.Load3;
import org.docx4j.openpackaging.io3.Save;
import org.docx4j.openpackaging.io3.stores.PartStore;
import org.docx4j.openpackaging.io3.stores.ZipPartStore;
import org.docx4j.openpackaging.parts.CustomXmlPart;
import org.docx4j.openpackaging.parts.DocPropsCorePart;
import org.docx4j.openpackaging.parts.DocPropsCustomPart;
import org.docx4j.openpackaging.parts.DocPropsExtendedPart;
import org.docx4j.openpackaging.parts.ExternalTarget;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.Parts;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.org.apache.poi.poifs.crypt.Decryptor;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode;
import org.docx4j.org.apache.poi.poifs.crypt.Encryptor;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class OpcPackage extends Base implements PackageIdentifier {

	private static Logger log = LoggerFactory.getLogger(OpcPackage.class);

	
	public HashMap<String, String> handled = new HashMap<String, String>();
	
	
	protected Parts parts = new Parts();

	
	public Parts getParts() {

		
		
		
		return parts;		
	}
	
	
	protected HashMap<ExternalTarget, Part> externalResources 
		= new HashMap<ExternalTarget, Part>();
	public HashMap<ExternalTarget, Part> getExternalResources() {
		return externalResources;		
	}	
	
	protected HashMap<String, CustomXmlPart> customXmlDataStorageParts
		= new HashMap<String, CustomXmlPart>(); 
	
	public HashMap<String, CustomXmlPart> getCustomXmlDataStorageParts() {
		return customXmlDataStorageParts;
	}	
	
	protected ContentTypeManager contentTypeManager;

	public ContentTypeManager getContentTypeManager() {
		return contentTypeManager;
	}

	public void setContentTypeManager(ContentTypeManager contentTypeManager) {
		this.contentTypeManager = contentTypeManager;
	}
	
	private PartStore sourcePartStore;	
	
	
	public PartStore getSourcePartStore() {
		return sourcePartStore;
	}

	
	public void setSourcePartStore(PartStore partStore) {
		this.sourcePartStore = partStore;
	}

	private PartStore targetPartStore;	
	
	
	public PartStore getTargetPartStore() {
		return targetPartStore;
	}

	
	public void setTargetPartStore(PartStore partStore) {
		this.targetPartStore = partStore;
	}
	
	
	public OpcPackage() {
		try {
			this.setPartName(new PartName("/", false));
			
			contentTypeManager = new ContentTypeManager();
		} catch (Exception e) {
			log.error(e.getMessage());
			
		}
	}

	
	public OpcPackage(ContentTypeManager contentTypeManager) {
		try {
			this.setPartName(new PartName("/", false));
			
			this.contentTypeManager = contentTypeManager;
		} catch (Exception e) {
			log.error(e.getMessage());
			
		}
	}
	
	public OpcPackage getPackage() {
		return this;
	}
		
	
	protected DocPropsCorePart docPropsCorePart;

	protected DocPropsExtendedPart docPropsExtendedPart;
	
	protected DocPropsCustomPart docPropsCustomPart;
	
		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final java.io.File docxFile) throws Docx4JException {
		return load(pkgIdentifier, docxFile, null);
	}
	
		
	public static OpcPackage load(final java.io.File docxFile) throws Docx4JException {
		return load(docxFile, null);
	}
	
		
	public static OpcPackage load(final java.io.File docxFile, String password) throws Docx4JException {
		
		PackageIdentifier name = new PackageIdentifierTransient(docxFile.getName());
		
		try {
			return OpcPackage.load(name, new FileInputStream(docxFile), password );
		} catch (final FileNotFoundException e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load file from " + docxFile.getAbsolutePath(), e);
		}
	}

		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final java.io.File docxFile, String password) throws Docx4JException {
		
		try {
			return OpcPackage.load(pkgIdentifier, new FileInputStream(docxFile), password );
		} catch (final FileNotFoundException e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load file from " + docxFile.getAbsolutePath(), e);
		}
	}
	
		
	public static OpcPackage load(final InputStream inputStream) throws Docx4JException {
		return load(inputStream, "");
	}

		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream inputStream) throws Docx4JException {
		return load(pkgIdentifier, inputStream, "");
	}
	
		
	public static OpcPackage load(final InputStream inputStream, String password) throws Docx4JException {

		return load(null, inputStream,  password);
	}
	
		
	private static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream inputStream, String password) throws Docx4JException {
		
		
		final BufferedInputStream bis = new BufferedInputStream(inputStream);
		bis.mark(0);
		final byte[] firstTwobytes=new byte[2];
		int read=0;
		try {
			read = bis.read(firstTwobytes);
			bis.reset();
		} catch (final IOException e) {
			throw new Docx4JException("Error reading from the stream", e);
		}
		if (read!=2){
			throw new Docx4JException("Error reading from the stream (no bytes available)");
		}
		if (firstTwobytes[0]=='P' && firstTwobytes[1]=='K') { 
			return OpcPackage.load(pkgIdentifier, bis, Filetype.ZippedPackage, null);
		} else if  (firstTwobytes[0]==(byte)0xD0 && firstTwobytes[1]==(byte)0xCF) {
			
			log.info("Detected compound file");
			return OpcPackage.load(pkgIdentifier, bis, Filetype.Compound, password);
		} else {
			
			log.info("Assuming Flat OPC XML");
			return OpcPackage.load(pkgIdentifier, bis, Filetype.FlatOPC, null);
		}
	}
	
	
	
	@Deprecated
	public static OpcPackage load(final InputStream is, final boolean docxFormat) throws Docx4JException {
		return load(is);  
	}

	
	public static OpcPackage load(final InputStream is, Filetype type) throws Docx4JException {
		return load(is, type, null);
	}

	
	public static OpcPackage load(final InputStream is, Filetype type, String password) throws Docx4JException {

		return load(null, is, type, password);
	}
	
	
	private static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream is, Filetype type, String password) throws Docx4JException {

		if (pkgIdentifier==null) {
			pkgIdentifier = new PackageIdentifierTransient("pkg_" + System.currentTimeMillis());
		}
		
		StartEvent startEvent = new StartEvent( pkgIdentifier,  WellKnownProcessSteps.PKG_LOAD );
		startEvent.publish();			
		
		if (type.equals(Filetype.ZippedPackage)){
			
			final ZipPartStore partLoader = new ZipPartStore(is);
			final Load3 loader = new Load3(partLoader);
			OpcPackage opcPackage = loader.get();
			
			if (pkgIdentifier!=null) {
				opcPackage.setName(pkgIdentifier.name());
			}
			
			new EventFinished(startEvent).publish();						
			return opcPackage;
			


			
		} else if (type.equals(Filetype.Compound)){
			
	        try {
				POIFSFileSystem fs = new POIFSFileSystem(is);
				EncryptionInfo info = new EncryptionInfo(fs); 
		        Decryptor d = Decryptor.getInstance(info); 
		        log.debug("Decrypting with " + d.getClass().getName());
		        if (d.verifyPassword(password))   {
	                 log.debug("Password works");
	             } else {
	 				throw new Docx4JException("Problem reading encrypted document: wrong password?");
	             }
		        
				InputStream is2 = d.getDataStream(fs);
				
				final ZipPartStore partLoader = new ZipPartStore(is2);
				final Load3 loader = new Load3(partLoader);
				OpcPackage opcPackage = loader.get();
				
				if (pkgIdentifier!=null) {
					opcPackage.setName(pkgIdentifier.name());
				}
				
				return opcPackage;
				
			} catch (Exception e) {
				throw new Docx4JException("Problem reading encrypted document", e);
			} finally {
				new EventFinished(startEvent).publish();				
			}
		}
		
		try {
			FlatOpcXmlImporter xmlPackage = new FlatOpcXmlImporter(is); 
			return xmlPackage.get(); 
		} catch (final Exception e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load xml from stream ",e);
		} finally {
			new EventFinished(startEvent).publish();									
		}
	}

		
	public void save(java.io.File file) throws Docx4JException {
		if (file.getName().endsWith(".xml")) {
			save(file, Docx4J.FLAG_SAVE_FLAT_XML);			
		} else {
			save(file, Docx4J.FLAG_SAVE_ZIP_FILE);						
		}
	}	

		
	public void save(File outFile, int flags) throws Docx4JException {
		save( outFile,  flags,  null);
	}
	
		
	public void save(File outFile, int flags, String password) throws Docx4JException {
		
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(outFile);
			save(outStream, flags, password);
		} catch (FileNotFoundException e) {
			throw new Docx4JException("Exception creating output stream: " + e.getMessage(), e);
		}
		finally {
			if (outStream != null) {
				try {
					outStream.close();
				} catch (IOException e) {}
				outStream = null;
			}
		}
		
	}	

		
	public void save(OutputStream outStream) throws Docx4JException {
		save(outStream, Docx4J.FLAG_SAVE_ZIP_FILE);						
	}


		
	public void save(OutputStream outStream, int flags) throws Docx4JException {
		
		save( outStream,  flags, null);
	}
	
		
	public void save(OutputStream outStream, int flags, String password) throws Docx4JException {
		
		StartEvent startEvent = new StartEvent( this,  WellKnownProcessSteps.PKG_SAVE );
		startEvent.publish();
		
		if (flags == Docx4J.FLAG_SAVE_FLAT_XML) {
			JAXBContext jc = Context.jcXmlPackage;
			FlatOpcXmlCreator opcXmlCreator = new FlatOpcXmlCreator(this);
			org.docx4j.xmlPackage.Package pkg = opcXmlCreator.get();
			Marshaller marshaller;
			try {
				marshaller = jc.createMarshaller();
				NamespacePrefixMapperUtils.setProperty(marshaller, 
						NamespacePrefixMapperUtils.getPrefixMapper());			
				marshaller.marshal(pkg, outStream);				
			} catch (JAXBException e) {
				throw new Docx4JException("Exception marshalling document for output: " + e.getMessage(), e);
			}
		} else if (
				flags == Docx4J.FLAG_SAVE_ENCRYPTED_BINARYRC4
				|| flags == Docx4J.FLAG_SAVE_ENCRYPTED_STANDARD 
				|| flags == Docx4J.FLAG_SAVE_ENCRYPTED_AGILE 							
				) {
			
			if (password==null || password.trim().length()==0) {
				
				throw new Docx4JException("Encryption requested, but a new password not provided.");
			}

			EncryptionInfo info = null;			
			if (flags == Docx4J.FLAG_SAVE_ENCRYPTED_BINARYRC4) {
				info = new EncryptionInfo(EncryptionMode.binaryRC4);
				
			} else if (flags == Docx4J.FLAG_SAVE_ENCRYPTED_STANDARD ) {
				info = new EncryptionInfo(EncryptionMode.standard);	
				
			} else if (flags == Docx4J.FLAG_SAVE_ENCRYPTED_AGILE ) {
				info = new EncryptionInfo(EncryptionMode.agile);
				

			}  			

			Encryptor enc = info.getEncryptor();
			enc.confirmPassword(password); 

			try {
				POIFSFileSystem fs = new POIFSFileSystem();
				OutputStream os = enc.getDataStream(fs);	
				
				Save saver = new Save(this);
				saver.save(os);
				
				fs.writeFilesystem(outStream);
				
			} catch (Exception e) {
				throw new  Docx4JException("Error encrypting as OLE compound file", e);
			}
			
		} else {

			Save saver = new Save(this);
			saver.save(outStream);
		}
		new EventFinished(startEvent).publish();
	}	
	
	
	

	@Override
	public boolean setPartShortcut(Part part, String relationshipType) {
		if (relationshipType.equals(Namespaces.PROPERTIES_CORE)) {
			docPropsCorePart = (DocPropsCorePart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_CUSTOM)) {
			docPropsCustomPart = (DocPropsCustomPart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_EXTENDED)) {
			docPropsExtendedPart = (DocPropsExtendedPart)part;
			return true;			
		} else {	
			return false;
		}
	}

	public DocPropsCorePart getDocPropsCorePart() {















		return docPropsCorePart;
	}

	public DocPropsExtendedPart getDocPropsExtendedPart() {















		return docPropsExtendedPart;
	}

	
	public DocPropsCustomPart getDocPropsCustomPart() {
		


















		
		return docPropsCustomPart;
	}
	
		
	public void setTitle(String title) {
		
		if (this.getDocPropsCorePart()==null) {
			DocPropsCorePart core;
			try {
				core = new DocPropsCorePart();
				org.docx4j.docProps.core.ObjectFactory coreFactory = new org.docx4j.docProps.core.ObjectFactory();
				core.setJaxbElement(coreFactory.createCoreProperties() );
				this.addTargetPart(core);			
			} catch (InvalidFormatException e) {
				log.error(e.getMessage(), e);
			}
		}
		
		org.docx4j.docProps.core.dc.elements.ObjectFactory of = new org.docx4j.docProps.core.dc.elements.ObjectFactory();
		SimpleLiteral literal = of.createSimpleLiteral();
		literal.getContent().add(title);
		this.getDocPropsCorePart().getJaxbElement().setTitle(of.createTitle(literal) );				
	}
	
		
	public String getTitle() {
		
		if (this.getDocPropsCorePart()==null) {
			return null;
		}
		
		JAXBElement<SimpleLiteral> sl = this.getDocPropsCorePart().getJaxbElement().getTitle();
		if (sl == null) return null;
		
		StringWriter sw = new StringWriter(); 
		 try {
			TextUtils.extractText(sl, sw, Context.jcDocPropsCore);
		} catch (Exception e) {
			log.error(e.getMessage(), e);
		}
		return sw.toString();				
	}
	

	
	public OpcPackage clone() {
		
		OpcPackage result = null;
		
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		SaveToZipFile saver = new SaveToZipFile(this);
		try {
			saver.save(baos);
			result = load(new ByteArrayInputStream(baos.toByteArray()));
		} catch (Docx4JException e) {
			
			e.printStackTrace();
		}

		return result;
		
	}

	@Override
	public String name() {
		return name;
	}
	private String name;
	
	public void setName(String name) {
		this.name = name;
	}
	
}

<code block>
@javax.xml.bind.annotation.XmlSchema(namespace = "http:
package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_KeyData")
public class CTKeyData {

    @XmlAttribute(name = "saltSize", required = true)
    protected long saltSize;
    @XmlAttribute(name = "blockSize", required = true)
    protected long blockSize;
    @XmlAttribute(name = "keyBits", required = true)
    protected long keyBits;
    @XmlAttribute(name = "hashSize", required = true)
    protected long hashSize;
    @XmlAttribute(name = "cipherAlgorithm", required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String cipherAlgorithm;
    @XmlAttribute(name = "cipherChaining", required = true)
    protected STCipherChaining cipherChaining;
    @XmlAttribute(name = "hashAlgorithm", required = true)
    protected STHashAlgorithm hashAlgorithm;
    @XmlAttribute(name = "saltValue", required = true)
    protected byte[] saltValue;

    
    public long getSaltSize() {
        return saltSize;
    }

    
    public void setSaltSize(long value) {
        this.saltSize = value;
    }

    
    public long getBlockSize() {
        return blockSize;
    }

    
    public void setBlockSize(long value) {
        this.blockSize = value;
    }

    
    public long getKeyBits() {
        return keyBits;
    }

    
    public void setKeyBits(long value) {
        this.keyBits = value;
    }

    
    public long getHashSize() {
        return hashSize;
    }

    
    public void setHashSize(long value) {
        this.hashSize = value;
    }

    
    public String getCipherAlgorithm() {
        return cipherAlgorithm;
    }

    
    public void setCipherAlgorithm(String value) {
        this.cipherAlgorithm = value;
    }

    
    public STCipherChaining getCipherChaining() {
        return cipherChaining;
    }

    
    public void setCipherChaining(STCipherChaining value) {
        this.cipherChaining = value;
    }

    
    public STHashAlgorithm getHashAlgorithm() {
        return hashAlgorithm;
    }

    
    public void setHashAlgorithm(STHashAlgorithm value) {
        this.hashAlgorithm = value;
    }

    
    public byte[] getSaltValue() {
        return saltValue;
    }

    
    public void setSaltValue(byte[] value) {
        this.saltValue = value;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_Encryption", propOrder = {
    "keyData",
    "dataIntegrity",
    "keyEncryptors"
})
@XmlRootElement (name="encryption")
public class CTEncryption {

    @XmlElement(required = true)
    protected CTKeyData keyData;
    @XmlElement(required = true)
    protected CTDataIntegrity dataIntegrity;
    @XmlElement(required = true)
    protected CTKeyEncryptors keyEncryptors;

    
    public CTKeyData getKeyData() {
        return keyData;
    }

    
    public void setKeyData(CTKeyData value) {
        this.keyData = value;
    }

    
    public CTDataIntegrity getDataIntegrity() {
        return dataIntegrity;
    }

    
    public void setDataIntegrity(CTDataIntegrity value) {
        this.dataIntegrity = value;
    }

    
    public CTKeyEncryptors getKeyEncryptors() {
        return keyEncryptors;
    }

    
    public void setKeyEncryptors(CTKeyEncryptors value) {
        this.keyEncryptors = value;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;



@XmlType(name = "ST_CipherChaining")
@XmlEnum
public enum STCipherChaining {


    
    @XmlEnumValue("ChainingModeCBC")
    CHAINING_MODE_CBC("ChainingModeCBC"),

    
    @XmlEnumValue("ChainingModeCFB")
    CHAINING_MODE_CFB("ChainingModeCFB");
    private final String value;

    STCipherChaining(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static STCipherChaining fromValue(String v) {
        for (STCipherChaining c: STCipherChaining.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate.CTCertificateKeyEncryptor;
import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_KeyEncryptor", propOrder = {
    "encryptedPasswordKey",
    "encryptedCertificateKey"
})
public class CTKeyEncryptor {

    @XmlElement(name = "encryptedKey", namespace = "http:
    protected CTPasswordKeyEncryptor encryptedPasswordKey;
    @XmlElement(name = "encryptedKey", namespace = "http:
    protected CTCertificateKeyEncryptor encryptedCertificateKey;
    @XmlAttribute(name = "uri")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String uri;

    
    public CTPasswordKeyEncryptor getEncryptedPasswordKey() {
        return encryptedPasswordKey;
    }

    
    public void setEncryptedPasswordKey(CTPasswordKeyEncryptor value) {
        this.encryptedPasswordKey = value;
    }

    
    public CTCertificateKeyEncryptor getEncryptedCertificateKey() {
        return encryptedCertificateKey;
    }

    
    public void setEncryptedCertificateKey(CTCertificateKeyEncryptor value) {
        this.encryptedCertificateKey = value;
    }

    
    public String getUri() {
        return uri;
    }

    
    public void setUri(String value) {
        this.uri = value;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_KeyEncryptors", propOrder = {
    "keyEncryptor"
})
public class CTKeyEncryptors {

    @XmlElement(required = true)
    protected List<CTKeyEncryptor> keyEncryptor;

    
    public List<CTKeyEncryptor> getKeyEncryptor() {
        if (keyEncryptor == null) {
            keyEncryptor = new ArrayList<CTKeyEncryptor>();
        }
        return this.keyEncryptor;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.namespace.QName;



@XmlRegistry
public class ObjectFactory {

    private final static QName _Encryption_QNAME = new QName("http:

    
    public ObjectFactory() {
    }

    
    public CTEncryption createCTEncryption() {
        return new CTEncryption();
    }

    
    public CTKeyEncryptor createCTKeyEncryptor() {
        return new CTKeyEncryptor();
    }

    
    public CTDataIntegrity createCTDataIntegrity() {
        return new CTDataIntegrity();
    }

    
    public CTKeyData createCTKeyData() {
        return new CTKeyData();
    }

    
    public CTKeyEncryptors createCTKeyEncryptors() {
        return new CTKeyEncryptors();
    }

    
    @XmlElementDecl(namespace = "http:
    public JAXBElement<CTEncryption> createEncryption(CTEncryption value) {
        return new JAXBElement<CTEncryption>(_Encryption_QNAME, CTEncryption.class, null, value);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_DataIntegrity")
public class CTDataIntegrity {

    @XmlAttribute(name = "encryptedHmacKey", required = true)
    protected byte[] encryptedHmacKey;
    @XmlAttribute(name = "encryptedHmacValue", required = true)
    protected byte[] encryptedHmacValue;

    
    public byte[] getEncryptedHmacKey() {
        return encryptedHmacKey;
    }

    
    public void setEncryptedHmacKey(byte[] value) {
        this.encryptedHmacKey = value;
    }

    
    public byte[] getEncryptedHmacValue() {
        return encryptedHmacValue;
    }

    
    public void setEncryptedHmacValue(byte[] value) {
        this.encryptedHmacValue = value;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.encryption;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;



@XmlType(name = "ST_HashAlgorithm")
@XmlEnum
public enum STHashAlgorithm {


    
    @XmlEnumValue("SHA1")
    SHA_1("SHA1"),

    
    @XmlEnumValue("SHA256")
    SHA_256("SHA256"),

    
    @XmlEnumValue("SHA384")
    SHA_384("SHA384"),

    
    @XmlEnumValue("SHA512")
    SHA_512("SHA512"),

    
    @XmlEnumValue("MD5")
    MD_5("MD5"),

    
    @XmlEnumValue("MD4")
    MD_4("MD4"),

    
    @XmlEnumValue("MD2")
    MD_2("MD2"),

    
    @XmlEnumValue("RIPEMD-128")
    RIPEMD_128("RIPEMD-128"),

    
    @XmlEnumValue("RIPEMD-160")
    RIPEMD_160("RIPEMD-160"),

    
    WHIRLPOOL("WHIRLPOOL");
    private final String value;

    STHashAlgorithm(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static STHashAlgorithm fromValue(String v) {
        for (STHashAlgorithm c: STHashAlgorithm.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }

}

<code block>
@javax.xml.bind.annotation.XmlSchema(namespace = "http:
package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password;

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STHashAlgorithm;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_PasswordKeyEncryptor")
public class CTPasswordKeyEncryptor {

    @XmlAttribute(name = "saltSize", required = true)
    protected long saltSize;
    @XmlAttribute(name = "blockSize", required = true)
    protected long blockSize;
    @XmlAttribute(name = "keyBits", required = true)
    protected long keyBits;
    @XmlAttribute(name = "hashSize", required = true)
    protected long hashSize;
    @XmlAttribute(name = "cipherAlgorithm", required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String cipherAlgorithm;
    @XmlAttribute(name = "cipherChaining", required = true)
    protected STCipherChaining cipherChaining;
    @XmlAttribute(name = "hashAlgorithm", required = true)
    protected STHashAlgorithm hashAlgorithm;
    @XmlAttribute(name = "saltValue", required = true)
    protected byte[] saltValue;
    @XmlAttribute(name = "spinCount", required = true)
    protected long spinCount;
    @XmlAttribute(name = "encryptedVerifierHashInput", required = true)
    protected byte[] encryptedVerifierHashInput;
    @XmlAttribute(name = "encryptedVerifierHashValue", required = true)
    protected byte[] encryptedVerifierHashValue;
    @XmlAttribute(name = "encryptedKeyValue", required = true)
    protected byte[] encryptedKeyValue;

    
    public long getSaltSize() {
        return saltSize;
    }

    
    public void setSaltSize(long value) {
        this.saltSize = value;
    }

    
    public long getBlockSize() {
        return blockSize;
    }

    
    public void setBlockSize(long value) {
        this.blockSize = value;
    }

    
    public long getKeyBits() {
        return keyBits;
    }

    
    public void setKeyBits(long value) {
        this.keyBits = value;
    }

    
    public long getHashSize() {
        return hashSize;
    }

    
    public void setHashSize(long value) {
        this.hashSize = value;
    }

    
    public String getCipherAlgorithm() {
        return cipherAlgorithm;
    }

    
    public void setCipherAlgorithm(String value) {
        this.cipherAlgorithm = value;
    }

    
    public STCipherChaining getCipherChaining() {
        return cipherChaining;
    }

    
    public void setCipherChaining(STCipherChaining value) {
        this.cipherChaining = value;
    }

    
    public STHashAlgorithm getHashAlgorithm() {
        return hashAlgorithm;
    }

    
    public void setHashAlgorithm(STHashAlgorithm value) {
        this.hashAlgorithm = value;
    }

    
    public byte[] getSaltValue() {
        return saltValue;
    }

    
    public void setSaltValue(byte[] value) {
        this.saltValue = value;
    }

    
    public long getSpinCount() {
        return spinCount;
    }

    
    public void setSpinCount(long value) {
        this.spinCount = value;
    }

    
    public byte[] getEncryptedVerifierHashInput() {
        return encryptedVerifierHashInput;
    }

    
    public void setEncryptedVerifierHashInput(byte[] value) {
        this.encryptedVerifierHashInput = value;
    }

    
    public byte[] getEncryptedVerifierHashValue() {
        return encryptedVerifierHashValue;
    }

    
    public void setEncryptedVerifierHashValue(byte[] value) {
        this.encryptedVerifierHashValue = value;
    }

    
    public byte[] getEncryptedKeyValue() {
        return encryptedKeyValue;
    }

    
    public void setEncryptedKeyValue(byte[] value) {
        this.encryptedKeyValue = value;
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;



@XmlType(name = "ST_PasswordKeyEncryptorUri")
@XmlEnum
public enum STPasswordKeyEncryptorUri {

    @XmlEnumValue("http:
    HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_PASSWORD("http:
    private final String value;

    STPasswordKeyEncryptorUri(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static STPasswordKeyEncryptorUri fromValue(String v) {
        for (STPasswordKeyEncryptorUri c: STPasswordKeyEncryptorUri.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.namespace.QName;



@XmlRegistry
public class ObjectFactory {

    private final static QName _EncryptedKey_QNAME = new QName("http:

    
    public ObjectFactory() {
    }

    
    public CTPasswordKeyEncryptor createCTPasswordKeyEncryptor() {
        return new CTPasswordKeyEncryptor();
    }

    
    @XmlElementDecl(namespace = "http:
    public JAXBElement<CTPasswordKeyEncryptor> createEncryptedKey(CTPasswordKeyEncryptor value) {
        return new JAXBElement<CTPasswordKeyEncryptor>(_EncryptedKey_QNAME, CTPasswordKeyEncryptor.class, null, value);
    }

}

<code block>
@javax.xml.bind.annotation.XmlSchema(namespace = "http:
package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate;

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;



@XmlType(name = "ST_PasswordKeyEncryptorUri")
@XmlEnum
public enum STPasswordKeyEncryptorUri {

    @XmlEnumValue("http:
    HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_CERTIFICATE("http:
    private final String value;

    STPasswordKeyEncryptorUri(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static STPasswordKeyEncryptorUri fromValue(String v) {
        for (STPasswordKeyEncryptorUri c: STPasswordKeyEncryptorUri.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.namespace.QName;



@XmlRegistry
public class ObjectFactory {

    private final static QName _EncryptedKey_QNAME = new QName("http:

    
    public ObjectFactory() {
    }

    
    public CTCertificateKeyEncryptor createCTCertificateKeyEncryptor() {
        return new CTCertificateKeyEncryptor();
    }

    
    @XmlElementDecl(namespace = "http:
    public JAXBElement<CTCertificateKeyEncryptor> createEncryptedKey(CTCertificateKeyEncryptor value) {
        return new JAXBElement<CTCertificateKeyEncryptor>(_EncryptedKey_QNAME, CTCertificateKeyEncryptor.class, null, value);
    }

}

<code block>

package org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;



@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CT_CertificateKeyEncryptor")
public class CTCertificateKeyEncryptor {

    @XmlAttribute(name = "encryptedKeyValue", required = true)
    protected byte[] encryptedKeyValue;
    @XmlAttribute(name = "X509Certificate", required = true)
    protected byte[] x509Certificate;
    @XmlAttribute(name = "certVerifier", required = true)
    protected byte[] certVerifier;

    
    public byte[] getEncryptedKeyValue() {
        return encryptedKeyValue;
    }

    
    public void setEncryptedKeyValue(byte[] value) {
        this.encryptedKeyValue = value;
    }

    
    public byte[] getX509Certificate() {
        return x509Certificate;
    }

    
    public void setX509Certificate(byte[] value) {
        this.x509Certificate = value;
    }

    
    public byte[] getCertVerifier() {
        return certVerifier;
    }

    
    public void setCertVerifier(byte[] value) {
        this.certVerifier = value;
    }

}

<code block>
package org.docx4j.org.apache.poi;




public class EmptyFileException extends IllegalArgumentException {
    private static final long serialVersionUID = 1536449292174360166L;

    public EmptyFileException() {
		super("The supplied file was empty (zero bytes long)");
	}
}
<code block>

package org.docx4j.org.apache.poi;


public abstract class UnsupportedFileFormatException extends IllegalArgumentException {
    private static final long serialVersionUID = -8281969197282030046L;

    public UnsupportedFileFormatException(String s) {
		super(s);
	}
}
<code block>

package org.docx4j.org.apache.poi;


public abstract class OldFileFormatException extends UnsupportedFileFormatException {
    private static final long serialVersionUID = 7849681804154571175L;

    public OldFileFormatException(String s) {
		super(s);
	}
}
<code block>

package org.docx4j.org.apache.poi;

public class EncryptedDocumentException extends IllegalStateException
{
    private static final long serialVersionUID = 7276950444540469193L;
    
	public EncryptedDocumentException(String s) {
		super(s);
	}

    public EncryptedDocumentException(String message, Throwable cause) {
        super(message, cause);
    }

    public EncryptedDocumentException(Throwable cause) {
        super(cause);
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.common;


public interface POIFSConstants
{
    
    public static final int SMALLER_BIG_BLOCK_SIZE = 0x0200;
    public static final POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(SMALLER_BIG_BLOCK_SIZE, (short)9);
    
    public static final int LARGER_BIG_BLOCK_SIZE = 0x1000;
    public static final POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(LARGER_BIG_BLOCK_SIZE, (short)12);
    
    
    public static final int SMALL_BLOCK_SIZE = 0x0040; 
    
    
    public static final int PROPERTY_SIZE  = 0x0080;
    
    
    public static final int BIG_BLOCK_MINIMUM_DOCUMENT_SIZE = 0x1000;
    
    
    public static final int LARGEST_REGULAR_SECTOR_NUMBER = -5;
    
    
    public static final int DIFAT_SECTOR_BLOCK   = -4;
    
    public static final int FAT_SECTOR_BLOCK   = -3;
    
    public static final int END_OF_CHAIN   = -2;
    
    public static final int UNUSED_BLOCK   = -1;
    
    
    public static final byte[] OOXML_FILE_HEADER = 
    	new byte[] { 0x50, 0x4b, 0x03, 0x04 };
}   

<code block>


        

package org.docx4j.org.apache.poi.poifs.common;

import org.docx4j.org.apache.poi.util.LittleEndianConsts;


public final class POIFSBigBlockSize
{
   private int bigBlockSize;
   private short headerValue;
   
   protected POIFSBigBlockSize(int bigBlockSize, short headerValue) {
      this.bigBlockSize = bigBlockSize;
      this.headerValue = headerValue;
   }
   
   public int getBigBlockSize() {
      return bigBlockSize;
   }
   
   
   public short getHeaderValue() {
      return headerValue;
   }
   
   public int getPropertiesPerBlock() {
      return bigBlockSize / POIFSConstants.PROPERTY_SIZE;
   }
   
   public int getBATEntriesPerBlock() {
      return bigBlockSize / LittleEndianConsts.INT_SIZE;
   }
   public int getXBATEntriesPerBlock() {
      return getBATEntriesPerBlock() - 1;
   }
   public int getNextXBATChainOffset() {
      return getXBATEntriesPerBlock() * LittleEndianConsts.INT_SIZE;
   }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.eventfilesystem;

import java.util.*;

import org.docx4j.org.apache.poi.poifs.filesystem.DocumentDescriptor;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSDocumentPath;



class POIFSReaderRegistry
{

    
    private Set omnivorousListeners;

    
    
    
    
    private Map selectiveListeners;

    
    
    
    
    
    private Map chosenDocumentDescriptors;

    

    POIFSReaderRegistry()
    {
        omnivorousListeners       = new HashSet();
        selectiveListeners        = new HashMap();
        chosenDocumentDescriptors = new HashMap();
    }

    

    void registerListener(final POIFSReaderListener listener,
                          final POIFSDocumentPath path,
                          final String documentName)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            Set descriptors = ( Set ) selectiveListeners.get(listener);

            if (descriptors == null)
            {

                
                descriptors = new HashSet();
                selectiveListeners.put(listener, descriptors);
            }
            DocumentDescriptor descriptor = new DocumentDescriptor(path,
                                                documentName);

            if (descriptors.add(descriptor))
            {

                
                
                
                Set listeners =
                    ( Set ) chosenDocumentDescriptors.get(descriptor);

                if (listeners == null)
                {

                    
                    listeners = new HashSet();
                    chosenDocumentDescriptors.put(descriptor, listeners);
                }
                listeners.add(listener);
            }
        }
    }

    

    void registerListener(final POIFSReaderListener listener)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            
            
            removeSelectiveListener(listener);
            omnivorousListeners.add(listener);
        }
    }

    

    Iterator getListeners(final POIFSDocumentPath path, final String name)
    {
        Set rval               = new HashSet(omnivorousListeners);
        Set selectiveListeners =
            ( Set ) chosenDocumentDescriptors.get(new DocumentDescriptor(path,
                name));

        if (selectiveListeners != null)
        {
            rval.addAll(selectiveListeners);
        }
        return rval.iterator();
    }

    private void removeSelectiveListener(final POIFSReaderListener listener)
    {
        Set selectedDescriptors = ( Set ) selectiveListeners.remove(listener);

        if (selectedDescriptors != null)
        {
            Iterator iter = selectedDescriptors.iterator();

            while (iter.hasNext())
            {
                dropDocument(listener, ( DocumentDescriptor ) iter.next());
            }
        }
    }

    private void dropDocument(final POIFSReaderListener listener,
                              final DocumentDescriptor descriptor)
    {
        Set listeners = ( Set ) chosenDocumentDescriptors.get(descriptor);

        listeners.remove(listener);
        if (listeners.size() == 0)
        {
            chosenDocumentDescriptors.remove(descriptor);
        }
    }
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.eventfilesystem;

import java.io.*;
import java.util.*;

import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSDocumentPath;
import org.docx4j.org.apache.poi.poifs.property.DirectoryProperty;
import org.docx4j.org.apache.poi.poifs.property.Property;
import org.docx4j.org.apache.poi.poifs.property.PropertyTable;
import org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.docx4j.org.apache.poi.poifs.storage.BlockList;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;
import org.docx4j.org.apache.poi.poifs.storage.RawDataBlockList;
import org.docx4j.org.apache.poi.poifs.storage.SmallBlockTableReader;



public class POIFSReader
{
    private POIFSReaderRegistry registry;
    private boolean             registryClosed;

    

    public POIFSReader()
    {
        registry       = new POIFSReaderRegistry();
        registryClosed = false;
    }

    

    public void read(final InputStream stream)
        throws IOException
    {
        registryClosed = true;

        
        HeaderBlock header_block = new HeaderBlock(stream);

        
        RawDataBlockList data_blocks = new RawDataBlockList(stream, header_block.getBigBlockSize());

        
        
        new BlockAllocationTableReader(header_block.getBigBlockSize(),
                                       header_block.getBATCount(),
                                       header_block.getBATArray(),
                                       header_block.getXBATCount(),
                                       header_block.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block, data_blocks);

        
        processProperties(SmallBlockTableReader
            .getSmallDocumentBlocks(
                  header_block.getBigBlockSize(),
                  data_blocks, properties.getRoot(), 
                  header_block.getSBATStart()), 
                  data_blocks, properties.getRoot()
                        .getChildren(), new POIFSDocumentPath());
    }

    

    public void registerListener(final POIFSReaderListener listener)
    {
        if (listener == null)
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final String name)
    {
        registerListener(listener, null, name);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final POIFSDocumentPath path,
                                 final String name)
    {
        if ((listener == null) || (name == null) || (name.length() == 0))
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener,
                                  (path == null) ? new POIFSDocumentPath()
                                                 : path, name);
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length == 0)
        {
            System.err
                .println("at least one argument required: input filename(s)");
            System.exit(1);
        }

        
        for (int j = 0; j < args.length; j++)
        {
            POIFSReader         reader   = new POIFSReader();
            POIFSReaderListener listener = new SampleListener();

            reader.registerListener(listener);
            System.out.println("reading " + args[ j ]);
            FileInputStream istream = new FileInputStream(args[ j ]);

            reader.read(istream);
            istream.close();
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator properties,
                                   final POIFSDocumentPath path)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property property = ( Property ) properties.next();
            String   name     = property.getName();

            if (property.isDirectory())
            {
                POIFSDocumentPath new_path = new POIFSDocumentPath(path,
                                                 new String[]
                {
                    name
                });

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(), new_path);
            }
            else
            {
                int      startBlock = property.getStartBlock();
                Iterator listeners  = registry.getListeners(path, name);

                if (listeners.hasNext())
                {
                    int            size     = property.getSize();
                    OPOIFSDocument document = null;

                    if (property.shouldUseSmallBlocks())
                    {
                        document =
                            new OPOIFSDocument(name, small_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    else
                    {
                        document =
                            new OPOIFSDocument(name, big_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    while (listeners.hasNext())
                    {
                        POIFSReaderListener listener =
                            ( POIFSReaderListener ) listeners.next();

                        listener.processPOIFSReaderEvent(
                            new POIFSReaderEvent(
                                new DocumentInputStream(document), path,
                                name));
                    }
                }
                else
                {

                    
                    if (property.shouldUseSmallBlocks())
                    {
                        small_blocks.fetchBlocks(startBlock, -1);
                    }
                    else
                    {
                        big_blocks.fetchBlocks(startBlock, -1);
                    }
                }
            }
        }
    }

    private static class SampleListener
        implements POIFSReaderListener
    {

        

        SampleListener()
        {
        }

        

        public void processPOIFSReaderEvent(final POIFSReaderEvent event)
        {
            DocumentInputStream istream = event.getStream();
            POIFSDocumentPath   path    = event.getPath();
            String              name    = event.getName();

            try
            {
                byte[] data = new byte[ istream.available() ];

                istream.read(data);
                int pathLength = path.length();

                for (int k = 0; k < pathLength; k++)
                {
                    System.out.print("/" + path.getComponent(k));
                }
                System.out.println("/" + name + ": " + data.length
                                   + " bytes read");
            }
            catch (IOException ignored)
            {
            }
        }
    }   
}       


<code block>


        

package org.docx4j.org.apache.poi.poifs.eventfilesystem;

import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSDocumentPath;



public class POIFSReaderEvent
{
    private DocumentInputStream stream;
    private POIFSDocumentPath   path;
    private String              documentName;

    

    POIFSReaderEvent(final DocumentInputStream stream,
                     final POIFSDocumentPath path, final String documentName)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
    }

    

    public DocumentInputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.eventfilesystem;



public interface POIFSReaderListener
{

    

    public void processPOIFSReaderEvent(POIFSReaderEvent event);
}   


<code block>


package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSStream;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class NPropertyTable extends PropertyTableBase {


	private static Logger _logger = LoggerFactory.getLogger(NPropertyTable.class);
	
    private POIFSBigBlockSize _bigBigBlockSize;

    public NPropertyTable(HeaderBlock headerBlock)
    {
        super(headerBlock);
        _bigBigBlockSize = headerBlock.getBigBlockSize();
    }

    
    public NPropertyTable(final HeaderBlock headerBlock,
                          final NPOIFSFileSystem filesystem)
        throws IOException
    {
        super(
              headerBlock,
              buildProperties(
                    (new NPOIFSStream(filesystem, headerBlock.getPropertyStart())).iterator(),
                    headerBlock.getBigBlockSize()
              )
        );
        _bigBigBlockSize = headerBlock.getBigBlockSize();
    }
    
    
    private static List<Property> buildProperties(final Iterator<ByteBuffer> dataSource,
          final POIFSBigBlockSize bigBlockSize) throws IOException
    {
       List<Property> properties = new ArrayList<Property>();
       while(dataSource.hasNext()) {
          ByteBuffer bb = dataSource.next();
          
          
          byte[] data;
          if(bb.hasArray() && bb.arrayOffset() == 0 && 
                bb.array().length == bigBlockSize.getBigBlockSize()) {
             data = bb.array();
          } else {
             data = new byte[bigBlockSize.getBigBlockSize()];
             
             int toRead = data.length;
             if (bb.remaining() < bigBlockSize.getBigBlockSize()) {
                
                
                
                _logger.warn( "Short Property Block, ", bb.remaining(),
                            " bytes instead of the expected " + bigBlockSize.getBigBlockSize());
                toRead = bb.remaining();
             }
             
             bb.get(data, 0, toRead);
          }
          
          PropertyFactory.convertToProperties(data, properties);
       }
       return properties;
    }

    
    public int countBlocks()
    {
       int size = _properties.size() * POIFSConstants.PROPERTY_SIZE;
       return (int)Math.ceil(size / _bigBigBlockSize.getBigBlockSize());
    }
 
    
    public void preWrite() {
        List<Property> pList = new ArrayList<Property>();
        
        int i=0;
        for (Property p : _properties) {
            
            if (p == null) continue;
            p.setIndex(i++);
            pList.add(p);
        }

        
        for (Property p : pList) p.preWrite();
    }    
    
    
    public void write(NPOIFSStream stream) throws IOException {
       OutputStream os = stream.getOutputStream();
       for(Property property : _properties) {
          if(property != null) {
             property.writeData(os);
          }
       }
       os.close();
       
       
       if(getStartBlock() != stream.getStartBlock()) {
          setStartBlock(stream.getStartBlock());
       }
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.property;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.storage.SmallDocumentBlock;


public final class RootProperty extends DirectoryProperty {
   private static final String NAME = "Root Entry";

    RootProperty()
    {
        super(NAME);

        
        setNodeColor(_NODE_BLACK);
        setPropertyType(PropertyConstants.ROOT_TYPE);
        setStartBlock(POIFSConstants.END_OF_CHAIN);
    }

    
    protected RootProperty(final int index, final byte [] array,
                           final int offset)
    {
        super(index, array, offset);
    }

    
    public void setSize(int size)
    {
        super.setSize(SmallDocumentBlock.calcSize(size));
    }

    
    @Override
    public String getName() {
        return NAME;
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.property;

import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument;



public class DocumentProperty
    extends Property
{

    
    private OPOIFSDocument _document;

    

    public DocumentProperty(final String name, final int size)
    {
        super();
        _document = null;
        setName(name);
        setSize(size);
        setNodeColor(_NODE_BLACK);   
        setPropertyType(PropertyConstants.DOCUMENT_TYPE);
    }

    

    protected DocumentProperty(final int index, final byte [] array,
                               final int offset)
    {
        super(index, array, offset);
        _document = null;
    }

    

    public void setDocument(OPOIFSDocument doc)
    {
        _document = doc;
    }

    

    public OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public boolean shouldUseSmallBlocks()
    {
        return super.shouldUseSmallBlocks();
    }

    

    public boolean isDirectory()
    {
        return false;
    }

    

    protected void preWrite()
    {

        
    }
    
    
    public void updateSize(int size)
    {
        setSize(size);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;


public class DirectoryProperty extends Property implements Parent, Iterable<Property> { 

    
    private List<Property> _children;

    
    private Set<String>  _children_names;

    
    public DirectoryProperty(String name)
    {
        super();
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
        setName(name);
        setSize(0);
        setPropertyType(PropertyConstants.DIRECTORY_TYPE);
        setStartBlock(0);
        setNodeColor(_NODE_BLACK);   
    }

    
    protected DirectoryProperty(final int index, final byte [] array,
                                final int offset)
    {
        super(index, array, offset);
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
    }

    
    public boolean changeName(Property property, String newName)
    {
        boolean result;
        String  oldName = property.getName();

        property.setName(newName);
        String cleanNewName = property.getName();

        if (_children_names.contains(cleanNewName))
        {

            
            property.setName(oldName);
            result = false;
        }
        else
        {
            _children_names.add(cleanNewName);
            _children_names.remove(oldName);
            result = true;
        }
        return result;
    }

    
    public boolean deleteChild(Property property)
    {
        boolean result = _children.remove(property);

        if (result)
        {
            _children_names.remove(property.getName());
        }
        return result;
    }

    public static class PropertyComparator implements Comparator<Property> {

        
        public int compare(Property o1, Property o2)
        {
            String VBA_PROJECT = "_VBA_PROJECT";
            String name1  = o1.getName();
            String name2  = o2.getName();
            int  result = name1.length() - name2.length();

            if (result == 0)
            {
              
              if (name1.compareTo(VBA_PROJECT) == 0)
                result = 1;
              else if (name2.compareTo(VBA_PROJECT) == 0)
                result = -1;
              else
              {
                if (name1.startsWith("__") && name2.startsWith("__"))
                {
                  
                  result = name1.compareToIgnoreCase(name2);
                }
                else if (name1.startsWith("__"))
                {
                  
                  result = 1;
                }
                else if (name2.startsWith("__"))
                {
                  
                  result = -1;
                }
                else
                  
                  
                  result = name1.compareToIgnoreCase(name2);
              }
            }
            return result;
        }
    }

    
    public boolean isDirectory()
    {
        return true;
    }

    
    protected void preWrite()
    {
        if (_children.size() > 0)
        {
            Property[] children = _children.toArray(new Property[ 0 ]);

            Arrays.sort(children, new PropertyComparator());
            int midpoint = children.length / 2;

            setChildProperty(children[ midpoint ].getIndex());
            children[ 0 ].setPreviousChild(null);
            children[ 0 ].setNextChild(null);
            for (int j = 1; j < midpoint; j++)
            {
                children[ j ].setPreviousChild(children[ j - 1 ]);
                children[ j ].setNextChild(null);
            }
            if (midpoint != 0)
            {
                children[ midpoint ]
                    .setPreviousChild(children[ midpoint - 1 ]);
            }
            if (midpoint != (children.length - 1))
            {
                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);
                for (int j = midpoint + 1; j < children.length - 1; j++)
                {
                    children[ j ].setPreviousChild(null);
                    children[ j ].setNextChild(children[ j + 1 ]);
                }
                children[ children.length - 1 ].setPreviousChild(null);
                children[ children.length - 1 ].setNextChild(null);
            }
            else
            {
                children[ midpoint ].setNextChild(null);
            }
        }
    }

    
    public Iterator<Property> getChildren()
    {
        return _children.iterator();
    }
    
    public Iterator<Property> iterator() {
        return getChildren();
    }

    
    public void addChild(final Property property)
        throws IOException
    {
        String name = property.getName();

        if (_children_names.contains(name))
        {
            throw new IOException("Duplicate name \"" + name + "\"");
        }
        _children_names.add(name);
        _children.add(property);
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.*;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.storage.ListManagedBlock;



class PropertyFactory
{
    
    private PropertyFactory()
    {
    }

    
    static List<Property> convertToProperties(ListManagedBlock [] blocks)
        throws IOException
    {
        List<Property> properties = new ArrayList<Property>();

        for (int j = 0; j < blocks.length; j++) {
            byte[] data = blocks[ j ].getData();
            convertToProperties(data, properties);
        }
        return properties;
    }
    
    static void convertToProperties(byte[] data, List<Property> properties)
        throws IOException
    {
       int property_count = data.length / POIFSConstants.PROPERTY_SIZE;
       int offset         = 0;

       for (int k = 0; k < property_count; k++) {
          switch (data[ offset + PropertyConstants.PROPERTY_TYPE_OFFSET ]) {
          case PropertyConstants.DIRECTORY_TYPE :
             properties.add(
                   new DirectoryProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.DOCUMENT_TYPE :
             properties.add(
                   new DocumentProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.ROOT_TYPE :
             properties.add(
                   new RootProperty(properties.size(), data, offset)
             );
             break;

          default :
             properties.add(null);
             break;
          }
          
          offset += POIFSConstants.PROPERTY_SIZE;
       }
    }
    
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.property;



public interface Child
{

    

    public Child getNextChild();

    

    public Child getPreviousChild();

    

    public void setNextChild(final Child child);

    

    public void setPreviousChild(final Child child);
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.property;



public interface PropertyConstants
{
    public static final int  PROPERTY_TYPE_OFFSET = 0x42;

    
    public static final byte DIRECTORY_TYPE       = 1;
    public static final byte DOCUMENT_TYPE        = 2;
    public static final byte ROOT_TYPE            = 5;
}   


<code block>


package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.storage.BlockWritable;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;
import org.docx4j.org.apache.poi.poifs.storage.PropertyBlock;
import org.docx4j.org.apache.poi.poifs.storage.RawDataBlockList;


public final class PropertyTable extends PropertyTableBase implements BlockWritable {
    private POIFSBigBlockSize _bigBigBlockSize;
    private BlockWritable[]   _blocks;

    public PropertyTable(HeaderBlock headerBlock)
    {
        super(headerBlock);
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks = null;
    }

    
    public PropertyTable(final HeaderBlock headerBlock,
                         final RawDataBlockList blockList)
        throws IOException
    {
        super(
              headerBlock,
              PropertyFactory.convertToProperties(
                    blockList.fetchBlocks(headerBlock.getPropertyStart(), -1)
              )
        );
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks      = null;
    }

    
    public void preWrite()
    {
        Property[] properties = _properties.toArray(new Property[_properties.size()]);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].setIndex(k);
        }

        
        _blocks = PropertyBlock.createPropertyBlockArray(_bigBigBlockSize, _properties);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].preWrite();
        }
    }
    
    
    public int countBlocks()
    {
        return (_blocks == null) ? 0
                                 : _blocks.length;
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        if (_blocks != null)
        {
            for (int j = 0; j < _blocks.length; j++)
            {
                _blocks[ j ].writeBlocks(stream);
            }
        }
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import org.docx4j.org.apache.poi.poifs.filesystem.BATManaged;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;


public abstract class PropertyTableBase implements BATManaged {
    private   final HeaderBlock    _header_block;
    protected final List<Property> _properties;

    public PropertyTableBase(final HeaderBlock header_block)
    {
        _header_block = header_block;
        _properties  = new ArrayList<Property>();
        addProperty(new RootProperty());
    }

    
    public PropertyTableBase(final HeaderBlock header_block,
                         final List<Property> properties)
        throws IOException
    {
        _header_block = header_block;
        _properties   = properties;
        populatePropertyTree( (DirectoryProperty)_properties.get(0));
    }

    
    public void addProperty(Property property)
    {
        _properties.add(property);
    }

    
    public void removeProperty(final Property property)
    {
        _properties.remove(property);
    }

    
    public RootProperty getRoot()
    {
        
        return ( RootProperty ) _properties.get(0);
    }
    
    private void populatePropertyTree(DirectoryProperty root)
        throws IOException
    {
        int index = root.getChildIndex();

        if (!Property.isValidIndex(index))
        {

            
            return;
        }
        Stack<Property> children = new Stack<Property>();

        children.push(_properties.get(index));
        while (!children.empty())
        {
            Property property = children.pop();
            if (property == null)
            {
                
                continue;
            }

            root.addChild(property);
            if (property.isDirectory())
            {
                populatePropertyTree(( DirectoryProperty ) property);
            }
            index = property.getPreviousChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
            index = property.getNextChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
        }
    }

    
    public int getStartBlock()
    {
        return _header_block.getPropertyStart();
    }

    
    public void setStartBlock(final int index)
    {
        _header_block.setPropertyStart(index);
    }
}

<code block>




package org.docx4j.org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;

import org.docx4j.org.apache.poi.hpsf.ClassID;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.util.ByteField;
import org.docx4j.org.apache.poi.util.IntegerField;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.ShortField;



public abstract class Property implements Child, POIFSViewable {
    static final private byte   _default_fill             = ( byte ) 0x00;
    static final private int    _name_size_offset         = 0x40;
    static final private int    _max_name_length          =
        (_name_size_offset / LittleEndianConsts.SHORT_SIZE) - 1;
    static final protected int  _NO_INDEX                 = -1;

    
    static final private int    _node_color_offset        = 0x43;
    static final private int    _previous_property_offset = 0x44;
    static final private int    _next_property_offset     = 0x48;
    static final private int    _child_property_offset    = 0x4C;
    static final private int    _storage_clsid_offset     = 0x50;
    static final private int    _user_flags_offset        = 0x60;
    static final private int    _seconds_1_offset         = 0x64;
    static final private int    _days_1_offset            = 0x68;
    static final private int    _seconds_2_offset         = 0x6C;
    static final private int    _days_2_offset            = 0x70;
    static final private int    _start_block_offset       = 0x74;
    static final private int    _size_offset              = 0x78;

    
    static final protected byte _NODE_BLACK               = 1;
    static final protected byte _NODE_RED                 = 0;

    
    static final private int    _big_block_minimum_bytes  = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
    private String              _name;
    private ShortField          _name_size;
    private ByteField           _property_type;
    private ByteField           _node_color;
    private IntegerField        _previous_property;
    private IntegerField        _next_property;
    private IntegerField        _child_property;
    private ClassID             _storage_clsid;
    private IntegerField        _user_flags;
    private IntegerField        _seconds_1;
    private IntegerField        _days_1;
    private IntegerField        _seconds_2;
    private IntegerField        _days_2;
    private IntegerField        _start_block;
    private IntegerField        _size;
    private byte[]              _raw_data;
    private int                 _index;
    private Child               _next_child;
    private Child               _previous_child;

    protected Property()
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        Arrays.fill(_raw_data, _default_fill);
        _name_size         = new ShortField(_name_size_offset);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET);
        _node_color        = new ByteField(_node_color_offset);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _NO_INDEX, _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _NO_INDEX, _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _NO_INDEX, _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, 0,
                                              _raw_data);
        _days_1            = new IntegerField(_days_1_offset, 0, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, 0,
                                              _raw_data);
        _days_2            = new IntegerField(_days_2_offset, 0, _raw_data);
        _start_block       = new IntegerField(_start_block_offset);
        _size              = new IntegerField(_size_offset, 0, _raw_data);
        _index             = _NO_INDEX;
        setName("");
        setNextChild(null);
        setPreviousChild(null);
    }

    
    protected Property(int index, byte [] array, int offset)
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        System.arraycopy(array, offset, _raw_data, 0,
                         POIFSConstants.PROPERTY_SIZE);
        _name_size         = new ShortField(_name_size_offset, _raw_data);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET, _raw_data);
        _node_color        = new ByteField(_node_color_offset, _raw_data);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, _raw_data);
        _days_1            = new IntegerField(_days_1_offset, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, _raw_data);
        _days_2            = new IntegerField(_days_2_offset, _raw_data);
        _start_block       = new IntegerField(_start_block_offset, _raw_data);
        _size              = new IntegerField(_size_offset, _raw_data);
        _index             = index;
        int name_length = (_name_size.get() / LittleEndianConsts.SHORT_SIZE)
                          - 1;

        if (name_length < 1)
        {
            _name = "";
        }
        else
        {
            char[] char_array  = new char[ name_length ];
            int    name_offset = 0;

            for (int j = 0; j < name_length; j++)
            {
                char_array[ j ] = ( char ) new ShortField(name_offset,
                                                          _raw_data).get();
                name_offset     += LittleEndianConsts.SHORT_SIZE;
            }
            _name = new String(char_array, 0, name_length);
        }
        _next_child     = null;
        _previous_child = null;
    }

    
    public void writeData(OutputStream stream)
        throws IOException
    {
        stream.write(_raw_data);
    }

    
    public void setStartBlock(int startBlock)
    {
        _start_block.set(startBlock, _raw_data);
    }

    
    public int getStartBlock()
    {
        return _start_block.get();
    }

    
    public int getSize()
    {
        return _size.get();
    }

    
    public boolean shouldUseSmallBlocks()
    {
        return Property.isSmall(_size.get());
    }

    
    public static boolean isSmall(int length)
    {
        return length < _big_block_minimum_bytes;
    }

    
    public String getName()
    {
        return _name;
    }

    
    abstract public boolean isDirectory();

    
    public ClassID getStorageClsid()
    {
        return _storage_clsid;
    }

    
    protected void setName(String name)
    {
        char[] char_array = name.toCharArray();
        int    limit      = Math.min(char_array.length, _max_name_length);

        _name = new String(char_array, 0, limit);
        short offset = 0;
        int   j      = 0;

        for (; j < limit; j++)
        {
            new ShortField(offset, ( short ) char_array[ j ], _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }
        for (; j < _max_name_length + 1; j++)
        {
            new ShortField(offset, ( short ) 0, _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }

        
        _name_size
            .set(( short ) ((limit + 1)
                            * LittleEndianConsts.SHORT_SIZE), _raw_data);
    }

    
    public void setStorageClsid( ClassID clsidStorage)
    {
        _storage_clsid = clsidStorage;
        if( clsidStorage == null) {
            Arrays.fill( _raw_data, _storage_clsid_offset, _storage_clsid_offset + ClassID.LENGTH, (byte) 0);
        } else {
            clsidStorage.write( _raw_data, _storage_clsid_offset);
        }
    }
    
    protected void setPropertyType(byte propertyType)
    {
        _property_type.set(propertyType, _raw_data);
    }

    
    protected void setNodeColor(byte nodeColor)
    {
        _node_color.set(nodeColor, _raw_data);
    }

    
    protected void setChildProperty(int child)
    {
        _child_property.set(child, _raw_data);
    }

    
    protected int getChildIndex()
    {
        return _child_property.get();
    }

    
    protected void setSize(int size)
    {
        _size.set(size, _raw_data);
    }

    
    protected void setIndex(int index)
    {
        _index = index;
    }

    
    protected int getIndex()
    {
        return _index;
    }

    
    abstract protected void preWrite();

    
    int getNextChildIndex()
    {
        return _next_property.get();
    }

    
    int getPreviousChildIndex()
    {
        return _previous_property.get();
    }

    
    static boolean isValidIndex(int index)
    {
        return index != _NO_INDEX;
    }

    
    public Child getNextChild()
    {
        return _next_child;
    }

    
    public Child getPreviousChild()
    {
        return _previous_child;
    }

    
    public void setNextChild(Child child)
    {
        _next_child = child;
        _next_property.set((child == null) ? _NO_INDEX
                                           : (( Property ) child)
                                               .getIndex(), _raw_data);
    }

    
    public void setPreviousChild(Child child)
    {
        _previous_child = child;
        _previous_property.set((child == null) ? _NO_INDEX
                                               : (( Property ) child)
                                                   .getIndex(), _raw_data);
    }

    
    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 5 ];

        results[ 0 ] = "Name          = \"" + getName() + "\"";
        results[ 1 ] = "Property Type = " + _property_type.get();
        results[ 2 ] = "Node Color    = " + _node_color.get();
        long time = _days_1.get();

        time         <<= 32;
        time         += _seconds_1.get() & 0x0000FFFFL;
        results[ 3 ] = "Time 1        = " + time;
        time         = _days_2.get();
        time         <<= 32;
        time         += _seconds_2.get() & 0x0000FFFFL;
        results[ 4 ] = "Time 2        = " + time;
        return results;
    }

    
    public Iterator<Object> getViewableIterator()
    {
        return Collections.emptyList().iterator();
    }

    
    public boolean preferArray()
    {
        return true;
    }

    
    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append("Property: \"").append(getName()).append("\"");
        return buffer.toString();
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.property;

import java.util.Iterator;

import java.io.IOException;



public interface Parent
    extends Child
{

    

    public Iterator getChildren();

    

    public void addChild(final Property property)
        throws IOException;

    

    public void setPreviousChild(final Child child);

    

    public void setNextChild(final Child child);

    

}   


<code block>


package org.docx4j.org.apache.poi.poifs.dev;

import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.property.DirectoryProperty;
import org.docx4j.org.apache.poi.poifs.property.Property;
import org.docx4j.org.apache.poi.poifs.property.PropertyTable;
import org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;
import org.docx4j.org.apache.poi.poifs.storage.ListManagedBlock;
import org.docx4j.org.apache.poi.poifs.storage.RawDataBlockList;
import org.docx4j.org.apache.poi.poifs.storage.SmallBlockTableReader;
import org.docx4j.org.apache.poi.util.HexDump;
import org.docx4j.org.apache.poi.util.IntList;


public class POIFSHeaderDumper {
    
    public static void main(final String args[]) throws Exception {
        if (args.length == 0) {
            System.err.println("Must specify at least one file to view");
            System.exit(1);
        }

        for (int j = 0; j < args.length; j++) {
            viewFile(args[j]);
        }
    }

    public static void viewFile(final String filename) throws Exception {
        System.out.println("Dumping headers from: " + filename);
        InputStream inp = new FileInputStream(filename);

        
        HeaderBlock header_block = new HeaderBlock(inp);
        displayHeader(header_block);

        
        POIFSBigBlockSize bigBlockSize = header_block.getBigBlockSize();
        RawDataBlockList data_blocks = new RawDataBlockList(inp, bigBlockSize);
        displayRawBlocksSummary(data_blocks);

        
        BlockAllocationTableReader batReader =
                new BlockAllocationTableReader(
                        header_block.getBigBlockSize(),
                        header_block.getBATCount(),
                        header_block.getBATArray(),
                        header_block.getXBATCount(),
                        header_block.getXBATIndex(),
                        data_blocks);
        displayBATReader("Big Blocks", batReader);

        
        PropertyTable properties =
                new PropertyTable(header_block, data_blocks);

        
        BlockAllocationTableReader sbatReader = 
                SmallBlockTableReader._getSmallDocumentBlockReader(
                        bigBlockSize, data_blocks, properties.getRoot(),
                        header_block.getSBATStart()
                        );
        displayBATReader("Small Blocks", sbatReader);

        
        displayPropertiesSummary(properties);
    }

    public static void displayHeader(HeaderBlock header_block) throws Exception {
        System.out.println("Header Details:");
        System.out.println(" Block size: " + header_block.getBigBlockSize().getBigBlockSize());
        System.out.println(" BAT (FAT) header blocks: " + header_block.getBATArray().length);
        System.out.println(" BAT (FAT) block count: " + header_block.getBATCount());
        if (header_block.getBATCount() > 0) 
            System.out.println(" BAT (FAT) block 1 at: " + header_block.getBATArray()[0]);
        System.out.println(" XBAT (FAT) block count: " + header_block.getXBATCount());
        System.out.println(" XBAT (FAT) block 1 at: " + header_block.getXBATIndex());
        System.out.println(" SBAT (MiniFAT) block count: " + header_block.getSBATCount());
        System.out.println(" SBAT (MiniFAT) block 1 at: " + header_block.getSBATStart());
        System.out.println(" Property table at: " + header_block.getPropertyStart());
        System.out.println("");
    }

    public static void displayRawBlocksSummary(RawDataBlockList data_blocks) throws Exception {
        System.out.println("Raw Blocks Details:");
        System.out.println(" Number of blocks: " + data_blocks.blockCount());

        Method gbm = data_blocks.getClass().getSuperclass().getDeclaredMethod("get", int.class);
        gbm.setAccessible(true);

        for(int i=0; i<Math.min(16, data_blocks.blockCount()); i++) {
            ListManagedBlock block = (ListManagedBlock)gbm.invoke(data_blocks, Integer.valueOf(i));
            byte[] data = new byte[Math.min(48, block.getData().length)];
            System.arraycopy(block.getData(), 0, data, 0, data.length);

            System.out.println(" Block #" + i + ":");
            System.out.println(HexDump.dump(data, 0, 0));
        }

        System.out.println("");
    }

    public static void displayBATReader(String type, BlockAllocationTableReader batReader) throws Exception {
        System.out.println("Sectors, as referenced from the "+type+" FAT:");
        Field entriesF = batReader.getClass().getDeclaredField("_entries");
        entriesF.setAccessible(true);
        IntList entries = (IntList)entriesF.get(batReader);

        for(int i=0; i<entries.size(); i++) {
            int bn = entries.get(i);
            String bnS = Integer.toString(bn);
            if(bn == POIFSConstants.END_OF_CHAIN) {
                bnS = "End Of Chain";
            } else if(bn == POIFSConstants.DIFAT_SECTOR_BLOCK) {
                bnS = "DI Fat Block";
            } else if(bn == POIFSConstants.FAT_SECTOR_BLOCK) {
                bnS = "Normal Fat Block";
            } else if(bn == POIFSConstants.UNUSED_BLOCK) {
                bnS = "Block Not Used (Free)";
            }

            System.out.println("  Block  # " + i + " -> " + bnS);
        }

        System.out.println("");
    }

    public static void displayPropertiesSummary(PropertyTable properties) {
        System.out.println("Mini Stream starts at " + properties.getRoot().getStartBlock());
        System.out.println("Mini Stream length is " + properties.getRoot().getSize());
        System.out.println();
        
        System.out.println("Properties and their block start:");
        displayProperties(properties.getRoot(), "");
        System.out.println("");
    }
    public static void displayProperties(DirectoryProperty prop, String indent) {
        String nextIndent = indent + "  ";
        System.out.println(indent + "-> " + prop.getName());
        for (Property cp : prop) {
            if (cp instanceof DirectoryProperty) {
                displayProperties((DirectoryProperty)cp, nextIndent);
            } else {
                System.out.println(nextIndent + "=> " + cp.getName());
                System.out.print(nextIndent + "   " + cp.getSize() + " bytes in ");
                if (cp.shouldUseSmallBlocks()) {
                    System.out.print("mini");
                } else {
                    System.out.print("main");
                }
                System.out.println(" stream, starts at " + cp.getStartBlock());
            }
        }
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.dev;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.util.Iterator;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentNode;
import org.docx4j.org.apache.poi.poifs.filesystem.Entry;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSStream;
import org.docx4j.org.apache.poi.poifs.property.NPropertyTable;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;


public class POIFSDump {
    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            System.err.println("Must specify at least one file to dump");
            System.exit(1);
        }
        
        boolean dumpProps = false, dumpMini = false;
        for (int i = 0; i < args.length; i++) {
            if (args[i].equalsIgnoreCase("-dumprops") ||
                args[i].equalsIgnoreCase("-dump-props") ||
                args[i].equalsIgnoreCase("-dump-properties")) {
                dumpProps = true;
                continue;
            }
            if (args[i].equalsIgnoreCase("-dumpmini") ||
                args[i].equalsIgnoreCase("-dump-mini") ||
                args[i].equalsIgnoreCase("-dump-ministream") ||
                args[i].equalsIgnoreCase("-dump-mini-stream")) {
                dumpMini = true;
                continue;
            }
            
            System.out.println("Dumping " + args[i]);
            FileInputStream is = new FileInputStream(args[i]);
            NPOIFSFileSystem fs = new NPOIFSFileSystem(is);
            is.close();

            DirectoryEntry root = fs.getRoot();
            File file = new File(root.getName());
            file.mkdir();

            dump(root, file);
            
            if (dumpProps) {
                HeaderBlock header = getHeaderBlock(fs);
                dump(fs, header.getPropertyStart(), "properties", file);
            }
            if (dumpMini) {
                NPropertyTable props = getPropertyTable(fs);
                int startBlock = props.getRoot().getStartBlock(); 
                if (startBlock == POIFSConstants.END_OF_CHAIN) {
                    System.err.println("No Mini Stream in file");
                } else {
                    dump(fs, startBlock, "mini-stream", file);
                }
            }
        }
   }
    
    protected static HeaderBlock getHeaderBlock(NPOIFSFileSystem fs) throws Exception {
        Field headerF = NPOIFSFileSystem.class.getDeclaredField("_header");
        headerF.setAccessible(true);
        HeaderBlock header = (HeaderBlock)headerF.get(fs);
        return header;
    }
    protected static NPropertyTable getPropertyTable(NPOIFSFileSystem fs) throws Exception {
        Field ptF = NPOIFSFileSystem.class.getDeclaredField("_property_table");
        ptF.setAccessible(true);
        NPropertyTable table = (NPropertyTable)ptF.get(fs);
        return table;
    }

    public static void dump(DirectoryEntry root, File parent) throws IOException {
        for(Iterator<Entry> it = root.getEntries(); it.hasNext();){
            Entry entry = it.next();
            if(entry instanceof DocumentNode){
                DocumentNode node = (DocumentNode)entry;
                DocumentInputStream is = new DocumentInputStream(node);
                byte[] bytes = new byte[node.getSize()];
                is.read(bytes);
                is.close();

                OutputStream out = new FileOutputStream(new File(parent, node.getName().trim()));
                try {
                	out.write(bytes);
                } finally {
                	out.close();
                }
            } else if (entry instanceof DirectoryEntry){
                DirectoryEntry dir = (DirectoryEntry)entry;
                File file = new File(parent, entry.getName());
                file.mkdir();
                dump(dir, file);
            } else {
                System.err.println("Skipping unsupported POIFS entry: " + entry);
            }
        }
    }
    public static void dump(NPOIFSFileSystem fs, int startBlock, String name, File parent) throws IOException {
        File file = new File(parent, name);
        FileOutputStream out = new FileOutputStream(file);
        NPOIFSStream stream = new NPOIFSStream(fs, startBlock);
        
        byte[] b = new byte[fs.getBigBlockSize()];
        for (ByteBuffer bb : stream) {
            int len = bb.remaining();
            bb.get(b);
            out.write(b, 0, len);
        }
        out.close();
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.dev;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;



public class POIFSViewer
{

    

    public static void main(final String args[])
    {
        if (args.length < 0)
        {
            System.err.println("Must specify at least one file to view");
            System.exit(1);
        }
        boolean printNames = (args.length > 1);

        for (int j = 0; j < args.length; j++)
        {
            viewFile(args[ j ], printNames);
        }
    }

    private static void viewFile(final String filename,
                                 final boolean printName)
    {
        if (printName)
        {
            StringBuffer flowerbox = new StringBuffer();

            flowerbox.append(".");
            for (int j = 0; j < filename.length(); j++)
            {
                flowerbox.append("-");
            }
            flowerbox.append(".");
            System.out.println(flowerbox);
            System.out.println("|" + filename + "|");
            System.out.println(flowerbox);
        }
        try
        {
            POIFSViewable fs      =
                new NPOIFSFileSystem(new File(filename));
            List<String>  strings = POIFSViewEngine.inspectViewable(fs, true,
                                        0, "  ");
            Iterator<String> iter = strings.iterator();

            while (iter.hasNext())
            {
                System.out.print(iter.next());
            }
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
        }
    }
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.dev;

import java.util.Iterator;



public interface POIFSViewable
{

    

    public Object [] getViewableArray();
    
    
    public Iterator<Object> getViewableIterator();

    

    public boolean preferArray();

    

    public String getShortDescription();
}   


<code block>


package org.docx4j.org.apache.poi.poifs.dev;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Iterator;

import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentNode;
import org.docx4j.org.apache.poi.poifs.filesystem.Entry;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;


public class POIFSLister {
   
   public static void main(final String args[]) throws IOException {
      if (args.length == 0) {
         System.err.println("Must specify at least one file to view");
         System.exit(1);
      }

      boolean withSizes = false;
      boolean newPOIFS = true;
      for (int j = 0; j < args.length; j++) {
         if (args[j].equalsIgnoreCase("-size") || args[j].equalsIgnoreCase("-sizes")) {
            withSizes = true;
         } else if (args[j].equalsIgnoreCase("-old") || args[j].equalsIgnoreCase("-old-poifs")) {
            newPOIFS = false;
         } else {
            if(newPOIFS) {
               viewFile(args[j], withSizes);
            } else {
               viewFileOld(args[j], withSizes);
            }
         }
      }
   }

   public static void viewFile(final String filename, boolean withSizes) throws IOException {
      NPOIFSFileSystem fs = new NPOIFSFileSystem(new File(filename));
      displayDirectory(fs.getRoot(), "", withSizes);
   }

   public static void viewFileOld(final String filename, boolean withSizes) throws IOException {
      POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream(filename));
      displayDirectory(fs.getRoot(), "", withSizes);
   }

   public static void displayDirectory(DirectoryNode dir, String indent, boolean withSizes) {
      System.out.println(indent + dir.getName() + " -");
      String newIndent = indent + "  ";

      boolean hadChildren = false;
      for(Iterator<Entry> it = dir.getEntries(); it.hasNext();) {
         hadChildren = true;
         Entry entry = it.next();
         if (entry instanceof DirectoryNode) {
            displayDirectory((DirectoryNode) entry, newIndent, withSizes);
         } else {
            DocumentNode doc = (DocumentNode) entry;
            String name = doc.getName();
            String size = "";
            if (name.charAt(0) < 10) {
               String altname = "(0x0" + (int) name.charAt(0) + ")" + name.substring(1);
               name = name.substring(1) + " <" + altname + ">";
            }
            if (withSizes) {
               size = " [" + doc.getSize() + " / 0x" + 
                      Integer.toHexString(doc.getSize()) + "]";
            }
            System.out.println(newIndent + name + size);
         }
      }
      if (!hadChildren) {
         System.out.println(newIndent + "(no children)");
      }
   }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.dev;

import java.io.IOException;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;



public class POIFSViewEngine
{
    private static final String _EOL = System.getProperty("line.separator");

    

    public static List<String> inspectViewable(final Object viewable,
                                       final boolean drilldown,
                                       final int indentLevel,
                                       final String indentString)
    {
        List<String> objects = new ArrayList<String>();

        if (viewable instanceof POIFSViewable)
        {
            POIFSViewable inspected = ( POIFSViewable ) viewable;

            objects.add(indent(indentLevel, indentString,
                               inspected.getShortDescription()));
            if (drilldown)
            {
                if (inspected.preferArray())
                {
                    Object[] data = inspected.getViewableArray();

                    for (int j = 0; j < data.length; j++)
                    {
                        objects.addAll(inspectViewable(data[ j ], drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
                else
                {
                    Iterator<Object> iter = inspected.getViewableIterator();

                    while (iter.hasNext())
                    {
                        objects.addAll(inspectViewable(iter.next(),
                                                       drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
            }
        }
        else if (viewable==null) {
            objects.add(indent(indentLevel, indentString, "[null]"));        	
        } else 
        {
            objects.add(indent(indentLevel, indentString,
                               viewable.toString()));
        }
        return objects;
    }

    private static String indent(final int indentLevel,
                                 final String indentString, final String data)
    {
        StringBuffer finalBuffer  = new StringBuffer();
        StringBuffer indentPrefix = new StringBuffer();

        for (int j = 0; j < indentLevel; j++)
        {
            indentPrefix.append(indentString);
        }
        LineNumberReader reader =
            new LineNumberReader(new StringReader(data));

        try
        {
            String line = reader.readLine();

            while (line != null)
            {
                finalBuffer.append(indentPrefix).append(line).append(_EOL);
                line = reader.readLine();
            }
        }
        catch (IOException e)
        {
            finalBuffer.append(indentPrefix).append(e.getMessage())
                .append(_EOL);
        }
        return finalBuffer.toString();
    }
}   


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.LittleEndianOutputStream;
import org.docx4j.org.apache.poi.util.StringUtil;


public class Ole10Native {

    public static final String OLE10_NATIVE = "\u0001Ole10Native";
    protected static final String ISO1 = "ISO-8859-1";
  
    
    private int totalSize;             
    private short flags1 = 2;          
    private String label;              
    private String fileName;           
    private short flags2 = 0;          
    private short unknown1 = 3;        
    private String command;            
    private byte[] dataBuffer;         
    private short flags3 = 0;          
  
     
    private enum EncodingMode {
        
        parsed,
        
        unparsed,
        
        compact;
    }
    
    private EncodingMode mode;

    
    
    
    public static Ole10Native createFromEmbeddedOleObject(POIFSFileSystem poifs) throws IOException, Ole10NativeException {
       return createFromEmbeddedOleObject(poifs.getRoot());
    }
    
    
    public static Ole10Native createFromEmbeddedOleObject(DirectoryNode directory) throws IOException, Ole10NativeException {
       DocumentEntry nativeEntry = 
          (DocumentEntry)directory.getEntry(OLE10_NATIVE);
       byte[] data = new byte[nativeEntry.getSize()];
       int readBytes = directory.createDocumentInputStream(nativeEntry).read(data);
       assert(readBytes == data.length);
  
       return new Ole10Native(data, 0);
    }
    
    
    public Ole10Native(String label, String filename, String command, byte[] data) {
       setLabel(label);
       setFileName(filename);
       setCommand(command);
       setDataBuffer(data);
       mode = EncodingMode.parsed;
    }

    
    public Ole10Native(byte[] data, int offset, boolean plain) throws Ole10NativeException {
        this(data, offset);
    }
    
    
    public Ole10Native(byte[] data, int offset) throws Ole10NativeException {
        int ofs = offset; 
        
        if (data.length < offset + 2) {
            throw new Ole10NativeException("data is too small");
        }
        
        totalSize = LittleEndian.getInt(data, ofs);
        ofs += LittleEndianConsts.INT_SIZE;
        
        mode = EncodingMode.unparsed;
        if (LittleEndian.getShort(data, ofs) == 2) {
            
            
            if (Character.isISOControl(data[ofs+LittleEndianConsts.SHORT_SIZE])) {
                mode = EncodingMode.compact;
            } else {
                mode = EncodingMode.parsed;
            }
        }

        int dataSize;
        switch (mode) {
        case parsed: {
            flags1 = LittleEndian.getShort(data, ofs);
            
            
            ofs += LittleEndianConsts.SHORT_SIZE;
        
            int len = getStringLength(data, ofs);
            label = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
            
            len = getStringLength(data, ofs);
            fileName = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
    
            flags2 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
            
            unknown1 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
          
            len = LittleEndian.getInt(data, ofs);
            ofs += LittleEndianConsts.INT_SIZE;
            command = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
            
            if (totalSize < ofs) {
                throw new Ole10NativeException("Invalid Ole10Native");
            }
          
            dataSize = LittleEndian.getInt(data, ofs);
            ofs += LittleEndianConsts.INT_SIZE;
          
            if (dataSize < 0 || totalSize - (ofs - LittleEndianConsts.INT_SIZE) < dataSize) {
                throw new Ole10NativeException("Invalid Ole10Native");
            }
            break;
        }
        case compact:
            flags1 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
            dataSize = totalSize - LittleEndianConsts.SHORT_SIZE;
            break;
        default:
        case unparsed:
            dataSize = totalSize;
            break;
        }
        
        dataBuffer = new byte[dataSize];
        System.arraycopy(data, ofs, dataBuffer, 0, dataSize);
        ofs += dataSize;
    }

    
    private static int getStringLength(byte[] data, int ofs) {
        int len = 0;
        while (len + ofs < data.length && data[ofs + len] != 0) {
            len++;
        }
        len++;
        return len;
    }

    
    public int getTotalSize() {
        return totalSize;
    }

    
    public short getFlags1() {
        return flags1;
    }

    
    public String getLabel() {
        return label;
    }

    
    public String getFileName() {
        return fileName;
    }

    
    public short getFlags2() {
        return flags2;
    }

    
    public short getUnknown1() {
        return unknown1;
    }

    
    public String getCommand() {
        return command;
    }

    
    public int getDataSize() {
        return dataBuffer.length;
    }

    
    public byte[] getDataBuffer() {
        return dataBuffer;
    }

    
    public short getFlags3() {
        return flags3;
    }

    
    public void writeOut(OutputStream out) throws IOException {
        
        

        @SuppressWarnings("resource")
        LittleEndianOutputStream leosOut = new LittleEndianOutputStream(out);
        
        switch (mode) {
        case parsed: {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            LittleEndianOutputStream leos = new LittleEndianOutputStream(bos);
            

            leos.writeShort(getFlags1());
            leos.write(getLabel().getBytes(ISO1));
            leos.write(0);
            leos.write(getFileName().getBytes(ISO1));
            leos.write(0);
            leos.writeShort(getFlags2());
            leos.writeShort(getUnknown1());
            leos.writeInt(getCommand().length() + 1);
            leos.write(getCommand().getBytes(ISO1));
            leos.write(0);
            leos.writeInt(getDataSize());
            leos.write(getDataBuffer());
            leos.writeShort(getFlags3());
            leos.close(); 
            
            leosOut.writeInt(bos.size()); 
            bos.writeTo(out);
            break;
        }
        case compact:
            leosOut.writeInt(getDataSize()+LittleEndianConsts.SHORT_SIZE);
            leosOut.writeShort(getFlags1());
            out.write(getDataBuffer());
            break;
        default:
        case unparsed:
            leosOut.writeInt(getDataSize());
            out.write(getDataBuffer());
            break;
        }

    }

    public void setFlags1(short flags1) {
        this.flags1 = flags1;
    }

    public void setFlags2(short flags2) {
        this.flags2 = flags2;
    }

    public void setFlags3(short flags3) {
        this.flags3 = flags3;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public void setCommand(String command) {
        this.command = command;
    }

    public void setUnknown1(short unknown1) {
        this.unknown1 = unknown1;
    }

    public void setDataBuffer(byte dataBuffer[]) {
        this.dataBuffer = dataBuffer;
    }
}

<code block>



package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;

import org.docx4j.org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;


public abstract class BlockStore {
   
   protected abstract int getBlockStoreBlockSize();
   
    
    protected abstract ByteBuffer getBlockAt(final int offset) throws IOException;
    
    
    protected abstract ByteBuffer createBlockIfNeeded(final int offset) throws IOException;
    
    
    protected abstract BATBlockAndIndex getBATBlockAndIndex(final int offset);
    
    
    protected abstract int getNextBlock(final int offset);
    
    
    protected abstract void setNextBlock(final int offset, final int nextBlock);
    
    
    protected abstract int getFreeBlock() throws IOException;
    
    
    protected abstract ChainLoopDetector getChainLoopDetector() throws IOException;
    
    
    protected class ChainLoopDetector {
       private boolean[] used_blocks;
       protected ChainLoopDetector(long rawSize) {
          int numBlocks = (int)Math.ceil( rawSize / getBlockStoreBlockSize() );
          used_blocks = new boolean[numBlocks];
       }
       protected void claim(int offset) {
          if(offset >= used_blocks.length) {
             
             
             
             return;
          }
          
          
          if(used_blocks[offset]) {
             throw new IllegalStateException(
                   "Potential loop detected - Block " + offset + 
                   " was already claimed but was just requested again"
             );
          }
          used_blocks[offset] = true;
       }
    }
}


<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.util.CloseIgnoringInputStream;



public class POIFSFileSystem
    extends NPOIFSFileSystem 
    implements POIFSViewable
{
    
    public static InputStream createNonClosingInputStream(InputStream is) {
        return new CloseIgnoringInputStream(is);
    }

    
    public POIFSFileSystem()
    {
        super();
    }

    

    public POIFSFileSystem(InputStream stream)
        throws IOException
    {
        super(stream);
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        return NPOIFSFileSystem.hasPOIFSHeader(inp);
    }
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        return NPOIFSFileSystem.hasPOIFSHeader(header8Bytes);
    }

    

    public static void main(String args[])
        throws IOException
    {
        OPOIFSFileSystem.main(args);
    }
}


<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public interface DocumentEntry
    extends Entry
{

    

    public int getSize();
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public class DocumentDescriptor
{
    private POIFSDocumentPath path;
    private String            name;
    private int               hashcode = 0;

    

    public DocumentDescriptor(final POIFSDocumentPath path, final String name)
    {
        if (path == null)
        {
            throw new NullPointerException("path must not be null");
        }
        if (name == null)
        {
            throw new NullPointerException("name must not be null");
        }
        if (name.length() == 0)
        {
            throw new IllegalArgumentException("name cannot be empty");
        }
        this.path = path;
        this.name = name;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                DocumentDescriptor descriptor = ( DocumentDescriptor ) o;

                rval = this.path.equals(descriptor.path)
                       && this.name.equals(descriptor.name);
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            hashcode = path.hashCode() ^ name.hashCode();
        }
        return hashcode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer(40 * (path.length() + 1));

        for (int j = 0; j < path.length(); j++)
        {
            buffer.append(path.getComponent(j)).append("/");
        }
        buffer.append(name);
        return buffer.toString();
    }
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public interface BATManaged
{

    

    public int countBlocks();

    

    public void setStartBlock(final int index);
}   


<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.docx4j.org.apache.poi.hpsf.ClassID;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.property.DirectoryProperty;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;
import org.docx4j.org.apache.poi.poifs.property.Property;


public class DirectoryNode
    extends EntryNode
    implements DirectoryEntry, POIFSViewable, Iterable<Entry>
{

    
    private Map<String,Entry> _byname;
    
    private ArrayList<Entry> _entries;

    
    
    private OPOIFSFileSystem   _ofilesystem;
    
    private NPOIFSFileSystem  _nfilesystem;

    
    private POIFSDocumentPath _path;

    
    DirectoryNode(final DirectoryProperty property,
                  final OPOIFSFileSystem filesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, filesystem, (NPOIFSFileSystem)null);
    }

    
    DirectoryNode(final DirectoryProperty property,
                  final NPOIFSFileSystem nfilesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, (OPOIFSFileSystem)null, nfilesystem);
    }

    private DirectoryNode(final DirectoryProperty property,
                          final DirectoryNode parent,
                          final OPOIFSFileSystem ofilesystem,
                          final NPOIFSFileSystem nfilesystem)
    {
        super(property, parent);
        this._ofilesystem = ofilesystem;
        this._nfilesystem = nfilesystem;

        if (parent == null)
        {
            _path = new POIFSDocumentPath();
        }
        else
        {
            _path = new POIFSDocumentPath(parent._path, new String[]
            {
                property.getName()
            });
        }
        _byname     = new HashMap<String, Entry>();
        _entries    = new ArrayList<Entry>();
        Iterator<Property> iter = property.getChildren();

        while (iter.hasNext())
        {
            Property child     = iter.next();
            Entry    childNode = null;

            if (child.isDirectory())
            {
                DirectoryProperty childDir = (DirectoryProperty) child;
                if(_ofilesystem != null) {
                   childNode = new DirectoryNode(childDir, _ofilesystem, this);
                } else {
                   childNode = new DirectoryNode(childDir, _nfilesystem, this);
                }
            }
            else
            {
                childNode = new DocumentNode((DocumentProperty) child, this);
            }
            _entries.add(childNode);
            _byname.put(childNode.getName(), childNode);
        }
    }

    

    public POIFSDocumentPath getPath()
    {
        return _path;
    }

    
    public NPOIFSFileSystem getFileSystem()
    {
        return _nfilesystem;
    }

    
    public OPOIFSFileSystem getOFileSystem()
    {
        return _ofilesystem;
    }

    
    public NPOIFSFileSystem getNFileSystem()
    {
        return _nfilesystem;
    }

    
    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
        return createDocumentInputStream(getEntry(documentName));
    }

    
    public DocumentInputStream createDocumentInputStream(
            final Entry document)
        throws IOException
    {
        if (!document.isDocumentEntry()) {
            throw new IOException("Entry '" + document.getName()
                                  + "' is not a DocumentEntry");
        }

        DocumentEntry entry = (DocumentEntry)document;
        return new DocumentInputStream(entry);
    }

    
    DocumentEntry createDocument(final OPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _ofilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    DocumentEntry createDocument(final NPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _nfilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    boolean changeName(final String oldName, final String newName)
    {
        boolean   rval  = false;
        EntryNode child = ( EntryNode ) _byname.get(oldName);

        if (child != null)
        {
            rval = (( DirectoryProperty ) getProperty())
                .changeName(child.getProperty(), newName);
            if (rval)
            {
                _byname.remove(oldName);
                _byname.put(child.getProperty().getName(), child);
            }
        }
        return rval;
    }

    

    boolean deleteEntry(final EntryNode entry)
    {
        boolean rval =
            (( DirectoryProperty ) getProperty())
                .deleteChild(entry.getProperty());

        if (rval)
        {
            _entries.remove(entry);
            _byname.remove(entry.getName());

            if(_ofilesystem != null) {
                _ofilesystem.remove(entry);
            } else {
                try {
                    _nfilesystem.remove(entry);
                } catch (IOException e) {
                    
                }
            }
        }
        return rval;
    }

    

    

    public Iterator<Entry> getEntries()
    {
        return _entries.iterator();
    }
    
    
    public Set<String> getEntryNames()
    {
        return _byname.keySet();
    }

    

    public boolean isEmpty()
    {
        return _entries.isEmpty();
    }

    

    public int getEntryCount()
    {
        return _entries.size();
    }

    public boolean hasEntry( String name )
    {
        return name != null && _byname.containsKey( name );
    }

    

    public Entry getEntry(final String name) throws FileNotFoundException {
        Entry rval = null;

        if (name != null) {
            rval = _byname.get(name);
        }
        if (rval == null) {
            
            throw new FileNotFoundException("no such entry: \"" + name
                    + "\", had: " + _byname.keySet());
        }
        return rval;
    }

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException
    {
        if(_nfilesystem != null) {
           return createDocument(new NPOIFSDocument(name, _nfilesystem, stream));
        } else {
           return createDocument(new OPOIFSDocument(name, stream));
        }
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        if(_nfilesystem != null) {
            return createDocument(new NPOIFSDocument(name, size, _nfilesystem, writer));
         } else {
            return createDocument(new OPOIFSDocument(name, size, _path, writer));
         }
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        DirectoryNode rval;
        DirectoryProperty property = new DirectoryProperty(name);

        if(_ofilesystem != null) {
           rval = new DirectoryNode(property, _ofilesystem, this);
           _ofilesystem.addDirectory(property);
        } else {
           rval = new DirectoryNode(property, _nfilesystem, this);
           _nfilesystem.addDirectory(property);
        }

        (( DirectoryProperty ) getProperty()).addChild(property);
        _entries.add(rval);
        _byname.put(name, rval);
        return rval;
    }

    
    public ClassID getStorageClsid()
    {
        return getProperty().getStorageClsid();
    }

    
    public void setStorageClsid(ClassID clsidStorage)
    {
        getProperty().setStorageClsid(clsidStorage);
    }

    
    

    

    @Override
    public boolean isDirectoryEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {

        
        return isEmpty();
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    
    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        Iterator<Entry> iter = _entries.iterator();
        while (iter.hasNext())
        {
            components.add(iter.next());
        }
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
    public Iterator<Entry> iterator() {
        return getEntries();
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;


public final class NDocumentOutputStream extends OutputStream {
	
	private int _document_size;

	
	private boolean _closed;

	
	private NPOIFSDocument _document;
	
	private DocumentProperty _property;
	
	
	private ByteArrayOutputStream _buffer = 
	        new ByteArrayOutputStream(POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE);
	
	
	private NPOIFSStream _stream;
	private OutputStream _stream_output;
	
	
	public NDocumentOutputStream(DocumentEntry document) throws IOException {
		if (!(document instanceof DocumentNode)) {
			throw new IOException("Cannot open internal document storage, " + document + " not a Document Node");
		}
		_document_size = 0;
		_closed = false;
		
		_property = (DocumentProperty)((DocumentNode)document).getProperty();
		
		_document = new NPOIFSDocument((DocumentNode)document);
		_document.free();
	}
	
	
	public NDocumentOutputStream(DirectoryEntry parent, String name) throws IOException {
        if (!(parent instanceof DirectoryNode)) {
            throw new IOException("Cannot open internal directory storage, " + parent + " not a Directory Node");
        }
        _document_size = 0;
        _closed = false;

        
        DocumentEntry doc = parent.createDocument(name, new ByteArrayInputStream(new byte[0]));
        _property = (DocumentProperty)((DocumentNode)doc).getProperty();
        _document = new NPOIFSDocument((DocumentNode)doc);
	}
	
    private void dieIfClosed() throws IOException {
        if (_closed) {
            throw new IOException("cannot perform requested operation on a closed stream");
        }
    }
    
    private void checkBufferSize() throws IOException {
        
        if (_buffer.size() > POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
            
            byte[] data = _buffer.toByteArray();
            _buffer = null;
            write(data, 0, data.length);
        } else {
            
        }
    }

    public void write(int b) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b);
            checkBufferSize();
        } else {
            write(new byte[] { (byte)b });
        }
    }

    public void write(byte[] b) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b);
            checkBufferSize();
        } else {
            write(b, 0, b.length);
        }
    }

    public void write(byte[] b, int off, int len) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b, off, len);
            checkBufferSize();
        } else {
            if (_stream == null) {
                _stream = new NPOIFSStream(_document.getFileSystem());
                _stream_output = _stream.getOutputStream();
            }
            _stream_output.write(b, off, len);
            _document_size += len;
        }
    }

    public void close() throws IOException {
        
        if (_buffer != null) {
            
            _document.replaceContents(new ByteArrayInputStream(_buffer.toByteArray()));
        }
        else {
            
            
            _stream_output.close();
            _property.updateSize(_document_size);
            _property.setStartBlock(_stream.getStartBlock());
        }
        
        
        _closed = true;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

public class Ole10NativeException extends Exception {
    public Ole10NativeException(String message) {
        super(message);
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public class POIFSWriterEvent
{
    private DocumentOutputStream stream;
    private POIFSDocumentPath    path;
    private String               documentName;
    private int                  limit;

    

    POIFSWriterEvent(final DocumentOutputStream stream,
                     final POIFSDocumentPath path, final String documentName,
                     final int limit)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
        this.limit        = limit;
    }

    

    public DocumentOutputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }

    

    public int getLimit()
    {
        return limit;
    }
}   


<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.property.RootProperty;
import org.docx4j.org.apache.poi.poifs.storage.BATBlock;
import org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;
import org.docx4j.org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;


public class NPOIFSMiniStore extends BlockStore
{
    private NPOIFSFileSystem _filesystem;
    private NPOIFSStream     _mini_stream;
    private List<BATBlock>   _sbat_blocks;
    private HeaderBlock      _header;
    private RootProperty     _root;

    protected NPOIFSMiniStore(NPOIFSFileSystem filesystem, RootProperty root,
         List<BATBlock> sbats, HeaderBlock header)
    {
       this._filesystem = filesystem;
       this._sbat_blocks = sbats;
       this._header = header;
       this._root = root;
       
       this._mini_stream = new NPOIFSStream(filesystem, root.getStartBlock());
    }
    
    
    protected ByteBuffer getBlockAt(final int offset) throws IOException {
       
       int byteOffset = offset * POIFSConstants.SMALL_BLOCK_SIZE;
       int bigBlockNumber = byteOffset / _filesystem.getBigBlockSize();
       int bigBlockOffset = byteOffset % _filesystem.getBigBlockSize();
       
       
       Iterator<ByteBuffer> it = _mini_stream.getBlockIterator();
       for(int i=0; i<bigBlockNumber; i++) {
          it.next();
       }
       ByteBuffer dataBlock = it.next();
       if(dataBlock == null) {
          throw new IndexOutOfBoundsException("Big block " + bigBlockNumber + " outside stream");
       }

       
       dataBlock.position(
             dataBlock.position() + bigBlockOffset
       );
       ByteBuffer miniBuffer = dataBlock.slice();
       miniBuffer.limit(POIFSConstants.SMALL_BLOCK_SIZE);
       return miniBuffer;
    }
    
    
    protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {
       boolean firstInStore = false;
       if (_mini_stream.getStartBlock() == POIFSConstants.END_OF_CHAIN) {
           firstInStore = true;
       }
       
       
       if (! firstInStore) {
           try {
              return getBlockAt(offset);
           } catch(IndexOutOfBoundsException e) {}
       }
       
       
       
       

       
       int newBigBlock = _filesystem.getFreeBlock();
       _filesystem.createBlockIfNeeded(newBigBlock);
       
       
       if (firstInStore) {
           _filesystem._get_property_table().getRoot().setStartBlock(newBigBlock);
           _mini_stream = new NPOIFSStream(_filesystem, newBigBlock);
       } else {
           
           ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();
           int block = _mini_stream.getStartBlock();
           while(true) {
              loopDetector.claim(block);
              int next = _filesystem.getNextBlock(block);
              if(next == POIFSConstants.END_OF_CHAIN) {
                 break;
              }
              block = next;
           }
           _filesystem.setNextBlock(block, newBigBlock);
       }
       
       
       _filesystem.setNextBlock(newBigBlock, POIFSConstants.END_OF_CHAIN);

       
       return createBlockIfNeeded(offset);
    }
    
    
    protected BATBlockAndIndex getBATBlockAndIndex(final int offset) {
       return BATBlock.getSBATBlockAndIndex(
             offset, _header, _sbat_blocks
       );
    }
    
    
    protected int getNextBlock(final int offset) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       return bai.getBlock().getValueAt( bai.getIndex() );
    }
    
    
    protected void setNextBlock(final int offset, final int nextBlock) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       bai.getBlock().setValueAt(
             bai.getIndex(), nextBlock
       );
    }
    
    
    protected int getFreeBlock() throws IOException {
       int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();
       
       
       int offset = 0;
       for(int i=0; i<_sbat_blocks.size(); i++) {
          
          BATBlock sbat = _sbat_blocks.get(i);
          if(sbat.hasFreeSectors()) {
             
             for(int j=0; j<sectorsPerSBAT; j++) {
                int sbatValue = sbat.getValueAt(j);
                if(sbatValue == POIFSConstants.UNUSED_BLOCK) {
                   
                   return offset + j;
                }
             }
          }
          
          
          offset += sectorsPerSBAT;
       }
       
       
       
       
       
       
       BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);
       int batForSBAT = _filesystem.getFreeBlock();
       newSBAT.setOurBlockIndex(batForSBAT);
       
       
       if(_header.getSBATCount() == 0) {
          
          _header.setSBATStart(batForSBAT);
          _header.setSBATBlockCount(1);
       } else {
          
          ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();
          int batOffset = _header.getSBATStart();
          while(true) {
             loopDetector.claim(batOffset);
             int nextBat = _filesystem.getNextBlock(batOffset);
             if(nextBat == POIFSConstants.END_OF_CHAIN) {
                break;
             }
             batOffset = nextBat;
          }
          
          
          _filesystem.setNextBlock(batOffset, batForSBAT);
          
          
          _header.setSBATBlockCount(
                _header.getSBATCount() + 1
          );
       }
       
       
       _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);
       _sbat_blocks.add(newSBAT);
       
       
       return offset;
    }
    
    @Override
    protected ChainLoopDetector getChainLoopDetector() throws IOException {
      return new ChainLoopDetector( _root.getSize() );
    }

    protected int getBlockStoreBlockSize() {
       return POIFSConstants.SMALL_BLOCK_SIZE;
    }
    
    
    protected void syncWithDataSource() throws IOException {
       int blocksUsed = 0;
       for (BATBlock sbat : _sbat_blocks) {
          ByteBuffer block = _filesystem.getBlockAt(sbat.getOurBlockIndex());
          BlockAllocationTableWriter.writeBlock(sbat, block);
          
          if (!sbat.hasFreeSectors()) {
              blocksUsed += _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();
          } else {
              blocksUsed += sbat.getUsedSectors(false);
          }
       }
       
       
       _filesystem._get_property_table().getRoot().setSize(blocksUsed);
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public interface POIFSWriterListener
{

    

    public void processPOIFSWriterEvent(POIFSWriterEvent event);
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.File;



import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class POIFSDocumentPath
{

	private static Logger log = LoggerFactory.getLogger(POIFSDocumentPath.class);
          
    private String[] components;
    private int      hashcode = 0;

    

    public POIFSDocumentPath(final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ 0 ];
        }
        else
        {
            this.components = new String[ components.length ];
            for (int j = 0; j < components.length; j++)
            {
                if ((components[ j ] == null)
                        || (components[ j ].length() == 0))
                {
                    throw new IllegalArgumentException(
                        "components cannot contain null or empty strings");
                }
                this.components[ j ] = components[ j ];
            }
        }
    }

    

    public POIFSDocumentPath()
    {
        this.components = new String[ 0 ];
    }

    

    public POIFSDocumentPath(final POIFSDocumentPath path,
                             final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ path.components.length ];
        }
        else
        {
            this.components =
                new String[ path.components.length + components.length ];
        }
        for (int j = 0; j < path.components.length; j++)
        {
            this.components[ j ] = path.components[ j ];
        }
        if (components != null)
        {
            for (int j = 0; j < components.length; j++)
            {
                if (components[ j ] == null)
                {
                    throw new IllegalArgumentException(
                        "components cannot contain null");
                }
                if (components[ j ].length() == 0)
                {
                    log.warn("Directory under " + path + " has an empty name, " +
                            "not all OLE2 readers will handle this file correctly!");
                }
                
                this.components[ j + path.components.length ] =
                    components[ j ];
            }
        }
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                POIFSDocumentPath path = ( POIFSDocumentPath ) o;

                if (path.components.length == this.components.length)
                {
                    rval = true;
                    for (int j = 0; j < this.components.length; j++)
                    {
                        if (!path.components[ j ]
                                .equals(this.components[ j ]))
                        {
                            rval = false;
                            break;
                        }
                    }
                }
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            for (int j = 0; j < components.length; j++)
            {
                hashcode += components[ j ].hashCode();
            }
        }
        return hashcode;
    }

    

    public int length()
    {
        return components.length;
    }

    

    public String getComponent(int n)
        throws ArrayIndexOutOfBoundsException
    {
        return components[ n ];
    }

    

    public POIFSDocumentPath getParent()
    {
        final int length = components.length - 1;

        if (length < 0)
        {
            return null;
        }
        POIFSDocumentPath parent = new POIFSDocumentPath(null);

        parent.components = new String[ length ];
        System.arraycopy(components, 0, parent.components, 0, length);
        return parent;
    }

    

    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int          l = length();

        b.append(File.separatorChar);
        for (int i = 0; i < l; i++)
        {
            b.append(getComponent(i));
            if (i < l - 1)
            {
                b.append(File.separatorChar);
            }
        }
        return b.toString();
    }
}   


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;
import org.docx4j.org.apache.poi.util.HexDump;


public final class NPOIFSDocument implements POIFSViewable {
   private DocumentProperty _property;

   private NPOIFSFileSystem _filesystem;
   private NPOIFSStream _stream;
   private int _block_size;
	
   
   public NPOIFSDocument(DocumentNode document) throws IOException {
       this((DocumentProperty)document.getProperty(), 
            ((DirectoryNode)document.getParent()).getNFileSystem());
   }
   
   
   public NPOIFSDocument(DocumentProperty property, NPOIFSFileSystem filesystem) 
      throws IOException
   {
      this._property = property;
      this._filesystem = filesystem;

      if(property.getSize() < POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
         _stream = new NPOIFSStream(_filesystem.getMiniStore(), property.getStartBlock());
         _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
      } else {
         _stream = new NPOIFSStream(_filesystem, property.getStartBlock());
         _block_size = _filesystem.getBlockStoreBlockSize();
      }
   }

   
   public NPOIFSDocument(String name, NPOIFSFileSystem filesystem, InputStream stream) 
      throws IOException 
   {
      this._filesystem = filesystem;

      
      int length = store(stream);

      
      this._property = new DocumentProperty(name, length);
      _property.setStartBlock(_stream.getStartBlock());     
   }
   
   public NPOIFSDocument(String name, int size, NPOIFSFileSystem filesystem, POIFSWriterListener writer) 
      throws IOException 
   {
       this._filesystem = filesystem;

       if (size < POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
           _stream = new NPOIFSStream(filesystem.getMiniStore());
           _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
       } else {
           _stream = new NPOIFSStream(filesystem);
           _block_size = _filesystem.getBlockStoreBlockSize();
       }
       
       OutputStream innerOs = _stream.getOutputStream();
       DocumentOutputStream os = new DocumentOutputStream(innerOs, size);
       POIFSDocumentPath path = new POIFSDocumentPath(name.split("\\\\"));
       String docName = path.getComponent(path.length()-1);
       POIFSWriterEvent event = new POIFSWriterEvent(os, path, docName, size);
       writer.processPOIFSWriterEvent(event);
       innerOs.close();

       
       this._property = new DocumentProperty(name, size);
       _property.setStartBlock(_stream.getStartBlock());     
   }
   
   
   private int store(InputStream stream) throws IOException {
       final int bigBlockSize = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
       BufferedInputStream bis = new BufferedInputStream(stream, bigBlockSize+1);
       bis.mark(bigBlockSize);

       
       if(bis.skip(bigBlockSize) < bigBlockSize) {
          _stream = new NPOIFSStream(_filesystem.getMiniStore());
          _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
       } else {
          _stream = new NPOIFSStream(_filesystem);
          _block_size = _filesystem.getBlockStoreBlockSize();
       }

       
       bis.reset();
       
       
       OutputStream os = _stream.getOutputStream();
       byte buf[] = new byte[1024];
       int length = 0;
       
       for (int readBytes; (readBytes = bis.read(buf)) != -1; length += readBytes) {
           os.write(buf, 0, readBytes);
       }
       
       
       int usedInBlock = length % _block_size;
       if (usedInBlock != 0 && usedInBlock != _block_size) {
           int toBlockEnd = _block_size - usedInBlock;
           byte[] padding = new byte[toBlockEnd];
           Arrays.fill(padding, (byte)0xFF);
           os.write(padding);
       }
       
       
       os.close();
       return length;
   }
   
   
   void free() throws IOException {
       _stream.free();
       _property.setStartBlock(POIFSConstants.END_OF_CHAIN);
   }
   
   NPOIFSFileSystem getFileSystem()
   {
       return _filesystem;
   }
   
   int getDocumentBlockSize() {
      return _block_size;
   }
   
   Iterator<ByteBuffer> getBlockIterator() {
      if(getSize() > 0) {
         return _stream.getBlockIterator();
      } else {
         List<ByteBuffer> empty = Collections.emptyList();
         return empty.iterator();
      }
   }

   
   public int getSize() {
      return _property.getSize();
   }
   
   public void replaceContents(InputStream stream) throws IOException {
       free();
       int size = store(stream);
       _property.setStartBlock(_stream.getStartBlock()); 
       _property.updateSize(size);
   }

   
   DocumentProperty getDocumentProperty() {
      return _property;
   }

   
   public Object[] getViewableArray() {
      Object[] results = new Object[1];
      String result;

      try {
         if(getSize() > 0) {
            
            byte[] data = new byte[getSize()];
            int offset = 0;
            for(ByteBuffer buffer : _stream) {
               int length = Math.min(_block_size, data.length-offset); 
               buffer.get(data, offset, length);
               offset += length;
            }

            ByteArrayOutputStream output = new ByteArrayOutputStream();
            HexDump.dump(data, 0, output, 0);
            result = output.toString();
         } else {
            result = "<NO DATA>";
         }
      } catch (IOException e) {
         result = e.getMessage();
      }
      results[0] = result;
      return results;
   }

   
   public Iterator<Object> getViewableIterator() {
      return Collections.emptyList().iterator();
   }

   
   public boolean preferArray() {
      return true;
   }

   
   public String getShortDescription() {
      StringBuffer buffer = new StringBuffer();

      buffer.append("Document: \"").append(_property.getName()).append("\"");
      buffer.append(" size = ").append(getSize());
      return buffer.toString();
   }
}

<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;
import org.docx4j.org.apache.poi.poifs.property.Property;
import org.docx4j.org.apache.poi.poifs.storage.BlockWritable;
import org.docx4j.org.apache.poi.poifs.storage.DataInputBlock;
import org.docx4j.org.apache.poi.poifs.storage.DocumentBlock;
import org.docx4j.org.apache.poi.poifs.storage.ListManagedBlock;
import org.docx4j.org.apache.poi.poifs.storage.RawDataBlock;
import org.docx4j.org.apache.poi.poifs.storage.SmallDocumentBlock;
import org.docx4j.org.apache.poi.util.HexDump;


public final class OPOIFSDocument implements BATManaged, BlockWritable, POIFSViewable  {
	private static final DocumentBlock[] EMPTY_BIG_BLOCK_ARRAY = { };
	private static final SmallDocumentBlock[] EMPTY_SMALL_BLOCK_ARRAY = { };
	private DocumentProperty _property;
	private int _size;
	
   private final POIFSBigBlockSize _bigBigBlockSize;

	
	private SmallBlockStore  _small_store;
	private BigBlockStore	 _big_store;
	
		
	public OPOIFSDocument(String name, RawDataBlock[] blocks, int length) throws IOException {
		_size = length;
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = (blocks[0].getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
		         POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS : 
		         POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
		   );
		}
		
		_big_store = new BigBlockStore(_bigBigBlockSize, convertRawBlocksToBigBlocks(blocks));
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
		_property.setDocument(this);
	}

	
	private static DocumentBlock[] convertRawBlocksToBigBlocks(ListManagedBlock[] blocks) throws IOException {
		DocumentBlock[] result = new DocumentBlock[blocks.length];
		for (int i = 0; i < result.length; i++) {
			result[i] = new DocumentBlock((RawDataBlock)blocks[i]);
		}
		return result;
	}
	private static SmallDocumentBlock[] convertRawBlocksToSmallBlocks(ListManagedBlock[] blocks) {
		if (blocks instanceof SmallDocumentBlock[]) {
			return (SmallDocumentBlock[]) blocks;
		}
		SmallDocumentBlock[] result = new SmallDocumentBlock[blocks.length];
		System.arraycopy(blocks, 0, result, 0, blocks.length);
		return result;
	}

	
	public OPOIFSDocument(String name, SmallDocumentBlock[] blocks, int length) {
		_size = length;
		
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = blocks[0].getBigBlockSize();
		}

		_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, blocks);
		_property.setDocument(this);
	}

	
	public OPOIFSDocument(String name, POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, int length) throws IOException {
		_size = length;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (Property.isSmall(_size)) {
			_big_store = new BigBlockStore(bigBlockSize,EMPTY_BIG_BLOCK_ARRAY);
			_small_store = new SmallBlockStore(bigBlockSize,convertRawBlocksToSmallBlocks(blocks));
		} else {
			_big_store = new BigBlockStore(bigBlockSize,convertRawBlocksToBigBlocks(blocks));
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public OPOIFSDocument(String name, ListManagedBlock[] blocks, int length) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, blocks, length);
	}

	
	public OPOIFSDocument(String name, POIFSBigBlockSize bigBlockSize, InputStream stream) throws IOException {
		List<DocumentBlock> blocks = new ArrayList<DocumentBlock>();

		_size = 0;
		_bigBigBlockSize = bigBlockSize;
		while (true) {
			DocumentBlock block = new DocumentBlock(stream, bigBlockSize);
			int blockSize = block.size();

			if (blockSize > 0) {
				blocks.add(block);
				_size += blockSize;
			}
			if (block.partiallyRead()) {
				break;
			}
		}
		DocumentBlock[] bigBlocks = blocks.toArray(new DocumentBlock[blocks.size()]);

		_big_store = new BigBlockStore(bigBlockSize,bigBlocks);
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(bigBlockSize,SmallDocumentBlock.convert(bigBlockSize,bigBlocks, _size));
			_big_store = new BigBlockStore(bigBlockSize,new DocumentBlock[0]);
		} else {
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public OPOIFSDocument(String name, InputStream stream) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, stream);
	}

	
	public OPOIFSDocument(String name, int size, POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, POIFSWriterListener writer) {
		_size = size;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(_bigBigBlockSize, path, name, size, writer);
			_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		} else {
			_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
			_big_store = new BigBlockStore(_bigBigBlockSize, path, name, size, writer);
		}
	}
	public OPOIFSDocument(String name, int size, POIFSDocumentPath path, POIFSWriterListener writer) {
	   this(name, size, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, path, writer);
	}

	
	public SmallDocumentBlock[] getSmallBlocks() {
		return _small_store.getBlocks();
	}

	
	public int getSize() {
		return _size;
	}

	
	void read(byte[] buffer, int offset) {
		int len = buffer.length;

		DataInputBlock currentBlock = getDataInputBlock(offset);

		int blockAvailable = currentBlock.available();
		if (blockAvailable > len) {
			currentBlock.readFully(buffer, 0, len);
			return;
		}
		
		int remaining = len;
		int writePos = 0;
		int currentOffset = offset;
		while (remaining > 0) {
			boolean blockIsExpiring = remaining >= blockAvailable;
			int reqSize;
			if (blockIsExpiring) {
				reqSize = blockAvailable;
			} else {
				reqSize = remaining;
			}
			currentBlock.readFully(buffer, writePos, reqSize);
			remaining-=reqSize;
			writePos+=reqSize;
			currentOffset += reqSize;
			if (blockIsExpiring) {
				if (currentOffset == _size) {
					if (remaining > 0) {
						throw new IllegalStateException("reached end of document stream unexpectedly");
					}
					currentBlock = null;
					break;
				}
				currentBlock = getDataInputBlock(currentOffset);
				blockAvailable = currentBlock.available();
			}
		}
	}

	
	DataInputBlock getDataInputBlock(int offset) {
		if (offset >= _size) {
			if (offset > _size) {
				throw new RuntimeException("Request for Offset " + offset + " doc size is " + _size);
			}
			return null;
		}
		if (_property.shouldUseSmallBlocks()) {
			return SmallDocumentBlock.getDataInputBlock(_small_store.getBlocks(), offset);
		}
		return DocumentBlock.getDataInputBlock(_big_store.getBlocks(), offset);
	}

	

	DocumentProperty getDocumentProperty() {
		return _property;
	}

	

	
	public void writeBlocks(OutputStream stream) throws IOException {
		_big_store.writeBlocks(stream);
	}

	
	

	
	public int countBlocks() {
		return _big_store.countBlocks();
	}

	
	public void setStartBlock(int index) {
		_property.setStartBlock(index);
	}

	
	

	
	public Object[] getViewableArray() {
		Object[] results = new Object[1];
		String result;

		try {
			ByteArrayOutputStream output = new ByteArrayOutputStream();
			BlockWritable[] blocks = null;

			if (_big_store.isValid()) {
				blocks = _big_store.getBlocks();
			} else if (_small_store.isValid()) {
				blocks = _small_store.getBlocks();
			}
			if (blocks != null) {
				for (int k = 0; k < blocks.length; k++) {
					blocks[k].writeBlocks(output);
				}
				byte[] data = output.toByteArray();

				if (data.length > _property.getSize()) {
					byte[] tmp = new byte[_property.getSize()];

					System.arraycopy(data, 0, tmp, 0, tmp.length);
					data = tmp;
				}
				output = new ByteArrayOutputStream();
				HexDump.dump(data, 0, output, 0);
				result = output.toString();
			} else {
				result = "<NO DATA>";
			}
		} catch (IOException e) {
			result = e.getMessage();
		}
		results[0] = result;
		return results;
	}

	
	public Iterator<Object> getViewableIterator() {
		return Collections.emptyList().iterator();
	}

	
	public boolean preferArray() {
		return true;
	}

	
	public String getShortDescription() {
		StringBuffer buffer = new StringBuffer();

		buffer.append("Document: \"").append(_property.getName()).append("\"");
		buffer.append(" size = ").append(getSize());
		return buffer.toString();
	}

	
	private static final class SmallBlockStore {
		private SmallDocumentBlock[] _smallBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
		private final POIFSBigBlockSize _bigBlockSize;

		
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, SmallDocumentBlock[] blocks) {
		   _bigBlockSize = bigBlockSize;
			_smallBlocks = blocks.clone();
			this._path = null;
			this._name = null;
			this._size = -1;
			this._writer = null;
		}

		
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		                String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			_smallBlocks = new SmallDocumentBlock[0];
			this._path = path;
			this._name = name;
			this._size = size;
			this._writer = writer;
		}

		
		boolean isValid() {
			return _smallBlocks.length > 0 || _writer != null;
		}

		
		SmallDocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				_smallBlocks = SmallDocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return _smallBlocks;
		}
	} 

	private static final class BigBlockStore {
		private DocumentBlock[] bigBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
      private final POIFSBigBlockSize _bigBlockSize;

		
		BigBlockStore(POIFSBigBlockSize bigBlockSize, DocumentBlock[] blocks) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = blocks.clone();
			_path = null;
			_name = null;
			_size = -1;
			_writer = null;
		}

		
		BigBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		              String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = new DocumentBlock[0];
			_path = path;
			_name = name;
			_size = size;
			_writer = writer;
		}

		
		boolean isValid() {
			return bigBlocks.length > 0 || _writer != null;
		}

		
		DocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				bigBlocks = DocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return bigBlocks;
		}

		
		void writeBlocks(OutputStream stream) throws IOException {
			if (isValid()) {
				if (_writer != null) {
					DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

					_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
					dstream.writeFiller(countBlocks() * _bigBlockSize.getBigBlockSize(),
							DocumentBlock.getFillByte());
				} else {
					for (int k = 0; k < bigBlocks.length; k++) {
						bigBlocks[k].writeBlocks(stream);
					}
				}
			}
		}

		
		int countBlocks() {

			if (isValid()) {
				if (_writer == null) {
					return bigBlocks.length;
				}
				return (_size + _bigBlockSize.getBigBlockSize() - 1)
							/ _bigBlockSize.getBigBlockSize();
			}
			return 0;
		}
	} 
}

<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.EmptyFileException;
import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.nio.ByteArrayBackedDataSource;
import org.docx4j.org.apache.poi.poifs.nio.DataSource;
import org.docx4j.org.apache.poi.poifs.nio.FileBackedDataSource;
import org.docx4j.org.apache.poi.poifs.property.DirectoryProperty;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;
import org.docx4j.org.apache.poi.poifs.property.NPropertyTable;
import org.docx4j.org.apache.poi.poifs.storage.BATBlock;
import org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.docx4j.org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlockConstants;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlockWriter;
import org.docx4j.org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;
import org.docx4j.org.apache.poi.util.CloseIgnoringInputStream;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.LongField;



public class NPOIFSFileSystem extends BlockStore
    implements POIFSViewable, Closeable
{



    
    public static InputStream createNonClosingInputStream(InputStream is) {
       return new CloseIgnoringInputStream(is);
    }
   
    private NPOIFSMiniStore _mini_store;
    private NPropertyTable  _property_table;
    private List<BATBlock>  _xbat_blocks;
    private List<BATBlock>  _bat_blocks;
    private HeaderBlock     _header;
    private DirectoryNode   _root;
    
    private DataSource _data;
    
    
    private POIFSBigBlockSize bigBlockSize = 
       POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;

    private NPOIFSFileSystem(boolean newFS)
    {
        _header         = new HeaderBlock(bigBlockSize);
        _property_table = new NPropertyTable(_header);
        _mini_store     = new NPOIFSMiniStore(this, _property_table.getRoot(), new ArrayList<BATBlock>(), _header);
        _xbat_blocks    = new ArrayList<BATBlock>();
        _bat_blocks     = new ArrayList<BATBlock>();
        _root           = null;
        
        if(newFS) {
           
           
           _data        = new ByteArrayBackedDataSource(new byte[bigBlockSize.getBigBlockSize()*3]);
        }
    }
    
    
    public NPOIFSFileSystem()
    {
       this(true);
       
        
        
        _header.setBATCount(1);
        _header.setBATArray(new int[] { 1 });
        BATBlock bb = BATBlock.createEmptyBATBlock(bigBlockSize, false);
        bb.setOurBlockIndex(1);
        _bat_blocks.add(bb);

        setNextBlock(0, POIFSConstants.END_OF_CHAIN);
        setNextBlock(1, POIFSConstants.FAT_SECTOR_BLOCK);

        _property_table.setStartBlock(0);
    }

    
    public NPOIFSFileSystem(File file)
         throws IOException
    {
       this(file, true);
    }
    
    
    public NPOIFSFileSystem(File file, boolean readOnly)
         throws IOException
    {
       this(null, file, readOnly, true);
    }
    
    
    public NPOIFSFileSystem(FileChannel channel)
         throws IOException
    {
       this(channel, true);
    }
    
    
    public NPOIFSFileSystem(FileChannel channel, boolean readOnly)
         throws IOException
    {
       this(channel, null, readOnly, false);
    }
    
    private NPOIFSFileSystem(FileChannel channel, File srcFile, boolean readOnly, boolean closeChannelOnError)
         throws IOException
    {
       this(false);

       try {
          
          if (srcFile != null) {
              if (srcFile.length() == 0)
                  throw new EmptyFileException();
              
              FileBackedDataSource d = new FileBackedDataSource(srcFile, readOnly);
              channel = d.getChannel();
              _data = d;
          } else {
              _data = new FileBackedDataSource(channel, readOnly);
          }
           
          
          ByteBuffer headerBuffer = ByteBuffer.allocate(POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
          IOUtils.readFully(channel, headerBuffer);
          
          
          _header = new HeaderBlock(headerBuffer);
          
          
          readCoreContents();
       } catch(IOException e) {
          if(closeChannelOnError) {
             channel.close();
          }
          throw e;
       } catch(RuntimeException e) {
          
          
          
          if(closeChannelOnError) {
              if (channel != null) {
                  channel.close();
                  channel = null;
              }
          }
          throw e;
       }
    }
    
    

    public NPOIFSFileSystem(InputStream stream)
        throws IOException
    {
        this(false);
        
        ReadableByteChannel channel = null;
        boolean success = false;
        
        try {
           
           channel = Channels.newChannel(stream);
           
           
           ByteBuffer headerBuffer = ByteBuffer.allocate(POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
           IOUtils.readFully(channel, headerBuffer);
           
           
           _header = new HeaderBlock(headerBuffer);
           
           
           BlockAllocationTableReader.sanityCheckBlockCount(_header.getBATCount());
   
           
           
           
           long maxSize = BATBlock.calculateMaximumSize(_header); 
           if (maxSize > Integer.MAX_VALUE) {
               throw new IllegalArgumentException("Unable read a >2gb file via an InputStream");
           }
           ByteBuffer data = ByteBuffer.allocate((int)maxSize);
           
           
           headerBuffer.position(0);
           data.put(headerBuffer);
           data.position(headerBuffer.capacity());
           
           
           IOUtils.readFully(channel, data);
           success = true;
           
           
           _data = new ByteArrayBackedDataSource(data.array(), data.position());
        } finally {
           
           if(channel != null)
              channel.close();
           closeInputStream(stream, success);
        }
        
        
        readCoreContents();
    }
    
    private void closeInputStream(InputStream stream, boolean success) {
        try {
            stream.close();
        } catch (IOException e) {
            if(success) {
                throw new RuntimeException(e);
            }
            
            
            e.printStackTrace();
        }
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        
        inp.mark(8);

        byte[] header = new byte[8];
        IOUtils.readFully(inp, header);
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header);

        
        if(inp instanceof PushbackInputStream) {
            PushbackInputStream pin = (PushbackInputStream)inp;
            pin.unread(header);
        } else {
            inp.reset();
        }

        
        return (signature.get() == HeaderBlockConstants._signature);
    }
    
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header8Bytes);
        return (signature.get() == HeaderBlockConstants._signature);
    }
    
    
    private void readCoreContents() throws IOException {
       
       bigBlockSize = _header.getBigBlockSize();
       
       
       
       ChainLoopDetector loopDetector = getChainLoopDetector();
       
       
       for(int fatAt : _header.getBATArray()) {
          readBAT(fatAt, loopDetector);
       }
       
       
       int remainingFATs = _header.getBATCount() - _header.getBATArray().length;
       
       
       BATBlock xfat; 
       int nextAt = _header.getXBATIndex();
       for(int i=0; i<_header.getXBATCount(); i++) {
          loopDetector.claim(nextAt);
          ByteBuffer fatData = getBlockAt(nextAt);
          xfat = BATBlock.createBATBlock(bigBlockSize, fatData);
          xfat.setOurBlockIndex(nextAt);
          nextAt = xfat.getValueAt(bigBlockSize.getXBATEntriesPerBlock());
          _xbat_blocks.add(xfat);
          
          
          int xbatFATs = Math.min(remainingFATs, bigBlockSize.getXBATEntriesPerBlock());
          for(int j=0; j<xbatFATs; j++) {
             int fatAt = xfat.getValueAt(j);
             if(fatAt == POIFSConstants.UNUSED_BLOCK || fatAt == POIFSConstants.END_OF_CHAIN) break;
             readBAT(fatAt, loopDetector);
          }
          remainingFATs -= xbatFATs;
       }
       
       
       
       _property_table = new NPropertyTable(_header, this);
       
       
       BATBlock sfat;
       List<BATBlock> sbats = new ArrayList<BATBlock>();
       _mini_store     = new NPOIFSMiniStore(this, _property_table.getRoot(), sbats, _header);
       nextAt = _header.getSBATStart();
       for(int i=0; i<_header.getSBATCount() && nextAt != POIFSConstants.END_OF_CHAIN; i++) {
          loopDetector.claim(nextAt);
          ByteBuffer fatData = getBlockAt(nextAt);
          sfat = BATBlock.createBATBlock(bigBlockSize, fatData);
          sfat.setOurBlockIndex(nextAt);
          sbats.add(sfat);
          nextAt = getNextBlock(nextAt);  
       }
    }
    private void readBAT(int batAt, ChainLoopDetector loopDetector) throws IOException {
       loopDetector.claim(batAt);
       ByteBuffer fatData = getBlockAt(batAt);
       BATBlock bat = BATBlock.createBATBlock(bigBlockSize, fatData);
       bat.setOurBlockIndex(batAt);
       _bat_blocks.add(bat);
    }
    private BATBlock createBAT(int offset, boolean isBAT) throws IOException {
       
       BATBlock newBAT = BATBlock.createEmptyBATBlock(bigBlockSize, !isBAT);
       newBAT.setOurBlockIndex(offset);
       
       ByteBuffer buffer = ByteBuffer.allocate(bigBlockSize.getBigBlockSize());
       int writeTo = (1+offset) * bigBlockSize.getBigBlockSize(); 
       _data.write(buffer, writeTo);
       
       return newBAT;
    }
    
    
    @Override
    protected ByteBuffer getBlockAt(final int offset) throws IOException {
       
       long blockWanted = offset + 1;
       long startAt = blockWanted * bigBlockSize.getBigBlockSize();
       try {
           return _data.read(bigBlockSize.getBigBlockSize(), startAt);
       } catch (IndexOutOfBoundsException e) {
           throw new IndexOutOfBoundsException("Block " + offset + " not found - " + e);
       }
    }
    
    
    @Override
    protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {
       try {
          return getBlockAt(offset);
       } catch(IndexOutOfBoundsException e) {
          
          long startAt = (offset+1) * bigBlockSize.getBigBlockSize();
          
          ByteBuffer buffer = ByteBuffer.allocate(getBigBlockSize());
          _data.write(buffer, startAt);
          
          return getBlockAt(offset);
       }
    }
    
    
    @Override
    protected BATBlockAndIndex getBATBlockAndIndex(final int offset) {
       return BATBlock.getBATBlockAndIndex(
             offset, _header, _bat_blocks
       );
    }
    
    
    @Override
    protected int getNextBlock(final int offset) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       return bai.getBlock().getValueAt( bai.getIndex() );
    }
    
    
    @Override
    protected void setNextBlock(final int offset, final int nextBlock) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       bai.getBlock().setValueAt(
             bai.getIndex(), nextBlock
       );
    }
    
    
    @Override
    protected int getFreeBlock() throws IOException {
        int numSectors = bigBlockSize.getBATEntriesPerBlock();

       
       int offset = 0;
       for (BATBlock bat : _bat_blocks) {
          if(bat.hasFreeSectors()) {
             
             for(int j=0; j<numSectors; j++) {
                int batValue = bat.getValueAt(j);
                if(batValue == POIFSConstants.UNUSED_BLOCK) {
                   
                   return offset + j;
                }
             }
          }
          
          
          offset += numSectors;
       }
       
       
       
       BATBlock bat = createBAT(offset, true);
       bat.setValueAt(0, POIFSConstants.FAT_SECTOR_BLOCK);
       _bat_blocks.add(bat);
       
       
       if(_header.getBATCount() >= 109) {
          
          BATBlock xbat = null;
          for(BATBlock x : _xbat_blocks) {
             if(x.hasFreeSectors()) {
                xbat = x;
                break;
             }
          }
          if(xbat == null) {
             
             xbat = createBAT(offset+1, false);
             
             xbat.setValueAt(0, offset);
             
             bat.setValueAt(1, POIFSConstants.DIFAT_SECTOR_BLOCK);
             
             
             offset++;
             
             
             if(_xbat_blocks.size() == 0) {
                _header.setXBATStart(offset);
             } else {
                _xbat_blocks.get(_xbat_blocks.size()-1).setValueAt(
                      bigBlockSize.getXBATEntriesPerBlock(), offset
                );
             }
             _xbat_blocks.add(xbat);
             _header.setXBATCount(_xbat_blocks.size());
          } else {
              
              for(int i=0; i<bigBlockSize.getXBATEntriesPerBlock(); i++) {
                 if(xbat.getValueAt(i) == POIFSConstants.UNUSED_BLOCK) {
                    xbat.setValueAt(i, offset);
                    break;
                 }
              }
          }
       } else {
          
          int[] newBATs = new int[_header.getBATCount()+1];
          System.arraycopy(_header.getBATArray(), 0, newBATs, 0, newBATs.length-1);
          newBATs[newBATs.length-1] = offset;
          _header.setBATArray(newBATs);
       }
       _header.setBATCount(_bat_blocks.size());
       
       
       return offset+1;
    }
    
    protected long size() throws IOException {
        return _data.size();
    }
    
    @Override
    protected ChainLoopDetector getChainLoopDetector() throws IOException {
      return new ChainLoopDetector(_data.size());
    }

   
    NPropertyTable _get_property_table() {
      return _property_table;
    }
    
    
    public NPOIFSMiniStore getMiniStore() {
       return _mini_store;
    }

    
    void addDocument(final NPOIFSDocument document)
    {
        _property_table.addProperty(document.getDocumentProperty());
    }

    
    void addDirectory(final DirectoryProperty directory)
    {
        _property_table.addProperty(directory);
    }

   

    public DocumentEntry createDocument(final InputStream stream,
                                        final String name)
        throws IOException
    {
        return getRoot().createDocument(name, stream);
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return getRoot().createDocument(name, size, writer);
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        return getRoot().createDirectory(name);
    }
    
    
    public void writeFilesystem() throws IOException
    {
       if(_data instanceof FileBackedDataSource) {
          
       } else {
          throw new IllegalArgumentException(
                "POIFS opened from an inputstream, so writeFilesystem() may " +
                "not be called. Use writeFilesystem(OutputStream) instead"
          );
       }
       if (! ((FileBackedDataSource)_data).isWriteable()) {
           throw new IllegalArgumentException(
                "POIFS opened in read only mode, so writeFilesystem() may " +
                "not be called. Open the FileSystem in read-write mode first"
           );
       }
       syncWithDataSource();
    }

    

    public void writeFilesystem(final OutputStream stream)
        throws IOException
    {
       
       syncWithDataSource();
       
       
       _data.copyTo(stream);
    }
    
    
    private void syncWithDataSource() throws IOException {
        
        
        _mini_store.syncWithDataSource();
        
        
        NPOIFSStream propStream = new NPOIFSStream(this, _header.getPropertyStart());
        _property_table.preWrite();
        _property_table.write(propStream);
        
        
       
       HeaderBlockWriter hbw = new HeaderBlockWriter(_header);
       hbw.writeBlock( getBlockAt(-1) );
       
       
       for(BATBlock bat : _bat_blocks) {
          ByteBuffer block = getBlockAt(bat.getOurBlockIndex());
          BlockAllocationTableWriter.writeBlock(bat, block);
       }
       
       for(BATBlock bat : _xbat_blocks) {
           ByteBuffer block = getBlockAt(bat.getOurBlockIndex());
           BlockAllocationTableWriter.writeBlock(bat, block);
        }
    }
    
    
    public void close() throws IOException {
       _data.close();
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length != 2)
        {
            System.err.println(
                "two arguments required: input filename and output filename");
            System.exit(1);
        }
        FileInputStream  istream = new FileInputStream(args[ 0 ]);
        try {
            FileOutputStream ostream = new FileOutputStream(args[ 1 ]);
            try {
                NPOIFSFileSystem fs = new NPOIFSFileSystem(istream);
                try {
                    fs.writeFilesystem(ostream);
                } finally {
                    fs.close();
                }
            } finally {
                ostream.close();
            }
        } finally {
            istream.close();
        }
    }

    
    public DirectoryNode getRoot()
    {
        if (_root == null) {
           _root = new DirectoryNode(_property_table.getRoot(), this, null);
        }
        return _root;
    }

    

    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
    	return getRoot().createDocumentInputStream(documentName);
    }

    
    void remove(EntryNode entry) throws IOException
    {
        
        if (entry instanceof DocumentEntry) {
            NPOIFSDocument doc = new NPOIFSDocument((DocumentProperty)entry.getProperty(), this);
            doc.free();
        }
        
        
        _property_table.removeProperty(entry.getProperty());
    }
    
    

    

    public Object [] getViewableArray()
    {
        if (preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableArray();
        }
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        if (!preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableIterator();
        }
        return Collections.emptyList().iterator();
    }

    

    public boolean preferArray()
    {
        return (( POIFSViewable ) getRoot()).preferArray();
    }

    

    public String getShortDescription()
    {
        return "POIFS FileSystem";
    }

    

    
    public int getBigBlockSize() {
      return bigBlockSize.getBigBlockSize();
    }

    
    public POIFSBigBlockSize getBigBlockSizeDetails() {
      return bigBlockSize;
    }

    @Override
    protected int getBlockStoreBlockSize() {
       return getBigBlockSize();
    }
}


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;

import org.docx4j.org.apache.poi.poifs.storage.DataInputBlock;


public final class ODocumentInputStream extends DocumentInputStream {
	
	private int _current_offset;

	
	private int _marked_offset;

	
	private int _document_size;

	
	private boolean _closed;

	
	private OPOIFSDocument _document;

	
	private DataInputBlock _currentBlock;

	
	public ODocumentInputStream(DocumentEntry document) throws IOException {
		if (!(document instanceof DocumentNode)) {
			throw new IOException("Cannot open internal document storage");
		}
		DocumentNode documentNode = (DocumentNode)document;
		if (documentNode.getDocument() == null) {
         throw new IOException("Cannot open internal document storage");
		}
		      
		_current_offset = 0;
		_marked_offset = 0;
		_document_size = document.getSize();
		_closed = false;
		_document = documentNode.getDocument();
		_currentBlock = getDataInputBlock(0);
	}

	
	public ODocumentInputStream(OPOIFSDocument document) {
		_current_offset = 0;
		_marked_offset = 0;
		_document_size = document.getSize();
		_closed = false;
		_document = document;
		_currentBlock = getDataInputBlock(0);
	}

	@Override
	public int available() {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		return _document_size - _current_offset;
	}

   @Override
	public void close() {
		_closed = true;
	}

   @Override
	public void mark(int ignoredReadlimit) {
		_marked_offset = _current_offset;
	}

	private DataInputBlock getDataInputBlock(int offset) {
		return _document.getDataInputBlock(offset);
	}

   @Override
	public int read() throws IOException {
		dieIfClosed();
		if (atEOD()) {
			return EOF;
		}
		int result = _currentBlock.readUByte();
		_current_offset++;
		if (_currentBlock.available() < 1) {
			_currentBlock = getDataInputBlock(_current_offset);
		}
		return result;
	}

   @Override
	public int read(byte[] b, int off, int len) throws IOException {
		dieIfClosed();
		if (b == null) {
			throw new IllegalArgumentException("buffer must not be null");
		}
		if (off < 0 || len < 0 || b.length < off + len) {
			throw new IndexOutOfBoundsException("can't read past buffer boundaries");
		}
		if (len == 0) {
			return 0;
		}
		if (atEOD()) {
			return EOF;
		}
		int limit = Math.min(available(), len);
		readFully(b, off, limit);
		return limit;
	}

	
   @Override
	public void reset() {
		_current_offset = _marked_offset;
		_currentBlock = getDataInputBlock(_current_offset);
	}

   @Override
	public long skip(long n) throws IOException {
		dieIfClosed();
		if (n < 0) {
			return 0;
		}
		int new_offset = _current_offset + (int) n;

		if (new_offset < _current_offset) {

			
			new_offset = _document_size;
		} else if (new_offset > _document_size) {
			new_offset = _document_size;
		}
		long rval = new_offset - _current_offset;

		_current_offset = new_offset;
		_currentBlock = getDataInputBlock(_current_offset);
		return rval;
	}

	private void dieIfClosed() throws IOException {
		if (_closed) {
			throw new IOException("cannot perform requested operation on a closed stream");
		}
	}

	private boolean atEOD() {
		return _current_offset == _document_size;
	}

	private void checkAvaliable(int requestedSize) {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		if (requestedSize > _document_size - _current_offset) {
			throw new RuntimeException("Buffer underrun - requested " + requestedSize
					+ " bytes but " + (_document_size - _current_offset) + " was available");
		}
	}

   @Override
	public byte readByte() {
		return (byte) readUByte();
	}

   @Override
	public double readDouble() {
		return Double.longBitsToDouble(readLong());
	}

   @Override
	public short readShort() {
		return (short) readUShort();
	}

   @Override
	public void readFully(byte[] buf, int off, int len) {
		checkAvaliable(len);
		int blockAvailable = _currentBlock.available();
		if (blockAvailable > len) {
			_currentBlock.readFully(buf, off, len);
			_current_offset += len;
			return;
		}
		
		int remaining = len;
		int writePos = off;
		while (remaining > 0) {
			boolean blockIsExpiring = remaining >= blockAvailable;
			int reqSize;
			if (blockIsExpiring) {
				reqSize = blockAvailable;
			} else {
				reqSize = remaining;
			}
			_currentBlock.readFully(buf, writePos, reqSize);
			remaining -= reqSize;
			writePos += reqSize;
			_current_offset += reqSize;
			if (blockIsExpiring) {
				if (_current_offset == _document_size) {
					if (remaining > 0) {
						throw new IllegalStateException(
								"reached end of document stream unexpectedly");
					}
					_currentBlock = null;
					break;
				}
				_currentBlock = getDataInputBlock(_current_offset);
				blockAvailable = _currentBlock.available();
			}
		}
	}

   @Override
	public long readLong() {
		checkAvaliable(SIZE_LONG);
		int blockAvailable = _currentBlock.available();
		long result;
		if (blockAvailable > SIZE_LONG) {
			result = _currentBlock.readLongLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_LONG) {
				result = _currentBlock.readLongLE();
			} else {
				result = nextBlock.readLongLE(_currentBlock, blockAvailable);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_LONG;
		return result;
	}

   @Override
	public int readInt() {
		checkAvaliable(SIZE_INT);
		int blockAvailable = _currentBlock.available();
		int result;
		if (blockAvailable > SIZE_INT) {
			result = _currentBlock.readIntLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_INT) {
				result = _currentBlock.readIntLE();
			} else {
				result = nextBlock.readIntLE(_currentBlock, blockAvailable);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_INT;
		return result;
	}

   @Override
	public int readUShort() {
		checkAvaliable(SIZE_SHORT);
		int blockAvailable = _currentBlock.available();
		int result;
		if (blockAvailable > SIZE_SHORT) {
			result = _currentBlock.readUShortLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_SHORT) {
				result = _currentBlock.readUShortLE();
			} else {
				result = nextBlock.readUShortLE(_currentBlock);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_SHORT;
		return result;
	}

   @Override
	public int readUByte() {
		checkAvaliable(1);
		int result = _currentBlock.readUByte();
		_current_offset++;
		if (_currentBlock.available() < 1) {
			_currentBlock = getDataInputBlock(_current_offset);
		}
		return result;
	}
}

<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.docx4j.org.apache.poi.util.LittleEndianInput;


public class DocumentInputStream extends InputStream implements LittleEndianInput {
	
	protected static final int EOF = -1;

	protected static final int SIZE_SHORT = 2;
	protected static final int SIZE_INT = 4;
	protected static final int SIZE_LONG = 8;
	
	private DocumentInputStream delegate;
	
	
	protected DocumentInputStream() {}

	
	public DocumentInputStream(DocumentEntry document) throws IOException {
	   if (!(document instanceof DocumentNode)) {
	      throw new IOException("Cannot open internal document storage");
	   }
	   DocumentNode documentNode = (DocumentNode)document;
	   DirectoryNode parentNode = (DirectoryNode)document.getParent();

	   if(documentNode.getDocument() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getOFileSystem() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getNFileSystem() != null) {
	      delegate = new NDocumentInputStream(document);
	   } else {
	      throw new IOException("No FileSystem bound on the parent, can't read contents");
	   }
	}

	
	public DocumentInputStream(OPOIFSDocument document) {
	   delegate = new ODocumentInputStream(document);
	}

   
   public DocumentInputStream(NPOIFSDocument document) {
      delegate = new NDocumentInputStream(document);
   }

	public int available() {
	   return delegate.available();
	}

	public void close() {
	   delegate.close();
	}

	public void mark(int ignoredReadlimit) {
		delegate.mark(ignoredReadlimit);
	}

	
	public boolean markSupported() {
		return true;
	}

	public int read() throws IOException {
	   return delegate.read();
	}

	public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}

	public int read(byte[] b, int off, int len) throws IOException {
	   return delegate.read(b, off, len);
	}

	
	public void reset() {
	   delegate.reset();
	}

	public long skip(long n) throws IOException {
	   return delegate.skip(n);
	}

	public byte readByte() {
	   return delegate.readByte();
	}

	public double readDouble() {
	   return delegate.readDouble();
	}

	public short readShort() {
		return (short) readUShort();
	}

   public void readFully(byte[] buf) {
      readFully(buf, 0, buf.length);
   }

	public void readFully(byte[] buf, int off, int len) {
	   delegate.readFully(buf, off, len);
	}

	public long readLong() {
	   return delegate.readLong();
	}

	public int readInt() {
	   return delegate.readInt();
	}

	public int readUShort() {
	   return delegate.readUShort();
	}

	public int readUByte() {
	   return delegate.readUByte();
	}
	
    public long readUInt() {
        int i = readInt();
        return i & 0xFFFFFFFFL;
    }
}

<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Iterator;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.BlockStore.ChainLoopDetector;
import org.docx4j.org.apache.poi.poifs.property.Property;
import org.docx4j.org.apache.poi.poifs.storage.HeaderBlock;



public class NPOIFSStream implements Iterable<ByteBuffer>
{
	private BlockStore blockStore;
	private int startBlock;
	private OutputStream outStream;
	
	
	public NPOIFSStream(BlockStore blockStore, int startBlock) {
	   this.blockStore = blockStore;
	   this.startBlock = startBlock;
	}
	
	
	public NPOIFSStream(BlockStore blockStore) {
      this.blockStore = blockStore;
	   this.startBlock = POIFSConstants.END_OF_CHAIN;
	}
	
	
	public int getStartBlock() {
	   return startBlock;
	}

	
   public Iterator<ByteBuffer> iterator() {
      return getBlockIterator();
   }
	
   public Iterator<ByteBuffer> getBlockIterator() {
      if(startBlock == POIFSConstants.END_OF_CHAIN) {
         throw new IllegalStateException(
               "Can't read from a new stream before it has been written to"
         );
      }
      return new StreamBlockByteBufferIterator(startBlock);
   }

   
   public void updateContents(byte[] contents) throws IOException {
       OutputStream os = getOutputStream();
       os.write(contents);
       os.close();
   }

   public OutputStream getOutputStream() throws IOException {
       if (outStream == null) {
           outStream = new StreamBlockByteBuffer();
       }
       return outStream;
   }
   
   
   
   
   
   
   public void free() throws IOException {
      ChainLoopDetector loopDetector = blockStore.getChainLoopDetector();
      free(loopDetector);
   }
   private void free(ChainLoopDetector loopDetector) {
      int nextBlock = startBlock;
      while(nextBlock != POIFSConstants.END_OF_CHAIN) {
         int thisBlock = nextBlock;
         loopDetector.claim(thisBlock);
         nextBlock = blockStore.getNextBlock(thisBlock);
         blockStore.setNextBlock(thisBlock, POIFSConstants.UNUSED_BLOCK);
      }
      this.startBlock = POIFSConstants.END_OF_CHAIN;
   }
   
   
   protected class StreamBlockByteBufferIterator implements Iterator<ByteBuffer> {
      private ChainLoopDetector loopDetector;
      private int nextBlock;
      
      protected StreamBlockByteBufferIterator(int firstBlock) {
         this.nextBlock = firstBlock;
         try {
            this.loopDetector = blockStore.getChainLoopDetector();
         } catch(IOException e) {
            throw new RuntimeException(e);
         }
      }

      public boolean hasNext() {
         if(nextBlock == POIFSConstants.END_OF_CHAIN) {
            return false;
         }
         return true;
      }

      public ByteBuffer next() {
         if(nextBlock == POIFSConstants.END_OF_CHAIN) {
            throw new IndexOutOfBoundsException("Can't read past the end of the stream");
         }
         
         try {
            loopDetector.claim(nextBlock);
            ByteBuffer data = blockStore.getBlockAt(nextBlock);
            nextBlock = blockStore.getNextBlock(nextBlock);
            return data;
         } catch(IOException e) {
            throw new RuntimeException(e);
         }
      }

      public void remove() {
         throw new UnsupportedOperationException();
      }
   }
   
   protected class StreamBlockByteBuffer extends OutputStream {
       byte oneByte[] = new byte[1];
       ByteBuffer buffer;
       
       
       ChainLoopDetector loopDetector;
       int prevBlock, nextBlock;

       protected StreamBlockByteBuffer() throws IOException {
           loopDetector = blockStore.getChainLoopDetector();
           prevBlock = POIFSConstants.END_OF_CHAIN;
           nextBlock = startBlock;
       }

       protected void createBlockIfNeeded() throws IOException {
           if (buffer != null && buffer.hasRemaining()) return;
           
           int thisBlock = nextBlock;
           
           
           
           if(thisBlock == POIFSConstants.END_OF_CHAIN) {
              thisBlock = blockStore.getFreeBlock();
              loopDetector.claim(thisBlock);
              
              
              nextBlock = POIFSConstants.END_OF_CHAIN;
              
              
              if(prevBlock != POIFSConstants.END_OF_CHAIN) {
                 blockStore.setNextBlock(prevBlock, thisBlock);
              }
              blockStore.setNextBlock(thisBlock, POIFSConstants.END_OF_CHAIN);
              
              
              
              if(startBlock == POIFSConstants.END_OF_CHAIN) {
                 startBlock = thisBlock;
              }
           } else {
              loopDetector.claim(thisBlock);
              nextBlock = blockStore.getNextBlock(thisBlock);
           }

           buffer = blockStore.createBlockIfNeeded(thisBlock);
           
           
           prevBlock = thisBlock;
       }
       
       public void write(int b) throws IOException {
            oneByte[0] = (byte)(b & 0xFF);
            write(oneByte);
       }
    
        public void write(byte[] b, int off, int len) throws IOException {
            if ((off < 0) || (off > b.length) || (len < 0) ||
                    ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return;
            }

            do {
                createBlockIfNeeded();
                int writeBytes = Math.min(buffer.remaining(), len);
                buffer.put(b, off, writeBytes);
                off += writeBytes;
                len -= writeBytes;
            } while (len > 0);
        }
    
        public void close() throws IOException {
            
            NPOIFSStream toFree = new NPOIFSStream(blockStore, nextBlock);
            toFree.free(loopDetector);
            
            
            if (prevBlock != POIFSConstants.END_OF_CHAIN) {
                blockStore.setNextBlock(prevBlock, POIFSConstants.END_OF_CHAIN);
            }
        }
   }
}


<code block>

        
package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;


public class NotOLE2FileException extends IOException {
	public NotOLE2FileException(String s) {
		super(s);
	}
}

<code block>

        
package org.docx4j.org.apache.poi.poifs.filesystem;


public class OfficeXmlFileException extends IllegalArgumentException {
	public OfficeXmlFileException(String s) {
		super(s);
	}
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;


public class DocumentNode
    extends EntryNode
    implements DocumentEntry, POIFSViewable
{

    
    private OPOIFSDocument _document;

    

    DocumentNode(final DocumentProperty property, final DirectoryNode parent)
    {
        super(property, parent);
        _document = property.getDocument();
    }

    
    OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public int getSize()
    {
        return getProperty().getSize();
    }

    
    

    

    @Override
    public boolean isDocumentEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {
        return true;
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        components.add(_document);
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;

import org.docx4j.org.apache.poi.poifs.property.DocumentProperty;
import org.docx4j.org.apache.poi.util.LittleEndian;


public final class NDocumentInputStream extends DocumentInputStream {
    
    private int _current_offset;
    
    private int _current_block_count;

    
    private int _marked_offset;
    
    private int _marked_offset_count;

    
    private int _document_size;

    
    private boolean _closed;

    
    private NPOIFSDocument _document;

    private Iterator<ByteBuffer> _data;
    private ByteBuffer _buffer;

    
    public NDocumentInputStream(DocumentEntry document) throws IOException {
        if (!(document instanceof DocumentNode)) {
            throw new IOException("Cannot open internal document storage, " + document + " not a Document Node");
        }
        _current_offset = 0;
        _current_block_count = 0;
        _marked_offset = 0;
        _marked_offset_count = 0;
        _document_size = document.getSize();
        _closed = false;

        DocumentNode doc = (DocumentNode)document;
        DocumentProperty property = (DocumentProperty)doc.getProperty();
        _document = new NPOIFSDocument(
                property, 
                ((DirectoryNode)doc.getParent()).getNFileSystem()
        );
        _data = _document.getBlockIterator();
    }

    
    public NDocumentInputStream(NPOIFSDocument document) {
        _current_offset = 0;
        _current_block_count = 0;
        _marked_offset = 0;
        _marked_offset_count = 0;
        _document_size = document.getSize();
        _closed = false;
        _document = document;
        _data = _document.getBlockIterator();
    }

    @Override
    public int available() {
        if (_closed) {
            throw new IllegalStateException("cannot perform requested operation on a closed stream");
        }
        return _document_size - _current_offset;
    }

    @Override
    public void close() {
        _closed = true;
    }

    @Override
    public void mark(int ignoredReadlimit) {
        _marked_offset = _current_offset;
        _marked_offset_count = Math.max(0, _current_block_count - 1);
    }

    @Override
    public int read() throws IOException {
        dieIfClosed();
        if (atEOD()) {
            return EOF;
        }
        byte[] b = new byte[1];
        int result = read(b, 0, 1);
        if(result >= 0) {
            if(b[0] < 0) {
                return b[0]+256;
            }
            return b[0];
        }
        return result;
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        dieIfClosed();
        if (b == null) {
            throw new IllegalArgumentException("buffer must not be null");
        }
        if (off < 0 || len < 0 || b.length < off + len) {
            throw new IndexOutOfBoundsException("can't read past buffer boundaries");
        }
        if (len == 0) {
            return 0;
        }
        if (atEOD()) {
            return EOF;
        }
        int limit = Math.min(available(), len);
        readFully(b, off, limit);
        return limit;
    }

    
    @Override
    public void reset() {
        
        if(_marked_offset == 0 && _marked_offset_count == 0) {
            _current_block_count = _marked_offset_count;
            _current_offset = _marked_offset;
            _data = _document.getBlockIterator();
            _buffer = null;
            return;
        }

        
        _data = _document.getBlockIterator();
        _current_offset = 0;
		for(int i=0; i<_marked_offset_count; i++) {
		   _buffer = _data.next();
		   _current_offset += _buffer.remaining();
		}
		
      _current_block_count = _marked_offset_count;
      
      
      if(_current_offset != _marked_offset) {
   		
         _buffer = _data.next();
         _current_block_count++;
         
   		
         
         
         int skipBy = _marked_offset - _current_offset;
   		_buffer.position(_buffer.position() + skipBy);
      }

      
      _current_offset = _marked_offset;
	}

   @Override
	public long skip(long n) throws IOException {
		dieIfClosed();
		if (n < 0) {
			return 0;
		}
		int new_offset = _current_offset + (int) n;

		if (new_offset < _current_offset) {
			
			new_offset = _document_size;
		} else if (new_offset > _document_size) {
			new_offset = _document_size;
		}
		
		long rval = new_offset - _current_offset;
		
		
		byte[] skip = new byte[(int)rval];
		readFully(skip);
		return rval;
	}

	private void dieIfClosed() throws IOException {
		if (_closed) {
			throw new IOException("cannot perform requested operation on a closed stream");
		}
	}

	private boolean atEOD() {
		return _current_offset == _document_size;
	}

	private void checkAvaliable(int requestedSize) {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		if (requestedSize > _document_size - _current_offset) {
			throw new RuntimeException("Buffer underrun - requested " + requestedSize
					+ " bytes but " + (_document_size - _current_offset) + " was available");
		}
	}

   @Override
	public void readFully(byte[] buf, int off, int len) {
		checkAvaliable(len);

		int read = 0;
		while(read < len) {
		   if(_buffer == null || _buffer.remaining() == 0) {
		      _current_block_count++;
		      _buffer = _data.next();
		   }
		   
		   int limit = Math.min(len-read, _buffer.remaining());
		   _buffer.get(buf, off+read, limit);
         _current_offset += limit;
		   read += limit;
		}
	}

   @Override
   public byte readByte() {
      return (byte) readUByte();
   }

   @Override
   public double readDouble() {
      return Double.longBitsToDouble(readLong());
   }

   @Override
	public long readLong() {
		checkAvaliable(SIZE_LONG);
		byte[] data = new byte[SIZE_LONG];
		readFully(data, 0, SIZE_LONG);
		return LittleEndian.getLong(data, 0);
	}

   @Override
   public short readShort() {
      checkAvaliable(SIZE_SHORT);
      byte[] data = new byte[SIZE_SHORT];
      readFully(data, 0, SIZE_SHORT);
      return LittleEndian.getShort(data);
   }

   @Override
	public int readInt() {
		checkAvaliable(SIZE_INT);
      byte[] data = new byte[SIZE_INT];
      readFully(data, 0, SIZE_INT);
      return LittleEndian.getInt(data);
	}

   @Override
	public int readUShort() {
		checkAvaliable(SIZE_SHORT);
      byte[] data = new byte[SIZE_SHORT];
      readFully(data, 0, SIZE_SHORT);
      return LittleEndian.getUShort(data);
	}

   @Override
	public int readUByte() {
		checkAvaliable(1);
      byte[] data = new byte[1];
      readFully(data, 0, 1);
      if(data[0] >= 0)
         return data[0];
      return data[0] + 256;
	}
}

<code block>

package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.docx4j.org.apache.poi.util.Internal;

@Internal
public class EntryUtils
{

    
    @Internal
    public static void copyNodeRecursively( Entry entry, DirectoryEntry target )
            throws IOException
    {
        
        
        DirectoryEntry newTarget = null;
        if ( entry.isDirectoryEntry() )
        {
        	DirectoryEntry dirEntry = (DirectoryEntry)entry;
            newTarget = target.createDirectory( entry.getName() );
            newTarget.setStorageClsid( dirEntry.getStorageClsid() );
            Iterator<Entry> entries = dirEntry.getEntries();

            while ( entries.hasNext() )
            {
                copyNodeRecursively( entries.next(), newTarget );
            }
        }
        else
        {
            DocumentEntry dentry = (DocumentEntry) entry;
            DocumentInputStream dstream = new DocumentInputStream( dentry );
            target.createDocument( dentry.getName(), dstream );
            dstream.close();
        }
    }

    
    public static void copyNodes(DirectoryEntry sourceRoot,
            DirectoryEntry targetRoot) throws IOException
    {
        for (Entry entry : sourceRoot) {
            copyNodeRecursively( entry, targetRoot );
        }
    }

    
    public static void copyNodes( FilteringDirectoryNode filteredSource,
            FilteringDirectoryNode filteredTarget ) throws IOException
    {
        
        
        copyNodes( (DirectoryEntry)filteredSource, (DirectoryEntry)filteredTarget );
    }

    
    public static void copyNodes( DirectoryEntry sourceRoot,
            DirectoryEntry targetRoot, List<String> excepts )
            throws IOException
    {
        Iterator<Entry> entries = sourceRoot.getEntries();
        while ( entries.hasNext() )
        {
            Entry entry = entries.next();
            if ( !excepts.contains( entry.getName() ) )
            {
                copyNodeRecursively( entry, targetRoot );
            }
        }
    }

    
    public static void copyNodes( OPOIFSFileSystem source,
            OPOIFSFileSystem target ) throws IOException
    {
        copyNodes( source.getRoot(), target.getRoot() );
    }
    
    public static void copyNodes( NPOIFSFileSystem source,
            NPOIFSFileSystem target ) throws IOException
    {
        copyNodes( source.getRoot(), target.getRoot() );
    }
    
    
    public static void copyNodes( OPOIFSFileSystem source,
            OPOIFSFileSystem target, List<String> excepts ) throws IOException
    {
        copyNodes(
              new FilteringDirectoryNode(source.getRoot(), excepts),
              new FilteringDirectoryNode(target.getRoot(), excepts)
        );
    }
    
    public static void copyNodes( NPOIFSFileSystem source,
            NPOIFSFileSystem target, List<String> excepts ) throws IOException
    {
        copyNodes(
              new FilteringDirectoryNode(source.getRoot(), excepts),
              new FilteringDirectoryNode(target.getRoot(), excepts)
        );
    }
    
    
    public static boolean areDirectoriesIdentical(DirectoryEntry dirA, DirectoryEntry dirB) {
       
       if (! dirA.getName().equals(dirB.getName())) {
          return false;
       }
       
       
       if (dirA.getEntryCount() != dirB.getEntryCount()) {
          return false;
       }
       
       
       Map<String,Integer> aSizes = new HashMap<String, Integer>();
       final int isDirectory = -12345; 
       for (Entry a : dirA) {
          String aName = a.getName();
          if (a.isDirectoryEntry()) {
             aSizes.put(aName, isDirectory);
          } else {
             aSizes.put(aName, ((DocumentNode)a).getSize());
          }
       }
       for (Entry b : dirB) {
          String bName = b.getName();
          if (! aSizes.containsKey(bName)) {
             
             return false;
          }
          
          int size;
          if (b.isDirectoryEntry()) {
             size = isDirectory;
          } else {
             size = ((DocumentNode)b).getSize();
          }
          if (size != aSizes.get(bName)) {
             
             return false;
          }
          
          
          aSizes.remove(bName);
       }
       if (!aSizes.isEmpty()) {
          
          return false;
       }
       
       
       for (Entry a : dirA) {
          try {
             Entry b = dirB.getEntry(a.getName());
             boolean match;
             if (a.isDirectoryEntry()) {
                match = areDirectoriesIdentical(
                      (DirectoryEntry)a, (DirectoryEntry)b);
             } else {
                match = areDocumentsIdentical(
                      (DocumentEntry)a, (DocumentEntry)b);
             }
             if (!match) return false;
          } catch(FileNotFoundException e) {
             
             return false;
          } catch(IOException e) {
             
             return false;
          }
       }
       
       
       return true;
    }
    
    
    public static boolean areDocumentsIdentical(DocumentEntry docA, DocumentEntry docB) throws IOException {
       if (! docA.getName().equals(docB.getName())) {
          
          return false;
       }
       if (docA.getSize() != docB.getSize()) {
          
          return false;
       }

       boolean matches = true;
       DocumentInputStream inpA = null, inpB = null;
       try {
          inpA = new DocumentInputStream(docA);
          inpB = new DocumentInputStream(docB);
          
          int readA, readB;
          do {
             readA = inpA.read();
             readB = inpB.read();
             if (readA != readB) {
                matches = false;
                break;
             }
          } while(readA != -1 && readB != -1);
       } finally {
          if (inpA != null) inpA.close();
          if (inpB != null) inpB.close();
       }
       
       return matches;
    }
}

<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.docx4j.openpackaging.packages.OpcPackage;
import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.dev.POIFSViewable;
import org.docx4j.org.apache.poi.poifs.property.DirectoryProperty;
import org.docx4j.org.apache.poi.poifs.property.Property;
import org.docx4j.org.apache.poi.poifs.property.PropertyTable;
import org.docx4j.org.apache.poi.poifs.storage.*;
import org.docx4j.org.apache.poi.util.CloseIgnoringInputStream;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.LongField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class OPOIFSFileSystem
    implements POIFSViewable
{
	
	private static Logger _logger = LoggerFactory.getLogger(OPOIFSFileSystem.class);
	

    
    public static InputStream createNonClosingInputStream(InputStream is) {
        return new CloseIgnoringInputStream(is);
    }

    private PropertyTable _property_table;
    private List<OPOIFSDocument> _documents;
    private DirectoryNode _root;

    
    private POIFSBigBlockSize bigBlockSize = 
       POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;

    
    public OPOIFSFileSystem()
    {
        HeaderBlock header_block = new HeaderBlock(bigBlockSize);
        _property_table = new PropertyTable(header_block);
        _documents      = new ArrayList<OPOIFSDocument>();
        _root           = null;
    }

    

    public OPOIFSFileSystem(InputStream stream)
        throws IOException
    {
        this();
        boolean success = false;

        HeaderBlock header_block;
        RawDataBlockList data_blocks;
        try {
            
            header_block = new HeaderBlock(stream);
            bigBlockSize = header_block.getBigBlockSize();

            
            data_blocks = new RawDataBlockList(stream, bigBlockSize);
            success = true;
        } finally {
            closeInputStream(stream, success);
        }


        
        
        new BlockAllocationTableReader(header_block.getBigBlockSize(),
                                       header_block.getBATCount(),
                                       header_block.getBATArray(),
                                       header_block.getXBATCount(),
                                       header_block.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block, data_blocks);

        
        processProperties(
        		SmallBlockTableReader.getSmallDocumentBlocks(
        		      bigBlockSize, data_blocks, properties.getRoot(),
        				header_block.getSBATStart()
        		),
        		data_blocks,
        		properties.getRoot().getChildren(),
        		null,
        		header_block.getPropertyStart()
        );

        
        getRoot().setStorageClsid(properties.getRoot().getStorageClsid());
    }
    
    protected void closeInputStream(InputStream stream, boolean success) {

        if(stream.markSupported() && !(stream instanceof ByteArrayInputStream)) {
            String msg = "POIFS is closing the supplied input stream of type ("
                    + stream.getClass().getName() + ") which supports mark/reset.  "
                    + "This will be a problem for the caller if the stream will still be used.  "
                    + "If that is the case the caller should wrap the input stream to avoid this close logic.  "
                    + "This warning is only temporary and will not be present in future versions.";
            _logger.warn( msg);
        }
        try {
            stream.close();
        } catch (IOException e) {
            if(success) {
                throw new RuntimeException(e);
            }
            
            
            e.printStackTrace();
        }
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        
        byte[] header = IOUtils.peekFirst8Bytes(inp);
        return hasPOIFSHeader(header);
    }
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header8Bytes);

        
        return (signature.get() == HeaderBlockConstants._signature);
    }

    

    public DocumentEntry createDocument(final InputStream stream,
                                        final String name)
        throws IOException
    {
        return getRoot().createDocument(name, stream);
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return getRoot().createDocument(name, size, writer);
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        return getRoot().createDirectory(name);
    }

    

    public void writeFilesystem(final OutputStream stream)
        throws IOException
    {

        
        _property_table.preWrite();

        
        SmallBlockTableWriter      sbtw       =
            new SmallBlockTableWriter(bigBlockSize, _documents, _property_table.getRoot());

        
        BlockAllocationTableWriter bat        =
            new BlockAllocationTableWriter(bigBlockSize);

        
        
        List<Object> bm_objects = new ArrayList<Object>();

        bm_objects.addAll(_documents);
        bm_objects.add(_property_table);
        bm_objects.add(sbtw);
        bm_objects.add(sbtw.getSBAT());

        
        
        Iterator<Object> iter = bm_objects.iterator();

        while (iter.hasNext())
        {
            BATManaged bmo         = ( BATManaged ) iter.next();
            int        block_count = bmo.countBlocks();

            if (block_count != 0)
            {
                bmo.setStartBlock(bat.allocateSpace(block_count));
            }
            else
            {

                
                
                
            }
        }

        
        
        int               batStartBlock       = bat.createBlocks();

        
        HeaderBlockWriter header_block_writer = new HeaderBlockWriter(bigBlockSize);
        BATBlock[]        xbat_blocks         =
            header_block_writer.setBATBlocks(bat.countBlocks(),
                                             batStartBlock);

        
        header_block_writer.setPropertyStart(_property_table.getStartBlock());

        
        header_block_writer.setSBATStart(sbtw.getSBAT().getStartBlock());

        
        header_block_writer.setSBATBlockCount(sbtw.getSBATBlockCount());

        
        
        
        
        
        List<Object> writers = new ArrayList<Object>();

        writers.add(header_block_writer);
        writers.addAll(_documents);
        writers.add(_property_table);
        writers.add(sbtw);
        writers.add(sbtw.getSBAT());
        writers.add(bat);
        for (int j = 0; j < xbat_blocks.length; j++)
        {
            writers.add(xbat_blocks[ j ]);
        }

        
        iter = writers.iterator();
        while (iter.hasNext())
        {
            BlockWritable writer = ( BlockWritable ) iter.next();

            writer.writeBlocks(stream);
        }
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length != 2)
        {
            System.err.println(
                "two arguments required: input filename and output filename");
            System.exit(1);
        }
        FileInputStream  istream = new FileInputStream(args[ 0 ]);
        FileOutputStream ostream = new FileOutputStream(args[ 1 ]);

        new OPOIFSFileSystem(istream).writeFilesystem(ostream);
        istream.close();
        ostream.close();
    }

    

    public DirectoryNode getRoot()
    {
        if (_root == null)
        {
            _root = new DirectoryNode(_property_table.getRoot(), this, null);
        }
        return _root;
    }

    

    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
    	return getRoot().createDocumentInputStream(documentName);
    }

    

    void addDocument(final OPOIFSDocument document)
    {
        _documents.add(document);
        _property_table.addProperty(document.getDocumentProperty());
    }

    

    void addDirectory(final DirectoryProperty directory)
    {
        _property_table.addProperty(directory);
    }

    

    void remove(EntryNode entry)
    {
        _property_table.removeProperty(entry.getProperty());
        if (entry.isDocumentEntry())
        {
            _documents.remove((( DocumentNode ) entry).getDocument());
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator<Property> properties,
                                   final DirectoryNode dir,
                                   final int headerPropertiesStartAt)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property      property = properties.next();
            String        name     = property.getName();
            DirectoryNode parent   = (dir == null)
                                     ? (( DirectoryNode ) getRoot())
                                     : dir;

            if (property.isDirectory())
            {
                DirectoryNode new_dir =
                    ( DirectoryNode ) parent.createDirectory(name);

                new_dir.setStorageClsid( property.getStorageClsid() );

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(),
                    new_dir, headerPropertiesStartAt);
            }
            else
            {
                int           startBlock = property.getStartBlock();
                int           size       = property.getSize();
                OPOIFSDocument document  = null;

                if (property.shouldUseSmallBlocks())
                {
                    document =
                        new OPOIFSDocument(name,
                                           small_blocks.fetchBlocks(startBlock, headerPropertiesStartAt),
                                           size);
                }
                else
                {
                    document =
                        new OPOIFSDocument(name,
                                           big_blocks.fetchBlocks(startBlock, headerPropertiesStartAt),
                                           size);
                }
                parent.createDocument(document);
            }
        }
    }

    

    

    public Object [] getViewableArray()
    {
        if (preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableArray();
        }
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        if (!preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableIterator();
        }
        return Collections.emptyList().iterator();
    }

    

    public boolean preferArray()
    {
        return (( POIFSViewable ) getRoot()).preferArray();
    }

    

    public String getShortDescription()
    {
        return "POIFS FileSystem";
    }

    
    public int getBigBlockSize() {
    	return bigBlockSize.getBigBlockSize();
    }
    
    public POIFSBigBlockSize getBigBlockSizeDetails() {
      return bigBlockSize;
    }

    
}   


<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.docx4j.org.apache.poi.hpsf.ClassID;


public class FilteringDirectoryNode implements DirectoryEntry
{
   
   private Set<String> excludes;
   
   private Map<String,List<String>> childExcludes;
   
   private DirectoryEntry directory;
   
   
   public FilteringDirectoryNode(DirectoryEntry directory, Collection<String> excludes) {
      this.directory = directory;
      
      
      this.excludes = new HashSet<String>();
      this.childExcludes = new HashMap<String, List<String>>();
      for (String excl : excludes) {
         int splitAt = excl.indexOf('/');
         if (splitAt == -1) {
            
            this.excludes.add(excl);
         } else {
            
            String child = excl.substring(0, splitAt);
            String childExcl = excl.substring(splitAt+1);
            if (! this.childExcludes.containsKey(child)) {
               this.childExcludes.put(child, new ArrayList<String>());
            }
            this.childExcludes.get(child).add(childExcl);
         }
      }
   }

   public DirectoryEntry createDirectory(String name) throws IOException {
      return directory.createDirectory(name);
   }

   public DocumentEntry createDocument(String name, InputStream stream)
         throws IOException {
      return directory.createDocument(name, stream);
   }

   public DocumentEntry createDocument(String name, int size,
         POIFSWriterListener writer) throws IOException {
      return directory.createDocument(name, size, writer);
   }

   public Iterator<Entry> getEntries() {
      return new FilteringIterator();
   }

   public Iterator<Entry> iterator() {
      return getEntries();
   }
   
   public int getEntryCount() {
      int size = directory.getEntryCount();
      for (String excl : excludes) {
         if (directory.hasEntry(excl)) {
            size--;
         }
      }
      return size;
   }
   
   public Set<String> getEntryNames() {
       Set<String> names = new HashSet<String>();
       for (String name : directory.getEntryNames()) {
           if (!excludes.contains(name)) {
               names.add(name);
           }
       }
       return names;
   }

   public boolean isEmpty() {
      return (getEntryCount() == 0);
   }

   public boolean hasEntry(String name) {
      if (excludes.contains(name)) {
         return false;
      }
      return directory.hasEntry(name);
   }

   public Entry getEntry(String name) throws FileNotFoundException {
      if (excludes.contains(name)) {
         throw new FileNotFoundException(name);
      }
      
      Entry entry = directory.getEntry(name);
      return wrapEntry(entry);
   }
   private Entry wrapEntry(Entry entry) {
      String name = entry.getName();
      if (childExcludes.containsKey(name) && entry instanceof DirectoryEntry) {
         return new FilteringDirectoryNode(
               (DirectoryEntry)entry, childExcludes.get(name)); 
      }
      return entry;
   }

   public ClassID getStorageClsid() {
      return directory.getStorageClsid();
   }

   public void setStorageClsid(ClassID clsidStorage) {
      directory.setStorageClsid(clsidStorage);
   }

   public boolean delete() {
      return directory.delete();
   }

   public boolean renameTo(String newName) {
      return directory.renameTo(newName);
   }
   
   public String getName() {
      return directory.getName();
   }

   public DirectoryEntry getParent() {
      return directory.getParent();
   }

   public boolean isDirectoryEntry() {
      return true;
   }

   public boolean isDocumentEntry() {
      return false;
   }
   
   private class FilteringIterator implements Iterator<Entry> {
      private Iterator<Entry> parent;
      private Entry next;
      
      private FilteringIterator() {
         parent = directory.getEntries();
         locateNext();
      }
      private void locateNext() {
         next = null;
         Entry e;
         while (parent.hasNext() && next == null) {
            e = parent.next();
            if (! excludes.contains(e.getName())) {
               next = wrapEntry(e);
            }
         }
      }
      
      public boolean hasNext() {
         return (next != null);
      }
      
      public Entry next() {
         Entry e = next;
         locateNext();
         return e;
      }
      
      public void remove() {
         throw new UnsupportedOperationException("Remove not supported");
      }
   }
}
<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;

import org.docx4j.org.apache.poi.poifs.property.Property;



public abstract class EntryNode
    implements Entry
{

    
    private Property      _property;

    
    private DirectoryNode _parent;

    

    protected EntryNode(final Property property, final DirectoryNode parent)
    {
        _property = property;
        _parent   = parent;
    }

    

    protected Property getProperty()
    {
        return _property;
    }

    

    protected boolean isRoot()
    {

        
        return (_parent == null);
    }

    

    protected abstract boolean isDeleteOK();

    

    

    public String getName()
    {
        return _property.getName();
    }

    

    public boolean isDirectoryEntry()
    {
        return false;
    }

    

    public boolean isDocumentEntry()
    {
        return false;
    }

    

    public DirectoryEntry getParent()
    {
        return _parent;
    }

    

    public boolean delete()
    {
        boolean rval = false;

        if ((!isRoot()) && isDeleteOK())
        {
            rval = _parent.deleteEntry(this);
        }
        return rval;
    }

    

    public boolean renameTo(final String newName)
    {
        boolean rval = false;

        if (!isRoot())
        {
            rval = _parent.changeName(getName(), newName);
        }
        return rval;
    }

    
}   


<code block>




package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;

import org.docx4j.org.apache.poi.hpsf.ClassID;



public interface DirectoryEntry
    extends Entry, Iterable<Entry>
{

    

    public Iterator<Entry> getEntries();
    
    
    public Set<String> getEntryNames();

    

    public boolean isEmpty();

    

    public int getEntryCount();

    

    public boolean hasEntry( final String name );

    

    public Entry getEntry(final String name)
        throws FileNotFoundException;

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException;

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException;

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException;

    
    public ClassID getStorageClsid();

    
    public void setStorageClsid(ClassID clsidStorage);

}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.filesystem;



public interface Entry
{

    

    public String getName();

    

    public boolean isDirectoryEntry();

    

    public boolean isDocumentEntry();

    

    public DirectoryEntry getParent();

    

    public boolean delete();

    

    public boolean renameTo(final String newName);
}   


<code block>


package org.docx4j.org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;



public final class DocumentOutputStream extends OutputStream {
    private final OutputStream _stream;
    private final int          _limit;
    private int          _written;

    
    DocumentOutputStream(OutputStream stream, int limit) {
        _stream  = stream;
        _limit   = limit;
        _written = 0;
    }

    
    public void write(int b)
        throws IOException
    {
        limitCheck(1);
        _stream.write(b);
    }

    
    public void write(byte b[])
        throws IOException
    {
        write(b, 0, b.length);
    }

    
    public void write(byte b[], int off, int len)
        throws IOException
    {
        limitCheck(len);
        _stream.write(b, off, len);
    }

    
    public void flush()
        throws IOException
    {
        _stream.flush();
    }

    
    public void close() {

        
    }

    
    void writeFiller(int totalLimit, byte fill)
        throws IOException
    {
        if (totalLimit > _written)
        {
            byte[] filler = new byte[ totalLimit - _written ];

            Arrays.fill(filler, fill);
            _stream.write(filler);
        }
    }

    private void limitCheck(int toBeWritten)
        throws IOException
    {
        if ((_written + toBeWritten) > _limit)
        {
            throw new IOException("tried to write too much data");
        }
        _written += toBeWritten;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.BATManaged;
import org.docx4j.org.apache.poi.util.IntList;


public final class BlockAllocationTableWriter implements BlockWritable, BATManaged {
    private IntList    _entries;
    private BATBlock[] _blocks;
    private int        _start_block;
    private POIFSBigBlockSize _bigBlockSize;

    
    public BlockAllocationTableWriter(POIFSBigBlockSize bigBlockSize)
    {
       _bigBlockSize = bigBlockSize; 
        _start_block  = POIFSConstants.END_OF_CHAIN;
        _entries      = new IntList();
        _blocks       = new BATBlock[ 0 ];
    }

    
    public int createBlocks()
    {
        int xbat_blocks = 0;
        int bat_blocks  = 0;

        while (true)
        {
            int calculated_bat_blocks  =
                BATBlock.calculateStorageRequirements(_bigBlockSize,
                                                      bat_blocks
                                                      + xbat_blocks
                                                      + _entries.size());
            int calculated_xbat_blocks =
                HeaderBlockWriter.calculateXBATStorageRequirements(
                      _bigBlockSize, calculated_bat_blocks);

            if ((bat_blocks == calculated_bat_blocks)
                    && (xbat_blocks == calculated_xbat_blocks))
            {

                
                break;
            }
            bat_blocks  = calculated_bat_blocks;
            xbat_blocks = calculated_xbat_blocks;
        }
        int startBlock = allocateSpace(bat_blocks);

        allocateSpace(xbat_blocks);
        simpleCreateBlocks();
        return startBlock;
    }

    
    public int allocateSpace(final int blockCount)
    {
        int startBlock = _entries.size();

        if (blockCount > 0)
        {
            int limit = blockCount - 1;
            int index = startBlock + 1;

            for (int k = 0; k < limit; k++)
            {
                _entries.add(index++);
            }
            _entries.add(POIFSConstants.END_OF_CHAIN);
        }
        return startBlock;
    }

    
    public int getStartBlock()
    {
        return _start_block;
    }

    
    void simpleCreateBlocks()
    {
        _blocks = BATBlock.createBATBlocks(_bigBlockSize, _entries.toArray());
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (int j = 0; j < _blocks.length; j++)
        {
            _blocks[ j ].writeBlocks(stream);
        }
    }
    
    
    public static void writeBlock(final BATBlock bat, final ByteBuffer block) 
        throws IOException
    {
        bat.writeData(block);
    }

    
    public int countBlocks()
    {
        return _blocks.length;
    }

    
    public void setStartBlock(int start_block)
    {
        _start_block = start_block;
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;



public interface ListManagedBlock
{

    

    public byte [] getData()
        throws IOException;
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.BATManaged;
import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.docx4j.org.apache.poi.poifs.property.RootProperty;

import java.util.*;
import java.io.*;



public class SmallBlockTableWriter
    implements BlockWritable, BATManaged
{
    private BlockAllocationTableWriter _sbat;
    private List<SmallDocumentBlock>   _small_blocks;
    private int                        _big_block_count;
    private RootProperty               _root;

    
    public SmallBlockTableWriter(final POIFSBigBlockSize bigBlockSize,
                                 final List<OPOIFSDocument> documents,
                                 final RootProperty root)
    {
        _sbat         = new BlockAllocationTableWriter(bigBlockSize);
        _small_blocks = new ArrayList<SmallDocumentBlock>();
        _root         = root;

        for (OPOIFSDocument doc : documents)
        {
            SmallDocumentBlock[] blocks = doc.getSmallBlocks();

            if (blocks.length != 0)
            {
                doc.setStartBlock(_sbat.allocateSpace(blocks.length));
                for (int j = 0; j < blocks.length; j++)
                {
                    _small_blocks.add(blocks[ j ]);
                }
            } else {
            	doc.setStartBlock(POIFSConstants.END_OF_CHAIN);
            }
        }
        _sbat.simpleCreateBlocks();
        _root.setSize(_small_blocks.size());
        _big_block_count = SmallDocumentBlock.fill(bigBlockSize,_small_blocks);
    }

    
    
    public int getSBATBlockCount()
    {
	return (_big_block_count + 15) / 16;
    }

    

    public BlockAllocationTableWriter getSBAT()
    {
        return _sbat;
    }

    

    

    public int countBlocks()
    {
        return _big_block_count;
    }

    

    public void setStartBlock(int start_block)
    {
        _root.setStartBlock(start_block);
    }

    
    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (BlockWritable block : _small_blocks) {
            block.writeBlocks(stream);
        }
    }

    
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;



public interface BlockWritable
{

    

    public void writeBlocks(final OutputStream stream)
        throws IOException;
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;


public interface HeaderBlockConstants
{
    public static final long _signature               = 0xE11AB1A1E011CFD0L;
    public static final int  _bat_array_offset        = 0x4c;
    public static final int  _max_bats_in_header      =
        (POIFSConstants.SMALLER_BIG_BLOCK_SIZE - _bat_array_offset)
        / LittleEndianConsts.INT_SIZE; 

    
    
    
    
    
    
    public static final int  _signature_offset        = 0;
    public static final int  _bat_count_offset        = 0x2C;
    public static final int  _property_start_offset   = 0x30;
    public static final int  _sbat_start_offset       = 0x3C;
    public static final int  _sbat_block_count_offset = 0x40;
    public static final int  _xbat_start_offset       = 0x44;
    public static final int  _xbat_count_offset       = 0x48;
}   


<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;



public interface BlockList
{

    

    public void zap(final int index);

    

    public ListManagedBlock remove(final int index)
        throws IOException;

    

    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException;

    

    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException;
    
    public int blockCount();
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.property.RootProperty;


public final class SmallBlockTableReader {
    private static BlockList prepareSmallDocumentBlocks(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
        
        ListManagedBlock [] smallBlockBlocks = 
                blockList.fetchBlocks(root.getStartBlock(), -1);
        
       
        BlockList list =new SmallDocumentBlockList(
                SmallDocumentBlock.extract(bigBlockSize, smallBlockBlocks));

        return list;
    }
    private static BlockAllocationTableReader prepareReader(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final BlockList list, 
            final RootProperty root, final int sbatStart)
        throws IOException
    {
        
        return new BlockAllocationTableReader(bigBlockSize,
                blockList.fetchBlocks(sbatStart, -1),
                list);
    }
            
    
    public static BlockAllocationTableReader _getSmallDocumentBlockReader(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
       BlockList list = prepareSmallDocumentBlocks(
                bigBlockSize, blockList, root, sbatStart);
        return prepareReader(
                bigBlockSize, blockList, list, root, sbatStart);
    }

    
    public static BlockList getSmallDocumentBlocks(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
        BlockList list = prepareSmallDocumentBlocks(
                bigBlockSize, blockList, root, sbatStart);
        prepareReader(bigBlockSize, blockList, list, root, sbatStart);
        return list;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.storage;


public final class DataInputBlock {

	
	private final byte[] _buf;
	private int _readIndex;
	private int _maxIndex;

	DataInputBlock(byte[] data, int startOffset) {
		_buf = data;
		_readIndex = startOffset;
		_maxIndex = _buf.length;
	}
	public int available() {
		return _maxIndex-_readIndex;
	}

	public int readUByte() {
		return _buf[_readIndex++] & 0xFF;
	}

	
	public int readUShortLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b1 << 8) + (b0 << 0);
	}

	
	public int readUShortLE(DataInputBlock prevBlock) {
		
		int i = prevBlock._buf.length-1;
		
		int b0 = prevBlock._buf[i++] & 0xFF;
		int b1 = _buf[_readIndex++] & 0xFF;
		return (b1 << 8) + (b0 << 0);
	}

	
	public int readIntLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	
	public int readIntLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[4];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	
	public long readLongLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		int b4 = _buf[i++] & 0xFF;
		int b5 = _buf[i++] & 0xFF;
		int b6 = _buf[i++] & 0xFF;
		int b7 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	
	public long readLongLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[8];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		int b4 = buf[4] & 0xFF;
		int b5 = buf[5] & 0xFF;
		int b6 = buf[6] & 0xFF;
		int b7 = buf[7] & 0xFF;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	
	private void readSpanning(DataInputBlock prevBlock, int prevBlockAvailable, byte[] buf) {
		System.arraycopy(prevBlock._buf, prevBlock._readIndex, buf, 0, prevBlockAvailable);
		int secondReadLen = buf.length-prevBlockAvailable;
		System.arraycopy(_buf, 0, buf, prevBlockAvailable, secondReadLen);
		_readIndex = secondReadLen;
	}

	
	public void readFully(byte[] buf, int off, int len) {
		System.arraycopy(_buf, _readIndex, buf, off, len);
		_readIndex += len;
	}
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;


public class HeaderBlockWriter implements HeaderBlockConstants, BlockWritable
{
   private final HeaderBlock _header_block;

    
    public HeaderBlockWriter(POIFSBigBlockSize bigBlockSize)
    {
       _header_block = new HeaderBlock(bigBlockSize);
    }

    
    public HeaderBlockWriter(HeaderBlock headerBlock)
    {
       _header_block = headerBlock;
    }

    

    public BATBlock [] setBATBlocks(final int blockCount,
                                    final int startBlock)
    {
        BATBlock[] rvalue;
        POIFSBigBlockSize bigBlockSize = _header_block.getBigBlockSize();

        _header_block.setBATCount(blockCount);

        
        int limit  = Math.min(blockCount, _max_bats_in_header);
        int[] bat_blocks = new int[limit];
        for (int j = 0; j < limit; j++) {
           bat_blocks[j] = startBlock + j;
        }
        _header_block.setBATArray(bat_blocks);
        
        
        if (blockCount > _max_bats_in_header)
        {
            int   excess_blocks      = blockCount - _max_bats_in_header;
            int[] excess_block_array = new int[ excess_blocks ];

            for (int j = 0; j < excess_blocks; j++)
            {
                excess_block_array[ j ] = startBlock + j
                                          + _max_bats_in_header;
            }
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, excess_block_array,
                                               startBlock + blockCount);
            _header_block.setXBATStart(startBlock + blockCount);
        }
        else
        {
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, new int[ 0 ], 0);
            _header_block.setXBATStart(POIFSConstants.END_OF_CHAIN);
        }
        _header_block.setXBATCount(rvalue.length);
        return rvalue;
    }

    
    public void setPropertyStart(final int startBlock)
    {
       _header_block.setPropertyStart(startBlock);
    }

    
    public void setSBATStart(final int startBlock)
    {
        _header_block.setSBATStart(startBlock);
    }

    
    public void setSBATBlockCount(final int count)
    {
       _header_block.setSBATBlockCount(count);
    }

    

    static int calculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize, final int blockCount)
    {
        return (blockCount > _max_bats_in_header)
               ? BATBlock.calculateXBATStorageRequirements(
                     bigBlockSize, blockCount - _max_bats_in_header)
               : 0;
    }

    

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        _header_block.writeData(stream);
    }
    
    
    public void writeBlock(ByteBuffer block)
        throws IOException
    {
       ByteArrayOutputStream baos = new ByteArrayOutputStream(
             _header_block.getBigBlockSize().getBigBlockSize()
       );
       _header_block.writeData(baos);
       
       block.put(baos.toByteArray());
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;



import org.docx4j.org.apache.poi.hssf.OldExcelFormatException;
import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.poifs.filesystem.NotOLE2FileException;
import org.docx4j.org.apache.poi.poifs.filesystem.OfficeXmlFileException;
import org.docx4j.org.apache.poi.util.HexDump;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.IntegerField;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.LongField;
import org.docx4j.org.apache.poi.util.ShortField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class HeaderBlock implements HeaderBlockConstants {
	
	private static Logger _logger = LoggerFactory.getLogger(HeaderBlock.class);
	


   
	
	private final POIFSBigBlockSize bigBlockSize;

	
	private int _bat_count;

	
	private int _property_start;

	
	private int _sbat_start;
	
	private int _sbat_count;

	
	private int _xbat_start;
	
	private int _xbat_count;
	
	
	private final byte[] _data;
	
   private static final byte _default_value = ( byte ) 0xFF;

	
	public HeaderBlock(InputStream stream) throws IOException {
		
	   
		
		this(readFirst512(stream));
		
		
		if(bigBlockSize.getBigBlockSize() != 512) {
		   int rest = bigBlockSize.getBigBlockSize() - 512;
		   byte[] tmp = new byte[rest];
		   IOUtils.readFully(stream, tmp);
		}
	}
	
	public HeaderBlock(ByteBuffer buffer) throws IOException {
	   this(IOUtils.toByteArray(buffer, POIFSConstants.SMALLER_BIG_BLOCK_SIZE));
	}
	
	private HeaderBlock(byte[] data) throws IOException {
	   this._data = data;
	   
		
		long signature = LittleEndian.getLong(_data, _signature_offset);

		if (signature != _signature) {
			
			byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;
			if (_data[0] == OOXML_FILE_HEADER[0] &&
				_data[1] == OOXML_FILE_HEADER[1] &&
				_data[2] == OOXML_FILE_HEADER[2] &&
				_data[3] == OOXML_FILE_HEADER[3]) {
				throw new OfficeXmlFileException("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");
			}
			
            if (_data[0] == 0x09 && _data[1] == 0x00 && 
                _data[2] == 0x04 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00 && 
               (_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                _data[7] == 0x00) {
                
                throw new OldExcelFormatException("The supplied data appears to be in BIFF2 format. " +
                        "HSSF only supports the BIFF8 format, try OldExcelExtractor");
            }
            if (_data[0] == 0x09 && _data[1] == 0x02 && 
                _data[2] == 0x06 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00 && 
               (_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                _data[7] == 0x00) {
                
                throw new OldExcelFormatException("The supplied data appears to be in BIFF3 format. " +
                        "HSSF only supports the BIFF8 format, try OldExcelExtractor");
            }
            if (_data[0] == 0x09 && _data[1] == 0x04 && 
                _data[2] == 0x06 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00) { 
                if (((_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                      _data[7] == 0x00) ||
                    (_data[6] == 0x00 && _data[7] == 0x01)) {
                    
                    throw new OldExcelFormatException("The supplied data appears to be in BIFF4 format. " +
                            "HSSF only supports the BIFF8 format, try OldExcelExtractor");
                }
            }

			
			throw new NotOLE2FileException("Invalid header signature; read "
				                  + longToHex(signature) + ", expected "
				                  + longToHex(_signature) + " - Your file appears "
				                  + "not to be a valid OLE2 document");
		}


		
		if (_data[30] == 12) {
			this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;
		} else if(_data[30] == 9) {
			this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   throw new IOException("Unsupported blocksize  (2^"+ _data[30] + "). Expected 2^9 or 2^12.");
		}

	   
      _bat_count      = new IntegerField(_bat_count_offset, data).get();
      _property_start = new IntegerField(_property_start_offset,_data).get();
      _sbat_start = new IntegerField(_sbat_start_offset, _data).get();
      _sbat_count = new IntegerField(_sbat_block_count_offset, _data).get();
      _xbat_start = new IntegerField(_xbat_start_offset, _data).get();
      _xbat_count = new IntegerField(_xbat_count_offset, _data).get();
	}
	
   
   public HeaderBlock(POIFSBigBlockSize bigBlockSize)
   {
      this.bigBlockSize = bigBlockSize;

      
      _data = new byte[ POIFSConstants.SMALLER_BIG_BLOCK_SIZE ];
      Arrays.fill(_data, _default_value);
      
      
      new LongField(_signature_offset, _signature, _data);
      new IntegerField(0x08, 0, _data);
      new IntegerField(0x0c, 0, _data);
      new IntegerField(0x10, 0, _data);
      new IntegerField(0x14, 0, _data);
      new ShortField(0x18, ( short ) 0x3b, _data);
      new ShortField(0x1a, ( short ) 0x3, _data);
      new ShortField(0x1c, ( short ) -2, _data);
       
      new ShortField(0x1e, bigBlockSize.getHeaderValue(), _data);
      new IntegerField(0x20, 0x6, _data);
      new IntegerField(0x24, 0, _data);
      new IntegerField(0x28, 0, _data);
      new IntegerField(0x34, 0, _data);
      new IntegerField(0x38, 0x1000, _data);
      
      
      _bat_count = 0;
      _sbat_count = 0;
      _xbat_count = 0;
      _property_start = POIFSConstants.END_OF_CHAIN;
      _sbat_start = POIFSConstants.END_OF_CHAIN;
      _xbat_start = POIFSConstants.END_OF_CHAIN;
   }
   
	private static byte[] readFirst512(InputStream stream) throws IOException {
      
      
      byte[] data = new byte[512];
      int bsCount = IOUtils.readFully(stream, data);
      if(bsCount != 512) {
         throw alertShortRead(bsCount, 512);
      }
      return data;
	}

	private static String longToHex(long value) {
		return new String(HexDump.longToHex(value));
	}

	private static IOException alertShortRead(int pRead, int expectedReadSize) {
		int read;
		if (pRead < 0) {
			
			read = 0;
		} else {
			read = pRead;
		}
		String type = " byte" + (read == 1 ? (""): ("s"));

		return new IOException("Unable to read entire header; "
				+ read + type + " read; expected "
				+ expectedReadSize + " bytes");
	}

	
	public int getPropertyStart() {
		return _property_start;
	}
   
   public void setPropertyStart(final int startBlock) {
       _property_start = startBlock;
   }

	
	public int getSBATStart() {
		return _sbat_start;
	}
	public int getSBATCount() {
	   return _sbat_count;
	}
	
   
   public void setSBATStart(final int startBlock) {
       _sbat_start = startBlock;
   }
   
   public void setSBATBlockCount(final int count)
   {
      _sbat_count = count;
   }

	
	public int getBATCount() {
		return _bat_count;
	}
   
   public void setBATCount(final int count) {
      _bat_count = count;
   }

	
	public int[] getBATArray() {
      
		int[] result = new int[ Math.min(_bat_count,_max_bats_in_header) ];
		int offset = _bat_array_offset;
		for (int j = 0; j < result.length; j++) {
			result[ j ] = LittleEndian.getInt(_data, offset);
			offset     += LittleEndianConsts.INT_SIZE;
		}
		return result;
	}
	
	public void setBATArray(int[] bat_array) {
	   int count = Math.min(bat_array.length, _max_bats_in_header);
	   int blank = _max_bats_in_header - count;
	   
      int offset = _bat_array_offset;
	   for(int i=0; i<count; i++) {
	      LittleEndian.putInt(_data, offset, bat_array[i]);
         offset += LittleEndianConsts.INT_SIZE;
	   }
	   for(int i=0; i<blank; i++) {
         LittleEndian.putInt(_data, offset, POIFSConstants.UNUSED_BLOCK);
         offset += LittleEndianConsts.INT_SIZE;
	   }
	}

	
	public int getXBATCount() {
		return _xbat_count;
	}
	
	public void setXBATCount(final int count) {
	   _xbat_count = count;
	}

	
	public int getXBATIndex() {
		return _xbat_start;
	}
	
   public void setXBATStart(final int startBlock) {
      _xbat_start = startBlock;
  }

	
	public POIFSBigBlockSize getBigBlockSize() {
		return bigBlockSize;
	}
	
   
   void writeData(final OutputStream stream)
       throws IOException
   {
      
      new IntegerField(_bat_count_offset,      _bat_count, _data);
      new IntegerField(_property_start_offset, _property_start, _data);
      new IntegerField(_sbat_start_offset,     _sbat_start, _data);
      new IntegerField(_sbat_block_count_offset, _sbat_count, _data);
      new IntegerField(_xbat_start_offset,      _xbat_start, _data);
      new IntegerField(_xbat_count_offset,      _xbat_count, _data);
      
      
      stream.write(_data, 0, 512);
      
      
      for(int i=POIFSConstants.SMALLER_BIG_BLOCK_SIZE; i<bigBlockSize.getBigBlockSize(); i++) {
         stream.write(0);
      }
   }
}

<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.util.IOUtils;


public final class DocumentBlock extends BigBlock {
    private static final byte _default_value = ( byte ) 0xFF;
    private byte[]            _data;
    private int               _bytes_read;

    

    public DocumentBlock(final RawDataBlock block)
        throws IOException
    {
        super(
              block.getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
                    POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS :
                    POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
        );
        _data       = block.getData();
        _bytes_read = _data.length;
    }

    

    public DocumentBlock(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        this(bigBlockSize);
        int count = IOUtils.readFully(stream, _data);

        _bytes_read = (count == -1) ? 0
                                    : count;
    }

    

    private DocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        _data = new byte[ bigBlockSize.getBigBlockSize() ];
        Arrays.fill(_data, _default_value);
    }

    

    public int size()
    {
        return _bytes_read;
    }

    

    public boolean partiallyRead()
    {
        return _bytes_read != bigBlockSize.getBigBlockSize();
    }

    

    public static byte getFillByte()
    {
        return _default_value;
    }

    

    public static DocumentBlock [] convert(final POIFSBigBlockSize bigBlockSize,
                                           final byte [] array,
                                           final int size)
    {
        DocumentBlock[] rval   =
            new DocumentBlock[ (size + bigBlockSize.getBigBlockSize() - 1) / bigBlockSize.getBigBlockSize() ];
        int             offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new DocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(bigBlockSize.getBigBlockSize(),
                                      array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != bigBlockSize.getBigBlockSize())
                {
                    Arrays.fill(rval[ k ]._data, length,
                          bigBlockSize.getBigBlockSize(),
                                _default_value);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_value);
            }
            offset += bigBlockSize.getBigBlockSize();
        }
        return rval;
    }

    public static DataInputBlock getDataInputBlock(DocumentBlock[] blocks, int offset) {
        if(blocks == null || blocks.length == 0) {
           return null;
        }
        
        
        POIFSBigBlockSize bigBlockSize = blocks[0].bigBlockSize;
        int BLOCK_SHIFT = bigBlockSize.getHeaderValue();
        int BLOCK_SIZE = bigBlockSize.getBigBlockSize();
        int BLOCK_MASK = BLOCK_SIZE - 1;

        
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.util.*;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class BlockAllocationTableReader {

	private static Logger _logger = LoggerFactory.getLogger(BlockAllocationTableReader.class);

    
    private static final int MAX_BLOCK_COUNT = 65535;
    private final IntList _entries;
    private POIFSBigBlockSize bigBlockSize;

    
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, int block_count, int [] block_array,
            int xbat_count, int xbat_index, BlockList raw_block_list) throws IOException {
        this(bigBlockSize);
        
        sanityCheckBlockCount(block_count);

        
        
        
        
        
        
        int          limit    = Math.min(block_count, block_array.length);
        int          block_index;
        
        
        RawDataBlock blocks[] = new RawDataBlock[ block_count ];

        
        for (block_index = 0; block_index < limit; block_index++)
        {
            
            int nextOffset = block_array[ block_index ];
            if(nextOffset > raw_block_list.blockCount()) {
               throw new IOException("Your file contains " + raw_block_list.blockCount() + 
                     " sectors, but the initial DIFAT array at index " + block_index +
                     " referenced block # " + nextOffset + ". This isn't allowed and " +
                     " your file is corrupt");
            }
            
            blocks[ block_index ] =
                ( RawDataBlock ) raw_block_list.remove(nextOffset);
        }
        
        
        if (block_index < block_count)
        {

            
            if (xbat_index < 0)
            {
                throw new IOException(
                    "BAT count exceeds limit, yet XBAT index indicates no valid entries");
            }
            int chain_index           = xbat_index;
            int max_entries_per_block = bigBlockSize.getXBATEntriesPerBlock(); 
            int chain_index_offset    = bigBlockSize.getNextXBATChainOffset(); 

            
            
            
            for (int j = 0; j < xbat_count; j++)
            {
                limit = Math.min(block_count - block_index,
                                 max_entries_per_block);
                byte[] data   = raw_block_list.remove(chain_index).getData();
                int    offset = 0;

                for (int k = 0; k < limit; k++)
                {
                    blocks[ block_index++ ] =
                        ( RawDataBlock ) raw_block_list
                            .remove(LittleEndian.getInt(data, offset));
                    offset                  += LittleEndianConsts.INT_SIZE;
                }
                chain_index = LittleEndian.getInt(data, chain_index_offset);
                if (chain_index == POIFSConstants.END_OF_CHAIN)
                {
                    break;
                }
            }
        }
        if (block_index != block_count)
        {
            throw new IOException("Could not find all blocks");
        }

        
        
        setEntries(blocks, raw_block_list);
    }

    
    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, BlockList raw_block_list)
            throws IOException {
        this(bigBlockSize);
        setEntries(blocks, raw_block_list);
    }

    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize) {
        this.bigBlockSize = bigBlockSize;
        _entries = new IntList();
    }
    
    public static void sanityCheckBlockCount(int block_count) throws IOException {
       if (block_count <= 0) {
          throw new IOException(
                "Illegal block count; minimum count is 1, got " + 
                block_count + " instead"
          );
       }
       if (block_count > MAX_BLOCK_COUNT) {
          throw new IOException(
                "Block count " + block_count + 
                " is too high. POI maximum is " + MAX_BLOCK_COUNT + "."
          );
       }
    }

    
    ListManagedBlock[] fetchBlocks(int startBlock, int headerPropertiesStartBlock,
            BlockList blockList) throws IOException {
        List<ListManagedBlock> blocks = new ArrayList<ListManagedBlock>();
        int  currentBlock = startBlock;
        boolean firstPass = true;
        ListManagedBlock dataBlock = null;

        
        
        
        
        while (currentBlock != POIFSConstants.END_OF_CHAIN) {
            try {
                
                dataBlock = blockList.remove(currentBlock);
                blocks.add(dataBlock);
                
                currentBlock = _entries.get(currentBlock);
                firstPass = false;
            } catch(IOException e) {
                if(currentBlock == headerPropertiesStartBlock) {
                    
                    _logger.warn("Warning, header block comes after data blocks in POIFS block listing");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else if(currentBlock == 0 && firstPass) {
                    
                    
                    _logger.warn("Warning, incorrectly terminated empty data blocks in POIFS block listing (should end at -2, ended at 0)");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else {
                    
                    throw e;
                }
            }
        }

        return blocks.toArray(new ListManagedBlock[blocks.size()]);
    }

    

    
    boolean isUsed(int index) {

        try {
            return _entries.get(index) != -1;
        } catch (IndexOutOfBoundsException e) {
            
            return false;
        }
    }

    
    int getNextBlockIndex(int index) throws IOException {
        if (isUsed(index)) {
            return _entries.get(index);
        }
        throw new IOException("index " + index + " is unused");
    }

    
    private void setEntries(ListManagedBlock[] blocks, BlockList raw_blocks) throws IOException {
        int limit = bigBlockSize.getBATEntriesPerBlock(); 

        for (int block_index = 0; block_index < blocks.length; block_index++)
        {
            byte[] data   = blocks[ block_index ].getData();
            int    offset = 0;

            for (int k = 0; k < limit; k++)
            {
                int entry = LittleEndian.getInt(data, offset);

                if (entry == POIFSConstants.UNUSED_BLOCK)
                {
                    raw_blocks.zap(_entries.size());
                }
                _entries.add(entry);
                offset += LittleEndianConsts.INT_SIZE;
            }

            
            blocks[ block_index ] = null;
        }
        raw_blocks.setBAT(this);
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.io.*;
import java.util.*;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;



public class RawDataBlockList
    extends BlockListImpl
{

    

    public RawDataBlockList(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        List<RawDataBlock> blocks = new ArrayList<RawDataBlock>();

        while (true)
        {
            RawDataBlock block = new RawDataBlock(stream, bigBlockSize.getBigBlockSize());
            
            
            if(block.hasData()) {
            	blocks.add(block);
            }

            
            if (block.eof()) {
                break;
            }
        }
        setBlocks( blocks.toArray(new RawDataBlock[ blocks.size() ]) );
    }
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.property.Property;


public final class PropertyBlock extends BigBlock {
    private Property[]       _properties;

    

    private PropertyBlock(final POIFSBigBlockSize bigBlockSize, final Property [] properties, final int offset)
    {
        super(bigBlockSize);
        
        _properties = new Property[ bigBlockSize.getPropertiesPerBlock() ]; 
        for (int j = 0; j < _properties.length; j++)
        {
            _properties[ j ] = properties[ j + offset ];
        }
    }

    

    public static BlockWritable [] createPropertyBlockArray(
            final POIFSBigBlockSize bigBlockSize, final List<Property> properties)
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        int        block_count   =
            (properties.size() + _properties_per_block - 1)
            / _properties_per_block;
        Property[] to_be_written =
            new Property[ block_count * _properties_per_block ];

        System.arraycopy(properties.toArray(new Property[ 0 ]), 0,
                         to_be_written, 0, properties.size());
        for (int j = properties.size(); j < to_be_written.length; j++)
        {

            
            
            to_be_written[ j ] = new Property()
            {
                protected void preWrite()
                {
                }

                public boolean isDirectory()
                {
                    return false;
                }
            };
        }
        BlockWritable[] rvalue = new BlockWritable[ block_count ];

        for (int j = 0; j < block_count; j++)
        {
            rvalue[ j ] = new PropertyBlock(bigBlockSize, to_be_written,
                                            j * _properties_per_block);
        }
        return rvalue;
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        for (int j = 0; j < _properties_per_block; j++)
        {
            _properties[ j ].writeData(stream);
        }
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;


abstract class BlockListImpl implements BlockList {
    private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    
    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    
    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    
    protected ListManagedBlock get(final int index) {
        return _blocks[index];
    }

    
    public ListManagedBlock remove(final int index)
        throws IOException
    {
        ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(
                		"block[ " + index + " ] already removed - " +
                		"does your POIFS have circular or duplicate block references?"
                );
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException("Cannot remove block[ " + index
                                  + " ]; out of range[ 0 - " +
                                  (_blocks.length-1) + " ]");
        }
        return result;
    }

    
    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                "Improperly initialized list: no block allocation table provided");
        }
        return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);
    }

    
    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                "Attempt to replace existing BlockAllocationTable");
        }
        _bat = bat;
    }
    
    
    public int blockCount() {
       return _blocks.length;
    }
    
    protected int remainingBlocks() {
       int c = 0;
       for(int i=0; i<_blocks.length; i++) {
          if(_blocks[i] != null) c++;
       }
       return c;
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.util.IOUtils;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;



public class RawDataBlock
    implements ListManagedBlock
{
    private byte[]  _data;
    private boolean _eof;
    private boolean _hasData;
    

	private static Logger log = LoggerFactory.getLogger(RawDataBlock.class);


    
    public RawDataBlock(final InputStream stream)
    		throws IOException {
    	this(stream, POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
    }
    
    public RawDataBlock(final InputStream stream, int blockSize)
    		throws IOException {
        _data = new byte[ blockSize ];
        int count = IOUtils.readFully(stream, _data);
        _hasData = (count > 0);

        if (count == -1) {
            _eof = true;
        }
        else if (count != blockSize) {
        	
        	
        	
            _eof = true;
            String type = " byte" + ((count == 1) ? ("")
                                                  : ("s"));

            log.error(
            		"Unable to read entire block; " + count
                     + type + " read before EOF; expected "
                     + blockSize + " bytes. Your document "
                     + "was either written by software that "
                     + "ignores the spec, or has been truncated!"
            );
        }
        else {
            _eof = false;
        }
    }

    
    public boolean eof() {
        return _eof;
    }
    
    public boolean hasData() {
    	return _hasData;
    }
    
    public String toString() {
       return "RawDataBlock of size " + _data.length; 
    }

    

    
    public byte [] getData()
        throws IOException
    {
        if (! hasData())
        {
            throw new IOException("Cannot return empty data");
        }
        return _data;
    }
    
    
    public int getBigBlockSize() {
       return _data.length;
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;
import org.docx4j.org.apache.poi.util.LittleEndian;


public final class BATBlock extends BigBlock {
    
    private int[] _values;
    
    
    private boolean _has_free_sectors;
    
    
    private int ourBlockIndex;
    
    
    private BATBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        _values = new int[_entries_per_block];
        _has_free_sectors = true;

        Arrays.fill(_values, POIFSConstants.UNUSED_BLOCK);
    }

    

    private BATBlock(POIFSBigBlockSize bigBlockSize, final int [] entries,
                     final int start_index, final int end_index)
    {
        this(bigBlockSize);
        for (int k = start_index; k < end_index; k++) {
           _values[k - start_index] = entries[k];
        }
        
        
        if(end_index - start_index == _values.length) {
           recomputeFree();
        }
    }
    
    private void recomputeFree() {
       boolean hasFree = false;
       for(int k=0; k<_values.length; k++) {
          if(_values[k] == POIFSConstants.UNUSED_BLOCK) {
             hasFree = true;
             break;
          }
       }
       _has_free_sectors = hasFree;
    }

    
    public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)
    {
       
       BATBlock block = new BATBlock(bigBlockSize);
       
       
       byte[] buffer = new byte[LittleEndian.INT_SIZE];
       for(int i=0; i<block._values.length; i++) {
          data.get(buffer);
          block._values[i] = LittleEndian.getInt(buffer);
       }
       block.recomputeFree();
       
       
       return block;
    }
    
    
    public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {
       BATBlock block = new BATBlock(bigBlockSize);
       if(isXBAT) {
          block.setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
       }
       return block;
    }

    
    public static BATBlock [] createBATBlocks(final POIFSBigBlockSize bigBlockSize, final int [] entries)
    {
        int        block_count = calculateStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        for (int j = 0; j < entries.length; j += _entries_per_block)
        {
            blocks[ index++ ] = new BATBlock(bigBlockSize, entries, j,
                                             (remaining > _entries_per_block)
                                             ? j + _entries_per_block
                                             : entries.length);
            remaining         -= _entries_per_block;
        }
        return blocks;
    }
    
    

    public static BATBlock [] createXBATBlocks(final POIFSBigBlockSize bigBlockSize,
                                               final int [] entries,
                                               final int startBlock)
    {
        int        block_count =
            calculateXBATStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        if (block_count != 0)
        {
            for (int j = 0; j < entries.length; j += _entries_per_xbat_block)
            {
                blocks[ index++ ] =
                    new BATBlock(bigBlockSize, entries, j,
                                 (remaining > _entries_per_xbat_block)
                                 ? j + _entries_per_xbat_block
                                 : entries.length);
                remaining         -= _entries_per_xbat_block;
            }
            for (index = 0; index < blocks.length - 1; index++)
            {
                blocks[ index ].setXBATChain(bigBlockSize, startBlock + index + 1);
            }
            blocks[ index ].setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
        }
        return blocks;
    }

    
    public static int calculateStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        return (entryCount + _entries_per_block - 1) / _entries_per_block;
    }

    
    public static int calculateXBATStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        return (entryCount + _entries_per_xbat_block - 1)
               / _entries_per_xbat_block;
    }
    
    
    public static long calculateMaximumSize(final POIFSBigBlockSize bigBlockSize,
          final int numBATs) {
       long size = 1; 
       
       
       
       
       size += (numBATs * bigBlockSize.getBATEntriesPerBlock());
       
       
       return size * bigBlockSize.getBigBlockSize();
    }
    public static long calculateMaximumSize(final HeaderBlock header)
    {
       return calculateMaximumSize(header.getBigBlockSize(), header.getBATCount());
    }

    
    public static BATBlockAndIndex getBATBlockAndIndex(final int offset, 
                final HeaderBlock header, final List<BATBlock> bats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       int whichBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, bats.get(whichBAT) );
    }
    
    
    public static BATBlockAndIndex getSBATBlockAndIndex(final int offset, 
          final HeaderBlock header, final List<BATBlock> sbats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       
       int whichSBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, sbats.get(whichSBAT) );
    }
    
    private void setXBATChain(final POIFSBigBlockSize bigBlockSize, int chainIndex)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        _values[ _entries_per_xbat_block ] = chainIndex;
    }
    
    
    public boolean hasFreeSectors() {
       return _has_free_sectors;
    }
    
    public int getUsedSectors(boolean isAnXBAT) {
        int usedSectors = 0;
        int toCheck = _values.length;
        if (isAnXBAT) toCheck--; 
        for(int k=0; k<toCheck; k++) {
            if(_values[k] != POIFSConstants.UNUSED_BLOCK) {
                usedSectors ++;
            }
        }
        return usedSectors;
    }
    
    public int getValueAt(int relativeOffset) {
       if(relativeOffset >= _values.length) {
          throw new ArrayIndexOutOfBoundsException(
                "Unable to fetch offset " + relativeOffset + " as the " + 
                "BAT only contains " + _values.length + " entries"
          ); 
       }
       return _values[relativeOffset];
    }
    public void setValueAt(int relativeOffset, int value) {
       int oldValue = _values[relativeOffset];
       _values[relativeOffset] = value;
       
       
       if(value == POIFSConstants.UNUSED_BLOCK) {
          _has_free_sectors = true;
          return;
       }
       if(oldValue == POIFSConstants.UNUSED_BLOCK) {
          recomputeFree();
       }
    }
    
    
    public void setOurBlockIndex(int index) {
       this.ourBlockIndex = index;
    }
    
    public int getOurBlockIndex() {
       return ourBlockIndex;
    }


    

   
    void writeData(final OutputStream stream)
        throws IOException
    {
       
       stream.write( serialize() );
    }
    
    void writeData(final ByteBuffer block)
        throws IOException
    {
       
       block.put( serialize() );
    }
    
    private byte[] serialize() {
       
       byte[] data = new byte[ bigBlockSize.getBigBlockSize() ];
       
       
       int offset = 0;
       for(int i=0; i<_values.length; i++) {
          LittleEndian.putInt(data, offset, _values[i]);
          offset += LittleEndian.INT_SIZE;
       }
       
       
       return data;
    }

    
    
    
    public static class BATBlockAndIndex {
       private final int index;
       private final BATBlock block;
       private BATBlockAndIndex(int index, BATBlock block) {
          this.index = index;
          this.block = block;
       }
       public int getIndex() {
          return index;
       }
       public BATBlock getBlock() {
          return block;
       }
    }
}


<code block>


package org.docx4j.org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;


public final class SmallDocumentBlock implements BlockWritable, ListManagedBlock {
    private static final int BLOCK_SHIFT = 6;

    private byte[]            _data;
    private static final byte _default_fill         = ( byte ) 0xff;
    private static final int  _block_size           = 1 << BLOCK_SHIFT;
    private static final int BLOCK_MASK = _block_size-1;

    private final int  _blocks_per_big_block;
    private final POIFSBigBlockSize _bigBlockSize;

    private SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize, final byte [] data, final int index)
    {
        this(bigBlockSize);
        System.arraycopy(data, index * _block_size, _data, 0, _block_size);
    }

    protected SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize)
    {
        _bigBlockSize = bigBlockSize;
        _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        _data = new byte[ _block_size ];
    }
    
    private static int getBlocksPerBigBlock(final POIFSBigBlockSize bigBlockSize)
    {
       return bigBlockSize.getBigBlockSize() / _block_size;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                byte [] array,
                                                int size)
    {
        SmallDocumentBlock[] rval   =
            new SmallDocumentBlock[ (size + _block_size - 1) / _block_size ];
        int                  offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new SmallDocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(_block_size, array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != _block_size)
                {
                    Arrays.fill(rval[ k ]._data, length, _block_size,
                                _default_fill);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_fill);
            }
            offset += _block_size;
        }
        return rval;
    }

    
    public static int fill(POIFSBigBlockSize bigBlockSize, List<SmallDocumentBlock> blocks)
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        int count           = blocks.size();
        int big_block_count = (count + _blocks_per_big_block - 1)
                              / _blocks_per_big_block;
        int full_count      = big_block_count * _blocks_per_big_block;

        for (; count < full_count; count++)
        {
            blocks.add(makeEmptySmallDocumentBlock(bigBlockSize));
        }
        return big_block_count;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                BlockWritable [] store,
                                                int size)
        throws IOException, ArrayIndexOutOfBoundsException
    {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();

        for (int j = 0; j < store.length; j++)
        {
            store[ j ].writeBlocks(stream);
        }
        byte[]               data = stream.toByteArray();
        SmallDocumentBlock[] rval =
            new SmallDocumentBlock[ convertToBlockCount(size) ];

        for (int index = 0; index < rval.length; index++)
        {
            rval[ index ] = new SmallDocumentBlock(bigBlockSize, data, index);
        }
        return rval;
    }

    
    public static List<SmallDocumentBlock> extract(POIFSBigBlockSize bigBlockSize, ListManagedBlock [] blocks)
        throws IOException
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        List<SmallDocumentBlock> sdbs = new ArrayList<SmallDocumentBlock>();

        for (int j = 0; j < blocks.length; j++)
        {
            byte[] data = blocks[ j ].getData();

            for (int k = 0; k < _blocks_per_big_block; k++)
            {
                sdbs.add(new SmallDocumentBlock(bigBlockSize, data, k));
            }
        }
        return sdbs;
    }

    public static DataInputBlock getDataInputBlock(SmallDocumentBlock[] blocks, int offset) {
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    
    public static int calcSize(int size)
    {
        return size * _block_size;
    }
    
    protected int getSmallBlocksPerBigBlock()
    {
        return _blocks_per_big_block;
    }

    private static SmallDocumentBlock makeEmptySmallDocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        SmallDocumentBlock block = new SmallDocumentBlock(bigBlockSize);

        Arrays.fill(block._data, _default_fill);
        return block;
    }

    private static int convertToBlockCount(int size)
    {
        return (size + _block_size - 1) / _block_size;
    }

    
    public void writeBlocks(OutputStream stream)
        throws IOException
    {
        stream.write(_data);
    }

    
    public byte [] getData() {
        return _data;
    }
    
    public POIFSBigBlockSize getBigBlockSize() {
       return _bigBlockSize;
    }
}

<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;

import java.util.*;


public class SmallDocumentBlockList
    extends BlockListImpl
{
    

    public SmallDocumentBlockList(final List<SmallDocumentBlock> blocks)
    {
        setBlocks(blocks.toArray(new SmallDocumentBlock[blocks.size()]));
    }
}


<code block>


        

package org.docx4j.org.apache.poi.poifs.storage;



import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.docx4j.org.apache.poi.poifs.common.POIFSConstants;

abstract class BigBlock
    implements BlockWritable
{
    
    protected POIFSBigBlockSize bigBlockSize;
    
    protected BigBlock(POIFSBigBlockSize bigBlockSize) {
       this.bigBlockSize = bigBlockSize;
    }

    

    protected void doWriteData(final OutputStream stream, final byte [] data)
        throws IOException
    {
        stream.write(data);
    }

    

    abstract void writeData(final OutputStream stream)
        throws IOException;

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        writeData(stream);
    }

    
}   


<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode.agile;
import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode.binaryRC4;
import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode.cryptoAPI;
import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode.standard;

import java.io.IOException;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.docx4j.org.apache.poi.util.BitField;
import org.docx4j.org.apache.poi.util.BitFieldFactory;
import org.docx4j.org.apache.poi.util.LittleEndianInput;


public class EncryptionInfo {
    private final int versionMajor;
    private final int versionMinor;
    private final int encryptionFlags;
    
    private final EncryptionHeader header;
    private final EncryptionVerifier verifier;
    private final Decryptor decryptor;
    private final Encryptor encryptor;

    
    public static BitField flagCryptoAPI = BitFieldFactory.getInstance(0x04);

    
    public static BitField flagDocProps = BitFieldFactory.getInstance(0x08);
    
    
    public static BitField flagExternal = BitFieldFactory.getInstance(0x10);
    
    
    public static BitField flagAES = BitFieldFactory.getInstance(0x20);
    
    
    
    public EncryptionInfo(POIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(OPOIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(NPOIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(DirectoryNode dir) throws IOException {
        this(dir.createDocumentInputStream("EncryptionInfo"), false);
    }

    public EncryptionInfo(LittleEndianInput dis, boolean isCryptoAPI) throws IOException {
        final EncryptionMode encryptionMode;
        versionMajor = dis.readShort();
        versionMinor = dis.readShort();

        if (!isCryptoAPI
            && versionMajor == binaryRC4.versionMajor
            && versionMinor == binaryRC4.versionMinor) {
            encryptionMode = binaryRC4;
            encryptionFlags = -1;
        } else if (!isCryptoAPI
            && versionMajor == agile.versionMajor
            && versionMinor == agile.versionMinor){
            encryptionMode = agile;
            encryptionFlags = dis.readInt();
        } else if (!isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == standard.versionMinor) {
            encryptionMode = standard;
            encryptionFlags = dis.readInt();
        } else if (isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == cryptoAPI.versionMinor) {
            encryptionMode = cryptoAPI;
            encryptionFlags = dis.readInt();
        } else {
            encryptionFlags = dis.readInt();
            throw new EncryptedDocumentException(
                "Unknown encryption: version major: "+versionMajor+
                " / version minor: "+versionMinor+
                " / fCrypto: "+flagCryptoAPI.isSet(encryptionFlags)+
                " / fExternal: "+flagExternal.isSet(encryptionFlags)+
                " / fDocProps: "+flagDocProps.isSet(encryptionFlags)+
                " / fAES: "+flagAES.isSet(encryptionFlags));
        }
        
        EncryptionInfoBuilder eib;
        try {
            eib = getBuilder(encryptionMode);
        } catch (Exception e) {
            throw new IOException(e);
        }

        eib.initialize(this, dis);
        header = eib.getHeader();
        verifier = eib.getVerifier();
        decryptor = eib.getDecryptor();
        encryptor = eib.getEncryptor();
    }
    
    
    @Deprecated
    public EncryptionInfo(POIFSFileSystem fs, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
     
    
    @Deprecated
    public EncryptionInfo(NPOIFSFileSystem fs, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
     
    
    @Deprecated
    public EncryptionInfo(DirectoryNode dir, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
    
    
    @Deprecated
    public EncryptionInfo(
        POIFSFileSystem fs
      , EncryptionMode encryptionMode
      , CipherAlgorithm cipherAlgorithm
      , HashAlgorithm hashAlgorithm
      , int keyBits
      , int blockSize
      , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }
    
    
    @Deprecated
    public EncryptionInfo(
        NPOIFSFileSystem fs
      , EncryptionMode encryptionMode
      , CipherAlgorithm cipherAlgorithm
      , HashAlgorithm hashAlgorithm
      , int keyBits
      , int blockSize
      , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }
        
    
    @Deprecated
    public EncryptionInfo(
          DirectoryNode dir
        , EncryptionMode encryptionMode
        , CipherAlgorithm cipherAlgorithm
        , HashAlgorithm hashAlgorithm
        , int keyBits
        , int blockSize
        , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }        

    
    public EncryptionInfo(EncryptionMode encryptionMode) {
        this(encryptionMode, null, null, -1, -1, null);
    }
    
    
    public EncryptionInfo(
            EncryptionMode encryptionMode
          , CipherAlgorithm cipherAlgorithm
          , HashAlgorithm hashAlgorithm
          , int keyBits
          , int blockSize
          , ChainingMode chainingMode
      ) {
        versionMajor = encryptionMode.versionMajor;
        versionMinor = encryptionMode.versionMinor;
        encryptionFlags = encryptionMode.encryptionFlags;

        EncryptionInfoBuilder eib;
        try {
            eib = getBuilder(encryptionMode);
        } catch (Exception e) {
            throw new EncryptedDocumentException(e);
        }
        
        eib.initialize(this, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        
        header = eib.getHeader();
        verifier = eib.getVerifier();
        decryptor = eib.getDecryptor();
        encryptor = eib.getEncryptor();
    }

    protected static EncryptionInfoBuilder getBuilder(EncryptionMode encryptionMode)
    throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        EncryptionInfoBuilder eib;
        eib = (EncryptionInfoBuilder)cl.loadClass(encryptionMode.builder).newInstance();
        return eib;
    }
    
    public int getVersionMajor() {
        return versionMajor;
    }

    public int getVersionMinor() {
        return versionMinor;
    }

    public int getEncryptionFlags() {
        return encryptionFlags;
    }

    public EncryptionHeader getHeader() {
        return header;
    }

    public EncryptionVerifier getVerifier() {
        return verifier;
    }
    
    public Decryptor getDecryptor() {
        return decryptor;
    }

    public Encryptor getEncryptor() {
        return encryptor;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.nio.charset.Charset;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.LittleEndianInput;
import org.docx4j.org.apache.poi.util.LittleEndianOutput;
import org.docx4j.org.apache.poi.util.StringUtil;

public class DataSpaceMapUtils {
    public static void addDefaultDataSpace(DirectoryEntry dir) throws IOException {
        DataSpaceMapEntry dsme = new DataSpaceMapEntry(
                new int[]{ 0 }
              , new String[]{ Decryptor.DEFAULT_POIFS_ENTRY }
              , "StrongEncryptionDataSpace"
          );
          DataSpaceMap dsm = new DataSpaceMap(new DataSpaceMapEntry[]{dsme});
          createEncryptionEntry(dir, "\u0006DataSpaces/DataSpaceMap", dsm);

          DataSpaceDefinition dsd = new DataSpaceDefinition(new String[]{ "StrongEncryptionTransform" });
          createEncryptionEntry(dir, "\u0006DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", dsd);

          TransformInfoHeader tih = new TransformInfoHeader(
                1
              , "{FF9A3F03-56EF-4613-BDD5-5A41C1D07246}"
              , "Microsoft.Container.EncryptionTransform"
              , 1, 0, 1, 0, 1, 0
          );
          IRMDSTransformInfo irm = new IRMDSTransformInfo(tih, 0, null);
          createEncryptionEntry(dir, "\u0006DataSpaces/TransformInfo/StrongEncryptionTransform/\u0006Primary", irm);
          
          DataSpaceVersionInfo dsvi = new DataSpaceVersionInfo("Microsoft.Container.DataSpaces", 1, 0, 1, 0, 1, 0);
          createEncryptionEntry(dir, "\u0006DataSpaces/Version", dsvi);
    }
    
    public static DocumentEntry createEncryptionEntry(DirectoryEntry dir, String path, EncryptionRecord out) throws IOException {
        String parts[] = path.split("/");
        for (int i=0; i<parts.length-1; i++) {
            dir = dir.hasEntry(parts[i])
                ? (DirectoryEntry)dir.getEntry(parts[i])
                : dir.createDirectory(parts[i]);
        }
        
        final byte buf[] = new byte[5000];        
        LittleEndianByteArrayOutputStream bos = new LittleEndianByteArrayOutputStream(buf, 0);
        out.write(bos);
        
        String fileName = parts[parts.length-1];
        
        if (dir.hasEntry(fileName)) {
            dir.getEntry(fileName).delete();
        }
        
        return dir.createDocument(fileName, bos.getWriteIndex(), new POIFSWriterListener(){
            public void processPOIFSWriterEvent(POIFSWriterEvent event) {
                try {
                    event.getStream().write(buf, 0, event.getLimit());
                } catch (IOException e) {
                    throw new EncryptedDocumentException(e);
                }
            }
        });
    }   
    
    public static class DataSpaceMap implements EncryptionRecord {
        DataSpaceMapEntry entries[];
        
        public DataSpaceMap(DataSpaceMapEntry entries[]) {
            this.entries = entries;
        }
        
        public DataSpaceMap(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            int entryCount = is.readInt();
            entries = new DataSpaceMapEntry[entryCount];
            for (int i=0; i<entryCount; i++) {
                entries[i] = new DataSpaceMapEntry(is);
            }
        }
    
        public void write(LittleEndianByteArrayOutputStream os) {
            os.writeInt(8);
            os.writeInt(entries.length);
            for (DataSpaceMapEntry dsme : entries) {
                dsme.write(os);
            }
        }
    }
    
    public static class DataSpaceMapEntry implements EncryptionRecord {
        int referenceComponentType[];
        String referenceComponent[];
        String dataSpaceName;
        
        public DataSpaceMapEntry(int referenceComponentType[], String referenceComponent[], String dataSpaceName) {
            this.referenceComponentType = referenceComponentType;
            this.referenceComponent = referenceComponent;
            this.dataSpaceName = dataSpaceName;
        }
        
        public DataSpaceMapEntry(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            int referenceComponentCount = is.readInt();
            referenceComponentType = new int[referenceComponentCount];
            referenceComponent = new String[referenceComponentCount];
            for (int i=0; i<referenceComponentCount; i++) {
                referenceComponentType[i] = is.readInt();
                referenceComponent[i] = readUnicodeLPP4(is);
            }
            dataSpaceName = readUnicodeLPP4(is);
        }
        
        public void write(LittleEndianByteArrayOutputStream os) {
            int start = os.getWriteIndex();
            LittleEndianOutput sizeOut = os.createDelayedOutput(LittleEndianConsts.INT_SIZE);
            os.writeInt(referenceComponent.length);
            for (int i=0; i<referenceComponent.length; i++) {
                os.writeInt(referenceComponentType[i]);
                writeUnicodeLPP4(os, referenceComponent[i]);
            }
            writeUnicodeLPP4(os, dataSpaceName);
            sizeOut.writeInt(os.getWriteIndex()-start);
        }
    }
    
    public static class DataSpaceDefinition implements EncryptionRecord {
        String transformer[];
        
        public DataSpaceDefinition(String transformer[]) {
            this.transformer = transformer;
        }
        
        public DataSpaceDefinition(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int headerLength = is.readInt();
            int transformReferenceCount = is.readInt();
            transformer = new String[transformReferenceCount];
            for (int i=0; i<transformReferenceCount; i++) {
                transformer[i] = readUnicodeLPP4(is);
            }
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            bos.writeInt(8);
            bos.writeInt(transformer.length);
            for (String str : transformer) {
                writeUnicodeLPP4(bos, str);
            }
        }
    }
    
    public static class IRMDSTransformInfo implements EncryptionRecord {
        TransformInfoHeader transformInfoHeader;
        int extensibilityHeader;
        String xrMLLicense;
        
        public IRMDSTransformInfo(TransformInfoHeader transformInfoHeader, int extensibilityHeader, String xrMLLicense) {
            this.transformInfoHeader = transformInfoHeader;
            this.extensibilityHeader = extensibilityHeader;
            this.xrMLLicense = xrMLLicense;
        }
        
        public IRMDSTransformInfo(LittleEndianInput is) {
            transformInfoHeader = new TransformInfoHeader(is);
            extensibilityHeader = is.readInt();
            xrMLLicense = readUtf8LPP4(is);
            
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            transformInfoHeader.write(bos);
            bos.writeInt(extensibilityHeader);
            writeUtf8LPP4(bos, xrMLLicense);
            bos.writeInt(4); 
        }
    }
    
    public static class TransformInfoHeader implements EncryptionRecord {
        int transformType;
        String transformerId;
        String transformerName;
        int readerVersionMajor = 1, readerVersionMinor = 0;
        int updaterVersionMajor = 1, updaterVersionMinor = 0;
        int writerVersionMajor = 1, writerVersionMinor = 0;

        public TransformInfoHeader(
            int transformType,
            String transformerId,
            String transformerName,
            int readerVersionMajor, int readerVersionMinor,
            int updaterVersionMajor, int updaterVersionMinor,
            int writerVersionMajor, int writerVersionMinor                
        ){
            this.transformType = transformType;
            this.transformerId = transformerId;
            this.transformerName = transformerName;
            this.readerVersionMajor = readerVersionMajor;
            this.readerVersionMinor = readerVersionMinor;
            this.updaterVersionMajor = updaterVersionMajor;
            this.updaterVersionMinor = updaterVersionMinor;
            this.writerVersionMajor = writerVersionMajor;
            this.writerVersionMinor = writerVersionMinor;
        }
        
        public TransformInfoHeader(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            transformType = is.readInt();
            transformerId = readUnicodeLPP4(is);
            transformerName = readUnicodeLPP4(is);
            readerVersionMajor = is.readShort();
            readerVersionMinor = is.readShort();
            updaterVersionMajor = is.readShort();
            updaterVersionMinor = is.readShort();
            writerVersionMajor = is.readShort();
            writerVersionMinor = is.readShort();
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            int start = bos.getWriteIndex();
            LittleEndianOutput sizeOut = bos.createDelayedOutput(LittleEndianConsts.INT_SIZE);
            bos.writeInt(transformType);
            writeUnicodeLPP4(bos, transformerId);
            sizeOut.writeInt(bos.getWriteIndex()-start);
            writeUnicodeLPP4(bos, transformerName);
            bos.writeShort(readerVersionMajor);
            bos.writeShort(readerVersionMinor); 
            bos.writeShort(updaterVersionMajor);
            bos.writeShort(updaterVersionMinor);
            bos.writeShort(writerVersionMajor); 
            bos.writeShort(writerVersionMinor); 
        }
    }
    
    public static class DataSpaceVersionInfo implements EncryptionRecord {
        String featureIdentifier;
        int readerVersionMajor = 1, readerVersionMinor = 0;
        int updaterVersionMajor = 1, updaterVersionMinor = 0;
        int writerVersionMajor = 1, writerVersionMinor = 0;
        
        public DataSpaceVersionInfo(LittleEndianInput is) {
            featureIdentifier = readUnicodeLPP4(is);
            readerVersionMajor = is.readShort();
            readerVersionMinor = is.readShort();
            updaterVersionMajor = is.readShort();
            updaterVersionMinor = is.readShort();
            writerVersionMajor = is.readShort();
            writerVersionMinor = is.readShort();
        }
        
        public DataSpaceVersionInfo(
            String featureIdentifier,
            int readerVersionMajor, int readerVersionMinor,
            int updaterVersionMajor, int updaterVersionMinor,
            int writerVersionMajor, int writerVersionMinor                
        ){
            this.featureIdentifier = featureIdentifier;
            this.readerVersionMajor = readerVersionMajor;
            this.readerVersionMinor = readerVersionMinor;
            this.updaterVersionMajor = updaterVersionMajor;
            this.updaterVersionMinor = updaterVersionMinor;
            this.writerVersionMajor = writerVersionMajor;
            this.writerVersionMinor = writerVersionMinor;
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            writeUnicodeLPP4(bos, featureIdentifier);
            bos.writeShort(readerVersionMajor);
            bos.writeShort(readerVersionMinor); 
            bos.writeShort(updaterVersionMajor);
            bos.writeShort(updaterVersionMinor);
            bos.writeShort(writerVersionMajor); 
            bos.writeShort(writerVersionMinor); 
        }
    }
    
    public static String readUnicodeLPP4(LittleEndianInput is) {
        int length = is.readInt();
        if (length%2 != 0) {
            throw new EncryptedDocumentException(
                "UNICODE-LP-P4 structure is a multiple of 4 bytes. "
                + "If Padding is present, it MUST be exactly 2 bytes long");
        }
        
        String result = StringUtil.readUnicodeLE(is, length/2);
        if (length%4==2) {
            
            
            
            is.readShort();
        }
        
        return result;
    }
    
    public static void writeUnicodeLPP4(LittleEndianOutput os, String string) {
        byte buf[] = StringUtil.getToUnicodeLE(string);
        os.writeInt(buf.length);
        os.write(buf);
        if (buf.length%4==2) {
            os.writeShort(0);
        }
    }

    public static String readUtf8LPP4(LittleEndianInput is) {
        int length = is.readInt();
        if (length == 0 || length == 4) {
            @SuppressWarnings("unused")
            int skip = is.readInt(); 
            return length == 0 ? null : "";
        }
        
        byte data[] = new byte[length];
        is.readFully(data);

        
        
        
        
        
        int scratchedBytes = length%4;
        if (scratchedBytes > 0) {
            for (int i=0; i<(4-scratchedBytes); i++) {
                is.readByte();
            }
        }

        return new String(data, 0, data.length, Charset.forName("UTF-8"));
    }
    
    public static void writeUtf8LPP4(LittleEndianOutput os, String str) {
        if (str == null || "".equals(str)) {
            os.writeInt(str == null ? 0 : 4);
            os.writeInt(0);
        } else {
            byte buf[] = str.getBytes(Charset.forName("UTF-8"));
            os.writeInt(buf.length);
            os.write(buf);
            int scratchBytes = buf.length%4;
            if (scratchBytes > 0) {
                for (int i=0; i<(4-scratchBytes); i++) {
                    os.writeByte(0);
                }
            }
        }        
    }

}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt;



public abstract class EncryptionVerifier {
    private byte[] salt;
    private byte[] encryptedVerifier;
    private byte[] encryptedVerifierHash;
    private byte[] encryptedKey;
    
    private int spinCount;
    private CipherAlgorithm cipherAlgorithm;
    private ChainingMode chainingMode;
    private HashAlgorithm hashAlgorithm;
    
    protected EncryptionVerifier() {}

    public byte[] getSalt() {
        return salt;
    }

    
    @Deprecated
    public byte[] getVerifier() {
        return encryptedVerifier;
    }

    public byte[] getEncryptedVerifier() {
        return encryptedVerifier;
    }    
    
    
    @Deprecated
    public byte[] getVerifierHash() {
        return encryptedVerifierHash;
    }

    public byte[] getEncryptedVerifierHash() {
        return encryptedVerifierHash;
    }    
    
    public int getSpinCount() {
        return spinCount;
    }

    public int getCipherMode() {
        return chainingMode.ecmaId;
    }

    public int getAlgorithm() {
        return cipherAlgorithm.ecmaId;
    }

    
    @Deprecated
    public String getAlgorithmName() {
        return cipherAlgorithm.jceId;
    }

    public byte[] getEncryptedKey() {
        return encryptedKey;
    }
    
    public CipherAlgorithm getCipherAlgorithm() {
        return cipherAlgorithm;
    }
    
    public HashAlgorithm getHashAlgorithm() {
        return hashAlgorithm;
    }
    
    public ChainingMode getChainingMode() {
        return chainingMode;
    }

    protected void setSalt(byte[] salt) {
        this.salt = salt;
    }

    protected void setEncryptedVerifier(byte[] encryptedVerifier) {
        this.encryptedVerifier = encryptedVerifier;
    }

    protected void setEncryptedVerifierHash(byte[] encryptedVerifierHash) {
        this.encryptedVerifierHash = encryptedVerifierHash;
    }

    protected void setEncryptedKey(byte[] encryptedKey) {
        this.encryptedKey = encryptedKey;
    }

    protected void setSpinCount(int spinCount) {
        this.spinCount = spinCount;
    }

    protected void setCipherAlgorithm(CipherAlgorithm cipherAlgorithm) {
        this.cipherAlgorithm = cipherAlgorithm;
    }

    protected void setChainingMode(ChainingMode chainingMode) {
        this.chainingMode = chainingMode;
    }

    protected void setHashAlgorithm(HashAlgorithm hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
    }
    
    
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;

import javax.crypto.SecretKey;

import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;

public abstract class Encryptor {
    protected static final String DEFAULT_POIFS_ENTRY = Decryptor.DEFAULT_POIFS_ENTRY;
    private SecretKey secretKey;
    
    
    public abstract OutputStream getDataStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException;

    
    public abstract void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]);
    
    public abstract void confirmPassword(String password);
	
	public static Encryptor getInstance(EncryptionInfo info) {
	    return info.getEncryptor();
    }

    public OutputStream getDataStream(NPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public OutputStream getDataStream(OPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public OutputStream getDataStream(POIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }

    public SecretKey getSecretKey() {
        return secretKey;
    }

    protected void setSecretKey(SecretKey secretKey) {
        this.secretKey = secretKey;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt;




public enum EncryptionMode {
    
    binaryRC4("org.docx4j.org.apache.poi.poifs.crypt.binaryrc4.BinaryRC4EncryptionInfoBuilder", 1, 1, 0x0),
    
    cryptoAPI("org.docx4j.org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIEncryptionInfoBuilder", 4, 2, 0x04),
    
    standard("org.docx4j.org.apache.poi.poifs.crypt.standard.StandardEncryptionInfoBuilder", 4, 2, 0x24),
    
    agile("org.docx4j.org.apache.poi.poifs.crypt.agile.AgileEncryptionInfoBuilder", 4, 4, 0x40)
    ;
    
    public final String builder;
    public final int versionMajor;
    public final int versionMinor;
    public final int encryptionFlags;
    
    EncryptionMode(String builder, int versionMajor, int versionMinor, int encryptionFlags) {
        this.builder = builder;
        this.versionMajor = versionMajor;
        this.versionMinor = versionMinor;
        this.encryptionFlags = encryptionFlags;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt;



public abstract class EncryptionHeader {
    public static final int ALGORITHM_RC4 = CipherAlgorithm.rc4.ecmaId;
    public static final int ALGORITHM_AES_128 = CipherAlgorithm.aes128.ecmaId;
    public static final int ALGORITHM_AES_192 = CipherAlgorithm.aes192.ecmaId;
    public static final int ALGORITHM_AES_256 = CipherAlgorithm.aes256.ecmaId;
    
    public static final int HASH_NONE   = HashAlgorithm.none.ecmaId;
    public static final int HASH_SHA1   = HashAlgorithm.sha1.ecmaId;
    public static final int HASH_SHA256 = HashAlgorithm.sha256.ecmaId;
    public static final int HASH_SHA384 = HashAlgorithm.sha384.ecmaId;
    public static final int HASH_SHA512 = HashAlgorithm.sha512.ecmaId;

    public static final int PROVIDER_RC4 = CipherProvider.rc4.ecmaId;
    public static final int PROVIDER_AES = CipherProvider.aes.ecmaId;

    public static final int MODE_ECB = ChainingMode.ecb.ecmaId;
    public static final int MODE_CBC = ChainingMode.cbc.ecmaId;
    public static final int MODE_CFB = ChainingMode.cfb.ecmaId;
    
    private int flags;
    private int sizeExtra;
    private CipherAlgorithm cipherAlgorithm;
    private HashAlgorithm hashAlgorithm;
    private int keyBits;
    private int blockSize;
    private CipherProvider providerType;
    private ChainingMode chainingMode;
    private byte[] keySalt;
    private String cspName;
    
    protected EncryptionHeader() {}

    
    public int getCipherMode() {
        return chainingMode.ecmaId;
    }
    
    public ChainingMode getChainingMode() {
        return chainingMode;
    }
    
    protected void setChainingMode(ChainingMode chainingMode) {
        this.chainingMode = chainingMode;
    }

    public int getFlags() {
        return flags;
    }
    
    protected void setFlags(int flags) {
        this.flags = flags;
    }

    public int getSizeExtra() {
        return sizeExtra;
    }
    
    protected void setSizeExtra(int sizeExtra) {
        this.sizeExtra = sizeExtra;
    }

    
    public int getAlgorithm() {
        return cipherAlgorithm.ecmaId;
    }

    public CipherAlgorithm getCipherAlgorithm() {
        return cipherAlgorithm;
    }
    
    protected void setCipherAlgorithm(CipherAlgorithm cipherAlgorithm) {
        this.cipherAlgorithm = cipherAlgorithm;
    }
    
    
    public int getHashAlgorithm() {
        return hashAlgorithm.ecmaId;
    }
    
    public HashAlgorithm getHashAlgorithmEx() {
        return hashAlgorithm;
    }
    
    protected void setHashAlgorithm(HashAlgorithm hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
    }

    public int getKeySize() {
        return keyBits;
    }
    
    protected void setKeySize(int keyBits) {
        this.keyBits = keyBits;
    }

    public int getBlockSize() {
    	return blockSize;
    }
    
    protected void setBlockSize(int blockSize) {
        this.blockSize = blockSize;
    }
    
    public byte[] getKeySalt() {
        return keySalt;
    }
    
    protected void setKeySalt(byte salt[]) {
        this.keySalt = salt;
    }

    
    public int getProviderType() {
        return providerType.ecmaId;
    }

    public CipherProvider getCipherProvider() {
        return providerType;
    }    

    protected void setCipherProvider(CipherProvider providerType) {
        this.providerType = providerType;
    }
    
    public String getCspName() {
        return cspName;
    }
    
    protected void setCspName(String cspName) {
        this.cspName = cspName;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;

import javax.crypto.SecretKey;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSFileSystem;

public abstract class Decryptor {
    public static final String DEFAULT_PASSWORD="VelvetSweatshop";
    public static final String DEFAULT_POIFS_ENTRY="EncryptedPackage";
    
    protected final EncryptionInfoBuilder builder;
    private SecretKey secretKey;
    private byte[] verifier, integrityHmacKey, integrityHmacValue;

    protected Decryptor(EncryptionInfoBuilder builder) {
        this.builder = builder;
    }
    
    
    public abstract InputStream getDataStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException;

    public abstract boolean verifyPassword(String password)
        throws GeneralSecurityException;

    
    public abstract long getLength();

    public static Decryptor getInstance(EncryptionInfo info) {
        Decryptor d = info.getDecryptor();
        if (d == null) {
            throw new EncryptedDocumentException("Unsupported version");
        }
        return d;
    }

    public InputStream getDataStream(NPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public InputStream getDataStream(OPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public InputStream getDataStream(POIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    
    
    public byte[] getVerifier() {
        return verifier;
    }

    public SecretKey getSecretKey() {
        return secretKey;
    }
    
    public byte[] getIntegrityHmacKey() {
        return integrityHmacKey;
    }

    public byte[] getIntegrityHmacValue() {
        return integrityHmacValue;
    }

    protected void setSecretKey(SecretKey secretKey) {
        this.secretKey = secretKey;
    }

    protected void setVerifier(byte[] verifier) {
        this.verifier = verifier;
    }

    protected void setIntegrityHmacKey(byte[] integrityHmacKey) {
        this.integrityHmacKey = integrityHmacKey;
    }

    protected void setIntegrityHmacValue(byte[] integrityHmacValue) {
        this.integrityHmacValue = integrityHmacValue;
    }

    protected int getBlockSizeInBytes() {
        return builder.getHeader().getBlockSize();
    }
    
    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize()/8;
    }
}
<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import java.nio.charset.Charset;
import java.security.DigestException;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.Provider;
import java.security.Security;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.RC2ParameterSpec;







import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.StringUtil;


public class CryptoFunctions {
    
    public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount) {
        return hashPassword(password, hashAlgorithm, salt, spinCount, true);
    }
        
    
    public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount, boolean iteratorFirst) {
        
        if (password == null) {
            password = Decryptor.DEFAULT_PASSWORD;
        }
        
        MessageDigest hashAlg = getMessageDigest(hashAlgorithm);
        
        hashAlg.update(salt);
        byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];

        byte[] first = (iteratorFirst ? iterator : hash);
        byte[] second = (iteratorFirst ? hash : iterator);
        
        try {
            for (int i = 0; i < spinCount; i++) {
                LittleEndian.putInt(iterator, 0, i);
                hashAlg.reset();
                hashAlg.update(first);
                hashAlg.update(second);
                hashAlg.digest(hash, 0, hash.length); 
            }
        } catch (DigestException e) {
            throw new EncryptedDocumentException("error in password hashing");
        }
        
        return hash;
    }    

    
    public static byte[] generateIv(HashAlgorithm hashAlgorithm, byte[] salt, byte[] blockKey, int blockSize) {
        byte iv[] = salt;
        if (blockKey != null) {
            MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
            hashAlgo.update(salt);
            iv = hashAlgo.digest(blockKey);
        }
        return getBlock36(iv, blockSize);
    }

    
    public static byte[] generateKey(byte[] passwordHash, HashAlgorithm hashAlgorithm, byte[] blockKey, int keySize) {
        MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
        hashAlgo.update(passwordHash);
        byte[] key = hashAlgo.digest(blockKey);
        return getBlock36(key, keySize);
    }

    public static Cipher getCipher(SecretKey key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode) {
        return getCipher(key, cipherAlgorithm, chain, vec, cipherMode, null);
    }

    
    public static Cipher getCipher(Key key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode, String padding) {

        int keySizeInBytes = key.getEncoded().length;
        if (padding == null) padding = "NoPadding";
        
        try {
            
            if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes*8) {
                throw new EncryptedDocumentException("Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files");
            }

            Cipher cipher;
            if (cipherAlgorithm == CipherAlgorithm.rc4) {
                cipher = Cipher.getInstance(cipherAlgorithm.jceId);
            } else if (cipherAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding, "BC");
            } else {
                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding);
            }
            
            if (vec == null) {
                cipher.init(cipherMode, key);
            } else {
                AlgorithmParameterSpec aps;
                if (cipherAlgorithm == CipherAlgorithm.rc2) {
                    aps = new RC2ParameterSpec(key.getEncoded().length*8, vec);
                } else {
                    aps = new IvParameterSpec(vec);
                }
                cipher.init(cipherMode, key, aps);
            }
            return cipher;
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }    
    
    
    public static byte[] getBlock36(byte[] hash, int size) {
        return getBlockX(hash, size, (byte)0x36);
    }

    
    public static byte[] getBlock0(byte[] hash, int size) {
        return getBlockX(hash, size, (byte)0);
    }
    
    private static byte[] getBlockX(byte[] hash, int size, byte fill) {
        if (hash.length == size) return hash;
        
        byte[] result = new byte[size];
        Arrays.fill(result, fill);
        System.arraycopy(hash, 0, result, 0, Math.min(result.length, hash.length));
        return result;
    }
    
    public static MessageDigest getMessageDigest(HashAlgorithm hashAlgorithm) {
        try {
            if (hashAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                return MessageDigest.getInstance(hashAlgorithm.jceId, "BC");
            } else {
                return MessageDigest.getInstance(hashAlgorithm.jceId);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("hash algo not supported", e);
        }
    }
    
    public static Mac getMac(HashAlgorithm hashAlgorithm) {
        try {
            if (hashAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                return Mac.getInstance(hashAlgorithm.jceHmacId, "BC");
            } else {
                return Mac.getInstance(hashAlgorithm.jceHmacId);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("hmac algo not supported", e);
        }
    }

    @SuppressWarnings("unchecked")
    public static void registerBouncyCastle() {
        if (Security.getProvider("BC") != null) return;
        try {
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            String bcProviderName = "org.bouncycastle.jce.provider.BouncyCastleProvider";
            Class<Provider> clazz = (Class<Provider>)cl.loadClass(bcProviderName);
            Security.addProvider(clazz.newInstance());
        } catch (Exception e) {
            throw new EncryptedDocumentException("Only the BouncyCastle provider supports your encryption settings - please add it to the classpath.");
        }
    }

    private static final int InitialCodeArray[] = { 
        0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 
        0x313E, 0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 
        0x4EC3
    };

    private static final byte PadArray[] = {
        (byte)0xBB, (byte)0xFF, (byte)0xFF, (byte)0xBA, (byte)0xFF,
        (byte)0xFF, (byte)0xB9, (byte)0x80, (byte)0x00, (byte)0xBE,
        (byte)0x0F, (byte)0x00, (byte)0xBF, (byte)0x0F, (byte)0x00
    };
    
    private static final int EncryptionMatrix[][] = {
         {0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09},
         {0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF},
         {0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0},
         {0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40},
         {0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5},
         {0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A},
         {0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9},
         {0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0},
         {0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC},
         {0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10},
         {0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168},
         {0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C},
         {0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD},
         {0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC},
         {0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4}
    };

    
    public static int createXorVerifier2(String password) {
        
        byte[] generatedKey = new byte[4];

        
        final int maxPasswordLength = 15; 
        
        if (!"".equals(password)) {
            
            password = password.substring(0, Math.min(password.length(), maxPasswordLength));

            
            
            
            byte[] arrByteChars = new byte[password.length()];
            
            for (int i = 0; i < password.length(); i++) {
                int intTemp = password.charAt(i);
                byte lowByte = (byte)(intTemp & 0x00FF);
                byte highByte = (byte)((intTemp & 0xFF00) >> 8);
                arrByteChars[i] = (lowByte != 0 ? lowByte : highByte);
            }

            

            
            int highOrderWord = InitialCodeArray[arrByteChars.length - 1];

            
            
            
            
            for (int i = 0; i < arrByteChars.length; i++) {
                int tmp = maxPasswordLength - arrByteChars.length + i;
                for (int intBit = 0; intBit < 7; intBit++) {
                    if ((arrByteChars[i] & (0x0001 << intBit)) != 0) {
                        highOrderWord ^= EncryptionMatrix[tmp][intBit];
                    }
                }
            }
            
            
            
            
            short verifier = 0;

            
            for (int i = arrByteChars.length-1; i >= 0; i--) {
                
                verifier = rotateLeftBase15Bit(verifier);
                verifier ^= arrByteChars[i];
            }

            
            
            verifier = rotateLeftBase15Bit(verifier);
            verifier ^= arrByteChars.length;
            
            
            verifier ^= 0xCE4B; 

            
            
            
            LittleEndian.putShort(generatedKey, 0, verifier);
            LittleEndian.putShort(generatedKey, 2, (short)highOrderWord);
        }
        
        return LittleEndian.getInt(generatedKey);
    }

    
    public static String xorHashPassword(String password) {
        int hashedPassword = createXorVerifier2(password);
        return String.format("%1$08X", hashedPassword);
    }
    
    
    public static String xorHashPasswordReversed(String password) {
        int hashedPassword = createXorVerifier2(password);
        
        return String.format("%1$02X%2$02X%3$02X%4$02X"
            , ( hashedPassword >>> 0 ) & 0xFF
            , ( hashedPassword >>> 8 ) & 0xFF
            , ( hashedPassword >>> 16 ) & 0xFF
            , ( hashedPassword >>> 24 ) & 0xFF
        );
    }

    
    public static int createXorVerifier1(String password) {
        
        
        return createXorVerifier2(password) & 0xFFFF;
    }
 
    
    public static int createXorKey1(String password) {
        
        
        return createXorVerifier2(password) >>> 16;
    }

    
    public static byte[] createXorArray1(String password) {
        if (password.length() > 15) password = password.substring(0, 15);
        byte passBytes[] = password.getBytes(Charset.forName("ASCII"));
        
        
        
        byte obfuscationArray[] = new byte[16];
        System.arraycopy(passBytes, 0, obfuscationArray, 0, passBytes.length);
        System.arraycopy(PadArray, 0, obfuscationArray, passBytes.length, PadArray.length-passBytes.length+1);
        
        int xorKey = createXorKey1(password);
        
        
        int nRotateSize = 2; 
        
        byte baseKeyLE[] = { (byte)(xorKey & 0xFF), (byte)((xorKey >>> 8) & 0xFF) };
        for (int i=0; i<obfuscationArray.length; i++) {
            obfuscationArray[i] ^= baseKeyLE[i&1];
            obfuscationArray[i] = rotateLeft(obfuscationArray[i], nRotateSize);
        }
        
        return obfuscationArray;
    }

    private static byte rotateLeft(byte bits, int shift) {
        return (byte)(((bits & 0xff) << shift) | ((bits & 0xff) >>> (8 - shift)));
    }
    
    private static short rotateLeftBase15Bit(short verifier) {
        
        short intermediate1 = (short)(((verifier & 0x4000) == 0) ? 0 : 1);
        
        short intermediate2 = (short)((verifier<<1) & 0x7FFF);
        
        short intermediate3 = (short)(intermediate1 | intermediate2);
        return intermediate3;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt;

import org.docx4j.org.apache.poi.EncryptedDocumentException;



public enum CipherProvider {
    rc4("RC4", 1, "Microsoft Base Cryptographic Provider v1.0"),
    aes("AES", 0x18, "Microsoft Enhanced RSA and AES Cryptographic Provider");

    public static CipherProvider fromEcmaId(int ecmaId) {
        for (CipherProvider cp : CipherProvider.values()) {
            if (cp.ecmaId == ecmaId) return cp;
        }
        throw new EncryptedDocumentException("cipher provider not found");
    }    
    
    public final String jceId;
    public final int ecmaId;
    public final String cipherProviderName;
    CipherProvider(String jceId, int ecmaId, String cipherProviderName) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.cipherProviderName = cipherProviderName;
    }
}
<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import static org.docx4j.org.apache.poi.poifs.crypt.Decryptor.DEFAULT_POIFS_ENTRY;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.TempFile;

@Internal
public abstract class ChunkedCipherOutputStream extends FilterOutputStream {
    protected final int chunkSize;
    protected final int chunkMask;
    protected final int chunkBits;
    
    private final byte[] _chunk;
    private final File fileOut;
    private final DirectoryNode dir;

    private long _pos = 0;
    private Cipher _cipher;
    
    public ChunkedCipherOutputStream(DirectoryNode dir, int chunkSize) throws IOException, GeneralSecurityException {
        super(null);
        this.chunkSize = chunkSize;
        chunkMask = chunkSize-1;
        chunkBits = Integer.bitCount(chunkMask);
        _chunk = new byte[chunkSize];

        fileOut = TempFile.createTempFile("encrypted_package", "crypt");
        fileOut.deleteOnExit();
        this.out = new FileOutputStream(fileOut);
        this.dir = dir;
        _cipher = initCipherForBlock(null, 0, false);
    }

    protected abstract Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk)
    throws GeneralSecurityException;    
    
    protected abstract void calculateChecksum(File fileOut, int oleStreamSize)
    throws GeneralSecurityException, IOException;
    
    protected abstract void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
    throws IOException, GeneralSecurityException;

    public void write(int b) throws IOException {
        write(new byte[]{(byte)b});
    }

    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }

    public void write(byte[] b, int off, int len)
    throws IOException {
        if (len == 0) return;
        
        if (len < 0 || b.length < off+len) {
            throw new IOException("not enough bytes in your input buffer");
        }
        
        while (len > 0) {
            int posInChunk = (int)(_pos & chunkMask);
            int nextLen = Math.min(chunkSize-posInChunk, len);
            System.arraycopy(b, off, _chunk, posInChunk, nextLen);
            _pos += nextLen;
            off += nextLen;
            len -= nextLen;
            if ((_pos & chunkMask) == 0) {
                try {
                    writeChunk();
                } catch (GeneralSecurityException e) {
                    throw new IOException(e);
                }
            }
        }
    }

    protected void writeChunk() throws IOException, GeneralSecurityException {
        int posInChunk = (int)(_pos & chunkMask);
        
        
        int index = (int)(_pos >> chunkBits);
        boolean lastChunk;
        if (posInChunk==0) {
            index--;
            posInChunk = chunkSize;
            lastChunk = false;
        } else {
            
            lastChunk = true;
        }

        _cipher = initCipherForBlock(_cipher, index, lastChunk);

        int ciLen = _cipher.doFinal(_chunk, 0, posInChunk, _chunk);
        out.write(_chunk, 0, ciLen);
    }
    
    public void close() throws IOException {
        try {
            writeChunk();

            super.close();
            
            int oleStreamSize = (int)(fileOut.length()+LittleEndianConsts.LONG_SIZE);
            calculateChecksum(fileOut, (int)_pos);
            dir.createDocument(DEFAULT_POIFS_ENTRY, oleStreamSize, new EncryptedPackageWriter());
            createEncryptionInfoEntry(dir, fileOut);
        } catch (GeneralSecurityException e) {
            throw new IOException(e);
        }
    }

    private class EncryptedPackageWriter implements POIFSWriterListener {
        public void processPOIFSWriterEvent(POIFSWriterEvent event) {
            try {
                OutputStream os = event.getStream();
                byte buf[] = new byte[chunkSize];
    
                
                
                
                
                LittleEndian.putLong(buf, 0, _pos);
                os.write(buf, 0, LittleEndian.LONG_SIZE);

                FileInputStream fis = new FileInputStream(fileOut);
                int readBytes;
                while ((readBytes = fis.read(buf)) != -1) {
                    os.write(buf, 0, readBytes);
                }
                fis.close();

                os.close();
                
                fileOut.delete();
            } catch (IOException e) {
                throw new EncryptedDocumentException(e);
            }
        }
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt;

public enum ChainingMode {
    
    ecb("ECB", 1),
    cbc("CBC", 2),
    
    cfb("CFB8", 3);

    public final String jceId;
    public final int ecmaId;
    ChainingMode(String jceId, int ecmaId) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
    }
}
<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndianInput;
import org.docx4j.org.apache.poi.util.LittleEndianInputStream;

@Internal
public abstract class ChunkedCipherInputStream extends LittleEndianInputStream {
    private final int chunkSize;
    private final int chunkMask;
    private final int chunkBits;
    
    private int _lastIndex = 0;
    private long _pos = 0;
    private long _size;
    private byte[] _chunk;
    private Cipher _cipher;

    public ChunkedCipherInputStream(LittleEndianInput stream, long size, int chunkSize)
        throws GeneralSecurityException {
        super((InputStream)stream);
        _size = size;
        this.chunkSize = chunkSize;
        chunkMask = chunkSize-1;
        chunkBits = Integer.bitCount(chunkMask);
        
        _cipher = initCipherForBlock(null, 0);
    }
    
    protected abstract Cipher initCipherForBlock(Cipher existing, int block)
    throws GeneralSecurityException;

    public int read() throws IOException {
        byte[] b = new byte[1];
        if (read(b) == 1)
            return b[0];
        return -1;
    }

    
    

    public int read(byte[] b, int off, int len) throws IOException {
        int total = 0;
        
        if (available() <= 0) return -1;

        while (len > 0) {
            if (_chunk == null) {
                try {
                    _chunk = nextChunk();
                } catch (GeneralSecurityException e) {
                    throw new EncryptedDocumentException(e.getMessage(), e);
                }
            }
            int count = (int)(chunkSize - (_pos & chunkMask));
            int avail = available();
            if (avail == 0) {
                return total;
            }
            count = Math.min(avail, Math.min(count, len));
            System.arraycopy(_chunk, (int)(_pos & chunkMask), b, off, count);
            off += count;
            len -= count;
            _pos += count;
            if ((_pos & chunkMask) == 0)
                _chunk = null;
            total += count;
        }

        return total;
    }

    @Override
    public long skip(long n) throws IOException {
        long start = _pos;
        long skip = Math.min(available(), n);

        if ((((_pos + skip) ^ start) & ~chunkMask) != 0)
            _chunk = null;
        _pos += skip;
        return skip;
    }

    @Override
    public int available() {
        return (int)(_size - _pos);
    }
    
    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public synchronized void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }
    
    @Override
    public synchronized void reset() throws IOException {
        throw new UnsupportedOperationException();
    }

    private byte[] nextChunk() throws GeneralSecurityException, IOException {
        int index = (int)(_pos >> chunkBits);
        initCipherForBlock(_cipher, index);
        
        if (_lastIndex != index) {
            super.skip((index - _lastIndex) << chunkBits);
        }

        byte[] block = new byte[Math.min(super.available(), chunkSize)];
        super.read(block, 0, block.length);
        _lastIndex = index + 1;
        return _cipher.doFinal(block);
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt;

import org.docx4j.org.apache.poi.EncryptedDocumentException;



public enum CipherAlgorithm {
    
    
    rc4(CipherProvider.rc4,    "RC4", 0x6801, 0x40, new int[]{0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80}, -1, 20, "RC4", false),
    
    aes128(CipherProvider.aes, "AES", 0x660E, 128, new int[]{128}, 16, 32, "AES", false),
    aes192(CipherProvider.aes, "AES", 0x660F, 192, new int[]{192}, 16, 32, "AES", false),
    aes256(CipherProvider.aes, "AES", 0x6610, 256, new int[]{256}, 16, 32, "AES", false),
    rc2(null, "RC2", -1, 0x80, new int[]{0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80}, 8, 20, "RC2", false),
    des(null, "DES", -1, 64, new int[]{64}, 8, 32, "DES", false),
    
    des3(null, "DESede", -1, 192, new int[]{192}, 8, 32, "3DES", false),
    
    
    des3_112(null, "DESede", -1, 128, new int[]{128}, 8, 32, "3DES_112", true),
    
    rsa(null, "RSA", -1, 1024, new int[]{1024, 2048, 3072, 4096}, -1, -1, "", false);
    ;
    
    public final CipherProvider provider;
    public final String jceId;
    public final int ecmaId;
    public final int defaultKeySize;
    public final int allowedKeySize[];
    public final int blockSize;
    public final int encryptedVerifierHashLength;
    public final String xmlId;
    public final boolean needsBouncyCastle;
    
    CipherAlgorithm(CipherProvider provider, String jceId, int ecmaId, int defaultKeySize, int allowedKeySize[], int blockSize, int encryptedVerifierHashLength, String xmlId, boolean needsBouncyCastle) {
        this.provider = provider;
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.defaultKeySize = defaultKeySize;
        this.allowedKeySize = allowedKeySize;
        this.blockSize = blockSize;
        this.encryptedVerifierHashLength = encryptedVerifierHashLength;
        this.xmlId = xmlId;
        this.needsBouncyCastle = needsBouncyCastle;
    }

    public static CipherAlgorithm fromEcmaId(int ecmaId) {
        for (CipherAlgorithm ca : CipherAlgorithm.values()) {
            if (ca.ecmaId == ecmaId) return ca;
        }
        throw new EncryptedDocumentException("cipher algorithm " + ecmaId + " not found");
    }
    
    public static CipherAlgorithm fromXmlId(String xmlId, int keySize) {
        for (CipherAlgorithm ca : CipherAlgorithm.values()) {
            if (!ca.xmlId.equals(xmlId)) continue;
            for (int ks : ca.allowedKeySize) {
                if (ks == keySize) return ca;
            }
        }
        throw new EncryptedDocumentException("cipher algorithm " + xmlId + "/" + keySize + " not found");
    }
}
<code block>


package org.docx4j.org.apache.poi.poifs.crypt;

import org.docx4j.org.apache.poi.EncryptedDocumentException;



public enum HashAlgorithm {
    none     (         "", 0x0000,           "",  0,               "", false),
    sha1     (    "SHA-1", 0x8004,       "SHA1", 20,       "HmacSHA1", false),
    sha256   (  "SHA-256", 0x800C,     "SHA256", 32,     "HmacSHA256", false),
    sha384   (  "SHA-384", 0x800D,     "SHA384", 48,     "HmacSHA384", false),
    sha512   (  "SHA-512", 0x800E,     "SHA512", 64,     "HmacSHA512", false),
    
    md5      (      "MD5",     -1,        "MD5", 16,        "HmacMD5", false),
    
    md2      (      "MD2",     -1,        "MD2", 16,       "Hmac-MD2", true),
    md4      (      "MD4",     -1,        "MD4", 16,       "Hmac-MD4", true),
    ripemd128("RipeMD128",     -1, "RIPEMD-128", 16, "HMac-RipeMD128", true),
    ripemd160("RipeMD160",     -1, "RIPEMD-160", 20, "HMac-RipeMD160", true),
    whirlpool("Whirlpool",     -1,  "WHIRLPOOL", 64, "HMac-Whirlpool", true),
    
    sha224   (  "SHA-224",     -1,     "SHA224", 28,     "HmacSHA224", true);
    ;

    public final String jceId;
    public final int ecmaId;
    public final String ecmaString;
    public final int hashSize;
    public final String jceHmacId;
    public final boolean needsBouncyCastle;
    
    HashAlgorithm(String jceId, int ecmaId, String ecmaString, int hashSize, String jceHmacId, boolean needsBouncyCastle) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.ecmaString = ecmaString;
        this.hashSize = hashSize;
        this.jceHmacId = jceHmacId;
        this.needsBouncyCastle = needsBouncyCastle;
    }
    
    public static HashAlgorithm fromEcmaId(int ecmaId) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaId == ecmaId) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found");
    }    
    
    public static HashAlgorithm fromEcmaId(String ecmaString) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaString.equals(ecmaString)) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found '" + ecmaString + "'");
    }
    
    public static HashAlgorithm fromString(String string) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaString.equalsIgnoreCase(string) || ha.jceId.equalsIgnoreCase(string)) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found '" + string + "'");
    }
}
<code block>

package org.docx4j.org.apache.poi.poifs.crypt;

import java.io.IOException;

import org.docx4j.org.apache.poi.util.LittleEndianInput;

public interface EncryptionInfoBuilder {
    
    void initialize(EncryptionInfo ei, LittleEndianInput dis) throws IOException;

    
    void initialize(EncryptionInfo ei, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);

    
    EncryptionHeader getHeader();

    
    EncryptionVerifier getVerifier();

    
    Decryptor getDecryptor();

    
    Encryptor getEncryptor();
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.standard;


import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.LittleEndianInput;


public class StandardEncryptionVerifier extends EncryptionVerifier implements EncryptionRecord {
    private static final int SPIN_COUNT = 50000;
    private final int verifierHashSize;
    
    protected StandardEncryptionVerifier(LittleEndianInput is, StandardEncryptionHeader header) {
        int saltSize = is.readInt();

        if (saltSize!=16) {
            throw new RuntimeException("Salt size != 16 !?");
        }

        byte salt[] = new byte[16];
        is.readFully(salt);
        setSalt(salt);
        
        byte encryptedVerifier[] = new byte[16];
        is.readFully(encryptedVerifier);
        setEncryptedVerifier(encryptedVerifier);

        verifierHashSize = is.readInt();

        byte encryptedVerifierHash[] = new byte[header.getCipherAlgorithm().encryptedVerifierHashLength];
        is.readFully(encryptedVerifierHash);
        setEncryptedVerifierHash(encryptedVerifierHash);

        setSpinCount(SPIN_COUNT);
        setCipherAlgorithm(header.getCipherAlgorithm());
        setChainingMode(header.getChainingMode());
        setEncryptedKey(null);
        setHashAlgorithm(header.getHashAlgorithmEx()); 
    }
    
    protected StandardEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setChainingMode(chainingMode);
        setSpinCount(SPIN_COUNT);
        verifierHashSize = hashAlgorithm.hashSize;
    }

    
    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != 16) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setSalt(salt);
    }
    
    
    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    
    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }
    
    public void write(LittleEndianByteArrayOutputStream bos) {
        
        byte salt[] = getSalt();
        assert(salt.length == 16);
        bos.writeInt(salt.length); 
        bos.write(salt);
        
        
        byte encryptedVerifier[] = getEncryptedVerifier(); 
        assert(encryptedVerifier.length == 16);
        bos.write(encryptedVerifier);

        
        
        bos.writeInt(20);

        
        
        
        
        
        
        byte encryptedVerifierHash[] = getEncryptedVerifierHash(); 
        assert(encryptedVerifierHash.length == getCipherAlgorithm().encryptedVerifierHashLength);
        bos.write(encryptedVerifierHash);
    }

    protected int getVerifierHashSize() {
        return verifierHashSize;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.standard;

import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;





import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.Decryptor;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.util.BoundedInputStream;
import org.docx4j.org.apache.poi.util.LittleEndian;


public class StandardDecryptor extends Decryptor {
    private long _length = -1;

    protected StandardDecryptor(EncryptionInfoBuilder builder) {
        super(builder);
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver, getKeySizeInBytes());
        Cipher cipher = getCipher(skey);

        try {
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = cipher.doFinal(encryptedVerifier);
            setVerifier(verifier);
            MessageDigest sha1 = CryptoFunctions.getMessageDigest(ver.getHashAlgorithm());
            byte[] calcVerifierHash = sha1.digest(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte decryptedVerifierHash[] = cipher.doFinal(encryptedVerifierHash);

            
            
            
            byte[] verifierHash = Arrays.copyOf(decryptedVerifierHash, calcVerifierHash.length);
    
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            } else {
                return false;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }
    
    protected static SecretKey generateSecretKey(String password, EncryptionVerifier ver, int keySize) {
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();

        byte pwHash[] = hashPassword(password, hashAlgo, ver.getSalt(), ver.getSpinCount());

        byte[] blockKey = new byte[4];
        LittleEndian.putInt(blockKey, 0, 0);

        byte[] finalHash = CryptoFunctions.generateKey(pwHash, hashAlgo, blockKey, hashAlgo.hashSize);
        byte x1[] = fillAndXor(finalHash, (byte) 0x36);
        byte x2[] = fillAndXor(finalHash, (byte) 0x5c);

        byte[] x3 = new byte[x1.length + x2.length];
        System.arraycopy(x1, 0, x3, 0, x1.length);
        System.arraycopy(x2, 0, x3, x1.length, x2.length);
        
        byte[] key = Arrays.copyOf(x3, keySize);

        SecretKey skey = new SecretKeySpec(key, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    protected static byte[] fillAndXor(byte hash[], byte fillByte) {
        byte[] buff = new byte[64];
        Arrays.fill(buff, fillByte);

        for (int i=0; i<hash.length; i++) {
            buff[i] = (byte) (buff[i] ^ hash[i]);
        }

        MessageDigest sha1 = CryptoFunctions.getMessageDigest(HashAlgorithm.sha1);
        return sha1.digest(buff);
    }

    private Cipher getCipher(SecretKey key) {
        EncryptionHeader em = builder.getHeader();
        ChainingMode cm = em.getChainingMode();
        assert(cm == ChainingMode.ecb);
        return CryptoFunctions.getCipher(key, em.getCipherAlgorithm(), cm, null, Cipher.DECRYPT_MODE);
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);

        _length = dis.readLong();

        
        
        
        int blockSize = builder.getHeader().getCipherAlgorithm().blockSize;
        long cipherLen = (_length/blockSize + 1) * blockSize;
        Cipher cipher = getCipher(getSecretKey());
        
        InputStream boundedDis = new BoundedInputStream(dis, cipherLen);
        return new BoundedInputStream(new CipherInputStream(boundedDis, cipher), _length);
    }

    
    public long getLength(){
        if(_length == -1) throw new IllegalStateException("Decryptor.getDataStream() was not called");
        return _length;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.standard;

import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;

public interface EncryptionRecord {
    void write(LittleEndianByteArrayOutputStream os);
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.standard;

import static org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils.createEncryptionEntry;
import static org.docx4j.org.apache.poi.poifs.crypt.standard.StandardDecryptor.generateSecretKey;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;





import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.Encryptor;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.docx4j.org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.LittleEndianOutputStream;
import org.docx4j.org.apache.poi.util.TempFile;

public class StandardEncryptor extends Encryptor {
    private final StandardEncryptionInfoBuilder builder;
    
    protected StandardEncryptor(StandardEncryptionInfoBuilder builder) {
        this.builder = builder;
    }    

    public void confirmPassword(String password) {
        
        Random r = new SecureRandom();
        byte[] salt = new byte[16], verifier = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        
        confirmPassword(password, null, null, salt, verifier, null);
    }
    
    
    
    public void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]) {
        StandardEncryptionVerifier ver = builder.getVerifier();

        ver.setSalt(verifierSalt);
        SecretKey secretKey = generateSecretKey(password, ver, getKeySizeInBytes());
        setSecretKey(secretKey);
        Cipher cipher = getCipher(secretKey, null);
        
        try {
            byte encryptedVerifier[] = cipher.doFinal(verifier); 
            MessageDigest hashAlgo = CryptoFunctions.getMessageDigest(ver.getHashAlgorithm());
            byte calcVerifierHash[] = hashAlgo.digest(verifier);
            
            
            
            
            
            
            
            
            int encVerHashSize = ver.getCipherAlgorithm().encryptedVerifierHashLength; 
            byte encryptedVerifierHash[] = cipher.doFinal(Arrays.copyOf(calcVerifierHash, encVerHashSize));
    
            ver.setEncryptedVerifier(encryptedVerifier);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
        
    }

    private Cipher getCipher(SecretKey key, String padding) {
        EncryptionVerifier ver = builder.getVerifier();
        return CryptoFunctions.getCipher(key, ver.getCipherAlgorithm(), ver.getChainingMode(), null, Cipher.ENCRYPT_MODE, padding);
    }
    
    public OutputStream getDataStream(final DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        createEncryptionInfoEntry(dir);
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        OutputStream countStream = new StandardCipherOutputStream(dir);
        return countStream;
    }
    
    protected class StandardCipherOutputStream extends FilterOutputStream implements POIFSWriterListener {
        protected long countBytes;
        protected final File fileOut;
        protected final DirectoryNode dir;
        
        protected StandardCipherOutputStream(DirectoryNode dir) throws IOException {
            super(null);

            this.dir = dir;
            fileOut = TempFile.createTempFile("encrypted_package", "crypt");
            FileOutputStream rawStream = new FileOutputStream(fileOut);

            
            
            
            
            
            
            
            
            
            
            CipherOutputStream cryptStream = new CipherOutputStream(rawStream, getCipher(getSecretKey(), "PKCS5Padding"));
            
            this.out = cryptStream;
        }
        
        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
            countBytes += len;
        }

        @Override
        public void write(int b) throws IOException {
            out.write(b);
            countBytes++;
        }
    
        public void close() throws IOException {
            
            super.close(); 
            writeToPOIFS();
        }
        
        void writeToPOIFS() throws IOException {
            int oleStreamSize = (int)(fileOut.length()+LittleEndianConsts.LONG_SIZE);
            dir.createDocument(DEFAULT_POIFS_ENTRY, oleStreamSize, this);
            
        }
    
        public void processPOIFSWriterEvent(POIFSWriterEvent event) {
            try {
                LittleEndianOutputStream leos = new LittleEndianOutputStream(event.getStream());

                
                
                
                
                leos.writeLong(countBytes);

                FileInputStream fis = new FileInputStream(fileOut);
                IOUtils.copy(fis, leos);
                fis.close();
                fileOut.delete();

                leos.close();
            } catch (IOException e) {
                throw new EncryptedDocumentException(e);
            }
        }
    }
    
    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize()/8;
    }
    
    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        final EncryptionInfo info = builder.getEncryptionInfo();
        final StandardEncryptionHeader header = builder.getHeader();
        final StandardEncryptionVerifier verifier = builder.getVerifier();
        
        EncryptionRecord er = new EncryptionRecord(){
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                bos.writeInt(info.getEncryptionFlags());
                header.write(bos);
                verifier.write(bos);
            }
        };
        
        createEncryptionEntry(dir, "EncryptionInfo", er);
        
        
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.standard;

import java.io.IOException;





import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class StandardEncryptionInfoBuilder implements EncryptionInfoBuilder {
    
    EncryptionInfo info;
    StandardEncryptionHeader header;
    StandardEncryptionVerifier verifier;
    StandardDecryptor decryptor;
    StandardEncryptor encryptor;

    
    public void initialize(EncryptionInfo info, LittleEndianInput dis) throws IOException {
        this.info = info;
        
        @SuppressWarnings("unused")
        int hSize = dis.readInt();
        header = new StandardEncryptionHeader(dis);
        verifier = new StandardEncryptionVerifier(dis, header);

        if (info.getVersionMinor() == 2 && (info.getVersionMajor() == 3 || info.getVersionMajor() == 4)) {
            decryptor = new StandardDecryptor(this);
        }
    }
    
    
    public void initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;

        if (cipherAlgorithm == null) {
            cipherAlgorithm = CipherAlgorithm.aes128;
        }
        if (cipherAlgorithm != CipherAlgorithm.aes128 &&
            cipherAlgorithm != CipherAlgorithm.aes192 &&
            cipherAlgorithm != CipherAlgorithm.aes256) {
            throw new EncryptedDocumentException("Standard encryption only supports AES128/192/256.");
        }
        
        if (hashAlgorithm == null) {
            hashAlgorithm = HashAlgorithm.sha1;
        }
        if (hashAlgorithm != HashAlgorithm.sha1) {
            throw new EncryptedDocumentException("Standard encryption only supports SHA-1.");
        }
        if (chainingMode == null) {
            chainingMode = ChainingMode.ecb;
        }
        if (chainingMode != ChainingMode.ecb) {
            throw new EncryptedDocumentException("Standard encryption only supports ECB chaining.");
        }
        if (keyBits == -1) {
            keyBits = cipherAlgorithm.defaultKeySize;
        }
        if (blockSize == -1) {
            blockSize = cipherAlgorithm.blockSize;
        }
        boolean found = false;
        for (int ks : cipherAlgorithm.allowedKeySize) {
            found |= (ks == keyBits);
        }
        if (!found) {
            throw new EncryptedDocumentException("KeySize "+keyBits+" not allowed for Cipher "+cipherAlgorithm.toString());
        }
        header = new StandardEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new StandardEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new StandardDecryptor(this);
        encryptor = new StandardEncryptor(this);
    }

    public StandardEncryptionHeader getHeader() {
        return header;
    }

    public StandardEncryptionVerifier getVerifier() {
        return verifier;
    }

    public StandardDecryptor getDecryptor() {
        return decryptor;
    }

    public StandardEncryptor getEncryptor() {
        return encryptor;
    }
    
    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.standard;

import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo.flagAES;
import static org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo.flagCryptoAPI;

import java.io.IOException;
import java.io.InputStream;

import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.CipherProvider;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;
import org.docx4j.org.apache.poi.util.LittleEndianInput;
import org.docx4j.org.apache.poi.util.LittleEndianOutput;
import org.docx4j.org.apache.poi.util.StringUtil;

public class StandardEncryptionHeader extends EncryptionHeader implements EncryptionRecord {

    protected StandardEncryptionHeader(LittleEndianInput is) throws IOException {
        setFlags(is.readInt());
        setSizeExtra(is.readInt());
        setCipherAlgorithm(CipherAlgorithm.fromEcmaId(is.readInt()));
        setHashAlgorithm(HashAlgorithm.fromEcmaId(is.readInt()));
        int keySize = is.readInt();
        if (keySize == 0) {
            
            
            
            keySize = 0x28;
        }
        setKeySize(keySize);
        setBlockSize(getKeySize());
        setCipherProvider(CipherProvider.fromEcmaId(is.readInt()));

        is.readLong(); 

        
        
        ((InputStream)is).mark(LittleEndianConsts.INT_SIZE+1);
        int checkForSalt = is.readInt();
        ((InputStream)is).reset();
        
        if (checkForSalt == 16) {
            setCspName("");
        } else {
            StringBuilder builder = new StringBuilder();
            while (true) {
                char c = (char) is.readShort();
                if (c == 0) break;
                builder.append(c);
            }
            setCspName(builder.toString());
        }
        
        setChainingMode(ChainingMode.ecb);
        setKeySalt(null);
    }

    protected StandardEncryptionHeader(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setKeySize(keyBits);
        setBlockSize(blockSize);
        setCipherProvider(cipherAlgorithm.provider);
        setFlags(flagCryptoAPI.setBoolean(0, true)
                | flagAES.setBoolean(0, cipherAlgorithm.provider == CipherProvider.aes));
        
        
    }
    
    
    public void write(LittleEndianByteArrayOutputStream bos) {
        int startIdx = bos.getWriteIndex();
        LittleEndianOutput sizeOutput = bos.createDelayedOutput(LittleEndianConsts.INT_SIZE);
        bos.writeInt(getFlags());
        bos.writeInt(0); 
        bos.writeInt(getCipherAlgorithm().ecmaId);
        bos.writeInt(getHashAlgorithmEx().ecmaId);
        bos.writeInt(getKeySize());
        bos.writeInt(getCipherProvider().ecmaId);
        bos.writeInt(0); 
        bos.writeInt(0); 
        String cspName = getCspName();
        if (cspName == null) cspName = getCipherProvider().cipherProviderName;
        bos.write(StringUtil.getToUnicodeLE(cspName));
        bos.writeShort(0);
        int headerSize = bos.getWriteIndex()-startIdx-LittleEndianConsts.INT_SIZE;
        sizeOutput.writeInt(headerSize);        
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.cryptoapi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;





import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.hpsf.DocumentSummaryInformation;
import org.docx4j.org.apache.poi.hpsf.PropertySetFactory;
import org.docx4j.org.apache.poi.hpsf.SummaryInformation;
import org.docx4j.org.apache.poi.hpsf.WritingNotSupportedException;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.Encryptor;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIDecryptor.StreamDescriptorEntry;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.StringUtil;

public class CryptoAPIEncryptor extends Encryptor {
    private final CryptoAPIEncryptionInfoBuilder builder;

    protected CryptoAPIEncryptor(CryptoAPIEncryptionInfoBuilder builder) {
        this.builder = builder;
    }

    public void confirmPassword(String password) {
        Random r = new SecureRandom();
        byte salt[] = new byte[16];
        byte verifier[] = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        confirmPassword(password, null, null, verifier, salt, null);
    }

    public void confirmPassword(String password, byte keySpec[],
            byte keySalt[], byte verifier[], byte verifierSalt[],
            byte integritySalt[]) {
        assert(verifier != null && verifierSalt != null);
        CryptoAPIEncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        SecretKey skey = CryptoAPIDecryptor.generateSecretKey(password, ver);
        setSecretKey(skey);
        try {
            Cipher cipher = initCipherForBlock(null, 0);
            byte encryptedVerifier[] = new byte[verifier.length];
            cipher.update(verifier, 0, verifier.length, encryptedVerifier);
            ver.setEncryptedVerifier(encryptedVerifier);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            byte encryptedVerifierHash[] = cipher.doFinal(calcVerifierHash);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
    }

    
    public Cipher initCipherForBlock(Cipher cipher, int block)
    throws GeneralSecurityException {
        return CryptoAPIDecryptor.initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
    }    
    
    
    public OutputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        CipherByteArrayOutputStream bos = new CipherByteArrayOutputStream();
        byte buf[] = new byte[8];
        
        bos.write(buf, 0, 8); 
        String entryNames[] = {
            SummaryInformation.DEFAULT_STREAM_NAME,
            DocumentSummaryInformation.DEFAULT_STREAM_NAME
        };
        
        List<StreamDescriptorEntry> descList = new ArrayList<StreamDescriptorEntry>();

        int block = 0;
        for (String entryName : entryNames) {
            if (!dir.hasEntry(entryName)) continue;
            StreamDescriptorEntry descEntry = new StreamDescriptorEntry();
            descEntry.block = block;
            descEntry.streamOffset = bos.size();
            descEntry.streamName = entryName;
            descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);
            descEntry.reserved2 = 0;
            
            bos.setBlock(block);
            DocumentInputStream dis = dir.createDocumentInputStream(entryName);
            IOUtils.copy(dis, bos);
            dis.close();
            
            descEntry.streamSize = bos.size() - descEntry.streamOffset;
            descList.add(descEntry);
            
            dir.getEntry(entryName).delete();
            
            block++;
        }
        
        int streamDescriptorArrayOffset = bos.size();
        
        bos.setBlock(0);
        LittleEndian.putUInt(buf, 0, descList.size());
        bos.write(buf, 0, 4);
        
        for (StreamDescriptorEntry sde : descList) {
            LittleEndian.putUInt(buf, 0, sde.streamOffset);
            bos.write(buf, 0, 4);
            LittleEndian.putUInt(buf, 0, sde.streamSize);
            bos.write(buf, 0, 4);
            LittleEndian.putUShort(buf, 0, sde.block);
            bos.write(buf, 0, 2);
            LittleEndian.putUByte(buf, 0, (short)sde.streamName.length());
            bos.write(buf, 0, 1);
            LittleEndian.putUByte(buf, 0, (short)sde.flags);
            bos.write(buf, 0, 1);
            LittleEndian.putUInt(buf, 0, sde.reserved2);
            bos.write(buf, 0, 4);
            byte nameBytes[] = StringUtil.getToUnicodeLE(sde.streamName);
            bos.write(nameBytes, 0, nameBytes.length);
            LittleEndian.putShort(buf, 0, (short)0); 
            bos.write(buf, 0, 2);
        }
        
        int savedSize = bos.size();
        int streamDescriptorArraySize = savedSize - streamDescriptorArrayOffset;
        LittleEndian.putUInt(buf, 0, streamDescriptorArrayOffset);
        LittleEndian.putUInt(buf, 4, streamDescriptorArraySize);

        bos.reset();
        bos.setBlock(0);
        bos.write(buf, 0, 8);
        bos.setSize(savedSize);
        
        dir.createDocument("EncryptedSummary", new ByteArrayInputStream(bos.getBuf(), 0, savedSize));
        DocumentSummaryInformation dsi = PropertySetFactory.newDocumentSummaryInformation();
        
        try {
            dsi.write(dir, DocumentSummaryInformation.DEFAULT_STREAM_NAME);
        } catch (WritingNotSupportedException e) {
            throw new IOException(e);
        }
        
        return bos;
    }

    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize() / 8;
    }

    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        final EncryptionInfo info = builder.getEncryptionInfo();
        final CryptoAPIEncryptionHeader header = builder.getHeader();
        final CryptoAPIEncryptionVerifier verifier = builder.getVerifier();
        EncryptionRecord er = new EncryptionRecord() {
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                header.write(bos);
                verifier.write(bos);
            }
        };
        DataSpaceMapUtils.createEncryptionEntry(dir, "EncryptionInfo", er);
    }

    private class CipherByteArrayOutputStream extends ByteArrayOutputStream {
        Cipher cipher;
        byte oneByte[] = { 0 };

        public CipherByteArrayOutputStream() throws GeneralSecurityException {
            setBlock(0);
        }
        
        public byte[] getBuf() {
            return buf;
        }
        
        public void setSize(int count) {
            this.count = count;
        }
        
        public void setBlock(int block) throws GeneralSecurityException {
            cipher = initCipherForBlock(cipher, block);
        }
        
        public void write(int b) {
            try {
                oneByte[0] = (byte)b;
                cipher.update(oneByte, 0, 1, oneByte, 0);
                super.write(oneByte);
            } catch (Exception e) {
                throw new EncryptedDocumentException(e);
            }
        }

        public void write(byte[] b, int off, int len) {
            try {
                cipher.update(b, off, len, b, off);
                super.write(b, off, len);
            } catch (Exception e) {
                throw new EncryptedDocumentException(e);
            }
        }

    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.cryptoapi;

import java.io.IOException;

import org.docx4j.org.apache.poi.poifs.crypt.*;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionInfoBuilder implements EncryptionInfoBuilder {
    EncryptionInfo info;
    CryptoAPIEncryptionHeader header;
    CryptoAPIEncryptionVerifier verifier;
    CryptoAPIDecryptor decryptor;
    CryptoAPIEncryptor encryptor;

    public CryptoAPIEncryptionInfoBuilder() {
    }

    
    @SuppressWarnings("unused")
    public void initialize(EncryptionInfo info, LittleEndianInput dis)
    throws IOException {
        this.info = info;
        int hSize = dis.readInt();
        header = new CryptoAPIEncryptionHeader(dis);
        verifier = new CryptoAPIEncryptionVerifier(dis, header);
        decryptor = new CryptoAPIDecryptor(this);
        encryptor = new CryptoAPIEncryptor(this);
    }

    
    public void initialize(EncryptionInfo info,
            CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm,
            int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;
        if (cipherAlgorithm == null) cipherAlgorithm = CipherAlgorithm.rc4;
        if (hashAlgorithm == null) hashAlgorithm = HashAlgorithm.sha1;
        if (keyBits == -1) keyBits = 0x28; 
        assert(cipherAlgorithm == CipherAlgorithm.rc4 && hashAlgorithm == HashAlgorithm.sha1);
        
        header = new CryptoAPIEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new CryptoAPIEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new CryptoAPIDecryptor(this);
        encryptor = new CryptoAPIEncryptor(this);
    }

    public CryptoAPIEncryptionHeader getHeader() {
        return header;
    }

    public CryptoAPIEncryptionVerifier getVerifier() {
        return verifier;
    }

    public CryptoAPIDecryptor getDecryptor() {
        return decryptor;
    }

    public CryptoAPIEncryptor getEncryptor() {
        return encryptor;
    }

    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.cryptoapi;

import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.standard.StandardEncryptionVerifier;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionVerifier extends StandardEncryptionVerifier {

    protected CryptoAPIEncryptionVerifier(LittleEndianInput is,
            CryptoAPIEncryptionHeader header) {
        super(is, header);
    }

    protected CryptoAPIEncryptionVerifier(CipherAlgorithm cipherAlgorithm,
            HashAlgorithm hashAlgorithm, int keyBits, int blockSize,
            ChainingMode chainingMode) {
        super(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }

    protected void setSalt(byte salt[]) {
        super.setSalt(salt);
    }

    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.cryptoapi;

import java.io.IOException;





import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.CipherProvider;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.standard.StandardEncryptionHeader;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionHeader extends StandardEncryptionHeader {

    public CryptoAPIEncryptionHeader(LittleEndianInput is) throws IOException {
        super(is);
    }

    protected CryptoAPIEncryptionHeader(CipherAlgorithm cipherAlgorithm,
            HashAlgorithm hashAlgorithm, int keyBits, int blockSize,
            ChainingMode chainingMode) {
        super(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }

    public void setKeySize(int keyBits) {
        
        
        boolean found = false;
        for (int size : getCipherAlgorithm().allowedKeySize) {
            if (size == keyBits) {
                found = true;
                break;
            }
        }
        if (!found) {
            throw new EncryptedDocumentException("invalid keysize "+keyBits+" for cipher algorithm "+getCipherAlgorithm());
        }
        super.setKeySize(keyBits);
        if (keyBits > 40) {
            setCspName("Microsoft Enhanced Cryptographic Provider v1.0");
        } else {
            setCspName(CipherProvider.rc4.cipherProviderName);
        }
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.cryptoapi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.SecretKeySpec;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.Decryptor;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentNode;
import org.docx4j.org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.docx4j.org.apache.poi.util.BitField;
import org.docx4j.org.apache.poi.util.BitFieldFactory;
import org.docx4j.org.apache.poi.util.BoundedInputStream;
import org.docx4j.org.apache.poi.util.IOUtils;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianInputStream;
import org.docx4j.org.apache.poi.util.StringUtil;

public class CryptoAPIDecryptor extends Decryptor {

    private long _length;
    
    private class SeekableByteArrayInputStream extends ByteArrayInputStream {
        Cipher cipher;
        byte oneByte[] = { 0 };
        
        public void seek(int pos) {
            if (pos > count) {
                throw new ArrayIndexOutOfBoundsException(pos);
            }
            
            this.pos = pos;
            mark = pos;
        }

        public void setBlock(int block) throws GeneralSecurityException {
            cipher = initCipherForBlock(cipher, block);
        }

        public synchronized int read() {
            int ch = super.read();
            if (ch == -1) return -1;
            oneByte[0] = (byte) ch;
            try {
                cipher.update(oneByte, 0, 1, oneByte);
            } catch (ShortBufferException e) {
                throw new EncryptedDocumentException(e);
            }
            return oneByte[0];
        }

        public synchronized int read(byte b[], int off, int len) {
            int readLen = super.read(b, off, len);
            if (readLen ==-1) return -1;
            try {
                cipher.update(b, off, readLen, b, off);
            } catch (ShortBufferException e) {
                throw new EncryptedDocumentException(e);
            }
            return readLen;
        }

        public SeekableByteArrayInputStream(byte buf[])
        throws GeneralSecurityException {
            super(buf);
            cipher = initCipherForBlock(null, 0);
        }
    }

    static class StreamDescriptorEntry {
        static BitField flagStream = BitFieldFactory.getInstance(1);
        
        int streamOffset;
        int streamSize;
        int block;
        int flags;
        int reserved2;
        String streamName;
    }

    protected CryptoAPIDecryptor(CryptoAPIEncryptionInfoBuilder builder) {
        super(builder);
        _length = -1L;
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver);
        try {
            Cipher cipher = initCipherForBlock(null, 0, builder, skey, Cipher.DECRYPT_MODE);
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = new byte[encryptedVerifier.length];
            cipher.update(encryptedVerifier, 0, encryptedVerifier.length, verifier);
            setVerifier(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte verifierHash[] = cipher.doFinal(encryptedVerifierHash);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
        return false;
    }

    
    public Cipher initCipherForBlock(Cipher cipher, int block)
    throws GeneralSecurityException {
        return initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.DECRYPT_MODE);
    }

    protected static Cipher initCipherForBlock(Cipher cipher, int block,
        EncryptionInfoBuilder builder, SecretKey skey, int encryptMode)
    throws GeneralSecurityException {
        EncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte blockKey[] = new byte[4];
        LittleEndian.putUInt(blockKey, 0, block);
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        hashAlg.update(skey.getEncoded());
        byte encKey[] = hashAlg.digest(blockKey);
        EncryptionHeader header = builder.getHeader();
        int keyBits = header.getKeySize();
        encKey = CryptoFunctions.getBlock0(encKey, keyBits / 8);
        if (keyBits == 40) {
            encKey = CryptoFunctions.getBlock0(encKey, 16);
        }
        SecretKey key = new SecretKeySpec(encKey, skey.getAlgorithm());
        if (cipher == null) {
            cipher = CryptoFunctions.getCipher(key, header.getCipherAlgorithm(), null, null, encryptMode);
        } else {
            cipher.init(encryptMode, key);
        }
        return cipher;
    }

    protected static SecretKey generateSecretKey(String password, EncryptionVerifier ver) {
        if (password.length() > 255) {
            password = password.substring(0, 255);
        }
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        hashAlg.update(ver.getSalt());
        byte hash[] = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        SecretKey skey = new SecretKeySpec(hash, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    
    @SuppressWarnings("unused")
    public InputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        NPOIFSFileSystem fsOut = new NPOIFSFileSystem();
        DocumentNode es = (DocumentNode) dir.getEntry("EncryptedSummary");
        DocumentInputStream dis = dir.createDocumentInputStream(es);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        IOUtils.copy(dis, bos);
        dis.close();
        SeekableByteArrayInputStream sbis = new SeekableByteArrayInputStream(bos.toByteArray());
        LittleEndianInputStream leis = new LittleEndianInputStream(sbis);
        int streamDescriptorArrayOffset = (int) leis.readUInt();
        int streamDescriptorArraySize = (int) leis.readUInt();
        sbis.skip(streamDescriptorArrayOffset - 8);
        sbis.setBlock(0);
        int encryptedStreamDescriptorCount = (int) leis.readUInt();
        StreamDescriptorEntry entries[] = new StreamDescriptorEntry[encryptedStreamDescriptorCount];
        for (int i = 0; i < encryptedStreamDescriptorCount; i++) {
            StreamDescriptorEntry entry = new StreamDescriptorEntry();
            entries[i] = entry;
            entry.streamOffset = (int) leis.readUInt();
            entry.streamSize = (int) leis.readUInt();
            entry.block = leis.readUShort();
            int nameSize = leis.readUByte();
            entry.flags = leis.readUByte();
            boolean isStream = StreamDescriptorEntry.flagStream.isSet(entry.flags);
            entry.reserved2 = leis.readInt();
            entry.streamName = StringUtil.readUnicodeLE(leis, nameSize);
            leis.readShort();
            assert(entry.streamName.length() == nameSize);
        }

        for (StreamDescriptorEntry entry : entries) {
            sbis.seek(entry.streamOffset);
            sbis.setBlock(entry.block);
            InputStream is = new BoundedInputStream(sbis, entry.streamSize);
            fsOut.createDocument(is, entry.streamName);
        }

        leis.close();
        sbis = null;
        bos.reset();
        fsOut.writeFilesystem(bos);
        fsOut.close();
        _length = bos.size();
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        return bis;
    }

    
    public long getLength() {
        if (_length == -1L) {
            throw new IllegalStateException("Decryptor.getDataStream() was not called");
        }
        return _length;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.agile;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.bind.JAXBException;





import org.apache.commons.io.IOUtils;
import org.docx4j.XmlUtils;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption;
import org.docx4j.jaxb.Context;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionMode;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.util.LittleEndianInput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class AgileEncryptionInfoBuilder implements EncryptionInfoBuilder {
	
	private static Logger log = LoggerFactory.getLogger(AgileEncryptionInfoBuilder.class);
	
    
    EncryptionInfo info;
    AgileEncryptionHeader header;
    AgileEncryptionVerifier verifier;
    AgileDecryptor decryptor;
    AgileEncryptor encryptor;

    public void initialize(EncryptionInfo info, LittleEndianInput dis) throws IOException {
        this.info = info;
        
        EncryptionDocument ed = parseDescriptor((InputStream)dis);
        header = new AgileEncryptionHeader(ed);
        verifier = new AgileEncryptionVerifier(ed);
        if (info.getVersionMajor() == EncryptionMode.agile.versionMajor
            && info.getVersionMinor() == EncryptionMode.agile.versionMinor) {
            decryptor = new AgileDecryptor(this);
            encryptor = new AgileEncryptor(this);
        }
    }

    public void initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;

        if (cipherAlgorithm == null) {
            cipherAlgorithm = CipherAlgorithm.aes128;
        }
        if (cipherAlgorithm == CipherAlgorithm.rc4) {
            throw new EncryptedDocumentException("RC4 must not be used with agile encryption.");
        }
        if (hashAlgorithm == null) {
            hashAlgorithm = HashAlgorithm.sha1;
        }
        if (chainingMode == null) {
            chainingMode = ChainingMode.cbc;
        }
        if (!(chainingMode == ChainingMode.cbc || chainingMode == ChainingMode.cfb)) {
            throw new EncryptedDocumentException("Agile encryption only supports CBC/CFB chaining.");
        }
        if (keyBits == -1) {
            keyBits = cipherAlgorithm.defaultKeySize;
        }
        if (blockSize == -1) {
            blockSize = cipherAlgorithm.blockSize;
        }
        boolean found = false;
        for (int ks : cipherAlgorithm.allowedKeySize) {
            found |= (ks == keyBits);
        }
        if (!found) {
            throw new EncryptedDocumentException("KeySize "+keyBits+" not allowed for Cipher "+cipherAlgorithm.toString());
        }
        header = new AgileEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new AgileEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new AgileDecryptor(this);
        encryptor = new AgileEncryptor(this);
    }
    
    public AgileEncryptionHeader getHeader() {
        return header;
    }

    public AgileEncryptionVerifier getVerifier() {
        return verifier;
    }

    public AgileDecryptor getDecryptor() {
        return decryptor;
    }

    public AgileEncryptor getEncryptor() {
        return encryptor;
    }

    protected EncryptionInfo getInfo() {
        return info;
    }
    
    protected static EncryptionDocument parseDescriptor(String descriptor) {





    	
    	log.error(descriptor);
        
        CTEncryption encryption = null;
		try {
			encryption = (CTEncryption)XmlUtils.unmarshalString(descriptor, Context.jcEncryption, CTEncryption.class);
		} catch (JAXBException e) {
			
			e.printStackTrace();
		}
        EncryptionDocument ed = new EncryptionDocument();
        ed.setEncryption(encryption);
        return ed;
        
    }

    protected static EncryptionDocument parseDescriptor(InputStream descriptor) {





    	







        
        CTEncryption encryption = null;
		try {
			encryption = (CTEncryption)XmlUtils.unwrap(
					XmlUtils.unmarshal(descriptor, Context.jcEncryption));
		} catch (JAXBException e) {
			
			e.printStackTrace();
		}
        EncryptionDocument ed = new EncryptionDocument();
        ed.setEncryption(encryption);
        return ed;
        
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.agile;

import java.io.ByteArrayInputStream;
import java.security.GeneralSecurityException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptor;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate.CTCertificateKeyEncryptor;
import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;


public class AgileEncryptionVerifier extends EncryptionVerifier {

    public static class AgileCertificateEntry {
        X509Certificate x509;
        byte encryptedKey[];
        byte certVerifier[];
    }
    
    private List<AgileCertificateEntry> certList = new ArrayList<AgileCertificateEntry>();

    public AgileEncryptionVerifier(String descriptor) {
        this(AgileEncryptionInfoBuilder.parseDescriptor(descriptor));
    }
    
    protected AgileEncryptionVerifier(EncryptionDocument ed) {
        Iterator<CTKeyEncryptor> encList = ed.getEncryption().getKeyEncryptors().getKeyEncryptor().iterator();
        CTPasswordKeyEncryptor keyData;
        try {
            keyData = encList.next().getEncryptedPasswordKey();
            if (keyData == null) {
                throw new NullPointerException("encryptedKey not set");
            }
        } catch (Exception e) {
            throw new EncryptedDocumentException("Unable to parse keyData", e);
        }
        
        int keyBits = (int)keyData.getKeyBits();
        
        CipherAlgorithm ca = CipherAlgorithm.fromXmlId(keyData.getCipherAlgorithm().toString(), keyBits);
        setCipherAlgorithm(ca);

        int hashSize = (int)keyData.getHashSize();

        HashAlgorithm ha = HashAlgorithm.fromEcmaId(keyData.getHashAlgorithm().value());
        setHashAlgorithm(ha);

        if (getHashAlgorithm().hashSize != hashSize) {
            throw new EncryptedDocumentException("Unsupported hash algorithm: " + 
                    keyData.getHashAlgorithm().value() + " @ " + hashSize + " bytes");
        }

        setSpinCount((int)keyData.getSpinCount());
        setEncryptedVerifier(keyData.getEncryptedVerifierHashInput());
        setSalt(keyData.getSaltValue());
        setEncryptedKey(keyData.getEncryptedKeyValue()); 
        setEncryptedVerifierHash(keyData.getEncryptedVerifierHashValue());

        int saltSize = (int)keyData.getSaltSize();
        if (saltSize != getSalt().length)
            throw new EncryptedDocumentException("Invalid salt size");
        
        if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CBC) {
            setChainingMode(ChainingMode.cbc);
        } else if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CFB) {
            setChainingMode(ChainingMode.cfb);
        } else {
            throw new EncryptedDocumentException("Unsupported chaining mode - "+keyData.getCipherChaining().toString());
        }
        
        if (!encList.hasNext()) return;
        
        try {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            while (encList.hasNext()) {
                CTCertificateKeyEncryptor certKey = encList.next().getEncryptedCertificateKey();
                AgileCertificateEntry ace = new AgileCertificateEntry();
                ace.certVerifier = certKey.getCertVerifier();
                ace.encryptedKey = certKey.getEncryptedKeyValue();
                ace.x509 = (X509Certificate)cf.generateCertificate(new ByteArrayInputStream(certKey.getX509Certificate()));
                certList.add(ace);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("can't parse X509 certificate", e);
        }
    }
    
    public AgileEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setChainingMode(chainingMode);
        setSpinCount(100000); 
    }
    
    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != getCipherAlgorithm().blockSize) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setSalt(salt);
    }
    
    
    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    
    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }

    
    protected void setEncryptedKey(byte[] encryptedKey) {
        super.setEncryptedKey(encryptedKey);
    }
    
    public void addCertificate(X509Certificate x509) {
        AgileCertificateEntry ace = new AgileCertificateEntry();
        ace.x509 = x509;
        certList.add(ace);
    }
    
    public List<AgileCertificateEntry> getCertificates() {
        return certList;
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.agile;

import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getBlock0;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getCipher;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getMessageDigest;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;
import static org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils.createEncryptionEntry;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.getNextBlockSize;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.hashInput;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.kCryptoKeyBlock;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.kHashedVerifierBlock;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.kIntegrityKeyBlock;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.kIntegrityValueBlock;
import static org.docx4j.org.apache.poi.poifs.crypt.agile.AgileDecryptor.kVerifierInputBlock;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.cert.CertificateEncodingException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;






import org.docx4j.XmlUtils;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTDataIntegrity;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTKeyData;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptor;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptors;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STHashAlgorithm;
import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.certificate.CTCertificateKeyEncryptor;
import org.docx4j.com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor;
import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.NamespacePrefixMapperUtils;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.Encryptor;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.agile.AgileEncryptionVerifier.AgileCertificateEntry;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;





public class AgileEncryptor extends Encryptor {
    private final AgileEncryptionInfoBuilder builder;
    private byte integritySalt[];
	private byte pwHash[];
    
	protected AgileEncryptor(AgileEncryptionInfoBuilder builder) {
		this.builder = builder;
	}

    public void confirmPassword(String password) {
        
        Random r = new SecureRandom();
        int blockSize = builder.getHeader().getBlockSize();
        int keySize = builder.getHeader().getKeySize()/8;
        int hashSize = builder.getHeader().getHashAlgorithmEx().hashSize;
        
        byte[] verifierSalt = new byte[blockSize]
             , verifier = new byte[blockSize]
             , keySalt = new byte[blockSize]
             , keySpec = new byte[keySize]
             , integritySalt = new byte[hashSize];
        r.nextBytes(verifierSalt); 
        r.nextBytes(verifier); 
        r.nextBytes(keySalt); 
        r.nextBytes(keySpec); 
        r.nextBytes(integritySalt); 
        
        confirmPassword(password, keySpec, keySalt, verifierSalt, verifier, integritySalt);
    }
	
	public void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]) {
        AgileEncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        AgileEncryptionHeader header = builder.getHeader();
        header.setKeySalt(keySalt);
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();

        int blockSize = header.getBlockSize();
	    
        pwHash = hashPassword(password, hashAlgo, verifierSalt, ver.getSpinCount());
        
        
        byte encryptedVerifier[] = hashInput(builder, pwHash, kVerifierInputBlock, verifier, Cipher.ENCRYPT_MODE);
        ver.setEncryptedVerifier(encryptedVerifier);
	    

        
        MessageDigest hashMD = getMessageDigest(hashAlgo);
        byte[] hashedVerifier = hashMD.digest(verifier);
        byte encryptedVerifierHash[] = hashInput(builder, pwHash, kHashedVerifierBlock, hashedVerifier, Cipher.ENCRYPT_MODE);
        ver.setEncryptedVerifierHash(encryptedVerifierHash);
        
        
        byte encryptedKey[] = hashInput(builder, pwHash, kCryptoKeyBlock, keySpec, Cipher.ENCRYPT_MODE);
        ver.setEncryptedKey(encryptedKey);
        
        SecretKey secretKey = new SecretKeySpec(keySpec, ver.getCipherAlgorithm().jceId);
        setSecretKey(secretKey);
        
        
        this.integritySalt = integritySalt;

        try {
            byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, header.getBlockSize());
            Cipher cipher = getCipher(secretKey, ver.getCipherAlgorithm(), ver.getChainingMode(), vec, Cipher.ENCRYPT_MODE);
            byte filledSalt[] = getBlock0(integritySalt, getNextBlockSize(integritySalt.length, blockSize));
            byte encryptedHmacKey[] = cipher.doFinal(filledSalt);
            header.setEncryptedHmacKey(encryptedHmacKey);

            cipher = Cipher.getInstance("RSA");
            for (AgileCertificateEntry ace : ver.getCertificates()) {
                cipher.init(Cipher.ENCRYPT_MODE, ace.x509.getPublicKey());
                ace.encryptedKey = cipher.doFinal(getSecretKey().getEncoded());
                Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);
                x509Hmac.init(getSecretKey());
                ace.certVerifier = x509Hmac.doFinal(ace.x509.getEncoded());
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
	}
	
    public OutputStream getDataStream(DirectoryNode dir)
            throws IOException, GeneralSecurityException {
        
        AgileCipherOutputStream countStream = new AgileCipherOutputStream(dir);
    	return countStream;
    }

    
    protected void updateIntegrityHMAC(File tmpFile, int oleStreamSize) throws GeneralSecurityException, IOException {
        
        
        
        AgileEncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        Mac integrityMD = CryptoFunctions.getMac(hashAlgo);
        integrityMD.init(new SecretKeySpec(integritySalt, hashAlgo.jceHmacId));

        byte buf[] = new byte[1024];
        LittleEndian.putLong(buf, 0, oleStreamSize);
        integrityMD.update(buf, 0, LittleEndian.LONG_SIZE);
        
        InputStream fis = new FileInputStream(tmpFile);
        try {
            int readBytes;
            while ((readBytes = fis.read(buf)) != -1) {
                integrityMD.update(buf, 0, readBytes);
            }
        } finally {
        	fis.close();
        }
        
        byte hmacValue[] = integrityMD.doFinal();
        
        AgileEncryptionHeader header = builder.getHeader();
        int blockSize = header.getBlockSize();
        byte iv[] = CryptoFunctions.generateIv(header.getHashAlgorithmEx(), header.getKeySalt(), kIntegrityValueBlock, blockSize);
        Cipher cipher = CryptoFunctions.getCipher(getSecretKey(), header.getCipherAlgorithm(), header.getChainingMode(), iv, Cipher.ENCRYPT_MODE);
        byte hmacValueFilled[] = getBlock0(hmacValue, getNextBlockSize(hmacValue.length, blockSize));
        byte encryptedHmacValue[] = cipher.doFinal(hmacValueFilled);
        
        header.setEncryptedHmacValue(encryptedHmacValue);
    }





    
    static final String HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_PASSWORD = "http:
    static final String HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_CERTIFICATE = "http:

    
    private final String passwordUri = 
        HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_PASSWORD;
    private final String certificateUri = 
        HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_CERTIFICATE;
    
    protected EncryptionDocument createEncryptionDocument() {
        AgileEncryptionVerifier ver = builder.getVerifier();
        AgileEncryptionHeader header = builder.getHeader(); 
        
        EncryptionDocument ed = new EncryptionDocument();
        CTEncryption edRoot = ed.addNewEncryption();
        
        CTKeyData keyData = new CTKeyData();
        edRoot.setKeyData(keyData);
        
        CTKeyEncryptors keyEncList = new CTKeyEncryptors();
        edRoot.setKeyEncryptors(keyEncList);
        
        CTKeyEncryptor keyEnc = new CTKeyEncryptor();
        keyEncList.getKeyEncryptor().add(keyEnc);
        keyEnc.setUri(passwordUri);
        
        CTPasswordKeyEncryptor keyPass = new CTPasswordKeyEncryptor();
        keyEnc.setEncryptedPasswordKey(keyPass);

        keyPass.setSpinCount(ver.getSpinCount());
        
        keyData.setSaltSize(header.getBlockSize());
        keyPass.setSaltSize(header.getBlockSize());
        
        keyData.setBlockSize(header.getBlockSize());
        keyPass.setBlockSize(header.getBlockSize());

        keyData.setKeyBits(header.getKeySize());
        keyPass.setKeyBits(header.getKeySize());

        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        keyData.setHashSize(hashAlgo.hashSize);
        keyPass.setHashSize(hashAlgo.hashSize);

        
        String xmlCipherAlgo = header.getCipherAlgorithm().xmlId;
        if (xmlCipherAlgo == null) {
            throw new EncryptedDocumentException("CipherAlgorithm "+header.getCipherAlgorithm()+" not supported.");
        }
        keyData.setCipherAlgorithm(xmlCipherAlgo);
        keyPass.setCipherAlgorithm(xmlCipherAlgo);
        
        switch (header.getChainingMode()) {
        case cbc: 
            keyData.setCipherChaining(STCipherChaining.CHAINING_MODE_CBC);
            keyPass.setCipherChaining(STCipherChaining.CHAINING_MODE_CBC);
            break;
        case cfb:
            keyData.setCipherChaining(STCipherChaining.CHAINING_MODE_CFB);
            keyPass.setCipherChaining(STCipherChaining.CHAINING_MODE_CFB);
            break;
        default:
            throw new EncryptedDocumentException("ChainingMode "+header.getChainingMode()+" not supported.");
        }
        
        STHashAlgorithm xmlHashAlgo = STHashAlgorithm.fromValue(hashAlgo.ecmaString);
        if (xmlHashAlgo == null) {
            throw new EncryptedDocumentException("HashAlgorithm "+hashAlgo+" not supported.");
        }
        keyData.setHashAlgorithm(xmlHashAlgo);
        keyPass.setHashAlgorithm(xmlHashAlgo);

        keyData.setSaltValue(header.getKeySalt());
        keyPass.setSaltValue(ver.getSalt());
        keyPass.setEncryptedVerifierHashInput(ver.getEncryptedVerifier());
        keyPass.setEncryptedVerifierHashValue(ver.getEncryptedVerifierHash());
        keyPass.setEncryptedKeyValue(ver.getEncryptedKey());
        
        CTDataIntegrity hmacData = new CTDataIntegrity();
        edRoot.setDataIntegrity(hmacData);
        
        hmacData.setEncryptedHmacKey(header.getEncryptedHmacKey());
        hmacData.setEncryptedHmacValue(header.getEncryptedHmacValue());
        
        for (AgileCertificateEntry ace : ver.getCertificates()) {
            keyEnc = new CTKeyEncryptor();
            keyEncList.getKeyEncryptor().add(keyEnc);
            keyEnc.setUri(certificateUri);
            
            CTCertificateKeyEncryptor certData = new CTCertificateKeyEncryptor();
            keyEnc.setEncryptedCertificateKey(certData);
            try {
                certData.setX509Certificate(ace.x509.getEncoded());
            } catch (CertificateEncodingException e) {
                throw new EncryptedDocumentException(e);
            }
            certData.setEncryptedKeyValue(ace.encryptedKey);
            certData.setCertVerifier(ace.certVerifier);
        }
        
        return ed;
    }
    
























    protected void marshallEncryptionDocument(EncryptionDocument ed, LittleEndianByteArrayOutputStream os) {

		try {
			Marshaller marshaller = Context.jcEncryption.createMarshaller();
			marshaller.setProperty("jaxb.formatted.output", false);
			
			NamespacePrefixMapperUtils.setProperty(marshaller, NamespacePrefixMapperUtils.getPrefixMapper());
			

			

			
			

			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			marshaller.marshal(ed.getEncryption(), bos);
			
			os.write(bos.toByteArray());

		} catch (JAXBException e) {
            throw new EncryptedDocumentException("error marshalling encryption info document", e);
		}        
    }
    
    
    
    protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
    throws IOException, GeneralSecurityException {
    	
        DataSpaceMapUtils.addDefaultDataSpace(dir);

        final EncryptionInfo info = builder.getInfo();

        EncryptionRecord er = new EncryptionRecord(){
        	
            public void write(LittleEndianByteArrayOutputStream bos) {
            	
                
                
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                
                bos.writeInt(info.getEncryptionFlags());

                EncryptionDocument ed = createEncryptionDocument();
                marshallEncryptionDocument(ed, bos);
            }
        };
        
        createEncryptionEntry(dir, "EncryptionInfo", er);
    }
    
    
    
    private class AgileCipherOutputStream extends ChunkedCipherOutputStream {
        public AgileCipherOutputStream(DirectoryNode dir) throws IOException, GeneralSecurityException {
            super(dir, 4096);
        }
        
        @Override
        protected Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk)
        throws GeneralSecurityException {
            return AgileDecryptor.initCipherForBlock(existing, block, lastChunk, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
        }

        @Override
        protected void calculateChecksum(File fileOut, int oleStreamSize)
        throws GeneralSecurityException, IOException {
            
            updateIntegrityHMAC(fileOut, oleStreamSize); 
        }
        
        @Override
        protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
        throws IOException, GeneralSecurityException {
            AgileEncryptor.this.createEncryptionInfoEntry(dir, tmpFile);
        }
    }

}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.agile;

import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.generateIv;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.generateKey;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getBlock0;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getCipher;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.getMessageDigest;
import static org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.MessageDigest;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.RC2ParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChunkedCipherInputStream;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.Decryptor;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.agile.AgileEncryptionVerifier.AgileCertificateEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.util.LittleEndian;


public class AgileDecryptor extends Decryptor {
    private long _length = -1;

    protected static final byte[] kVerifierInputBlock;
    protected static final byte[] kHashedVerifierBlock;
    protected static final byte[] kCryptoKeyBlock;
    protected static final byte[] kIntegrityKeyBlock;
    protected static final byte[] kIntegrityValueBlock;

    static {
        kVerifierInputBlock =
            new byte[] { (byte)0xfe, (byte)0xa7, (byte)0xd2, (byte)0x76,
                         (byte)0x3b, (byte)0x4b, (byte)0x9e, (byte)0x79 };
        kHashedVerifierBlock =
            new byte[] { (byte)0xd7, (byte)0xaa, (byte)0x0f, (byte)0x6d,
                         (byte)0x30, (byte)0x61, (byte)0x34, (byte)0x4e };
        kCryptoKeyBlock =
            new byte[] { (byte)0x14, (byte)0x6e, (byte)0x0b, (byte)0xe7,
                         (byte)0xab, (byte)0xac, (byte)0xd0, (byte)0xd6 };
        kIntegrityKeyBlock =
            new byte[] { (byte)0x5f, (byte)0xb2, (byte)0xad, (byte)0x01, 
                         (byte)0x0c, (byte)0xb9, (byte)0xe1, (byte)0xf6 };
        kIntegrityValueBlock =
            new byte[] { (byte)0xa0, (byte)0x67, (byte)0x7f, (byte)0x02,
                         (byte)0xb2, (byte)0x2c, (byte)0x84, (byte)0x33 };
    }

    protected AgileDecryptor(AgileEncryptionInfoBuilder builder) {
        super(builder);
    }
    
    
    public boolean verifyPassword(String password) throws GeneralSecurityException {
        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)builder.getVerifier();
        AgileEncryptionHeader header = (AgileEncryptionHeader)builder.getHeader(); 
        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();
        int blockSize = header.getBlockSize();
        int keySize = header.getKeySize()/8;

        byte[] pwHash = hashPassword(password, ver.getHashAlgorithm(), ver.getSalt(), ver.getSpinCount());

        
        byte verfierInputEnc[] = hashInput(builder, pwHash, kVerifierInputBlock, ver.getEncryptedVerifier(), Cipher.DECRYPT_MODE);
        setVerifier(verfierInputEnc);
        MessageDigest hashMD = getMessageDigest(hashAlgo);
        byte[] verifierHash = hashMD.digest(verfierInputEnc);

        
        byte verifierHashDec[] = hashInput(builder, pwHash, kHashedVerifierBlock, ver.getEncryptedVerifierHash(), Cipher.DECRYPT_MODE);
        verifierHashDec = getBlock0(verifierHashDec, hashAlgo.hashSize);
        
        
        byte keyspec[] = hashInput(builder, pwHash, kCryptoKeyBlock, ver.getEncryptedKey(), Cipher.DECRYPT_MODE);
        keyspec = getBlock0(keyspec, keySize);
        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);

        
        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); 
        Cipher cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        
        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());
        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);

        
        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);
        
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());
        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);
        
        if (Arrays.equals(verifierHashDec, verifierHash)) {
            setSecretKey(secretKey);
            setIntegrityHmacKey(hmacKey);
            setIntegrityHmacValue(hmacValue);
            return true;
        } else {
            return false;
        }
    }

    
    public boolean verifyPassword(KeyPair keyPair, X509Certificate x509) throws GeneralSecurityException {
        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)builder.getVerifier();
        AgileEncryptionHeader header = (AgileEncryptionHeader)builder.getHeader();
        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();
        int blockSize = header.getBlockSize();
        
        AgileCertificateEntry ace = null;
        for (AgileCertificateEntry aceEntry : ver.getCertificates()) {
            if (x509.equals(aceEntry.x509)) {
                ace = aceEntry;
                break;
            }
        }
        if (ace == null) return false;
        
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
        byte keyspec[] = cipher.doFinal(ace.encryptedKey);
        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);
        
        Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);
        x509Hmac.init(secretKey);
        byte certVerifier[] = x509Hmac.doFinal(ace.x509.getEncoded());

        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); 
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());
        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);

        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());
        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);
        
        
        if (Arrays.equals(ace.certVerifier, certVerifier)) {
            setSecretKey(secretKey);
            setIntegrityHmacKey(hmacKey);
            setIntegrityHmacValue(hmacValue);
            return true;
        } else {
            return false;
        }
    }

    protected static int getNextBlockSize(int inputLen, int blockSize) {
        int fillSize;
        for (fillSize=blockSize; fillSize<inputLen; fillSize+=blockSize);
        return fillSize;
    }

    protected static byte[] hashInput(EncryptionInfoBuilder builder, byte pwHash[], byte blockKey[], byte inputKey[], int cipherMode) {
        EncryptionVerifier ver = builder.getVerifier();
        AgileDecryptor dec = (AgileDecryptor)builder.getDecryptor();
        int keySize = dec.getKeySizeInBytes();
        int blockSize = dec.getBlockSizeInBytes();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte[] salt = ver.getSalt();

        byte intermedKey[] = generateKey(pwHash, hashAlgo, blockKey, keySize);
        SecretKey skey = new SecretKeySpec(intermedKey, ver.getCipherAlgorithm().jceId);
        byte[] iv = generateIv(hashAlgo, salt, null, blockSize);
        Cipher cipher = getCipher(skey, ver.getCipherAlgorithm(), ver.getChainingMode(), iv, cipherMode);
        byte[] hashFinal;
        
        try {
            inputKey = getBlock0(inputKey, getNextBlockSize(inputKey.length, blockSize));
            hashFinal = cipher.doFinal(inputKey);
            return hashFinal;
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException, GeneralSecurityException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);
        _length = dis.readLong();
        
        ChunkedCipherInputStream cipherStream = new AgileCipherInputStream(dis, _length);
        return cipherStream;
    }

    public long getLength(){
        if(_length == -1) throw new IllegalStateException("EcmaDecryptor.getDataStream() was not called");
        return _length;
    }


    protected static Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk, EncryptionInfoBuilder builder, SecretKey skey, int encryptionMode)
    throws GeneralSecurityException {
    	
        EncryptionHeader header = builder.getHeader();
        if (existing == null || lastChunk) {
            String padding = (lastChunk ? "PKCS5Padding" : "NoPadding");
            existing = getCipher(skey, header.getCipherAlgorithm(), header.getChainingMode(), 
            		header.getKeySalt(), encryptionMode, padding);
        }

        byte[] blockKey = new byte[4];
        LittleEndian.putInt(blockKey, 0, block);
        byte[] iv = generateIv(header.getHashAlgorithmEx(), header.getKeySalt(), blockKey, header.getBlockSize());

        AlgorithmParameterSpec aps;
        if (header.getCipherAlgorithm() == CipherAlgorithm.rc2) {
            aps = new RC2ParameterSpec(skey.getEncoded().length*8, iv);
        } else {
            aps = new IvParameterSpec(iv);
        }
            
        existing.init(encryptionMode, skey, aps);
        
        return existing;
    }

    
    private class AgileCipherInputStream extends ChunkedCipherInputStream {
        public AgileCipherInputStream(DocumentInputStream stream, long size)
        throws GeneralSecurityException {
            super(stream, size, 4096);
        }

        
        
        
        protected Cipher initCipherForBlock(Cipher cipher, int block)
        throws GeneralSecurityException {
            return AgileDecryptor.initCipherForBlock(cipher, block, false, builder, getSecretKey(), Cipher.DECRYPT_MODE);
        }
    }
}

<code block>

package org.docx4j.org.apache.poi.poifs.crypt.agile;

import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTDataIntegrity;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTKeyData;
import org.docx4j.com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChainingMode;
import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;

public class AgileEncryptionHeader extends EncryptionHeader {
    private byte encryptedHmacKey[], encryptedHmacValue[];
    
    public AgileEncryptionHeader(String descriptor) {
        this(AgileEncryptionInfoBuilder.parseDescriptor(descriptor));
    }
    
    protected AgileEncryptionHeader(EncryptionDocument ed) {
        CTKeyData keyData;
        try {
            keyData = ed.getEncryption().getKeyData();
            if (keyData == null) {
                throw new NullPointerException("keyData not set");
            }
        } catch (Exception e) {
            throw new EncryptedDocumentException("Unable to parse keyData");
        }

        setKeySize((int)keyData.getKeyBits());
        setFlags(0);
        setSizeExtra(0);
        setCspName(null);
        setBlockSize((int)keyData.getBlockSize());

        int keyBits = (int)keyData.getKeyBits();
        
        CipherAlgorithm ca = CipherAlgorithm.fromXmlId(keyData.getCipherAlgorithm().toString(), keyBits);
        setCipherAlgorithm(ca);
        setCipherProvider(ca.provider);

        if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CBC) {
            setChainingMode(ChainingMode.cbc);
        } else if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CFB) {
            setChainingMode(ChainingMode.cfb);
        } else {
            throw new EncryptedDocumentException("Unsupported chaining mode - "+keyData.getCipherChaining().toString());
        }
    
        int hashSize = (int)keyData.getHashSize();
        
        HashAlgorithm ha = HashAlgorithm.fromEcmaId(keyData.getHashAlgorithm().value());
        setHashAlgorithm(ha);

        if (getHashAlgorithmEx().hashSize != hashSize) {
            throw new EncryptedDocumentException("Unsupported hash algorithm: " + 
                    keyData.getHashAlgorithm().value() + " @ " + hashSize + " bytes");
        }

        int saltLength = (int)keyData.getSaltSize();
        setKeySalt(keyData.getSaltValue());
        if (getKeySalt().length != saltLength) {
            throw new EncryptedDocumentException("Invalid salt length");
        }
        
        CTDataIntegrity di = ed.getEncryption().getDataIntegrity();
        setEncryptedHmacKey(di.getEncryptedHmacKey());
        setEncryptedHmacValue(di.getEncryptedHmacValue());
    }
    
    
    public AgileEncryptionHeader(CipherAlgorithm algorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(algorithm);
        setHashAlgorithm(hashAlgorithm);
        setKeySize(keyBits);
        setBlockSize(blockSize);
        setChainingMode(chainingMode);
    }

    
    protected void setKeySalt(byte salt[]) {
        if (salt == null || salt.length != getBlockSize()) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setKeySalt(salt);
    }

    public byte[] getEncryptedHmacKey() {
        return encryptedHmacKey;
    }

    protected void setEncryptedHmacKey(byte[] encryptedHmacKey) {
        this.encryptedHmacKey = encryptedHmacKey;
    }

    public byte[] getEncryptedHmacValue() {
        return encryptedHmacValue;
    }

    protected void setEncryptedHmacValue(byte[] encryptedHmacValue) {
        this.encryptedHmacValue = encryptedHmacValue;
    }
}

<code block>
package org.docx4j.org.apache.poi.poifs.crypt.agile;

import org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption;



public class EncryptionDocument 
{
	CTEncryption  encryption = null;
	
    
    public org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption getEncryption()
    {
    	return encryption;
    }
    
    
    public void setEncryption(org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption encryption)
    {
        this.encryption = encryption;
    }
    
    
    public org.docx4j.com.microsoft.schemas.office.x2006.encryption.CTEncryption addNewEncryption()
    {
    	encryption = new CTEncryption();
    	return encryption;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.binaryrc4;

import java.io.IOException;

import org.docx4j.org.apache.poi.poifs.crypt.*;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class BinaryRC4EncryptionInfoBuilder implements EncryptionInfoBuilder {

    EncryptionInfo info;
    BinaryRC4EncryptionHeader header;
    BinaryRC4EncryptionVerifier verifier;
    BinaryRC4Decryptor decryptor;
    BinaryRC4Encryptor encryptor;

    public BinaryRC4EncryptionInfoBuilder() {
    }

    public void initialize(EncryptionInfo info, LittleEndianInput dis)
    throws IOException {
        this.info = info;
        int vMajor = info.getVersionMajor();
        int vMinor = info.getVersionMinor();
        assert (vMajor == 1 && vMinor == 1);

        header = new BinaryRC4EncryptionHeader();
        verifier = new BinaryRC4EncryptionVerifier(dis);
        decryptor = new BinaryRC4Decryptor(this);
        encryptor = new BinaryRC4Encryptor(this);
    }

    public void initialize(EncryptionInfo info,
        CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm,
        int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;
        header = new BinaryRC4EncryptionHeader();
        verifier = new BinaryRC4EncryptionVerifier();
        decryptor = new BinaryRC4Decryptor(this);
        encryptor = new BinaryRC4Encryptor(this);
    }

    public BinaryRC4EncryptionHeader getHeader() {
        return header;
    }

    public BinaryRC4EncryptionVerifier getVerifier() {
        return verifier;
    }

    public BinaryRC4Decryptor getDecryptor() {
        return decryptor;
    }

    public BinaryRC4Encryptor getEncryptor() {
        return encryptor;
    }

    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.binaryrc4;

import org.docx4j.org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.CipherProvider;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionHeader;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;

public class BinaryRC4EncryptionHeader extends EncryptionHeader implements
        EncryptionRecord {

    protected BinaryRC4EncryptionHeader() {
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setKeySize(40);
        setBlockSize(-1);
        setCipherProvider(CipherProvider.rc4);
        setHashAlgorithm(HashAlgorithm.md5);
        setSizeExtra(0);
        setFlags(0);
        setCspName("");
        setChainingMode(null);
    }

    public void write(LittleEndianByteArrayOutputStream littleendianbytearrayoutputstream) {
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.binaryrc4;


import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.*;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.docx4j.org.apache.poi.util.LittleEndianInput;

public class BinaryRC4EncryptionVerifier extends EncryptionVerifier implements EncryptionRecord {

    protected BinaryRC4EncryptionVerifier() {
        setSpinCount(-1);
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setChainingMode(null);
        setEncryptedKey(null);
        setHashAlgorithm(HashAlgorithm.md5);
    }

    protected BinaryRC4EncryptionVerifier(LittleEndianInput is) {
        byte salt[] = new byte[16];
        is.readFully(salt);
        setSalt(salt);
        byte encryptedVerifier[] = new byte[16];
        is.readFully(encryptedVerifier);
        setEncryptedVerifier(encryptedVerifier);
        byte encryptedVerifierHash[] = new byte[16];
        is.readFully(encryptedVerifierHash);
        setEncryptedVerifierHash(encryptedVerifierHash);
        setSpinCount(-1);
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setChainingMode(null);
        setEncryptedKey(null);
        setHashAlgorithm(HashAlgorithm.md5);
    }

    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != 16) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        
        super.setSalt(salt);
    }

    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }

    public void write(LittleEndianByteArrayOutputStream bos) {
        byte salt[] = getSalt();
        assert (salt.length == 16);
        bos.write(salt);
        byte encryptedVerifier[] = getEncryptedVerifier();
        assert (encryptedVerifier.length == 16);
        bos.write(encryptedVerifier);
        byte encryptedVerifierHash[] = getEncryptedVerifierHash();
        assert (encryptedVerifierHash.length == 16);
        bos.write(encryptedVerifierHash);
    }

}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.binaryrc4;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.*;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.StringUtil;

public class BinaryRC4Decryptor extends Decryptor {
    private long _length = -1L;
    
    private class BinaryRC4CipherInputStream extends ChunkedCipherInputStream {

        protected Cipher initCipherForBlock(Cipher existing, int block)
                throws GeneralSecurityException {
            return BinaryRC4Decryptor.initCipherForBlock(existing, block, builder, getSecretKey(), Cipher.DECRYPT_MODE);
        }

        public BinaryRC4CipherInputStream(DocumentInputStream stream, long size)
                throws GeneralSecurityException {
            super(stream, size, 512);
        }
    }

    protected BinaryRC4Decryptor(BinaryRC4EncryptionInfoBuilder builder) {
        super(builder);
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver);
        try {
            Cipher cipher = initCipherForBlock(null, 0, builder, skey, Cipher.DECRYPT_MODE);
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = new byte[encryptedVerifier.length];
            cipher.update(encryptedVerifier, 0, encryptedVerifier.length, verifier);
            setVerifier(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte verifierHash[] = cipher.doFinal(encryptedVerifierHash);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
        return false;
    }

    protected static Cipher initCipherForBlock(Cipher cipher, int block,
        EncryptionInfoBuilder builder, SecretKey skey, int encryptMode)
    throws GeneralSecurityException {
        EncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte blockKey[] = new byte[4];
        LittleEndian.putUInt(blockKey, 0, block);
        byte encKey[] = CryptoFunctions.generateKey(skey.getEncoded(), hashAlgo, blockKey, 16);
        SecretKey key = new SecretKeySpec(encKey, skey.getAlgorithm());
        if (cipher == null) {
            EncryptionHeader em = builder.getHeader();
            cipher = CryptoFunctions.getCipher(key, em.getCipherAlgorithm(), null, null, encryptMode);
        } else {
            cipher.init(encryptMode, key);
        }
        return cipher;
    }

    protected static SecretKey generateSecretKey(String password,
            EncryptionVerifier ver) {
        if (password.length() > 255)
            password = password.substring(0, 255);
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        byte hash[] = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        byte salt[] = ver.getSalt();
        hashAlg.reset();
        for (int i = 0; i < 16; i++) {
            hashAlg.update(hash, 0, 5);
            hashAlg.update(salt);
        }

        hash = new byte[5];
        System.arraycopy(hashAlg.digest(), 0, hash, 0, 5);
        SecretKey skey = new SecretKeySpec(hash, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException,
            GeneralSecurityException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);
        _length = dis.readLong();
        BinaryRC4CipherInputStream cipherStream = new BinaryRC4CipherInputStream(dis, _length);
        return cipherStream;
    }

    public long getLength() {
        if (_length == -1L) {
            throw new IllegalStateException("Decryptor.getDataStream() was not called");
        }
        
        return _length;
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.crypt.binaryrc4;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;




import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.docx4j.org.apache.poi.poifs.crypt.EncryptionInfo;
import org.docx4j.org.apache.poi.poifs.crypt.Encryptor;
import org.docx4j.org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryNode;
import org.docx4j.org.apache.poi.util.LittleEndianByteArrayOutputStream;

public class BinaryRC4Encryptor extends Encryptor {

    private final BinaryRC4EncryptionInfoBuilder builder;
    
    protected class BinaryRC4CipherOutputStream extends ChunkedCipherOutputStream {

        protected Cipher initCipherForBlock(Cipher cipher, int block, boolean lastChunk)
        throws GeneralSecurityException {
            return BinaryRC4Decryptor.initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
        }

        protected void calculateChecksum(File file, int i) {
        }

        protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
        throws IOException, GeneralSecurityException {
            BinaryRC4Encryptor.this.createEncryptionInfoEntry(dir);
        }

        public BinaryRC4CipherOutputStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException {
            super(dir, 512);
        }
    }

    protected BinaryRC4Encryptor(BinaryRC4EncryptionInfoBuilder builder) {
        this.builder = builder;
    }

    public void confirmPassword(String password) {
        Random r = new SecureRandom();
        byte salt[] = new byte[16];
        byte verifier[] = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        confirmPassword(password, null, null, verifier, salt, null);
    }

    public void confirmPassword(String password, byte keySpec[],
            byte keySalt[], byte verifier[], byte verifierSalt[],
            byte integritySalt[]) {
        BinaryRC4EncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        SecretKey skey = BinaryRC4Decryptor.generateSecretKey(password, ver);
        setSecretKey(skey);
        try {
            Cipher cipher = BinaryRC4Decryptor.initCipherForBlock(null, 0, builder, skey, Cipher.ENCRYPT_MODE);
            byte encryptedVerifier[] = new byte[16];
            cipher.update(verifier, 0, 16, encryptedVerifier);
            ver.setEncryptedVerifier(encryptedVerifier);
            org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm hashAlgo = ver
                    .getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            byte encryptedVerifierHash[] = cipher.doFinal(calcVerifierHash);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
    }

    public OutputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        OutputStream countStream = new BinaryRC4CipherOutputStream(dir);
        return countStream;
    }

    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize() / 8;
    }

    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        final EncryptionInfo info = builder.getEncryptionInfo();
        final BinaryRC4EncryptionHeader header = builder.getHeader();
        final BinaryRC4EncryptionVerifier verifier = builder.getVerifier();
        EncryptionRecord er = new EncryptionRecord() {
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                header.write(bos);
                verifier.write(bos);
            }
        };
        DataSpaceMapUtils.createEncryptionEntry(dir, "EncryptionInfo", er);
    }
}

<code block>


package org.docx4j.org.apache.poi.poifs.nio;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

import org.docx4j.org.apache.poi.util.IOUtils;


public class FileBackedDataSource extends DataSource {
   private FileChannel channel;
   private boolean writable;
   
   private RandomAccessFile srcFile;

   public FileBackedDataSource(File file) throws FileNotFoundException {
       this(newSrcFile(file, "r"), true);
   }

   public FileBackedDataSource(File file, boolean readOnly) throws FileNotFoundException {
       this(newSrcFile(file, readOnly ? "r" : "rw"), readOnly);
   }

   public FileBackedDataSource(RandomAccessFile srcFile, boolean readOnly) {
       this(srcFile.getChannel(), readOnly);
       this.srcFile = srcFile;
   }   
   
   public FileBackedDataSource(FileChannel channel, boolean readOnly) {
      this.channel = channel;
      this.writable = !readOnly;
   }
   
   public boolean isWriteable() {
       return this.writable;
   }
   
   public FileChannel getChannel() {
       return this.channel;
   }

   @Override
   public ByteBuffer read(int length, long position) throws IOException {
      if(position >= size()) {
         throw new IllegalArgumentException("Position " + position + " past the end of the file");
      }
      
      
      ByteBuffer dst;
      int worked = -1;
      if (writable) {
          dst = channel.map(FileChannel.MapMode.READ_WRITE, position, length);
          worked = 0;
      } else {
          
          channel.position(position);
          dst = ByteBuffer.allocate(length);
          worked = IOUtils.readFully(channel, dst);
      }

      
      if(worked == -1) {
         throw new IllegalArgumentException("Position " + position + " past the end of the file");
      }

      
      dst.position(0);

      
      return dst;
   }

   @Override
   public void write(ByteBuffer src, long position) throws IOException {
      channel.write(src, position);
   }

   @Override
   public void copyTo(OutputStream stream) throws IOException {
      
      WritableByteChannel out = Channels.newChannel(stream);
      
      channel.transferTo(0, channel.size(), out);
   }

   @Override
   public long size() throws IOException {
      return channel.size();
   }

   @Override
   public void close() throws IOException {
      if (srcFile != null) {
          
          srcFile.close();
      } else {
          channel.close();
      }
   }

   private static RandomAccessFile newSrcFile(File file, String mode) throws FileNotFoundException {
       if(!file.exists()) {
           throw new FileNotFoundException(file.toString());
        }
        return new RandomAccessFile(file, mode);
   }
}

<code block>


package org.docx4j.org.apache.poi.poifs.nio;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;


public abstract class DataSource {
   public abstract ByteBuffer read(int length, long position) throws IOException;
   public abstract void write(ByteBuffer src, long position) throws IOException;
   public abstract long size() throws IOException;
   
   public abstract void close() throws IOException;
   
   public abstract void copyTo(OutputStream stream) throws IOException;
}

<code block>


package org.docx4j.org.apache.poi.poifs.nio;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;


public class ByteArrayBackedDataSource extends DataSource {
   private byte[] buffer;
   private long size;
   
   public ByteArrayBackedDataSource(byte[] data, int size) {
      this.buffer = data;
      this.size = size;
   }
   public ByteArrayBackedDataSource(byte[] data) {
      this(data, data.length);
   }
                
   @Override
   public ByteBuffer read(int length, long position) {
      if(position >= size) {
         throw new IndexOutOfBoundsException(
               "Unable to read " + length + " bytes from " +
               position + " in stream of length " + size
         );
      }
      
      int toRead = (int)Math.min(length, size - position);
      return ByteBuffer.wrap(buffer, (int)position, toRead);
   }
   
   @Override
   public void write(ByteBuffer src, long position) {
      
      long endPosition = position + src.capacity(); 
      if(endPosition > buffer.length) {
         extend(endPosition);
      }
      
      
      src.get(buffer, (int)position, src.capacity());
      
      
      if(endPosition > size) {
         size = endPosition;
      }
   }
   
   private void extend(long length) {
      
      long difference = length - buffer.length;
      if(difference < buffer.length*0.25) {
         difference = (long)(buffer.length*0.25);
      }
      if(difference < 4096) {
         difference = 4096;
      }

      byte[] nb = new byte[(int)(difference+buffer.length)];
      System.arraycopy(buffer, 0, nb, 0, (int)size);
      buffer = nb;
   }
   
   @Override
   public void copyTo(OutputStream stream) throws IOException {
      stream.write(buffer, 0, (int)size);
   }
   
   @Override
   public long size() {
      return size;
   }
   
   @Override
   public void close() {
      buffer = null;
      size = -1;
   }
}

<code block>

package org.docx4j.org.apache.poi.hssf;

import org.docx4j.org.apache.poi.OldFileFormatException;

public class OldExcelFormatException extends OldFileFormatException {
	public OldExcelFormatException(String s) {
		super(s);
	}
}
<code block>


package org.docx4j.org.apache.poi.util;


public final class PngUtils {

    
    private static final byte[] PNG_FILE_HEADER =
        new byte[] { (byte) 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A };

    private PngUtils() {
        
    }

    
    public static boolean matchesPngHeader(byte[] data, int offset) {
        if (data == null || data.length - offset < PNG_FILE_HEADER.length) {
            return false;
        }

        for (int i = 0; i < PNG_FILE_HEADER.length; i++) {
            if (PNG_FILE_HEADER[i] != data[i + offset]) {
                return false;
            }
        }

        return true;
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.UnsupportedEncodingException;


public class CodePageUtil
{
    
    public static final int CP_037 = 37;

    
    public static final int CP_SJIS = 932;

    
    public static final int CP_GBK = 936;

    
    public static final int CP_MS949 = 949;

    
    public static final int CP_UTF16 = 1200;

    
    public static final int CP_UTF16_BE = 1201;

    
    public static final int CP_WINDOWS_1250 = 1250;

    
    public static final int CP_WINDOWS_1251 = 1251;

    
    public static final int CP_WINDOWS_1252 = 1252;
    public static final int CP_WINDOWS_1252_BIFF23 = 32769;

    
    public static final int CP_WINDOWS_1253 = 1253;

    
    public static final int CP_WINDOWS_1254 = 1254;

    
    public static final int CP_WINDOWS_1255 = 1255;

    
    public static final int CP_WINDOWS_1256 = 1256;

    
    public static final int CP_WINDOWS_1257 = 1257;

    
    public static final int CP_WINDOWS_1258 = 1258;

    
    public static final int CP_JOHAB = 1361;

    
    public static final int CP_MAC_ROMAN = 10000;
    public static final int CP_MAC_ROMAN_BIFF23 = 32768;

    
    public static final int CP_MAC_JAPAN = 10001;

    
    public static final int CP_MAC_CHINESE_TRADITIONAL = 10002;

    
    public static final int CP_MAC_KOREAN = 10003;

    
    public static final int CP_MAC_ARABIC = 10004;

    
    public static final int CP_MAC_HEBREW = 10005;

    
    public static final int CP_MAC_GREEK = 10006;

    
    public static final int CP_MAC_CYRILLIC = 10007;

    
    public static final int CP_MAC_CHINESE_SIMPLE = 10008;

    
    public static final int CP_MAC_ROMANIA = 10010;

    
    public static final int CP_MAC_UKRAINE = 10017;

    
    public static final int CP_MAC_THAI = 10021;

    
    public static final int CP_MAC_CENTRAL_EUROPE = 10029;

    
    public static final int CP_MAC_ICELAND = 10079;

    
    public static final int CP_MAC_TURKISH = 10081;

    
    public static final int CP_MAC_CROATIAN = 10082;

    
    public static final int CP_US_ACSII = 20127;

    
    public static final int CP_KOI8_R = 20866;

    
    public static final int CP_ISO_8859_1 = 28591;

    
    public static final int CP_ISO_8859_2 = 28592;

    
    public static final int CP_ISO_8859_3 = 28593;

    
    public static final int CP_ISO_8859_4 = 28594;

    
    public static final int CP_ISO_8859_5 = 28595;

    
    public static final int CP_ISO_8859_6 = 28596;

    
    public static final int CP_ISO_8859_7 = 28597;

    
    public static final int CP_ISO_8859_8 = 28598;

    
    public static final int CP_ISO_8859_9 = 28599;

    
    public static final int CP_ISO_2022_JP1 = 50220;

    
    public static final int CP_ISO_2022_JP2 = 50221;

    
    public static final int CP_ISO_2022_JP3 = 50222;

    
    public static final int CP_ISO_2022_KR = 50225;

    
    public static final int CP_EUC_JP = 51932;

    
    public static final int CP_EUC_KR = 51949;

    
    public static final int CP_GB2312 = 52936;

    
    public static final int CP_GB18030 = 54936;

    
    public static final int CP_US_ASCII2 = 65000;

    
    public static final int CP_UTF8 = 65001;

    
    public static final int CP_UNICODE = CP_UTF16;
    
    
    public static byte[] getBytesInCodePage(final String string, final int codepage) 
    throws UnsupportedEncodingException 
    {
        String encoding = codepageToEncoding(codepage);
        return string.getBytes(encoding);
    }

    
    public static String getStringFromCodePage(final byte[] string, final int codepage)
    throws UnsupportedEncodingException 
    {
        return getStringFromCodePage(string, 0, string.length, codepage);
    }
    
    
    public static String getStringFromCodePage(final byte[] string, final int offset, 
            final int length, final int codepage) throws UnsupportedEncodingException 
    {
        String encoding = codepageToEncoding(codepage);
        return new String(string, offset, length, encoding);
    }
    
    
    public static String codepageToEncoding(final int codepage)
    throws UnsupportedEncodingException
    {
        return codepageToEncoding(codepage, false);
    }
    
    
    public static String codepageToEncoding(final int codepage, boolean javaLangFormat)
    throws UnsupportedEncodingException
    {
        if (codepage <= 0)
            throw new UnsupportedEncodingException("Codepage number may not be " + codepage);
        
        switch (codepage) {
            case CP_UTF16:
                return "UTF-16";
            case CP_UTF16_BE:
                return "UTF-16BE";
            case CP_UTF8:
                return "UTF-8";
            case CP_037:
                return "cp037";
            case CP_GBK:
                return "GBK";
            case CP_MS949:
                return "ms949";
            case CP_WINDOWS_1250:
                if (javaLangFormat)
                    return "Cp1250";
                else
                    return "windows-1250";
            case CP_WINDOWS_1251:
                if (javaLangFormat)
                    return "Cp1251";
                else
                    return "windows-1251";
            case CP_WINDOWS_1252:
            case CP_WINDOWS_1252_BIFF23:
                if (javaLangFormat)
                    return "Cp1252";
                else
                    return "windows-1252";
            case CP_WINDOWS_1253:
                if (javaLangFormat)
                    return "Cp1253";
                else
                    return "windows-1253";
            case CP_WINDOWS_1254:
                if (javaLangFormat)
                    return "Cp1254";
                else
                    return "windows-1254";
            case CP_WINDOWS_1255:
                if (javaLangFormat)
                    return "Cp1255";
                else
                    return "windows-1255";
            case CP_WINDOWS_1256:
                if (javaLangFormat)
                    return "Cp1255";
                else
                    return "windows-1256";
            case CP_WINDOWS_1257:
                if (javaLangFormat)
                    return "Cp1257";
                else
                    return "windows-1257";
            case CP_WINDOWS_1258:
                if (javaLangFormat)
                    return "Cp1258";
                else
                    return "windows-1258";
            case CP_JOHAB:
                return "johab";
            case CP_MAC_ROMAN:
            case CP_MAC_ROMAN_BIFF23:
                return "MacRoman";
            case CP_MAC_JAPAN:
                return "SJIS";
            case CP_MAC_CHINESE_TRADITIONAL:
                return "Big5";
            case CP_MAC_KOREAN:
                return "EUC-KR";
            case CP_MAC_ARABIC:
                return "MacArabic";
            case CP_MAC_HEBREW:
                return "MacHebrew";
            case CP_MAC_GREEK:
                return "MacGreek";
            case CP_MAC_CYRILLIC:
                return "MacCyrillic";
            case CP_MAC_CHINESE_SIMPLE:
                return "EUC_CN";
            case CP_MAC_ROMANIA:
                return "MacRomania";
            case CP_MAC_UKRAINE:
                return "MacUkraine";
            case CP_MAC_THAI:
                return "MacThai";
            case CP_MAC_CENTRAL_EUROPE:
                return "MacCentralEurope";
            case CP_MAC_ICELAND:
                  return "MacIceland";
            case CP_MAC_TURKISH:
                return "MacTurkish";
            case CP_MAC_CROATIAN:
                return "MacCroatian";
            case CP_US_ACSII:
            case CP_US_ASCII2:
                return "US-ASCII";
            case CP_KOI8_R:
                return "KOI8-R";
            case CP_ISO_8859_1:
                if (javaLangFormat)
                    return "ISO8859_1";
                else
                    return "ISO-8859-1";
            case CP_ISO_8859_2:
                if (javaLangFormat)
                    return "ISO8859_2";
                else
                    return "ISO-8859-2";
            case CP_ISO_8859_3:
                if (javaLangFormat)
                    return "ISO8859_3";
                else
                    return "ISO-8859-3";
            case CP_ISO_8859_4:
                if (javaLangFormat)
                    return "ISO8859_4";
                else
                    return "ISO-8859-4";
            case CP_ISO_8859_5:
                if (javaLangFormat)
                    return "ISO8859_5";
                else
                    return "ISO-8859-5";
            case CP_ISO_8859_6:
                if (javaLangFormat)
                    return "ISO8859_6";
                else
                    return "ISO-8859-6";
            case CP_ISO_8859_7:
                if (javaLangFormat)
                    return "ISO8859_7";
                else
                    return "ISO-8859-7";
            case CP_ISO_8859_8:
                if (javaLangFormat)
                    return "ISO8859_8";
                else
                    return "ISO-8859-8";
            case CP_ISO_8859_9:
                if (javaLangFormat)
                    return "ISO8859_9";
                else
                    return "ISO-8859-9";
            case CP_ISO_2022_JP1:
            case CP_ISO_2022_JP2:
            case CP_ISO_2022_JP3:
                return "ISO-2022-JP";
            case CP_ISO_2022_KR:
                return "ISO-2022-KR";
            case CP_EUC_JP:
                return "EUC-JP";
            case CP_EUC_KR:
                return "EUC-KR";
            case CP_GB2312:
                return "GB2312";
            case CP_GB18030:
                return "GB18030";
            case CP_SJIS:
                return "SJIS";
            default:
                return "cp" + codepage;
        }
    }
}

<code block>


        

package org.docx4j.org.apache.poi.util;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class IntegerField
    implements FixedField
{
    private int       _value;
    private final int _offset;

    

    public IntegerField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("negative offset");
        }
        _offset = offset;
    }

    

    public IntegerField(final int offset, final int value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public IntegerField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public IntegerField(final int offset, final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public int get()
    {
        return _value;
    }

    

    public void set(final int value)
    {
        _value = value;
    }

    

    public void set(final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getInt(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readInt(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putInt(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.util;


public class IntList
{
    private int[]            _array;
    private int              _limit;
    private int              fillval = 0;
    private static final int _default_size = 128;

    

    public IntList()
    {
        this(_default_size);
    }

    public IntList(final int initialCapacity)
    {
        this(initialCapacity,0);
    }


    

    public IntList(final IntList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public IntList(final int initialCapacity, int fillvalue)
    {
        _array = new int[ initialCapacity ];
        if (fillval != 0) {
            fillval = fillvalue;
            fillArray(fillval, _array, 0);
        }
        _limit = 0;
    }

    private void fillArray(int val, int[] array, int index) {
      for (int k = index; k < array.length; k++) {
        array[k] = val;
      }
    }

    

    public void add(final int index, final int value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final int value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final IntList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final IntList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final IntList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            IntList other = ( IntList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public int get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException(
                  index + " not accessible in a list of length " + _limit
            );
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final int o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final int o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public int remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                if (j+1 < _limit) {
                    System.arraycopy(_array, j + 1, _array, j, _limit - j);
                }
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public int set(final int index, final int element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public int [] toArray()
    {
        int[] rval = new int[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public int [] toArray(final int [] a)
    {
        int[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int   size      = (new_size == _array.length) ? new_size + 1
                                                      : new_size;
        int[] new_array = new int[ size ];

        if (fillval != 0) {
          fillArray(fillval, new_array, _array.length);
        }

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   


<code block>


package org.docx4j.org.apache.poi.util;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import org.docx4j.org.apache.poi.EmptyFileException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class IOUtils {

	private static Logger logger = LoggerFactory.getLogger(IOUtils.class);
    

    private IOUtils() {
        
    }

    
    public static byte[] peekFirst8Bytes(InputStream stream) throws IOException, EmptyFileException {
        
        stream.mark(8);

        byte[] header = new byte[8];
        int read = IOUtils.readFully(stream, header);

        if (read < 1)
            throw new EmptyFileException();

        
        if(stream instanceof PushbackInputStream) {
            PushbackInputStream pin = (PushbackInputStream)stream;
            pin.unread(header);
        } else {
            stream.reset();
        }

        return header;
    }

    
    public static byte[] toByteArray(InputStream stream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        byte[] buffer = new byte[4096];
        int read = 0;
        while (read != -1) {
            read = stream.read(buffer);
            if (read > 0) {
                baos.write(buffer, 0, read);
            }
        }

        return baos.toByteArray();
    }

    
    public static byte[] toByteArray(ByteBuffer buffer, int length) {
        if(buffer.hasArray() && buffer.arrayOffset() == 0) {
            
            return buffer.array();
        }

        byte[] data = new byte[length];
        buffer.get(data);
        return data;
    }

    
    public static int readFully(InputStream in, byte[] b) throws IOException {
        return readFully(in, b, 0, b.length);
    }

    
    public static int readFully(InputStream in, byte[] b, int off, int len) throws IOException {
        int total = 0;
        while (true) {
            int got = in.read(b, off + total, len - total);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == len) {
                return total;
            }
        }
    }

    
    public static int readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {
        int total = 0;
        while (true) {
            int got = channel.read(b);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == b.capacity() || b.position() == b.capacity()) {
                return total;
            }
        }
    }

    
    public static void copy(InputStream inp, OutputStream out) throws IOException {
        byte[] buff = new byte[4096];
        int count;
        while ((count = inp.read(buff)) != -1) {
            if (count > 0) {
                out.write(buff, 0, count);
            }
        }
    }

    public static long calculateChecksum(byte[] data) {
        Checksum sum = new CRC32();
        sum.update(data, 0, data.length);
        return sum.getValue();
    }

    
    public static void closeQuietly( final Closeable closeable ) {
        try {
            closeable.close();
        } catch ( Exception exc ) {
            logger.error( "Unable to close resource: " + exc,
                    exc );
        }
    }
}

<code block>


        

package org.docx4j.org.apache.poi.util;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class LongField
    implements FixedField
{
    private long      _value;
    private final int _offset;

    

    public LongField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("Illegal offset: "
                                                     + offset);
        }
        _offset = offset;
    }

    

    public LongField(final int offset, final long value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public LongField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public LongField(final int offset, final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public long get()
    {
        return _value;
    }

    

    public void set(final long value)
    {
        _value = value;
    }

    

    public void set(final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getLong(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readLong(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putLong(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.util;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;


public final class LittleEndianOutputStream extends FilterOutputStream implements LittleEndianOutput {
	public LittleEndianOutputStream(OutputStream out) {
		super(out);
	}

	@Override
    public void writeByte(int v) {
		try {
			out.write(v);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
    public void writeDouble(double v) {
		writeLong(Double.doubleToLongBits(v));
	}

	@Override
    public void writeInt(int v) {
		int b3 = (v >>> 24) & 0xFF;
		int b2 = (v >>> 16) & 0xFF;
		int b1 = (v >>>  8) & 0xFF;
		int b0 = (v >>>  0) & 0xFF;
		try {
			out.write(b0);
			out.write(b1);
			out.write(b2);
			out.write(b3);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
    public void writeLong(long v) {
		writeInt((int)(v >>  0));
		writeInt((int)(v >> 32));
	}

	@Override
    public void writeShort(int v) {
		int b1 = (v >>>  8) & 0xFF;
		int b0 = (v >>>  0) & 0xFF;
		try {
			out.write(b0);
			out.write(b1);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	@Override
    public void write(byte[] b) {
		
		try {
			super.write(b);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	@Override
    public void write(byte[] b, int off, int len) {
		
		try {
			super.write(b, off, len);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
}

<code block>


        

package org.docx4j.org.apache.poi.util;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class ShortField
    implements FixedField
{
    private short     _value;
    private final int _offset;

    

    public ShortField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("Illegal offset: "
                                                     + offset);
        }
        _offset = offset;
    }

    

    public ShortField(final int offset, final short value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public ShortField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ShortField(final int offset, final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public short get()
    {
        return _value;
    }

    

    public void set(final short value)
    {
        _value = value;
    }

    

    public void set(final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getShort(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readShort(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putShort(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.util;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.text.DecimalFormat;


public class HexDump {
    public static final String EOL = System.getProperty("line.separator");
    private static final char _hexcodes[] = "0123456789ABCDEF".toCharArray();
    private static final int _shifts[]   =
    {
        60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0
    };

    private HexDump() {
        
    }

    
    public static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index, final int length)
            throws IOException, ArrayIndexOutOfBoundsException,
                    IllegalArgumentException
    {
        if (data.length == 0)
        {
            stream.write( ("No Data" + EOL).getBytes() );
            stream.flush();
            return;
        }
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                "illegal index: " + index + " into array of length "
                + data.length);
        }
        if (stream == null)
        {
            throw new IllegalArgumentException("cannot write to nullstream");
        }

        long         display_offset = offset + index;
        StringBuffer buffer         = new StringBuffer(74);


        int data_length = Math.min(data.length,index+length);
        for (int j = index; j < data_length; j += 16)
        {
            int chars_read = data_length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(
                        dump(display_offset)
                         ).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            stream.write(buffer.toString().getBytes());
            stream.flush();
            buffer.setLength(0);
            display_offset += chars_read;
        }

    }

    

    public synchronized static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index)
        throws IOException, ArrayIndexOutOfBoundsException,
                IllegalArgumentException
    {
        dump(data, offset, stream, index, data.length-index);
    }

    

    public static String dump(final byte [] data, final long offset,
                            final int index) {
        StringBuffer buffer;
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                "illegal index: " + index + " into array of length "
                + data.length);
        }
        long         display_offset = offset + index;
        buffer         = new StringBuffer(74);

        for (int j = index; j < data.length; j += 16)
        {
            int chars_read = data.length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(dump(display_offset)).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            display_offset += chars_read;
        }
        return buffer.toString();
    }


    private static String dump(final long value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 8; j++)
        {
            buf.append( _hexcodes[ (( int ) (value >> _shifts[ j + _shifts.length - 8 ])) & 15 ]);
        }
        return buf.toString();
    }

    private static String dump(final byte value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 2; j++)
        {
            buf.append(_hexcodes[ (value >> _shifts[ j + 6 ]) & 15 ]);
        }
        return buf.toString();
    }

    
    public static String toHex(final byte[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final short[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final byte[] value, final int bytesPerLine)
    {
        final int digits =
            (int) Math.round(Math.log(value.length) / Math.log(10) + 0.5);
        final StringBuffer formatString = new StringBuffer();
        for (int i = 0; i < digits; i++)
            formatString.append('0');
        formatString.append(": ");
        final DecimalFormat format = new DecimalFormat(formatString.toString());
        StringBuffer retVal = new StringBuffer();
        retVal.append(format.format(0));
        int i = -1;
        for(int x = 0; x < value.length; x++)
        {
            if (++i == bytesPerLine)
            {
                retVal.append('\n');
                retVal.append(format.format(x));
                i = 0;
            } else if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        return retVal.toString();
    }

    
    public static String toHex(final short value)
    {
        return toHex(value, 4);
    }

    
    public static String toHex(final byte value)
    {
        return toHex(value, 2);
    }

    
    public static String toHex(final int value)
    {
        return toHex(value, 8);
    }

    
    public static String toHex(final long value)
    {
        return toHex(value, 16);
    }


    private static String toHex(final long value, final int digits)
    {
        StringBuffer result = new StringBuffer(digits);
        for (int j = 0; j < digits; j++)
        {
            result.append( _hexcodes[ (int) ((value >> _shifts[ j + (16 - digits) ]) & 15)]);
        }
        return result.toString();
    }

    
    public static void dump( InputStream in, PrintStream out, int start, int bytesToDump ) throws IOException
    {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        if (bytesToDump == -1)
        {
            int c = in.read();
            while (c != -1)
            {
                buf.write(c);
                c = in.read();
            }
        }
        else
        {
            int bytesRemaining = bytesToDump;
            while (bytesRemaining-- > 0)
            {
                int c = in.read();
                if (c == -1) {
                    break;
                }
                buf.write(c);
            }
        }

        byte[] data = buf.toByteArray();
        dump(data, 0, out, start, data.length);
    }
    
    private static char[] toHexChars(long pValue, int nBytes) {
        int charPos = 2 + nBytes*2;
        
        
        char[] result = new char[charPos];

        long value = pValue;
        do {
            result[--charPos] = _hexcodes[(int) (value & 0x0F)];
            value >>>= 4;
        } while (charPos > 1);

        
        result[0] = '0';
        result[1] = 'x';
        return result;
    }
    
    public static char[] longToHex(long value) {
        return toHexChars(value, 8);
    }
    
    public static char[] intToHex(int value) {
        return toHexChars(value, 4);
    }
    
    public static char[] shortToHex(int value) {
        return toHexChars(value, 2);
    }
    
    public static char[] byteToHex(int value) {
        return toHexChars(value, 1);
    }

    public static void main(String[] args) throws Exception {
        File file = new File(args[0]);
        InputStream in = new BufferedInputStream(new FileInputStream(file));
        byte[] b = new byte[(int)file.length()];
        in.read(b);
        System.out.println(HexDump.dump(b, 0, 0));
        in.close();
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;
import java.lang.annotation.Documented;



@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Internal {
    String value() default "";    
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.File;
import java.io.IOException;


public interface TempFileCreationStrategy {
    
    public File createTempFile(String prefix, String suffix) throws IOException;
}

<code block>


        

package org.docx4j.org.apache.poi.util;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;
import java.nio.BufferUnderflowException;



public class ByteField
    implements FixedField
{
    private static final byte _default_value = 0;
    private byte              _value;
    private final int         _offset;

    

    public ByteField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, _default_value);
    }

    

    public ByteField(final int offset, final byte value)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(
                "offset cannot be negative");
        }
        _offset = offset;
        set(value);
    }

    

    public ByteField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ByteField(final int offset, final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, value);
        writeToBytes(data);
    }

    

    public byte get()
    {
        return _value;
    }

    

    public void set(final byte value)
    {
        _value = value;
    }

    

    public void set(final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        set(value);
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = data[ _offset ];
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
    	
    	int ib = stream.read();
    	if (ib < 0) {
    		throw new BufferUnderflowException();
    	}
        _value = (byte) ib;
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        data[ _offset ] = _value;
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.docx4j.org.apache.poi.util;

public interface LittleEndianInput {
	int available();
	byte readByte();
	int readUByte();
	short readShort();
	int readUShort();
	int readInt();
	long readLong();
	double readDouble();
	void readFully(byte[] buf);
	void readFully(byte[] buf, int off, int len);
}

<code block>


package org.docx4j.org.apache.poi.util;

public interface DelayableLittleEndianOutput extends LittleEndianOutput {
	
	LittleEndianOutput createDelayedOutput(int size);
}

<code block>



package org.docx4j.org.apache.poi.util;

import java.util.*;



public class BitFieldFactory {
    private static Map<Integer, BitField> instances = new HashMap<Integer, BitField>();

    public static BitField getInstance(int mask) {
      BitField f = instances.get(Integer.valueOf(mask));
      if (f == null) {
        f = new BitField(mask);
        instances.put(Integer.valueOf(mask), f);
      }
      return f;
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.FilterInputStream;
import java.io.InputStream;


public class CloseIgnoringInputStream extends FilterInputStream {
   public CloseIgnoringInputStream(InputStream in) {
      super(in);
   }

   public void close() {
      
      return;
   }
}

<code block>


package org.docx4j.org.apache.poi.util;

public interface LittleEndianOutput {
	void writeByte(int v);
	void writeShort(int v);
	void writeInt(int v);
	void writeLong(long v);
	void writeDouble(double v);
	void write(byte[] b);
	void write(byte[] b, int offset, int len);
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.*;
import java.util.List;
import java.util.ArrayList;


public class HexRead
{
    
    public static byte[] readData( String filename ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        try
        {
            return readData( stream, -1 );
        }
        finally
        {
            stream.close();
        }
    }

    
    public static byte[] readData(InputStream stream, String section ) throws IOException {

        try
        {
            StringBuffer sectionText = new StringBuffer();
            boolean inSection = false;
            int c = stream.read();
            while ( c != -1 )
            {
                switch ( c )
                {
                    case '[':
                        inSection = true;
                        break;
                    case '\n':
                    case '\r':
                        inSection = false;
                        sectionText = new StringBuffer();
                        break;
                    case ']':
                        inSection = false;
                        if ( sectionText.toString().equals( section ) ) return readData( stream, '[' );
                        sectionText = new StringBuffer();
                        break;
                    default:
                        if ( inSection ) sectionText.append( (char) c );
                }
                c = stream.read();
            }
        }
        finally
        {
            stream.close();
        }
        throw new IOException( "Section '" + section + "' not found" );
    }
    public static byte[] readData( String filename, String section ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        return readData(stream, section);
    }

    static public byte[] readData( InputStream stream, int eofChar )
            throws IOException
    {
        int characterCount = 0;
        byte b = (byte) 0;
        List<Byte> bytes = new ArrayList<Byte>();
        boolean done = false;
        while ( !done )
        {
            int count = stream.read();
            char baseChar = 'a';
            if ( count == eofChar ) break;
            switch ( count )
            {
                case '#':
                    readToEOL( stream );
                    break;
                case '0': case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    b <<= 4;
                    b += (byte) ( count - '0' );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                    baseChar = 'A';
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                    b <<= 4;
                    b += (byte) ( count + 10 - baseChar );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case -1:
                    done = true;
                    break;
                default :
                    break;
            }
        }
        Byte[] polished = bytes.toArray( new Byte[0] );
        byte[] rval = new byte[polished.length];
        for ( int j = 0; j < polished.length; j++ )
        {
            rval[j] = polished[j].byteValue();
        }
        return rval;
    }

    static public byte[] readFromString(String data) {
        try {
            return readData(new ByteArrayInputStream( data.getBytes() ), -1);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    static private void readToEOL( InputStream stream ) throws IOException
    {
        int c = stream.read();
        while ( c != -1 && c != '\n' && c != '\r' )
        {
            c = stream.read();
        }
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Method;

import javax.xml.XMLConstants;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;



public final class SAXHelper {

	private static Logger logger = LoggerFactory.getLogger(SAXHelper.class);	
	

    private SAXHelper() {}

    
    public static synchronized XMLReader newXMLReader() throws SAXException, ParserConfigurationException {
        XMLReader xmlReader = saxFactory.newSAXParser().getXMLReader();
        xmlReader.setEntityResolver(IGNORING_ENTITY_RESOLVER);
        trySetSAXFeature(xmlReader, XMLConstants.FEATURE_SECURE_PROCESSING, true);
        trySetXercesSecurityManager(xmlReader);
        return xmlReader;
    }
    
    static final EntityResolver IGNORING_ENTITY_RESOLVER = new EntityResolver() {
        @Override
        public InputSource resolveEntity(String publicId, String systemId)
                throws SAXException, IOException {
            return new InputSource(new StringReader(""));
        }
    };
    
    private static final SAXParserFactory saxFactory;
    static {
        saxFactory = SAXParserFactory.newInstance();
        saxFactory.setValidating(false);
        saxFactory.setNamespaceAware(true);
    }
            
    private static void trySetSAXFeature(XMLReader xmlReader, String feature, boolean enabled) {
        try {
            xmlReader.setFeature(feature, enabled);
        } catch (Exception e) {
            logger.warn("SAX Feature unsupported "+ feature, e);
        } catch (AbstractMethodError ame) {
            logger.warn( "Cannot set SAX feature because outdated XML parser in classpath" + feature, ame);
        }
    }
    
    private static void trySetXercesSecurityManager(XMLReader xmlReader) {
        
        for (String securityManagerClassName : new String[] {
                "com.sun.org.apache.xerces.internal.util.SecurityManager",
                "org.apache.xerces.util.SecurityManager"
        }) {
            try {
                Object mgr = Class.forName(securityManagerClassName).newInstance();
                Method setLimit = mgr.getClass().getMethod("setEntityExpansionLimit", Integer.TYPE);
                setLimit.invoke(mgr, 4096);
                xmlReader.setProperty("http:
                
                return;
            } catch (Exception e) {
                logger.warn( "SAX Security Manager could not be setup", e);
            }
        }
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;


public class LittleEndianInputStream extends FilterInputStream implements LittleEndianInput {
	public LittleEndianInputStream(InputStream is) {
		super(is);
	}
	
	public int available() {
		try {
			return super.available();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	
	public byte readByte() {
		return (byte)readUByte();
	}
	
	public int readUByte() {
		byte buf[] = new byte[1];
		try {
			checkEOF(read(buf), 1);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getUByte(buf);
	}
	
	public double readDouble() {
		return Double.longBitsToDouble(readLong());
	}
	
	public int readInt() {
	    byte buf[] = new byte[LittleEndianConsts.INT_SIZE];
		try {
		    checkEOF(read(buf), buf.length);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getInt(buf);
	}
	
    
    public long readUInt() {
       long retNum = readInt();
       return retNum & 0x00FFFFFFFFl;
    }
	
	public long readLong() {
		byte buf[] = new byte[LittleEndianConsts.LONG_SIZE];
		try {
		    checkEOF(read(buf), LittleEndianConsts.LONG_SIZE);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getLong(buf);
	}
	
	public short readShort() {
		return (short)readUShort();
	}
	
	public int readUShort() {
		byte buf[] = new byte[LittleEndianConsts.SHORT_SIZE];
		try {
		    checkEOF(read(buf), LittleEndianConsts.SHORT_SIZE);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getUShort(buf);
	}
	
	private static void checkEOF(int actualBytes, int expectedBytes) {
		if (expectedBytes != 0 && (actualBytes == -1 || actualBytes != expectedBytes)) {
			throw new RuntimeException("Unexpected end-of-file");
		}
	}

	public void readFully(byte[] buf) {
		readFully(buf, 0, buf.length);
	}

	public void readFully(byte[] buf, int off, int len) {
	    try {
	        checkEOF(read(buf, off, len), len);
	    } catch (IOException e) {
            throw new RuntimeException(e);
        }
	}
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.events.Namespace;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;

public final class DocumentHelper {

	private static Logger logger = LoggerFactory.getLogger(DocumentHelper.class);	
	
    
    private DocumentHelper() {}

    
    public static synchronized DocumentBuilder newDocumentBuilder() {
        try {
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            documentBuilder.setEntityResolver(SAXHelper.IGNORING_ENTITY_RESOLVER);
            return documentBuilder;
        } catch (ParserConfigurationException e) {
            throw new IllegalStateException("cannot create a DocumentBuilder", e);
        }
    }

    private static final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
    static {
        documentBuilderFactory.setNamespaceAware(true);
        documentBuilderFactory.setValidating(false);
        trySetSAXFeature(documentBuilderFactory, XMLConstants.FEATURE_SECURE_PROCESSING, true);
        trySetXercesSecurityManager(documentBuilderFactory);
    }

    private static void trySetSAXFeature(DocumentBuilderFactory documentBuilderFactory, String feature, boolean enabled) {
        try {
            documentBuilderFactory.setFeature(feature, enabled);
        } catch (Exception e) {
            logger.warn( "SAX Feature unsupported " + feature, e);
        } catch (AbstractMethodError ame) {
            logger.warn("Cannot set SAX feature because outdated XML parser in classpath " + feature, ame);
        }
    }
    
    private static void trySetXercesSecurityManager(DocumentBuilderFactory documentBuilderFactory) {
        
        for (String securityManagerClassName : new String[] {
                "com.sun.org.apache.xerces.internal.util.SecurityManager",
                "org.apache.xerces.util.SecurityManager"
        }) {
            try {
                Object mgr = Class.forName(securityManagerClassName).newInstance();
                Method setLimit = mgr.getClass().getMethod("setEntityExpansionLimit", Integer.TYPE);
                setLimit.invoke(mgr, 4096);
                documentBuilderFactory.setAttribute("http:
                
                return;
            } catch (Throwable t) {
                logger.warn( "SAX Security Manager could not be setup", t);
            }
        }
    }

    
    public static Document readDocument(InputStream inp) throws IOException, SAXException {
        return newDocumentBuilder().parse(inp);
    }

    
    private static final DocumentBuilder documentBuilderSingleton = newDocumentBuilder();

    
    public static synchronized Document createDocument() {
        return documentBuilderSingleton.newDocument();
    }

    
    public static void addNamespaceDeclaration(Element element, String namespacePrefix, String namespaceURI) {
        element.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI,
                XMLConstants.XMLNS_ATTRIBUTE + ':' + namespacePrefix,
                namespaceURI);
    }

    
    public static void addNamespaceDeclaration(Element element, Namespace namespace) {
        addNamespaceDeclaration(element, namespace.getPrefix(), namespace.getNamespaceURI());
    }

}

<code block>

package org.docx4j.org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;


public class BoundedInputStream extends InputStream {

    
    private final InputStream in;

    
    private final long max;

    
    private long pos = 0;

    
    private long mark = -1;

    
    private boolean propagateClose = true;

    
    public BoundedInputStream(InputStream in, long size) {
        
        
        this.max = size;
        this.in = in;
    }

    
    public BoundedInputStream(InputStream in) {
        this(in, -1);
    }

    
    @Override
    public int read() throws IOException {
        if (max>=0 && pos==max) {
            return -1;
        }
        int result = in.read();
        pos++;
        return result;
    }

    
    @Override
    public int read(byte[] b) throws IOException {
        return this.read(b, 0, b.length);
    }

    
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        if (max>=0 && pos>=max) {
            return -1;
        }
        long maxRead = max>=0 ? Math.min(len, max-pos) : len;
        int bytesRead = in.read(b, off, (int)maxRead);

        if (bytesRead==-1) {
            return -1;
        }

        pos+=bytesRead;
        return bytesRead;
    }

    
    @Override
    public long skip(long n) throws IOException {
        long toSkip = max>=0 ? Math.min(n, max-pos) : n;
        long skippedBytes = in.skip(toSkip);
        pos+=skippedBytes;
        return skippedBytes;
    }

    
    @Override
    public int available() throws IOException {
        if (max>=0 && pos>=max) {
            return 0;
        }
        return in.available();
    }

    
    @Override
    public String toString() {
        return in.toString();
    }

    
    @Override
    public void close() throws IOException {
        if (propagateClose) {
            in.close();
        }
    }

    
    @Override
    public synchronized void reset() throws IOException {
        in.reset();
        pos = mark;
    }

    
    @Override
    public synchronized void mark(int readlimit) {
        in.mark(readlimit);
        mark = pos;
    }

    
    @Override
    public boolean markSupported() {
        return in.markSupported();
    }

    
    public boolean isPropagateClose() {
        return propagateClose;
    }

    
    public void setPropagateClose(boolean propagateClose) {
        this.propagateClose = propagateClose;
    }
}

<code block>


package org.docx4j.org.apache.poi.util;



public final class LittleEndianByteArrayOutputStream implements LittleEndianOutput, DelayableLittleEndianOutput {
	private final byte[] _buf;
	private final int _endIndex;
	private int _writeIndex;

	public LittleEndianByteArrayOutputStream(byte[] buf, int startOffset, int maxWriteLen) {
		if (startOffset < 0 || startOffset > buf.length) {
			throw new IllegalArgumentException("Specified startOffset (" + startOffset 
					+ ") is out of allowable range (0.." + buf.length + ")");
		}
		_buf = buf;
		_writeIndex = startOffset;
		_endIndex = startOffset + maxWriteLen;
		if (_endIndex < startOffset ||  _endIndex > buf.length) {
			throw new IllegalArgumentException("calculated end index (" + _endIndex 
					+ ") is out of allowable range (" + _writeIndex + ".." + buf.length + ")");
		}
	}
	public LittleEndianByteArrayOutputStream(byte[] buf, int startOffset) {
		this(buf, startOffset, buf.length - startOffset);
	}

	private void checkPosition(int i) {
		if (i > _endIndex - _writeIndex) {
			throw new RuntimeException("Buffer overrun");
		}
	}

	public void writeByte(int v) {
		checkPosition(1);
		_buf[_writeIndex++] = (byte)v;
	}

	public void writeDouble(double v) {
		writeLong(Double.doubleToLongBits(v));
	}

	public void writeInt(int v) {
		checkPosition(4);
		int i = _writeIndex;
		_buf[i++] = (byte)((v >>>  0) & 0xFF);
		_buf[i++] = (byte)((v >>>  8) & 0xFF);
		_buf[i++] = (byte)((v >>> 16) & 0xFF);
		_buf[i++] = (byte)((v >>> 24) & 0xFF);
		_writeIndex = i;
	}

	public void writeLong(long v) {
		writeInt((int)(v >>  0));
		writeInt((int)(v >> 32));
	}

	public void writeShort(int v) {
		checkPosition(2);
		int i = _writeIndex;
		_buf[i++] = (byte)((v >>>  0) & 0xFF);
		_buf[i++] = (byte)((v >>>  8) & 0xFF);
		_writeIndex = i;
	}
	public void write(byte[] b) {
		int len = b.length;
		checkPosition(len);
		System.arraycopy(b, 0, _buf, _writeIndex, len);
		_writeIndex += len;
	}
	public void write(byte[] b, int offset, int len) {
		checkPosition(len);
		System.arraycopy(b, offset, _buf, _writeIndex, len);
		_writeIndex += len;
	}
	public int getWriteIndex() {
		return _writeIndex;
	}
	public LittleEndianOutput createDelayedOutput(int size) {
		checkPosition(size);
		LittleEndianOutput result = new LittleEndianByteArrayOutputStream(_buf, _writeIndex, size);
		_writeIndex += size;
		return result;
	}
}

<code block>


        

package org.docx4j.org.apache.poi.util;



public interface LittleEndianConsts
{

    
    public static final int BYTE_SIZE   = 1;
    public static final int SHORT_SIZE  = 2;
    public static final int INT_SIZE    = 4;
    public static final int LONG_SIZE   = 8;
    public static final int DOUBLE_SIZE = 8;
}   


<code block>


        

package org.docx4j.org.apache.poi.util;

import org.docx4j.org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public interface FixedField
{

    

    public void readFromBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public void readFromStream(InputStream stream)
        throws IOException, BufferUnderrunException;

    

    public void writeToBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public String toString();
}   


<code block>


        

package org.docx4j.org.apache.poi.util;



public class BitField
{
    private final int _mask;
    private final int _shift_count;

    

    public BitField(final int mask)
    {
        _mask = mask;
        int count       = 0;
        int bit_pattern = mask;

        if (bit_pattern != 0)
        {
            while ((bit_pattern & 1) == 0)
            {
                count++;
                bit_pattern >>= 1;
            }
        }
        _shift_count = count;
    }

    

    public int getValue(final int holder)
    {
        return getRawValue(holder) >>> _shift_count;
    }

    

    public short getShortValue(final short holder)
    {
        return ( short ) getValue(holder);
    }

    

    public int getRawValue(final int holder)
    {
        return (holder & _mask);
    }

    

    public short getShortRawValue(final short holder)
    {
        return ( short ) getRawValue(holder);
    }

    

    public boolean isSet(final int holder)
    {
        return (holder & _mask) != 0;
    }

    

    public boolean isAllSet(final int holder)
    {
        return (holder & _mask) == _mask;
    }

    

    public int setValue(final int holder, final int value)
    {
        return (holder & ~_mask) | ((value << _shift_count) & _mask);
    }

    

    public short setShortValue(final short holder, final short value)
    {
        return ( short ) setValue(holder, value);
    }

    

    public int clear(final int holder)
    {
        return holder & ~_mask;
    }

    

    public short clearShort(final short holder)
    {
        return ( short ) clear(holder);
    }

    

    public byte clearByte(final byte holder)
    {
        return ( byte ) clear(holder);
    }

    

    public int set(final int holder)
    {
        return holder | _mask;
    }

    

    public short setShort(final short holder)
    {
        return ( short ) set(holder);
    }

    

    public byte setByte(final byte holder)
    {
        return ( byte ) set(holder);
    }

    

    public int setBoolean(final int holder, final boolean flag)
    {
        return flag ? set(holder)
                    : clear(holder);
    }

    

    public short setShortBoolean(final short holder, final boolean flag)
    {
        return flag ? setShort(holder)
                    : clearShort(holder);
    }

    

    public byte setByteBoolean(final byte holder, final boolean flag)
    {
        return flag ? setByte(holder)
                    : clearByte(holder);
    }
}   


<code block>


        

package org.docx4j.org.apache.poi.util;


public class RecordFormatException
    extends RuntimeException
{
    public RecordFormatException(String exception)
    {
        super(exception);
    }
    
    public RecordFormatException(String exception, Throwable thr) {
      super(exception, thr);
    }
    
    public RecordFormatException(Throwable thr) {
      super(thr);
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;


public class LittleEndian implements LittleEndianConsts
{

    
    public static final class BufferUnderrunException extends IOException
    {
        
        private static final long serialVersionUID = 8736973884877006145L;

        BufferUnderrunException()
        {
            super( "buffer underrun" );
        }
    }

    
    public static byte[] getByteArray( byte[] data, int offset, int size )
    {
        byte[] copy = new byte[size];
        System.arraycopy( data, offset, copy, 0, size );

        return copy;
    }

    
    public static double getDouble( byte[] data )
    {
        return Double.longBitsToDouble( getLong( data, 0 ) );
    }

    
    public static double getDouble( byte[] data, int offset )
    {
        return Double.longBitsToDouble( getLong( data, offset ) );
    }

    
    public static float getFloat( byte[] data )
    {
        return getFloat( data, 0 );
    }

    
    public static float getFloat( byte[] data, int offset )
    {
        return Float.intBitsToFloat( getInt( data, offset ) );
    }

    
    public static int getInt( byte[] data )
    {
        return getInt( data, 0 );
    }

    
    public static int getInt( byte[] data, int offset )
    {
        int i = offset;
        int b0 = data[i++] & 0xFF;
        int b1 = data[i++] & 0xFF;
        int b2 = data[i++] & 0xFF;
        int b3 = data[i++] & 0xFF;
        return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static long getLong( byte[] data )
    {
        return getLong( data, 0 );
    }

    
    public static long getLong( byte[] data, int offset )
    {
        long result = 0xff & data[offset + 7];

        for ( int j = offset + LONG_SIZE - 1; j >= offset; j-- )
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    
    public static short getShort( byte[] data )
    {
        return getShort( data, 0 );
    }

    
    public static short getShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return (short) ( ( b1 << 8 ) + ( b0 << 0 ) );
    }

    
    public static short[] getShortArray( byte[] data, int offset, int size )
    {
        short[] result = new short[size / SHORT_SIZE];
        for ( int i = 0; i < result.length; i++ )
        {
            result[i] = getShort( data, offset + i * SHORT_SIZE );
        }
        return result;
    }

    
    public static short getUByte( byte[] data )
    {
        return (short) ( data[0] & 0xFF );
    }

    
    public static short getUByte( byte[] data, int offset )
    {
        return (short) ( data[offset] & 0xFF );
    }

    
    public static long getUInt( byte[] data )
    {
        return getUInt( data, 0 );
    }

    
    public static long getUInt( byte[] data, int offset )
    {
        long retNum = getInt( data, offset );
        return retNum & 0x00FFFFFFFFl;
    }

    
    @Deprecated
    public static int getUnsignedByte( byte[] data, int offset )
    {
        return data[offset] & 0xFF;
    }

    
    public static int getUShort( byte[] data )
    {
        return getUShort( data, 0 );
    }

    
    public static int getUShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static void putByte( byte[] data, int offset, int value )
    {
        data[offset] = (byte) value;
    }

    
    public static void putDouble( byte[] data, int offset, double value )
    {
        putLong( data, offset, Double.doubleToLongBits( value ) );
    }

    
    public static void putDouble( double value, OutputStream outputStream )
            throws IOException
    {
        putLong( Double.doubleToLongBits( value ), outputStream );
    }

    
    public static void putFloat( byte[] data, int offset, float value )
    {
        putInt( data, offset, Float.floatToIntBits( value ) );
    }

    
    public static void putFloat( float value, OutputStream outputStream )
            throws IOException
    {
        putInt( Float.floatToIntBits( value ), outputStream );
    }

    
    @Deprecated
    public static void putInt( byte[] data, int value )
    {
        putInt( data, 0, value );
    }

    
    public static void putInt( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    public static void putInt( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putLong( byte[] data, int offset, long value )
    {
        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );
        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );
        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );
        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );
        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );
    }

    
    public static void putLong( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );
    }

    
    public static void putShort( byte[] data, int offset, short value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    @Deprecated
    public static void putShort( byte[] data, short value )
    {
        putShort( data, 0, value );
    }

    
    public static void putShort( OutputStream outputStream, short value )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static void putShortArray( byte[] data, int startOffset,
            short[] value )
    {
        int offset = startOffset;
        for ( short s : value )
        {
            putShort( data, offset, s );
            offset += SHORT_SIZE;
        }
    }

    
    public static void putUByte( byte[] data, int offset, short value )
    {
        data[offset] = (byte) ( value & 0xFF );
    }

    
    public static void putUInt( byte[] data, int offset, long value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    @Deprecated
    public static void putUInt( byte[] data, long value )
    {
        putUInt( data, 0, value );
    }

    
    public static void putUInt( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putUShort( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    public static void putUShort( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static int readInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }
    
    
    public static long readUInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
       long retNum = readInt(stream);
       return retNum & 0x00FFFFFFFFl;
    }

    
    public static long readLong( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        int ch5 = stream.read();
        int ch6 = stream.read();
        int ch7 = stream.read();
        int ch8 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 ) < 0 )
        {
            throw new BufferUnderrunException();
        }

        return ( (long) ch8 << 56 ) + ( (long) ch7 << 48 )
                + ( (long) ch6 << 40 ) + ( (long) ch5 << 32 )
                + ( (long) ch4 << 24 ) + 
                                         
                ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static short readShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        return (short) readUShort( stream );
    }

    public static int readUShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        if ( ( ch1 | ch2 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static int ubyteToInt( byte b )
    {
        return b & 0xFF;
    }

    private LittleEndian()
    {
        
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.io.File;
import java.io.IOException;


public final class TempFile {
    
    
    private static TempFileCreationStrategy strategy = new DefaultTempFileCreationStrategy();
    
    
    public static void setTempFileCreationStrategy(TempFileCreationStrategy strategy) {
        if (strategy == null) {
            throw new IllegalArgumentException("strategy == null");
        }
        TempFile.strategy = strategy;
    }
    
    
    public static File createTempFile(String prefix, String suffix) throws IOException {
        return strategy.createTempFile(prefix, suffix);
    }
    
    
    public static class DefaultTempFileCreationStrategy implements TempFileCreationStrategy {
        
        
        private File dir;
        
        
        public DefaultTempFileCreationStrategy() {
            this(null);
        }
        
        
        public DefaultTempFileCreationStrategy(File dir) {
            this.dir = dir;
        }
        
        @Override
        public File createTempFile(String prefix, String suffix) throws IOException {
            
            if (dir == null)
            {
                dir = new File(System.getProperty("java.io.tmpdir"), "poifiles");
                dir.mkdir();
                if (System.getProperty("poi.keep.tmp.files") == null)
                    dir.deleteOnExit();
            }

            
            File newFile = File.createTempFile(prefix, suffix, dir);

            
            if (System.getProperty("poi.keep.tmp.files") == null)
                newFile.deleteOnExit();

            
            return newFile;
        }
        
    }
}

<code block>


package org.docx4j.org.apache.poi.util;

import java.nio.charset.Charset;
import java.text.FieldPosition;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;



public class StringUtil {
	private static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
	private static final Charset UTF16LE = Charset.forName("UTF-16LE");
    private static Map<Integer,Integer> msCodepointToUnicode;

	private StringUtil() {
		
	}

	
	public static String getFromUnicodeLE(
		final byte[] string,
		final int offset,
		final int len)
		throws ArrayIndexOutOfBoundsException, IllegalArgumentException {
		if ((offset < 0) || (offset >= string.length)) {
			throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");
		}
		if ((len < 0) || (((string.length - offset) / 2) < len)) {
			throw new IllegalArgumentException("Illegal length " + len);
		}

		return new String(string, offset, len * 2, UTF16LE);
	}

	
	public static String getFromUnicodeLE(byte[] string) {
        if(string.length == 0) { return ""; }
        return getFromUnicodeLE(string, 0, string.length / 2);
	}
	
	
	public static byte[] getToUnicodeLE(String string) {
	    return string.getBytes(UTF16LE);
	}

	
	public static String getFromCompressedUnicode(
		final byte[] string,
		final int offset,
		final int len) {
		int len_to_use = Math.min(len, string.length - offset);
		return new String(string, offset, len_to_use, ISO_8859_1);
	}
	
	public static String readCompressedUnicode(LittleEndianInput in, int nChars) {
		byte[] buf = new byte[nChars];
		in.readFully(buf);
		return new String(buf, ISO_8859_1);
	}
	
	
	public static String readUnicodeString(LittleEndianInput in) {

		int nChars = in.readUShort();
		byte flag = in.readByte();
		if ((flag & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static String readUnicodeString(LittleEndianInput in, int nChars) {
		byte is16Bit = in.readByte();
		if ((is16Bit & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static void writeUnicodeString(LittleEndianOutput out, String value) {

		int nChars = value.length();
		out.writeShort(nChars);
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}
	
	public static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}

	
	public static int getEncodedSize(String value) {
		int result = 2 + 1;
		result += value.length() * (StringUtil.hasMultibyte(value) ? 2 : 1);
		return result;
	}

	
	public static void putCompressedUnicode(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}

	public static void putCompressedUnicode(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		out.write(bytes);
	}

	
	public static void putUnicodeLE(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(UTF16LE);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}
	public static void putUnicodeLE(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(UTF16LE);
		out.write(bytes);
	}

	public static String readUnicodeLE(LittleEndianInput in, int nChars) {
        byte[] bytes = new byte[nChars*2];
        in.readFully(bytes);
        return new String(bytes, UTF16LE);
	}

	
	public static String format(String message, Object[] params) {
		int currentParamNumber = 0;
		StringBuffer formattedMessage = new StringBuffer();
		for (int i = 0; i < message.length(); i++) {
			if (message.charAt(i) == '%') {
				if (currentParamNumber >= params.length) {
					formattedMessage.append("?missing data?");
				} else if (
					(params[currentParamNumber] instanceof Number)
						&& (i + 1 < message.length())) {
					i
						+= matchOptionalFormatting(
							(Number) params[currentParamNumber++],
							message.substring(i + 1),
							formattedMessage);
				} else {
					formattedMessage.append(
						params[currentParamNumber++].toString());
				}
			} else {
				if ((message.charAt(i) == '\\')
					&& (i + 1 < message.length())
					&& (message.charAt(i + 1) == '%')) {
					formattedMessage.append('%');
					i++;
				} else {
					formattedMessage.append(message.charAt(i));
				}
			}
		}
		return formattedMessage.toString();
	}


	private static int matchOptionalFormatting(
		Number number,
		String formatting,
		StringBuffer outputTo) {
		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
		if ((0 < formatting.length())
			&& Character.isDigit(formatting.charAt(0))) {
			numberFormat.setMinimumIntegerDigits(
				Integer.parseInt(formatting.charAt(0) + ""));
			if ((2 < formatting.length())
				&& (formatting.charAt(1) == '.')
				&& Character.isDigit(formatting.charAt(2))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(2) + ""));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 3;
			}
			numberFormat.format(number, outputTo, new FieldPosition(0));
			return 1;
		} else if (
			(0 < formatting.length()) && (formatting.charAt(0) == '.')) {
			if ((1 < formatting.length())
				&& Character.isDigit(formatting.charAt(1))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(1) + ""));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 2;
			}
		}
		numberFormat.format(number, outputTo, new FieldPosition(0));
		return 1;
	}

	
	public static String getPreferredEncoding() {
		return ISO_8859_1.name();
	}

	
	public static boolean hasMultibyte(String value) {
		if (value == null)
			return false;
		for (int i = 0; i < value.length(); i++) {
			char c = value.charAt(i);
			if (c > 0xFF) {
				return true;
			}
		}
		return false;
	}

	
	public static boolean isUnicodeString(final String value) {
        return !value.equals(new String(value.getBytes(ISO_8859_1), ISO_8859_1));
	}
	
   
   public static class StringsIterator implements Iterator<String> {
      private String[] strings;
      private int position = 0;
      public StringsIterator(String[] strings) {
         if(strings != null) {
            this.strings = strings;
         } else {
            this.strings = new String[0];
         }
      }

      public boolean hasNext() {
         return position < strings.length;
      }
      public String next() {
         int ourPos = position++;
         if(ourPos >= strings.length)
            throw new ArrayIndexOutOfBoundsException(ourPos);
         return strings[ourPos];
      }
      public void remove() {}
   }


   
   public static String mapMsCodepointString(String string) {
       if (string == null || "".equals(string)) return string;
       initMsCodepointMap();
       
       StringBuilder sb = new StringBuilder();
       final int length = string.length();
       for (int offset = 0; offset < length; ) {
          Integer msCodepoint = string.codePointAt(offset);
          Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);
          sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);
          offset += Character.charCount(msCodepoint);
       }
       
       return sb.toString();
   }
   
   public static synchronized void mapMsCodepoint(int msCodepoint, int unicodeCodepoint) {
       initMsCodepointMap();
       msCodepointToUnicode.put(msCodepoint, unicodeCodepoint);
   }
   
   private static synchronized void initMsCodepointMap() {
       if (msCodepointToUnicode != null) return;
       msCodepointToUnicode = new HashMap<Integer,Integer>();
       int i=0xF020;
       for (int ch : symbolMap_f020) {
           msCodepointToUnicode.put(i++, ch);
       }
       i = 0xf0a0;
       for (int ch : symbolMap_f0a0) {
           msCodepointToUnicode.put(i++, ch);
       }       
   }
   
   private static final int symbolMap_f020[] = {
       ' ', 
       '!', 
       8704, 
       '#', 
       8707, 
       '%', 
       '&', 
       8717, 
       '(', 
       ')', 
       8727, 
       '+', 
       ',', 
       8722, 
       '.', 
       '/', 
       '0', 
       '1', 
       '2', 
       '3', 
       '4', 
       '5', 
       '6', 
       '7', 
       '8', 
       '9', 
       ':', 
       ';', 
       '<', 
       '=', 
       '>', 
       '?', 
       8773, 
       913, 
       914, 
       935, 
       916, 
       917, 
       934, 
       915, 
       919, 
       921, 
       977, 
       922, 
       923, 
       924, 
       925, 
       927, 
       928, 
       920, 
       929, 
       931, 
       932, 
       933, 
       962, 
       937, 
       926, 
       936, 
       918, 
       '[', 
       8765, 
       ']', 
       8869, 
       '_', 
       ' ', 
       945, 
       946, 
       967, 
       948, 
       949, 
       966, 
       947, 
       951, 
       953, 
       981, 
       954, 
       955, 
       956, 
       957, 
       959, 
       960, 
       952, 
       961, 
       963, 
       964, 
       965, 
       982, 
       969, 
       958, 
       968, 
       950, 
       '{', 
       '|', 
       '}', 
       8764, 
       ' ', 
   };

   private static final int symbolMap_f0a0[] = {
       8364, 
       978, 
       8242, 
       8804, 
       8260, 
       8734, 
       402, 
       9827, 
       9830, 
       9829, 
       9824, 
       8596, 
       8591, 
       8593, 
       8594, 
       8595, 
       176, 
       177, 
       8243, 
       8805, 
       215, 
       181, 
       8706, 
       8729, 
       247, 
       8800, 
       8801, 
       8776, 
       8230, 
       9168, 
       9135, 
       8629, 
       8501, 
       8475, 
       8476, 
       8472, 
       8855, 
       8853, 
       8709, 
       8745, 
       8746, 
       8835, 
       8839, 
       8836, 
       8834, 
       8838, 
       8712, 
       8713, 
       8736, 
       8711, 
       174, 
       169, 
       8482, 
       8719, 
       8730, 
       8901, 
       172, 
       8743, 
       8744, 
       8660, 
       8656, 
       8657, 
       8658, 
       8659, 
       9674, 
       9001, 
       174, 
       169, 
       8482, 
       8721, 
       9115, 
       9116, 
       9117, 
       9121, 
       9122, 
       9123, 
       9127, 
       9128, 
       9129, 
       9130, 
       ' ', 
       9002, 
       8747, 
       8992, 
       9134, 
       8993, 
       9118, 
       9119, 
       9120, 
       9124, 
       9125, 
       9126, 
       9131, 
       9132, 
       9133, 
       ' ', 
   };
}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public abstract class VariantTypeException extends HPSFException
{

    private Object value;

    private long variantType;



    
    public VariantTypeException(final long variantType, final Object value,
                                final String msg)
    {
        super(msg);
        this.variantType = variantType;
        this.value = value;
    }



    
    public long getVariantType()
    {
        return variantType;
    }



    
    public Object getValue()
    {
        return value;
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.LinkedList;

import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.Entry;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.LittleEndianConsts;


public class MutablePropertySet extends PropertySet
{

    
    public MutablePropertySet()
    {
        
        byteOrder = LittleEndian.getUShort(BYTE_ORDER_ASSERTION);

        
        format = LittleEndian.getUShort(FORMAT_ASSERTION);

        
        osVersion = (OS_WIN32 << 16) | 0x0A04;

        
        classID = new ClassID();

        
        sections = new LinkedList<Section>();
        sections.add(new MutableSection());
    }



    
    public MutablePropertySet(final PropertySet ps)
    {
        byteOrder = ps.getByteOrder();
        format = ps.getFormat();
        osVersion = ps.getOSVersion();
        setClassID(ps.getClassID());
        clearSections();
        if (sections == null)
            sections = new LinkedList<Section>();
        for (final Section section : ps.getSections())
        {
            final MutableSection s = new MutableSection(section);
            addSection(s);
        }
    }



    
    private final int OFFSET_HEADER =
        BYTE_ORDER_ASSERTION.length + 
        FORMAT_ASSERTION.length +     
        LittleEndianConsts.INT_SIZE + 
        ClassID.LENGTH +              
        LittleEndianConsts.INT_SIZE;  



    
    public void setByteOrder(final int byteOrder)
    {
        this.byteOrder = byteOrder;
    }



    
    public void setFormat(final int format)
    {
        this.format = format;
    }



    
    public void setOSVersion(final int osVersion)
    {
        this.osVersion = osVersion;
    }



    
    public void setClassID(final ClassID classID)
    {
        this.classID = classID;
    }



    
    public void clearSections()
    {
        sections = null;
    }



    
    public void addSection(final Section section)
    {
        if (sections == null)
            sections = new LinkedList<Section>();
        sections.add(section);
    }



    
    public void write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        final int nrSections = sections.size();
        int length = 0;

        
        length += TypeWriter.writeToStream(out, (short) getByteOrder());
        length += TypeWriter.writeToStream(out, (short) getFormat());
        length += TypeWriter.writeToStream(out, getOSVersion());
        length += TypeWriter.writeToStream(out, getClassID());
        length += TypeWriter.writeToStream(out, nrSections);
        int offset = OFFSET_HEADER;

        
        offset += nrSections * (ClassID.LENGTH + LittleEndian.INT_SIZE);
        final int sectionsBegin = offset;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            final ClassID formatID = s.getFormatID();
            if (formatID == null)
                throw new NoFormatIDException();
            length += TypeWriter.writeToStream(out, s.getFormatID());
            length += TypeWriter.writeUIntToStream(out, offset);
            try
            {
                offset += s.getSize();
            }
            catch (HPSFRuntimeException ex)
            {
                final Throwable cause = ex.getReason();
                if (cause instanceof UnsupportedEncodingException) {
                    throw new IllegalPropertySetDataException(cause);
                }
                throw ex;
            }
        }

        
        offset = sectionsBegin;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            offset += s.write(out);
        }
        
        
        out.close();
    }



    
    public InputStream toInputStream()
        throws IOException, WritingNotSupportedException
    {
        final ByteArrayOutputStream psStream = new ByteArrayOutputStream();
        try {
            write(psStream);
        } finally {
            psStream.close();
        }
        final byte[] streamData = psStream.toByteArray();
        return new ByteArrayInputStream(streamData);
    }

    
    public void write(final DirectoryEntry dir, final String name)
    throws WritingNotSupportedException, IOException
    {
        
        try
        {
            final Entry e = dir.getEntry(name);
            e.delete();
        }
        catch (FileNotFoundException ex)
        {
            
        }
        
        dir.createDocument(name, toInputStream());
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class IllegalPropertySetDataException extends HPSFRuntimeException
{

    
    public IllegalPropertySetDataException()
    {
        super();
    }



    
    public IllegalPropertySetDataException(final String msg)
    {
        super(msg);
    }



    
    public IllegalPropertySetDataException(final Throwable reason)
    {
        super(reason);
    }



    
    public IllegalPropertySetDataException(final String msg,
                                           final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;


@Internal
class Vector
{
    private final short _type;

    private TypedPropertyValue[] _values;

    Vector( byte[] data, int startOffset, short type )
    {
        this._type = type;
        read( data, startOffset );
    }

    Vector( short type )
    {
        this._type = type;
    }

    int read( byte[] data, int startOffset )
    {
        int offset = startOffset;

        final long longLength = LittleEndian.getUInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        if ( longLength > Integer.MAX_VALUE )
            throw new UnsupportedOperationException( "Vector is too long -- "
                    + longLength );
        final int length = (int) longLength;

        _values = new TypedPropertyValue[length];

        if ( _type == Variant.VT_VARIANT )
        {
            for ( int i = 0; i < length; i++ )
            {
                TypedPropertyValue value = new TypedPropertyValue();
                offset += value.read( data, offset );
                _values[i] = value;
            }
        }
        else
        {
            for ( int i = 0; i < length; i++ )
            {
                TypedPropertyValue value = new TypedPropertyValue( _type, null );
                
                offset += value.readValue( data, offset );
                _values[i] = value;
            }
        }
        return offset - startOffset;
    }

    TypedPropertyValue[] getValues(){
        return _values;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.util.LittleEndian;


public class TypeWriter
{

    
    public static int writeToStream( final OutputStream out, final short n )
            throws IOException
    {
        LittleEndian.putShort( out, n ); 
        return LittleEndian.SHORT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final int n )
            throws IOException
    {
        LittleEndian.putInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final long n )
            throws IOException
    {
        LittleEndian.putLong( n, out );
        return LittleEndian.LONG_SIZE;
    }

    
    public static void writeUShortToStream( final OutputStream out, final int n )
            throws IOException
    {
        int high = n & 0xFFFF0000;
        if ( high != 0 )
            throw new IllegalPropertySetDataException( "Value " + n
                    + " cannot be represented by 2 bytes." );
        LittleEndian.putUShort( n, out );
    }

    
    public static int writeUIntToStream( final OutputStream out, final long n )
            throws IOException
    {
        long high = n & 0xFFFFFFFF00000000L;
        if ( high != 0 && high != 0xFFFFFFFF00000000L )
            throw new IllegalPropertySetDataException( "Value " + n
                    + " cannot be represented by 4 bytes." );
        LittleEndian.putUInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream(final OutputStream out, final ClassID n)
        throws IOException
    {
        byte[] b = new byte[16];
        n.write(b, 0);
        out.write(b, 0, b.length);
        return b.length;
    }



    
    public static void writeToStream(final OutputStream out,
                                     final Property[] properties,
                                     final int codepage)
        throws IOException, UnsupportedVariantTypeException
    {
        
        if (properties == null)
            return;

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            writeUIntToStream(out, p.getID());
            writeUIntToStream(out, p.getSize());
        }

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            long type = p.getType();
            writeUIntToStream(out, type);
            VariantSupport.write(out, (int) type, p.getValue(), codepage);
        }
    }



    
    public static int writeToStream( final OutputStream out, final double n )
            throws IOException
    {
        LittleEndian.putDouble( n, out );
        return LittleEndian.DOUBLE_SIZE;
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class MarkUnsupportedException extends HPSFException
{

    
    public MarkUnsupportedException()
    {
        super();
    }


    
    public MarkUnsupportedException(final String msg)
    {
        super(msg);
    }


    
    public MarkUnsupportedException(final Throwable reason)
    {
        super(reason);
    }


   
    public MarkUnsupportedException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class ReadingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public ReadingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class Currency
{
    static final int SIZE = 8;

    private byte[] _value;

    Currency( byte[] data, int offset )
    {
        _value = LittleEndian.getByteArray( data, offset, SIZE );
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class VariantBool
{


	private static Logger logger = LoggerFactory.getLogger(VariantBool.class);

    static final int SIZE = 2;

    private boolean _value;

    VariantBool( byte[] data, int offset )
    {
        short value = LittleEndian.getShort( data, offset );
        if ( value == 0x0000 )
        {
            _value = false;
            return;
        }

        if ( value == 0xffff )
        {
            _value = true;
            return;
        }

        logger.warn(  "VARIANT_BOOL value '",
                Short.valueOf( value ), "' is incorrect" );
        _value = value != 0;
    }

    boolean getValue()
    {
        return _value;
    }

    void setValue( boolean value )
    {
        this._value = value;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.docx4j.org.apache.poi.util.LittleEndian;


public abstract class SpecialPropertySet extends MutablePropertySet
{
    
    public abstract PropertyIDMap getPropertySetIDMap();

    
    private MutablePropertySet delegate;



    
    public SpecialPropertySet(final PropertySet ps)
    {
        delegate = new MutablePropertySet(ps);
    }



    
    public SpecialPropertySet(final MutablePropertySet ps)
    {
        delegate = ps;
    }



    
    public int getByteOrder()
    {
        return delegate.getByteOrder();
    }



    
    public int getFormat()
    {
        return delegate.getFormat();
    }



    
    public int getOSVersion()
    {
        return delegate.getOSVersion();
    }



    
    public ClassID getClassID()
    {
        return delegate.getClassID();
    }



    
    public int getSectionCount()
    {
        return delegate.getSectionCount();
    }



    
    public List<Section> getSections()
    {
        return delegate.getSections();
    }



    
    public boolean isSummaryInformation()
    {
        return delegate.isSummaryInformation();
    }



    
    public boolean isDocumentSummaryInformation()
    {
        return delegate.isDocumentSummaryInformation();
    }



    
    public Section getFirstSection()
    {
        return delegate.getFirstSection();
    }


    
    public void addSection(final Section section)
    {
        delegate.addSection(section);
    }



    
    public void clearSections()
    {
        delegate.clearSections();
    }



    
    public void setByteOrder(final int byteOrder)
    {
        delegate.setByteOrder(byteOrder);
    }



    
    public void setClassID(final ClassID classID)
    {
        delegate.setClassID(classID);
    }



    
    public void setFormat(final int format)
    {
        delegate.setFormat(format);
    }



    
    public void setOSVersion(final int osVersion)
    {
        delegate.setOSVersion(osVersion);
    }



    
    public InputStream toInputStream() throws IOException, WritingNotSupportedException
    {
        return delegate.toInputStream();
    }



    
    public void write(final DirectoryEntry dir, final String name) throws WritingNotSupportedException, IOException
    {
        delegate.write(dir, name);
    }

    
    public void write(final OutputStream out) throws WritingNotSupportedException, IOException
    {
        delegate.write(out);
    }

    
    public boolean equals(final Object o)
    {
        return delegate.equals(o);
    }

    
    public Property[] getProperties() throws NoSingleSectionException
    {
        return delegate.getProperties();
    }

    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return delegate.getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyIntValue(id);
    }


    
    
    protected String getPropertyStringValue(final int propertyId) {
        Object propertyValue = getProperty(propertyId);
        return getPropertyStringValue(propertyValue);
    }
    protected static String getPropertyStringValue(final Object propertyValue) {
        
        if (propertyValue == null) return null;
        if (propertyValue instanceof String) return (String)propertyValue;
        
        
        if (propertyValue instanceof byte[]) {
            byte[] b = (byte[])propertyValue;
            if (b.length == 0) {
                return "";
            }
            if (b.length == 1) {
                return Byte.toString(b[0]);
            }
            if (b.length == 2) {
                return Integer.toString( LittleEndian.getUShort(b) );
            }
            if (b.length == 4) {
                return Long.toString( LittleEndian.getUInt(b) );
            }
            
            return new String(b);
        }
        return propertyValue.toString();
    }


    
    public int hashCode()
    {
        return delegate.hashCode();
    }



    
    public String toString()
    {
        return delegate.toString();
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return delegate.wasNull();
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import org.docx4j.org.apache.poi.util.CodePageUtil;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VariantSupport extends Variant
{
	private static Logger logger = LoggerFactory.getLogger(VariantSupport.class);	

    private static boolean logUnsupportedTypes = false;

    
    public static void setLogUnsupportedTypes(final boolean logUnsupportedTypes)
    {
        VariantSupport.logUnsupportedTypes = logUnsupportedTypes;
    }

    
    public static boolean isLogUnsupportedTypes()
    {
        return logUnsupportedTypes;
    }



    
    protected static List<Long> unsupportedMessage;

    
    protected static void writeUnsupportedTypeMessage
        (final UnsupportedVariantTypeException ex)
    {
        if (isLogUnsupportedTypes())
        {
            if (unsupportedMessage == null)
                unsupportedMessage = new LinkedList<Long>();
            Long vt = Long.valueOf(ex.getVariantType());
            if (!unsupportedMessage.contains(vt))
            {
            	logger.error( ex.getMessage());
                unsupportedMessage.add(vt);
            }
        }
    }


    
    final static public int[] SUPPORTED_TYPES = { Variant.VT_EMPTY,
            Variant.VT_I2, Variant.VT_I4, Variant.VT_I8, Variant.VT_R8,
            Variant.VT_FILETIME, Variant.VT_LPSTR, Variant.VT_LPWSTR,
            Variant.VT_CF, Variant.VT_BOOL };



    
    public boolean isSupportedType(final int variantType)
    {
        for (int i = 0; i < SUPPORTED_TYPES.length; i++)
            if (variantType == SUPPORTED_TYPES[i])
                return true;
        return false;
    }



    
    public static Object read( final byte[] src, final int offset,
            final int length, final long type, final int codepage )
            throws ReadingNotSupportedException, UnsupportedEncodingException
    {
        TypedPropertyValue typedPropertyValue = new TypedPropertyValue(
                (int) type, null );
        int unpadded;
        try
        {
            unpadded = typedPropertyValue.readValue( src, offset );
        }
        catch ( UnsupportedOperationException exc )
        {
            int propLength = Math.min( length, src.length - offset );
            final byte[] v = new byte[propLength];
            System.arraycopy( src, offset, v, 0, propLength );
            throw new ReadingNotSupportedException( type, v );
        }

        switch ( (int) type )
        {
        case Variant.VT_EMPTY:
        case Variant.VT_I4:
        case Variant.VT_I8:
        case Variant.VT_R8:
            
            return typedPropertyValue.getValue();

        case Variant.VT_I2:
        {
            
            return Integer.valueOf( ( (Short) typedPropertyValue.getValue() )
                    .intValue() );
        }
        case Variant.VT_FILETIME:
        {
            Filetime filetime = (Filetime) typedPropertyValue.getValue();
            return Util.filetimeToDate( (int) filetime.getHigh(),
                    (int) filetime.getLow() );
        }
        case Variant.VT_LPSTR:
        {
            CodePageString string = (CodePageString) typedPropertyValue
                    .getValue();
            return string.getJavaValue( codepage );
        }
        case Variant.VT_LPWSTR:
        {
            UnicodeString string = (UnicodeString) typedPropertyValue
                    .getValue();
            return string.toJavaString();
        }
        case Variant.VT_CF:
        {
            
            
            
            
            
            
            
            
            ClipboardData clipboardData = (ClipboardData) typedPropertyValue
                    .getValue();
            return clipboardData.toByteArray();
        }

        case Variant.VT_BOOL:
        {
            VariantBool bool = (VariantBool) typedPropertyValue.getValue();
            return Boolean.valueOf( bool.getValue() );
        }

        default:
        {
            
            final byte[] v = new byte[unpadded];
            System.arraycopy( src, offset, v, 0, unpadded );
            throw new ReadingNotSupportedException( type, v );
        }
        }
    }

    
    public static String codepageToEncoding(final int codepage)
    throws UnsupportedEncodingException
    {
        return CodePageUtil.codepageToEncoding(codepage);
    }


    
    public static int write(final OutputStream out, final long type,
                            final Object value, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        switch ((int) type)
        {
            case Variant.VT_BOOL:
            {
                if ( ( (Boolean) value ).booleanValue() )
                {
                    out.write( 0xff );
                    out.write( 0xff );
                }
                else
                {
                    out.write( 0x00 );
                    out.write( 0x00 );
                }
                length += 2;
                break;
            }
            case Variant.VT_LPSTR:
            {
                CodePageString codePageString = new CodePageString( (String) value,
                        codepage );
                length += codePageString.write( out );
                break;
            }
            case Variant.VT_LPWSTR:
            {
                final int nrOfChars = ( (String) value ).length() + 1;
                length += TypeWriter.writeUIntToStream( out, nrOfChars );
                char[] s = ( (String) value ).toCharArray();
                for ( int i = 0; i < s.length; i++ )
                {
                    final int high = ( ( s[i] & 0x0000ff00 ) >> 8 );
                    final int low = ( s[i] & 0x000000ff );
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write( lowb );
                    out.write( highb );
                    length += 2;
                }
                
                out.write( 0x00 );
                out.write( 0x00 );
                length += 2;
                break;
            }
            case Variant.VT_CF:
            {
                final byte[] b = (byte[]) value;
                out.write(b);
                length = b.length;
                break;
            }
            case Variant.VT_EMPTY:
            {
                length += TypeWriter.writeUIntToStream( out, Variant.VT_EMPTY );
                break;
            }
            case Variant.VT_I2:
            {
                length += TypeWriter.writeToStream( out,
                        ( (Integer) value ).shortValue() );
                break;
            }
            case Variant.VT_I4:
            {
                if (!(value instanceof Integer))
                {
                    throw new ClassCastException("Could not cast an object to "
                            + Integer.class.toString() + ": "
                            + value.getClass().toString() + ", "
                            + value.toString());
                }
                length += TypeWriter.writeToStream(out,
                          ((Integer) value).intValue());
                break;
            }
            case Variant.VT_I8:
            {
                length += TypeWriter.writeToStream(out, ((Long) value).longValue());
                break;
            }
            case Variant.VT_R8:
            {
                length += TypeWriter.writeToStream(out,
                          ((Double) value).doubleValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0x00000000FFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                Filetime filetimeValue = new Filetime( low, high);
                length += filetimeValue.write( out );
                break;
            }
            default:
            {
                
                if (value instanceof byte[])
                {
                    final byte[] b = (byte[]) value;
                    out.write(b);
                    length = b.length;
                    writeUnsupportedTypeMessage
                        (new WritingNotSupportedException(type, value));
                }
                else
                    throw new WritingNotSupportedException(type, value);
                break;
            }
        }

        
        while ( ( length & 0x3 ) != 0 )
        {
            out.write( 0x00 );
            length++;
        }

        return length;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.HexDump;


public class ClassID
{
    public static final ClassID OLE10_PACKAGE = new ClassID("{0003000C-0000-0000-C000-000000000046}");
    public static final ClassID PPT_SHOW = new ClassID("{64818D10-4F9B-11CF-86EA-00AA00B929E8}");
    public static final ClassID XLS_WORKBOOK = new ClassID("{00020841-0000-0000-C000-000000000046}");
    public static final ClassID TXT_ONLY = new ClassID("{5e941d80-bf96-11cd-b579-08002b30bfeb}"); 
    public static final ClassID EXCEL97      = new ClassID("{00020820-0000-0000-C000-000000000046}");
    public static final ClassID EXCEL95      = new ClassID("{00020810-0000-0000-C000-000000000046}");
    public static final ClassID WORD97       = new ClassID("{00020906-0000-0000-C000-000000000046}");
    public static final ClassID WORD95       = new ClassID("{00020900-0000-0000-C000-000000000046}");
    public static final ClassID POWERPOINT97 = new ClassID("{64818D10-4F9B-11CF-86EA-00AA00B929E8}");
    public static final ClassID POWERPOINT95 = new ClassID("{EA7BAE70-FB3B-11CD-A903-00AA00510EA3}");
    public static final ClassID EQUATION30   = new ClassID("{0002CE02-0000-0000-C000-000000000046}");
	
	
    
    protected byte[] bytes;



    
    public ClassID(final byte[] src, final int offset)
    {
        read(src, offset);
    }


    
    public ClassID()
    {
        bytes = new byte[LENGTH];
        for (int i = 0; i < LENGTH; i++)
            bytes[i] = 0x00;
    }


    
    public ClassID(String externalForm) {
    	bytes = new byte[LENGTH];
        String clsStr = externalForm.replaceAll("[{}-]", "");
        for (int i=0; i<clsStr.length(); i+=2) {
        	bytes[i/2] = (byte)Integer.parseInt(clsStr.substring(i, i+2), 16);
        }
    }
    

    
    public static final int LENGTH = 16;

    
    public int length()
    {
        return LENGTH;
    }



    
    public byte[] getBytes()
    {
        return bytes;
    }



    
    public void setBytes(final byte[] bytes)
    {
        for (int i = 0; i < this.bytes.length; i++)
            this.bytes[i] = bytes[i];
    }



    
    public byte[] read(final byte[] src, final int offset)
    {
        bytes = new byte[16];

        
        bytes[0] = src[3 + offset];
        bytes[1] = src[2 + offset];
        bytes[2] = src[1 + offset];
        bytes[3] = src[0 + offset];

        
        bytes[4] = src[5 + offset];
        bytes[5] = src[4 + offset];

        
        bytes[6] = src[7 + offset];
        bytes[7] = src[6 + offset];

        
        for (int i = 8; i < 16; i++)
            bytes[i] = src[i + offset];

        return bytes;
    }



    
    public void write(final byte[] dst, final int offset)
    throws ArrayStoreException
    {
        
        if (dst.length < 16)
            throw new ArrayStoreException
                ("Destination byte[] must have room for at least 16 bytes, " +
                 "but has a length of only " + dst.length + ".");
        
        dst[0 + offset] = bytes[3];
        dst[1 + offset] = bytes[2];
        dst[2 + offset] = bytes[1];
        dst[3 + offset] = bytes[0];

        
        dst[4 + offset] = bytes[5];
        dst[5 + offset] = bytes[4];

        
        dst[6 + offset] = bytes[7];
        dst[7 + offset] = bytes[6];

        
        for (int i = 8; i < 16; i++)
            dst[i + offset] = bytes[i];
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof ClassID))
            return false;
        final ClassID cid = (ClassID) o;
        if (bytes.length != cid.bytes.length)
            return false;
        for (int i = 0; i < bytes.length; i++)
            if (bytes[i] != cid.bytes[i])
                return false;
        return true;
    }



    
    public int hashCode()
    {
        return new String(bytes).hashCode();
    }



    
    public String toString()
    {
        StringBuffer sbClassId = new StringBuffer(38);
        sbClassId.append('{');
        for (int i = 0; i < 16; i++)
        {
            sbClassId.append(HexDump.toHex(bytes[i]));
            if (i == 3 || i == 5 || i == 7 || i == 9)
                sbClassId.append('-');
        }
        sbClassId.append('}');
        return sbClassId.toString();
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class MissingSectionException extends HPSFRuntimeException
{

    
    public MissingSectionException()
    {
        super();
    }


    
    public MissingSectionException(final String msg)
    {
        super(msg);
    }


    
    public MissingSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public MissingSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collection;
import java.util.Date;


public class Util
{

    
    public static boolean equal(final byte[] a, final byte[] b)
    {
        if (a.length != b.length)
            return false;
        for (int i = 0; i < a.length; i++)
            if (a[i] != b[i])
                return false;
        return true;
    }



    
    public static void copy(final byte[] src, final int srcOffset,
                            final int length, final byte[] dst,
                            final int dstOffset)
    {
        for (int i = 0; i < length; i++)
            dst[dstOffset + i] = src[srcOffset + i];
    }



    
    public static byte[] cat(final byte[][] byteArrays)
    {
        int capacity = 0;
        for (int i = 0; i < byteArrays.length; i++)
            capacity += byteArrays[i].length;
        final byte[] result = new byte[capacity];
        int r = 0;
        for (int i = 0; i < byteArrays.length; i++)
            for (int j = 0; j < byteArrays[i].length; j++)
                result[r++] = byteArrays[i][j];
        return result;
    }



    
    public static byte[] copy(final byte[] src, final int offset,
                              final int length)
    {
        final byte[] result = new byte[length];
        copy(src, offset, length, result, 0);
        return result;
    }



    
    public static final long EPOCH_DIFF = 11644473600000L;


    
    public static Date filetimeToDate(final int high, final int low)
    {
        final long filetime = ((long) high) << 32 | (low & 0xffffffffL);
        return filetimeToDate(filetime);
    }

    
    public static Date filetimeToDate(final long filetime)
    {
        final long ms_since_16010101 = filetime / (1000 * 10);
        final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF;
        return new Date(ms_since_19700101);
    }



    
    public static long dateToFileTime(final Date date)
    {
        long ms_since_19700101 = date.getTime();
        long ms_since_16010101 = ms_since_19700101 + EPOCH_DIFF;
        return ms_since_16010101 * (1000 * 10);
    }


    
    public static boolean equals(Collection<?> c1, Collection<?> c2)
    {
        Object[] o1 = c1.toArray();
        Object[] o2 = c2.toArray();
        return internalEquals(o1, o2);
    }



    
    public static boolean equals(Object[] c1, Object[] c2)
    {
        final Object[] o1 = c1.clone();
        final Object[] o2 = c2.clone();
        return internalEquals(o1, o2);
    }

    private static boolean internalEquals(Object[] o1, Object[] o2)
    {
        for (int i1 = 0; i1 < o1.length; i1++)
        {
            final Object obj1 = o1[i1];
            boolean matchFound = false;
            for (int i2 = 0; !matchFound && i2 < o1.length; i2++)
            {
                final Object obj2 = o2[i2];
                if (obj1.equals(obj2))
                {
                    matchFound = true;
                    o2[i2] = null;
                }
            }
            if (!matchFound)
                return false;
        }
        return true;
    }



    
    public static byte[] pad4(final byte[] ba)
    {
        final int PAD = 4;
        final byte[] result;
        int l = ba.length % PAD;
        if (l == 0)
            result = ba;
        else
        {
            l = PAD - l;
            result = new byte[ba.length + l];
            System.arraycopy(ba, 0, result, 0, ba.length);
        }
        return result;
    }



    
    public static char[] pad4(final char[] ca)
    {
        final int PAD = 4;
        final char[] result;
        int l = ca.length % PAD;
        if (l == 0)
            result = ca;
        else
        {
            l = PAD - l;
            result = new char[ca.length + l];
            System.arraycopy(ca, 0, result, 0, ca.length);
        }
        return result;
    }



    
    public static char[] pad4(final String s)
    {
        return pad4(s.toCharArray());
    }



    
    public static String toString(final Throwable t)
    {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        t.printStackTrace(pw);
        pw.close();
        try
        {
            sw.close();
            return sw.toString();
        }
        catch (IOException e)
        {
            final StringBuffer b = new StringBuffer(t.getMessage());
            b.append("\n");
            b.append("Could not create a stacktrace. Reason: ");
            b.append(e.getMessage());
            return b.toString();
        }
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class Variant
{

    
    public static final int VT_EMPTY = 0;

    
    public static final int VT_NULL = 1;

    
    public static final int VT_I2 = 2;

    
    public static final int VT_I4 = 3;

    
    public static final int VT_R4 = 4;

    
    public static final int VT_R8 = 5;

    
    public static final int VT_CY = 6;

    
    public static final int VT_DATE = 7;

    
    public static final int VT_BSTR = 8;

    
    public static final int VT_DISPATCH = 9;

    
    public static final int VT_ERROR = 10;

    
    public static final int VT_BOOL = 11;

    
    public static final int VT_VARIANT = 12;

    
    public static final int VT_UNKNOWN = 13;

    
    public static final int VT_DECIMAL = 14;

    
    public static final int VT_I1 = 16;

    
    public static final int VT_UI1 = 17;

    
    public static final int VT_UI2 = 18;

    
    public static final int VT_UI4 = 19;

    
    public static final int VT_I8 = 20;

    
    public static final int VT_UI8 = 21;

    
    public static final int VT_INT = 22;

    
    public static final int VT_UINT = 23;

    
    public static final int VT_VOID = 24;

    
    public static final int VT_HRESULT = 25;

    
    public static final int VT_PTR = 26;

    
    public static final int VT_SAFEARRAY = 27;

    
    public static final int VT_CARRAY = 28;

    
    public static final int VT_USERDEFINED = 29;

    
    public static final int VT_LPSTR = 30;

    
    public static final int VT_LPWSTR = 31;

    
    public static final int VT_FILETIME = 64;

    
    public static final int VT_BLOB = 65;

    
    public static final int VT_STREAM = 66;

    
    public static final int VT_STORAGE = 67;

    
    public static final int VT_STREAMED_OBJECT = 68;

    
    public static final int VT_STORED_OBJECT = 69;

    
    public static final int VT_BLOB_OBJECT = 70;

    
    public static final int VT_CF = 71;

    
    public static final int VT_CLSID = 72;

    
    public static final int VT_VERSIONED_STREAM = 0x0049;

    
    public static final int VT_VECTOR = 0x1000;

    
    public static final int VT_ARRAY = 0x2000;

    
    public static final int VT_BYREF = 0x4000;

    
    public static final int VT_RESERVED = 0x8000;

    
    public static final int VT_ILLEGAL = 0xFFFF;

    
    public static final int VT_ILLEGALMASKED = 0xFFF;

    
    public static final int VT_TYPEMASK = 0xFFF;



    
    private static Map<Long,String> numberToName;

    private static Map<Long,Integer> numberToLength;

    
    public static final Integer LENGTH_UNKNOWN = Integer.valueOf(-2);

    
    public static final Integer LENGTH_VARIABLE = Integer.valueOf(-1);

    
    public static final Integer LENGTH_0 = Integer.valueOf(0);

    
    public static final Integer LENGTH_2 = Integer.valueOf(2);

    
    public static final Integer LENGTH_4 = Integer.valueOf(4);

    
    public static final Integer LENGTH_8 = Integer.valueOf(8);



    static
    {
        
        Map<Long,String> tm1 = new HashMap<Long,String>();
        tm1.put(Long.valueOf(0), "VT_EMPTY");
        tm1.put(Long.valueOf(1), "VT_NULL");
        tm1.put(Long.valueOf(2), "VT_I2");
        tm1.put(Long.valueOf(3), "VT_I4");
        tm1.put(Long.valueOf(4), "VT_R4");
        tm1.put(Long.valueOf(5), "VT_R8");
        tm1.put(Long.valueOf(6), "VT_CY");
        tm1.put(Long.valueOf(7), "VT_DATE");
        tm1.put(Long.valueOf(8), "VT_BSTR");
        tm1.put(Long.valueOf(9), "VT_DISPATCH");
        tm1.put(Long.valueOf(10), "VT_ERROR");
        tm1.put(Long.valueOf(11), "VT_BOOL");
        tm1.put(Long.valueOf(12), "VT_VARIANT");
        tm1.put(Long.valueOf(13), "VT_UNKNOWN");
        tm1.put(Long.valueOf(14), "VT_DECIMAL");
        tm1.put(Long.valueOf(16), "VT_I1");
        tm1.put(Long.valueOf(17), "VT_UI1");
        tm1.put(Long.valueOf(18), "VT_UI2");
        tm1.put(Long.valueOf(19), "VT_UI4");
        tm1.put(Long.valueOf(20), "VT_I8");
        tm1.put(Long.valueOf(21), "VT_UI8");
        tm1.put(Long.valueOf(22), "VT_INT");
        tm1.put(Long.valueOf(23), "VT_UINT");
        tm1.put(Long.valueOf(24), "VT_VOID");
        tm1.put(Long.valueOf(25), "VT_HRESULT");
        tm1.put(Long.valueOf(26), "VT_PTR");
        tm1.put(Long.valueOf(27), "VT_SAFEARRAY");
        tm1.put(Long.valueOf(28), "VT_CARRAY");
        tm1.put(Long.valueOf(29), "VT_USERDEFINED");
        tm1.put(Long.valueOf(30), "VT_LPSTR");
        tm1.put(Long.valueOf(31), "VT_LPWSTR");
        tm1.put(Long.valueOf(64), "VT_FILETIME");
        tm1.put(Long.valueOf(65), "VT_BLOB");
        tm1.put(Long.valueOf(66), "VT_STREAM");
        tm1.put(Long.valueOf(67), "VT_STORAGE");
        tm1.put(Long.valueOf(68), "VT_STREAMED_OBJECT");
        tm1.put(Long.valueOf(69), "VT_STORED_OBJECT");
        tm1.put(Long.valueOf(70), "VT_BLOB_OBJECT");
        tm1.put(Long.valueOf(71), "VT_CF");
        tm1.put(Long.valueOf(72), "VT_CLSID");
        Map<Long,String> tm2 = new HashMap<Long,String>(tm1.size(), 1.0F);
        tm2.putAll(tm1);
        numberToName = Collections.unmodifiableMap(tm2);

        
        Map<Long,Integer> tm3 = new HashMap<Long,Integer>();
        tm3.put(Long.valueOf(0), LENGTH_0);
        tm3.put(Long.valueOf(1), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(2), LENGTH_2);
        tm3.put(Long.valueOf(3), LENGTH_4);
        tm3.put(Long.valueOf(4), LENGTH_4);
        tm3.put(Long.valueOf(5), LENGTH_8);
        tm3.put(Long.valueOf(6), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(7), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(8), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(9), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(10), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(11), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(12), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(13), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(14), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(16), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(17), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(18), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(19), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(20), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(21), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(22), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(23), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(24), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(25), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(26), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(27), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(28), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(29), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(30), LENGTH_VARIABLE);
        tm3.put(Long.valueOf(31), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(64), LENGTH_8);
        tm3.put(Long.valueOf(65), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(66), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(67), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(68), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(69), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(70), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(71), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(72), LENGTH_UNKNOWN);
        Map<Long,Integer> tm4 = new HashMap<Long,Integer>(tm1.size(), 1.0F);
        tm4.putAll(tm3);
        numberToLength = Collections.unmodifiableMap(tm4);
    }



    
    public static String getVariantName(final long variantType)
    {
        final String name = numberToName.get(Long.valueOf(variantType));
        return name != null ? name : "unknown variant type";
    }

    
    public static int getVariantLength(final long variantType)
    {
        final Long key = Long.valueOf((int) variantType);
        final Integer length = numberToLength.get(key);
        if (length == null)
            return -2;
        return length.intValue();
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class Date
{
    static final int SIZE = 8;

    private byte[] _value;

    Date( byte[] data, int offset )
    {
        _value = LittleEndian.getByteArray( data, offset, SIZE );
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.util.Date;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;


public final class SummaryInformation extends SpecialPropertySet {

    
    public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getSummaryInformationProperties();
    }


    
    public SummaryInformation(final PropertySet ps)
            throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isSummaryInformation())
            throw new UnexpectedPropertySetTypeException("Not a "
                    + getClass().getName());
    }



    
    public String getTitle()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TITLE);
    }



    
    public void setTitle(final String title)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TITLE, title);
    }



    
    public void removeTitle()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TITLE);
    }



    
    public String getSubject()
    {
        return getPropertyStringValue(PropertyIDMap.PID_SUBJECT);
    }



    
    public void setSubject(final String subject)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SUBJECT, subject);
    }



    
    public void removeSubject()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SUBJECT);
    }



    
    public String getAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_AUTHOR);
    }



    
    public void setAuthor(final String author)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_AUTHOR, author);
    }



    
    public void removeAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_AUTHOR);
    }



    
    public String getKeywords()
    {
        return getPropertyStringValue(PropertyIDMap.PID_KEYWORDS);
    }



    
    public void setKeywords(final String keywords)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_KEYWORDS, keywords);
    }



    
    public void removeKeywords()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_KEYWORDS);
    }



    
    public String getComments()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMMENTS);
    }



    
    public void setComments(final String comments)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMMENTS, comments);
    }



    
    public void removeComments()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMMENTS);
    }



    
    public String getTemplate()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TEMPLATE);
    }



    
    public void setTemplate(final String template)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TEMPLATE, template);
    }



    
    public void removeTemplate()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TEMPLATE);
    }



    
    public String getLastAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public void setLastAuthor(final String lastAuthor)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTAUTHOR, lastAuthor);
    }



    
    public void removeLastAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public String getRevNumber()
    {
        return getPropertyStringValue(PropertyIDMap.PID_REVNUMBER);
    }



    
    public void setRevNumber(final String revNumber)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_REVNUMBER, revNumber);
    }



    
    public void removeRevNumber()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_REVNUMBER);
    }



    
    public long getEditTime()
    {
        final Date d = (Date) getProperty(PropertyIDMap.PID_EDITTIME);
        if (d == null) {
            return 0;
        }
        return Util.dateToFileTime(d);
    }



    
    public void setEditTime(final long time)
    {
        final Date d = Util.filetimeToDate(time);
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_EDITTIME, Variant.VT_FILETIME, d);
    }



    
    public void removeEditTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_EDITTIME);
    }



    
    public Date getLastPrinted()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public void setLastPrinted(final Date lastPrinted)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTPRINTED, Variant.VT_FILETIME,
                lastPrinted);
    }



    
    public void removeLastPrinted()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public Date getCreateDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public void setCreateDateTime(final Date createDateTime)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CREATE_DTM, Variant.VT_FILETIME,
                createDateTime);
    }



    
    public void removeCreateDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public Date getLastSaveDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public void setLastSaveDateTime(final Date time)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s
                .setProperty(PropertyIDMap.PID_LASTSAVE_DTM,
                        Variant.VT_FILETIME, time);
    }



    
    public void removeLastSaveDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public int getPageCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public void setPageCount(final int pageCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PAGECOUNT, pageCount);
    }



    
    public void removePageCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public int getWordCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public void setWordCount(final int wordCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_WORDCOUNT, wordCount);
    }



    
    public void removeWordCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public int getCharCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public void setCharCount(final int charCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CHARCOUNT, charCount);
    }



    
    public void removeCharCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public byte[] getThumbnail()
    {
        return (byte[]) getProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public void setThumbnail(final byte[] thumbnail)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_THUMBNAIL, 
                Variant.VT_LPSTR, thumbnail);
    }



    
    public void removeThumbnail()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public String getApplicationName()
    {
        return getPropertyStringValue(PropertyIDMap.PID_APPNAME);
    }



    
    public void setApplicationName(final String applicationName)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_APPNAME, applicationName);
    }



    
    public void removeApplicationName()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_APPNAME);
    }



    
    public int getSecurity()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SECURITY);
    }



    
    public void setSecurity(final int security)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SECURITY, security);
    }



    
    public void removeSecurity()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SECURITY);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.docx4j.org.apache.poi.util.CodePageUtil;
import org.docx4j.org.apache.poi.util.LittleEndian;


public class MutableSection extends Section
{
    
    private boolean dirty = true;



    
    private List<Property> preprops;



    
    private byte[] sectionBytes;



    
    public MutableSection()
    {
        dirty = true;
        formatID = null;
        offset = -1;
        preprops = new LinkedList<Property>();
    }



    
    public MutableSection(final Section s)
    {
        setFormatID(s.getFormatID());
        final Property[] pa = s.getProperties();
        final MutableProperty[] mpa = new MutableProperty[pa.length];
        for (int i = 0; i < pa.length; i++)
            mpa[i] = new MutableProperty(pa[i]);
        setProperties(mpa);
        setDictionary(s.getDictionary());
    }



    
    public void setFormatID(final ClassID formatID)
    {
        this.formatID = formatID;
    }



    
    public void setFormatID(final byte[] formatID)
    {
        ClassID fid = getFormatID();
        if (fid == null)
        {
            fid = new ClassID();
            setFormatID(fid);
        }
        fid.setBytes(formatID);
    }



    
    public void setProperties(final Property[] properties)
    {
        this.properties = properties;
        preprops = new LinkedList<Property>();
        for (int i = 0; i < properties.length; i++)
            preprops.add(properties[i]);
        dirty = true;
    }



    
    public void setProperty(final int id, final String value)
    {
        setProperty(id, Variant.VT_LPWSTR, value);
        dirty = true;
    }



    
    public void setProperty(final int id, final int value)
    {
        setProperty(id, Variant.VT_I4, Integer.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long value)
    {
        setProperty(id, Variant.VT_I8, Long.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long variantType,
                            final Object value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(id);
        p.setType(variantType);
        p.setValue(value);
        setProperty(p);
        dirty = true;
    }



    
    public void setProperty(final Property p)
    {
        final long id = p.getID();
        removeProperty(id);
        preprops.add(p);
        dirty = true;
    }



    
    public void removeProperty(final long id)
    {
        for (final Iterator<Property> i = preprops.iterator(); i.hasNext();)
            if (i.next().getID() == id)
            {
                i.remove();
                break;
            }
        dirty = true;
    }



    
    protected void setPropertyBooleanValue(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
    }



    
    public int getSize()
    {
        if (dirty)
        {
            try
            {
                size = calcSize();
                dirty = false;
            }
            catch (HPSFRuntimeException ex)
            {
                throw ex;
            }
            catch (Exception ex)
            {
                throw new HPSFRuntimeException(ex);
            }
        }
        return size;
    }



    
    private int calcSize() throws WritingNotSupportedException, IOException
    {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        write(out);
        out.close();
        
        sectionBytes = Util.pad4(out.toByteArray());
        return sectionBytes.length;
    }



    
    public int write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        if (!dirty && sectionBytes != null)
        {
            out.write(sectionBytes);
            return sectionBytes.length;
        }

        
        final ByteArrayOutputStream propertyStream =
            new ByteArrayOutputStream();

        
        final ByteArrayOutputStream propertyListStream =
            new ByteArrayOutputStream();

        
        int position = 0;

        
        position += 2 * LittleEndian.INT_SIZE +
                    getPropertyCount() * 2 * LittleEndian.INT_SIZE;

        
        int codepage = -1;
        if (getProperty(PropertyIDMap.PID_DICTIONARY) != null)
        {
            final Object p1 = getProperty(PropertyIDMap.PID_CODEPAGE);
            if (p1 != null)
            {
                if (!(p1 instanceof Integer))
                    throw new IllegalPropertySetDataException
                        ("The codepage property (ID = 1) must be an " +
                         "Integer object.");
            }
            else
                
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
            codepage = getCodepage();
        }

        
        Collections.sort(preprops, new Comparator<Property>()
            {
                public int compare(final Property p1, final Property p2)
                {
                    if (p1.getID() < p2.getID())
                        return -1;
                    else if (p1.getID() == p2.getID())
                        return 0;
                    else
                        return 1;
                }
            });

        
        for (final ListIterator<Property> i = preprops.listIterator(); i.hasNext();)
        {
            final MutableProperty p = (MutableProperty) i.next();
            final long id = p.getID();

            
            TypeWriter.writeUIntToStream(propertyListStream, p.getID());
            TypeWriter.writeUIntToStream(propertyListStream, position);

            
            if (id != 0)
                
                position += p.write(propertyStream, getCodepage());
            else
            {
                if (codepage == -1)
                    throw new IllegalPropertySetDataException
                        ("Codepage (property 1) is undefined.");
                position += writeDictionary(propertyStream, dictionary,
                                            codepage);
            }
        }
        propertyStream.close();
        propertyListStream.close();

        
        byte[] pb1 = propertyListStream.toByteArray();
        byte[] pb2 = propertyStream.toByteArray();

        
        TypeWriter.writeToStream(out, LittleEndian.INT_SIZE * 2 +
                                      pb1.length + pb2.length);

        
        TypeWriter.writeToStream(out, getPropertyCount());

        
        out.write(pb1);

        
        out.write(pb2);

        int streamLength = LittleEndian.INT_SIZE * 2 + pb1.length + pb2.length;
        return streamLength;
    }



    
    private static int writeDictionary(final OutputStream out,
                                       final Map<Long,String> dictionary, final int codepage)
        throws IOException
    {
        int length = TypeWriter.writeUIntToStream(out, dictionary.size());
        for (final Iterator<Long> i = dictionary.keySet().iterator(); i.hasNext();)
        {
            final Long key = i.next();
            final String value = dictionary.get(key);

            if (codepage == CodePageUtil.CP_UNICODE)
            {
                
                int sLength = value.length() + 1;
                if (sLength % 2 == 1)
                    sLength++;
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, sLength);
                final byte[] ca = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 2; j < ca.length; j += 2)
                {
                    out.write(ca[j+1]);
                    out.write(ca[j]);
                    length += 2;
                }
                sLength -= value.length();
                while (sLength > 0)
                {
                    out.write(0x00);
                    out.write(0x00);
                    length += 2;
                    sLength--;
                }
            }
            else
            {
                
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, value.length() + 1);
                final byte[] ba = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 0; j < ba.length; j++)
                {
                    out.write(ba[j]);
                    length++;
                }
                out.write(0x00);
                length++;
            }
        }
        return length;
    }



    
    public int getPropertyCount()
    {
        return preprops.size();
    }



    
    public Property[] getProperties()
    {
        properties = preprops.toArray(new Property[0]);
        return properties;
    }



    
    public Object getProperty(final long id)
    {
        
        getProperties();
        return super.getProperty(id);
    }



    
    public void setDictionary(final Map<Long,String> dictionary)
        throws IllegalPropertySetDataException
    {
        if (dictionary != null)
        {
            this.dictionary = dictionary;

            
            setProperty(PropertyIDMap.PID_DICTIONARY, -1, dictionary);

            
            final Integer codepage =
                (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
            if (codepage == null)
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
        }
        else
            
            removeProperty(PropertyIDMap.PID_DICTIONARY);
    }



    
    public void setProperty(final int id, final Object value)
    {
        if (value instanceof String)
            setProperty(id, (String) value);
        else if (value instanceof Long)
            setProperty(id, ((Long) value).longValue());
        else if (value instanceof Integer)
            setProperty(id, ((Integer) value).intValue());
        else if (value instanceof Short)
            setProperty(id, ((Short) value).intValue());
        else if (value instanceof Boolean)
            setProperty(id, ((Boolean) value).booleanValue());
        else if (value instanceof Date)
            setProperty(id, Variant.VT_FILETIME, value);
        else
            throw new HPSFRuntimeException(
                    "HPSF does not support properties of type " +
                    value.getClass().getName() + ".");
    }



    
    public void clear()
    {
        final Property[] properties = getProperties();
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            removeProperty(p.getID());
        }
    }

    
    public void setCodepage(final int codepage)
    {
        setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                Integer.valueOf(codepage));
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.HexDump;


public abstract class UnsupportedVariantTypeException
extends VariantTypeException
{

    
    public UnsupportedVariantTypeException(final long variantType,
                                           final Object value)
    {
        super(variantType, value,
              "HPSF does not yet support the variant type " + variantType + 
              " (" + Variant.getVariantName(variantType) + ", " +
              HexDump.toHex(variantType) + "). If you want support for " +
              "this variant type in one of the next POI releases please " +
              "submit a request for enhancement (RFE) to " +
              "<http:
    }



}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class Array
{
    static class ArrayDimension
    {
        static final int SIZE = 8;

        private int _indexOffset;
        private long _size;

        ArrayDimension( byte[] data, int offset )
        {
            _size = LittleEndian.getUInt( data, offset );
            _indexOffset = LittleEndian.getInt( data, offset
                    + LittleEndian.INT_SIZE );
        }
    }

    static class ArrayHeader
    {
        private ArrayDimension[] _dimensions;
        private int _type;

        ArrayHeader( byte[] data, int startOffset )
        {
            int offset = startOffset;

            _type = LittleEndian.getInt( data, offset );
            offset += LittleEndian.INT_SIZE;

            long numDimensionsUnsigned = LittleEndian.getUInt( data, offset );
            offset += LittleEndian.INT_SIZE;

            if ( !( 1 <= numDimensionsUnsigned && numDimensionsUnsigned <= 31 ) )
                throw new IllegalPropertySetDataException(
                        "Array dimension number " + numDimensionsUnsigned
                                + " is not in [1; 31] range" );
            int numDimensions = (int) numDimensionsUnsigned;

            _dimensions = new ArrayDimension[numDimensions];
            for ( int i = 0; i < numDimensions; i++ )
            {
                _dimensions[i] = new ArrayDimension( data, offset );
                offset += ArrayDimension.SIZE;
            }
        }

        long getNumberOfScalarValues()
        {
            long result = 1;
            for ( ArrayDimension dimension : _dimensions )
                result *= dimension._size;
            return result;
        }

        int getSize()
        {
            return LittleEndian.INT_SIZE * 2 + _dimensions.length
                    * ArrayDimension.SIZE;
        }

        int getType()
        {
            return _type;
        }
    }

    private ArrayHeader _header;
    private TypedPropertyValue[] _values;

    Array()
    {
    }

    Array( final byte[] data, final int offset )
    {
        read( data, offset );
    }

    int read( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        _header = new ArrayHeader( data, offset );
        offset += _header.getSize();

        long numberOfScalarsLong = _header.getNumberOfScalarValues();
        if ( numberOfScalarsLong > Integer.MAX_VALUE )
            throw new UnsupportedOperationException(
                    "Sorry, but POI can't store array of properties with size of "
                            + numberOfScalarsLong + " in memory" );
        int numberOfScalars = (int) numberOfScalarsLong;

        _values = new TypedPropertyValue[numberOfScalars];
        final int type = _header._type;
        if ( type == Variant.VT_VARIANT )
        {
            for ( int i = 0; i < numberOfScalars; i++ )
            {
                TypedPropertyValue typedPropertyValue = new TypedPropertyValue();
                offset += typedPropertyValue.read( data, offset );
            }
        }
        else
        {
            for ( int i = 0; i < numberOfScalars; i++ )
            {
                TypedPropertyValue typedPropertyValue = new TypedPropertyValue(
                        type, null );
                offset += typedPropertyValue.readValuePadded( data, offset );
            }
        }

        return offset - startOffset;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class NoSingleSectionException extends HPSFRuntimeException
{

    
    public NoSingleSectionException()
    {
        super();
    }


    
    public NoSingleSectionException(final String msg)
    {
        super(msg);
    }


    
    public NoSingleSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoSingleSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class NoPropertySetStreamException extends HPSFException
{

    
    public NoPropertySetStreamException()
    {
        super();
    }



    
    public NoPropertySetStreamException(final String msg)
    {
        super(msg);
    }



    
    public NoPropertySetStreamException(final Throwable reason)
    {
        super(reason);
    }



    
    public NoPropertySetStreamException(final String msg,
                                        final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class ClipboardData
{


	private static Logger logger = LoggerFactory.getLogger(ClipboardData.class);

    private int _format;
    private byte[] _value;

    ClipboardData( byte[] data, int offset )
    {
        int size = LittleEndian.getInt( data, offset );

        if ( size < 4 )
        {
            logger.warn( "ClipboardData at offset ",
                    Integer.valueOf( offset ), " size less than 4 bytes "
                            + "(doesn't even have format field!). "
                            + "Setting to format == 0 and hope for the best" );
            _format = 0;
            _value = new byte[0];
            return;
        }

        _format = LittleEndian.getInt( data, offset + LittleEndian.INT_SIZE );
        _value = LittleEndian.getByteArray( data, offset
                + LittleEndian.INT_SIZE * 2, size - LittleEndian.INT_SIZE );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE * 2 + _value.length;
    }

    byte[] getValue()
    {
        return _value;
    }

    byte[] toByteArray()
    {
        byte[] result = new byte[getSize()];
        LittleEndian.putInt( result, 0 * LittleEndian.INT_SIZE,
                LittleEndian.INT_SIZE + _value.length );
        LittleEndian.putInt( result, 1 * LittleEndian.INT_SIZE, _format );
        System.arraycopy( _value, 0, result, LittleEndian.INT_SIZE
                + LittleEndian.INT_SIZE, _value.length );
        return result;
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( LittleEndian.INT_SIZE + _value.length, out );
        LittleEndian.putInt( _format, out );
        out.write( _value );
        return 2 * LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class Blob
{
    private byte[] _value;

    Blob( byte[] data, int offset )
    {
        int size = LittleEndian.getInt( data, offset );

        if ( size == 0 )
        {
            _value = new byte[0];
            return;
        }

        _value = LittleEndian.getByteArray( data, offset
                + LittleEndian.INT_SIZE, size );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class WritingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public WritingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

import org.docx4j.org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.docx4j.org.apache.poi.util.LittleEndian;


public class PropertySet
{

    
    static final byte[] BYTE_ORDER_ASSERTION =
        new byte[] {(byte) 0xFE, (byte) 0xFF};

    
    protected int byteOrder;

    
    public int getByteOrder()
    {
        return byteOrder;
    }



    
    static final byte[] FORMAT_ASSERTION =
        new byte[]{(byte) 0x00, (byte) 0x00};

    
    protected int format;

    
    public int getFormat()
    {
        return format;
    }


 
    
    protected int osVersion;


    
    public static final int OS_WIN16     = 0x0000;

    
    public static final int OS_MACINTOSH = 0x0001;

    
    public static final int OS_WIN32     = 0x0002;

    
    public int getOSVersion()
    {
        return osVersion;
    }



    
    protected ClassID classID;

    
    public ClassID getClassID()
    {
        return classID;
    }



    
    public int getSectionCount()
    {
        return sections.size();
    }



    
    protected List<Section> sections;

    
    public List<Section> getSections()
    {
        return sections;
    }



    
    protected PropertySet()
    { }



    
    public PropertySet(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               IOException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream))
        {
            final int avail = stream.available();
            final byte[] buffer = new byte[avail];
            stream.read(buffer, 0, buffer.length);
            init(buffer, 0, buffer.length);
        }
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream, final int offset, final int length)
        throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream, offset, length))
            init(stream, offset, length);
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream)
    throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        this(stream, 0, stream.length);
    }



    
    public static boolean isPropertySetStream(final InputStream stream)
        throws MarkUnsupportedException, IOException
    {
        
        final int BUFFER_SIZE = 50;

        
        if (!stream.markSupported())
            throw new MarkUnsupportedException(stream.getClass().getName());
        stream.mark(BUFFER_SIZE);

        
        final byte[] buffer = new byte[BUFFER_SIZE];
        final int bytes =
            stream.read(buffer, 0,
                        Math.min(buffer.length, stream.available()));
        final boolean isPropertySetStream =
            isPropertySetStream(buffer, 0, bytes);
        stream.reset();
        return isPropertySetStream;
    }



    
    public static boolean isPropertySetStream(final byte[] src,
                                              final int offset,
                                              final int length)
    {
        

        
        int o = offset;
        final int byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        byte[] temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) byteOrder);
        if (!Util.equal(temp, BYTE_ORDER_ASSERTION))
            return false;
        final int format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) format);
        if (!Util.equal(temp, FORMAT_ASSERTION))
            return false;
        
        o += LittleEndian.INT_SIZE;
        
        o += ClassID.LENGTH;
        final long sectionCount = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            return false;
        return true;
    }



    
    private void init(final byte[] src, final int offset, final int length)
    throws UnsupportedEncodingException
    {
        
        
        
        int o = offset;
        byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        osVersion = (int) LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        classID = new ClassID(src, o);
        o += ClassID.LENGTH;
        final int sectionCount = LittleEndian.getInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            throw new HPSFRuntimeException("Section count " + sectionCount +
                                           " is negative.");

        
        
        sections = new ArrayList<Section>( sectionCount );

        
        for (int i = 0; i < sectionCount; i++)
        {
            final Section s = new Section(src, o);
            o += ClassID.LENGTH + LittleEndian.INT_SIZE;
            sections.add(s);
        }
    }



    
    public boolean isSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.SUMMARY_INFORMATION_ID);
    }



    
    public boolean isDocumentSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
    }



    
    public Property[] getProperties()
        throws NoSingleSectionException
    {
        return getFirstSection().getProperties();
    }



    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return getFirstSection().getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyIntValue(id);
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return getFirstSection().wasNull();
    }



    
    public Section getFirstSection()
    {
        if (getSectionCount() < 1)
            throw new MissingSectionException("Property set does not contain any sections.");
        return sections.get(0);
    }



    
    public Section getSingleSection()
    {
        final int sectionCount = getSectionCount();
        if (sectionCount != 1)
            throw new NoSingleSectionException
                ("Property set contains " + sectionCount + " sections.");
        return sections.get(0);
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof PropertySet))
            return false;
        final PropertySet ps = (PropertySet) o;
        int byteOrder1 = ps.getByteOrder();
        int byteOrder2 = getByteOrder();
        ClassID classID1 = ps.getClassID();
        ClassID classID2 = getClassID();
        int format1 = ps.getFormat();
        int format2 = getFormat();
        int osVersion1 = ps.getOSVersion();
        int osVersion2 = getOSVersion();
        int sectionCount1 = ps.getSectionCount();
        int sectionCount2 = getSectionCount();
        if (byteOrder1 != byteOrder2      ||
            !classID1.equals(classID2)    ||
            format1 != format2            ||
            osVersion1 != osVersion2      ||
            sectionCount1 != sectionCount2)
            return false;

        
        return Util.equals(getSections(), ps.getSections());
    }



    
    public int hashCode()
    {
        throw new UnsupportedOperationException("FIXME: Not yet implemented.");
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int sectionCount = getSectionCount();
        b.append(getClass().getName());
        b.append('[');
        b.append("byteOrder: ");
        b.append(getByteOrder());
        b.append(", classID: ");
        b.append(getClassID());
        b.append(", format: ");
        b.append(getFormat());
        b.append(", OSVersion: ");
        b.append(getOSVersion());
        b.append(", sectionCount: ");
        b.append(sectionCount);
        b.append(", sections: [\n");
        for (Section section: getSections())
            b.append(section);
        b.append(']');
        b.append(']');
        return b.toString();
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;



import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.docx4j.org.apache.poi.util.StringUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class UnicodeString {


	private static Logger logger = LoggerFactory.getLogger(UnicodeString.class);
	

    private byte[] _value;

    UnicodeString(byte[] data, int offset) {
        int length = LittleEndian.getInt( data, offset );
        int dataOffset = offset + LittleEndian.INT_SIZE;
        
        if (! validLength(length, data, dataOffset)) {
            
            
            
            boolean valid = false;
            int past4byte = offset % 4;
            if (past4byte != 0) {
                offset = offset + past4byte;
                length = LittleEndian.getInt( data, offset );
                dataOffset = offset + LittleEndian.INT_SIZE;
                
                valid = validLength(length, data, dataOffset);
            }
            
            if (!valid) {
                throw new IllegalPropertySetDataException(
                        "UnicodeString started at offset #" + offset +
                        " is not NULL-terminated" );
            }
        }

        if ( length == 0 )
        {
            _value = new byte[0];
            return;
        }

        _value = LittleEndian.getByteArray( data, dataOffset, length * 2 );
    }
    
    
    boolean validLength(int length, byte[] data, int offset) {
        if (length == 0) {
            return true;
        }

        int endOffset = offset + (length * 2);
        if (endOffset <= data.length) {
            
            if (data[endOffset-1] == 0 && data[endOffset-2] == 0) {
                
                return true;
            }
        }

        
        return false;
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }

    byte[] getValue()
    {
        return _value;
    }

    String toJavaString()
    {
        if ( _value.length == 0 )
            return null;

        String result = StringUtil.getFromUnicodeLE( _value, 0,
                _value.length >> 1 );

        final int terminator = result.indexOf( '\0' );
        if ( terminator == -1 )
        {
            logger.warn(
                    "String terminator (\\0) for UnicodeString property value not found."
                            + "Continue without trimming and hope for the best." );
            return result;
        }
        if ( terminator != result.length() - 1 )
        {
            logger.warn(
                    "String terminator (\\0) for UnicodeString property value occured before the end of string. "
                            + "Trimming and hope for the best." );
        }
        return result.substring( 0, terminator );
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.util.LittleEndian;

class Filetime
{
    static final int SIZE = LittleEndian.INT_SIZE * 2;

    private int _dwHighDateTime;
    private int _dwLowDateTime;

    Filetime( byte[] data, int offset )
    {
        _dwLowDateTime = LittleEndian.getInt( data, offset + 0
                * LittleEndian.INT_SIZE );
        _dwHighDateTime = LittleEndian.getInt( data, offset + 1
                * LittleEndian.INT_SIZE );
    }

    Filetime( int low, int high )
    {
        _dwLowDateTime = low;
        _dwHighDateTime = high;
    }

    long getHigh()
    {
        return _dwHighDateTime;
    }

    long getLow()
    {
        return _dwLowDateTime;
    }

    byte[] toByteArray()
    {
        byte[] result = new byte[SIZE];
        LittleEndian.putInt( result, 0 * LittleEndian.INT_SIZE, _dwLowDateTime );
        LittleEndian
                .putInt( result, 1 * LittleEndian.INT_SIZE, _dwHighDateTime );
        return result;
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( _dwLowDateTime, out );
        LittleEndian.putInt( _dwHighDateTime, out );
        return SIZE;
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class GUID
{
    static final int SIZE = 16;

    private int _data1;
    private short _data2;
    private short _data3;
    private long _data4;

    GUID( byte[] data, int offset )
    {
        _data1 = LittleEndian.getInt( data, offset + 0 );
        _data2 = LittleEndian.getShort( data, offset + 4 );
        _data3 = LittleEndian.getShort( data, offset + 6 );
        _data4 = LittleEndian.getLong( data, offset + 8 );
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.docx4j.org.apache.poi.util.CodePageUtil;


public class MutableProperty extends Property
{

    
    public MutableProperty()
    { }



    
    public MutableProperty(final Property p)
    {
        setID(p.getID());
        setType(p.getType());
        setValue(p.getValue());
    }


    
    public void setID(final long id)
    {
        this.id = id;
    }



    
    public void setType(final long type)
    {
        this.type = type;
    }



    
    public void setValue(final Object value)
    {
        this.value = value;
    }



    
    public int write(final OutputStream out, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        long variantType = getType();

        
        if (codepage == CodePageUtil.CP_UNICODE && variantType == Variant.VT_LPSTR)
            variantType = Variant.VT_LPWSTR;

        length += TypeWriter.writeUIntToStream(out, variantType);
        length += VariantSupport.write(out, variantType, getValue(), codepage);
        return length;
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;



public class HPSFRuntimeException extends RuntimeException
{
	private static final long serialVersionUID = -7804271670232727159L;
	
    private Throwable reason;



    
    public HPSFRuntimeException()
    {
        super();
    }



    
    public HPSFRuntimeException(final String msg)
    {
        super(msg);
    }



    
    public HPSFRuntimeException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFRuntimeException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }











































}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.util.Iterator;
import java.util.Map;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.docx4j.org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.docx4j.org.apache.poi.util.CodePageUtil;


public class DocumentSummaryInformation extends SpecialPropertySet
{
    
    public static final String DEFAULT_STREAM_NAME =
        "\005DocumentSummaryInformation";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getDocumentSummaryInformationProperties();
    }


    
    public DocumentSummaryInformation(final PropertySet ps)
        throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isDocumentSummaryInformation())
            throw new UnexpectedPropertySetTypeException
                ("Not a " + getClass().getName());
    }

    
    
    public String getCategory()
    {
        return getPropertyStringValue(PropertyIDMap.PID_CATEGORY);
    }

    
    public void setCategory(final String category)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CATEGORY, category);
    }

    
    public void removeCategory()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CATEGORY);
    }



    
    public String getPresentationFormat()
    {
        return getPropertyStringValue(PropertyIDMap.PID_PRESFORMAT);
    }

    
    public void setPresentationFormat(final String presentationFormat)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PRESFORMAT, presentationFormat);
    }

    
    public void removePresentationFormat()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PRESFORMAT);
    }



    
    public int getByteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_BYTECOUNT);
    }

    
    public void setByteCount(final int byteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_BYTECOUNT, byteCount);
    }

    
    public void removeByteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_BYTECOUNT);
    }



    
    public int getLineCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_LINECOUNT);
    }

    
    public void setLineCount(final int lineCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINECOUNT, lineCount);
    }

    
    public void removeLineCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINECOUNT);
    }



    
    public int getParCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PARCOUNT);
    }

    
    public void setParCount(final int parCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PARCOUNT, parCount);
    }

    
    public void removeParCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PARCOUNT);
    }



    
    public int getSlideCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SLIDECOUNT);
    }

    
    public void setSlideCount(final int slideCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SLIDECOUNT, slideCount);
    }

    
    public void removeSlideCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SLIDECOUNT);
    }



    
    public int getNoteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_NOTECOUNT);
    }

    
    public void setNoteCount(final int noteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_NOTECOUNT, noteCount);
    }

    
    public void removeNoteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_NOTECOUNT);
    }



    
    public int getHiddenCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_HIDDENCOUNT);
    }

    
    public void setHiddenCount(final int hiddenCount)
    {
        final MutableSection s = (MutableSection) getSections().get(0);
        s.setProperty(PropertyIDMap.PID_HIDDENCOUNT, hiddenCount);
    }

    
    public void removeHiddenCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HIDDENCOUNT);
    }



    
    public int getMMClipCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_MMCLIPCOUNT);
    }

    
    public void setMMClipCount(final int mmClipCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MMCLIPCOUNT, mmClipCount);
    }

    
    public void removeMMClipCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MMCLIPCOUNT);
    }



    
    public boolean getScale()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_SCALE);
    }

    
    public void setScale(final boolean scale)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SCALE, scale);
    }

    
    public void removeScale()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SCALE);
    }



    
    public byte[] getHeadingPair()
    {
        notYetImplemented("Reading byte arrays ");
        return (byte[]) getProperty(PropertyIDMap.PID_HEADINGPAIR);
    }

    
    public void setHeadingPair(final byte[] headingPair)
    {
        notYetImplemented("Writing byte arrays ");
    }

    
    public void removeHeadingPair()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HEADINGPAIR);
    }



    
    public byte[] getDocparts()
    {
        notYetImplemented("Reading byte arrays");
        return (byte[]) getProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public void setDocparts(final byte[] docparts)
    {
        notYetImplemented("Writing byte arrays");
    }

    
    public void removeDocparts()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public String getManager()
    {
        return getPropertyStringValue(PropertyIDMap.PID_MANAGER);
    }

    
    public void setManager(final String manager)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MANAGER, manager);
    }

    
    public void removeManager()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MANAGER);
    }



    
    public String getCompany()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMPANY);
    }

    
    public void setCompany(final String company)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMPANY, company);
    }

    
    public void removeCompany()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMPANY);
    }


    
    public boolean getLinksDirty()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_LINKSDIRTY);
    }

    
    public void setLinksDirty(final boolean linksDirty)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINKSDIRTY, linksDirty);
    }

    
    public void removeLinksDirty()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINKSDIRTY);
    }


    
    public CustomProperties getCustomProperties()
    {
        CustomProperties cps = null;
        if (getSectionCount() >= 2)
        {
            cps = new CustomProperties();
            final Section section = getSections().get(1);
            final Map<Long,String> dictionary = section.getDictionary();
            final Property[] properties = section.getProperties();
            int propertyCount = 0;
            for (int i = 0; i < properties.length; i++)
            {
                final Property p = properties[i];
                final long id = p.getID();
                if (id != 0 && id != 1)
                {
                    propertyCount++;
                    final CustomProperty cp = new CustomProperty(p,
                            dictionary.get(Long.valueOf(id)));
                    cps.put(cp.getName(), cp);
                }
            }
            if (cps.size() != propertyCount)
                cps.setPure(false);
        }
        return cps;
    }

    
    public void setCustomProperties(final CustomProperties customProperties)
    {
        ensureSection2();
        final MutableSection section = (MutableSection) getSections().get(1);
        final Map<Long,String> dictionary = customProperties.getDictionary();
        section.clear();

        
        int cpCodepage = customProperties.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = section.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = CodePageUtil.CP_UNICODE;
        customProperties.setCodepage(cpCodepage);
        section.setCodepage(cpCodepage);
        section.setDictionary(dictionary);
        for (final Iterator<CustomProperty> i = customProperties.values().iterator(); i.hasNext();)
        {
            final Property p = i.next();
            section.setProperty(p);
        }
    }

    
    private void ensureSection2()
    {
        if (getSectionCount() < 2)
        {
            MutableSection s2 = new MutableSection();
            s2.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[1]);
            addSection(s2);
        }
    }

    
    public void removeCustomProperties()
    {
        if (getSectionCount() >= 2)
            getSections().remove(1);
        else
            throw new HPSFRuntimeException("Illegal internal format of Document SummaryInformation stream: second section is missing.");
    }


    
    private void notYetImplemented(final String msg)
    {
        throw new UnsupportedOperationException(msg + " is not yet implemented.");
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class HPSFException extends Exception
{

    
    private Throwable reason;



    
    public HPSFException()
    {
        super();
    }



    
    public HPSFException(final String msg)
    {
        super(msg);
    }



    
    public HPSFException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;

@Internal
class VersionedStream
{
    private GUID _versionGuid;
    private IndirectPropertyName _streamName;

    VersionedStream( byte[] data, int offset )
    {
        _versionGuid = new GUID( data, offset );
        _streamName = new IndirectPropertyName( data, offset + GUID.SIZE );
    }

    int getSize()
    {
        return GUID.SIZE + _streamName.getSize();
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;

@Internal
class Decimal
{
    static final int SIZE = 16;

    private short field_1_wReserved;
    private byte field_2_scale;
    private byte field_3_sign;
    private int field_4_hi32;
    private long field_5_lo64;

    Decimal( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        field_1_wReserved = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;

        field_2_scale = data[offset];
        offset += LittleEndian.BYTE_SIZE;

        field_3_sign = data[offset];
        offset += LittleEndian.BYTE_SIZE;

        field_4_hi32 = LittleEndian.getInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        field_5_lo64 = LittleEndian.getLong( data, offset );
        offset += LittleEndian.LONG_SIZE;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.docx4j.org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.docx4j.org.apache.poi.util.LittleEndian;


public class Section
{

    
    protected Map<Long,String> dictionary;

    
    protected ClassID formatID;


    
    public ClassID getFormatID()
    {
        return formatID;
    }



    
    protected long offset;


    
    public long getOffset()
    {
        return offset;
    }



    
    protected int size;


    
    public int getSize()
    {
        return size;
    }



    
    public int getPropertyCount()
    {
        return properties.length;
    }



    
    protected Property[] properties;


    
    public Property[] getProperties()
    {
        return properties;
    }



    
    protected Section()
    { }



    
    public Section(final byte[] src, final int offset)
    throws UnsupportedEncodingException
    {
        int o1 = offset;

        
        formatID = new ClassID(src, o1);
        o1 += ClassID.LENGTH;

        
        this.offset = LittleEndian.getUInt(src, o1);
        o1 = (int) this.offset;

        
        size = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        final int propertyCount = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        properties = new Property[propertyCount];

        
        int pass1Offset = o1;
        final List<PropertyListEntry> propertyList = new ArrayList<PropertyListEntry>(propertyCount);
        PropertyListEntry ple;
        for (int i = 0; i < properties.length; i++)
        {
            ple = new PropertyListEntry();

            
            ple.id = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            ple.offset = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            propertyList.add(ple);
        }

        
        Collections.sort(propertyList);

        
        for (int i = 0; i < propertyCount - 1; i++)
        {
            PropertyListEntry ple1 = propertyList.get(i);
            PropertyListEntry ple2 = propertyList.get(i + 1);
            ple1.length = ple2.offset - ple1.offset;
        }
        if (propertyCount > 0)
        {
            ple = propertyList.get(propertyCount - 1);
            ple.length = size - ple.offset;
        }

        
        int codepage = -1;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator();
             codepage == -1 && i.hasNext();)
        {
            ple = i.next();

            
            if (ple.id == PropertyIDMap.PID_CODEPAGE)
            {
                
                int o = (int) (this.offset + ple.offset);
                final long type = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                if (type != Variant.VT_I2)
                    throw new HPSFRuntimeException
                        ("Value type of property ID 1 is not VT_I2 but " +
                         type + ".");

                
                codepage = LittleEndian.getUShort(src, o);
            }
        }

        
        int i1 = 0;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator(); i.hasNext();)
        {
            ple = i.next();
            Property p = new Property(ple.id, src,
                    this.offset + ple.offset,
                    ple.length, codepage);
            if (p.getID() == PropertyIDMap.PID_CODEPAGE)
                p = new Property(p.getID(), p.getType(), Integer.valueOf(codepage));
            properties[i1++] = p;
        }

        
        dictionary = (Map) getProperty(0);
    }



    
    static class PropertyListEntry implements Comparable<PropertyListEntry>
    {
        int id;
        int offset;
        int length;

        
        public int compareTo(final PropertyListEntry o)
        {
            final int otherOffset = o.offset;
            if (offset < otherOffset)
                return -1;
            else if (offset == otherOffset)
                return 0;
            else
                return 1;
        }

        public String toString()
        {
            final StringBuffer b = new StringBuffer();
            b.append(getClass().getName());
            b.append("[id=");
            b.append(id);
            b.append(", offset=");
            b.append(offset);
            b.append(", length=");
            b.append(length);
            b.append(']');
            return b.toString();
        }
    }



    
    public Object getProperty(final long id)
    {
        wasNull = false;
        for (int i = 0; i < properties.length; i++)
            if (id == properties[i].getID())
                return properties[i].getValue();
        wasNull = true;
        return null;
    }



    
    protected int getPropertyIntValue(final long id)
    {
        final Number i;
        final Object o = getProperty(id);
        if (o == null)
            return 0;
        if (!(o instanceof Long || o instanceof Integer))
            throw new HPSFRuntimeException
                ("This property is not an integer type, but " +
                 o.getClass().getName() + ".");
        i = (Number) o;
        return i.intValue();
    }



    
    protected boolean getPropertyBooleanValue(final int id)
    {
        final Boolean b = (Boolean) getProperty(id);
        if (b == null) {
            return false;
        }
        return b.booleanValue();
        }



    
    private boolean wasNull;


    
    public boolean wasNull()
    {
        return wasNull;
    }



    
    public String getPIDString(final long pid)
    {
        String s = null;
        if (dictionary != null)
            s = dictionary.get(Long.valueOf(pid));
        if (s == null)
            s = SectionIDMap.getPIDString(getFormatID().getBytes(), pid);
        if (s == null)
            s = SectionIDMap.UNDEFINED;
        return s;
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof Section))
            return false;
        final Section s = (Section) o;
        if (!s.getFormatID().equals(getFormatID()))
            return false;

        
        Property[] pa1 = new Property[getProperties().length];
        Property[] pa2 = new Property[s.getProperties().length];
        System.arraycopy(getProperties(), 0, pa1, 0, pa1.length);
        System.arraycopy(s.getProperties(), 0, pa2, 0, pa2.length);

        
        Property p10 = null;
        Property p20 = null;
        for (int i = 0; i < pa1.length; i++)
        {
            final long id = pa1[i].getID();
            if (id == 0)
            {
                p10 = pa1[i];
                pa1 = remove(pa1, i);
                i--;
            }
            if (id == 1)
            {
                
                pa1 = remove(pa1, i);
                i--;
            }
        }
        for (int i = 0; i < pa2.length; i++)
        {
            final long id = pa2[i].getID();
            if (id == 0)
            {
                p20 = pa2[i];
                pa2 = remove(pa2, i);
                i--;
            }
            if (id == 1)
            {
                
                pa2 = remove(pa2, i);
                i--;
            }
        }

        
        if (pa1.length != pa2.length)
            return false;

        
        boolean dictionaryEqual = true;
        if (p10 != null && p20 != null)
            dictionaryEqual = p10.getValue().equals(p20.getValue());
        else if (p10 != null || p20 != null)
            dictionaryEqual = false;
        if (dictionaryEqual) {
            return Util.equals(pa1, pa2);
        }
        return false;
    }



    
    private Property[] remove(final Property[] pa, final int i)
    {
        final Property[] h = new Property[pa.length - 1];
        if (i > 0)
            System.arraycopy(pa, 0, h, 0, i);
        System.arraycopy(pa, i + 1, h, i, h.length - i);
        return h;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += getFormatID().hashCode();
        final Property[] pa = getProperties();
        for (int i = 0; i < pa.length; i++)
            hashCode += pa[i].hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL);
        return returnHashCode;
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final Property[] pa = getProperties();
        b.append(getClass().getName());
        b.append('[');
        b.append("formatID: ");
        b.append(getFormatID());
        b.append(", offset: ");
        b.append(getOffset());
        b.append(", propertyCount: ");
        b.append(getPropertyCount());
        b.append(", size: ");
        b.append(getSize());
        b.append(", properties: [\n");
        for (int i = 0; i < pa.length; i++)
        {
            b.append(pa[i].toString());
            b.append(",\n");
        }
        b.append(']');
        b.append(']');
        return b.toString();
    }



    
    public Map<Long,String> getDictionary()
    {
        return dictionary;
    }



    
    public int getCodepage()
    {
        final Integer codepage =
            (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
        if (codepage == null)
            return -1;
        int cp = codepage.intValue();
        return cp;
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class UnexpectedPropertySetTypeException extends HPSFException
{

    
    public UnexpectedPropertySetTypeException()
    {
        super();
    }


    
    public UnexpectedPropertySetTypeException(final String msg)
    {
        super(msg);
    }


    
    public UnexpectedPropertySetTypeException(final Throwable reason)
    {
        super(reason);
    }


    
    public UnexpectedPropertySetTypeException(final String msg,
                                              final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

import org.docx4j.org.apache.poi.util.CodePageUtil;
import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class CodePageString
{


	private static Logger logger = LoggerFactory.getLogger(CodePageString.class);

    private byte[] _value;

    CodePageString( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        int size = LittleEndian.getInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        _value = LittleEndian.getByteArray( data, offset, size );
        if ( size != 0 && _value[size - 1] != 0 ) {
            
            
            
            logger.warn("CodePageString started at offset #" + offset
                        + " is not NULL-terminated" );



        }
    }

    CodePageString( String string, int codepage )
            throws UnsupportedEncodingException
    {
        setJavaValue( string, codepage );
    }

    String getJavaValue( int codepage ) throws UnsupportedEncodingException
    {
        String result;
        if ( codepage == -1 )
            result = new String( _value );
        else
            result = CodePageUtil.getStringFromCodePage(_value, codepage);
        final int terminator = result.indexOf( '\0' );
        if ( terminator == -1 )
        {
            logger.warn(
                    "String terminator (\\0) for CodePageString property value not found."
                            + "Continue without trimming and hope for the best." );
            return result;
        }
        if ( terminator != result.length() - 1 )
        {
            logger.warn(
                    "String terminator (\\0) for CodePageString property value occured before the end of string. "
                            + "Trimming and hope for the best." );
        }
        return result.substring( 0, terminator );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }

    void setJavaValue( String string, int codepage )
            throws UnsupportedEncodingException
    {
        String stringNT = string + "\0";
        if ( codepage == -1 )
            _value = stringNT.getBytes();
        else
            _value = CodePageUtil.getBytesInCodePage(stringNT, codepage);
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( _value.length, out );
        out.write( _value );
        return LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class NoFormatIDException extends HPSFRuntimeException
{

    
    public NoFormatIDException()
    {
        super();
    }


    
    public NoFormatIDException(final String msg)
    {
        super(msg);
    }


    
    public NoFormatIDException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoFormatIDException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;


public class CustomProperty extends MutableProperty
{

    private String name;

    
    public CustomProperty()
    {
        this.name = null;
    }

    
    public CustomProperty(final Property property)
    {
        this(property, null);
    }

    
    public CustomProperty(final Property property, final String name)
    {
        super(property);
        this.name = name;
    }

    
    public String getName()
    {
        return name;
    }

    
    public void setName(final String name)
    {
        this.name = name;
    }


    
    public boolean equalsContents(final Object o)
    {
        final CustomProperty c = (CustomProperty) o;
        final String name1 = c.getName();
        final String name2 = this.getName();
        boolean equalNames = true;
        if (name1 == null)
            equalNames = name2 == null;
        else
            equalNames = name1.equals(name2);
        return equalNames && c.getID() == this.getID()
                && c.getType() == this.getType()
                && c.getValue().equals(this.getValue());
    }

    
    @Override
    public int hashCode()
    {
        return (int) this.getID();
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof CustomProperty) ? equalsContents(o) : false;
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;



import org.docx4j.TraversalUtil;
import org.docx4j.org.apache.poi.util.Internal;
import org.docx4j.org.apache.poi.util.LittleEndian;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class TypedPropertyValue
{



	private static Logger logger = LoggerFactory.getLogger(TraversalUtil.class);

	
    private int _type;

    private Object _value;

    TypedPropertyValue()
    {
    }

    TypedPropertyValue( byte[] data, int startOffset )
    {
        read( data, startOffset );
    }

    TypedPropertyValue( int type, Object value )
    {
        _type = type;
        _value = value;
    }

    Object getValue()
    {
        return _value;
    }

    int read( byte[] data, int startOffset )
    {
        int offset = startOffset;

        _type = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;

        short padding = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;
        if ( padding != 0 )
        {
            logger.warn(  "TypedPropertyValue padding at offset "
                    + offset + " MUST be 0, but it's value is " + padding );
        }

        offset += readValue( data, offset );

        return offset - startOffset;
    }

    int readValue( byte[] data, int offset )
    {
        switch ( _type )
        {
        case Variant.VT_EMPTY:
        case Variant.VT_NULL:
            _value = null;
            return 0;

        case Variant.VT_I2:
            _value = Short.valueOf( LittleEndian.getShort( data, offset ) );
            return 4;

        case Variant.VT_I4:
            _value = Integer.valueOf( LittleEndian.getInt( data, offset ) );
            return 4;

        case Variant.VT_R4:
            _value = Short.valueOf( LittleEndian.getShort( data, offset ) );
            return 4;

        case Variant.VT_R8:
            _value = Double.valueOf( LittleEndian.getDouble( data, offset ) );
            return 8;

        case Variant.VT_CY:
            _value = new Currency( data, offset );
            return Currency.SIZE;

        case Variant.VT_DATE:
            _value = new Date( data, offset );
            return Date.SIZE;

        case Variant.VT_BSTR:
            _value = new CodePageString( data, offset );
            return ( (CodePageString) _value ).getSize();

        case Variant.VT_ERROR:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_BOOL:
            _value = new VariantBool( data, offset );
            return VariantBool.SIZE;

        case Variant.VT_DECIMAL:
            _value = new Decimal( data, offset );
            return Decimal.SIZE;

        case Variant.VT_I1:
            _value = Byte.valueOf( data[offset] );
            return 1;

        case Variant.VT_UI1:
            _value = Short.valueOf( LittleEndian.getUByte( data, offset ) );
            return 2;

        case Variant.VT_UI2:
            _value = Integer.valueOf( LittleEndian.getUShort( data, offset ) );
            return 4;

        case Variant.VT_UI4:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_I8:
            _value = Long.valueOf( LittleEndian.getLong( data, offset ) );
            return 8;

        case Variant.VT_UI8:
            _value = LittleEndian.getByteArray( data, offset, 8 );
            return 8;

        case Variant.VT_INT:
            _value = Integer.valueOf( LittleEndian.getInt( data, offset ) );
            return 4;

        case Variant.VT_UINT:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_LPSTR:
            _value = new CodePageString( data, offset );
            return ( (CodePageString) _value ).getSize();

        case Variant.VT_LPWSTR:
            _value = new UnicodeString( data, offset );
            return ( (UnicodeString) _value ).getSize();

        case Variant.VT_FILETIME:
            _value = new Filetime( data, offset );
            return Filetime.SIZE;

        case Variant.VT_BLOB:
            _value = new Blob( data, offset );
            return ( (Blob) _value ).getSize();

        case Variant.VT_STREAM:
        case Variant.VT_STORAGE:
        case Variant.VT_STREAMED_OBJECT:
        case Variant.VT_STORED_OBJECT:
            _value = new IndirectPropertyName( data, offset );
            return ( (IndirectPropertyName) _value ).getSize();

        case Variant.VT_BLOB_OBJECT:
            _value = new Blob( data, offset );
            return ( (Blob) _value ).getSize();

        case Variant.VT_CF:
            _value = new ClipboardData( data, offset );
            return ( (ClipboardData) _value ).getSize();

        case Variant.VT_CLSID:
            _value = new GUID( data, offset );
            return GUID.SIZE;

        case Variant.VT_VERSIONED_STREAM:
            _value = new VersionedStream( data, offset );
            return ( (VersionedStream) _value ).getSize();

        case Variant.VT_VECTOR | Variant.VT_I2:
        case Variant.VT_VECTOR | Variant.VT_I4:
        case Variant.VT_VECTOR | Variant.VT_R4:
        case Variant.VT_VECTOR | Variant.VT_R8:
        case Variant.VT_VECTOR | Variant.VT_CY:
        case Variant.VT_VECTOR | Variant.VT_DATE:
        case Variant.VT_VECTOR | Variant.VT_BSTR:
        case Variant.VT_VECTOR | Variant.VT_ERROR:
        case Variant.VT_VECTOR | Variant.VT_BOOL:
        case Variant.VT_VECTOR | Variant.VT_VARIANT:
        case Variant.VT_VECTOR | Variant.VT_I1:
        case Variant.VT_VECTOR | Variant.VT_UI1:
        case Variant.VT_VECTOR | Variant.VT_UI2:
        case Variant.VT_VECTOR | Variant.VT_UI4:
        case Variant.VT_VECTOR | Variant.VT_I8:
        case Variant.VT_VECTOR | Variant.VT_UI8:
        case Variant.VT_VECTOR | Variant.VT_LPSTR:
        case Variant.VT_VECTOR | Variant.VT_LPWSTR:
        case Variant.VT_VECTOR | Variant.VT_FILETIME:
        case Variant.VT_VECTOR | Variant.VT_CF:
        case Variant.VT_VECTOR | Variant.VT_CLSID:
            _value = new Vector( (short) ( _type & 0x0FFF ) );
            return ( (Vector) _value ).read( data, offset );

        case Variant.VT_ARRAY | Variant.VT_I2:
        case Variant.VT_ARRAY | Variant.VT_I4:
        case Variant.VT_ARRAY | Variant.VT_R4:
        case Variant.VT_ARRAY | Variant.VT_R8:
        case Variant.VT_ARRAY | Variant.VT_CY:
        case Variant.VT_ARRAY | Variant.VT_DATE:
        case Variant.VT_ARRAY | Variant.VT_BSTR:
        case Variant.VT_ARRAY | Variant.VT_ERROR:
        case Variant.VT_ARRAY | Variant.VT_BOOL:
        case Variant.VT_ARRAY | Variant.VT_VARIANT:
        case Variant.VT_ARRAY | Variant.VT_DECIMAL:
        case Variant.VT_ARRAY | Variant.VT_I1:
        case Variant.VT_ARRAY | Variant.VT_UI1:
        case Variant.VT_ARRAY | Variant.VT_UI2:
        case Variant.VT_ARRAY | Variant.VT_UI4:
        case Variant.VT_ARRAY | Variant.VT_INT:
        case Variant.VT_ARRAY | Variant.VT_UINT:
            _value = new Array();
            return ( (Array) _value ).read( data, offset );

        default:
            throw new UnsupportedOperationException(
                    "Unknown (possibly, incorrect) TypedPropertyValue type: "
                            + _type );
        }
    }

    int readValuePadded( byte[] data, int offset )
    {
        int nonPadded = readValue( data, offset );
        return ( nonPadded & 0x03 ) == 0 ? nonPadded : nonPadded
                + ( 4 - ( nonPadded & 0x03 ) );
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.LinkedHashMap;
import java.util.Map;

import org.docx4j.org.apache.poi.util.CodePageUtil;
import org.docx4j.org.apache.poi.util.HexDump;
import org.docx4j.org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Property
{
	
	private static Logger logger = LoggerFactory.getLogger(Property.class);
	

    
    protected long id;


    
    public long getID()
    {
        return id;
    }



    
    protected long type;


    
    public long getType()
    {
        return type;
    }



    
    protected Object value;


    
    public Object getValue()
    {
        return value;
    }



    
    public Property(final long id, final long type, final Object value)
    {
        this.id = id;
        this.type = type;
        this.value = value;
    }



    
    public Property(final long id, final byte[] src, final long offset,
                    final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        this.id = id;

        
        if (id == 0)
        {
            value = readDictionary(src, offset, length, codepage);
            return;
        }

        int o = (int) offset;
        type = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        try
        {
            value = VariantSupport.read(src, o, length, (int) type, codepage);
        }
        catch (UnsupportedVariantTypeException ex)
        {
            VariantSupport.writeUnsupportedTypeMessage(ex);
            value = ex.getValue();
        }
    }



    
    protected Property()
    { }



    
    protected Map<?, ?> readDictionary(final byte[] src, final long offset,
                                 final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        
        if (offset < 0 || offset > src.length)
            throw new HPSFRuntimeException
                ("Illegal offset " + offset + " while HPSF stream contains " +
                 length + " bytes.");
        int o = (int) offset;

        
        final long nrEntries = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        final Map<Object, Object> m = new LinkedHashMap<Object, Object>(
                (int) nrEntries, (float) 1.0 );

        try
        {
            for (int i = 0; i < nrEntries; i++)
            {
                
                final Long id = Long.valueOf(LittleEndian.getUInt(src, o));
                o += LittleEndian.INT_SIZE;

                
                long sLength = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                
                final StringBuffer b = new StringBuffer();
                switch (codepage)
                {
                    case -1:
                    {
                        
                        b.append(new String(src, o, (int) sLength));
                        break;
                    }
                    case CodePageUtil.CP_UNICODE:
                    {
                        
                        final int nrBytes = (int) (sLength * 2);
                        final byte[] h = new byte[nrBytes];
                        for (int i2 = 0; i2 < nrBytes; i2 += 2)
                        {
                            h[i2] = src[o + i2 + 1];
                            h[i2 + 1] = src[o + i2];
                        }
                        b.append(new String(h, 0, nrBytes,
                                CodePageUtil.codepageToEncoding(codepage)));
                        break;
                    }
                    default:
                    {
                        
                        b.append(new String(src, o, (int) sLength,
                                 VariantSupport.codepageToEncoding(codepage)));
                        break;
                    }
                }

                
                while (b.length() > 0 && b.charAt(b.length() - 1) == 0x00)
                    b.setLength(b.length() - 1);
                if (codepage == CodePageUtil.CP_UNICODE)
                {
                    if (sLength % 2 == 1)
                        sLength++;
                    o += (sLength + sLength);
                }
                else
                    o += sLength;
                m.put(id, b.toString());
            }
        }
        catch (RuntimeException ex)
        {
            logger.warn(
                    "The property set's dictionary contains bogus data. "
                    + "All dictionary entries starting with the one with ID "
                    + id + " will be ignored.", ex);
        }
        return m;
    }



    
    protected int getSize() throws WritingNotSupportedException
    {
        int length = VariantSupport.getVariantLength(type);
        if (length >= 0)
            return length; 
        if (length == -2)
            
            throw new WritingNotSupportedException(type, null);

        
        final int PADDING = 4; 
        switch ((int) type)
        {
            case Variant.VT_LPSTR:
            {
                int l = ((String) value).length() + 1;
                int r = l % PADDING;
                if (r > 0)
                    l += PADDING - r;
                length += l;
                break;
            }
            case Variant.VT_EMPTY:
                break;
            default:
                throw new WritingNotSupportedException(type, value);
        }
        return length;
    }



    
    public boolean equals(final Object o)
    {
        if (!(o instanceof Property)) {
            return false;
        }
        final Property p = (Property) o;
        final Object pValue = p.getValue();
        final long pId = p.getID();
        if (id != pId || (id != 0 && !typesAreEqual(type, p.getType())))
            return false;
        if (value == null && pValue == null)
            return true;
        if (value == null || pValue == null)
            return false;

        
        final Class<?> valueClass = value.getClass();
        final Class<?> pValueClass = pValue.getClass();
        if (!(valueClass.isAssignableFrom(pValueClass)) &&
            !(pValueClass.isAssignableFrom(valueClass)))
            return false;

        if (value instanceof byte[])
            return Util.equal((byte[]) value, (byte[]) pValue);

        return value.equals(pValue);
    }



    private boolean typesAreEqual(final long t1, final long t2)
    {
        if (t1 == t2 ||
            (t1 == Variant.VT_LPSTR && t2 == Variant.VT_LPWSTR) ||
            (t2 == Variant.VT_LPSTR && t1 == Variant.VT_LPWSTR)) {
            return true;
        }
        return false;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += id;
        hashCode += type;
        if (value != null)
            hashCode += value.hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL );
        return returnHashCode;

    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        b.append(getClass().getName());
        b.append('[');
        b.append("id: ");
        b.append(getID());
        b.append(", type: ");
        b.append(getType());
        final Object value = getValue();
        b.append(", value: ");
        if (value instanceof String)
        {
            b.append(value.toString());
            final String s = (String) value;
            final int l = s.length();
            final byte[] bytes = new byte[l * 2];
            for (int i = 0; i < l; i++)
            {
                final char c = s.charAt(i);
                final byte high = (byte) ((c & 0x00ff00) >> 8);
                final byte low  = (byte) ((c & 0x0000ff) >> 0);
                bytes[i * 2]     = high;
                bytes[i * 2 + 1] = low;
            }
            b.append(" [");
            if(bytes.length > 0) {
                final String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
            b.append("]");
        }
        else if (value instanceof byte[])
        {
            byte[] bytes = (byte[])value;
            if(bytes.length > 0) {
                String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
        }
        else
        {
            b.append(value.toString());
        }
        b.append(']');
        return b.toString();
    }

}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.docx4j.org.apache.poi.hpsf.wellknown.PropertyIDMap;


@SuppressWarnings("serial")
public class CustomProperties extends HashMap<Object,CustomProperty>
{

    
    private Map<Long,String> dictionaryIDToName = new HashMap<Long,String>();

    
    private Map<String,Long> dictionaryNameToID = new HashMap<String,Long>();

    
    private boolean isPure = true;


    
    public CustomProperty put(final String name, final CustomProperty cp)
    {
        if (name == null)
        {
            
            isPure = false;
            return null;
        }
        if (!(name.equals(cp.getName())))
            throw new IllegalArgumentException("Parameter \"name\" (" + name +
                    ") and custom property's name (" + cp.getName() +
                    ") do not match.");

        
        final Long idKey = Long.valueOf(cp.getID());
        final Long oldID = dictionaryNameToID.get(name);
        dictionaryIDToName.remove(oldID);
        dictionaryNameToID.put(name, idKey);
        dictionaryIDToName.put(idKey, name);

        
        final CustomProperty oldCp = super.remove(oldID);
        super.put(idKey, cp);
        return oldCp;
    }



    
    private Object put(final CustomProperty customProperty) throws ClassCastException
    {
        final String name = customProperty.getName();

        
        final Long oldId = dictionaryNameToID.get(name);
        if (oldId != null)
            customProperty.setID(oldId.longValue());
        else
        {
            long max = 1;
            for (final Iterator<Long> i = dictionaryIDToName.keySet().iterator(); i.hasNext();)
            {
                final long id = i.next().longValue();
                if (id > max)
                    max = id;
            }
            customProperty.setID(max + 1);
        }
        return this.put(name, customProperty);
    }



    
    public Object remove(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        if (id == null)
            return null;
        dictionaryIDToName.remove(id);
        dictionaryNameToID.remove(name);
        return super.remove(id);
    }

    
    public Object put(final String name, final String value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_LPWSTR);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Long value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Double value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_R8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Integer value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I4);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Boolean value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_BOOL);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }


    
    public Object get(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        final CustomProperty cp = super.get(id);
        return cp != null ? cp.getValue() : null;
    }



    
    public Object put(final String name, final Date value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_FILETIME);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Set keySet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> nameSet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> idSet() {
        return dictionaryNameToID.keySet();
    }


    
    public void setCodepage(final int codepage)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(PropertyIDMap.PID_CODEPAGE);
        p.setType(Variant.VT_I2);
        p.setValue(Integer.valueOf(codepage));
        put(new CustomProperty(p));
    }



    
    Map<Long,String> getDictionary()
    {
        return dictionaryIDToName;
    }


    
   public boolean containsKey(Object key) {
      if(key instanceof Long) {
         return super.containsKey(key);
      }
      if(key instanceof String) {
         return super.containsKey(dictionaryNameToID.get(key));
      }
      return false;
   }

   
   public boolean containsValue(Object value) {
      if(value instanceof CustomProperty) {
         return super.containsValue(value);
      } else {
         for(CustomProperty cp : super.values()) {
            if(cp.getValue() == value) {
               return true;
            }
         }
      }
      return false;
   }



   
    public int getCodepage()
    {
        int codepage = -1;
        for (final Iterator<CustomProperty> i = this.values().iterator(); codepage == -1 && i.hasNext();)
        {
            final CustomProperty cp = i.next();
            if (cp.getID() == PropertyIDMap.PID_CODEPAGE)
                codepage = ((Integer) cp.getValue()).intValue();
        }
        return codepage;
    }



    
    public boolean isPure()
    {
        return isPure;
    }

    
    public void setPure(final boolean isPure)
    {
        this.isPure = isPure;
    }
}

<code block>

package org.docx4j.org.apache.poi.hpsf;

import org.docx4j.org.apache.poi.util.Internal;

@Internal
class IndirectPropertyName
{
    private CodePageString _value;

    IndirectPropertyName( byte[] data, int offset )
    {
        _value = new CodePageString( data, offset );
    }

    int getSize()
    {
        return _value.getSize();
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;

import org.docx4j.org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.docx4j.org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentEntry;
import org.docx4j.org.apache.poi.poifs.filesystem.DocumentInputStream;


public class PropertySetFactory
{
    
    public static PropertySet create(final DirectoryEntry dir, final String name)
        throws FileNotFoundException, NoPropertySetStreamException,
               IOException, UnsupportedEncodingException
    {
        InputStream inp = null;
        try {
            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);
            inp = new DocumentInputStream(entry);
            try {
                return create(inp);
            } catch (MarkUnsupportedException e) { return null; }
        } finally {
            if (inp != null) inp.close();
        }
    }

    
    public static PropertySet create(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               UnsupportedEncodingException, IOException
    {
        final PropertySet ps = new PropertySet(stream);
        try
        {
            if (ps.isSummaryInformation())
                return new SummaryInformation(ps);
            else if (ps.isDocumentSummaryInformation())
                return new DocumentSummaryInformation(ps);
            else
                return ps;
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new IllegalStateException(ex);
        }
    }

    
    public static SummaryInformation newSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.SUMMARY_INFORMATION_ID);
        try
        {
            return new SummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }

    
    public static DocumentSummaryInformation newDocumentSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
        try
        {
            return new DocumentSummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }
}
<code block>


package org.docx4j.org.apache.poi.hpsf.wellknown;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class PropertyIDMap extends HashMap<Long,String> {

    

    
    public static final int PID_TITLE = 2;

    
    public static final int PID_SUBJECT = 3;

    
    public static final int PID_AUTHOR = 4;

    
    public static final int PID_KEYWORDS = 5;

    
    public static final int PID_COMMENTS = 6;

    
    public static final int PID_TEMPLATE = 7;

    
    public static final int PID_LASTAUTHOR = 8;

    
    public static final int PID_REVNUMBER = 9;

    
    public static final int PID_EDITTIME = 10;

    
    public static final int PID_LASTPRINTED = 11;

    
    public static final int PID_CREATE_DTM = 12;

    
    public static final int PID_LASTSAVE_DTM = 13;

    
    public static final int PID_PAGECOUNT = 14;

    
    public static final int PID_WORDCOUNT = 15;

    
    public static final int PID_CHARCOUNT = 16;

    
    public static final int PID_THUMBNAIL = 17;

    
    public static final int PID_APPNAME = 18;

    
    public static final int PID_SECURITY = 19;



    

    
    public static final int PID_DICTIONARY = 0;

    
    public static final int PID_CODEPAGE = 1;

    
    public static final int PID_CATEGORY = 2;

    
    public static final int PID_PRESFORMAT = 3;

    
    public static final int PID_BYTECOUNT = 4;

    
    public static final int PID_LINECOUNT = 5;

    
    public static final int PID_PARCOUNT = 6;

    
    public static final int PID_SLIDECOUNT = 7;

    
    public static final int PID_NOTECOUNT = 8;

    
    public static final int PID_HIDDENCOUNT = 9;

    
    public static final int PID_MMCLIPCOUNT = 10;

    
    public static final int PID_SCALE = 11;

    
    public static final int PID_HEADINGPAIR = 12;

    
    public static final int PID_DOCPARTS = 13;

    
    public static final int PID_MANAGER = 14;

    
    public static final int PID_COMPANY = 15;

    
    public static final int PID_LINKSDIRTY = 16;

    
    public static final int PID_MAX = PID_LINKSDIRTY;



    
    private static PropertyIDMap summaryInformationProperties;

    
    private static PropertyIDMap documentSummaryInformationProperties;



    
    public PropertyIDMap(final int initialCapacity, final float loadFactor)
    {
        super(initialCapacity, loadFactor);
    }



    
    public PropertyIDMap(final Map<Long,String> map)
    {
        super(map);
    }



    
    public Object put(final long id, final String idString)
    {
        return put(Long.valueOf(id), idString);
    }



    
    public Object get(final long id)
    {
        return get(Long.valueOf(id));
    }



    
    public static PropertyIDMap getSummaryInformationProperties()
    {
        if (summaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);
            m.put(PID_TITLE, "PID_TITLE");
            m.put(PID_SUBJECT, "PID_SUBJECT");
            m.put(PID_AUTHOR, "PID_AUTHOR");
            m.put(PID_KEYWORDS, "PID_KEYWORDS");
            m.put(PID_COMMENTS, "PID_COMMENTS");
            m.put(PID_TEMPLATE, "PID_TEMPLATE");
            m.put(PID_LASTAUTHOR, "PID_LASTAUTHOR");
            m.put(PID_REVNUMBER, "PID_REVNUMBER");
            m.put(PID_EDITTIME, "PID_EDITTIME");
            m.put(PID_LASTPRINTED, "PID_LASTPRINTED");
            m.put(PID_CREATE_DTM, "PID_CREATE_DTM");
            m.put(PID_LASTSAVE_DTM, "PID_LASTSAVE_DTM");
            m.put(PID_PAGECOUNT, "PID_PAGECOUNT");
            m.put(PID_WORDCOUNT, "PID_WORDCOUNT");
            m.put(PID_CHARCOUNT, "PID_CHARCOUNT");
            m.put(PID_THUMBNAIL, "PID_THUMBNAIL");
            m.put(PID_APPNAME, "PID_APPNAME");
            m.put(PID_SECURITY, "PID_SECURITY");
            summaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return summaryInformationProperties;
    }



    
    public static PropertyIDMap getDocumentSummaryInformationProperties()
    {
        if (documentSummaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);
            m.put(PID_DICTIONARY, "PID_DICTIONARY");
            m.put(PID_CODEPAGE, "PID_CODEPAGE");
            m.put(PID_CATEGORY, "PID_CATEGORY");
            m.put(PID_PRESFORMAT, "PID_PRESFORMAT");
            m.put(PID_BYTECOUNT, "PID_BYTECOUNT");
            m.put(PID_LINECOUNT, "PID_LINECOUNT");
            m.put(PID_PARCOUNT, "PID_PARCOUNT");
            m.put(PID_SLIDECOUNT, "PID_SLIDECOUNT");
            m.put(PID_NOTECOUNT, "PID_NOTECOUNT");
            m.put(PID_HIDDENCOUNT, "PID_HIDDENCOUNT");
            m.put(PID_MMCLIPCOUNT, "PID_MMCLIPCOUNT");
            m.put(PID_SCALE, "PID_SCALE");
            m.put(PID_HEADINGPAIR, "PID_HEADINGPAIR");
            m.put(PID_DOCPARTS, "PID_DOCPARTS");
            m.put(PID_MANAGER, "PID_MANAGER");
            m.put(PID_COMPANY, "PID_COMPANY");
            m.put(PID_LINKSDIRTY, "PID_LINKSDIRTY");
            documentSummaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return documentSummaryInformationProperties;
    }



    
    public static void main(final String[] args)
    {
        PropertyIDMap s1 = getSummaryInformationProperties();
        PropertyIDMap s2 = getDocumentSummaryInformationProperties();
        System.out.println("s1: " + s1);
        System.out.println("s2: " + s2);
    }
}

<code block>


package org.docx4j.org.apache.poi.hpsf.wellknown;

import java.util.HashMap;


public class SectionIDMap extends HashMap {

    
    public static final byte[] SUMMARY_INFORMATION_ID = new byte[]
    {
        (byte) 0xF2, (byte) 0x9F, (byte) 0x85, (byte) 0xE0,
        (byte) 0x4F, (byte) 0xF9, (byte) 0x10, (byte) 0x68,
        (byte) 0xAB, (byte) 0x91, (byte) 0x08, (byte) 0x00,
        (byte) 0x2B, (byte) 0x27, (byte) 0xB3, (byte) 0xD9
    };

    
    public static final byte[][] DOCUMENT_SUMMARY_INFORMATION_ID = new byte[][]
    {
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x02,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        },
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x05,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        }
    };

    
    public static final String UNDEFINED = "[undefined]";

    
    private static SectionIDMap defaultMap;



    
    public static SectionIDMap getInstance()
    {
        if (defaultMap == null)
        {
            final SectionIDMap m = new SectionIDMap();
            m.put(SUMMARY_INFORMATION_ID,
                  PropertyIDMap.getSummaryInformationProperties());
            m.put(DOCUMENT_SUMMARY_INFORMATION_ID[0],
                  PropertyIDMap.getDocumentSummaryInformationProperties());
            defaultMap = m;
        }
        return defaultMap;
    }



    
    public static String getPIDString(final byte[] sectionFormatID,
                                      final long pid)
    {
        final PropertyIDMap m = getInstance().get(sectionFormatID);
        if (m == null) {
            return UNDEFINED;
        }
        final String s = (String) m.get(pid);
        if (s == null)
            return UNDEFINED;
        return s;
    }



    
    public PropertyIDMap get(final byte[] sectionFormatID)
    {
        return (PropertyIDMap) super.get(new String(sectionFormatID));
    }



    
    public Object get(final Object sectionFormatID)
    {
        return get((byte[]) sectionFormatID);
    }



    
    public Object put(final byte[] sectionFormatID,
                      final PropertyIDMap propertyIDMap)
    {
        return super.put(new String(sectionFormatID), propertyIDMap);
    }



    
    public Object put(final Object key, final Object value)
    {
        return put((byte[]) key, (PropertyIDMap) value);
    }

}

<code block>
package org.apache.poi;




public class EmptyFileException extends IllegalArgumentException {
    private static final long serialVersionUID = 1536449292174360166L;

    public EmptyFileException() {
		super("The supplied file was empty (zero bytes long)");
	}
}
<code block>

package org.apache.poi;


public abstract class UnsupportedFileFormatException extends IllegalArgumentException {
    private static final long serialVersionUID = -8281969197282030046L;

    public UnsupportedFileFormatException(String s) {
		super(s);
	}
}
<code block>

package org.apache.poi;


public abstract class OldFileFormatException extends UnsupportedFileFormatException {
    private static final long serialVersionUID = 7849681804154571175L;

    public OldFileFormatException(String s) {
		super(s);
	}
}
<code block>

package org.apache.poi;

public class EncryptedDocumentException extends IllegalStateException
{
    private static final long serialVersionUID = 7276950444540469193L;
    
	public EncryptedDocumentException(String s) {
		super(s);
	}

    public EncryptedDocumentException(String message, Throwable cause) {
        super(message, cause);
    }

    public EncryptedDocumentException(Throwable cause) {
        super(cause);
    }
}

<code block>


        

package org.apache.poi.poifs.common;


public interface POIFSConstants
{
    
    public static final int SMALLER_BIG_BLOCK_SIZE = 0x0200;
    public static final POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(SMALLER_BIG_BLOCK_SIZE, (short)9);
    
    public static final int LARGER_BIG_BLOCK_SIZE = 0x1000;
    public static final POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS = 
       new POIFSBigBlockSize(LARGER_BIG_BLOCK_SIZE, (short)12);
    
    
    public static final int SMALL_BLOCK_SIZE = 0x0040; 
    
    
    public static final int PROPERTY_SIZE  = 0x0080;
    
    
    public static final int BIG_BLOCK_MINIMUM_DOCUMENT_SIZE = 0x1000;
    
    
    public static final int LARGEST_REGULAR_SECTOR_NUMBER = -5;
    
    
    public static final int DIFAT_SECTOR_BLOCK   = -4;
    
    public static final int FAT_SECTOR_BLOCK   = -3;
    
    public static final int END_OF_CHAIN   = -2;
    
    public static final int UNUSED_BLOCK   = -1;
    
    
    public static final byte[] OOXML_FILE_HEADER = 
    	new byte[] { 0x50, 0x4b, 0x03, 0x04 };
}   

<code block>


        

package org.apache.poi.poifs.common;

import org.apache.poi.util.LittleEndianConsts;


public final class POIFSBigBlockSize
{
   private int bigBlockSize;
   private short headerValue;
   
   protected POIFSBigBlockSize(int bigBlockSize, short headerValue) {
      this.bigBlockSize = bigBlockSize;
      this.headerValue = headerValue;
   }
   
   public int getBigBlockSize() {
      return bigBlockSize;
   }
   
   
   public short getHeaderValue() {
      return headerValue;
   }
   
   public int getPropertiesPerBlock() {
      return bigBlockSize / POIFSConstants.PROPERTY_SIZE;
   }
   
   public int getBATEntriesPerBlock() {
      return bigBlockSize / LittleEndianConsts.INT_SIZE;
   }
   public int getXBATEntriesPerBlock() {
      return getBATEntriesPerBlock() - 1;
   }
   public int getNextXBATChainOffset() {
      return getXBATEntriesPerBlock() * LittleEndianConsts.INT_SIZE;
   }
}

<code block>


        

package org.apache.poi.poifs.eventfilesystem;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentDescriptor;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



class POIFSReaderRegistry
{

    
    private Set omnivorousListeners;

    
    
    
    
    private Map selectiveListeners;

    
    
    
    
    
    private Map chosenDocumentDescriptors;

    

    POIFSReaderRegistry()
    {
        omnivorousListeners       = new HashSet();
        selectiveListeners        = new HashMap();
        chosenDocumentDescriptors = new HashMap();
    }

    

    void registerListener(final POIFSReaderListener listener,
                          final POIFSDocumentPath path,
                          final String documentName)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            Set descriptors = ( Set ) selectiveListeners.get(listener);

            if (descriptors == null)
            {

                
                descriptors = new HashSet();
                selectiveListeners.put(listener, descriptors);
            }
            DocumentDescriptor descriptor = new DocumentDescriptor(path,
                                                documentName);

            if (descriptors.add(descriptor))
            {

                
                
                
                Set listeners =
                    ( Set ) chosenDocumentDescriptors.get(descriptor);

                if (listeners == null)
                {

                    
                    listeners = new HashSet();
                    chosenDocumentDescriptors.put(descriptor, listeners);
                }
                listeners.add(listener);
            }
        }
    }

    

    void registerListener(final POIFSReaderListener listener)
    {
        if (!omnivorousListeners.contains(listener))
        {

            
            
            
            
            removeSelectiveListener(listener);
            omnivorousListeners.add(listener);
        }
    }

    

    Iterator getListeners(final POIFSDocumentPath path, final String name)
    {
        Set rval               = new HashSet(omnivorousListeners);
        Set selectiveListeners =
            ( Set ) chosenDocumentDescriptors.get(new DocumentDescriptor(path,
                name));

        if (selectiveListeners != null)
        {
            rval.addAll(selectiveListeners);
        }
        return rval.iterator();
    }

    private void removeSelectiveListener(final POIFSReaderListener listener)
    {
        Set selectedDescriptors = ( Set ) selectiveListeners.remove(listener);

        if (selectedDescriptors != null)
        {
            Iterator iter = selectedDescriptors.iterator();

            while (iter.hasNext())
            {
                dropDocument(listener, ( DocumentDescriptor ) iter.next());
            }
        }
    }

    private void dropDocument(final POIFSReaderListener listener,
                              final DocumentDescriptor descriptor)
    {
        Set listeners = ( Set ) chosenDocumentDescriptors.get(descriptor);

        listeners.remove(listener);
        if (listeners.size() == 0)
        {
            chosenDocumentDescriptors.remove(descriptor);
        }
    }
}   


<code block>


        

package org.apache.poi.poifs.eventfilesystem;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;



public class POIFSReader
{
    private POIFSReaderRegistry registry;
    private boolean             registryClosed;

    

    public POIFSReader()
    {
        registry       = new POIFSReaderRegistry();
        registryClosed = false;
    }

    

    public void read(final InputStream stream)
        throws IOException
    {
        registryClosed = true;

        
        HeaderBlock header_block = new HeaderBlock(stream);

        
        RawDataBlockList data_blocks = new RawDataBlockList(stream, header_block.getBigBlockSize());

        
        
        new BlockAllocationTableReader(header_block.getBigBlockSize(),
                                       header_block.getBATCount(),
                                       header_block.getBATArray(),
                                       header_block.getXBATCount(),
                                       header_block.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block, data_blocks);

        
        processProperties(SmallBlockTableReader
            .getSmallDocumentBlocks(
                  header_block.getBigBlockSize(),
                  data_blocks, properties.getRoot(), 
                  header_block.getSBATStart()), 
                  data_blocks, properties.getRoot()
                        .getChildren(), new POIFSDocumentPath());
    }

    

    public void registerListener(final POIFSReaderListener listener)
    {
        if (listener == null)
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final String name)
    {
        registerListener(listener, null, name);
    }

    

    public void registerListener(final POIFSReaderListener listener,
                                 final POIFSDocumentPath path,
                                 final String name)
    {
        if ((listener == null) || (name == null) || (name.length() == 0))
        {
            throw new NullPointerException();
        }
        if (registryClosed)
        {
            throw new IllegalStateException();
        }
        registry.registerListener(listener,
                                  (path == null) ? new POIFSDocumentPath()
                                                 : path, name);
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length == 0)
        {
            System.err
                .println("at least one argument required: input filename(s)");
            System.exit(1);
        }

        
        for (int j = 0; j < args.length; j++)
        {
            POIFSReader         reader   = new POIFSReader();
            POIFSReaderListener listener = new SampleListener();

            reader.registerListener(listener);
            System.out.println("reading " + args[ j ]);
            FileInputStream istream = new FileInputStream(args[ j ]);

            reader.read(istream);
            istream.close();
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator properties,
                                   final POIFSDocumentPath path)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property property = ( Property ) properties.next();
            String   name     = property.getName();

            if (property.isDirectory())
            {
                POIFSDocumentPath new_path = new POIFSDocumentPath(path,
                                                 new String[]
                {
                    name
                });

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(), new_path);
            }
            else
            {
                int      startBlock = property.getStartBlock();
                Iterator listeners  = registry.getListeners(path, name);

                if (listeners.hasNext())
                {
                    int            size     = property.getSize();
                    OPOIFSDocument document = null;

                    if (property.shouldUseSmallBlocks())
                    {
                        document =
                            new OPOIFSDocument(name, small_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    else
                    {
                        document =
                            new OPOIFSDocument(name, big_blocks
                                .fetchBlocks(startBlock, -1), size);
                    }
                    while (listeners.hasNext())
                    {
                        POIFSReaderListener listener =
                            ( POIFSReaderListener ) listeners.next();

                        listener.processPOIFSReaderEvent(
                            new POIFSReaderEvent(
                                new DocumentInputStream(document), path,
                                name));
                    }
                }
                else
                {

                    
                    if (property.shouldUseSmallBlocks())
                    {
                        small_blocks.fetchBlocks(startBlock, -1);
                    }
                    else
                    {
                        big_blocks.fetchBlocks(startBlock, -1);
                    }
                }
            }
        }
    }

    private static class SampleListener
        implements POIFSReaderListener
    {

        

        SampleListener()
        {
        }

        

        public void processPOIFSReaderEvent(final POIFSReaderEvent event)
        {
            DocumentInputStream istream = event.getStream();
            POIFSDocumentPath   path    = event.getPath();
            String              name    = event.getName();

            try
            {
                byte[] data = new byte[ istream.available() ];

                istream.read(data);
                int pathLength = path.length();

                for (int k = 0; k < pathLength; k++)
                {
                    System.out.print("/" + path.getComponent(k));
                }
                System.out.println("/" + name + ": " + data.length
                                   + " bytes read");
            }
            catch (IOException ignored)
            {
            }
        }
    }   
}       


<code block>


        

package org.apache.poi.poifs.eventfilesystem;

import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.POIFSDocumentPath;



public class POIFSReaderEvent
{
    private DocumentInputStream stream;
    private POIFSDocumentPath   path;
    private String              documentName;

    

    POIFSReaderEvent(final DocumentInputStream stream,
                     final POIFSDocumentPath path, final String documentName)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
    }

    

    public DocumentInputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }
}   


<code block>


        

package org.apache.poi.poifs.eventfilesystem;



public interface POIFSReaderListener
{

    

    public void processPOIFSReaderEvent(POIFSReaderEvent event);
}   


<code block>


package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.NPOIFSStream;
import org.apache.poi.poifs.storage.HeaderBlock;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class NPropertyTable extends PropertyTableBase {


	private static Logger _logger = LoggerFactory.getLogger(NPropertyTable.class);
	
    private POIFSBigBlockSize _bigBigBlockSize;

    public NPropertyTable(HeaderBlock headerBlock)
    {
        super(headerBlock);
        _bigBigBlockSize = headerBlock.getBigBlockSize();
    }

    
    public NPropertyTable(final HeaderBlock headerBlock,
                          final NPOIFSFileSystem filesystem)
        throws IOException
    {
        super(
              headerBlock,
              buildProperties(
                    (new NPOIFSStream(filesystem, headerBlock.getPropertyStart())).iterator(),
                    headerBlock.getBigBlockSize()
              )
        );
        _bigBigBlockSize = headerBlock.getBigBlockSize();
    }
    
    
    private static List<Property> buildProperties(final Iterator<ByteBuffer> dataSource,
          final POIFSBigBlockSize bigBlockSize) throws IOException
    {
       List<Property> properties = new ArrayList<Property>();
       while(dataSource.hasNext()) {
          ByteBuffer bb = dataSource.next();
          
          
          byte[] data;
          if(bb.hasArray() && bb.arrayOffset() == 0 && 
                bb.array().length == bigBlockSize.getBigBlockSize()) {
             data = bb.array();
          } else {
             data = new byte[bigBlockSize.getBigBlockSize()];
             
             int toRead = data.length;
             if (bb.remaining() < bigBlockSize.getBigBlockSize()) {
                
                
                
                _logger.warn( "Short Property Block, ", bb.remaining(),
                            " bytes instead of the expected " + bigBlockSize.getBigBlockSize());
                toRead = bb.remaining();
             }
             
             bb.get(data, 0, toRead);
          }
          
          PropertyFactory.convertToProperties(data, properties);
       }
       return properties;
    }

    
    public int countBlocks()
    {
       int size = _properties.size() * POIFSConstants.PROPERTY_SIZE;
       return (int)Math.ceil(size / _bigBigBlockSize.getBigBlockSize());
    }
 
    
    public void preWrite() {
        List<Property> pList = new ArrayList<Property>();
        
        int i=0;
        for (Property p : _properties) {
            
            if (p == null) continue;
            p.setIndex(i++);
            pList.add(p);
        }

        
        for (Property p : pList) p.preWrite();
    }    
    
    
    public void write(NPOIFSStream stream) throws IOException {
       OutputStream os = stream.getOutputStream();
       for(Property property : _properties) {
          if(property != null) {
             property.writeData(os);
          }
       }
       os.close();
       
       
       if(getStartBlock() != stream.getStartBlock()) {
          setStartBlock(stream.getStartBlock());
       }
    }
}

<code block>


package org.apache.poi.poifs.property;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.SmallDocumentBlock;


public final class RootProperty extends DirectoryProperty {
   private static final String NAME = "Root Entry";

    RootProperty()
    {
        super(NAME);

        
        setNodeColor(_NODE_BLACK);
        setPropertyType(PropertyConstants.ROOT_TYPE);
        setStartBlock(POIFSConstants.END_OF_CHAIN);
    }

    
    protected RootProperty(final int index, final byte [] array,
                           final int offset)
    {
        super(index, array, offset);
    }

    
    public void setSize(int size)
    {
        super.setSize(SmallDocumentBlock.calcSize(size));
    }

    
    @Override
    public String getName() {
        return NAME;
    }
}

<code block>


        

package org.apache.poi.poifs.property;

import org.apache.poi.poifs.filesystem.OPOIFSDocument;



public class DocumentProperty
    extends Property
{

    
    private OPOIFSDocument _document;

    

    public DocumentProperty(final String name, final int size)
    {
        super();
        _document = null;
        setName(name);
        setSize(size);
        setNodeColor(_NODE_BLACK);   
        setPropertyType(PropertyConstants.DOCUMENT_TYPE);
    }

    

    protected DocumentProperty(final int index, final byte [] array,
                               final int offset)
    {
        super(index, array, offset);
        _document = null;
    }

    

    public void setDocument(OPOIFSDocument doc)
    {
        _document = doc;
    }

    

    public OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public boolean shouldUseSmallBlocks()
    {
        return super.shouldUseSmallBlocks();
    }

    

    public boolean isDirectory()
    {
        return false;
    }

    

    protected void preWrite()
    {

        
    }
    
    
    public void updateSize(int size)
    {
        setSize(size);
    }

    
}   


<code block>


package org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;


public class DirectoryProperty extends Property implements Parent, Iterable<Property> { 

    
    private List<Property> _children;

    
    private Set<String>  _children_names;

    
    public DirectoryProperty(String name)
    {
        super();
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
        setName(name);
        setSize(0);
        setPropertyType(PropertyConstants.DIRECTORY_TYPE);
        setStartBlock(0);
        setNodeColor(_NODE_BLACK);   
    }

    
    protected DirectoryProperty(final int index, final byte [] array,
                                final int offset)
    {
        super(index, array, offset);
        _children       = new ArrayList<Property>();
        _children_names = new HashSet<String>();
    }

    
    public boolean changeName(Property property, String newName)
    {
        boolean result;
        String  oldName = property.getName();

        property.setName(newName);
        String cleanNewName = property.getName();

        if (_children_names.contains(cleanNewName))
        {

            
            property.setName(oldName);
            result = false;
        }
        else
        {
            _children_names.add(cleanNewName);
            _children_names.remove(oldName);
            result = true;
        }
        return result;
    }

    
    public boolean deleteChild(Property property)
    {
        boolean result = _children.remove(property);

        if (result)
        {
            _children_names.remove(property.getName());
        }
        return result;
    }

    public static class PropertyComparator implements Comparator<Property> {

        
        public int compare(Property o1, Property o2)
        {
            String VBA_PROJECT = "_VBA_PROJECT";
            String name1  = o1.getName();
            String name2  = o2.getName();
            int  result = name1.length() - name2.length();

            if (result == 0)
            {
              
              if (name1.compareTo(VBA_PROJECT) == 0)
                result = 1;
              else if (name2.compareTo(VBA_PROJECT) == 0)
                result = -1;
              else
              {
                if (name1.startsWith("__") && name2.startsWith("__"))
                {
                  
                  result = name1.compareToIgnoreCase(name2);
                }
                else if (name1.startsWith("__"))
                {
                  
                  result = 1;
                }
                else if (name2.startsWith("__"))
                {
                  
                  result = -1;
                }
                else
                  
                  
                  result = name1.compareToIgnoreCase(name2);
              }
            }
            return result;
        }
    }

    
    public boolean isDirectory()
    {
        return true;
    }

    
    protected void preWrite()
    {
        if (_children.size() > 0)
        {
            Property[] children = _children.toArray(new Property[ 0 ]);

            Arrays.sort(children, new PropertyComparator());
            int midpoint = children.length / 2;

            setChildProperty(children[ midpoint ].getIndex());
            children[ 0 ].setPreviousChild(null);
            children[ 0 ].setNextChild(null);
            for (int j = 1; j < midpoint; j++)
            {
                children[ j ].setPreviousChild(children[ j - 1 ]);
                children[ j ].setNextChild(null);
            }
            if (midpoint != 0)
            {
                children[ midpoint ]
                    .setPreviousChild(children[ midpoint - 1 ]);
            }
            if (midpoint != (children.length - 1))
            {
                children[ midpoint ].setNextChild(children[ midpoint + 1 ]);
                for (int j = midpoint + 1; j < children.length - 1; j++)
                {
                    children[ j ].setPreviousChild(null);
                    children[ j ].setNextChild(children[ j + 1 ]);
                }
                children[ children.length - 1 ].setPreviousChild(null);
                children[ children.length - 1 ].setNextChild(null);
            }
            else
            {
                children[ midpoint ].setNextChild(null);
            }
        }
    }

    
    public Iterator<Property> getChildren()
    {
        return _children.iterator();
    }
    
    public Iterator<Property> iterator() {
        return getChildren();
    }

    
    public void addChild(final Property property)
        throws IOException
    {
        String name = property.getName();

        if (_children_names.contains(name))
        {
            throw new IOException("Duplicate name \"" + name + "\"");
        }
        _children_names.add(name);
        _children.add(property);
    }
}

<code block>


        

package org.apache.poi.poifs.property;

import java.io.IOException;

import java.util.*;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.storage.ListManagedBlock;



class PropertyFactory
{
    
    private PropertyFactory()
    {
    }

    
    static List<Property> convertToProperties(ListManagedBlock [] blocks)
        throws IOException
    {
        List<Property> properties = new ArrayList<Property>();

        for (int j = 0; j < blocks.length; j++) {
            byte[] data = blocks[ j ].getData();
            convertToProperties(data, properties);
        }
        return properties;
    }
    
    static void convertToProperties(byte[] data, List<Property> properties)
        throws IOException
    {
       int property_count = data.length / POIFSConstants.PROPERTY_SIZE;
       int offset         = 0;

       for (int k = 0; k < property_count; k++) {
          switch (data[ offset + PropertyConstants.PROPERTY_TYPE_OFFSET ]) {
          case PropertyConstants.DIRECTORY_TYPE :
             properties.add(
                   new DirectoryProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.DOCUMENT_TYPE :
             properties.add(
                   new DocumentProperty(properties.size(), data, offset)
             );
             break;

          case PropertyConstants.ROOT_TYPE :
             properties.add(
                   new RootProperty(properties.size(), data, offset)
             );
             break;

          default :
             properties.add(null);
             break;
          }
          
          offset += POIFSConstants.PROPERTY_SIZE;
       }
    }
    
}   


<code block>


        

package org.apache.poi.poifs.property;



public interface Child
{

    

    public Child getNextChild();

    

    public Child getPreviousChild();

    

    public void setNextChild(final Child child);

    

    public void setPreviousChild(final Child child);
}   


<code block>


        

package org.apache.poi.poifs.property;



public interface PropertyConstants
{
    public static final int  PROPERTY_TYPE_OFFSET = 0x42;

    
    public static final byte DIRECTORY_TYPE       = 1;
    public static final byte DOCUMENT_TYPE        = 2;
    public static final byte ROOT_TYPE            = 5;
}   


<code block>


package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.PropertyBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;


public final class PropertyTable extends PropertyTableBase implements BlockWritable {
    private POIFSBigBlockSize _bigBigBlockSize;
    private BlockWritable[]   _blocks;

    public PropertyTable(HeaderBlock headerBlock)
    {
        super(headerBlock);
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks = null;
    }

    
    public PropertyTable(final HeaderBlock headerBlock,
                         final RawDataBlockList blockList)
        throws IOException
    {
        super(
              headerBlock,
              PropertyFactory.convertToProperties(
                    blockList.fetchBlocks(headerBlock.getPropertyStart(), -1)
              )
        );
        _bigBigBlockSize = headerBlock.getBigBlockSize();
        _blocks      = null;
    }

    
    public void preWrite()
    {
        Property[] properties = _properties.toArray(new Property[_properties.size()]);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].setIndex(k);
        }

        
        _blocks = PropertyBlock.createPropertyBlockArray(_bigBigBlockSize, _properties);

        
        for (int k = 0; k < properties.length; k++)
        {
            properties[ k ].preWrite();
        }
    }
    
    
    public int countBlocks()
    {
        return (_blocks == null) ? 0
                                 : _blocks.length;
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        if (_blocks != null)
        {
            for (int j = 0; j < _blocks.length; j++)
            {
                _blocks[ j ].writeBlocks(stream);
            }
        }
    }
}

<code block>


package org.apache.poi.poifs.property;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.poifs.storage.HeaderBlock;


public abstract class PropertyTableBase implements BATManaged {
    private   final HeaderBlock    _header_block;
    protected final List<Property> _properties;

    public PropertyTableBase(final HeaderBlock header_block)
    {
        _header_block = header_block;
        _properties  = new ArrayList<Property>();
        addProperty(new RootProperty());
    }

    
    public PropertyTableBase(final HeaderBlock header_block,
                         final List<Property> properties)
        throws IOException
    {
        _header_block = header_block;
        _properties   = properties;
        populatePropertyTree( (DirectoryProperty)_properties.get(0));
    }

    
    public void addProperty(Property property)
    {
        _properties.add(property);
    }

    
    public void removeProperty(final Property property)
    {
        _properties.remove(property);
    }

    
    public RootProperty getRoot()
    {
        
        return ( RootProperty ) _properties.get(0);
    }
    
    private void populatePropertyTree(DirectoryProperty root)
        throws IOException
    {
        int index = root.getChildIndex();

        if (!Property.isValidIndex(index))
        {

            
            return;
        }
        Stack<Property> children = new Stack<Property>();

        children.push(_properties.get(index));
        while (!children.empty())
        {
            Property property = children.pop();
            if (property == null)
            {
                
                continue;
            }

            root.addChild(property);
            if (property.isDirectory())
            {
                populatePropertyTree(( DirectoryProperty ) property);
            }
            index = property.getPreviousChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
            index = property.getNextChildIndex();
            if (Property.isValidIndex(index))
            {
                children.push(_properties.get(index));
            }
        }
    }

    
    public int getStartBlock()
    {
        return _header_block.getPropertyStart();
    }

    
    public void setStartBlock(final int index)
    {
        _header_block.setPropertyStart(index);
    }
}

<code block>




package org.apache.poi.poifs.property;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;

import org.apache.poi.hpsf.ClassID;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.ByteField;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.ShortField;



public abstract class Property implements Child, POIFSViewable {
    static final private byte   _default_fill             = ( byte ) 0x00;
    static final private int    _name_size_offset         = 0x40;
    static final private int    _max_name_length          =
        (_name_size_offset / LittleEndianConsts.SHORT_SIZE) - 1;
    static final protected int  _NO_INDEX                 = -1;

    
    static final private int    _node_color_offset        = 0x43;
    static final private int    _previous_property_offset = 0x44;
    static final private int    _next_property_offset     = 0x48;
    static final private int    _child_property_offset    = 0x4C;
    static final private int    _storage_clsid_offset     = 0x50;
    static final private int    _user_flags_offset        = 0x60;
    static final private int    _seconds_1_offset         = 0x64;
    static final private int    _days_1_offset            = 0x68;
    static final private int    _seconds_2_offset         = 0x6C;
    static final private int    _days_2_offset            = 0x70;
    static final private int    _start_block_offset       = 0x74;
    static final private int    _size_offset              = 0x78;

    
    static final protected byte _NODE_BLACK               = 1;
    static final protected byte _NODE_RED                 = 0;

    
    static final private int    _big_block_minimum_bytes  = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
    private String              _name;
    private ShortField          _name_size;
    private ByteField           _property_type;
    private ByteField           _node_color;
    private IntegerField        _previous_property;
    private IntegerField        _next_property;
    private IntegerField        _child_property;
    private ClassID             _storage_clsid;
    private IntegerField        _user_flags;
    private IntegerField        _seconds_1;
    private IntegerField        _days_1;
    private IntegerField        _seconds_2;
    private IntegerField        _days_2;
    private IntegerField        _start_block;
    private IntegerField        _size;
    private byte[]              _raw_data;
    private int                 _index;
    private Child               _next_child;
    private Child               _previous_child;

    protected Property()
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        Arrays.fill(_raw_data, _default_fill);
        _name_size         = new ShortField(_name_size_offset);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET);
        _node_color        = new ByteField(_node_color_offset);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _NO_INDEX, _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _NO_INDEX, _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _NO_INDEX, _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, 0,
                                              _raw_data);
        _days_1            = new IntegerField(_days_1_offset, 0, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, 0,
                                              _raw_data);
        _days_2            = new IntegerField(_days_2_offset, 0, _raw_data);
        _start_block       = new IntegerField(_start_block_offset);
        _size              = new IntegerField(_size_offset, 0, _raw_data);
        _index             = _NO_INDEX;
        setName("");
        setNextChild(null);
        setPreviousChild(null);
    }

    
    protected Property(int index, byte [] array, int offset)
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        System.arraycopy(array, offset, _raw_data, 0,
                         POIFSConstants.PROPERTY_SIZE);
        _name_size         = new ShortField(_name_size_offset, _raw_data);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET, _raw_data);
        _node_color        = new ByteField(_node_color_offset, _raw_data);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, _raw_data);
        _days_1            = new IntegerField(_days_1_offset, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, _raw_data);
        _days_2            = new IntegerField(_days_2_offset, _raw_data);
        _start_block       = new IntegerField(_start_block_offset, _raw_data);
        _size              = new IntegerField(_size_offset, _raw_data);
        _index             = index;
        int name_length = (_name_size.get() / LittleEndianConsts.SHORT_SIZE)
                          - 1;

        if (name_length < 1)
        {
            _name = "";
        }
        else
        {
            char[] char_array  = new char[ name_length ];
            int    name_offset = 0;

            for (int j = 0; j < name_length; j++)
            {
                char_array[ j ] = ( char ) new ShortField(name_offset,
                                                          _raw_data).get();
                name_offset     += LittleEndianConsts.SHORT_SIZE;
            }
            _name = new String(char_array, 0, name_length);
        }
        _next_child     = null;
        _previous_child = null;
    }

    
    public void writeData(OutputStream stream)
        throws IOException
    {
        stream.write(_raw_data);
    }

    
    public void setStartBlock(int startBlock)
    {
        _start_block.set(startBlock, _raw_data);
    }

    
    public int getStartBlock()
    {
        return _start_block.get();
    }

    
    public int getSize()
    {
        return _size.get();
    }

    
    public boolean shouldUseSmallBlocks()
    {
        return Property.isSmall(_size.get());
    }

    
    public static boolean isSmall(int length)
    {
        return length < _big_block_minimum_bytes;
    }

    
    public String getName()
    {
        return _name;
    }

    
    abstract public boolean isDirectory();

    
    public ClassID getStorageClsid()
    {
        return _storage_clsid;
    }

    
    protected void setName(String name)
    {
        char[] char_array = name.toCharArray();
        int    limit      = Math.min(char_array.length, _max_name_length);

        _name = new String(char_array, 0, limit);
        short offset = 0;
        int   j      = 0;

        for (; j < limit; j++)
        {
            new ShortField(offset, ( short ) char_array[ j ], _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }
        for (; j < _max_name_length + 1; j++)
        {
            new ShortField(offset, ( short ) 0, _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }

        
        _name_size
            .set(( short ) ((limit + 1)
                            * LittleEndianConsts.SHORT_SIZE), _raw_data);
    }

    
    public void setStorageClsid( ClassID clsidStorage)
    {
        _storage_clsid = clsidStorage;
        if( clsidStorage == null) {
            Arrays.fill( _raw_data, _storage_clsid_offset, _storage_clsid_offset + ClassID.LENGTH, (byte) 0);
        } else {
            clsidStorage.write( _raw_data, _storage_clsid_offset);
        }
    }
    
    protected void setPropertyType(byte propertyType)
    {
        _property_type.set(propertyType, _raw_data);
    }

    
    protected void setNodeColor(byte nodeColor)
    {
        _node_color.set(nodeColor, _raw_data);
    }

    
    protected void setChildProperty(int child)
    {
        _child_property.set(child, _raw_data);
    }

    
    protected int getChildIndex()
    {
        return _child_property.get();
    }

    
    protected void setSize(int size)
    {
        _size.set(size, _raw_data);
    }

    
    protected void setIndex(int index)
    {
        _index = index;
    }

    
    protected int getIndex()
    {
        return _index;
    }

    
    abstract protected void preWrite();

    
    int getNextChildIndex()
    {
        return _next_property.get();
    }

    
    int getPreviousChildIndex()
    {
        return _previous_property.get();
    }

    
    static boolean isValidIndex(int index)
    {
        return index != _NO_INDEX;
    }

    
    public Child getNextChild()
    {
        return _next_child;
    }

    
    public Child getPreviousChild()
    {
        return _previous_child;
    }

    
    public void setNextChild(Child child)
    {
        _next_child = child;
        _next_property.set((child == null) ? _NO_INDEX
                                           : (( Property ) child)
                                               .getIndex(), _raw_data);
    }

    
    public void setPreviousChild(Child child)
    {
        _previous_child = child;
        _previous_property.set((child == null) ? _NO_INDEX
                                               : (( Property ) child)
                                                   .getIndex(), _raw_data);
    }

    
    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 5 ];

        results[ 0 ] = "Name          = \"" + getName() + "\"";
        results[ 1 ] = "Property Type = " + _property_type.get();
        results[ 2 ] = "Node Color    = " + _node_color.get();
        long time = _days_1.get();

        time         <<= 32;
        time         += _seconds_1.get() & 0x0000FFFFL;
        results[ 3 ] = "Time 1        = " + time;
        time         = _days_2.get();
        time         <<= 32;
        time         += _seconds_2.get() & 0x0000FFFFL;
        results[ 4 ] = "Time 2        = " + time;
        return results;
    }

    
    public Iterator<Object> getViewableIterator()
    {
        return Collections.emptyList().iterator();
    }

    
    public boolean preferArray()
    {
        return true;
    }

    
    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append("Property: \"").append(getName()).append("\"");
        return buffer.toString();
    }
}

<code block>


        

package org.apache.poi.poifs.property;

import java.util.Iterator;

import java.io.IOException;



public interface Parent
    extends Child
{

    

    public Iterator getChildren();

    

    public void addChild(final Property property)
        throws IOException;

    

    public void setPreviousChild(final Child child);

    

    public void setNextChild(final Child child);

    

}   


<code block>


package org.apache.poi.poifs.dev;

import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.ListManagedBlock;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.IntList;


public class POIFSHeaderDumper {
	
	public static void main(final String args[]) throws Exception {
		if (args.length == 0) {
			System.err.println("Must specify at least one file to view");
			System.exit(1);
		}

		for (int j = 0; j < args.length; j++) {
		   viewFile(args[j]);
		}
	}

	public static void viewFile(final String filename) throws Exception {
		InputStream inp = new FileInputStream(filename);
		
		
		HeaderBlock header_block = new HeaderBlock(inp);
		displayHeader(header_block);
		
		
      POIFSBigBlockSize bigBlockSize = header_block.getBigBlockSize();
      RawDataBlockList data_blocks = new RawDataBlockList(inp, bigBlockSize);
      displayRawBlocksSummary(data_blocks);
      
      
      BlockAllocationTableReader batReader =
         new BlockAllocationTableReader(
            header_block.getBigBlockSize(),
            header_block.getBATCount(),
            header_block.getBATArray(),
            header_block.getXBATCount(),
            header_block.getXBATIndex(),
            data_blocks);
      displayBATReader(batReader);

      
      PropertyTable properties =
         new PropertyTable(header_block, data_blocks);
      
      
      BlockList sbat = 
         SmallBlockTableReader.getSmallDocumentBlocks(
               bigBlockSize, data_blocks, properties.getRoot(),
               header_block.getSBATStart()
         );
   }

	public static void displayHeader(HeaderBlock header_block) throws Exception {
	   System.out.println("Header Details:");
	   System.out.println(" Block size: " + header_block.getBigBlockSize().getBigBlockSize());
      System.out.println(" BAT (FAT) header blocks: " + header_block.getBATArray().length);
      System.out.println(" BAT (FAT) block count: " + header_block.getBATCount());
      System.out.println(" XBAT (FAT) block count: " + header_block.getXBATCount());
      System.out.println(" XBAT (FAT) block 1 at: " + header_block.getXBATIndex());
      System.out.println(" SBAT (MiniFAT) block count: " + header_block.getSBATCount());
      System.out.println(" SBAT (MiniFAT) block 1 at: " + header_block.getSBATStart());
      System.out.println(" Property table at: " + header_block.getPropertyStart());
      System.out.println("");
	}

   public static void displayRawBlocksSummary(RawDataBlockList data_blocks) throws Exception {
      System.out.println("Raw Blocks Details:");
      System.out.println(" Number of blocks: " + data_blocks.blockCount());
      
      Method gbm = data_blocks.getClass().getSuperclass().getDeclaredMethod("get", int.class);
      gbm.setAccessible(true);
      
      for(int i=0; i<Math.min(16, data_blocks.blockCount()); i++) {
         ListManagedBlock block = (ListManagedBlock)gbm.invoke(data_blocks, Integer.valueOf(i));
         byte[] data = new byte[Math.min(48, block.getData().length)];
         System.arraycopy(block.getData(), 0, data, 0, data.length);
         
         System.out.println(" Block #" + i + ":");
         System.out.println(HexDump.dump(data, 0, 0));
      }
      
      System.out.println("");
   }
   
   public static void displayBATReader(BlockAllocationTableReader batReader) throws Exception {
      System.out.println("Sectors, as referenced from the FAT:");
      Field entriesF = batReader.getClass().getDeclaredField("_entries");
      entriesF.setAccessible(true);
      IntList entries = (IntList)entriesF.get(batReader);
      
      for(int i=0; i<entries.size(); i++) {
         int bn = entries.get(i);
         String bnS = Integer.toString(bn);
         if(bn == POIFSConstants.END_OF_CHAIN) {
            bnS = "End Of Chain";
         } else if(bn == POIFSConstants.DIFAT_SECTOR_BLOCK) {
            bnS = "DI Fat Block";
         } else if(bn == POIFSConstants.FAT_SECTOR_BLOCK) {
            bnS = "Normal Fat Block";
         } else if(bn == POIFSConstants.UNUSED_BLOCK) {
            bnS = "Block Not Used (Free)";
         }
         
         System.out.println("  Block  # " + i + " -> " + bnS);
      }
      
      System.out.println("");
   }
}

<code block>

package org.apache.poi.poifs.dev;

import org.apache.poi.poifs.filesystem.*;

import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.Iterator;


public class POIFSDump {

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < args.length; i++) {
            System.out.println("Dumping " + args[i]);
            FileInputStream is = new FileInputStream(args[i]);
            NPOIFSFileSystem fs = new NPOIFSFileSystem(is);
            is.close();

            DirectoryEntry root = fs.getRoot();
            File file = new File(root.getName());
            file.mkdir();

            dump(root, file);
        }
   }


    public static void dump(DirectoryEntry root, File parent) throws IOException {
        for(Iterator<Entry> it = root.getEntries(); it.hasNext();){
            Entry entry = it.next();
            if(entry instanceof DocumentNode){
                DocumentNode node = (DocumentNode)entry;
                DocumentInputStream is = new DocumentInputStream(node);
                byte[] bytes = new byte[node.getSize()];
                is.read(bytes);
                is.close();

                OutputStream out = new FileOutputStream(new File(parent, node.getName().trim()));
                try {
                	out.write(bytes);
                } finally {
                	out.close();
                }
            } else if (entry instanceof DirectoryEntry){
                DirectoryEntry dir = (DirectoryEntry)entry;
                File file = new File(parent, entry.getName());
                file.mkdir();
                dump(dir, file);
            } else {
                System.err.println("Skipping unsupported POIFS entry: " + entry);
            }
        }
    }
}

<code block>


        

package org.apache.poi.poifs.dev;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;



public class POIFSViewer
{

    

    public static void main(final String args[])
    {
        if (args.length < 0)
        {
            System.err.println("Must specify at least one file to view");
            System.exit(1);
        }
        boolean printNames = (args.length > 1);

        for (int j = 0; j < args.length; j++)
        {
            viewFile(args[ j ], printNames);
        }
    }

    private static void viewFile(final String filename,
                                 final boolean printName)
    {
        if (printName)
        {
            StringBuffer flowerbox = new StringBuffer();

            flowerbox.append(".");
            for (int j = 0; j < filename.length(); j++)
            {
                flowerbox.append("-");
            }
            flowerbox.append(".");
            System.out.println(flowerbox);
            System.out.println("|" + filename + "|");
            System.out.println(flowerbox);
        }
        try
        {
            POIFSViewable fs      =
                new NPOIFSFileSystem(new File(filename));
            List<String>  strings = POIFSViewEngine.inspectViewable(fs, true,
                                        0, "  ");
            Iterator<String> iter = strings.iterator();

            while (iter.hasNext())
            {
                System.out.print(iter.next());
            }
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
        }
    }
}   


<code block>


        

package org.apache.poi.poifs.dev;

import java.util.Iterator;



public interface POIFSViewable
{

    

    public Object [] getViewableArray();
    
    
    public Iterator<Object> getViewableIterator();

    

    public boolean preferArray();

    

    public String getShortDescription();
}   


<code block>


package org.apache.poi.poifs.dev;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Iterator;

import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentNode;
import org.apache.poi.poifs.filesystem.Entry;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;


public class POIFSLister {
   
   public static void main(final String args[]) throws IOException {
      if (args.length == 0) {
         System.err.println("Must specify at least one file to view");
         System.exit(1);
      }

      boolean withSizes = false;
      boolean newPOIFS = true;
      for (int j = 0; j < args.length; j++) {
         if (args[j].equalsIgnoreCase("-size") || args[j].equalsIgnoreCase("-sizes")) {
            withSizes = true;
         } else if (args[j].equalsIgnoreCase("-old") || args[j].equalsIgnoreCase("-old-poifs")) {
            newPOIFS = false;
         } else {
            if(newPOIFS) {
               viewFile(args[j], withSizes);
            } else {
               viewFileOld(args[j], withSizes);
            }
         }
      }
   }

   public static void viewFile(final String filename, boolean withSizes) throws IOException {
      NPOIFSFileSystem fs = new NPOIFSFileSystem(new File(filename));
      displayDirectory(fs.getRoot(), "", withSizes);
   }

   public static void viewFileOld(final String filename, boolean withSizes) throws IOException {
      POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream(filename));
      displayDirectory(fs.getRoot(), "", withSizes);
   }

   public static void displayDirectory(DirectoryNode dir, String indent, boolean withSizes) {
      System.out.println(indent + dir.getName() + " -");
      String newIndent = indent + "  ";

      boolean hadChildren = false;
      for(Iterator<Entry> it = dir.getEntries(); it.hasNext();) {
         hadChildren = true;
         Entry entry = it.next();
         if (entry instanceof DirectoryNode) {
            displayDirectory((DirectoryNode) entry, newIndent, withSizes);
         } else {
            DocumentNode doc = (DocumentNode) entry;
            String name = doc.getName();
            String size = "";
            if (name.charAt(0) < 10) {
               String altname = "(0x0" + (int) name.charAt(0) + ")" + name.substring(1);
               name = name.substring(1) + " <" + altname + ">";
            }
            if (withSizes) {
               size = " [" + doc.getSize() + " / 0x" + 
                      Integer.toHexString(doc.getSize()) + "]";
            }
            System.out.println(newIndent + name + size);
         }
      }
      if (!hadChildren) {
         System.out.println(newIndent + "(no children)");
      }
   }
}

<code block>


        

package org.apache.poi.poifs.dev;

import java.io.IOException;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;



public class POIFSViewEngine
{
    private static final String _EOL = System.getProperty("line.separator");

    

    public static List<String> inspectViewable(final Object viewable,
                                       final boolean drilldown,
                                       final int indentLevel,
                                       final String indentString)
    {
        List<String> objects = new ArrayList<String>();

        if (viewable instanceof POIFSViewable)
        {
            POIFSViewable inspected = ( POIFSViewable ) viewable;

            objects.add(indent(indentLevel, indentString,
                               inspected.getShortDescription()));
            if (drilldown)
            {
                if (inspected.preferArray())
                {
                    Object[] data = inspected.getViewableArray();

                    for (int j = 0; j < data.length; j++)
                    {
                        objects.addAll(inspectViewable(data[ j ], drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
                else
                {
                    Iterator<Object> iter = inspected.getViewableIterator();

                    while (iter.hasNext())
                    {
                        objects.addAll(inspectViewable(iter.next(),
                                                       drilldown,
                                                       indentLevel + 1,
                                                       indentString));
                    }
                }
            }
        }
        else
        {
            objects.add(indent(indentLevel, indentString,
                               viewable.toString()));
        }
        return objects;
    }

    private static String indent(final int indentLevel,
                                 final String indentString, final String data)
    {
        StringBuffer finalBuffer  = new StringBuffer();
        StringBuffer indentPrefix = new StringBuffer();

        for (int j = 0; j < indentLevel; j++)
        {
            indentPrefix.append(indentString);
        }
        LineNumberReader reader =
            new LineNumberReader(new StringReader(data));

        try
        {
            String line = reader.readLine();

            while (line != null)
            {
                finalBuffer.append(indentPrefix).append(line).append(_EOL);
                line = reader.readLine();
            }
        }
        catch (IOException e)
        {
            finalBuffer.append(indentPrefix).append(e.getMessage())
                .append(_EOL);
        }
        return finalBuffer.toString();
    }
}   


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LittleEndianOutputStream;
import org.apache.poi.util.StringUtil;


public class Ole10Native {

    public static final String OLE10_NATIVE = "\u0001Ole10Native";
    protected static final String ISO1 = "ISO-8859-1";
  
    
    private int totalSize;             
    private short flags1 = 2;          
    private String label;              
    private String fileName;           
    private short flags2 = 0;          
    private short unknown1 = 3;        
    private String command;            
    private byte[] dataBuffer;         
    private short flags3 = 0;          
  
     
    private enum EncodingMode {
        
        parsed,
        
        unparsed,
        
        compact;
    }
    
    private EncodingMode mode;

    
    
    
    public static Ole10Native createFromEmbeddedOleObject(POIFSFileSystem poifs) throws IOException, Ole10NativeException {
       return createFromEmbeddedOleObject(poifs.getRoot());
    }
    
    
    public static Ole10Native createFromEmbeddedOleObject(DirectoryNode directory) throws IOException, Ole10NativeException {
       DocumentEntry nativeEntry = 
          (DocumentEntry)directory.getEntry(OLE10_NATIVE);
       byte[] data = new byte[nativeEntry.getSize()];
       int readBytes = directory.createDocumentInputStream(nativeEntry).read(data);
       assert(readBytes == data.length);
  
       return new Ole10Native(data, 0);
    }
    
    
    public Ole10Native(String label, String filename, String command, byte[] data) {
       setLabel(label);
       setFileName(filename);
       setCommand(command);
       setDataBuffer(data);
       mode = EncodingMode.parsed;
    }

    
    public Ole10Native(byte[] data, int offset, boolean plain) throws Ole10NativeException {
        this(data, offset);
    }
    
    
    public Ole10Native(byte[] data, int offset) throws Ole10NativeException {
        int ofs = offset; 
        
        if (data.length < offset + 2) {
            throw new Ole10NativeException("data is too small");
        }
        
        totalSize = LittleEndian.getInt(data, ofs);
        ofs += LittleEndianConsts.INT_SIZE;
        
        mode = EncodingMode.unparsed;
        if (LittleEndian.getShort(data, ofs) == 2) {
            
            
            if (Character.isISOControl(data[ofs+LittleEndianConsts.SHORT_SIZE])) {
                mode = EncodingMode.compact;
            } else {
                mode = EncodingMode.parsed;
            }
        }

        int dataSize;
        switch (mode) {
        case parsed: {
            flags1 = LittleEndian.getShort(data, ofs);
            
            
            ofs += LittleEndianConsts.SHORT_SIZE;
        
            int len = getStringLength(data, ofs);
            label = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
            
            len = getStringLength(data, ofs);
            fileName = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
    
            flags2 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
            
            unknown1 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
          
            len = LittleEndian.getInt(data, ofs);
            ofs += LittleEndianConsts.INT_SIZE;
            command = StringUtil.getFromCompressedUnicode(data, ofs, len - 1);
            ofs += len;
            
            if (totalSize < ofs) {
                throw new Ole10NativeException("Invalid Ole10Native");
            }
          
            dataSize = LittleEndian.getInt(data, ofs);
            ofs += LittleEndianConsts.INT_SIZE;
          
            if (dataSize < 0 || totalSize - (ofs - LittleEndianConsts.INT_SIZE) < dataSize) {
                throw new Ole10NativeException("Invalid Ole10Native");
            }
            break;
        }
        case compact:
            flags1 = LittleEndian.getShort(data, ofs);
            ofs += LittleEndianConsts.SHORT_SIZE;
            dataSize = totalSize - LittleEndianConsts.SHORT_SIZE;
            break;
        default:
        case unparsed:
            dataSize = totalSize;
            break;
        }
        
        dataBuffer = new byte[dataSize];
        System.arraycopy(data, ofs, dataBuffer, 0, dataSize);
        ofs += dataSize;
    }

    
    private static int getStringLength(byte[] data, int ofs) {
        int len = 0;
        while (len + ofs < data.length && data[ofs + len] != 0) {
            len++;
        }
        len++;
        return len;
    }

    
    public int getTotalSize() {
        return totalSize;
    }

    
    public short getFlags1() {
        return flags1;
    }

    
    public String getLabel() {
        return label;
    }

    
    public String getFileName() {
        return fileName;
    }

    
    public short getFlags2() {
        return flags2;
    }

    
    public short getUnknown1() {
        return unknown1;
    }

    
    public String getCommand() {
        return command;
    }

    
    public int getDataSize() {
        return dataBuffer.length;
    }

    
    public byte[] getDataBuffer() {
        return dataBuffer;
    }

    
    public short getFlags3() {
        return flags3;
    }

    
    public void writeOut(OutputStream out) throws IOException {
        
        

        @SuppressWarnings("resource")
        LittleEndianOutputStream leosOut = new LittleEndianOutputStream(out);
        
        switch (mode) {
        case parsed: {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            LittleEndianOutputStream leos = new LittleEndianOutputStream(bos);
            

            leos.writeShort(getFlags1());
            leos.write(getLabel().getBytes(ISO1));
            leos.write(0);
            leos.write(getFileName().getBytes(ISO1));
            leos.write(0);
            leos.writeShort(getFlags2());
            leos.writeShort(getUnknown1());
            leos.writeInt(getCommand().length() + 1);
            leos.write(getCommand().getBytes(ISO1));
            leos.write(0);
            leos.writeInt(getDataSize());
            leos.write(getDataBuffer());
            leos.writeShort(getFlags3());
            leos.close(); 
            
            leosOut.writeInt(bos.size()); 
            bos.writeTo(out);
            break;
        }
        case compact:
            leosOut.writeInt(getDataSize()+LittleEndianConsts.SHORT_SIZE);
            leosOut.writeShort(getFlags1());
            out.write(getDataBuffer());
            break;
        default:
        case unparsed:
            leosOut.writeInt(getDataSize());
            out.write(getDataBuffer());
            break;
        }

    }

    public void setFlags1(short flags1) {
        this.flags1 = flags1;
    }

    public void setFlags2(short flags2) {
        this.flags2 = flags2;
    }

    public void setFlags3(short flags3) {
        this.flags3 = flags3;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public void setCommand(String command) {
        this.command = command;
    }

    public void setUnknown1(short unknown1) {
        this.unknown1 = unknown1;
    }

    public void setDataBuffer(byte dataBuffer[]) {
        this.dataBuffer = dataBuffer;
    }
}

<code block>



package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;

import org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;


public abstract class BlockStore {
   
   protected abstract int getBlockStoreBlockSize();
   
    
    protected abstract ByteBuffer getBlockAt(final int offset) throws IOException;
    
    
    protected abstract ByteBuffer createBlockIfNeeded(final int offset) throws IOException;
    
    
    protected abstract BATBlockAndIndex getBATBlockAndIndex(final int offset);
    
    
    protected abstract int getNextBlock(final int offset);
    
    
    protected abstract void setNextBlock(final int offset, final int nextBlock);
    
    
    protected abstract int getFreeBlock() throws IOException;
    
    
    protected abstract ChainLoopDetector getChainLoopDetector() throws IOException;
    
    
    protected class ChainLoopDetector {
       private boolean[] used_blocks;
       protected ChainLoopDetector(long rawSize) {
          int numBlocks = (int)Math.ceil( rawSize / getBlockStoreBlockSize() );
          used_blocks = new boolean[numBlocks];
       }
       protected void claim(int offset) {
          if(offset >= used_blocks.length) {
             
             
             
             return;
          }
          
          
          if(used_blocks[offset]) {
             throw new IllegalStateException(
                   "Potential loop detected - Block " + offset + 
                   " was already claimed but was just requested again"
             );
          }
          used_blocks[offset] = true;
       }
    }
}


<code block>




package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.CloseIgnoringInputStream;



public class POIFSFileSystem
    extends NPOIFSFileSystem 
    implements POIFSViewable
{
    
    public static InputStream createNonClosingInputStream(InputStream is) {
        return new CloseIgnoringInputStream(is);
    }

    
    public POIFSFileSystem()
    {
        super();
    }

    

    public POIFSFileSystem(InputStream stream)
        throws IOException
    {
        super(stream);
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        return NPOIFSFileSystem.hasPOIFSHeader(inp);
    }
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        return NPOIFSFileSystem.hasPOIFSHeader(header8Bytes);
    }

    

    public static void main(String args[])
        throws IOException
    {
        OPOIFSFileSystem.main(args);
    }
}


<code block>


        

package org.apache.poi.poifs.filesystem;



public interface DocumentEntry
    extends Entry
{

    

    public int getSize();
}   


<code block>


        

package org.apache.poi.poifs.filesystem;



public class DocumentDescriptor
{
    private POIFSDocumentPath path;
    private String            name;
    private int               hashcode = 0;

    

    public DocumentDescriptor(final POIFSDocumentPath path, final String name)
    {
        if (path == null)
        {
            throw new NullPointerException("path must not be null");
        }
        if (name == null)
        {
            throw new NullPointerException("name must not be null");
        }
        if (name.length() == 0)
        {
            throw new IllegalArgumentException("name cannot be empty");
        }
        this.path = path;
        this.name = name;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                DocumentDescriptor descriptor = ( DocumentDescriptor ) o;

                rval = this.path.equals(descriptor.path)
                       && this.name.equals(descriptor.name);
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            hashcode = path.hashCode() ^ name.hashCode();
        }
        return hashcode;
    }

    public String toString()
    {
        StringBuffer buffer = new StringBuffer(40 * (path.length() + 1));

        for (int j = 0; j < path.length(); j++)
        {
            buffer.append(path.getComponent(j)).append("/");
        }
        buffer.append(name);
        return buffer.toString();
    }
}   


<code block>


        

package org.apache.poi.poifs.filesystem;



public interface BATManaged
{

    

    public int countBlocks();

    

    public void setStartBlock(final int index);
}   


<code block>




package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.poi.hpsf.ClassID;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;


public class DirectoryNode
    extends EntryNode
    implements DirectoryEntry, POIFSViewable, Iterable<Entry>
{

    
    private Map<String,Entry> _byname;
    
    private ArrayList<Entry> _entries;

    
    
    private OPOIFSFileSystem   _ofilesystem;
    
    private NPOIFSFileSystem  _nfilesystem;

    
    private POIFSDocumentPath _path;

    
    DirectoryNode(final DirectoryProperty property,
                  final OPOIFSFileSystem filesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, filesystem, (NPOIFSFileSystem)null);
    }

    
    DirectoryNode(final DirectoryProperty property,
                  final NPOIFSFileSystem nfilesystem,
                  final DirectoryNode parent)
    {
       this(property, parent, (OPOIFSFileSystem)null, nfilesystem);
    }

    private DirectoryNode(final DirectoryProperty property,
                          final DirectoryNode parent,
                          final OPOIFSFileSystem ofilesystem,
                          final NPOIFSFileSystem nfilesystem)
    {
        super(property, parent);
        this._ofilesystem = ofilesystem;
        this._nfilesystem = nfilesystem;

        if (parent == null)
        {
            _path = new POIFSDocumentPath();
        }
        else
        {
            _path = new POIFSDocumentPath(parent._path, new String[]
            {
                property.getName()
            });
        }
        _byname     = new HashMap<String, Entry>();
        _entries    = new ArrayList<Entry>();
        Iterator<Property> iter = property.getChildren();

        while (iter.hasNext())
        {
            Property child     = iter.next();
            Entry    childNode = null;

            if (child.isDirectory())
            {
                DirectoryProperty childDir = (DirectoryProperty) child;
                if(_ofilesystem != null) {
                   childNode = new DirectoryNode(childDir, _ofilesystem, this);
                } else {
                   childNode = new DirectoryNode(childDir, _nfilesystem, this);
                }
            }
            else
            {
                childNode = new DocumentNode((DocumentProperty) child, this);
            }
            _entries.add(childNode);
            _byname.put(childNode.getName(), childNode);
        }
    }

    

    public POIFSDocumentPath getPath()
    {
        return _path;
    }

    
    public NPOIFSFileSystem getFileSystem()
    {
        return _nfilesystem;
    }

    
    public OPOIFSFileSystem getOFileSystem()
    {
        return _ofilesystem;
    }

    
    public NPOIFSFileSystem getNFileSystem()
    {
        return _nfilesystem;
    }

    
    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
        return createDocumentInputStream(getEntry(documentName));
    }

    
    public DocumentInputStream createDocumentInputStream(
            final Entry document)
        throws IOException
    {
        if (!document.isDocumentEntry()) {
            throw new IOException("Entry '" + document.getName()
                                  + "' is not a DocumentEntry");
        }

        DocumentEntry entry = (DocumentEntry)document;
        return new DocumentInputStream(entry);
    }

    
    DocumentEntry createDocument(final OPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _ofilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    DocumentEntry createDocument(final NPOIFSDocument document)
        throws IOException
    {
        DocumentProperty property = document.getDocumentProperty();
        DocumentNode     rval     = new DocumentNode(property, this);

        (( DirectoryProperty ) getProperty()).addChild(property);
        _nfilesystem.addDocument(document);

        _entries.add(rval);
        _byname.put(property.getName(), rval);
        return rval;
    }

    
    boolean changeName(final String oldName, final String newName)
    {
        boolean   rval  = false;
        EntryNode child = ( EntryNode ) _byname.get(oldName);

        if (child != null)
        {
            rval = (( DirectoryProperty ) getProperty())
                .changeName(child.getProperty(), newName);
            if (rval)
            {
                _byname.remove(oldName);
                _byname.put(child.getProperty().getName(), child);
            }
        }
        return rval;
    }

    

    boolean deleteEntry(final EntryNode entry)
    {
        boolean rval =
            (( DirectoryProperty ) getProperty())
                .deleteChild(entry.getProperty());

        if (rval)
        {
            _entries.remove(entry);
            _byname.remove(entry.getName());

            if(_ofilesystem != null) {
                _ofilesystem.remove(entry);
            } else {
                try {
                    _nfilesystem.remove(entry);
                } catch (IOException e) {
                    
                }
            }
        }
        return rval;
    }

    

    

    public Iterator<Entry> getEntries()
    {
        return _entries.iterator();
    }
    
    
    public Set<String> getEntryNames()
    {
        return _byname.keySet();
    }

    

    public boolean isEmpty()
    {
        return _entries.isEmpty();
    }

    

    public int getEntryCount()
    {
        return _entries.size();
    }

    public boolean hasEntry( String name )
    {
        return name != null && _byname.containsKey( name );
    }

    

    public Entry getEntry(final String name) throws FileNotFoundException {
        Entry rval = null;

        if (name != null) {
            rval = _byname.get(name);
        }
        if (rval == null) {
            
            throw new FileNotFoundException("no such entry: \"" + name
                    + "\", had: " + _byname.keySet());
        }
        return rval;
    }

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException
    {
        if(_nfilesystem != null) {
           return createDocument(new NPOIFSDocument(name, _nfilesystem, stream));
        } else {
           return createDocument(new OPOIFSDocument(name, stream));
        }
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        if(_nfilesystem != null) {
            return createDocument(new NPOIFSDocument(name, size, _nfilesystem, writer));
         } else {
            return createDocument(new OPOIFSDocument(name, size, _path, writer));
         }
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        DirectoryNode rval;
        DirectoryProperty property = new DirectoryProperty(name);

        if(_ofilesystem != null) {
           rval = new DirectoryNode(property, _ofilesystem, this);
           _ofilesystem.addDirectory(property);
        } else {
           rval = new DirectoryNode(property, _nfilesystem, this);
           _nfilesystem.addDirectory(property);
        }

        (( DirectoryProperty ) getProperty()).addChild(property);
        _entries.add(rval);
        _byname.put(name, rval);
        return rval;
    }

    
    public ClassID getStorageClsid()
    {
        return getProperty().getStorageClsid();
    }

    
    public void setStorageClsid(ClassID clsidStorage)
    {
        getProperty().setStorageClsid(clsidStorage);
    }

    
    

    

    @Override
    public boolean isDirectoryEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {

        
        return isEmpty();
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    
    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        Iterator<Entry> iter = _entries.iterator();
        while (iter.hasNext())
        {
            components.add(iter.next());
        }
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
    public Iterator<Entry> iterator() {
        return getEntries();
    }

    
}   


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.property.DocumentProperty;


public final class NDocumentOutputStream extends OutputStream {
	
	private int _document_size;

	
	private boolean _closed;

	
	private NPOIFSDocument _document;
	
	private DocumentProperty _property;
	
	
	private ByteArrayOutputStream _buffer = 
	        new ByteArrayOutputStream(POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE);
	
	
	private NPOIFSStream _stream;
	private OutputStream _stream_output;
	
	
	public NDocumentOutputStream(DocumentEntry document) throws IOException {
		if (!(document instanceof DocumentNode)) {
			throw new IOException("Cannot open internal document storage, " + document + " not a Document Node");
		}
		_document_size = 0;
		_closed = false;
		
		_property = (DocumentProperty)((DocumentNode)document).getProperty();
		
		_document = new NPOIFSDocument((DocumentNode)document);
		_document.free();
	}
	
	
	public NDocumentOutputStream(DirectoryEntry parent, String name) throws IOException {
        if (!(parent instanceof DirectoryNode)) {
            throw new IOException("Cannot open internal directory storage, " + parent + " not a Directory Node");
        }
        _document_size = 0;
        _closed = false;

        
        DocumentEntry doc = parent.createDocument(name, new ByteArrayInputStream(new byte[0]));
        _property = (DocumentProperty)((DocumentNode)doc).getProperty();
        _document = new NPOIFSDocument((DocumentNode)doc);
	}
	
    private void dieIfClosed() throws IOException {
        if (_closed) {
            throw new IOException("cannot perform requested operation on a closed stream");
        }
    }
    
    private void checkBufferSize() throws IOException {
        
        if (_buffer.size() > POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
            
            byte[] data = _buffer.toByteArray();
            _buffer = null;
            write(data, 0, data.length);
        } else {
            
        }
    }

    public void write(int b) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b);
            checkBufferSize();
        } else {
            write(new byte[] { (byte)b });
        }
    }

    public void write(byte[] b) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b);
            checkBufferSize();
        } else {
            write(b, 0, b.length);
        }
    }

    public void write(byte[] b, int off, int len) throws IOException {
        dieIfClosed();
        
        if (_buffer != null) {
            _buffer.write(b, off, len);
            checkBufferSize();
        } else {
            if (_stream == null) {
                _stream = new NPOIFSStream(_document.getFileSystem());
                _stream_output = _stream.getOutputStream();
            }
            _stream_output.write(b, off, len);
            _document_size += len;
        }
    }

    public void close() throws IOException {
        
        if (_buffer != null) {
            
            _document.replaceContents(new ByteArrayInputStream(_buffer.toByteArray()));
        }
        else {
            
            
            _stream_output.close();
            _property.updateSize(_document_size);
            _property.setStartBlock(_stream.getStartBlock());
        }
        
        
        _closed = true;
    }
}

<code block>


package org.apache.poi.poifs.filesystem;

public class Ole10NativeException extends Exception {
    public Ole10NativeException(String message) {
        super(message);
    }
}

<code block>


        

package org.apache.poi.poifs.filesystem;



public class POIFSWriterEvent
{
    private DocumentOutputStream stream;
    private POIFSDocumentPath    path;
    private String               documentName;
    private int                  limit;

    

    POIFSWriterEvent(final DocumentOutputStream stream,
                     final POIFSDocumentPath path, final String documentName,
                     final int limit)
    {
        this.stream       = stream;
        this.path         = path;
        this.documentName = documentName;
        this.limit        = limit;
    }

    

    public DocumentOutputStream getStream()
    {
        return stream;
    }

    

    public POIFSDocumentPath getPath()
    {
        return path;
    }

    

    public String getName()
    {
        return documentName;
    }

    

    public int getLimit()
    {
        return limit;
    }
}   


<code block>




package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.property.RootProperty;
import org.apache.poi.poifs.storage.BATBlock;
import org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;
import org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.apache.poi.poifs.storage.HeaderBlock;


public class NPOIFSMiniStore extends BlockStore
{
    private NPOIFSFileSystem _filesystem;
    private NPOIFSStream     _mini_stream;
    private List<BATBlock>   _sbat_blocks;
    private HeaderBlock      _header;
    private RootProperty     _root;

    protected NPOIFSMiniStore(NPOIFSFileSystem filesystem, RootProperty root,
         List<BATBlock> sbats, HeaderBlock header)
    {
       this._filesystem = filesystem;
       this._sbat_blocks = sbats;
       this._header = header;
       this._root = root;
       
       this._mini_stream = new NPOIFSStream(filesystem, root.getStartBlock());
    }
    
    
    protected ByteBuffer getBlockAt(final int offset) throws IOException {
       
       int byteOffset = offset * POIFSConstants.SMALL_BLOCK_SIZE;
       int bigBlockNumber = byteOffset / _filesystem.getBigBlockSize();
       int bigBlockOffset = byteOffset % _filesystem.getBigBlockSize();
       
       
       Iterator<ByteBuffer> it = _mini_stream.getBlockIterator();
       for(int i=0; i<bigBlockNumber; i++) {
          it.next();
       }
       ByteBuffer dataBlock = it.next();
       if(dataBlock == null) {
          throw new IndexOutOfBoundsException("Big block " + bigBlockNumber + " outside stream");
       }

       
       dataBlock.position(
             dataBlock.position() + bigBlockOffset
       );
       ByteBuffer miniBuffer = dataBlock.slice();
       miniBuffer.limit(POIFSConstants.SMALL_BLOCK_SIZE);
       return miniBuffer;
    }
    
    
    protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {
       boolean firstInStore = false;
       if (_mini_stream.getStartBlock() == POIFSConstants.END_OF_CHAIN) {
           firstInStore = true;
       }
       
       
       if (! firstInStore) {
           try {
              return getBlockAt(offset);
           } catch(IndexOutOfBoundsException e) {}
       }
       
       
       
       

       
       int newBigBlock = _filesystem.getFreeBlock();
       _filesystem.createBlockIfNeeded(newBigBlock);
       
       
       if (firstInStore) {
           _filesystem._get_property_table().getRoot().setStartBlock(newBigBlock);
           _mini_stream = new NPOIFSStream(_filesystem, newBigBlock);
       } else {
           
           ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();
           int block = _mini_stream.getStartBlock();
           while(true) {
              loopDetector.claim(block);
              int next = _filesystem.getNextBlock(block);
              if(next == POIFSConstants.END_OF_CHAIN) {
                 break;
              }
              block = next;
           }
           _filesystem.setNextBlock(block, newBigBlock);
       }
       
       
       _filesystem.setNextBlock(newBigBlock, POIFSConstants.END_OF_CHAIN);

       
       return createBlockIfNeeded(offset);
    }
    
    
    protected BATBlockAndIndex getBATBlockAndIndex(final int offset) {
       return BATBlock.getSBATBlockAndIndex(
             offset, _header, _sbat_blocks
       );
    }
    
    
    protected int getNextBlock(final int offset) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       return bai.getBlock().getValueAt( bai.getIndex() );
    }
    
    
    protected void setNextBlock(final int offset, final int nextBlock) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       bai.getBlock().setValueAt(
             bai.getIndex(), nextBlock
       );
    }
    
    
    protected int getFreeBlock() throws IOException {
       int sectorsPerSBAT = _filesystem.getBigBlockSizeDetails().getBATEntriesPerBlock();
       
       
       int offset = 0;
       for(int i=0; i<_sbat_blocks.size(); i++) {
          
          BATBlock sbat = _sbat_blocks.get(i);
          if(sbat.hasFreeSectors()) {
             
             for(int j=0; j<sectorsPerSBAT; j++) {
                int sbatValue = sbat.getValueAt(j);
                if(sbatValue == POIFSConstants.UNUSED_BLOCK) {
                   
                   return offset + j;
                }
             }
          }
          
          
          offset += sectorsPerSBAT;
       }
       
       
       
       
       
       
       BATBlock newSBAT = BATBlock.createEmptyBATBlock(_filesystem.getBigBlockSizeDetails(), false);
       int batForSBAT = _filesystem.getFreeBlock();
       newSBAT.setOurBlockIndex(batForSBAT);
       
       
       if(_header.getSBATCount() == 0) {
          
          _header.setSBATStart(batForSBAT);
          _header.setSBATBlockCount(1);
       } else {
          
          ChainLoopDetector loopDetector = _filesystem.getChainLoopDetector();
          int batOffset = _header.getSBATStart();
          while(true) {
             loopDetector.claim(batOffset);
             int nextBat = _filesystem.getNextBlock(batOffset);
             if(nextBat == POIFSConstants.END_OF_CHAIN) {
                break;
             }
             batOffset = nextBat;
          }
          
          
          _filesystem.setNextBlock(batOffset, batForSBAT);
          
          
          _header.setSBATBlockCount(
                _header.getSBATCount() + 1
          );
       }
       
       
       _filesystem.setNextBlock(batForSBAT, POIFSConstants.END_OF_CHAIN);
       _sbat_blocks.add(newSBAT);
       
       
       return offset;
    }
    
    @Override
    protected ChainLoopDetector getChainLoopDetector() throws IOException {
      return new ChainLoopDetector( _root.getSize() );
    }

    protected int getBlockStoreBlockSize() {
       return POIFSConstants.SMALL_BLOCK_SIZE;
    }
    
    
    protected void syncWithDataSource() throws IOException {
       for(BATBlock sbat : _sbat_blocks) {
          ByteBuffer block = _filesystem.getBlockAt(sbat.getOurBlockIndex());
          BlockAllocationTableWriter.writeBlock(sbat, block);
       }
    }
}

<code block>


        

package org.apache.poi.poifs.filesystem;



public interface POIFSWriterListener
{

    

    public void processPOIFSWriterEvent(POIFSWriterEvent event);
}   


<code block>


        

package org.apache.poi.poifs.filesystem;

import java.io.File;



import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class POIFSDocumentPath
{

	private static Logger log = LoggerFactory.getLogger(POIFSDocumentPath.class);
          
    private String[] components;
    private int      hashcode = 0;

    

    public POIFSDocumentPath(final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ 0 ];
        }
        else
        {
            this.components = new String[ components.length ];
            for (int j = 0; j < components.length; j++)
            {
                if ((components[ j ] == null)
                        || (components[ j ].length() == 0))
                {
                    throw new IllegalArgumentException(
                        "components cannot contain null or empty strings");
                }
                this.components[ j ] = components[ j ];
            }
        }
    }

    

    public POIFSDocumentPath()
    {
        this.components = new String[ 0 ];
    }

    

    public POIFSDocumentPath(final POIFSDocumentPath path,
                             final String [] components)
        throws IllegalArgumentException
    {
        if (components == null)
        {
            this.components = new String[ path.components.length ];
        }
        else
        {
            this.components =
                new String[ path.components.length + components.length ];
        }
        for (int j = 0; j < path.components.length; j++)
        {
            this.components[ j ] = path.components[ j ];
        }
        if (components != null)
        {
            for (int j = 0; j < components.length; j++)
            {
                if (components[ j ] == null)
                {
                    throw new IllegalArgumentException(
                        "components cannot contain null");
                }
                if (components[ j ].length() == 0)
                {
                    log.warn("Directory under " + path + " has an empty name, " +
                            "not all OLE2 readers will handle this file correctly!");
                }
                
                this.components[ j + path.components.length ] =
                    components[ j ];
            }
        }
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = false;

        if ((o != null) && (o.getClass() == this.getClass()))
        {
            if (this == o)
            {
                rval = true;
            }
            else
            {
                POIFSDocumentPath path = ( POIFSDocumentPath ) o;

                if (path.components.length == this.components.length)
                {
                    rval = true;
                    for (int j = 0; j < this.components.length; j++)
                    {
                        if (!path.components[ j ]
                                .equals(this.components[ j ]))
                        {
                            rval = false;
                            break;
                        }
                    }
                }
            }
        }
        return rval;
    }

    

    public int hashCode()
    {
        if (hashcode == 0)
        {
            for (int j = 0; j < components.length; j++)
            {
                hashcode += components[ j ].hashCode();
            }
        }
        return hashcode;
    }

    

    public int length()
    {
        return components.length;
    }

    

    public String getComponent(int n)
        throws ArrayIndexOutOfBoundsException
    {
        return components[ n ];
    }

    

    public POIFSDocumentPath getParent()
    {
        final int length = components.length - 1;

        if (length < 0)
        {
            return null;
        }
        POIFSDocumentPath parent = new POIFSDocumentPath(null);

        parent.components = new String[ length ];
        System.arraycopy(components, 0, parent.components, 0, length);
        return parent;
    }

    

    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int          l = length();

        b.append(File.separatorChar);
        for (int i = 0; i < l; i++)
        {
            b.append(getComponent(i));
            if (i < l - 1)
            {
                b.append(File.separatorChar);
            }
        }
        return b.toString();
    }
}   


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.util.HexDump;


public final class NPOIFSDocument implements POIFSViewable {
   private DocumentProperty _property;

   private NPOIFSFileSystem _filesystem;
   private NPOIFSStream _stream;
   private int _block_size;
	
   
   public NPOIFSDocument(DocumentNode document) throws IOException {
       this((DocumentProperty)document.getProperty(), 
            ((DirectoryNode)document.getParent()).getNFileSystem());
   }
   
   
   public NPOIFSDocument(DocumentProperty property, NPOIFSFileSystem filesystem) 
      throws IOException
   {
      this._property = property;
      this._filesystem = filesystem;

      if(property.getSize() < POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
         _stream = new NPOIFSStream(_filesystem.getMiniStore(), property.getStartBlock());
         _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
      } else {
         _stream = new NPOIFSStream(_filesystem, property.getStartBlock());
         _block_size = _filesystem.getBlockStoreBlockSize();
      }
   }

   
   public NPOIFSDocument(String name, NPOIFSFileSystem filesystem, InputStream stream) 
      throws IOException 
   {
      this._filesystem = filesystem;

      
      int length = store(stream);

      
      this._property = new DocumentProperty(name, length);
      _property.setStartBlock(_stream.getStartBlock());     
   }
   
   public NPOIFSDocument(String name, int size, NPOIFSFileSystem filesystem, POIFSWriterListener writer) 
      throws IOException 
   {
       this._filesystem = filesystem;

       if (size < POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE) {
           _stream = new NPOIFSStream(filesystem.getMiniStore());
           _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
       } else {
           _stream = new NPOIFSStream(filesystem);
           _block_size = _filesystem.getBlockStoreBlockSize();
       }
       
       OutputStream innerOs = _stream.getOutputStream();
       DocumentOutputStream os = new DocumentOutputStream(innerOs, size);
       POIFSDocumentPath path = new POIFSDocumentPath(name.split("\\\\"));
       String docName = path.getComponent(path.length()-1);
       POIFSWriterEvent event = new POIFSWriterEvent(os, path, docName, size);
       writer.processPOIFSWriterEvent(event);
       innerOs.close();

       
       this._property = new DocumentProperty(name, size);
       _property.setStartBlock(_stream.getStartBlock());     
   }
   
   
   private int store(InputStream stream) throws IOException {
       final int bigBlockSize = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
       BufferedInputStream bis = new BufferedInputStream(stream, bigBlockSize+1);
       bis.mark(bigBlockSize);

       
       if(bis.skip(bigBlockSize) < bigBlockSize) {
          _stream = new NPOIFSStream(_filesystem.getMiniStore());
          _block_size = _filesystem.getMiniStore().getBlockStoreBlockSize();
       } else {
          _stream = new NPOIFSStream(_filesystem);
          _block_size = _filesystem.getBlockStoreBlockSize();
       }

       
       bis.reset();
       
       
       OutputStream os = _stream.getOutputStream();
       byte buf[] = new byte[1024];
       int length = 0;
       
       for (int readBytes; (readBytes = bis.read(buf)) != -1; length += readBytes) {
           os.write(buf, 0, readBytes);
       }
       
       
       os.close();
       return length;
   }
   
   
   void free() throws IOException {
       _stream.free();
       _property.setStartBlock(POIFSConstants.END_OF_CHAIN);
   }
   
   NPOIFSFileSystem getFileSystem()
   {
       return _filesystem;
   }
   
   int getDocumentBlockSize() {
      return _block_size;
   }
   
   Iterator<ByteBuffer> getBlockIterator() {
      if(getSize() > 0) {
         return _stream.getBlockIterator();
      } else {
         List<ByteBuffer> empty = Collections.emptyList();
         return empty.iterator();
      }
   }

   
   public int getSize() {
      return _property.getSize();
   }
   
   public void replaceContents(InputStream stream) throws IOException {
       free();
       int size = store(stream);
       _property.setStartBlock(_stream.getStartBlock()); 
       _property.updateSize(size);
   }

   
   DocumentProperty getDocumentProperty() {
      return _property;
   }

   
   public Object[] getViewableArray() {
      Object[] results = new Object[1];
      String result;

      try {
         if(getSize() > 0) {
            
            byte[] data = new byte[getSize()];
            int offset = 0;
            for(ByteBuffer buffer : _stream) {
               int length = Math.min(_block_size, data.length-offset); 
               buffer.get(data, offset, length);
               offset += length;
            }

            ByteArrayOutputStream output = new ByteArrayOutputStream();
            HexDump.dump(data, 0, output, 0);
            result = output.toString();
         } else {
            result = "<NO DATA>";
         }
      } catch (IOException e) {
         result = e.getMessage();
      }
      results[0] = result;
      return results;
   }

   
   public Iterator<Object> getViewableIterator() {
      return Collections.emptyList().iterator();
   }

   
   public boolean preferArray() {
      return true;
   }

   
   public String getShortDescription() {
      StringBuffer buffer = new StringBuffer();

      buffer.append("Document: \"").append(_property.getName()).append("\"");
      buffer.append(" size = ").append(getSize());
      return buffer.toString();
   }
}

<code block>


package org.apache.poi.poifs.filesystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.DataInputBlock;
import org.apache.poi.poifs.storage.DocumentBlock;
import org.apache.poi.poifs.storage.ListManagedBlock;
import org.apache.poi.poifs.storage.RawDataBlock;
import org.apache.poi.poifs.storage.SmallDocumentBlock;
import org.apache.poi.util.HexDump;


public final class OPOIFSDocument implements BATManaged, BlockWritable, POIFSViewable  {
	private static final DocumentBlock[] EMPTY_BIG_BLOCK_ARRAY = { };
	private static final SmallDocumentBlock[] EMPTY_SMALL_BLOCK_ARRAY = { };
	private DocumentProperty _property;
	private int _size;
	
   private final POIFSBigBlockSize _bigBigBlockSize;

	
	private SmallBlockStore  _small_store;
	private BigBlockStore	 _big_store;
	
		
	public OPOIFSDocument(String name, RawDataBlock[] blocks, int length) throws IOException {
		_size = length;
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = (blocks[0].getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
		         POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS : 
		         POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
		   );
		}
		
		_big_store = new BigBlockStore(_bigBigBlockSize, convertRawBlocksToBigBlocks(blocks));
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
		_property.setDocument(this);
	}

	
	private static DocumentBlock[] convertRawBlocksToBigBlocks(ListManagedBlock[] blocks) throws IOException {
		DocumentBlock[] result = new DocumentBlock[blocks.length];
		for (int i = 0; i < result.length; i++) {
			result[i] = new DocumentBlock((RawDataBlock)blocks[i]);
		}
		return result;
	}
	private static SmallDocumentBlock[] convertRawBlocksToSmallBlocks(ListManagedBlock[] blocks) {
		if (blocks instanceof SmallDocumentBlock[]) {
			return (SmallDocumentBlock[]) blocks;
		}
		SmallDocumentBlock[] result = new SmallDocumentBlock[blocks.length];
		System.arraycopy(blocks, 0, result, 0, blocks.length);
		return result;
	}

	
	public OPOIFSDocument(String name, SmallDocumentBlock[] blocks, int length) {
		_size = length;
		
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = blocks[0].getBigBlockSize();
		}

		_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, blocks);
		_property.setDocument(this);
	}

	
	public OPOIFSDocument(String name, POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, int length) throws IOException {
		_size = length;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (Property.isSmall(_size)) {
			_big_store = new BigBlockStore(bigBlockSize,EMPTY_BIG_BLOCK_ARRAY);
			_small_store = new SmallBlockStore(bigBlockSize,convertRawBlocksToSmallBlocks(blocks));
		} else {
			_big_store = new BigBlockStore(bigBlockSize,convertRawBlocksToBigBlocks(blocks));
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public OPOIFSDocument(String name, ListManagedBlock[] blocks, int length) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, blocks, length);
	}

	
	public OPOIFSDocument(String name, POIFSBigBlockSize bigBlockSize, InputStream stream) throws IOException {
		List<DocumentBlock> blocks = new ArrayList<DocumentBlock>();

		_size = 0;
		_bigBigBlockSize = bigBlockSize;
		while (true) {
			DocumentBlock block = new DocumentBlock(stream, bigBlockSize);
			int blockSize = block.size();

			if (blockSize > 0) {
				blocks.add(block);
				_size += blockSize;
			}
			if (block.partiallyRead()) {
				break;
			}
		}
		DocumentBlock[] bigBlocks = blocks.toArray(new DocumentBlock[blocks.size()]);

		_big_store = new BigBlockStore(bigBlockSize,bigBlocks);
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(bigBlockSize,SmallDocumentBlock.convert(bigBlockSize,bigBlocks, _size));
			_big_store = new BigBlockStore(bigBlockSize,new DocumentBlock[0]);
		} else {
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public OPOIFSDocument(String name, InputStream stream) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, stream);
	}

	
	public OPOIFSDocument(String name, int size, POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, POIFSWriterListener writer) {
		_size = size;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(_bigBigBlockSize, path, name, size, writer);
			_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		} else {
			_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
			_big_store = new BigBlockStore(_bigBigBlockSize, path, name, size, writer);
		}
	}
	public OPOIFSDocument(String name, int size, POIFSDocumentPath path, POIFSWriterListener writer) {
	   this(name, size, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, path, writer);
	}

	
	public BlockWritable[] getSmallBlocks() {
		return _small_store.getBlocks();
	}

	
	public int getSize() {
		return _size;
	}

	
	void read(byte[] buffer, int offset) {
		int len = buffer.length;

		DataInputBlock currentBlock = getDataInputBlock(offset);

		int blockAvailable = currentBlock.available();
		if (blockAvailable > len) {
			currentBlock.readFully(buffer, 0, len);
			return;
		}
		
		int remaining = len;
		int writePos = 0;
		int currentOffset = offset;
		while (remaining > 0) {
			boolean blockIsExpiring = remaining >= blockAvailable;
			int reqSize;
			if (blockIsExpiring) {
				reqSize = blockAvailable;
			} else {
				reqSize = remaining;
			}
			currentBlock.readFully(buffer, writePos, reqSize);
			remaining-=reqSize;
			writePos+=reqSize;
			currentOffset += reqSize;
			if (blockIsExpiring) {
				if (currentOffset == _size) {
					if (remaining > 0) {
						throw new IllegalStateException("reached end of document stream unexpectedly");
					}
					currentBlock = null;
					break;
				}
				currentBlock = getDataInputBlock(currentOffset);
				blockAvailable = currentBlock.available();
			}
		}
	}

	
	DataInputBlock getDataInputBlock(int offset) {
		if (offset >= _size) {
			if (offset > _size) {
				throw new RuntimeException("Request for Offset " + offset + " doc size is " + _size);
			}
			return null;
		}
		if (_property.shouldUseSmallBlocks()) {
			return SmallDocumentBlock.getDataInputBlock(_small_store.getBlocks(), offset);
		}
		return DocumentBlock.getDataInputBlock(_big_store.getBlocks(), offset);
	}

	

	DocumentProperty getDocumentProperty() {
		return _property;
	}

	

	
	public void writeBlocks(OutputStream stream) throws IOException {
		_big_store.writeBlocks(stream);
	}

	
	

	
	public int countBlocks() {
		return _big_store.countBlocks();
	}

	
	public void setStartBlock(int index) {
		_property.setStartBlock(index);
	}

	
	

	
	public Object[] getViewableArray() {
		Object[] results = new Object[1];
		String result;

		try {
			ByteArrayOutputStream output = new ByteArrayOutputStream();
			BlockWritable[] blocks = null;

			if (_big_store.isValid()) {
				blocks = _big_store.getBlocks();
			} else if (_small_store.isValid()) {
				blocks = _small_store.getBlocks();
			}
			if (blocks != null) {
				for (int k = 0; k < blocks.length; k++) {
					blocks[k].writeBlocks(output);
				}
				byte[] data = output.toByteArray();

				if (data.length > _property.getSize()) {
					byte[] tmp = new byte[_property.getSize()];

					System.arraycopy(data, 0, tmp, 0, tmp.length);
					data = tmp;
				}
				output = new ByteArrayOutputStream();
				HexDump.dump(data, 0, output, 0);
				result = output.toString();
			} else {
				result = "<NO DATA>";
			}
		} catch (IOException e) {
			result = e.getMessage();
		}
		results[0] = result;
		return results;
	}

	
	public Iterator<Object> getViewableIterator() {
		return Collections.emptyList().iterator();
	}

	
	public boolean preferArray() {
		return true;
	}

	
	public String getShortDescription() {
		StringBuffer buffer = new StringBuffer();

		buffer.append("Document: \"").append(_property.getName()).append("\"");
		buffer.append(" size = ").append(getSize());
		return buffer.toString();
	}

	
	private static final class SmallBlockStore {
		private SmallDocumentBlock[] _smallBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
		private final POIFSBigBlockSize _bigBlockSize;

		
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, SmallDocumentBlock[] blocks) {
		   _bigBlockSize = bigBlockSize;
			_smallBlocks = blocks.clone();
			this._path = null;
			this._name = null;
			this._size = -1;
			this._writer = null;
		}

		
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		                String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			_smallBlocks = new SmallDocumentBlock[0];
			this._path = path;
			this._name = name;
			this._size = size;
			this._writer = writer;
		}

		
		boolean isValid() {
			return _smallBlocks.length > 0 || _writer != null;
		}

		
		SmallDocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				_smallBlocks = SmallDocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return _smallBlocks;
		}
	} 

	private static final class BigBlockStore {
		private DocumentBlock[] bigBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
      private final POIFSBigBlockSize _bigBlockSize;

		
		BigBlockStore(POIFSBigBlockSize bigBlockSize, DocumentBlock[] blocks) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = blocks.clone();
			_path = null;
			_name = null;
			_size = -1;
			_writer = null;
		}

		
		BigBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		              String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = new DocumentBlock[0];
			_path = path;
			_name = name;
			_size = size;
			_writer = writer;
		}

		
		boolean isValid() {
			return bigBlocks.length > 0 || _writer != null;
		}

		
		DocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				bigBlocks = DocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return bigBlocks;
		}

		
		void writeBlocks(OutputStream stream) throws IOException {
			if (isValid()) {
				if (_writer != null) {
					DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

					_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
					dstream.writeFiller(countBlocks() * _bigBlockSize.getBigBlockSize(),
							DocumentBlock.getFillByte());
				} else {
					for (int k = 0; k < bigBlocks.length; k++) {
						bigBlocks[k].writeBlocks(stream);
					}
				}
			}
		}

		
		int countBlocks() {

			if (isValid()) {
				if (_writer == null) {
					return bigBlocks.length;
				}
				return (_size + _bigBlockSize.getBigBlockSize() - 1)
							/ _bigBlockSize.getBigBlockSize();
			}
			return 0;
		}
	} 
}

<code block>




package org.apache.poi.poifs.filesystem;

import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.EmptyFileException;
import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.nio.ByteArrayBackedDataSource;
import org.apache.poi.poifs.nio.DataSource;
import org.apache.poi.poifs.nio.FileBackedDataSource;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.NPropertyTable;
import org.apache.poi.poifs.storage.BATBlock;
import org.apache.poi.poifs.storage.BATBlock.BATBlockAndIndex;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.HeaderBlockConstants;
import org.apache.poi.poifs.storage.HeaderBlockWriter;
import org.apache.poi.util.CloseIgnoringInputStream;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.LongField;



public class NPOIFSFileSystem extends BlockStore
    implements POIFSViewable, Closeable
{



    
    public static InputStream createNonClosingInputStream(InputStream is) {
       return new CloseIgnoringInputStream(is);
    }
   
    private NPOIFSMiniStore _mini_store;
    private NPropertyTable  _property_table;
    private List<BATBlock>  _xbat_blocks;
    private List<BATBlock>  _bat_blocks;
    private HeaderBlock     _header;
    private DirectoryNode   _root;
    
    private DataSource _data;
    
    
    private POIFSBigBlockSize bigBlockSize = 
       POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;

    private NPOIFSFileSystem(boolean newFS)
    {
        _header         = new HeaderBlock(bigBlockSize);
        _property_table = new NPropertyTable(_header);
        _mini_store     = new NPOIFSMiniStore(this, _property_table.getRoot(), new ArrayList<BATBlock>(), _header);
        _xbat_blocks    = new ArrayList<BATBlock>();
        _bat_blocks     = new ArrayList<BATBlock>();
        _root           = null;
        
        if(newFS) {
           
           
           _data        = new ByteArrayBackedDataSource(new byte[bigBlockSize.getBigBlockSize()*3]);
        }
    }
    
    
    public NPOIFSFileSystem()
    {
       this(true);
       
        
        _header.setBATCount(1);
        _header.setBATArray(new int[] { 0 });
        BATBlock bb = BATBlock.createEmptyBATBlock(bigBlockSize, false);
        bb.setOurBlockIndex(0);
        _bat_blocks.add(bb);

        setNextBlock(0, POIFSConstants.FAT_SECTOR_BLOCK);
        setNextBlock(1, POIFSConstants.END_OF_CHAIN);

        _property_table.setStartBlock(POIFSConstants.END_OF_CHAIN);
    }

    
    public NPOIFSFileSystem(File file)
         throws IOException
    {
       this(file, true);
    }
    
    
    public NPOIFSFileSystem(File file, boolean readOnly)
         throws IOException
    {
       this(null, file, readOnly, true);
    }
    
    
    public NPOIFSFileSystem(FileChannel channel)
         throws IOException
    {
       this(channel, true);
    }
    
    
    public NPOIFSFileSystem(FileChannel channel, boolean readOnly)
         throws IOException
    {
       this(channel, null, readOnly, false);
    }
    
    private NPOIFSFileSystem(FileChannel channel, File srcFile, boolean readOnly, boolean closeChannelOnError)
         throws IOException
    {
       this(false);

       try {
          
          if (srcFile != null) {
              if (srcFile.length() == 0)
                  throw new EmptyFileException();
              
              FileBackedDataSource d = new FileBackedDataSource(srcFile, readOnly);
              channel = d.getChannel();
              _data = d;
          } else {
              _data = new FileBackedDataSource(channel, readOnly);
          }
           
          
          ByteBuffer headerBuffer = ByteBuffer.allocate(POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
          IOUtils.readFully(channel, headerBuffer);
          
          
          _header = new HeaderBlock(headerBuffer);
          
          
          readCoreContents();
       } catch(IOException e) {
          if(closeChannelOnError) {
             channel.close();
          }
          throw e;
       } catch(RuntimeException e) {
          
          
          
          if(closeChannelOnError) {
              if (channel != null) {
                  channel.close();
                  channel = null;
              }
          }
          throw e;
       }
    }
    
    

    public NPOIFSFileSystem(InputStream stream)
        throws IOException
    {
        this(false);
        
        ReadableByteChannel channel = null;
        boolean success = false;
        
        try {
           
           channel = Channels.newChannel(stream);
           
           
           ByteBuffer headerBuffer = ByteBuffer.allocate(POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
           IOUtils.readFully(channel, headerBuffer);
           
           
           _header = new HeaderBlock(headerBuffer);
           
           
           BlockAllocationTableReader.sanityCheckBlockCount(_header.getBATCount());
   
           
           
           
           long maxSize = BATBlock.calculateMaximumSize(_header); 
           if (maxSize > Integer.MAX_VALUE) {
               throw new IllegalArgumentException("Unable read a >2gb file via an InputStream");
           }
           ByteBuffer data = ByteBuffer.allocate((int)maxSize);
           
           
           headerBuffer.position(0);
           data.put(headerBuffer);
           data.position(headerBuffer.capacity());
           
           
           IOUtils.readFully(channel, data);
           success = true;
           
           
           _data = new ByteArrayBackedDataSource(data.array(), data.position());
        } finally {
           
           if(channel != null)
              channel.close();
           closeInputStream(stream, success);
        }
        
        
        readCoreContents();
    }
    
    private void closeInputStream(InputStream stream, boolean success) {
        try {
            stream.close();
        } catch (IOException e) {
            if(success) {
                throw new RuntimeException(e);
            }
            
            
            e.printStackTrace();
        }
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        
        inp.mark(8);

        byte[] header = new byte[8];
        IOUtils.readFully(inp, header);
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header);

        
        if(inp instanceof PushbackInputStream) {
            PushbackInputStream pin = (PushbackInputStream)inp;
            pin.unread(header);
        } else {
            inp.reset();
        }

        
        return (signature.get() == HeaderBlockConstants._signature);
    }
    
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header8Bytes);
        return (signature.get() == HeaderBlockConstants._signature);
    }
    
    
    private void readCoreContents() throws IOException {
       
       bigBlockSize = _header.getBigBlockSize();
       
       
       
       ChainLoopDetector loopDetector = getChainLoopDetector();
       
       
       for(int fatAt : _header.getBATArray()) {
          readBAT(fatAt, loopDetector);
       }
       
       
       int remainingFATs = _header.getBATCount() - _header.getBATArray().length;
       
       
       BATBlock xfat; 
       int nextAt = _header.getXBATIndex();
       for(int i=0; i<_header.getXBATCount(); i++) {
          loopDetector.claim(nextAt);
          ByteBuffer fatData = getBlockAt(nextAt);
          xfat = BATBlock.createBATBlock(bigBlockSize, fatData);
          xfat.setOurBlockIndex(nextAt);
          nextAt = xfat.getValueAt(bigBlockSize.getXBATEntriesPerBlock());
          _xbat_blocks.add(xfat);
          
          
          int xbatFATs = Math.min(remainingFATs, bigBlockSize.getXBATEntriesPerBlock());
          for(int j=0; j<xbatFATs; j++) {
             int fatAt = xfat.getValueAt(j);
             if(fatAt == POIFSConstants.UNUSED_BLOCK || fatAt == POIFSConstants.END_OF_CHAIN) break;
             readBAT(fatAt, loopDetector);
          }
          remainingFATs -= xbatFATs;
       }
       
       
       
       _property_table = new NPropertyTable(_header, this);
       
       
       BATBlock sfat;
       List<BATBlock> sbats = new ArrayList<BATBlock>();
       _mini_store     = new NPOIFSMiniStore(this, _property_table.getRoot(), sbats, _header);
       nextAt = _header.getSBATStart();
       for(int i=0; i<_header.getSBATCount() && nextAt != POIFSConstants.END_OF_CHAIN; i++) {
          loopDetector.claim(nextAt);
          ByteBuffer fatData = getBlockAt(nextAt);
          sfat = BATBlock.createBATBlock(bigBlockSize, fatData);
          sfat.setOurBlockIndex(nextAt);
          sbats.add(sfat);
          nextAt = getNextBlock(nextAt);  
       }
    }
    private void readBAT(int batAt, ChainLoopDetector loopDetector) throws IOException {
       loopDetector.claim(batAt);
       ByteBuffer fatData = getBlockAt(batAt);
       BATBlock bat = BATBlock.createBATBlock(bigBlockSize, fatData);
       bat.setOurBlockIndex(batAt);
       _bat_blocks.add(bat);
    }
    private BATBlock createBAT(int offset, boolean isBAT) throws IOException {
       
       BATBlock newBAT = BATBlock.createEmptyBATBlock(bigBlockSize, !isBAT);
       newBAT.setOurBlockIndex(offset);
       
       ByteBuffer buffer = ByteBuffer.allocate(bigBlockSize.getBigBlockSize());
       int writeTo = (1+offset) * bigBlockSize.getBigBlockSize(); 
       _data.write(buffer, writeTo);
       
       return newBAT;
    }
    
    
    @Override
    protected ByteBuffer getBlockAt(final int offset) throws IOException {
       
       long blockWanted = offset + 1;
       long startAt = blockWanted * bigBlockSize.getBigBlockSize();
       try {
           return _data.read(bigBlockSize.getBigBlockSize(), startAt);
       } catch (IndexOutOfBoundsException e) {
           throw new IndexOutOfBoundsException("Block " + offset + " not found - " + e);
       }
    }
    
    
    @Override
    protected ByteBuffer createBlockIfNeeded(final int offset) throws IOException {
       try {
          return getBlockAt(offset);
       } catch(IndexOutOfBoundsException e) {
          
          long startAt = (offset+1) * bigBlockSize.getBigBlockSize();
          
          ByteBuffer buffer = ByteBuffer.allocate(getBigBlockSize());
          _data.write(buffer, startAt);
          
          return getBlockAt(offset);
       }
    }
    
    
    @Override
    protected BATBlockAndIndex getBATBlockAndIndex(final int offset) {
       return BATBlock.getBATBlockAndIndex(
             offset, _header, _bat_blocks
       );
    }
    
    
    @Override
    protected int getNextBlock(final int offset) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       return bai.getBlock().getValueAt( bai.getIndex() );
    }
    
    
    @Override
    protected void setNextBlock(final int offset, final int nextBlock) {
       BATBlockAndIndex bai = getBATBlockAndIndex(offset);
       bai.getBlock().setValueAt(
             bai.getIndex(), nextBlock
       );
    }
    
    
    @Override
    protected int getFreeBlock() throws IOException {
        int numSectors = bigBlockSize.getBATEntriesPerBlock();

       
       int offset = 0;
       for (BATBlock bat : _bat_blocks) {
          if(bat.hasFreeSectors()) {
             
             for(int j=0; j<numSectors; j++) {
                int batValue = bat.getValueAt(j);
                if(batValue == POIFSConstants.UNUSED_BLOCK) {
                   
                   return offset + j;
                }
             }
          }
          
          
          offset += numSectors;
       }
       
       
       
       BATBlock bat = createBAT(offset, true);
       bat.setValueAt(0, POIFSConstants.FAT_SECTOR_BLOCK);
       _bat_blocks.add(bat);
       
       
       if(_header.getBATCount() >= 109) {
          
          BATBlock xbat = null;
          for(BATBlock x : _xbat_blocks) {
             if(x.hasFreeSectors()) {
                xbat = x;
                break;
             }
          }
          if(xbat == null) {
             
             xbat = createBAT(offset+1, false);
             
             xbat.setValueAt(0, offset);
             
             bat.setValueAt(1, POIFSConstants.DIFAT_SECTOR_BLOCK);
             
             
             offset++;
             
             
             if(_xbat_blocks.size() == 0) {
                _header.setXBATStart(offset);
             } else {
                _xbat_blocks.get(_xbat_blocks.size()-1).setValueAt(
                      bigBlockSize.getXBATEntriesPerBlock(), offset
                );
             }
             _xbat_blocks.add(xbat);
             _header.setXBATCount(_xbat_blocks.size());
          } else {
              
              for(int i=0; i<bigBlockSize.getXBATEntriesPerBlock(); i++) {
                 if(xbat.getValueAt(i) == POIFSConstants.UNUSED_BLOCK) {
                    xbat.setValueAt(i, offset);
                    break;
                 }
              }
          }
       } else {
          
          int[] newBATs = new int[_header.getBATCount()+1];
          System.arraycopy(_header.getBATArray(), 0, newBATs, 0, newBATs.length-1);
          newBATs[newBATs.length-1] = offset;
          _header.setBATArray(newBATs);
       }
       _header.setBATCount(_bat_blocks.size());
       
       
       return offset+1;
    }
    
    protected long size() throws IOException {
        return _data.size();
    }
    
    @Override
    protected ChainLoopDetector getChainLoopDetector() throws IOException {
      return new ChainLoopDetector(_data.size());
    }

   
    NPropertyTable _get_property_table() {
      return _property_table;
    }
    
    
    public NPOIFSMiniStore getMiniStore() {
       return _mini_store;
    }

    
    void addDocument(final NPOIFSDocument document)
    {
        _property_table.addProperty(document.getDocumentProperty());
    }

    
    void addDirectory(final DirectoryProperty directory)
    {
        _property_table.addProperty(directory);
    }

   

    public DocumentEntry createDocument(final InputStream stream,
                                        final String name)
        throws IOException
    {
        return getRoot().createDocument(name, stream);
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return getRoot().createDocument(name, size, writer);
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        return getRoot().createDirectory(name);
    }
    
    
    public void writeFilesystem() throws IOException
    {
       if(_data instanceof FileBackedDataSource) {
          
       } else {
          throw new IllegalArgumentException(
                "POIFS opened from an inputstream, so writeFilesystem() may " +
                "not be called. Use writeFilesystem(OutputStream) instead"
          );
       }
       if (! ((FileBackedDataSource)_data).isWriteable()) {
           throw new IllegalArgumentException(
                "POIFS opened in read only mode, so writeFilesystem() may " +
                "not be called. Open the FileSystem in read-write mode first"
           );
       }
       syncWithDataSource();
    }

    

    public void writeFilesystem(final OutputStream stream)
        throws IOException
    {
       
       syncWithDataSource();
       
       
       _data.copyTo(stream);
    }
    
    
    private void syncWithDataSource() throws IOException {
        
        NPOIFSStream propStream = new NPOIFSStream(this, _header.getPropertyStart());
        _property_table.preWrite();
        _property_table.write(propStream);
        
        
       
       HeaderBlockWriter hbw = new HeaderBlockWriter(_header);
       hbw.writeBlock( getBlockAt(-1) );
       
       
       for(BATBlock bat : _bat_blocks) {
          ByteBuffer block = getBlockAt(bat.getOurBlockIndex());
          BlockAllocationTableWriter.writeBlock(bat, block);
       }
       
       for(BATBlock bat : _xbat_blocks) {
           ByteBuffer block = getBlockAt(bat.getOurBlockIndex());
           BlockAllocationTableWriter.writeBlock(bat, block);
        }
       
       
       _mini_store.syncWithDataSource();
    }
    
    
    public void close() throws IOException {
       _data.close();
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length != 2)
        {
            System.err.println(
                "two arguments required: input filename and output filename");
            System.exit(1);
        }
        FileInputStream  istream = new FileInputStream(args[ 0 ]);
        try {
            FileOutputStream ostream = new FileOutputStream(args[ 1 ]);
            try {
                NPOIFSFileSystem fs = new NPOIFSFileSystem(istream);
                try {
                    fs.writeFilesystem(ostream);
                } finally {
                    fs.close();
                }
            } finally {
                ostream.close();
            }
        } finally {
            istream.close();
        }
    }

    
    public DirectoryNode getRoot()
    {
        if (_root == null) {
           _root = new DirectoryNode(_property_table.getRoot(), this, null);
        }
        return _root;
    }

    

    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
    	return getRoot().createDocumentInputStream(documentName);
    }

    
    void remove(EntryNode entry) throws IOException
    {
        
        if (entry instanceof DocumentEntry) {
            NPOIFSDocument doc = new NPOIFSDocument((DocumentProperty)entry.getProperty(), this);
            doc.free();
        }
        
        
        _property_table.removeProperty(entry.getProperty());
    }
    
    

    

    public Object [] getViewableArray()
    {
        if (preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableArray();
        }
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        if (!preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableIterator();
        }
        return Collections.emptyList().iterator();
    }

    

    public boolean preferArray()
    {
        return (( POIFSViewable ) getRoot()).preferArray();
    }

    

    public String getShortDescription()
    {
        return "POIFS FileSystem";
    }

    

    
    public int getBigBlockSize() {
      return bigBlockSize.getBigBlockSize();
    }

    
    public POIFSBigBlockSize getBigBlockSizeDetails() {
      return bigBlockSize;
    }

    @Override
    protected int getBlockStoreBlockSize() {
       return getBigBlockSize();
    }
}


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.IOException;

import org.apache.poi.poifs.storage.DataInputBlock;


public final class ODocumentInputStream extends DocumentInputStream {
	
	private int _current_offset;

	
	private int _marked_offset;

	
	private int _document_size;

	
	private boolean _closed;

	
	private OPOIFSDocument _document;

	
	private DataInputBlock _currentBlock;

	
	public ODocumentInputStream(DocumentEntry document) throws IOException {
		if (!(document instanceof DocumentNode)) {
			throw new IOException("Cannot open internal document storage");
		}
		DocumentNode documentNode = (DocumentNode)document;
		if (documentNode.getDocument() == null) {
         throw new IOException("Cannot open internal document storage");
		}
		      
		_current_offset = 0;
		_marked_offset = 0;
		_document_size = document.getSize();
		_closed = false;
		_document = documentNode.getDocument();
		_currentBlock = getDataInputBlock(0);
	}

	
	public ODocumentInputStream(OPOIFSDocument document) {
		_current_offset = 0;
		_marked_offset = 0;
		_document_size = document.getSize();
		_closed = false;
		_document = document;
		_currentBlock = getDataInputBlock(0);
	}

	@Override
	public int available() {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		return _document_size - _current_offset;
	}

   @Override
	public void close() {
		_closed = true;
	}

   @Override
	public void mark(int ignoredReadlimit) {
		_marked_offset = _current_offset;
	}

	private DataInputBlock getDataInputBlock(int offset) {
		return _document.getDataInputBlock(offset);
	}

   @Override
	public int read() throws IOException {
		dieIfClosed();
		if (atEOD()) {
			return EOF;
		}
		int result = _currentBlock.readUByte();
		_current_offset++;
		if (_currentBlock.available() < 1) {
			_currentBlock = getDataInputBlock(_current_offset);
		}
		return result;
	}

   @Override
	public int read(byte[] b, int off, int len) throws IOException {
		dieIfClosed();
		if (b == null) {
			throw new IllegalArgumentException("buffer must not be null");
		}
		if (off < 0 || len < 0 || b.length < off + len) {
			throw new IndexOutOfBoundsException("can't read past buffer boundaries");
		}
		if (len == 0) {
			return 0;
		}
		if (atEOD()) {
			return EOF;
		}
		int limit = Math.min(available(), len);
		readFully(b, off, limit);
		return limit;
	}

	
   @Override
	public void reset() {
		_current_offset = _marked_offset;
		_currentBlock = getDataInputBlock(_current_offset);
	}

   @Override
	public long skip(long n) throws IOException {
		dieIfClosed();
		if (n < 0) {
			return 0;
		}
		int new_offset = _current_offset + (int) n;

		if (new_offset < _current_offset) {

			
			new_offset = _document_size;
		} else if (new_offset > _document_size) {
			new_offset = _document_size;
		}
		long rval = new_offset - _current_offset;

		_current_offset = new_offset;
		_currentBlock = getDataInputBlock(_current_offset);
		return rval;
	}

	private void dieIfClosed() throws IOException {
		if (_closed) {
			throw new IOException("cannot perform requested operation on a closed stream");
		}
	}

	private boolean atEOD() {
		return _current_offset == _document_size;
	}

	private void checkAvaliable(int requestedSize) {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		if (requestedSize > _document_size - _current_offset) {
			throw new RuntimeException("Buffer underrun - requested " + requestedSize
					+ " bytes but " + (_document_size - _current_offset) + " was available");
		}
	}

   @Override
	public byte readByte() {
		return (byte) readUByte();
	}

   @Override
	public double readDouble() {
		return Double.longBitsToDouble(readLong());
	}

   @Override
	public short readShort() {
		return (short) readUShort();
	}

   @Override
	public void readFully(byte[] buf, int off, int len) {
		checkAvaliable(len);
		int blockAvailable = _currentBlock.available();
		if (blockAvailable > len) {
			_currentBlock.readFully(buf, off, len);
			_current_offset += len;
			return;
		}
		
		int remaining = len;
		int writePos = off;
		while (remaining > 0) {
			boolean blockIsExpiring = remaining >= blockAvailable;
			int reqSize;
			if (blockIsExpiring) {
				reqSize = blockAvailable;
			} else {
				reqSize = remaining;
			}
			_currentBlock.readFully(buf, writePos, reqSize);
			remaining -= reqSize;
			writePos += reqSize;
			_current_offset += reqSize;
			if (blockIsExpiring) {
				if (_current_offset == _document_size) {
					if (remaining > 0) {
						throw new IllegalStateException(
								"reached end of document stream unexpectedly");
					}
					_currentBlock = null;
					break;
				}
				_currentBlock = getDataInputBlock(_current_offset);
				blockAvailable = _currentBlock.available();
			}
		}
	}

   @Override
	public long readLong() {
		checkAvaliable(SIZE_LONG);
		int blockAvailable = _currentBlock.available();
		long result;
		if (blockAvailable > SIZE_LONG) {
			result = _currentBlock.readLongLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_LONG) {
				result = _currentBlock.readLongLE();
			} else {
				result = nextBlock.readLongLE(_currentBlock, blockAvailable);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_LONG;
		return result;
	}

   @Override
	public int readInt() {
		checkAvaliable(SIZE_INT);
		int blockAvailable = _currentBlock.available();
		int result;
		if (blockAvailable > SIZE_INT) {
			result = _currentBlock.readIntLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_INT) {
				result = _currentBlock.readIntLE();
			} else {
				result = nextBlock.readIntLE(_currentBlock, blockAvailable);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_INT;
		return result;
	}

   @Override
	public int readUShort() {
		checkAvaliable(SIZE_SHORT);
		int blockAvailable = _currentBlock.available();
		int result;
		if (blockAvailable > SIZE_SHORT) {
			result = _currentBlock.readUShortLE();
		} else {
			DataInputBlock nextBlock = getDataInputBlock(_current_offset + blockAvailable);
			if (blockAvailable == SIZE_SHORT) {
				result = _currentBlock.readUShortLE();
			} else {
				result = nextBlock.readUShortLE(_currentBlock);
			}
			_currentBlock = nextBlock;
		}
		_current_offset += SIZE_SHORT;
		return result;
	}

   @Override
	public int readUByte() {
		checkAvaliable(1);
		int result = _currentBlock.readUByte();
		_current_offset++;
		if (_currentBlock.available() < 1) {
			_currentBlock = getDataInputBlock(_current_offset);
		}
		return result;
	}
}

<code block>


package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.util.LittleEndianInput;


public class DocumentInputStream extends InputStream implements LittleEndianInput {
	
	protected static final int EOF = -1;

	protected static final int SIZE_SHORT = 2;
	protected static final int SIZE_INT = 4;
	protected static final int SIZE_LONG = 8;
	
	private DocumentInputStream delegate;
	
	
	protected DocumentInputStream() {}

	
	public DocumentInputStream(DocumentEntry document) throws IOException {
	   if (!(document instanceof DocumentNode)) {
	      throw new IOException("Cannot open internal document storage");
	   }
	   DocumentNode documentNode = (DocumentNode)document;
	   DirectoryNode parentNode = (DirectoryNode)document.getParent();

	   if(documentNode.getDocument() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getOFileSystem() != null) {
	      delegate = new ODocumentInputStream(document);
	   } else if(parentNode.getNFileSystem() != null) {
	      delegate = new NDocumentInputStream(document);
	   } else {
	      throw new IOException("No FileSystem bound on the parent, can't read contents");
	   }
	}

	
	public DocumentInputStream(OPOIFSDocument document) {
	   delegate = new ODocumentInputStream(document);
	}

   
   public DocumentInputStream(NPOIFSDocument document) {
      delegate = new NDocumentInputStream(document);
   }

	public int available() {
	   return delegate.available();
	}

	public void close() {
	   delegate.close();
	}

	public void mark(int ignoredReadlimit) {
		delegate.mark(ignoredReadlimit);
	}

	
	public boolean markSupported() {
		return true;
	}

	public int read() throws IOException {
	   return delegate.read();
	}

	public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}

	public int read(byte[] b, int off, int len) throws IOException {
	   return delegate.read(b, off, len);
	}

	
	public void reset() {
	   delegate.reset();
	}

	public long skip(long n) throws IOException {
	   return delegate.skip(n);
	}

	public byte readByte() {
	   return delegate.readByte();
	}

	public double readDouble() {
	   return delegate.readDouble();
	}

	public short readShort() {
		return (short) readUShort();
	}

   public void readFully(byte[] buf) {
      readFully(buf, 0, buf.length);
   }

	public void readFully(byte[] buf, int off, int len) {
	   delegate.readFully(buf, off, len);
	}

	public long readLong() {
	   return delegate.readLong();
	}

	public int readInt() {
	   return delegate.readInt();
	}

	public int readUShort() {
	   return delegate.readUShort();
	}

	public int readUByte() {
	   return delegate.readUByte();
	}
	
    public long readUInt() {
        int i = readInt();
        return i & 0xFFFFFFFFL;
    }
}

<code block>




package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Iterator;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BlockStore.ChainLoopDetector;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.storage.HeaderBlock;



public class NPOIFSStream implements Iterable<ByteBuffer>
{
	private BlockStore blockStore;
	private int startBlock;
	private OutputStream outStream;
	
	
	public NPOIFSStream(BlockStore blockStore, int startBlock) {
	   this.blockStore = blockStore;
	   this.startBlock = startBlock;
	}
	
	
	public NPOIFSStream(BlockStore blockStore) {
      this.blockStore = blockStore;
	   this.startBlock = POIFSConstants.END_OF_CHAIN;
	}
	
	
	public int getStartBlock() {
	   return startBlock;
	}

	
   public Iterator<ByteBuffer> iterator() {
      return getBlockIterator();
   }
	
   public Iterator<ByteBuffer> getBlockIterator() {
      if(startBlock == POIFSConstants.END_OF_CHAIN) {
         throw new IllegalStateException(
               "Can't read from a new stream before it has been written to"
         );
      }
      return new StreamBlockByteBufferIterator(startBlock);
   }

   
   public void updateContents(byte[] contents) throws IOException {
       OutputStream os = getOutputStream();
       os.write(contents);
       os.close();
   }

   public OutputStream getOutputStream() throws IOException {
       if (outStream == null) {
           outStream = new StreamBlockByteBuffer();
       }
       return outStream;
   }
   
   
   
   
   
   
   public void free() throws IOException {
      ChainLoopDetector loopDetector = blockStore.getChainLoopDetector();
      free(loopDetector);
   }
   private void free(ChainLoopDetector loopDetector) {
      int nextBlock = startBlock;
      while(nextBlock != POIFSConstants.END_OF_CHAIN) {
         int thisBlock = nextBlock;
         loopDetector.claim(thisBlock);
         nextBlock = blockStore.getNextBlock(thisBlock);
         blockStore.setNextBlock(thisBlock, POIFSConstants.UNUSED_BLOCK);
      }
      this.startBlock = POIFSConstants.END_OF_CHAIN;
   }
   
   
   protected class StreamBlockByteBufferIterator implements Iterator<ByteBuffer> {
      private ChainLoopDetector loopDetector;
      private int nextBlock;
      
      protected StreamBlockByteBufferIterator(int firstBlock) {
         this.nextBlock = firstBlock;
         try {
            this.loopDetector = blockStore.getChainLoopDetector();
         } catch(IOException e) {
            throw new RuntimeException(e);
         }
      }

      public boolean hasNext() {
         if(nextBlock == POIFSConstants.END_OF_CHAIN) {
            return false;
         }
         return true;
      }

      public ByteBuffer next() {
         if(nextBlock == POIFSConstants.END_OF_CHAIN) {
            throw new IndexOutOfBoundsException("Can't read past the end of the stream");
         }
         
         try {
            loopDetector.claim(nextBlock);
            ByteBuffer data = blockStore.getBlockAt(nextBlock);
            nextBlock = blockStore.getNextBlock(nextBlock);
            return data;
         } catch(IOException e) {
            throw new RuntimeException(e);
         }
      }

      public void remove() {
         throw new UnsupportedOperationException();
      }
   }
   
   protected class StreamBlockByteBuffer extends OutputStream {
       byte oneByte[] = new byte[1];
       ByteBuffer buffer;
       
       
       ChainLoopDetector loopDetector;
       int prevBlock, nextBlock;

       protected StreamBlockByteBuffer() throws IOException {
           loopDetector = blockStore.getChainLoopDetector();
           prevBlock = POIFSConstants.END_OF_CHAIN;
           nextBlock = startBlock;
       }

       protected void createBlockIfNeeded() throws IOException {
           if (buffer != null && buffer.hasRemaining()) return;
           
           int thisBlock = nextBlock;
           
           
           
           if(thisBlock == POIFSConstants.END_OF_CHAIN) {
              thisBlock = blockStore.getFreeBlock();
              loopDetector.claim(thisBlock);
              
              
              nextBlock = POIFSConstants.END_OF_CHAIN;
              
              
              if(prevBlock != POIFSConstants.END_OF_CHAIN) {
                 blockStore.setNextBlock(prevBlock, thisBlock);
              }
              blockStore.setNextBlock(thisBlock, POIFSConstants.END_OF_CHAIN);
              
              
              
              if(startBlock == POIFSConstants.END_OF_CHAIN) {
                 startBlock = thisBlock;
              }
           } else {
              loopDetector.claim(thisBlock);
              nextBlock = blockStore.getNextBlock(thisBlock);
           }

           buffer = blockStore.createBlockIfNeeded(thisBlock);
           
           
           prevBlock = thisBlock;
       }
       
       public void write(int b) throws IOException {
            oneByte[0] = (byte)(b & 0xFF);
            write(oneByte);
       }
    
        public void write(byte[] b, int off, int len) throws IOException {
            if ((off < 0) || (off > b.length) || (len < 0) ||
                    ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return;
            }

            do {
                createBlockIfNeeded();
                int writeBytes = Math.min(buffer.remaining(), len);
                buffer.put(b, off, writeBytes);
                off += writeBytes;
                len -= writeBytes;
            } while (len > 0);
        }
    
        public void close() throws IOException {
            
            NPOIFSStream toFree = new NPOIFSStream(blockStore, nextBlock);
            toFree.free(loopDetector);
            
            
            if (prevBlock != POIFSConstants.END_OF_CHAIN) {
                blockStore.setNextBlock(prevBlock, POIFSConstants.END_OF_CHAIN);
            }
        }
   }
}


<code block>

        
package org.apache.poi.poifs.filesystem;

import java.io.IOException;


public class NotOLE2FileException extends IOException {
	public NotOLE2FileException(String s) {
		super(s);
	}
}

<code block>

        
package org.apache.poi.poifs.filesystem;


public class OfficeXmlFileException extends IllegalArgumentException {
	public OfficeXmlFileException(String s) {
		super(s);
	}
}

<code block>


        

package org.apache.poi.poifs.filesystem;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;


public class DocumentNode
    extends EntryNode
    implements DocumentEntry, POIFSViewable
{

    
    private OPOIFSDocument _document;

    

    DocumentNode(final DocumentProperty property, final DirectoryNode parent)
    {
        super(property, parent);
        _document = property.getDocument();
    }

    
    OPOIFSDocument getDocument()
    {
        return _document;
    }

    

    

    public int getSize()
    {
        return getProperty().getSize();
    }

    
    

    

    @Override
    public boolean isDocumentEntry()
    {
        return true;
    }

    
    

    

    @Override
    protected boolean isDeleteOK()
    {
        return true;
    }

    
    

    

    public Object [] getViewableArray()
    {
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        List<Object> components = new ArrayList<Object>();

        components.add(getProperty());
        components.add(_document);
        return components.iterator();
    }

    

    public boolean preferArray()
    {
        return false;
    }

    

    public String getShortDescription()
    {
        return getName();
    }

    
}   


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;

import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.util.LittleEndian;


public final class NDocumentInputStream extends DocumentInputStream {
    
    private int _current_offset;
    
    private int _current_block_count;

    
    private int _marked_offset;
    
    private int _marked_offset_count;

    
    private int _document_size;

    
    private boolean _closed;

    
    private NPOIFSDocument _document;

    private Iterator<ByteBuffer> _data;
    private ByteBuffer _buffer;

    
    public NDocumentInputStream(DocumentEntry document) throws IOException {
        if (!(document instanceof DocumentNode)) {
            throw new IOException("Cannot open internal document storage, " + document + " not a Document Node");
        }
        _current_offset = 0;
        _current_block_count = 0;
        _marked_offset = 0;
        _marked_offset_count = 0;
        _document_size = document.getSize();
        _closed = false;

        DocumentNode doc = (DocumentNode)document;
        DocumentProperty property = (DocumentProperty)doc.getProperty();
        _document = new NPOIFSDocument(
                property, 
                ((DirectoryNode)doc.getParent()).getNFileSystem()
        );
        _data = _document.getBlockIterator();
    }

    
    public NDocumentInputStream(NPOIFSDocument document) {
        _current_offset = 0;
        _current_block_count = 0;
        _marked_offset = 0;
        _marked_offset_count = 0;
        _document_size = document.getSize();
        _closed = false;
        _document = document;
        _data = _document.getBlockIterator();
    }

    @Override
    public int available() {
        if (_closed) {
            throw new IllegalStateException("cannot perform requested operation on a closed stream");
        }
        return _document_size - _current_offset;
    }

    @Override
    public void close() {
        _closed = true;
    }

    @Override
    public void mark(int ignoredReadlimit) {
        _marked_offset = _current_offset;
        _marked_offset_count = Math.max(0, _current_block_count - 1);
    }

    @Override
    public int read() throws IOException {
        dieIfClosed();
        if (atEOD()) {
            return EOF;
        }
        byte[] b = new byte[1];
        int result = read(b, 0, 1);
        if(result >= 0) {
            if(b[0] < 0) {
                return b[0]+256;
            }
            return b[0];
        }
        return result;
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        dieIfClosed();
        if (b == null) {
            throw new IllegalArgumentException("buffer must not be null");
        }
        if (off < 0 || len < 0 || b.length < off + len) {
            throw new IndexOutOfBoundsException("can't read past buffer boundaries");
        }
        if (len == 0) {
            return 0;
        }
        if (atEOD()) {
            return EOF;
        }
        int limit = Math.min(available(), len);
        readFully(b, off, limit);
        return limit;
    }

    
    @Override
    public void reset() {
        
        if(_marked_offset == 0 && _marked_offset_count == 0) {
            _current_block_count = _marked_offset_count;
            _current_offset = _marked_offset;
            _data = _document.getBlockIterator();
            _buffer = null;
            return;
        }

        
        _data = _document.getBlockIterator();
        _current_offset = 0;
		for(int i=0; i<_marked_offset_count; i++) {
		   _buffer = _data.next();
		   _current_offset += _buffer.remaining();
		}
		
      _current_block_count = _marked_offset_count;
      
      
      if(_current_offset != _marked_offset) {
   		
         _buffer = _data.next();
         _current_block_count++;
         
   		
         
         
         int skipBy = _marked_offset - _current_offset;
   		_buffer.position(_buffer.position() + skipBy);
      }

      
      _current_offset = _marked_offset;
	}

   @Override
	public long skip(long n) throws IOException {
		dieIfClosed();
		if (n < 0) {
			return 0;
		}
		int new_offset = _current_offset + (int) n;

		if (new_offset < _current_offset) {
			
			new_offset = _document_size;
		} else if (new_offset > _document_size) {
			new_offset = _document_size;
		}
		
		long rval = new_offset - _current_offset;
		
		
		byte[] skip = new byte[(int)rval];
		readFully(skip);
		return rval;
	}

	private void dieIfClosed() throws IOException {
		if (_closed) {
			throw new IOException("cannot perform requested operation on a closed stream");
		}
	}

	private boolean atEOD() {
		return _current_offset == _document_size;
	}

	private void checkAvaliable(int requestedSize) {
		if (_closed) {
			throw new IllegalStateException("cannot perform requested operation on a closed stream");
		}
		if (requestedSize > _document_size - _current_offset) {
			throw new RuntimeException("Buffer underrun - requested " + requestedSize
					+ " bytes but " + (_document_size - _current_offset) + " was available");
		}
	}

   @Override
	public void readFully(byte[] buf, int off, int len) {
		checkAvaliable(len);

		int read = 0;
		while(read < len) {
		   if(_buffer == null || _buffer.remaining() == 0) {
		      _current_block_count++;
		      _buffer = _data.next();
		   }
		   
		   int limit = Math.min(len-read, _buffer.remaining());
		   _buffer.get(buf, off+read, limit);
         _current_offset += limit;
		   read += limit;
		}
	}

   @Override
   public byte readByte() {
      return (byte) readUByte();
   }

   @Override
   public double readDouble() {
      return Double.longBitsToDouble(readLong());
   }

   @Override
	public long readLong() {
		checkAvaliable(SIZE_LONG);
		byte[] data = new byte[SIZE_LONG];
		readFully(data, 0, SIZE_LONG);
		return LittleEndian.getLong(data, 0);
	}

   @Override
   public short readShort() {
      checkAvaliable(SIZE_SHORT);
      byte[] data = new byte[SIZE_SHORT];
      readFully(data, 0, SIZE_SHORT);
      return LittleEndian.getShort(data);
   }

   @Override
	public int readInt() {
		checkAvaliable(SIZE_INT);
      byte[] data = new byte[SIZE_INT];
      readFully(data, 0, SIZE_INT);
      return LittleEndian.getInt(data);
	}

   @Override
	public int readUShort() {
		checkAvaliable(SIZE_SHORT);
      byte[] data = new byte[SIZE_SHORT];
      readFully(data, 0, SIZE_SHORT);
      return LittleEndian.getUShort(data);
	}

   @Override
	public int readUByte() {
		checkAvaliable(1);
      byte[] data = new byte[1];
      readFully(data, 0, 1);
      if(data[0] >= 0)
         return data[0];
      return data[0] + 256;
	}
}

<code block>

package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.poi.util.Internal;

@Internal
public class EntryUtils
{

    
    @Internal
    public static void copyNodeRecursively( Entry entry, DirectoryEntry target )
            throws IOException
    {
        
        
        DirectoryEntry newTarget = null;
        if ( entry.isDirectoryEntry() )
        {
        	DirectoryEntry dirEntry = (DirectoryEntry)entry;
            newTarget = target.createDirectory( entry.getName() );
            newTarget.setStorageClsid( dirEntry.getStorageClsid() );
            Iterator<Entry> entries = dirEntry.getEntries();

            while ( entries.hasNext() )
            {
                copyNodeRecursively( entries.next(), newTarget );
            }
        }
        else
        {
            DocumentEntry dentry = (DocumentEntry) entry;
            DocumentInputStream dstream = new DocumentInputStream( dentry );
            target.createDocument( dentry.getName(), dstream );
            dstream.close();
        }
    }

    
    public static void copyNodes(DirectoryEntry sourceRoot,
            DirectoryEntry targetRoot) throws IOException
    {
        for (Entry entry : sourceRoot) {
            copyNodeRecursively( entry, targetRoot );
        }
    }

    
    public static void copyNodes( FilteringDirectoryNode filteredSource,
            FilteringDirectoryNode filteredTarget ) throws IOException
    {
        
        
        copyNodes( (DirectoryEntry)filteredSource, (DirectoryEntry)filteredTarget );
    }

    
    public static void copyNodes( DirectoryEntry sourceRoot,
            DirectoryEntry targetRoot, List<String> excepts )
            throws IOException
    {
        Iterator<Entry> entries = sourceRoot.getEntries();
        while ( entries.hasNext() )
        {
            Entry entry = entries.next();
            if ( !excepts.contains( entry.getName() ) )
            {
                copyNodeRecursively( entry, targetRoot );
            }
        }
    }

    
    public static void copyNodes( OPOIFSFileSystem source,
            OPOIFSFileSystem target ) throws IOException
    {
        copyNodes( source.getRoot(), target.getRoot() );
    }
    
    public static void copyNodes( NPOIFSFileSystem source,
            NPOIFSFileSystem target ) throws IOException
    {
        copyNodes( source.getRoot(), target.getRoot() );
    }
    
    
    public static void copyNodes( OPOIFSFileSystem source,
            OPOIFSFileSystem target, List<String> excepts ) throws IOException
    {
        copyNodes(
              new FilteringDirectoryNode(source.getRoot(), excepts),
              new FilteringDirectoryNode(target.getRoot(), excepts)
        );
    }
    
    public static void copyNodes( NPOIFSFileSystem source,
            NPOIFSFileSystem target, List<String> excepts ) throws IOException
    {
        copyNodes(
              new FilteringDirectoryNode(source.getRoot(), excepts),
              new FilteringDirectoryNode(target.getRoot(), excepts)
        );
    }
    
    
    public static boolean areDirectoriesIdentical(DirectoryEntry dirA, DirectoryEntry dirB) {
       
       if (! dirA.getName().equals(dirB.getName())) {
          return false;
       }
       
       
       if (dirA.getEntryCount() != dirB.getEntryCount()) {
          return false;
       }
       
       
       Map<String,Integer> aSizes = new HashMap<String, Integer>();
       final int isDirectory = -12345; 
       for (Entry a : dirA) {
          String aName = a.getName();
          if (a.isDirectoryEntry()) {
             aSizes.put(aName, isDirectory);
          } else {
             aSizes.put(aName, ((DocumentNode)a).getSize());
          }
       }
       for (Entry b : dirB) {
          String bName = b.getName();
          if (! aSizes.containsKey(bName)) {
             
             return false;
          }
          
          int size;
          if (b.isDirectoryEntry()) {
             size = isDirectory;
          } else {
             size = ((DocumentNode)b).getSize();
          }
          if (size != aSizes.get(bName)) {
             
             return false;
          }
          
          
          aSizes.remove(bName);
       }
       if (!aSizes.isEmpty()) {
          
          return false;
       }
       
       
       for (Entry a : dirA) {
          try {
             Entry b = dirB.getEntry(a.getName());
             boolean match;
             if (a.isDirectoryEntry()) {
                match = areDirectoriesIdentical(
                      (DirectoryEntry)a, (DirectoryEntry)b);
             } else {
                match = areDocumentsIdentical(
                      (DocumentEntry)a, (DocumentEntry)b);
             }
             if (!match) return false;
          } catch(FileNotFoundException e) {
             
             return false;
          } catch(IOException e) {
             
             return false;
          }
       }
       
       
       return true;
    }
    
    
    public static boolean areDocumentsIdentical(DocumentEntry docA, DocumentEntry docB) throws IOException {
       if (! docA.getName().equals(docB.getName())) {
          
          return false;
       }
       if (docA.getSize() != docB.getSize()) {
          
          return false;
       }

       boolean matches = true;
       DocumentInputStream inpA = null, inpB = null;
       try {
          inpA = new DocumentInputStream(docA);
          inpB = new DocumentInputStream(docB);
          
          int readA, readB;
          do {
             readA = inpA.read();
             readB = inpB.read();
             if (readA != readB) {
                matches = false;
                break;
             }
          } while(readA != -1 && readB != -1);
       } finally {
          if (inpA != null) inpA.close();
          if (inpB != null) inpB.close();
       }
       
       return matches;
    }
}

<code block>




package org.apache.poi.poifs.filesystem;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DirectoryProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.property.PropertyTable;
import org.apache.poi.poifs.storage.BATBlock;
import org.apache.poi.poifs.storage.BlockAllocationTableReader;
import org.apache.poi.poifs.storage.BlockAllocationTableWriter;
import org.apache.poi.poifs.storage.BlockList;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.HeaderBlock;
import org.apache.poi.poifs.storage.HeaderBlockConstants;
import org.apache.poi.poifs.storage.HeaderBlockWriter;
import org.apache.poi.poifs.storage.RawDataBlockList;
import org.apache.poi.poifs.storage.SmallBlockTableReader;
import org.apache.poi.poifs.storage.SmallBlockTableWriter;
import org.apache.poi.util.CloseIgnoringInputStream;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.LongField;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class OPOIFSFileSystem
    implements POIFSViewable
{


	private static Logger _logger = LoggerFactory.getLogger(OPOIFSFileSystem.class);

    
    public static InputStream createNonClosingInputStream(InputStream is) {
        return new CloseIgnoringInputStream(is);
    }

    private PropertyTable _property_table;
    private List<POIFSViewable>          _documents;
    private DirectoryNode _root;

    
    private POIFSBigBlockSize bigBlockSize = 
       POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;

    
    public OPOIFSFileSystem()
    {
        HeaderBlock header_block = new HeaderBlock(bigBlockSize);
        _property_table = new PropertyTable(header_block);
        _documents      = new ArrayList<POIFSViewable>();
        _root           = null;
    }

    

    public OPOIFSFileSystem(InputStream stream)
        throws IOException
    {
        this();
        boolean success = false;

        HeaderBlock header_block;
        RawDataBlockList data_blocks;
        try {
            
            header_block = new HeaderBlock(stream);
            bigBlockSize = header_block.getBigBlockSize();

            
            data_blocks = new RawDataBlockList(stream, bigBlockSize);
            success = true;
        } finally {
            closeInputStream(stream, success);
        }


        
        
        new BlockAllocationTableReader(header_block.getBigBlockSize(),
                                       header_block.getBATCount(),
                                       header_block.getBATArray(),
                                       header_block.getXBATCount(),
                                       header_block.getXBATIndex(),
                                       data_blocks);

        
        PropertyTable properties =
            new PropertyTable(header_block, data_blocks);

        
        processProperties(
        		SmallBlockTableReader.getSmallDocumentBlocks(
        		      bigBlockSize, data_blocks, properties.getRoot(),
        				header_block.getSBATStart()
        		),
        		data_blocks,
        		properties.getRoot().getChildren(),
        		null,
        		header_block.getPropertyStart()
        );

        
        getRoot().setStorageClsid(properties.getRoot().getStorageClsid());
    }
    
    protected void closeInputStream(InputStream stream, boolean success) {

        if(stream.markSupported() && !(stream instanceof ByteArrayInputStream)) {
            String msg = "POIFS is closing the supplied input stream of type ("
                    + stream.getClass().getName() + ") which supports mark/reset.  "
                    + "This will be a problem for the caller if the stream will still be used.  "
                    + "If that is the case the caller should wrap the input stream to avoid this close logic.  "
                    + "This warning is only temporary and will not be present in future versions of POI.";
            _logger.warn(msg);
        }
        try {
            stream.close();
        } catch (IOException e) {
            if(success) {
                throw new RuntimeException(e);
            }
            
            
            e.printStackTrace();
        }
    }

    
    public static boolean hasPOIFSHeader(InputStream inp) throws IOException {
        
        byte[] header = IOUtils.peekFirst8Bytes(inp);
        return hasPOIFSHeader(header);
    }
    
    public static boolean hasPOIFSHeader(byte[] header8Bytes) {
        LongField signature = new LongField(HeaderBlockConstants._signature_offset, header8Bytes);

        
        return (signature.get() == HeaderBlockConstants._signature);
    }

    

    public DocumentEntry createDocument(final InputStream stream,
                                        final String name)
        throws IOException
    {
        return getRoot().createDocument(name, stream);
    }

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException
    {
        return getRoot().createDocument(name, size, writer);
    }

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException
    {
        return getRoot().createDirectory(name);
    }

    

    public void writeFilesystem(final OutputStream stream)
        throws IOException
    {

        
        _property_table.preWrite();

        
        SmallBlockTableWriter      sbtw       =
            new SmallBlockTableWriter(bigBlockSize, _documents, _property_table.getRoot());

        
        BlockAllocationTableWriter bat        =
            new BlockAllocationTableWriter(bigBlockSize);

        
        
        List<Object> bm_objects = new ArrayList<Object>();

        bm_objects.addAll(_documents);
        bm_objects.add(_property_table);
        bm_objects.add(sbtw);
        bm_objects.add(sbtw.getSBAT());

        
        
        Iterator<Object> iter = bm_objects.iterator();

        while (iter.hasNext())
        {
            BATManaged bmo         = ( BATManaged ) iter.next();
            int        block_count = bmo.countBlocks();

            if (block_count != 0)
            {
                bmo.setStartBlock(bat.allocateSpace(block_count));
            }
            else
            {

                
                
                
            }
        }

        
        
        int               batStartBlock       = bat.createBlocks();

        
        HeaderBlockWriter header_block_writer = new HeaderBlockWriter(bigBlockSize);
        BATBlock[]        xbat_blocks         =
            header_block_writer.setBATBlocks(bat.countBlocks(),
                                             batStartBlock);

        
        header_block_writer.setPropertyStart(_property_table.getStartBlock());

        
        header_block_writer.setSBATStart(sbtw.getSBAT().getStartBlock());

        
        header_block_writer.setSBATBlockCount(sbtw.getSBATBlockCount());

        
        
        
        
        
        List<Object> writers = new ArrayList<Object>();

        writers.add(header_block_writer);
        writers.addAll(_documents);
        writers.add(_property_table);
        writers.add(sbtw);
        writers.add(sbtw.getSBAT());
        writers.add(bat);
        for (int j = 0; j < xbat_blocks.length; j++)
        {
            writers.add(xbat_blocks[ j ]);
        }

        
        iter = writers.iterator();
        while (iter.hasNext())
        {
            BlockWritable writer = ( BlockWritable ) iter.next();

            writer.writeBlocks(stream);
        }
    }

    

    public static void main(String args[])
        throws IOException
    {
        if (args.length != 2)
        {
            System.err.println(
                "two arguments required: input filename and output filename");
            System.exit(1);
        }
        FileInputStream  istream = new FileInputStream(args[ 0 ]);
        FileOutputStream ostream = new FileOutputStream(args[ 1 ]);

        new OPOIFSFileSystem(istream).writeFilesystem(ostream);
        istream.close();
        ostream.close();
    }

    

    public DirectoryNode getRoot()
    {
        if (_root == null)
        {
            _root = new DirectoryNode(_property_table.getRoot(), this, null);
        }
        return _root;
    }

    

    public DocumentInputStream createDocumentInputStream(
            final String documentName)
        throws IOException
    {
    	return getRoot().createDocumentInputStream(documentName);
    }

    

    void addDocument(final OPOIFSDocument document)
    {
        _documents.add(document);
        _property_table.addProperty(document.getDocumentProperty());
    }

    

    void addDirectory(final DirectoryProperty directory)
    {
        _property_table.addProperty(directory);
    }

    

    void remove(EntryNode entry)
    {
        _property_table.removeProperty(entry.getProperty());
        if (entry.isDocumentEntry())
        {
            _documents.remove((( DocumentNode ) entry).getDocument());
        }
    }

    private void processProperties(final BlockList small_blocks,
                                   final BlockList big_blocks,
                                   final Iterator<Property> properties,
                                   final DirectoryNode dir,
                                   final int headerPropertiesStartAt)
        throws IOException
    {
        while (properties.hasNext())
        {
            Property      property = properties.next();
            String        name     = property.getName();
            DirectoryNode parent   = (dir == null)
                                     ? (( DirectoryNode ) getRoot())
                                     : dir;

            if (property.isDirectory())
            {
                DirectoryNode new_dir =
                    ( DirectoryNode ) parent.createDirectory(name);

                new_dir.setStorageClsid( property.getStorageClsid() );

                processProperties(
                    small_blocks, big_blocks,
                    (( DirectoryProperty ) property).getChildren(),
                    new_dir, headerPropertiesStartAt);
            }
            else
            {
                int           startBlock = property.getStartBlock();
                int           size       = property.getSize();
                OPOIFSDocument document  = null;

                if (property.shouldUseSmallBlocks())
                {
                    document =
                        new OPOIFSDocument(name,
                                           small_blocks.fetchBlocks(startBlock, headerPropertiesStartAt),
                                           size);
                }
                else
                {
                    document =
                        new OPOIFSDocument(name,
                                           big_blocks.fetchBlocks(startBlock, headerPropertiesStartAt),
                                           size);
                }
                parent.createDocument(document);
            }
        }
    }

    

    

    public Object [] getViewableArray()
    {
        if (preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableArray();
        }
        return new Object[ 0 ];
    }

    

    public Iterator<Object> getViewableIterator()
    {
        if (!preferArray())
        {
            return (( POIFSViewable ) getRoot()).getViewableIterator();
        }
        return Collections.emptyList().iterator();
    }

    

    public boolean preferArray()
    {
        return (( POIFSViewable ) getRoot()).preferArray();
    }

    

    public String getShortDescription()
    {
        return "POIFS FileSystem";
    }

    
    public int getBigBlockSize() {
    	return bigBlockSize.getBigBlockSize();
    }
    
    public POIFSBigBlockSize getBigBlockSizeDetails() {
      return bigBlockSize;
    }

    
}   


<code block>




package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.poi.hpsf.ClassID;


public class FilteringDirectoryNode implements DirectoryEntry
{
   
   private Set<String> excludes;
   
   private Map<String,List<String>> childExcludes;
   
   private DirectoryEntry directory;
   
   
   public FilteringDirectoryNode(DirectoryEntry directory, Collection<String> excludes) {
      this.directory = directory;
      
      
      this.excludes = new HashSet<String>();
      this.childExcludes = new HashMap<String, List<String>>();
      for (String excl : excludes) {
         int splitAt = excl.indexOf('/');
         if (splitAt == -1) {
            
            this.excludes.add(excl);
         } else {
            
            String child = excl.substring(0, splitAt);
            String childExcl = excl.substring(splitAt+1);
            if (! this.childExcludes.containsKey(child)) {
               this.childExcludes.put(child, new ArrayList<String>());
            }
            this.childExcludes.get(child).add(childExcl);
         }
      }
   }

   public DirectoryEntry createDirectory(String name) throws IOException {
      return directory.createDirectory(name);
   }

   public DocumentEntry createDocument(String name, InputStream stream)
         throws IOException {
      return directory.createDocument(name, stream);
   }

   public DocumentEntry createDocument(String name, int size,
         POIFSWriterListener writer) throws IOException {
      return directory.createDocument(name, size, writer);
   }

   public Iterator<Entry> getEntries() {
      return new FilteringIterator();
   }

   public Iterator<Entry> iterator() {
      return getEntries();
   }
   
   public int getEntryCount() {
      int size = directory.getEntryCount();
      for (String excl : excludes) {
         if (directory.hasEntry(excl)) {
            size--;
         }
      }
      return size;
   }
   
   public Set<String> getEntryNames() {
       Set<String> names = new HashSet<String>();
       for (String name : directory.getEntryNames()) {
           if (!excludes.contains(name)) {
               names.add(name);
           }
       }
       return names;
   }

   public boolean isEmpty() {
      return (getEntryCount() == 0);
   }

   public boolean hasEntry(String name) {
      if (excludes.contains(name)) {
         return false;
      }
      return directory.hasEntry(name);
   }

   public Entry getEntry(String name) throws FileNotFoundException {
      if (excludes.contains(name)) {
         throw new FileNotFoundException(name);
      }
      
      Entry entry = directory.getEntry(name);
      return wrapEntry(entry);
   }
   private Entry wrapEntry(Entry entry) {
      String name = entry.getName();
      if (childExcludes.containsKey(name) && entry instanceof DirectoryEntry) {
         return new FilteringDirectoryNode(
               (DirectoryEntry)entry, childExcludes.get(name)); 
      }
      return entry;
   }

   public ClassID getStorageClsid() {
      return directory.getStorageClsid();
   }

   public void setStorageClsid(ClassID clsidStorage) {
      directory.setStorageClsid(clsidStorage);
   }

   public boolean delete() {
      return directory.delete();
   }

   public boolean renameTo(String newName) {
      return directory.renameTo(newName);
   }
   
   public String getName() {
      return directory.getName();
   }

   public DirectoryEntry getParent() {
      return directory.getParent();
   }

   public boolean isDirectoryEntry() {
      return true;
   }

   public boolean isDocumentEntry() {
      return false;
   }
   
   private class FilteringIterator implements Iterator<Entry> {
      private Iterator<Entry> parent;
      private Entry next;
      
      private FilteringIterator() {
         parent = directory.getEntries();
         locateNext();
      }
      private void locateNext() {
         next = null;
         Entry e;
         while (parent.hasNext() && next == null) {
            e = parent.next();
            if (! excludes.contains(e.getName())) {
               next = wrapEntry(e);
            }
         }
      }
      
      public boolean hasNext() {
         return (next != null);
      }
      
      public Entry next() {
         Entry e = next;
         locateNext();
         return e;
      }
      
      public void remove() {
         throw new UnsupportedOperationException("Remove not supported");
      }
   }
}
<code block>


        

package org.apache.poi.poifs.filesystem;

import org.apache.poi.poifs.property.Property;



public abstract class EntryNode
    implements Entry
{

    
    private Property      _property;

    
    private DirectoryNode _parent;

    

    protected EntryNode(final Property property, final DirectoryNode parent)
    {
        _property = property;
        _parent   = parent;
    }

    

    protected Property getProperty()
    {
        return _property;
    }

    

    protected boolean isRoot()
    {

        
        return (_parent == null);
    }

    

    protected abstract boolean isDeleteOK();

    

    

    public String getName()
    {
        return _property.getName();
    }

    

    public boolean isDirectoryEntry()
    {
        return false;
    }

    

    public boolean isDocumentEntry()
    {
        return false;
    }

    

    public DirectoryEntry getParent()
    {
        return _parent;
    }

    

    public boolean delete()
    {
        boolean rval = false;

        if ((!isRoot()) && isDeleteOK())
        {
            rval = _parent.deleteEntry(this);
        }
        return rval;
    }

    

    public boolean renameTo(final String newName)
    {
        boolean rval = false;

        if (!isRoot())
        {
            rval = _parent.changeName(getName(), newName);
        }
        return rval;
    }

    
}   


<code block>




package org.apache.poi.poifs.filesystem;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Set;

import org.apache.poi.hpsf.ClassID;



public interface DirectoryEntry
    extends Entry, Iterable<Entry>
{

    

    public Iterator<Entry> getEntries();
    
    
    public Set<String> getEntryNames();

    

    public boolean isEmpty();

    

    public int getEntryCount();

    

    public boolean hasEntry( final String name );

    

    public Entry getEntry(final String name)
        throws FileNotFoundException;

    

    public DocumentEntry createDocument(final String name,
                                        final InputStream stream)
        throws IOException;

    

    public DocumentEntry createDocument(final String name, final int size,
                                        final POIFSWriterListener writer)
        throws IOException;

    

    public DirectoryEntry createDirectory(final String name)
        throws IOException;

    
    public ClassID getStorageClsid();

    
    public void setStorageClsid(ClassID clsidStorage);

}   


<code block>


        

package org.apache.poi.poifs.filesystem;



public interface Entry
{

    

    public String getName();

    

    public boolean isDirectoryEntry();

    

    public boolean isDocumentEntry();

    

    public DirectoryEntry getParent();

    

    public boolean delete();

    

    public boolean renameTo(final String newName);
}   


<code block>


package org.apache.poi.poifs.filesystem;

import java.io.*;

import java.util.*;



public final class DocumentOutputStream extends OutputStream {
    private final OutputStream _stream;
    private final int          _limit;
    private int          _written;

    
    DocumentOutputStream(OutputStream stream, int limit) {
        _stream  = stream;
        _limit   = limit;
        _written = 0;
    }

    
    public void write(int b)
        throws IOException
    {
        limitCheck(1);
        _stream.write(b);
    }

    
    public void write(byte b[])
        throws IOException
    {
        write(b, 0, b.length);
    }

    
    public void write(byte b[], int off, int len)
        throws IOException
    {
        limitCheck(len);
        _stream.write(b, off, len);
    }

    
    public void flush()
        throws IOException
    {
        _stream.flush();
    }

    
    public void close() {

        
    }

    
    void writeFiller(int totalLimit, byte fill)
        throws IOException
    {
        if (totalLimit > _written)
        {
            byte[] filler = new byte[ totalLimit - _written ];

            Arrays.fill(filler, fill);
            _stream.write(filler);
        }
    }

    private void limitCheck(int toBeWritten)
        throws IOException
    {
        if ((_written + toBeWritten) > _limit)
        {
            throw new IOException("tried to write too much data");
        }
        _written += toBeWritten;
    }
}

<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.util.IntList;


public final class BlockAllocationTableWriter implements BlockWritable, BATManaged {
    private IntList    _entries;
    private BATBlock[] _blocks;
    private int        _start_block;
    private POIFSBigBlockSize _bigBlockSize;

    
    public BlockAllocationTableWriter(POIFSBigBlockSize bigBlockSize)
    {
       _bigBlockSize = bigBlockSize; 
        _start_block  = POIFSConstants.END_OF_CHAIN;
        _entries      = new IntList();
        _blocks       = new BATBlock[ 0 ];
    }

    
    public int createBlocks()
    {
        int xbat_blocks = 0;
        int bat_blocks  = 0;

        while (true)
        {
            int calculated_bat_blocks  =
                BATBlock.calculateStorageRequirements(_bigBlockSize,
                                                      bat_blocks
                                                      + xbat_blocks
                                                      + _entries.size());
            int calculated_xbat_blocks =
                HeaderBlockWriter.calculateXBATStorageRequirements(
                      _bigBlockSize, calculated_bat_blocks);

            if ((bat_blocks == calculated_bat_blocks)
                    && (xbat_blocks == calculated_xbat_blocks))
            {

                
                break;
            }
            bat_blocks  = calculated_bat_blocks;
            xbat_blocks = calculated_xbat_blocks;
        }
        int startBlock = allocateSpace(bat_blocks);

        allocateSpace(xbat_blocks);
        simpleCreateBlocks();
        return startBlock;
    }

    
    public int allocateSpace(final int blockCount)
    {
        int startBlock = _entries.size();

        if (blockCount > 0)
        {
            int limit = blockCount - 1;
            int index = startBlock + 1;

            for (int k = 0; k < limit; k++)
            {
                _entries.add(index++);
            }
            _entries.add(POIFSConstants.END_OF_CHAIN);
        }
        return startBlock;
    }

    
    public int getStartBlock()
    {
        return _start_block;
    }

    
    void simpleCreateBlocks()
    {
        _blocks = BATBlock.createBATBlocks(_bigBlockSize, _entries.toArray());
    }

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        for (int j = 0; j < _blocks.length; j++)
        {
            _blocks[ j ].writeBlocks(stream);
        }
    }
    
    
    public static void writeBlock(final BATBlock bat, final ByteBuffer block) 
        throws IOException
    {
        bat.writeData(block);
    }

    
    public int countBlocks()
    {
        return _blocks.length;
    }

    
    public void setStartBlock(int start_block)
    {
        _start_block = start_block;
    }
}

<code block>


        

package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface ListManagedBlock
{

    

    public byte [] getData()
        throws IOException;
}   


<code block>


        

package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.BATManaged;
import org.apache.poi.poifs.filesystem.OPOIFSDocument;
import org.apache.poi.poifs.property.RootProperty;

import java.util.*;

import java.io.*;



public class SmallBlockTableWriter
    implements BlockWritable, BATManaged
{
    private BlockAllocationTableWriter _sbat;
    private List                       _small_blocks;
    private int                        _big_block_count;
    private RootProperty               _root;

    

    public SmallBlockTableWriter(final POIFSBigBlockSize bigBlockSize,
                                 final List documents,
                                 final RootProperty root)
    {
        _sbat         = new BlockAllocationTableWriter(bigBlockSize);
        _small_blocks = new ArrayList();
        _root         = root;
        Iterator iter = documents.iterator();

        while (iter.hasNext())
        {
            OPOIFSDocument   doc    = ( OPOIFSDocument ) iter.next();
            BlockWritable[] blocks = doc.getSmallBlocks();

            if (blocks.length != 0)
            {
                doc.setStartBlock(_sbat.allocateSpace(blocks.length));
                for (int j = 0; j < blocks.length; j++)
                {
                    _small_blocks.add(blocks[ j ]);
                }
            } else {
            	doc.setStartBlock(POIFSConstants.END_OF_CHAIN);
            }
        }
        _sbat.simpleCreateBlocks();
        _root.setSize(_small_blocks.size());
        _big_block_count = SmallDocumentBlock.fill(bigBlockSize,_small_blocks);
    }

    
    
    public int getSBATBlockCount()
    {
	return (_big_block_count + 15) / 16;
    }

    

    public BlockAllocationTableWriter getSBAT()
    {
        return _sbat;
    }

    

    

    public int countBlocks()
    {
        return _big_block_count;
    }

    

    public void setStartBlock(int start_block)
    {
        _root.setStartBlock(start_block);
    }

    
    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        Iterator iter = _small_blocks.iterator();

        while (iter.hasNext())
        {
            (( BlockWritable ) iter.next()).writeBlocks(stream);
        }
    }

    
}

<code block>


        

package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;



public interface BlockWritable
{

    

    public void writeBlocks(final OutputStream stream)
        throws IOException;
}   


<code block>


package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.LittleEndianConsts;


public interface HeaderBlockConstants
{
    public static final long _signature               = 0xE11AB1A1E011CFD0L;
    public static final int  _bat_array_offset        = 0x4c;
    public static final int  _max_bats_in_header      =
        (POIFSConstants.SMALLER_BIG_BLOCK_SIZE - _bat_array_offset)
        / LittleEndianConsts.INT_SIZE; 

    
    
    
    
    
    
    public static final int  _signature_offset        = 0;
    public static final int  _bat_count_offset        = 0x2C;
    public static final int  _property_start_offset   = 0x30;
    public static final int  _sbat_start_offset       = 0x3C;
    public static final int  _sbat_block_count_offset = 0x40;
    public static final int  _xbat_start_offset       = 0x44;
    public static final int  _xbat_count_offset       = 0x48;
}   


<code block>


        

package org.apache.poi.poifs.storage;

import java.io.IOException;



public interface BlockList
{

    

    public void zap(final int index);

    

    public ListManagedBlock remove(final int index)
        throws IOException;

    

    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException;

    

    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException;
    
    public int blockCount();
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.property.RootProperty;


public final class SmallBlockTableReader {

    
    public static BlockList getSmallDocumentBlocks(
            final POIFSBigBlockSize bigBlockSize,
            final RawDataBlockList blockList, final RootProperty root,
            final int sbatStart)
        throws IOException
    {
       
       ListManagedBlock [] smallBlockBlocks = 
          blockList.fetchBlocks(root.getStartBlock(), -1);
        
       
       BlockList list =new SmallDocumentBlockList(
             SmallDocumentBlock.extract(bigBlockSize, smallBlockBlocks));

       
        new BlockAllocationTableReader(bigBlockSize,
                                       blockList.fetchBlocks(sbatStart, -1),
                                       list);
        return list;
    }
}

<code block>


package org.apache.poi.poifs.storage;


public final class DataInputBlock {

	
	private final byte[] _buf;
	private int _readIndex;
	private int _maxIndex;

	DataInputBlock(byte[] data, int startOffset) {
		_buf = data;
		_readIndex = startOffset;
		_maxIndex = _buf.length;
	}
	public int available() {
		return _maxIndex-_readIndex;
	}

	public int readUByte() {
		return _buf[_readIndex++] & 0xFF;
	}

	
	public int readUShortLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b1 << 8) + (b0 << 0);
	}

	
	public int readUShortLE(DataInputBlock prevBlock) {
		
		int i = prevBlock._buf.length-1;
		
		int b0 = prevBlock._buf[i++] & 0xFF;
		int b1 = _buf[_readIndex++] & 0xFF;
		return (b1 << 8) + (b0 << 0);
	}

	
	public int readIntLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	
	public int readIntLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[4];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	
	public long readLongLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		int b4 = _buf[i++] & 0xFF;
		int b5 = _buf[i++] & 0xFF;
		int b6 = _buf[i++] & 0xFF;
		int b7 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	
	public long readLongLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[8];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		int b4 = buf[4] & 0xFF;
		int b5 = buf[5] & 0xFF;
		int b6 = buf[6] & 0xFF;
		int b7 = buf[7] & 0xFF;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	
	private void readSpanning(DataInputBlock prevBlock, int prevBlockAvailable, byte[] buf) {
		System.arraycopy(prevBlock._buf, prevBlock._readIndex, buf, 0, prevBlockAvailable);
		int secondReadLen = buf.length-prevBlockAvailable;
		System.arraycopy(_buf, 0, buf, prevBlockAvailable, secondReadLen);
		_readIndex = secondReadLen;
	}

	
	public void readFully(byte[] buf, int off, int len) {
		System.arraycopy(_buf, _readIndex, buf, off, len);
		_readIndex += len;
	}
}

<code block>


        

package org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;


public class HeaderBlockWriter implements HeaderBlockConstants, BlockWritable
{
   private final HeaderBlock _header_block;

    
    public HeaderBlockWriter(POIFSBigBlockSize bigBlockSize)
    {
       _header_block = new HeaderBlock(bigBlockSize);
    }

    
    public HeaderBlockWriter(HeaderBlock headerBlock)
    {
       _header_block = headerBlock;
    }

    

    public BATBlock [] setBATBlocks(final int blockCount,
                                    final int startBlock)
    {
        BATBlock[] rvalue;
        POIFSBigBlockSize bigBlockSize = _header_block.getBigBlockSize();

        _header_block.setBATCount(blockCount);

        
        int limit  = Math.min(blockCount, _max_bats_in_header);
        int[] bat_blocks = new int[limit];
        for (int j = 0; j < limit; j++) {
           bat_blocks[j] = startBlock + j;
        }
        _header_block.setBATArray(bat_blocks);
        
        
        if (blockCount > _max_bats_in_header)
        {
            int   excess_blocks      = blockCount - _max_bats_in_header;
            int[] excess_block_array = new int[ excess_blocks ];

            for (int j = 0; j < excess_blocks; j++)
            {
                excess_block_array[ j ] = startBlock + j
                                          + _max_bats_in_header;
            }
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, excess_block_array,
                                               startBlock + blockCount);
            _header_block.setXBATStart(startBlock + blockCount);
        }
        else
        {
            rvalue = BATBlock.createXBATBlocks(bigBlockSize, new int[ 0 ], 0);
            _header_block.setXBATStart(POIFSConstants.END_OF_CHAIN);
        }
        _header_block.setXBATCount(rvalue.length);
        return rvalue;
    }

    
    public void setPropertyStart(final int startBlock)
    {
       _header_block.setPropertyStart(startBlock);
    }

    
    public void setSBATStart(final int startBlock)
    {
        _header_block.setSBATStart(startBlock);
    }

    
    public void setSBATBlockCount(final int count)
    {
       _header_block.setSBATBlockCount(count);
    }

    

    static int calculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize, final int blockCount)
    {
        return (blockCount > _max_bats_in_header)
               ? BATBlock.calculateXBATStorageRequirements(
                     bigBlockSize, blockCount - _max_bats_in_header)
               : 0;
    }

    

    
    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        _header_block.writeData(stream);
    }
    
    
    public void writeBlock(ByteBuffer block)
        throws IOException
    {
       ByteArrayOutputStream baos = new ByteArrayOutputStream(
             _header_block.getBigBlockSize().getBigBlockSize()
       );
       _header_block.writeData(baos);
       
       block.put(baos.toByteArray());
    }

    
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;

import org.apache.poi.hssf.OldExcelFormatException;
import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.filesystem.NotOLE2FileException;
import org.apache.poi.poifs.filesystem.OfficeXmlFileException;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LongField;


import org.apache.poi.util.ShortField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class HeaderBlock implements HeaderBlockConstants {
	
	private static Logger _logger = LoggerFactory.getLogger(HeaderBlock.class);
	


   
	
	private final POIFSBigBlockSize bigBlockSize;

	
	private int _bat_count;

	
	private int _property_start;

	
	private int _sbat_start;
	
	private int _sbat_count;

	
	private int _xbat_start;
	
	private int _xbat_count;
	
	
	private final byte[] _data;
	
   private static final byte _default_value = ( byte ) 0xFF;

	
	public HeaderBlock(InputStream stream) throws IOException {
		
	   
		
		this(readFirst512(stream));
		
		
		if(bigBlockSize.getBigBlockSize() != 512) {
		   int rest = bigBlockSize.getBigBlockSize() - 512;
		   byte[] tmp = new byte[rest];
		   IOUtils.readFully(stream, tmp);
		}
	}
	
	public HeaderBlock(ByteBuffer buffer) throws IOException {
	   this(IOUtils.toByteArray(buffer, POIFSConstants.SMALLER_BIG_BLOCK_SIZE));
	}
	
	private HeaderBlock(byte[] data) throws IOException {
	   this._data = data;
	   
		
		long signature = LittleEndian.getLong(_data, _signature_offset);

		if (signature != _signature) {
			
			byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;
			if (_data[0] == OOXML_FILE_HEADER[0] &&
				_data[1] == OOXML_FILE_HEADER[1] &&
				_data[2] == OOXML_FILE_HEADER[2] &&
				_data[3] == OOXML_FILE_HEADER[3]) {
				throw new OfficeXmlFileException("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");
			}
			
            if (_data[0] == 0x09 && _data[1] == 0x00 && 
                _data[2] == 0x04 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00 && 
               (_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                _data[7] == 0x00) {
                
                throw new OldExcelFormatException("The supplied data appears to be in BIFF2 format. " +
                        "HSSF only supports the BIFF8 format, try OldExcelExtractor");
            }
            if (_data[0] == 0x09 && _data[1] == 0x02 && 
                _data[2] == 0x06 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00 && 
               (_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                _data[7] == 0x00) {
                
                throw new OldExcelFormatException("The supplied data appears to be in BIFF3 format. " +
                        "HSSF only supports the BIFF8 format, try OldExcelExtractor");
            }
            if (_data[0] == 0x09 && _data[1] == 0x04 && 
                _data[2] == 0x06 && _data[3] == 0x00 && 
                _data[4] == 0x00 && _data[5] == 0x00) { 
                if (((_data[6] == 0x10 || _data[6] == 0x20 || _data[6] == 0x40) &&
                      _data[7] == 0x00) ||
                    (_data[6] == 0x00 && _data[7] == 0x01)) {
                    
                    throw new OldExcelFormatException("The supplied data appears to be in BIFF4 format. " +
                            "HSSF only supports the BIFF8 format, try OldExcelExtractor");
                }
            }

			
			throw new NotOLE2FileException("Invalid header signature; read "
				                  + longToHex(signature) + ", expected "
				                  + longToHex(_signature) + " - Your file appears "
				                  + "not to be a valid OLE2 document");
		}


		
		if (_data[30] == 12) {
			this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;
		} else if(_data[30] == 9) {
			this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   throw new IOException("Unsupported blocksize  (2^"+ _data[30] + "). Expected 2^9 or 2^12.");
		}

	   
      _bat_count      = new IntegerField(_bat_count_offset, data).get();
      _property_start = new IntegerField(_property_start_offset,_data).get();
      _sbat_start = new IntegerField(_sbat_start_offset, _data).get();
      _sbat_count = new IntegerField(_sbat_block_count_offset, _data).get();
      _xbat_start = new IntegerField(_xbat_start_offset, _data).get();
      _xbat_count = new IntegerField(_xbat_count_offset, _data).get();
	}
	
   
   public HeaderBlock(POIFSBigBlockSize bigBlockSize)
   {
      this.bigBlockSize = bigBlockSize;

      
      _data = new byte[ POIFSConstants.SMALLER_BIG_BLOCK_SIZE ];
      Arrays.fill(_data, _default_value);
      
      
      new LongField(_signature_offset, _signature, _data);
      new IntegerField(0x08, 0, _data);
      new IntegerField(0x0c, 0, _data);
      new IntegerField(0x10, 0, _data);
      new IntegerField(0x14, 0, _data);
      new ShortField(0x18, ( short ) 0x3b, _data);
      new ShortField(0x1a, ( short ) 0x3, _data);
      new ShortField(0x1c, ( short ) -2, _data);
       
      new ShortField(0x1e, bigBlockSize.getHeaderValue(), _data);
      new IntegerField(0x20, 0x6, _data);
      new IntegerField(0x24, 0, _data);
      new IntegerField(0x28, 0, _data);
      new IntegerField(0x34, 0, _data);
      new IntegerField(0x38, 0x1000, _data);
      
      
      _bat_count = 0;
      _sbat_count = 0;
      _xbat_count = 0;
      _property_start = POIFSConstants.END_OF_CHAIN;
      _sbat_start = POIFSConstants.END_OF_CHAIN;
      _xbat_start = POIFSConstants.END_OF_CHAIN;
   }
   
	private static byte[] readFirst512(InputStream stream) throws IOException {
      
      
      byte[] data = new byte[512];
      int bsCount = IOUtils.readFully(stream, data);
      if(bsCount != 512) {
         throw alertShortRead(bsCount, 512);
      }
      return data;
	}

	private static String longToHex(long value) {
		return new String(HexDump.longToHex(value));
	}

	private static IOException alertShortRead(int pRead, int expectedReadSize) {
		int read;
		if (pRead < 0) {
			
			read = 0;
		} else {
			read = pRead;
		}
		String type = " byte" + (read == 1 ? (""): ("s"));

		return new IOException("Unable to read entire header; "
				+ read + type + " read; expected "
				+ expectedReadSize + " bytes");
	}

	
	public int getPropertyStart() {
		return _property_start;
	}
   
   public void setPropertyStart(final int startBlock) {
       _property_start = startBlock;
   }

	
	public int getSBATStart() {
		return _sbat_start;
	}
	public int getSBATCount() {
	   return _sbat_count;
	}
	
   
   public void setSBATStart(final int startBlock) {
       _sbat_start = startBlock;
   }
   
   public void setSBATBlockCount(final int count)
   {
      _sbat_count = count;
   }

	
	public int getBATCount() {
		return _bat_count;
	}
   
   public void setBATCount(final int count) {
      _bat_count = count;
   }

	
	public int[] getBATArray() {
      
		int[] result = new int[ Math.min(_bat_count,_max_bats_in_header) ];
		int offset = _bat_array_offset;
		for (int j = 0; j < result.length; j++) {
			result[ j ] = LittleEndian.getInt(_data, offset);
			offset     += LittleEndianConsts.INT_SIZE;
		}
		return result;
	}
	
	public void setBATArray(int[] bat_array) {
	   int count = Math.min(bat_array.length, _max_bats_in_header);
	   int blank = _max_bats_in_header - count;
	   
      int offset = _bat_array_offset;
	   for(int i=0; i<count; i++) {
	      LittleEndian.putInt(_data, offset, bat_array[i]);
         offset += LittleEndianConsts.INT_SIZE;
	   }
	   for(int i=0; i<blank; i++) {
         LittleEndian.putInt(_data, offset, POIFSConstants.UNUSED_BLOCK);
         offset += LittleEndianConsts.INT_SIZE;
	   }
	}

	
	public int getXBATCount() {
		return _xbat_count;
	}
	
	public void setXBATCount(final int count) {
	   _xbat_count = count;
	}

	
	public int getXBATIndex() {
		return _xbat_start;
	}
	
   public void setXBATStart(final int startBlock) {
      _xbat_start = startBlock;
  }

	
	public POIFSBigBlockSize getBigBlockSize() {
		return bigBlockSize;
	}
	
   
   void writeData(final OutputStream stream)
       throws IOException
   {
      
      new IntegerField(_bat_count_offset,      _bat_count, _data);
      new IntegerField(_property_start_offset, _property_start, _data);
      new IntegerField(_sbat_start_offset,     _sbat_start, _data);
      new IntegerField(_sbat_block_count_offset, _sbat_count, _data);
      new IntegerField(_xbat_start_offset,      _xbat_start, _data);
      new IntegerField(_xbat_count_offset,      _xbat_count, _data);
      
      
      stream.write(_data, 0, 512);
      
      
      for(int i=POIFSConstants.SMALLER_BIG_BLOCK_SIZE; i<bigBlockSize.getBigBlockSize(); i++) {
         stream.write(0);
      }
   }
}

<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IOUtils;


public final class DocumentBlock extends BigBlock {
    private static final byte _default_value = ( byte ) 0xFF;
    private byte[]            _data;
    private int               _bytes_read;

    

    public DocumentBlock(final RawDataBlock block)
        throws IOException
    {
        super(
              block.getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
                    POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS :
                    POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
        );
        _data       = block.getData();
        _bytes_read = _data.length;
    }

    

    public DocumentBlock(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        this(bigBlockSize);
        int count = IOUtils.readFully(stream, _data);

        _bytes_read = (count == -1) ? 0
                                    : count;
    }

    

    private DocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        _data = new byte[ bigBlockSize.getBigBlockSize() ];
        Arrays.fill(_data, _default_value);
    }

    

    public int size()
    {
        return _bytes_read;
    }

    

    public boolean partiallyRead()
    {
        return _bytes_read != bigBlockSize.getBigBlockSize();
    }

    

    public static byte getFillByte()
    {
        return _default_value;
    }

    

    public static DocumentBlock [] convert(final POIFSBigBlockSize bigBlockSize,
                                           final byte [] array,
                                           final int size)
    {
        DocumentBlock[] rval   =
            new DocumentBlock[ (size + bigBlockSize.getBigBlockSize() - 1) / bigBlockSize.getBigBlockSize() ];
        int             offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new DocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(bigBlockSize.getBigBlockSize(),
                                      array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != bigBlockSize.getBigBlockSize())
                {
                    Arrays.fill(rval[ k ]._data, length,
                          bigBlockSize.getBigBlockSize(),
                                _default_value);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_value);
            }
            offset += bigBlockSize.getBigBlockSize();
        }
        return rval;
    }

    public static DataInputBlock getDataInputBlock(DocumentBlock[] blocks, int offset) {
        if(blocks == null || blocks.length == 0) {
           return null;
        }
        
        
        POIFSBigBlockSize bigBlockSize = blocks[0].bigBlockSize;
        int BLOCK_SHIFT = bigBlockSize.getHeaderValue();
        int BLOCK_SIZE = bigBlockSize.getBigBlockSize();
        int BLOCK_MASK = BLOCK_SIZE - 1;

        
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        doWriteData(stream, _data);
    }

    
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.util.*;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class BlockAllocationTableReader {

	private static Logger _logger = LoggerFactory.getLogger(BlockAllocationTableReader.class);

    
    private static final int MAX_BLOCK_COUNT = 65535;
    private final IntList _entries;
    private POIFSBigBlockSize bigBlockSize;

    
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, int block_count, int [] block_array,
            int xbat_count, int xbat_index, BlockList raw_block_list) throws IOException {
        this(bigBlockSize);
        
        sanityCheckBlockCount(block_count);

        
        
        
        
        
        
        int          limit    = Math.min(block_count, block_array.length);
        int          block_index;
        
        
        RawDataBlock blocks[] = new RawDataBlock[ block_count ];

        
        for (block_index = 0; block_index < limit; block_index++)
        {
            
            int nextOffset = block_array[ block_index ];
            if(nextOffset > raw_block_list.blockCount()) {
               throw new IOException("Your file contains " + raw_block_list.blockCount() + 
                     " sectors, but the initial DIFAT array at index " + block_index +
                     " referenced block # " + nextOffset + ". This isn't allowed and " +
                     " your file is corrupt");
            }
            
            blocks[ block_index ] =
                ( RawDataBlock ) raw_block_list.remove(nextOffset);
        }
        
        
        if (block_index < block_count)
        {

            
            if (xbat_index < 0)
            {
                throw new IOException(
                    "BAT count exceeds limit, yet XBAT index indicates no valid entries");
            }
            int chain_index           = xbat_index;
            int max_entries_per_block = bigBlockSize.getXBATEntriesPerBlock(); 
            int chain_index_offset    = bigBlockSize.getNextXBATChainOffset(); 

            
            
            
            for (int j = 0; j < xbat_count; j++)
            {
                limit = Math.min(block_count - block_index,
                                 max_entries_per_block);
                byte[] data   = raw_block_list.remove(chain_index).getData();
                int    offset = 0;

                for (int k = 0; k < limit; k++)
                {
                    blocks[ block_index++ ] =
                        ( RawDataBlock ) raw_block_list
                            .remove(LittleEndian.getInt(data, offset));
                    offset                  += LittleEndianConsts.INT_SIZE;
                }
                chain_index = LittleEndian.getInt(data, chain_index_offset);
                if (chain_index == POIFSConstants.END_OF_CHAIN)
                {
                    break;
                }
            }
        }
        if (block_index != block_count)
        {
            throw new IOException("Could not find all blocks");
        }

        
        
        setEntries(blocks, raw_block_list);
    }

    
    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, BlockList raw_block_list)
            throws IOException {
        this(bigBlockSize);
        setEntries(blocks, raw_block_list);
    }

    BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize) {
        this.bigBlockSize = bigBlockSize;
        _entries = new IntList();
    }
    
    public static void sanityCheckBlockCount(int block_count) throws IOException {
       if (block_count <= 0) {
          throw new IOException(
                "Illegal block count; minimum count is 1, got " + 
                block_count + " instead"
          );
       }
       if (block_count > MAX_BLOCK_COUNT) {
          throw new IOException(
                "Block count " + block_count + 
                " is too high. POI maximum is " + MAX_BLOCK_COUNT + "."
          );
       }
    }

    
    ListManagedBlock[] fetchBlocks(int startBlock, int headerPropertiesStartBlock,
            BlockList blockList) throws IOException {
        List<ListManagedBlock> blocks = new ArrayList<ListManagedBlock>();
        int  currentBlock = startBlock;
        boolean firstPass = true;
        ListManagedBlock dataBlock = null;

        
        
        
        
        while (currentBlock != POIFSConstants.END_OF_CHAIN) {
            try {
                
                dataBlock = blockList.remove(currentBlock);
                blocks.add(dataBlock);
                
                currentBlock = _entries.get(currentBlock);
                firstPass = false;
            } catch(IOException e) {
                if(currentBlock == headerPropertiesStartBlock) {
                    
                    _logger.warn("Warning, header block comes after data blocks in POIFS block listing");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else if(currentBlock == 0 && firstPass) {
                    
                    
                    _logger.warn("Warning, incorrectly terminated empty data blocks in POIFS block listing (should end at -2, ended at 0)");
                    currentBlock = POIFSConstants.END_OF_CHAIN;
                } else {
                    
                    throw e;
                }
            }
        }

        return blocks.toArray(new ListManagedBlock[blocks.size()]);
    }

    

    
    boolean isUsed(int index) {

        try {
            return _entries.get(index) != -1;
        } catch (IndexOutOfBoundsException e) {
            
            return false;
        }
    }

    
    int getNextBlockIndex(int index) throws IOException {
        if (isUsed(index)) {
            return _entries.get(index);
        }
        throw new IOException("index " + index + " is unused");
    }

    
    private void setEntries(ListManagedBlock[] blocks, BlockList raw_blocks) throws IOException {
        int limit = bigBlockSize.getBATEntriesPerBlock(); 

        for (int block_index = 0; block_index < blocks.length; block_index++)
        {
            byte[] data   = blocks[ block_index ].getData();
            int    offset = 0;

            for (int k = 0; k < limit; k++)
            {
                int entry = LittleEndian.getInt(data, offset);

                if (entry == POIFSConstants.UNUSED_BLOCK)
                {
                    raw_blocks.zap(_entries.size());
                }
                _entries.add(entry);
                offset += LittleEndianConsts.INT_SIZE;
            }

            
            blocks[ block_index ] = null;
        }
        raw_blocks.setBAT(this);
    }
}

<code block>


        

package org.apache.poi.poifs.storage;

import java.io.*;

import java.util.*;

import org.apache.poi.poifs.common.POIFSBigBlockSize;



public class RawDataBlockList
    extends BlockListImpl
{

    

    public RawDataBlockList(final InputStream stream, POIFSBigBlockSize bigBlockSize)
        throws IOException
    {
        List<RawDataBlock> blocks = new ArrayList<RawDataBlock>();

        while (true)
        {
            RawDataBlock block = new RawDataBlock(stream, bigBlockSize.getBigBlockSize());
            
            
            if(block.hasData()) {
            	blocks.add(block);
            }

            
            if (block.eof()) {
                break;
            }
        }
        setBlocks( blocks.toArray(new RawDataBlock[ blocks.size() ]) );
    }
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.property.Property;


public final class PropertyBlock extends BigBlock {
    private Property[]       _properties;

    

    private PropertyBlock(final POIFSBigBlockSize bigBlockSize, final Property [] properties, final int offset)
    {
        super(bigBlockSize);
        
        _properties = new Property[ bigBlockSize.getPropertiesPerBlock() ]; 
        for (int j = 0; j < _properties.length; j++)
        {
            _properties[ j ] = properties[ j + offset ];
        }
    }

    

    public static BlockWritable [] createPropertyBlockArray(
            final POIFSBigBlockSize bigBlockSize, final List<Property> properties)
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        int        block_count   =
            (properties.size() + _properties_per_block - 1)
            / _properties_per_block;
        Property[] to_be_written =
            new Property[ block_count * _properties_per_block ];

        System.arraycopy(properties.toArray(new Property[ 0 ]), 0,
                         to_be_written, 0, properties.size());
        for (int j = properties.size(); j < to_be_written.length; j++)
        {

            
            
            to_be_written[ j ] = new Property()
            {
                protected void preWrite()
                {
                }

                public boolean isDirectory()
                {
                    return false;
                }
            };
        }
        BlockWritable[] rvalue = new BlockWritable[ block_count ];

        for (int j = 0; j < block_count; j++)
        {
            rvalue[ j ] = new PropertyBlock(bigBlockSize, to_be_written,
                                            j * _properties_per_block);
        }
        return rvalue;
    }

    

    

    void writeData(final OutputStream stream)
        throws IOException
    {
        int _properties_per_block = bigBlockSize.getPropertiesPerBlock();
        for (int j = 0; j < _properties_per_block; j++)
        {
            _properties[ j ].writeData(stream);
        }
    }

    
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;


abstract class BlockListImpl implements BlockList {
    private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    
    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    
    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    
    protected ListManagedBlock get(final int index) {
        return _blocks[index];
    }

    
    public ListManagedBlock remove(final int index)
        throws IOException
    {
        ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(
                		"block[ " + index + " ] already removed - " +
                		"does your POIFS have circular or duplicate block references?"
                );
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException("Cannot remove block[ " + index
                                  + " ]; out of range[ 0 - " +
                                  (_blocks.length-1) + " ]");
        }
        return result;
    }

    
    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                "Improperly initialized list: no block allocation table provided");
        }
        return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);
    }

    
    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                "Attempt to replace existing BlockAllocationTable");
        }
        _bat = bat;
    }
    
    
    public int blockCount() {
       return _blocks.length;
    }
    
    protected int remainingBlocks() {
       int c = 0;
       for(int i=0; i<_blocks.length; i++) {
          if(_blocks[i] != null) c++;
       }
       return c;
    }
}

<code block>


        

package org.apache.poi.poifs.storage;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.IOUtils;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;



public class RawDataBlock
    implements ListManagedBlock
{
    private byte[]  _data;
    private boolean _eof;
    private boolean _hasData;
    

	private static Logger log = LoggerFactory.getLogger(RawDataBlock.class);


    
    public RawDataBlock(final InputStream stream)
    		throws IOException {
    	this(stream, POIFSConstants.SMALLER_BIG_BLOCK_SIZE);
    }
    
    public RawDataBlock(final InputStream stream, int blockSize)
    		throws IOException {
        _data = new byte[ blockSize ];
        int count = IOUtils.readFully(stream, _data);
        _hasData = (count > 0);

        if (count == -1) {
            _eof = true;
        }
        else if (count != blockSize) {
        	
        	
        	
            _eof = true;
            String type = " byte" + ((count == 1) ? ("")
                                                  : ("s"));

            log.error(
            		"Unable to read entire block; " + count
                     + type + " read before EOF; expected "
                     + blockSize + " bytes. Your document "
                     + "was either written by software that "
                     + "ignores the spec, or has been truncated!"
            );
        }
        else {
            _eof = false;
        }
    }

    
    public boolean eof() {
        return _eof;
    }
    
    public boolean hasData() {
    	return _hasData;
    }
    
    public String toString() {
       return "RawDataBlock of size " + _data.length; 
    }

    

    
    public byte [] getData()
        throws IOException
    {
        if (! hasData())
        {
            throw new IOException("Cannot return empty data");
        }
        return _data;
    }
    
    
    public int getBigBlockSize() {
       return _data.length;
    }

    
}   


<code block>


package org.apache.poi.poifs.storage;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.util.LittleEndian;


public final class BATBlock extends BigBlock {
    
    private int[] _values;
    
    
    private boolean _has_free_sectors;
    
    
    private int ourBlockIndex;
    
    
    private BATBlock(POIFSBigBlockSize bigBlockSize)
    {
        super(bigBlockSize);
        
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        _values = new int[_entries_per_block];
        _has_free_sectors = true;

        Arrays.fill(_values, POIFSConstants.UNUSED_BLOCK);
    }

    

    private BATBlock(POIFSBigBlockSize bigBlockSize, final int [] entries,
                     final int start_index, final int end_index)
    {
        this(bigBlockSize);
        for (int k = start_index; k < end_index; k++) {
           _values[k - start_index] = entries[k];
        }
        
        
        if(end_index - start_index == _values.length) {
           recomputeFree();
        }
    }
    
    private void recomputeFree() {
       boolean hasFree = false;
       for(int k=0; k<_values.length; k++) {
          if(_values[k] == POIFSConstants.UNUSED_BLOCK) {
             hasFree = true;
             break;
          }
       }
       _has_free_sectors = hasFree;
    }

    
    public static BATBlock createBATBlock(final POIFSBigBlockSize bigBlockSize, ByteBuffer data)
    {
       
       BATBlock block = new BATBlock(bigBlockSize);
       
       
       byte[] buffer = new byte[LittleEndian.INT_SIZE];
       for(int i=0; i<block._values.length; i++) {
          data.get(buffer);
          block._values[i] = LittleEndian.getInt(buffer);
       }
       block.recomputeFree();
       
       
       return block;
    }
    
    
    public static BATBlock createEmptyBATBlock(final POIFSBigBlockSize bigBlockSize, boolean isXBAT) {
       BATBlock block = new BATBlock(bigBlockSize);
       if(isXBAT) {
          block.setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
       }
       return block;
    }

    
    public static BATBlock [] createBATBlocks(final POIFSBigBlockSize bigBlockSize, final int [] entries)
    {
        int        block_count = calculateStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        for (int j = 0; j < entries.length; j += _entries_per_block)
        {
            blocks[ index++ ] = new BATBlock(bigBlockSize, entries, j,
                                             (remaining > _entries_per_block)
                                             ? j + _entries_per_block
                                             : entries.length);
            remaining         -= _entries_per_block;
        }
        return blocks;
    }
    
    

    public static BATBlock [] createXBATBlocks(final POIFSBigBlockSize bigBlockSize,
                                               final int [] entries,
                                               final int startBlock)
    {
        int        block_count =
            calculateXBATStorageRequirements(bigBlockSize, entries.length);
        BATBlock[] blocks      = new BATBlock[ block_count ];
        int        index       = 0;
        int        remaining   = entries.length;

        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        if (block_count != 0)
        {
            for (int j = 0; j < entries.length; j += _entries_per_xbat_block)
            {
                blocks[ index++ ] =
                    new BATBlock(bigBlockSize, entries, j,
                                 (remaining > _entries_per_xbat_block)
                                 ? j + _entries_per_xbat_block
                                 : entries.length);
                remaining         -= _entries_per_xbat_block;
            }
            for (index = 0; index < blocks.length - 1; index++)
            {
                blocks[ index ].setXBATChain(bigBlockSize, startBlock + index + 1);
            }
            blocks[ index ].setXBATChain(bigBlockSize, POIFSConstants.END_OF_CHAIN);
        }
        return blocks;
    }

    
    public static int calculateStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_block = bigBlockSize.getBATEntriesPerBlock();
        return (entryCount + _entries_per_block - 1) / _entries_per_block;
    }

    
    public static int calculateXBATStorageRequirements(final POIFSBigBlockSize bigBlockSize, final int entryCount)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        return (entryCount + _entries_per_xbat_block - 1)
               / _entries_per_xbat_block;
    }
    
    
    public static long calculateMaximumSize(final POIFSBigBlockSize bigBlockSize,
          final int numBATs) {
       long size = 1; 
       
       
       
       
       size += (numBATs * bigBlockSize.getBATEntriesPerBlock());
       
       
       return size * bigBlockSize.getBigBlockSize();
    }
    public static long calculateMaximumSize(final HeaderBlock header)
    {
       return calculateMaximumSize(header.getBigBlockSize(), header.getBATCount());
    }

    
    public static BATBlockAndIndex getBATBlockAndIndex(final int offset, 
                final HeaderBlock header, final List<BATBlock> bats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       int whichBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, bats.get(whichBAT) );
    }
    
    
    public static BATBlockAndIndex getSBATBlockAndIndex(final int offset, 
          final HeaderBlock header, final List<BATBlock> sbats) {
       POIFSBigBlockSize bigBlockSize = header.getBigBlockSize();
       
       
       int whichSBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());
       int index = offset % bigBlockSize.getBATEntriesPerBlock();
       return new BATBlockAndIndex( index, sbats.get(whichSBAT) );
    }
    
    private void setXBATChain(final POIFSBigBlockSize bigBlockSize, int chainIndex)
    {
        int _entries_per_xbat_block = bigBlockSize.getXBATEntriesPerBlock();
        _values[ _entries_per_xbat_block ] = chainIndex;
    }
    
    
    public boolean hasFreeSectors() {
       return _has_free_sectors;
    }
    
    public int getValueAt(int relativeOffset) {
       if(relativeOffset >= _values.length) {
          throw new ArrayIndexOutOfBoundsException(
                "Unable to fetch offset " + relativeOffset + " as the " + 
                "BAT only contains " + _values.length + " entries"
          ); 
       }
       return _values[relativeOffset];
    }
    public void setValueAt(int relativeOffset, int value) {
       int oldValue = _values[relativeOffset];
       _values[relativeOffset] = value;
       
       
       if(value == POIFSConstants.UNUSED_BLOCK) {
          _has_free_sectors = true;
          return;
       }
       if(oldValue == POIFSConstants.UNUSED_BLOCK) {
          recomputeFree();
       }
    }
    
    
    public void setOurBlockIndex(int index) {
       this.ourBlockIndex = index;
    }
    
    public int getOurBlockIndex() {
       return ourBlockIndex;
    }


    

   
    void writeData(final OutputStream stream)
        throws IOException
    {
       
       stream.write( serialize() );
    }
    
    void writeData(final ByteBuffer block)
        throws IOException
    {
       
       block.put( serialize() );
    }
    
    private byte[] serialize() {
       
       byte[] data = new byte[ bigBlockSize.getBigBlockSize() ];
       
       
       int offset = 0;
       for(int i=0; i<_values.length; i++) {
          LittleEndian.putInt(data, offset, _values[i]);
          offset += LittleEndian.INT_SIZE;
       }
       
       
       return data;
    }

    
    
    
    public static class BATBlockAndIndex {
       private final int index;
       private final BATBlock block;
       private BATBlockAndIndex(int index, BATBlock block) {
          this.index = index;
          this.block = block;
       }
       public int getIndex() {
          return index;
       }
       public BATBlock getBlock() {
          return block;
       }
    }
}


<code block>


package org.apache.poi.poifs.storage;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;


public final class SmallDocumentBlock implements BlockWritable, ListManagedBlock {
    private static final int BLOCK_SHIFT = 6;

    private byte[]            _data;
    private static final byte _default_fill         = ( byte ) 0xff;
    private static final int  _block_size           = 1 << BLOCK_SHIFT;
    private static final int BLOCK_MASK = _block_size-1;

    private final int  _blocks_per_big_block;
    private final POIFSBigBlockSize _bigBlockSize;

    private SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize, final byte [] data, final int index)
    {
        this(bigBlockSize);
        System.arraycopy(data, index * _block_size, _data, 0, _block_size);
    }

    private SmallDocumentBlock(final POIFSBigBlockSize bigBlockSize)
    {
        _bigBlockSize = bigBlockSize;
        _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        _data = new byte[ _block_size ];
    }
    
    private static int getBlocksPerBigBlock(final POIFSBigBlockSize bigBlockSize)
    {
       return bigBlockSize.getBigBlockSize() / _block_size;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                byte [] array,
                                                int size)
    {
        SmallDocumentBlock[] rval   =
            new SmallDocumentBlock[ (size + _block_size - 1) / _block_size ];
        int                  offset = 0;

        for (int k = 0; k < rval.length; k++)
        {
            rval[ k ] = new SmallDocumentBlock(bigBlockSize);
            if (offset < array.length)
            {
                int length = Math.min(_block_size, array.length - offset);

                System.arraycopy(array, offset, rval[ k ]._data, 0, length);
                if (length != _block_size)
                {
                    Arrays.fill(rval[ k ]._data, length, _block_size,
                                _default_fill);
                }
            }
            else
            {
                Arrays.fill(rval[ k ]._data, _default_fill);
            }
            offset += _block_size;
        }
        return rval;
    }

    
    public static int fill(POIFSBigBlockSize bigBlockSize, List blocks)
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        int count           = blocks.size();
        int big_block_count = (count + _blocks_per_big_block - 1)
                              / _blocks_per_big_block;
        int full_count      = big_block_count * _blocks_per_big_block;

        for (; count < full_count; count++)
        {
            blocks.add(makeEmptySmallDocumentBlock(bigBlockSize));
        }
        return big_block_count;
    }

    
    public static SmallDocumentBlock [] convert(POIFSBigBlockSize bigBlockSize,
                                                BlockWritable [] store,
                                                int size)
        throws IOException, ArrayIndexOutOfBoundsException
    {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();

        for (int j = 0; j < store.length; j++)
        {
            store[ j ].writeBlocks(stream);
        }
        byte[]               data = stream.toByteArray();
        SmallDocumentBlock[] rval =
            new SmallDocumentBlock[ convertToBlockCount(size) ];

        for (int index = 0; index < rval.length; index++)
        {
            rval[ index ] = new SmallDocumentBlock(bigBlockSize, data, index);
        }
        return rval;
    }

    
    public static List extract(POIFSBigBlockSize bigBlockSize, ListManagedBlock [] blocks)
        throws IOException
    {
        int _blocks_per_big_block = getBlocksPerBigBlock(bigBlockSize);
        
        List sdbs = new ArrayList();

        for (int j = 0; j < blocks.length; j++)
        {
            byte[] data = blocks[ j ].getData();

            for (int k = 0; k < _blocks_per_big_block; k++)
            {
                sdbs.add(new SmallDocumentBlock(bigBlockSize, data, k));
            }
        }
        return sdbs;
    }

    public static DataInputBlock getDataInputBlock(SmallDocumentBlock[] blocks, int offset) {
        int firstBlockIndex = offset >> BLOCK_SHIFT;
        int firstBlockOffset= offset & BLOCK_MASK;
        return new DataInputBlock(blocks[firstBlockIndex]._data, firstBlockOffset);
    }

    
    public static int calcSize(int size)
    {
        return size * _block_size;
    }

    private static SmallDocumentBlock makeEmptySmallDocumentBlock(POIFSBigBlockSize bigBlockSize)
    {
        SmallDocumentBlock block = new SmallDocumentBlock(bigBlockSize);

        Arrays.fill(block._data, _default_fill);
        return block;
    }

    private static int convertToBlockCount(int size)
    {
        return (size + _block_size - 1) / _block_size;
    }

    
    public void writeBlocks(OutputStream stream)
        throws IOException
    {
        stream.write(_data);
    }

    
    public byte [] getData() {
        return _data;
    }
    
    public POIFSBigBlockSize getBigBlockSize() {
       return _bigBlockSize;
    }
}

<code block>


        

package org.apache.poi.poifs.storage;

import java.util.*;



public class SmallDocumentBlockList
    extends BlockListImpl
{

    

    public SmallDocumentBlockList(final List blocks)
    {
        setBlocks(( SmallDocumentBlock [] ) blocks
            .toArray(new SmallDocumentBlock[ blocks.size() ]));
    }
}   


<code block>


        

package org.apache.poi.poifs.storage;



import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;

abstract class BigBlock
    implements BlockWritable
{
    
    protected POIFSBigBlockSize bigBlockSize;
    
    protected BigBlock(POIFSBigBlockSize bigBlockSize) {
       this.bigBlockSize = bigBlockSize;
    }

    

    protected void doWriteData(final OutputStream stream, final byte [] data)
        throws IOException
    {
        stream.write(data);
    }

    

    abstract void writeData(final OutputStream stream)
        throws IOException;

    

    

    public void writeBlocks(final OutputStream stream)
        throws IOException
    {
        writeData(stream);
    }

    
}   


<code block>

package org.apache.poi.poifs.crypt;

import static org.apache.poi.poifs.crypt.EncryptionMode.agile;
import static org.apache.poi.poifs.crypt.EncryptionMode.binaryRC4;
import static org.apache.poi.poifs.crypt.EncryptionMode.cryptoAPI;
import static org.apache.poi.poifs.crypt.EncryptionMode.standard;

import java.io.IOException;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.LittleEndianInput;


public class EncryptionInfo {
    private final int versionMajor;
    private final int versionMinor;
    private final int encryptionFlags;
    
    private final EncryptionHeader header;
    private final EncryptionVerifier verifier;
    private final Decryptor decryptor;
    private final Encryptor encryptor;

    
    public static BitField flagCryptoAPI = BitFieldFactory.getInstance(0x04);

    
    public static BitField flagDocProps = BitFieldFactory.getInstance(0x08);
    
    
    public static BitField flagExternal = BitFieldFactory.getInstance(0x10);
    
    
    public static BitField flagAES = BitFieldFactory.getInstance(0x20);
    
    
    
    public EncryptionInfo(POIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(OPOIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(NPOIFSFileSystem fs) throws IOException {
       this(fs.getRoot());
    }
    
    public EncryptionInfo(DirectoryNode dir) throws IOException {
        this(dir.createDocumentInputStream("EncryptionInfo"), false);
    }

    public EncryptionInfo(LittleEndianInput dis, boolean isCryptoAPI) throws IOException {
        final EncryptionMode encryptionMode;
        versionMajor = dis.readShort();
        versionMinor = dis.readShort();

        if (!isCryptoAPI
            && versionMajor == binaryRC4.versionMajor
            && versionMinor == binaryRC4.versionMinor) {
            encryptionMode = binaryRC4;
            encryptionFlags = -1;
        } else if (!isCryptoAPI
            && versionMajor == agile.versionMajor
            && versionMinor == agile.versionMinor){
            encryptionMode = agile;
            encryptionFlags = dis.readInt();
        } else if (!isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == standard.versionMinor) {
            encryptionMode = standard;
            encryptionFlags = dis.readInt();
        } else if (isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == cryptoAPI.versionMinor) {
            encryptionMode = cryptoAPI;
            encryptionFlags = dis.readInt();
        } else {
            encryptionFlags = dis.readInt();
            throw new EncryptedDocumentException(
                "Unknown encryption: version major: "+versionMajor+
                " / version minor: "+versionMinor+
                " / fCrypto: "+flagCryptoAPI.isSet(encryptionFlags)+
                " / fExternal: "+flagExternal.isSet(encryptionFlags)+
                " / fDocProps: "+flagDocProps.isSet(encryptionFlags)+
                " / fAES: "+flagAES.isSet(encryptionFlags));
        }
        
        EncryptionInfoBuilder eib;
        try {
            eib = getBuilder(encryptionMode);
        } catch (Exception e) {
            throw new IOException(e);
        }

        eib.initialize(this, dis);
        header = eib.getHeader();
        verifier = eib.getVerifier();
        decryptor = eib.getDecryptor();
        encryptor = eib.getEncryptor();
    }
    
    
    @Deprecated
    public EncryptionInfo(POIFSFileSystem fs, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
     
    
    @Deprecated
    public EncryptionInfo(NPOIFSFileSystem fs, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
     
    
    @Deprecated
    public EncryptionInfo(DirectoryNode dir, EncryptionMode encryptionMode) {
        this(encryptionMode);
    }
    
    
    @Deprecated
    public EncryptionInfo(
        POIFSFileSystem fs
      , EncryptionMode encryptionMode
      , CipherAlgorithm cipherAlgorithm
      , HashAlgorithm hashAlgorithm
      , int keyBits
      , int blockSize
      , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }
    
    
    @Deprecated
    public EncryptionInfo(
        NPOIFSFileSystem fs
      , EncryptionMode encryptionMode
      , CipherAlgorithm cipherAlgorithm
      , HashAlgorithm hashAlgorithm
      , int keyBits
      , int blockSize
      , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }
        
    
    @Deprecated
    public EncryptionInfo(
          DirectoryNode dir
        , EncryptionMode encryptionMode
        , CipherAlgorithm cipherAlgorithm
        , HashAlgorithm hashAlgorithm
        , int keyBits
        , int blockSize
        , ChainingMode chainingMode
    ) {
        this(encryptionMode, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }        

    
    public EncryptionInfo(EncryptionMode encryptionMode) {
        this(encryptionMode, null, null, -1, -1, null);
    }
    
    
    public EncryptionInfo(
            EncryptionMode encryptionMode
          , CipherAlgorithm cipherAlgorithm
          , HashAlgorithm hashAlgorithm
          , int keyBits
          , int blockSize
          , ChainingMode chainingMode
      ) {
        versionMajor = encryptionMode.versionMajor;
        versionMinor = encryptionMode.versionMinor;
        encryptionFlags = encryptionMode.encryptionFlags;

        EncryptionInfoBuilder eib;
        try {
            eib = getBuilder(encryptionMode);
        } catch (Exception e) {
            throw new EncryptedDocumentException(e);
        }
        
        eib.initialize(this, cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        
        header = eib.getHeader();
        verifier = eib.getVerifier();
        decryptor = eib.getDecryptor();
        encryptor = eib.getEncryptor();
    }

    protected static EncryptionInfoBuilder getBuilder(EncryptionMode encryptionMode)
    throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        EncryptionInfoBuilder eib;
        eib = (EncryptionInfoBuilder)cl.loadClass(encryptionMode.builder).newInstance();
        return eib;
    }
    
    public int getVersionMajor() {
        return versionMajor;
    }

    public int getVersionMinor() {
        return versionMinor;
    }

    public int getEncryptionFlags() {
        return encryptionFlags;
    }

    public EncryptionHeader getHeader() {
        return header;
    }

    public EncryptionVerifier getVerifier() {
        return verifier;
    }
    
    public Decryptor getDecryptor() {
        return decryptor;
    }

    public Encryptor getEncryptor() {
        return encryptor;
    }
}

<code block>


package org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.nio.charset.Charset;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.DocumentEntry;
import org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;

public class DataSpaceMapUtils {
    public static void addDefaultDataSpace(DirectoryEntry dir) throws IOException {
        DataSpaceMapEntry dsme = new DataSpaceMapEntry(
                new int[]{ 0 }
              , new String[]{ Decryptor.DEFAULT_POIFS_ENTRY }
              , "StrongEncryptionDataSpace"
          );
          DataSpaceMap dsm = new DataSpaceMap(new DataSpaceMapEntry[]{dsme});
          createEncryptionEntry(dir, "\u0006DataSpaces/DataSpaceMap", dsm);

          DataSpaceDefinition dsd = new DataSpaceDefinition(new String[]{ "StrongEncryptionTransform" });
          createEncryptionEntry(dir, "\u0006DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", dsd);

          TransformInfoHeader tih = new TransformInfoHeader(
                1
              , "{FF9A3F03-56EF-4613-BDD5-5A41C1D07246}"
              , "Microsoft.Container.EncryptionTransform"
              , 1, 0, 1, 0, 1, 0
          );
          IRMDSTransformInfo irm = new IRMDSTransformInfo(tih, 0, null);
          createEncryptionEntry(dir, "\u0006DataSpaces/TransformInfo/StrongEncryptionTransform/\u0006Primary", irm);
          
          DataSpaceVersionInfo dsvi = new DataSpaceVersionInfo("Microsoft.Container.DataSpaces", 1, 0, 1, 0, 1, 0);
          createEncryptionEntry(dir, "\u0006DataSpaces/Version", dsvi);
    }
    
    public static DocumentEntry createEncryptionEntry(DirectoryEntry dir, String path, EncryptionRecord out) throws IOException {
        String parts[] = path.split("/");
        for (int i=0; i<parts.length-1; i++) {
            dir = dir.hasEntry(parts[i])
                ? (DirectoryEntry)dir.getEntry(parts[i])
                : dir.createDirectory(parts[i]);
        }
        
        final byte buf[] = new byte[5000];        
        LittleEndianByteArrayOutputStream bos = new LittleEndianByteArrayOutputStream(buf, 0);
        out.write(bos);
        
        String fileName = parts[parts.length-1];
        
        if (dir.hasEntry(fileName)) {
            dir.getEntry(fileName).delete();
        }
        
        return dir.createDocument(fileName, bos.getWriteIndex(), new POIFSWriterListener(){
            public void processPOIFSWriterEvent(POIFSWriterEvent event) {
                try {
                    event.getStream().write(buf, 0, event.getLimit());
                } catch (IOException e) {
                    throw new EncryptedDocumentException(e);
                }
            }
        });
    }   
    
    public static class DataSpaceMap implements EncryptionRecord {
        DataSpaceMapEntry entries[];
        
        public DataSpaceMap(DataSpaceMapEntry entries[]) {
            this.entries = entries;
        }
        
        public DataSpaceMap(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            int entryCount = is.readInt();
            entries = new DataSpaceMapEntry[entryCount];
            for (int i=0; i<entryCount; i++) {
                entries[i] = new DataSpaceMapEntry(is);
            }
        }
    
        public void write(LittleEndianByteArrayOutputStream os) {
            os.writeInt(8);
            os.writeInt(entries.length);
            for (DataSpaceMapEntry dsme : entries) {
                dsme.write(os);
            }
        }
    }
    
    public static class DataSpaceMapEntry implements EncryptionRecord {
        int referenceComponentType[];
        String referenceComponent[];
        String dataSpaceName;
        
        public DataSpaceMapEntry(int referenceComponentType[], String referenceComponent[], String dataSpaceName) {
            this.referenceComponentType = referenceComponentType;
            this.referenceComponent = referenceComponent;
            this.dataSpaceName = dataSpaceName;
        }
        
        public DataSpaceMapEntry(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            int referenceComponentCount = is.readInt();
            referenceComponentType = new int[referenceComponentCount];
            referenceComponent = new String[referenceComponentCount];
            for (int i=0; i<referenceComponentCount; i++) {
                referenceComponentType[i] = is.readInt();
                referenceComponent[i] = readUnicodeLPP4(is);
            }
            dataSpaceName = readUnicodeLPP4(is);
        }
        
        public void write(LittleEndianByteArrayOutputStream os) {
            int start = os.getWriteIndex();
            LittleEndianOutput sizeOut = os.createDelayedOutput(LittleEndianConsts.INT_SIZE);
            os.writeInt(referenceComponent.length);
            for (int i=0; i<referenceComponent.length; i++) {
                os.writeInt(referenceComponentType[i]);
                writeUnicodeLPP4(os, referenceComponent[i]);
            }
            writeUnicodeLPP4(os, dataSpaceName);
            sizeOut.writeInt(os.getWriteIndex()-start);
        }
    }
    
    public static class DataSpaceDefinition implements EncryptionRecord {
        String transformer[];
        
        public DataSpaceDefinition(String transformer[]) {
            this.transformer = transformer;
        }
        
        public DataSpaceDefinition(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int headerLength = is.readInt();
            int transformReferenceCount = is.readInt();
            transformer = new String[transformReferenceCount];
            for (int i=0; i<transformReferenceCount; i++) {
                transformer[i] = readUnicodeLPP4(is);
            }
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            bos.writeInt(8);
            bos.writeInt(transformer.length);
            for (String str : transformer) {
                writeUnicodeLPP4(bos, str);
            }
        }
    }
    
    public static class IRMDSTransformInfo implements EncryptionRecord {
        TransformInfoHeader transformInfoHeader;
        int extensibilityHeader;
        String xrMLLicense;
        
        public IRMDSTransformInfo(TransformInfoHeader transformInfoHeader, int extensibilityHeader, String xrMLLicense) {
            this.transformInfoHeader = transformInfoHeader;
            this.extensibilityHeader = extensibilityHeader;
            this.xrMLLicense = xrMLLicense;
        }
        
        public IRMDSTransformInfo(LittleEndianInput is) {
            transformInfoHeader = new TransformInfoHeader(is);
            extensibilityHeader = is.readInt();
            xrMLLicense = readUtf8LPP4(is);
            
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            transformInfoHeader.write(bos);
            bos.writeInt(extensibilityHeader);
            writeUtf8LPP4(bos, xrMLLicense);
            bos.writeInt(4); 
        }
    }
    
    public static class TransformInfoHeader implements EncryptionRecord {
        int transformType;
        String transformerId;
        String transformerName;
        int readerVersionMajor = 1, readerVersionMinor = 0;
        int updaterVersionMajor = 1, updaterVersionMinor = 0;
        int writerVersionMajor = 1, writerVersionMinor = 0;

        public TransformInfoHeader(
            int transformType,
            String transformerId,
            String transformerName,
            int readerVersionMajor, int readerVersionMinor,
            int updaterVersionMajor, int updaterVersionMinor,
            int writerVersionMajor, int writerVersionMinor                
        ){
            this.transformType = transformType;
            this.transformerId = transformerId;
            this.transformerName = transformerName;
            this.readerVersionMajor = readerVersionMajor;
            this.readerVersionMinor = readerVersionMinor;
            this.updaterVersionMajor = updaterVersionMajor;
            this.updaterVersionMinor = updaterVersionMinor;
            this.writerVersionMajor = writerVersionMajor;
            this.writerVersionMinor = writerVersionMinor;
        }
        
        public TransformInfoHeader(LittleEndianInput is) {
            @SuppressWarnings("unused")
            int length = is.readInt();
            transformType = is.readInt();
            transformerId = readUnicodeLPP4(is);
            transformerName = readUnicodeLPP4(is);
            readerVersionMajor = is.readShort();
            readerVersionMinor = is.readShort();
            updaterVersionMajor = is.readShort();
            updaterVersionMinor = is.readShort();
            writerVersionMajor = is.readShort();
            writerVersionMinor = is.readShort();
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            int start = bos.getWriteIndex();
            LittleEndianOutput sizeOut = bos.createDelayedOutput(LittleEndianConsts.INT_SIZE);
            bos.writeInt(transformType);
            writeUnicodeLPP4(bos, transformerId);
            sizeOut.writeInt(bos.getWriteIndex()-start);
            writeUnicodeLPP4(bos, transformerName);
            bos.writeShort(readerVersionMajor);
            bos.writeShort(readerVersionMinor); 
            bos.writeShort(updaterVersionMajor);
            bos.writeShort(updaterVersionMinor);
            bos.writeShort(writerVersionMajor); 
            bos.writeShort(writerVersionMinor); 
        }
    }
    
    public static class DataSpaceVersionInfo implements EncryptionRecord {
        String featureIdentifier;
        int readerVersionMajor = 1, readerVersionMinor = 0;
        int updaterVersionMajor = 1, updaterVersionMinor = 0;
        int writerVersionMajor = 1, writerVersionMinor = 0;
        
        public DataSpaceVersionInfo(LittleEndianInput is) {
            featureIdentifier = readUnicodeLPP4(is);
            readerVersionMajor = is.readShort();
            readerVersionMinor = is.readShort();
            updaterVersionMajor = is.readShort();
            updaterVersionMinor = is.readShort();
            writerVersionMajor = is.readShort();
            writerVersionMinor = is.readShort();
        }
        
        public DataSpaceVersionInfo(
            String featureIdentifier,
            int readerVersionMajor, int readerVersionMinor,
            int updaterVersionMajor, int updaterVersionMinor,
            int writerVersionMajor, int writerVersionMinor                
        ){
            this.featureIdentifier = featureIdentifier;
            this.readerVersionMajor = readerVersionMajor;
            this.readerVersionMinor = readerVersionMinor;
            this.updaterVersionMajor = updaterVersionMajor;
            this.updaterVersionMinor = updaterVersionMinor;
            this.writerVersionMajor = writerVersionMajor;
            this.writerVersionMinor = writerVersionMinor;
        }
        
        public void write(LittleEndianByteArrayOutputStream bos) {
            writeUnicodeLPP4(bos, featureIdentifier);
            bos.writeShort(readerVersionMajor);
            bos.writeShort(readerVersionMinor); 
            bos.writeShort(updaterVersionMajor);
            bos.writeShort(updaterVersionMinor);
            bos.writeShort(writerVersionMajor); 
            bos.writeShort(writerVersionMinor); 
        }
    }
    
    public static String readUnicodeLPP4(LittleEndianInput is) {
        int length = is.readInt();
        if (length%2 != 0) {
            throw new EncryptedDocumentException(
                "UNICODE-LP-P4 structure is a multiple of 4 bytes. "
                + "If Padding is present, it MUST be exactly 2 bytes long");
        }
        
        String result = StringUtil.readUnicodeLE(is, length/2);
        if (length%4==2) {
            
            
            
            is.readShort();
        }
        
        return result;
    }
    
    public static void writeUnicodeLPP4(LittleEndianOutput os, String string) {
        byte buf[] = StringUtil.getToUnicodeLE(string);
        os.writeInt(buf.length);
        os.write(buf);
        if (buf.length%4==2) {
            os.writeShort(0);
        }
    }

    public static String readUtf8LPP4(LittleEndianInput is) {
        int length = is.readInt();
        if (length == 0 || length == 4) {
            @SuppressWarnings("unused")
            int skip = is.readInt(); 
            return length == 0 ? null : "";
        }
        
        byte data[] = new byte[length];
        is.readFully(data);

        
        
        
        
        
        int scratchedBytes = length%4;
        if (scratchedBytes > 0) {
            for (int i=0; i<(4-scratchedBytes); i++) {
                is.readByte();
            }
        }

        return new String(data, 0, data.length, Charset.forName("UTF-8"));
    }
    
    public static void writeUtf8LPP4(LittleEndianOutput os, String str) {
        if (str == null || "".equals(str)) {
            os.writeInt(str == null ? 0 : 4);
            os.writeInt(0);
        } else {
            byte buf[] = str.getBytes(Charset.forName("UTF-8"));
            os.writeInt(buf.length);
            os.write(buf);
            int scratchBytes = buf.length%4;
            if (scratchBytes > 0) {
                for (int i=0; i<(4-scratchBytes); i++) {
                    os.writeByte(0);
                }
            }
        }        
    }

}

<code block>

package org.apache.poi.poifs.crypt;



public abstract class EncryptionVerifier {
    private byte[] salt;
    private byte[] encryptedVerifier;
    private byte[] encryptedVerifierHash;
    private byte[] encryptedKey;
    
    private int spinCount;
    private CipherAlgorithm cipherAlgorithm;
    private ChainingMode chainingMode;
    private HashAlgorithm hashAlgorithm;
    
    protected EncryptionVerifier() {}

    public byte[] getSalt() {
        return salt;
    }

    
    @Deprecated
    public byte[] getVerifier() {
        return encryptedVerifier;
    }

    public byte[] getEncryptedVerifier() {
        return encryptedVerifier;
    }    
    
    
    @Deprecated
    public byte[] getVerifierHash() {
        return encryptedVerifierHash;
    }

    public byte[] getEncryptedVerifierHash() {
        return encryptedVerifierHash;
    }    
    
    public int getSpinCount() {
        return spinCount;
    }

    public int getCipherMode() {
        return chainingMode.ecmaId;
    }

    public int getAlgorithm() {
        return cipherAlgorithm.ecmaId;
    }

    
    @Deprecated
    public String getAlgorithmName() {
        return cipherAlgorithm.jceId;
    }

    public byte[] getEncryptedKey() {
        return encryptedKey;
    }
    
    public CipherAlgorithm getCipherAlgorithm() {
        return cipherAlgorithm;
    }
    
    public HashAlgorithm getHashAlgorithm() {
        return hashAlgorithm;
    }
    
    public ChainingMode getChainingMode() {
        return chainingMode;
    }

    protected void setSalt(byte[] salt) {
        this.salt = salt;
    }

    protected void setEncryptedVerifier(byte[] encryptedVerifier) {
        this.encryptedVerifier = encryptedVerifier;
    }

    protected void setEncryptedVerifierHash(byte[] encryptedVerifierHash) {
        this.encryptedVerifierHash = encryptedVerifierHash;
    }

    protected void setEncryptedKey(byte[] encryptedKey) {
        this.encryptedKey = encryptedKey;
    }

    protected void setSpinCount(int spinCount) {
        this.spinCount = spinCount;
    }

    protected void setCipherAlgorithm(CipherAlgorithm cipherAlgorithm) {
        this.cipherAlgorithm = cipherAlgorithm;
    }

    protected void setChainingMode(ChainingMode chainingMode) {
        this.chainingMode = chainingMode;
    }

    protected void setHashAlgorithm(HashAlgorithm hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
    }
    
    
}

<code block>

package org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;

import javax.crypto.SecretKey;

import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;

public abstract class Encryptor {
    protected static final String DEFAULT_POIFS_ENTRY = Decryptor.DEFAULT_POIFS_ENTRY;
    private SecretKey secretKey;
    
    
    public abstract OutputStream getDataStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException;

    
    public abstract void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]);
    
    public abstract void confirmPassword(String password);
	
	public static Encryptor getInstance(EncryptionInfo info) {
	    return info.getEncryptor();
    }

    public OutputStream getDataStream(NPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public OutputStream getDataStream(OPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public OutputStream getDataStream(POIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }

    public SecretKey getSecretKey() {
        return secretKey;
    }

    protected void setSecretKey(SecretKey secretKey) {
        this.secretKey = secretKey;
    }
}

<code block>


package org.apache.poi.poifs.crypt;




public enum EncryptionMode {
    
    binaryRC4("org.apache.poi.poifs.crypt.binaryrc4.BinaryRC4EncryptionInfoBuilder", 1, 1, 0x0),
    
    cryptoAPI("org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIEncryptionInfoBuilder", 4, 2, 0x04),
    
    standard("org.apache.poi.poifs.crypt.standard.StandardEncryptionInfoBuilder", 4, 2, 0x24),
    
    agile("org.apache.poi.poifs.crypt.agile.AgileEncryptionInfoBuilder", 4, 4, 0x40)
    ;
    
    public final String builder;
    public final int versionMajor;
    public final int versionMinor;
    public final int encryptionFlags;
    
    EncryptionMode(String builder, int versionMajor, int versionMinor, int encryptionFlags) {
        this.builder = builder;
        this.versionMajor = versionMajor;
        this.versionMinor = versionMinor;
        this.encryptionFlags = encryptionFlags;
    }
}

<code block>

package org.apache.poi.poifs.crypt;



public abstract class EncryptionHeader {
    public static final int ALGORITHM_RC4 = CipherAlgorithm.rc4.ecmaId;
    public static final int ALGORITHM_AES_128 = CipherAlgorithm.aes128.ecmaId;
    public static final int ALGORITHM_AES_192 = CipherAlgorithm.aes192.ecmaId;
    public static final int ALGORITHM_AES_256 = CipherAlgorithm.aes256.ecmaId;
    
    public static final int HASH_NONE   = HashAlgorithm.none.ecmaId;
    public static final int HASH_SHA1   = HashAlgorithm.sha1.ecmaId;
    public static final int HASH_SHA256 = HashAlgorithm.sha256.ecmaId;
    public static final int HASH_SHA384 = HashAlgorithm.sha384.ecmaId;
    public static final int HASH_SHA512 = HashAlgorithm.sha512.ecmaId;

    public static final int PROVIDER_RC4 = CipherProvider.rc4.ecmaId;
    public static final int PROVIDER_AES = CipherProvider.aes.ecmaId;

    public static final int MODE_ECB = ChainingMode.ecb.ecmaId;
    public static final int MODE_CBC = ChainingMode.cbc.ecmaId;
    public static final int MODE_CFB = ChainingMode.cfb.ecmaId;
    
    private int flags;
    private int sizeExtra;
    private CipherAlgorithm cipherAlgorithm;
    private HashAlgorithm hashAlgorithm;
    private int keyBits;
    private int blockSize;
    private CipherProvider providerType;
    private ChainingMode chainingMode;
    private byte[] keySalt;
    private String cspName;
    
    protected EncryptionHeader() {}

    
    public int getCipherMode() {
        return chainingMode.ecmaId;
    }
    
    public ChainingMode getChainingMode() {
        return chainingMode;
    }
    
    protected void setChainingMode(ChainingMode chainingMode) {
        this.chainingMode = chainingMode;
    }

    public int getFlags() {
        return flags;
    }
    
    protected void setFlags(int flags) {
        this.flags = flags;
    }

    public int getSizeExtra() {
        return sizeExtra;
    }
    
    protected void setSizeExtra(int sizeExtra) {
        this.sizeExtra = sizeExtra;
    }

    
    public int getAlgorithm() {
        return cipherAlgorithm.ecmaId;
    }

    public CipherAlgorithm getCipherAlgorithm() {
        return cipherAlgorithm;
    }
    
    protected void setCipherAlgorithm(CipherAlgorithm cipherAlgorithm) {
        this.cipherAlgorithm = cipherAlgorithm;
    }
    
    
    public int getHashAlgorithm() {
        return hashAlgorithm.ecmaId;
    }
    
    public HashAlgorithm getHashAlgorithmEx() {
        return hashAlgorithm;
    }
    
    protected void setHashAlgorithm(HashAlgorithm hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
    }

    public int getKeySize() {
        return keyBits;
    }
    
    protected void setKeySize(int keyBits) {
        this.keyBits = keyBits;
    }

    public int getBlockSize() {
    	return blockSize;
    }
    
    protected void setBlockSize(int blockSize) {
        this.blockSize = blockSize;
    }
    
    public byte[] getKeySalt() {
        return keySalt;
    }
    
    protected void setKeySalt(byte salt[]) {
        this.keySalt = salt;
    }

    
    public int getProviderType() {
        return providerType.ecmaId;
    }

    public CipherProvider getCipherProvider() {
        return providerType;
    }    

    protected void setCipherProvider(CipherProvider providerType) {
        this.providerType = providerType;
    }
    
    public String getCspName() {
        return cspName;
    }
    
    protected void setCspName(String cspName) {
        this.cspName = cspName;
    }
}

<code block>

package org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;

import javax.crypto.SecretKey;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.OPOIFSFileSystem;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;

public abstract class Decryptor {
    public static final String DEFAULT_PASSWORD="VelvetSweatshop";
    public static final String DEFAULT_POIFS_ENTRY="EncryptedPackage";
    
    protected final EncryptionInfoBuilder builder;
    private SecretKey secretKey;
    private byte[] verifier, integrityHmacKey, integrityHmacValue;

    protected Decryptor(EncryptionInfoBuilder builder) {
        this.builder = builder;
    }
    
    
    public abstract InputStream getDataStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException;

    public abstract boolean verifyPassword(String password)
        throws GeneralSecurityException;

    
    public abstract long getLength();

    public static Decryptor getInstance(EncryptionInfo info) {
        Decryptor d = info.getDecryptor();
        if (d == null) {
            throw new EncryptedDocumentException("Unsupported version");
        }
        return d;
    }

    public InputStream getDataStream(NPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public InputStream getDataStream(OPOIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    public InputStream getDataStream(POIFSFileSystem fs) throws IOException, GeneralSecurityException {
        return getDataStream(fs.getRoot());
    }
    
    
    public byte[] getVerifier() {
        return verifier;
    }

    public SecretKey getSecretKey() {
        return secretKey;
    }
    
    public byte[] getIntegrityHmacKey() {
        return integrityHmacKey;
    }

    public byte[] getIntegrityHmacValue() {
        return integrityHmacValue;
    }

    protected void setSecretKey(SecretKey secretKey) {
        this.secretKey = secretKey;
    }

    protected void setVerifier(byte[] verifier) {
        this.verifier = verifier;
    }

    protected void setIntegrityHmacKey(byte[] integrityHmacKey) {
        this.integrityHmacKey = integrityHmacKey;
    }

    protected void setIntegrityHmacValue(byte[] integrityHmacValue) {
        this.integrityHmacValue = integrityHmacValue;
    }

    protected int getBlockSizeInBytes() {
        return builder.getHeader().getBlockSize();
    }
    
    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize()/8;
    }
}
<code block>

package org.apache.poi.poifs.crypt;

import java.nio.charset.Charset;
import java.security.DigestException;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.Provider;
import java.security.Security;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.RC2ParameterSpec;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.StringUtil;


public class CryptoFunctions {
    
    public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount) {
        return hashPassword(password, hashAlgorithm, salt, spinCount, true);
    }
        
    
    public static byte[] hashPassword(String password, HashAlgorithm hashAlgorithm, byte salt[], int spinCount, boolean iteratorFirst) {
        
        if (password == null) {
            password = Decryptor.DEFAULT_PASSWORD;
        }
        
        MessageDigest hashAlg = getMessageDigest(hashAlgorithm);
        
        hashAlg.update(salt);
        byte[] hash = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];

        byte[] first = (iteratorFirst ? iterator : hash);
        byte[] second = (iteratorFirst ? hash : iterator);
        
        try {
            for (int i = 0; i < spinCount; i++) {
                LittleEndian.putInt(iterator, 0, i);
                hashAlg.reset();
                hashAlg.update(first);
                hashAlg.update(second);
                hashAlg.digest(hash, 0, hash.length); 
            }
        } catch (DigestException e) {
            throw new EncryptedDocumentException("error in password hashing");
        }
        
        return hash;
    }    

    
    public static byte[] generateIv(HashAlgorithm hashAlgorithm, byte[] salt, byte[] blockKey, int blockSize) {
        byte iv[] = salt;
        if (blockKey != null) {
            MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
            hashAlgo.update(salt);
            iv = hashAlgo.digest(blockKey);
        }
        return getBlock36(iv, blockSize);
    }

    
    public static byte[] generateKey(byte[] passwordHash, HashAlgorithm hashAlgorithm, byte[] blockKey, int keySize) {
        MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
        hashAlgo.update(passwordHash);
        byte[] key = hashAlgo.digest(blockKey);
        return getBlock36(key, keySize);
    }

    public static Cipher getCipher(SecretKey key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode) {
        return getCipher(key, cipherAlgorithm, chain, vec, cipherMode, null);
    }

    
    public static Cipher getCipher(Key key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, byte[] vec, int cipherMode, String padding) {
        int keySizeInBytes = key.getEncoded().length;
        if (padding == null) padding = "NoPadding";
        
        try {
            
            if (Cipher.getMaxAllowedKeyLength(cipherAlgorithm.jceId) < keySizeInBytes*8) {
                throw new EncryptedDocumentException("Export Restrictions in place - please install JCE Unlimited Strength Jurisdiction Policy files");
            }

            Cipher cipher;
            if (cipherAlgorithm == CipherAlgorithm.rc4) {
                cipher = Cipher.getInstance(cipherAlgorithm.jceId);
            } else if (cipherAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding, "BC");
            } else {
                cipher = Cipher.getInstance(cipherAlgorithm.jceId + "/" + chain.jceId + "/" + padding);
            }
            
            if (vec == null) {
                cipher.init(cipherMode, key);
            } else {
                AlgorithmParameterSpec aps;
                if (cipherAlgorithm == CipherAlgorithm.rc2) {
                    aps = new RC2ParameterSpec(key.getEncoded().length*8, vec);
                } else {
                    aps = new IvParameterSpec(vec);
                }
                cipher.init(cipherMode, key, aps);
            }
            return cipher;
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }    
    
    
    public static byte[] getBlock36(byte[] hash, int size) {
        return getBlockX(hash, size, (byte)0x36);
    }

    
    public static byte[] getBlock0(byte[] hash, int size) {
        return getBlockX(hash, size, (byte)0);
    }
    
    private static byte[] getBlockX(byte[] hash, int size, byte fill) {
        if (hash.length == size) return hash;
        
        byte[] result = new byte[size];
        Arrays.fill(result, fill);
        System.arraycopy(hash, 0, result, 0, Math.min(result.length, hash.length));
        return result;
    }
    
    public static MessageDigest getMessageDigest(HashAlgorithm hashAlgorithm) {
        try {
            if (hashAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                return MessageDigest.getInstance(hashAlgorithm.jceId, "BC");
            } else {
                return MessageDigest.getInstance(hashAlgorithm.jceId);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("hash algo not supported", e);
        }
    }
    
    public static Mac getMac(HashAlgorithm hashAlgorithm) {
        try {
            if (hashAlgorithm.needsBouncyCastle) {
                registerBouncyCastle();
                return Mac.getInstance(hashAlgorithm.jceHmacId, "BC");
            } else {
                return Mac.getInstance(hashAlgorithm.jceHmacId);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("hmac algo not supported", e);
        }
    }

    @SuppressWarnings("unchecked")
    public static void registerBouncyCastle() {
        if (Security.getProvider("BC") != null) return;
        try {
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            String bcProviderName = "org.bouncycastle.jce.provider.BouncyCastleProvider";
            Class<Provider> clazz = (Class<Provider>)cl.loadClass(bcProviderName);
            Security.addProvider(clazz.newInstance());
        } catch (Exception e) {
            throw new EncryptedDocumentException("Only the BouncyCastle provider supports your encryption settings - please add it to the classpath.");
        }
    }

    private static final int InitialCodeArray[] = { 
        0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 
        0x313E, 0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 
        0x4EC3
    };

    private static final byte PadArray[] = {
        (byte)0xBB, (byte)0xFF, (byte)0xFF, (byte)0xBA, (byte)0xFF,
        (byte)0xFF, (byte)0xB9, (byte)0x80, (byte)0x00, (byte)0xBE,
        (byte)0x0F, (byte)0x00, (byte)0xBF, (byte)0x0F, (byte)0x00
    };
    
    private static final int EncryptionMatrix[][] = {
         {0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09},
         {0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF},
         {0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0},
         {0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40},
         {0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5},
         {0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A},
         {0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9},
         {0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0},
         {0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC},
         {0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10},
         {0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168},
         {0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C},
         {0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD},
         {0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC},
         {0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4}
    };

    
    public static int createXorVerifier2(String password) {
        
        byte[] generatedKey = new byte[4];

        
        final int maxPasswordLength = 15; 
        
        if (!"".equals(password)) {
            
            password = password.substring(0, Math.min(password.length(), maxPasswordLength));

            
            
            
            byte[] arrByteChars = new byte[password.length()];
            
            for (int i = 0; i < password.length(); i++) {
                int intTemp = password.charAt(i);
                byte lowByte = (byte)(intTemp & 0x00FF);
                byte highByte = (byte)((intTemp & 0xFF00) >> 8);
                arrByteChars[i] = (lowByte != 0 ? lowByte : highByte);
            }

            

            
            int highOrderWord = InitialCodeArray[arrByteChars.length - 1];

            
            
            
            
            for (int i = 0; i < arrByteChars.length; i++) {
                int tmp = maxPasswordLength - arrByteChars.length + i;
                for (int intBit = 0; intBit < 7; intBit++) {
                    if ((arrByteChars[i] & (0x0001 << intBit)) != 0) {
                        highOrderWord ^= EncryptionMatrix[tmp][intBit];
                    }
                }
            }
            
            
            
            
            short verifier = 0;

            
            for (int i = arrByteChars.length-1; i >= 0; i--) {
                
                verifier = rotateLeftBase15Bit(verifier);
                verifier ^= arrByteChars[i];
            }

            
            
            verifier = rotateLeftBase15Bit(verifier);
            verifier ^= arrByteChars.length;
            
            
            verifier ^= 0xCE4B; 

            
            
            
            LittleEndian.putShort(generatedKey, 0, verifier);
            LittleEndian.putShort(generatedKey, 2, (short)highOrderWord);
        }
        
        return LittleEndian.getInt(generatedKey);
    }

    
    public static String xorHashPassword(String password) {
        int hashedPassword = createXorVerifier2(password);
        return String.format("%1$08X", hashedPassword);
    }
    
    
    public static String xorHashPasswordReversed(String password) {
        int hashedPassword = createXorVerifier2(password);
        
        return String.format("%1$02X%2$02X%3$02X%4$02X"
            , ( hashedPassword >>> 0 ) & 0xFF
            , ( hashedPassword >>> 8 ) & 0xFF
            , ( hashedPassword >>> 16 ) & 0xFF
            , ( hashedPassword >>> 24 ) & 0xFF
        );
    }

    
    public static int createXorVerifier1(String password) {
        
        
        return createXorVerifier2(password) & 0xFFFF;
    }
 
    
    public static int createXorKey1(String password) {
        
        
        return createXorVerifier2(password) >>> 16;
    }

    
    public static byte[] createXorArray1(String password) {
        if (password.length() > 15) password = password.substring(0, 15);
        byte passBytes[] = password.getBytes(Charset.forName("ASCII"));
        
        
        
        byte obfuscationArray[] = new byte[16];
        System.arraycopy(passBytes, 0, obfuscationArray, 0, passBytes.length);
        System.arraycopy(PadArray, 0, obfuscationArray, passBytes.length, PadArray.length-passBytes.length+1);
        
        int xorKey = createXorKey1(password);
        
        
        int nRotateSize = 2; 
        
        byte baseKeyLE[] = { (byte)(xorKey & 0xFF), (byte)((xorKey >>> 8) & 0xFF) };
        for (int i=0; i<obfuscationArray.length; i++) {
            obfuscationArray[i] ^= baseKeyLE[i&1];
            obfuscationArray[i] = rotateLeft(obfuscationArray[i], nRotateSize);
        }
        
        return obfuscationArray;
    }

    private static byte rotateLeft(byte bits, int shift) {
        return (byte)(((bits & 0xff) << shift) | ((bits & 0xff) >>> (8 - shift)));
    }
    
    private static short rotateLeftBase15Bit(short verifier) {
        
        short intermediate1 = (short)(((verifier & 0x4000) == 0) ? 0 : 1);
        
        short intermediate2 = (short)((verifier<<1) & 0x7FFF);
        
        short intermediate3 = (short)(intermediate1 | intermediate2);
        return intermediate3;
    }
}

<code block>


package org.apache.poi.poifs.crypt;

import org.apache.poi.EncryptedDocumentException;



public enum CipherProvider {
    rc4("RC4", 1, "Microsoft Base Cryptographic Provider v1.0"),
    aes("AES", 0x18, "Microsoft Enhanced RSA and AES Cryptographic Provider");

    public static CipherProvider fromEcmaId(int ecmaId) {
        for (CipherProvider cp : CipherProvider.values()) {
            if (cp.ecmaId == ecmaId) return cp;
        }
        throw new EncryptedDocumentException("cipher provider not found");
    }    
    
    public final String jceId;
    public final int ecmaId;
    public final String cipherProviderName;
    CipherProvider(String jceId, int ecmaId, String cipherProviderName) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.cipherProviderName = cipherProviderName;
    }
}
<code block>

package org.apache.poi.poifs.crypt;

import static org.apache.poi.poifs.crypt.Decryptor.DEFAULT_POIFS_ENTRY;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.TempFile;

@Internal
public abstract class ChunkedCipherOutputStream extends FilterOutputStream {
    protected final int chunkSize;
    protected final int chunkMask;
    protected final int chunkBits;
    
    private final byte[] _chunk;
    private final File fileOut;
    private final DirectoryNode dir;

    private long _pos = 0;
    private Cipher _cipher;
    
    public ChunkedCipherOutputStream(DirectoryNode dir, int chunkSize) throws IOException, GeneralSecurityException {
        super(null);
        this.chunkSize = chunkSize;
        chunkMask = chunkSize-1;
        chunkBits = Integer.bitCount(chunkMask);
        _chunk = new byte[chunkSize];

        fileOut = TempFile.createTempFile("encrypted_package", "crypt");
        fileOut.deleteOnExit();
        this.out = new FileOutputStream(fileOut);
        this.dir = dir;
        _cipher = initCipherForBlock(null, 0, false);
    }

    protected abstract Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk)
    throws GeneralSecurityException;    
    
    protected abstract void calculateChecksum(File fileOut, int oleStreamSize)
    throws GeneralSecurityException, IOException;
    
    protected abstract void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
    throws IOException, GeneralSecurityException;

    public void write(int b) throws IOException {
        write(new byte[]{(byte)b});
    }

    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }

    public void write(byte[] b, int off, int len)
    throws IOException {
        if (len == 0) return;
        
        if (len < 0 || b.length < off+len) {
            throw new IOException("not enough bytes in your input buffer");
        }
        
        while (len > 0) {
            int posInChunk = (int)(_pos & chunkMask);
            int nextLen = Math.min(chunkSize-posInChunk, len);
            System.arraycopy(b, off, _chunk, posInChunk, nextLen);
            _pos += nextLen;
            off += nextLen;
            len -= nextLen;
            if ((_pos & chunkMask) == 0) {
                try {
                    writeChunk();
                } catch (GeneralSecurityException e) {
                    throw new IOException(e);
                }
            }
        }
    }

    protected void writeChunk() throws IOException, GeneralSecurityException {
        int posInChunk = (int)(_pos & chunkMask);
        
        
        int index = (int)(_pos >> chunkBits);
        boolean lastChunk;
        if (posInChunk==0) {
            index--;
            posInChunk = chunkSize;
            lastChunk = false;
        } else {
            
            lastChunk = true;
        }

        _cipher = initCipherForBlock(_cipher, index, lastChunk);

        int ciLen = _cipher.doFinal(_chunk, 0, posInChunk, _chunk);
        out.write(_chunk, 0, ciLen);
    }
    
    public void close() throws IOException {
        try {
            writeChunk();

            super.close();
            
            int oleStreamSize = (int)(fileOut.length()+LittleEndianConsts.LONG_SIZE);
            calculateChecksum(fileOut, oleStreamSize);
            dir.createDocument(DEFAULT_POIFS_ENTRY, oleStreamSize, new EncryptedPackageWriter());
            createEncryptionInfoEntry(dir, fileOut);
        } catch (GeneralSecurityException e) {
            throw new IOException(e);
        }
    }

    private class EncryptedPackageWriter implements POIFSWriterListener {
        public void processPOIFSWriterEvent(POIFSWriterEvent event) {
            try {
                OutputStream os = event.getStream();
                byte buf[] = new byte[chunkSize];
    
                
                
                
                
                LittleEndian.putLong(buf, 0, _pos);
                os.write(buf, 0, LittleEndian.LONG_SIZE);

                FileInputStream fis = new FileInputStream(fileOut);
                int readBytes;
                while ((readBytes = fis.read(buf)) != -1) {
                    os.write(buf, 0, readBytes);
                }
                fis.close();

                os.close();
                
                fileOut.delete();
            } catch (IOException e) {
                throw new EncryptedDocumentException(e);
            }
        }
    }
}

<code block>


package org.apache.poi.poifs.crypt;

public enum ChainingMode {
    
    ecb("ECB", 1),
    cbc("CBC", 2),
    
    cfb("CFB8", 3);

    public final String jceId;
    public final int ecmaId;
    ChainingMode(String jceId, int ecmaId) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
    }
}
<code block>

package org.apache.poi.poifs.crypt;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianInputStream;

@Internal
public abstract class ChunkedCipherInputStream extends LittleEndianInputStream {
    private final int chunkSize;
    private final int chunkMask;
    private final int chunkBits;
    
    private int _lastIndex = 0;
    private long _pos = 0;
    private long _size;
    private byte[] _chunk;
    private Cipher _cipher;

    public ChunkedCipherInputStream(LittleEndianInput stream, long size, int chunkSize)
        throws GeneralSecurityException {
        super((InputStream)stream);
        _size = size;
        this.chunkSize = chunkSize;
        chunkMask = chunkSize-1;
        chunkBits = Integer.bitCount(chunkMask);
        
        _cipher = initCipherForBlock(null, 0);
    }
    
    protected abstract Cipher initCipherForBlock(Cipher existing, int block)
    throws GeneralSecurityException;

    public int read() throws IOException {
        byte[] b = new byte[1];
        if (read(b) == 1)
            return b[0];
        return -1;
    }

    
    

    public int read(byte[] b, int off, int len) throws IOException {
        int total = 0;
        
        if (available() <= 0) return -1;

        while (len > 0) {
            if (_chunk == null) {
                try {
                    _chunk = nextChunk();
                } catch (GeneralSecurityException e) {
                    throw new EncryptedDocumentException(e.getMessage(), e);
                }
            }
            int count = (int)(chunkSize - (_pos & chunkMask));
            int avail = available();
            if (avail == 0) {
                return total;
            }
            count = Math.min(avail, Math.min(count, len));
            System.arraycopy(_chunk, (int)(_pos & chunkMask), b, off, count);
            off += count;
            len -= count;
            _pos += count;
            if ((_pos & chunkMask) == 0)
                _chunk = null;
            total += count;
        }

        return total;
    }

    @Override
    public long skip(long n) throws IOException {
        long start = _pos;
        long skip = Math.min(available(), n);

        if ((((_pos + skip) ^ start) & ~chunkMask) != 0)
            _chunk = null;
        _pos += skip;
        return skip;
    }

    @Override
    public int available() {
        return (int)(_size - _pos);
    }
    
    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public synchronized void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }
    
    @Override
    public synchronized void reset() throws IOException {
        throw new UnsupportedOperationException();
    }

    private byte[] nextChunk() throws GeneralSecurityException, IOException {
        int index = (int)(_pos >> chunkBits);
        initCipherForBlock(_cipher, index);
        
        if (_lastIndex != index) {
            super.skip((index - _lastIndex) << chunkBits);
        }

        byte[] block = new byte[Math.min(super.available(), chunkSize)];
        super.read(block, 0, block.length);
        _lastIndex = index + 1;
        return _cipher.doFinal(block);
    }
}

<code block>


package org.apache.poi.poifs.crypt;

import org.apache.poi.EncryptedDocumentException;



public enum CipherAlgorithm {
    
    
    rc4(CipherProvider.rc4,    "RC4", 0x6801, 0x40, new int[]{0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80}, -1, 20, "RC4", false),
    
    aes128(CipherProvider.aes, "AES", 0x660E, 128, new int[]{128}, 16, 32, "AES", false),
    aes192(CipherProvider.aes, "AES", 0x660F, 192, new int[]{192}, 16, 32, "AES", false),
    aes256(CipherProvider.aes, "AES", 0x6610, 256, new int[]{256}, 16, 32, "AES", false),
    rc2(null, "RC2", -1, 0x80, new int[]{0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80}, 8, 20, "RC2", false),
    des(null, "DES", -1, 64, new int[]{64}, 8, 32, "DES", false),
    
    des3(null, "DESede", -1, 192, new int[]{192}, 8, 32, "3DES", false),
    
    
    des3_112(null, "DESede", -1, 128, new int[]{128}, 8, 32, "3DES_112", true),
    
    rsa(null, "RSA", -1, 1024, new int[]{1024, 2048, 3072, 4096}, -1, -1, "", false);
    ;
    
    public final CipherProvider provider;
    public final String jceId;
    public final int ecmaId;
    public final int defaultKeySize;
    public final int allowedKeySize[];
    public final int blockSize;
    public final int encryptedVerifierHashLength;
    public final String xmlId;
    public final boolean needsBouncyCastle;
    
    CipherAlgorithm(CipherProvider provider, String jceId, int ecmaId, int defaultKeySize, int allowedKeySize[], int blockSize, int encryptedVerifierHashLength, String xmlId, boolean needsBouncyCastle) {
        this.provider = provider;
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.defaultKeySize = defaultKeySize;
        this.allowedKeySize = allowedKeySize;
        this.blockSize = blockSize;
        this.encryptedVerifierHashLength = encryptedVerifierHashLength;
        this.xmlId = xmlId;
        this.needsBouncyCastle = needsBouncyCastle;
    }

    public static CipherAlgorithm fromEcmaId(int ecmaId) {
        for (CipherAlgorithm ca : CipherAlgorithm.values()) {
            if (ca.ecmaId == ecmaId) return ca;
        }
        throw new EncryptedDocumentException("cipher algorithm " + ecmaId + " not found");
    }
    
    public static CipherAlgorithm fromXmlId(String xmlId, int keySize) {
        for (CipherAlgorithm ca : CipherAlgorithm.values()) {
            if (!ca.xmlId.equals(xmlId)) continue;
            for (int ks : ca.allowedKeySize) {
                if (ks == keySize) return ca;
            }
        }
        throw new EncryptedDocumentException("cipher algorithm " + xmlId + "/" + keySize + " not found");
    }
}
<code block>


package org.apache.poi.poifs.crypt;

import org.apache.poi.EncryptedDocumentException;



public enum HashAlgorithm {
    none     (         "", 0x0000,           "",  0,               "", false),
    sha1     (    "SHA-1", 0x8004,       "SHA1", 20,       "HmacSHA1", false),
    sha256   (  "SHA-256", 0x800C,     "SHA256", 32,     "HmacSHA256", false),
    sha384   (  "SHA-384", 0x800D,     "SHA384", 48,     "HmacSHA384", false),
    sha512   (  "SHA-512", 0x800E,     "SHA512", 64,     "HmacSHA512", false),
    
    md5      (      "MD5",     -1,        "MD5", 16,        "HmacMD5", false),
    
    md2      (      "MD2",     -1,        "MD2", 16,       "Hmac-MD2", true),
    md4      (      "MD4",     -1,        "MD4", 16,       "Hmac-MD4", true),
    ripemd128("RipeMD128",     -1, "RIPEMD-128", 16, "HMac-RipeMD128", true),
    ripemd160("RipeMD160",     -1, "RIPEMD-160", 20, "HMac-RipeMD160", true),
    whirlpool("Whirlpool",     -1,  "WHIRLPOOL", 64, "HMac-Whirlpool", true),
    
    sha224   (  "SHA-224",     -1,     "SHA224", 28,     "HmacSHA224", true);
    ;

    public final String jceId;
    public final int ecmaId;
    public final String ecmaString;
    public final int hashSize;
    public final String jceHmacId;
    public final boolean needsBouncyCastle;
    
    HashAlgorithm(String jceId, int ecmaId, String ecmaString, int hashSize, String jceHmacId, boolean needsBouncyCastle) {
        this.jceId = jceId;
        this.ecmaId = ecmaId;
        this.ecmaString = ecmaString;
        this.hashSize = hashSize;
        this.jceHmacId = jceHmacId;
        this.needsBouncyCastle = needsBouncyCastle;
    }
    
    public static HashAlgorithm fromEcmaId(int ecmaId) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaId == ecmaId) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found");
    }    
    
    public static HashAlgorithm fromEcmaId(String ecmaString) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaString.equals(ecmaString)) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found");
    }
    
    public static HashAlgorithm fromString(String string) {
        for (HashAlgorithm ha : values()) {
            if (ha.ecmaString.equalsIgnoreCase(string) || ha.jceId.equalsIgnoreCase(string)) return ha;
        }
        throw new EncryptedDocumentException("hash algorithm not found");
    }
}
<code block>

package org.apache.poi.poifs.crypt;

import java.io.IOException;

import org.apache.poi.util.LittleEndianInput;

public interface EncryptionInfoBuilder {
    
    void initialize(EncryptionInfo ei, LittleEndianInput dis) throws IOException;

    
    void initialize(EncryptionInfo ei, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);

    
    EncryptionHeader getHeader();

    
    EncryptionVerifier getVerifier();

    
    Decryptor getDecryptor();

    
    Encryptor getEncryptor();
}

<code block>

package org.apache.poi.poifs.crypt.standard;


import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianInput;


public class StandardEncryptionVerifier extends EncryptionVerifier implements EncryptionRecord {
    private static final int SPIN_COUNT = 50000;
    private final int verifierHashSize;
    
    protected StandardEncryptionVerifier(LittleEndianInput is, StandardEncryptionHeader header) {
        int saltSize = is.readInt();

        if (saltSize!=16) {
            throw new RuntimeException("Salt size != 16 !?");
        }

        byte salt[] = new byte[16];
        is.readFully(salt);
        setSalt(salt);
        
        byte encryptedVerifier[] = new byte[16];
        is.readFully(encryptedVerifier);
        setEncryptedVerifier(encryptedVerifier);

        verifierHashSize = is.readInt();

        byte encryptedVerifierHash[] = new byte[header.getCipherAlgorithm().encryptedVerifierHashLength];
        is.readFully(encryptedVerifierHash);
        setEncryptedVerifierHash(encryptedVerifierHash);

        setSpinCount(SPIN_COUNT);
        setCipherAlgorithm(header.getCipherAlgorithm());
        setChainingMode(header.getChainingMode());
        setEncryptedKey(null);
        setHashAlgorithm(header.getHashAlgorithmEx()); 
    }
    
    protected StandardEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setChainingMode(chainingMode);
        setSpinCount(SPIN_COUNT);
        verifierHashSize = hashAlgorithm.hashSize;
    }

    
    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != 16) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setSalt(salt);
    }
    
    
    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    
    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }
    
    public void write(LittleEndianByteArrayOutputStream bos) {
        
        byte salt[] = getSalt();
        assert(salt.length == 16);
        bos.writeInt(salt.length); 
        bos.write(salt);
        
        
        byte encryptedVerifier[] = getEncryptedVerifier(); 
        assert(encryptedVerifier.length == 16);
        bos.write(encryptedVerifier);

        
        
        bos.writeInt(20);

        
        
        
        
        
        
        byte encryptedVerifierHash[] = getEncryptedVerifierHash(); 
        assert(encryptedVerifierHash.length == getCipherAlgorithm().encryptedVerifierHashLength);
        bos.write(encryptedVerifierHash);
    }

    protected int getVerifierHashSize() {
        return verifierHashSize;
    }
}

<code block>

package org.apache.poi.poifs.crypt.standard;

import static org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;



import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.Decryptor;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.util.BoundedInputStream;
import org.apache.poi.util.LittleEndian;


public class StandardDecryptor extends Decryptor {
    private long _length = -1;

    protected StandardDecryptor(EncryptionInfoBuilder builder) {
        super(builder);
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver, getKeySizeInBytes());
        Cipher cipher = getCipher(skey);

        try {
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = cipher.doFinal(encryptedVerifier);
            setVerifier(verifier);
            MessageDigest sha1 = CryptoFunctions.getMessageDigest(ver.getHashAlgorithm());
            byte[] calcVerifierHash = sha1.digest(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte decryptedVerifierHash[] = cipher.doFinal(encryptedVerifierHash);

            
            
            
            byte[] verifierHash = Arrays.copyOf(decryptedVerifierHash, calcVerifierHash.length);
    
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            } else {
                return false;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }
    
    protected static SecretKey generateSecretKey(String password, EncryptionVerifier ver, int keySize) {
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();

        byte pwHash[] = hashPassword(password, hashAlgo, ver.getSalt(), ver.getSpinCount());

        byte[] blockKey = new byte[4];
        LittleEndian.putInt(blockKey, 0, 0);

        byte[] finalHash = CryptoFunctions.generateKey(pwHash, hashAlgo, blockKey, hashAlgo.hashSize);
        byte x1[] = fillAndXor(finalHash, (byte) 0x36);
        byte x2[] = fillAndXor(finalHash, (byte) 0x5c);

        byte[] x3 = new byte[x1.length + x2.length];
        System.arraycopy(x1, 0, x3, 0, x1.length);
        System.arraycopy(x2, 0, x3, x1.length, x2.length);
        
        byte[] key = Arrays.copyOf(x3, keySize);

        SecretKey skey = new SecretKeySpec(key, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    protected static byte[] fillAndXor(byte hash[], byte fillByte) {
        byte[] buff = new byte[64];
        Arrays.fill(buff, fillByte);

        for (int i=0; i<hash.length; i++) {
            buff[i] = (byte) (buff[i] ^ hash[i]);
        }

        MessageDigest sha1 = CryptoFunctions.getMessageDigest(HashAlgorithm.sha1);
        return sha1.digest(buff);
    }

    private Cipher getCipher(SecretKey key) {
        EncryptionHeader em = builder.getHeader();
        ChainingMode cm = em.getChainingMode();
        assert(cm == ChainingMode.ecb);
        return CryptoFunctions.getCipher(key, em.getCipherAlgorithm(), cm, null, Cipher.DECRYPT_MODE);
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);

        _length = dis.readLong();

        
        
        
        int blockSize = builder.getHeader().getCipherAlgorithm().blockSize;
        long cipherLen = (_length/blockSize + 1) * blockSize;
        Cipher cipher = getCipher(getSecretKey());
        
        InputStream boundedDis = new BoundedInputStream(dis, cipherLen);
        return new BoundedInputStream(new CipherInputStream(boundedDis, cipher), _length);
    }

    
    public long getLength(){
        if(_length == -1) throw new IllegalStateException("Decryptor.getDataStream() was not called");
        return _length;
    }
}

<code block>

package org.apache.poi.poifs.crypt.standard;

import org.apache.poi.util.LittleEndianByteArrayOutputStream;

public interface EncryptionRecord {
    void write(LittleEndianByteArrayOutputStream os);
}

<code block>


package org.apache.poi.poifs.crypt.standard;

import static org.apache.poi.poifs.crypt.DataSpaceMapUtils.createEncryptionEntry;
import static org.apache.poi.poifs.crypt.standard.StandardDecryptor.generateSecretKey;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;



import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.Encryptor;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.POIFSWriterEvent;
import org.apache.poi.poifs.filesystem.POIFSWriterListener;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LittleEndianOutputStream;
import org.apache.poi.util.TempFile;

public class StandardEncryptor extends Encryptor {
    private final StandardEncryptionInfoBuilder builder;
    
    protected StandardEncryptor(StandardEncryptionInfoBuilder builder) {
        this.builder = builder;
    }    

    public void confirmPassword(String password) {
        
        Random r = new SecureRandom();
        byte[] salt = new byte[16], verifier = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        
        confirmPassword(password, null, null, salt, verifier, null);
    }
    
    
    
    public void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]) {
        StandardEncryptionVerifier ver = builder.getVerifier();

        ver.setSalt(verifierSalt);
        SecretKey secretKey = generateSecretKey(password, ver, getKeySizeInBytes());
        setSecretKey(secretKey);
        Cipher cipher = getCipher(secretKey, null);
        
        try {
            byte encryptedVerifier[] = cipher.doFinal(verifier); 
            MessageDigest hashAlgo = CryptoFunctions.getMessageDigest(ver.getHashAlgorithm());
            byte calcVerifierHash[] = hashAlgo.digest(verifier);
            
            
            
            
            
            
            
            
            int encVerHashSize = ver.getCipherAlgorithm().encryptedVerifierHashLength; 
            byte encryptedVerifierHash[] = cipher.doFinal(Arrays.copyOf(calcVerifierHash, encVerHashSize));
    
            ver.setEncryptedVerifier(encryptedVerifier);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
        
    }

    private Cipher getCipher(SecretKey key, String padding) {
        EncryptionVerifier ver = builder.getVerifier();
        return CryptoFunctions.getCipher(key, ver.getCipherAlgorithm(), ver.getChainingMode(), null, Cipher.ENCRYPT_MODE, padding);
    }
    
    public OutputStream getDataStream(final DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        createEncryptionInfoEntry(dir);
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        OutputStream countStream = new StandardCipherOutputStream(dir);
        return countStream;
    }
    
    protected class StandardCipherOutputStream extends FilterOutputStream implements POIFSWriterListener {
        protected long countBytes;
        protected final File fileOut;
        protected final DirectoryNode dir;
        
        protected StandardCipherOutputStream(DirectoryNode dir) throws IOException {
            super(null);

            this.dir = dir;
            fileOut = TempFile.createTempFile("encrypted_package", "crypt");
            FileOutputStream rawStream = new FileOutputStream(fileOut);

            
            
            
            
            
            
            
            
            
            
            CipherOutputStream cryptStream = new CipherOutputStream(rawStream, getCipher(getSecretKey(), "PKCS5Padding"));
            
            this.out = cryptStream;
        }
        
        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
            countBytes += len;
        }

        @Override
        public void write(int b) throws IOException {
            out.write(b);
            countBytes++;
        }
    
        public void close() throws IOException {
            
            super.close(); 
            writeToPOIFS();
        }
        
        void writeToPOIFS() throws IOException {
            int oleStreamSize = (int)(fileOut.length()+LittleEndianConsts.LONG_SIZE);
            dir.createDocument(DEFAULT_POIFS_ENTRY, oleStreamSize, this);
            
        }
    
        public void processPOIFSWriterEvent(POIFSWriterEvent event) {
            try {
                LittleEndianOutputStream leos = new LittleEndianOutputStream(event.getStream());

                
                
                
                
                leos.writeLong(countBytes);

                FileInputStream fis = new FileInputStream(fileOut);
                IOUtils.copy(fis, leos);
                fis.close();
                fileOut.delete();

                leos.close();
            } catch (IOException e) {
                throw new EncryptedDocumentException(e);
            }
        }
    }
    
    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize()/8;
    }
    
    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        final EncryptionInfo info = builder.getEncryptionInfo();
        final StandardEncryptionHeader header = builder.getHeader();
        final StandardEncryptionVerifier verifier = builder.getVerifier();
        
        EncryptionRecord er = new EncryptionRecord(){
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                bos.writeInt(info.getEncryptionFlags());
                header.write(bos);
                verifier.write(bos);
            }
        };
        
        createEncryptionEntry(dir, "EncryptionInfo", er);
        
        
    }
}

<code block>

package org.apache.poi.poifs.crypt.standard;

import java.io.IOException;



import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.util.LittleEndianInput;

public class StandardEncryptionInfoBuilder implements EncryptionInfoBuilder {
    
    EncryptionInfo info;
    StandardEncryptionHeader header;
    StandardEncryptionVerifier verifier;
    StandardDecryptor decryptor;
    StandardEncryptor encryptor;

    
    public void initialize(EncryptionInfo info, LittleEndianInput dis) throws IOException {
        this.info = info;
        
        @SuppressWarnings("unused")
        int hSize = dis.readInt();
        header = new StandardEncryptionHeader(dis);
        verifier = new StandardEncryptionVerifier(dis, header);

        if (info.getVersionMinor() == 2 && (info.getVersionMajor() == 3 || info.getVersionMajor() == 4)) {
            decryptor = new StandardDecryptor(this);
        }
    }
    
    
    public void initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;

        if (cipherAlgorithm == null) {
            cipherAlgorithm = CipherAlgorithm.aes128;
        }
        if (cipherAlgorithm != CipherAlgorithm.aes128 &&
            cipherAlgorithm != CipherAlgorithm.aes192 &&
            cipherAlgorithm != CipherAlgorithm.aes256) {
            throw new EncryptedDocumentException("Standard encryption only supports AES128/192/256.");
        }
        
        if (hashAlgorithm == null) {
            hashAlgorithm = HashAlgorithm.sha1;
        }
        if (hashAlgorithm != HashAlgorithm.sha1) {
            throw new EncryptedDocumentException("Standard encryption only supports SHA-1.");
        }
        if (chainingMode == null) {
            chainingMode = ChainingMode.ecb;
        }
        if (chainingMode != ChainingMode.ecb) {
            throw new EncryptedDocumentException("Standard encryption only supports ECB chaining.");
        }
        if (keyBits == -1) {
            keyBits = cipherAlgorithm.defaultKeySize;
        }
        if (blockSize == -1) {
            blockSize = cipherAlgorithm.blockSize;
        }
        boolean found = false;
        for (int ks : cipherAlgorithm.allowedKeySize) {
            found |= (ks == keyBits);
        }
        if (!found) {
            throw new EncryptedDocumentException("KeySize "+keyBits+" not allowed for Cipher "+cipherAlgorithm.toString());
        }
        header = new StandardEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new StandardEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new StandardDecryptor(this);
        encryptor = new StandardEncryptor(this);
    }

    public StandardEncryptionHeader getHeader() {
        return header;
    }

    public StandardEncryptionVerifier getVerifier() {
        return verifier;
    }

    public StandardDecryptor getDecryptor() {
        return decryptor;
    }

    public StandardEncryptor getEncryptor() {
        return encryptor;
    }
    
    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>

package org.apache.poi.poifs.crypt.standard;

import static org.apache.poi.poifs.crypt.EncryptionInfo.flagAES;
import static org.apache.poi.poifs.crypt.EncryptionInfo.flagCryptoAPI;

import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.CipherProvider;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.LittleEndianInput;
import org.apache.poi.util.LittleEndianOutput;
import org.apache.poi.util.StringUtil;

public class StandardEncryptionHeader extends EncryptionHeader implements EncryptionRecord {

    protected StandardEncryptionHeader(LittleEndianInput is) throws IOException {
        setFlags(is.readInt());
        setSizeExtra(is.readInt());
        setCipherAlgorithm(CipherAlgorithm.fromEcmaId(is.readInt()));
        setHashAlgorithm(HashAlgorithm.fromEcmaId(is.readInt()));
        int keySize = is.readInt();
        if (keySize == 0) {
            
            
            
            keySize = 0x28;
        }
        setKeySize(keySize);
        setBlockSize(getKeySize());
        setCipherProvider(CipherProvider.fromEcmaId(is.readInt()));

        is.readLong(); 

        
        
        ((InputStream)is).mark(LittleEndianConsts.INT_SIZE+1);
        int checkForSalt = is.readInt();
        ((InputStream)is).reset();
        
        if (checkForSalt == 16) {
            setCspName("");
        } else {
            StringBuilder builder = new StringBuilder();
            while (true) {
                char c = (char) is.readShort();
                if (c == 0) break;
                builder.append(c);
            }
            setCspName(builder.toString());
        }
        
        setChainingMode(ChainingMode.ecb);
        setKeySalt(null);
    }

    protected StandardEncryptionHeader(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setKeySize(keyBits);
        setBlockSize(blockSize);
        setCipherProvider(cipherAlgorithm.provider);
        setFlags(flagCryptoAPI.setBoolean(0, true)
                | flagAES.setBoolean(0, cipherAlgorithm.provider == CipherProvider.aes));
        
        
    }
    
    
    public void write(LittleEndianByteArrayOutputStream bos) {
        int startIdx = bos.getWriteIndex();
        LittleEndianOutput sizeOutput = bos.createDelayedOutput(LittleEndianConsts.INT_SIZE);
        bos.writeInt(getFlags());
        bos.writeInt(0); 
        bos.writeInt(getCipherAlgorithm().ecmaId);
        bos.writeInt(getHashAlgorithmEx().ecmaId);
        bos.writeInt(getKeySize());
        bos.writeInt(getCipherProvider().ecmaId);
        bos.writeInt(0); 
        bos.writeInt(0); 
        String cspName = getCspName();
        if (cspName == null) cspName = getCipherProvider().cipherProviderName;
        bos.write(StringUtil.getToUnicodeLE(cspName));
        bos.writeShort(0);
        int headerSize = bos.getWriteIndex()-startIdx-LittleEndianConsts.INT_SIZE;
        sizeOutput.writeInt(headerSize);        
    }
}

<code block>


package org.apache.poi.poifs.crypt.cryptoapi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;



import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.hpsf.DocumentSummaryInformation;
import org.apache.poi.hpsf.PropertySetFactory;
import org.apache.poi.hpsf.SummaryInformation;
import org.apache.poi.hpsf.WritingNotSupportedException;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.Encryptor;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIDecryptor.StreamDescriptorEntry;
import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.StringUtil;

public class CryptoAPIEncryptor extends Encryptor {
    private final CryptoAPIEncryptionInfoBuilder builder;

    protected CryptoAPIEncryptor(CryptoAPIEncryptionInfoBuilder builder) {
        this.builder = builder;
    }

    public void confirmPassword(String password) {
        Random r = new SecureRandom();
        byte salt[] = new byte[16];
        byte verifier[] = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        confirmPassword(password, null, null, verifier, salt, null);
    }

    public void confirmPassword(String password, byte keySpec[],
            byte keySalt[], byte verifier[], byte verifierSalt[],
            byte integritySalt[]) {
        assert(verifier != null && verifierSalt != null);
        CryptoAPIEncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        SecretKey skey = CryptoAPIDecryptor.generateSecretKey(password, ver);
        setSecretKey(skey);
        try {
            Cipher cipher = initCipherForBlock(null, 0);
            byte encryptedVerifier[] = new byte[verifier.length];
            cipher.update(verifier, 0, verifier.length, encryptedVerifier);
            ver.setEncryptedVerifier(encryptedVerifier);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            byte encryptedVerifierHash[] = cipher.doFinal(calcVerifierHash);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
    }

    
    public Cipher initCipherForBlock(Cipher cipher, int block)
    throws GeneralSecurityException {
        return CryptoAPIDecryptor.initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
    }    
    
    
    public OutputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        CipherByteArrayOutputStream bos = new CipherByteArrayOutputStream();
        byte buf[] = new byte[8];
        
        bos.write(buf, 0, 8); 
        String entryNames[] = {
            SummaryInformation.DEFAULT_STREAM_NAME,
            DocumentSummaryInformation.DEFAULT_STREAM_NAME
        };
        
        List<StreamDescriptorEntry> descList = new ArrayList<StreamDescriptorEntry>();

        int block = 0;
        for (String entryName : entryNames) {
            if (!dir.hasEntry(entryName)) continue;
            StreamDescriptorEntry descEntry = new StreamDescriptorEntry();
            descEntry.block = block;
            descEntry.streamOffset = bos.size();
            descEntry.streamName = entryName;
            descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);
            descEntry.reserved2 = 0;
            
            bos.setBlock(block);
            DocumentInputStream dis = dir.createDocumentInputStream(entryName);
            IOUtils.copy(dis, bos);
            dis.close();
            
            descEntry.streamSize = bos.size() - descEntry.streamOffset;
            descList.add(descEntry);
            
            dir.getEntry(entryName).delete();
            
            block++;
        }
        
        int streamDescriptorArrayOffset = bos.size();
        
        bos.setBlock(0);
        LittleEndian.putUInt(buf, 0, descList.size());
        bos.write(buf, 0, 4);
        
        for (StreamDescriptorEntry sde : descList) {
            LittleEndian.putUInt(buf, 0, sde.streamOffset);
            bos.write(buf, 0, 4);
            LittleEndian.putUInt(buf, 0, sde.streamSize);
            bos.write(buf, 0, 4);
            LittleEndian.putUShort(buf, 0, sde.block);
            bos.write(buf, 0, 2);
            LittleEndian.putUByte(buf, 0, (short)sde.streamName.length());
            bos.write(buf, 0, 1);
            LittleEndian.putUByte(buf, 0, (short)sde.flags);
            bos.write(buf, 0, 1);
            LittleEndian.putUInt(buf, 0, sde.reserved2);
            bos.write(buf, 0, 4);
            byte nameBytes[] = StringUtil.getToUnicodeLE(sde.streamName);
            bos.write(nameBytes, 0, nameBytes.length);
            LittleEndian.putShort(buf, 0, (short)0); 
            bos.write(buf, 0, 2);
        }
        
        int savedSize = bos.size();
        int streamDescriptorArraySize = savedSize - streamDescriptorArrayOffset;
        LittleEndian.putUInt(buf, 0, streamDescriptorArrayOffset);
        LittleEndian.putUInt(buf, 4, streamDescriptorArraySize);

        bos.reset();
        bos.setBlock(0);
        bos.write(buf, 0, 8);
        bos.setSize(savedSize);
        
        dir.createDocument("EncryptedSummary", new ByteArrayInputStream(bos.getBuf(), 0, savedSize));
        DocumentSummaryInformation dsi = PropertySetFactory.newDocumentSummaryInformation();
        
        try {
            dsi.write(dir, DocumentSummaryInformation.DEFAULT_STREAM_NAME);
        } catch (WritingNotSupportedException e) {
            throw new IOException(e);
        }
        
        return bos;
    }

    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize() / 8;
    }

    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        final EncryptionInfo info = builder.getEncryptionInfo();
        final CryptoAPIEncryptionHeader header = builder.getHeader();
        final CryptoAPIEncryptionVerifier verifier = builder.getVerifier();
        EncryptionRecord er = new EncryptionRecord() {
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                header.write(bos);
                verifier.write(bos);
            }
        };
        DataSpaceMapUtils.createEncryptionEntry(dir, "EncryptionInfo", er);
    }

    private class CipherByteArrayOutputStream extends ByteArrayOutputStream {
        Cipher cipher;
        byte oneByte[] = { 0 };

        public CipherByteArrayOutputStream() throws GeneralSecurityException {
            setBlock(0);
        }
        
        public byte[] getBuf() {
            return buf;
        }
        
        public void setSize(int count) {
            this.count = count;
        }
        
        public void setBlock(int block) throws GeneralSecurityException {
            cipher = initCipherForBlock(cipher, block);
        }
        
        public void write(int b) {
            try {
                oneByte[0] = (byte)b;
                cipher.update(oneByte, 0, 1, oneByte, 0);
                super.write(oneByte);
            } catch (Exception e) {
                throw new EncryptedDocumentException(e);
            }
        }

        public void write(byte[] b, int off, int len) {
            try {
                cipher.update(b, off, len, b, off);
                super.write(b, off, len);
            } catch (Exception e) {
                throw new EncryptedDocumentException(e);
            }
        }

    }
}

<code block>


package org.apache.poi.poifs.crypt.cryptoapi;

import java.io.IOException;

import org.apache.poi.poifs.crypt.*;
import org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionInfoBuilder implements EncryptionInfoBuilder {
    EncryptionInfo info;
    CryptoAPIEncryptionHeader header;
    CryptoAPIEncryptionVerifier verifier;
    CryptoAPIDecryptor decryptor;
    CryptoAPIEncryptor encryptor;

    public CryptoAPIEncryptionInfoBuilder() {
    }

    
    @SuppressWarnings("unused")
    public void initialize(EncryptionInfo info, LittleEndianInput dis)
    throws IOException {
        this.info = info;
        int hSize = dis.readInt();
        header = new CryptoAPIEncryptionHeader(dis);
        verifier = new CryptoAPIEncryptionVerifier(dis, header);
        decryptor = new CryptoAPIDecryptor(this);
        encryptor = new CryptoAPIEncryptor(this);
    }

    
    public void initialize(EncryptionInfo info,
            CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm,
            int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;
        if (cipherAlgorithm == null) cipherAlgorithm = CipherAlgorithm.rc4;
        if (hashAlgorithm == null) hashAlgorithm = HashAlgorithm.sha1;
        if (keyBits == -1) keyBits = 0x28; 
        assert(cipherAlgorithm == CipherAlgorithm.rc4 && hashAlgorithm == HashAlgorithm.sha1);
        
        header = new CryptoAPIEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new CryptoAPIEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new CryptoAPIDecryptor(this);
        encryptor = new CryptoAPIEncryptor(this);
    }

    public CryptoAPIEncryptionHeader getHeader() {
        return header;
    }

    public CryptoAPIEncryptionVerifier getVerifier() {
        return verifier;
    }

    public CryptoAPIDecryptor getDecryptor() {
        return decryptor;
    }

    public CryptoAPIEncryptor getEncryptor() {
        return encryptor;
    }

    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>


package org.apache.poi.poifs.crypt.cryptoapi;

import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.standard.StandardEncryptionVerifier;
import org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionVerifier extends StandardEncryptionVerifier {

    protected CryptoAPIEncryptionVerifier(LittleEndianInput is,
            CryptoAPIEncryptionHeader header) {
        super(is, header);
    }

    protected CryptoAPIEncryptionVerifier(CipherAlgorithm cipherAlgorithm,
            HashAlgorithm hashAlgorithm, int keyBits, int blockSize,
            ChainingMode chainingMode) {
        super(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }

    protected void setSalt(byte salt[]) {
        super.setSalt(salt);
    }

    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }
}

<code block>


package org.apache.poi.poifs.crypt.cryptoapi;

import java.io.IOException;



import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.CipherProvider;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.standard.StandardEncryptionHeader;
import org.apache.poi.util.LittleEndianInput;

public class CryptoAPIEncryptionHeader extends StandardEncryptionHeader {

    public CryptoAPIEncryptionHeader(LittleEndianInput is) throws IOException {
        super(is);
    }

    protected CryptoAPIEncryptionHeader(CipherAlgorithm cipherAlgorithm,
            HashAlgorithm hashAlgorithm, int keyBits, int blockSize,
            ChainingMode chainingMode) {
        super(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
    }

    public void setKeySize(int keyBits) {
        
        
        boolean found = false;
        for (int size : getCipherAlgorithm().allowedKeySize) {
            if (size == keyBits) {
                found = true;
                break;
            }
        }
        if (!found) {
            throw new EncryptedDocumentException("invalid keysize "+keyBits+" for cipher algorithm "+getCipherAlgorithm());
        }
        super.setKeySize(keyBits);
        if (keyBits > 40) {
            setCspName("Microsoft Enhanced Cryptographic Provider v1.0");
        } else {
            setCspName(CipherProvider.rc4.cipherProviderName);
        }
    }
}

<code block>


package org.apache.poi.poifs.crypt.cryptoapi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.SecretKeySpec;



import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.Decryptor;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.poifs.filesystem.DocumentNode;
import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
import org.apache.poi.util.BitField;
import org.apache.poi.util.BitFieldFactory;
import org.apache.poi.util.BoundedInputStream;
import org.apache.poi.util.IOUtils;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianInputStream;
import org.apache.poi.util.StringUtil;

public class CryptoAPIDecryptor extends Decryptor {

    private long _length;
    
    private class SeekableByteArrayInputStream extends ByteArrayInputStream {
        Cipher cipher;
        byte oneByte[] = { 0 };
        
        public void seek(int pos) {
            if (pos > count) {
                throw new ArrayIndexOutOfBoundsException(pos);
            }
            
            this.pos = pos;
            mark = pos;
        }

        public void setBlock(int block) throws GeneralSecurityException {
            cipher = initCipherForBlock(cipher, block);
        }

        public synchronized int read() {
            int ch = super.read();
            if (ch == -1) return -1;
            oneByte[0] = (byte) ch;
            try {
                cipher.update(oneByte, 0, 1, oneByte);
            } catch (ShortBufferException e) {
                throw new EncryptedDocumentException(e);
            }
            return oneByte[0];
        }

        public synchronized int read(byte b[], int off, int len) {
            int readLen = super.read(b, off, len);
            if (readLen ==-1) return -1;
            try {
                cipher.update(b, off, readLen, b, off);
            } catch (ShortBufferException e) {
                throw new EncryptedDocumentException(e);
            }
            return readLen;
        }

        public SeekableByteArrayInputStream(byte buf[])
        throws GeneralSecurityException {
            super(buf);
            cipher = initCipherForBlock(null, 0);
        }
    }

    static class StreamDescriptorEntry {
        static BitField flagStream = BitFieldFactory.getInstance(1);
        
        int streamOffset;
        int streamSize;
        int block;
        int flags;
        int reserved2;
        String streamName;
    }

    protected CryptoAPIDecryptor(CryptoAPIEncryptionInfoBuilder builder) {
        super(builder);
        _length = -1L;
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver);
        try {
            Cipher cipher = initCipherForBlock(null, 0, builder, skey, Cipher.DECRYPT_MODE);
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = new byte[encryptedVerifier.length];
            cipher.update(encryptedVerifier, 0, encryptedVerifier.length, verifier);
            setVerifier(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte verifierHash[] = cipher.doFinal(encryptedVerifierHash);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
        return false;
    }

    
    public Cipher initCipherForBlock(Cipher cipher, int block)
    throws GeneralSecurityException {
        return initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.DECRYPT_MODE);
    }

    protected static Cipher initCipherForBlock(Cipher cipher, int block,
        EncryptionInfoBuilder builder, SecretKey skey, int encryptMode)
    throws GeneralSecurityException {
        EncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte blockKey[] = new byte[4];
        LittleEndian.putUInt(blockKey, 0, block);
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        hashAlg.update(skey.getEncoded());
        byte encKey[] = hashAlg.digest(blockKey);
        EncryptionHeader header = builder.getHeader();
        int keyBits = header.getKeySize();
        encKey = CryptoFunctions.getBlock0(encKey, keyBits / 8);
        if (keyBits == 40) {
            encKey = CryptoFunctions.getBlock0(encKey, 16);
        }
        SecretKey key = new SecretKeySpec(encKey, skey.getAlgorithm());
        if (cipher == null) {
            cipher = CryptoFunctions.getCipher(key, header.getCipherAlgorithm(), null, null, encryptMode);
        } else {
            cipher.init(encryptMode, key);
        }
        return cipher;
    }

    protected static SecretKey generateSecretKey(String password, EncryptionVerifier ver) {
        if (password.length() > 255) {
            password = password.substring(0, 255);
        }
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        hashAlg.update(ver.getSalt());
        byte hash[] = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        SecretKey skey = new SecretKeySpec(hash, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    
    @SuppressWarnings("unused")
    public InputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        NPOIFSFileSystem fsOut = new NPOIFSFileSystem();
        DocumentNode es = (DocumentNode) dir.getEntry("EncryptedSummary");
        DocumentInputStream dis = dir.createDocumentInputStream(es);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        IOUtils.copy(dis, bos);
        dis.close();
        SeekableByteArrayInputStream sbis = new SeekableByteArrayInputStream(bos.toByteArray());
        LittleEndianInputStream leis = new LittleEndianInputStream(sbis);
        int streamDescriptorArrayOffset = (int) leis.readUInt();
        int streamDescriptorArraySize = (int) leis.readUInt();
        sbis.skip(streamDescriptorArrayOffset - 8);
        sbis.setBlock(0);
        int encryptedStreamDescriptorCount = (int) leis.readUInt();
        StreamDescriptorEntry entries[] = new StreamDescriptorEntry[encryptedStreamDescriptorCount];
        for (int i = 0; i < encryptedStreamDescriptorCount; i++) {
            StreamDescriptorEntry entry = new StreamDescriptorEntry();
            entries[i] = entry;
            entry.streamOffset = (int) leis.readUInt();
            entry.streamSize = (int) leis.readUInt();
            entry.block = leis.readUShort();
            int nameSize = leis.readUByte();
            entry.flags = leis.readUByte();
            boolean isStream = StreamDescriptorEntry.flagStream.isSet(entry.flags);
            entry.reserved2 = leis.readInt();
            entry.streamName = StringUtil.readUnicodeLE(leis, nameSize);
            leis.readShort();
            assert(entry.streamName.length() == nameSize);
        }

        for (StreamDescriptorEntry entry : entries) {
            sbis.seek(entry.streamOffset);
            sbis.setBlock(entry.block);
            InputStream is = new BoundedInputStream(sbis, entry.streamSize);
            fsOut.createDocument(is, entry.streamName);
        }

        leis.close();
        sbis = null;
        bos.reset();
        fsOut.writeFilesystem(bos);
        fsOut.close();
        _length = bos.size();
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        return bis;
    }

    
    public long getLength() {
        if (_length == -1L) {
            throw new IllegalStateException("Decryptor.getDataStream() was not called");
        }
        return _length;
    }
}

<code block>

package org.apache.poi.poifs.crypt.agile;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.bind.JAXBException;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.apache.poi.poifs.crypt.EncryptionMode;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.util.LittleEndianInput;


import org.docx4j.XmlUtils;
import org.docx4j.jaxb.Context;

import com.microsoft.schemas.office.x2006.encryption.CTEncryption;


public class AgileEncryptionInfoBuilder implements EncryptionInfoBuilder {
    
    EncryptionInfo info;
    AgileEncryptionHeader header;
    AgileEncryptionVerifier verifier;
    AgileDecryptor decryptor;
    AgileEncryptor encryptor;

    public void initialize(EncryptionInfo info, LittleEndianInput dis) throws IOException {
        this.info = info;
        
        EncryptionDocument ed = parseDescriptor((InputStream)dis);
        header = new AgileEncryptionHeader(ed);
        verifier = new AgileEncryptionVerifier(ed);
        if (info.getVersionMajor() == EncryptionMode.agile.versionMajor
            && info.getVersionMinor() == EncryptionMode.agile.versionMinor) {
            decryptor = new AgileDecryptor(this);
            encryptor = new AgileEncryptor(this);
        }
    }

    public void initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;

        if (cipherAlgorithm == null) {
            cipherAlgorithm = CipherAlgorithm.aes128;
        }
        if (cipherAlgorithm == CipherAlgorithm.rc4) {
            throw new EncryptedDocumentException("RC4 must not be used with agile encryption.");
        }
        if (hashAlgorithm == null) {
            hashAlgorithm = HashAlgorithm.sha1;
        }
        if (chainingMode == null) {
            chainingMode = ChainingMode.cbc;
        }
        if (!(chainingMode == ChainingMode.cbc || chainingMode == ChainingMode.cfb)) {
            throw new EncryptedDocumentException("Agile encryption only supports CBC/CFB chaining.");
        }
        if (keyBits == -1) {
            keyBits = cipherAlgorithm.defaultKeySize;
        }
        if (blockSize == -1) {
            blockSize = cipherAlgorithm.blockSize;
        }
        boolean found = false;
        for (int ks : cipherAlgorithm.allowedKeySize) {
            found |= (ks == keyBits);
        }
        if (!found) {
            throw new EncryptedDocumentException("KeySize "+keyBits+" not allowed for Cipher "+cipherAlgorithm.toString());
        }
        header = new AgileEncryptionHeader(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        verifier = new AgileEncryptionVerifier(cipherAlgorithm, hashAlgorithm, keyBits, blockSize, chainingMode);
        decryptor = new AgileDecryptor(this);
        encryptor = new AgileEncryptor(this);
    }
    
    public AgileEncryptionHeader getHeader() {
        return header;
    }

    public AgileEncryptionVerifier getVerifier() {
        return verifier;
    }

    public AgileDecryptor getDecryptor() {
        return decryptor;
    }

    public AgileEncryptor getEncryptor() {
        return encryptor;
    }

    protected EncryptionInfo getInfo() {
        return info;
    }
    
    protected static EncryptionDocument parseDescriptor(String descriptor) {





        
        CTEncryption encryption = null;
		try {
			encryption = (CTEncryption)XmlUtils.unmarshalString(descriptor, Context.jcXmlDSig, CTEncryption.class);
		} catch (JAXBException e) {
			
			e.printStackTrace();
		}
        EncryptionDocument ed = new EncryptionDocument();
        ed.setEncryption(encryption);
        return ed;
        
    }

    protected static EncryptionDocument parseDescriptor(InputStream descriptor) {





        
        CTEncryption encryption = null;
		try {
			encryption = (CTEncryption)XmlUtils.unmarshal(descriptor, Context.jcXmlDSig);
		} catch (JAXBException e) {
			
			e.printStackTrace();
		}
        EncryptionDocument ed = new EncryptionDocument();
        ed.setEncryption(encryption);
        return ed;
        
    }
}

<code block>

package org.apache.poi.poifs.crypt.agile;

import java.io.ByteArrayInputStream;
import java.security.GeneralSecurityException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.HashAlgorithm;

import com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptor;
import com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import com.microsoft.schemas.office.x2006.keyEncryptor.certificate.CTCertificateKeyEncryptor;
import com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor;


public class AgileEncryptionVerifier extends EncryptionVerifier {

    public static class AgileCertificateEntry {
        X509Certificate x509;
        byte encryptedKey[];
        byte certVerifier[];
    }
    
    private List<AgileCertificateEntry> certList = new ArrayList<AgileCertificateEntry>();

    public AgileEncryptionVerifier(String descriptor) {
        this(AgileEncryptionInfoBuilder.parseDescriptor(descriptor));
    }
    
    protected AgileEncryptionVerifier(EncryptionDocument ed) {
        Iterator<CTKeyEncryptor> encList = ed.getEncryption().getKeyEncryptors().getKeyEncryptor().iterator();
        CTPasswordKeyEncryptor keyData;
        try {
            keyData = encList.next().getEncryptedPasswordKey();
            if (keyData == null) {
                throw new NullPointerException("encryptedKey not set");
            }
        } catch (Exception e) {
            throw new EncryptedDocumentException("Unable to parse keyData", e);
        }
        
        int keyBits = (int)keyData.getKeyBits();
        
        CipherAlgorithm ca = CipherAlgorithm.fromXmlId(keyData.getCipherAlgorithm().toString(), keyBits);
        setCipherAlgorithm(ca);

        int hashSize = (int)keyData.getHashSize();

        HashAlgorithm ha = HashAlgorithm.fromEcmaId(keyData.getHashAlgorithm().toString());
        setHashAlgorithm(ha);

        if (getHashAlgorithm().hashSize != hashSize) {
            throw new EncryptedDocumentException("Unsupported hash algorithm: " + 
                    keyData.getHashAlgorithm() + " @ " + hashSize + " bytes");
        }

        setSpinCount((int)keyData.getSpinCount());
        setEncryptedVerifier(keyData.getEncryptedVerifierHashInput());
        setSalt(keyData.getSaltValue());
        setEncryptedKey(keyData.getEncryptedKeyValue()); 
        setEncryptedVerifierHash(keyData.getEncryptedVerifierHashValue());

        int saltSize = (int)keyData.getSaltSize();
        if (saltSize != getSalt().length)
            throw new EncryptedDocumentException("Invalid salt size");
        
        if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CBC) {
            setChainingMode(ChainingMode.cbc);
        } else if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CFB) {
            setChainingMode(ChainingMode.cfb);
        } else {
            throw new EncryptedDocumentException("Unsupported chaining mode - "+keyData.getCipherChaining().toString());
        }
        
        if (!encList.hasNext()) return;
        
        try {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            while (encList.hasNext()) {
                CTCertificateKeyEncryptor certKey = encList.next().getEncryptedCertificateKey();
                AgileCertificateEntry ace = new AgileCertificateEntry();
                ace.certVerifier = certKey.getCertVerifier();
                ace.encryptedKey = certKey.getEncryptedKeyValue();
                ace.x509 = (X509Certificate)cf.generateCertificate(new ByteArrayInputStream(certKey.getX509Certificate()));
                certList.add(ace);
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("can't parse X509 certificate", e);
        }
    }
    
    public AgileEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(cipherAlgorithm);
        setHashAlgorithm(hashAlgorithm);
        setChainingMode(chainingMode);
        setSpinCount(100000); 
    }
    
    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != getCipherAlgorithm().blockSize) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setSalt(salt);
    }
    
    
    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    
    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }

    
    protected void setEncryptedKey(byte[] encryptedKey) {
        super.setEncryptedKey(encryptedKey);
    }
    
    public void addCertificate(X509Certificate x509) {
        AgileCertificateEntry ace = new AgileCertificateEntry();
        ace.x509 = x509;
        certList.add(ace);
    }
    
    public List<AgileCertificateEntry> getCertificates() {
        return certList;
    }
}

<code block>

package org.apache.poi.poifs.crypt.agile;

import static org.apache.poi.poifs.crypt.CryptoFunctions.getBlock0;
import static org.apache.poi.poifs.crypt.CryptoFunctions.getCipher;
import static org.apache.poi.poifs.crypt.CryptoFunctions.getMessageDigest;
import static org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;
import static org.apache.poi.poifs.crypt.DataSpaceMapUtils.createEncryptionEntry;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.getNextBlockSize;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.hashInput;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.kCryptoKeyBlock;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.kHashedVerifierBlock;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.kIntegrityKeyBlock;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.kIntegrityValueBlock;
import static org.apache.poi.poifs.crypt.agile.AgileDecryptor.kVerifierInputBlock;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.cert.CertificateEncodingException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.Encryptor;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.agile.AgileEncryptionVerifier.AgileCertificateEntry;
import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;




import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.NamespacePrefixMapperUtils;
import org.docx4j.openpackaging.exceptions.Docx4JException;

import com.microsoft.schemas.office.x2006.encryption.CTDataIntegrity;
import com.microsoft.schemas.office.x2006.encryption.CTEncryption;
import com.microsoft.schemas.office.x2006.encryption.CTKeyData;
import com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptor;
import com.microsoft.schemas.office.x2006.encryption.CTKeyEncryptors;

import com.microsoft.schemas.office.x2006.encryption.STCipherChaining;
import com.microsoft.schemas.office.x2006.encryption.STHashAlgorithm;

import com.microsoft.schemas.office.x2006.keyEncryptor.certificate.CTCertificateKeyEncryptor;
import com.microsoft.schemas.office.x2006.keyEncryptor.password.CTPasswordKeyEncryptor;

public class AgileEncryptor extends Encryptor {
    private final AgileEncryptionInfoBuilder builder;
    private byte integritySalt[];
	private byte pwHash[];
    
	protected AgileEncryptor(AgileEncryptionInfoBuilder builder) {
		this.builder = builder;
	}

    public void confirmPassword(String password) {
        
        Random r = new SecureRandom();
        int blockSize = builder.getHeader().getBlockSize();
        int keySize = builder.getHeader().getKeySize()/8;
        int hashSize = builder.getHeader().getHashAlgorithmEx().hashSize;
        
        byte[] verifierSalt = new byte[blockSize]
             , verifier = new byte[blockSize]
             , keySalt = new byte[blockSize]
             , keySpec = new byte[keySize]
             , integritySalt = new byte[hashSize];
        r.nextBytes(verifierSalt); 
        r.nextBytes(verifier); 
        r.nextBytes(keySalt); 
        r.nextBytes(keySpec); 
        r.nextBytes(integritySalt); 
        
        confirmPassword(password, keySpec, keySalt, verifierSalt, verifier, integritySalt);
    }
	
	public void confirmPassword(String password, byte keySpec[], byte keySalt[], byte verifier[], byte verifierSalt[], byte integritySalt[]) {
        AgileEncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        AgileEncryptionHeader header = builder.getHeader();
        header.setKeySalt(keySalt);
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();

        int blockSize = header.getBlockSize();
	    
        pwHash = hashPassword(password, hashAlgo, verifierSalt, ver.getSpinCount());
        
        
        byte encryptedVerifier[] = hashInput(builder, pwHash, kVerifierInputBlock, verifier, Cipher.ENCRYPT_MODE);
        ver.setEncryptedVerifier(encryptedVerifier);
	    

        
        MessageDigest hashMD = getMessageDigest(hashAlgo);
        byte[] hashedVerifier = hashMD.digest(verifier);
        byte encryptedVerifierHash[] = hashInput(builder, pwHash, kHashedVerifierBlock, hashedVerifier, Cipher.ENCRYPT_MODE);
        ver.setEncryptedVerifierHash(encryptedVerifierHash);
        
        
        byte encryptedKey[] = hashInput(builder, pwHash, kCryptoKeyBlock, keySpec, Cipher.ENCRYPT_MODE);
        ver.setEncryptedKey(encryptedKey);
        
        SecretKey secretKey = new SecretKeySpec(keySpec, ver.getCipherAlgorithm().jceId);
        setSecretKey(secretKey);
        
        
        this.integritySalt = integritySalt;

        try {
            byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, header.getBlockSize());
            Cipher cipher = getCipher(secretKey, ver.getCipherAlgorithm(), ver.getChainingMode(), vec, Cipher.ENCRYPT_MODE);
            byte filledSalt[] = getBlock0(integritySalt, getNextBlockSize(integritySalt.length, blockSize));
            byte encryptedHmacKey[] = cipher.doFinal(filledSalt);
            header.setEncryptedHmacKey(encryptedHmacKey);

            cipher = Cipher.getInstance("RSA");
            for (AgileCertificateEntry ace : ver.getCertificates()) {
                cipher.init(Cipher.ENCRYPT_MODE, ace.x509.getPublicKey());
                ace.encryptedKey = cipher.doFinal(getSecretKey().getEncoded());
                Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);
                x509Hmac.init(getSecretKey());
                ace.certVerifier = x509Hmac.doFinal(ace.x509.getEncoded());
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
	}
	
    public OutputStream getDataStream(DirectoryNode dir)
            throws IOException, GeneralSecurityException {
        
        AgileCipherOutputStream countStream = new AgileCipherOutputStream(dir);
    	return countStream;
    }

    
    protected void updateIntegrityHMAC(File tmpFile, int oleStreamSize) throws GeneralSecurityException, IOException {
        
        
        
        AgileEncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        Mac integrityMD = CryptoFunctions.getMac(hashAlgo);
        integrityMD.init(new SecretKeySpec(integritySalt, hashAlgo.jceHmacId));

        byte buf[] = new byte[1024];
        LittleEndian.putLong(buf, 0, oleStreamSize);
        integrityMD.update(buf, 0, LittleEndian.LONG_SIZE);
        
        InputStream fis = new FileInputStream(tmpFile);
        try {
            int readBytes;
            while ((readBytes = fis.read(buf)) != -1) {
                integrityMD.update(buf, 0, readBytes);
            }
        } finally {
        	fis.close();
        }
        
        byte hmacValue[] = integrityMD.doFinal();
        
        AgileEncryptionHeader header = builder.getHeader();
        int blockSize = header.getBlockSize();
        byte iv[] = CryptoFunctions.generateIv(header.getHashAlgorithmEx(), header.getKeySalt(), kIntegrityValueBlock, blockSize);
        Cipher cipher = CryptoFunctions.getCipher(getSecretKey(), header.getCipherAlgorithm(), header.getChainingMode(), iv, Cipher.ENCRYPT_MODE);
        byte hmacValueFilled[] = getBlock0(hmacValue, getNextBlockSize(hmacValue.length, blockSize));
        byte encryptedHmacValue[] = cipher.doFinal(hmacValueFilled);
        
        header.setEncryptedHmacValue(encryptedHmacValue);
    }





    
    static final String HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_PASSWORD = "http:
    static final String HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_CERTIFICATE = "http:

    
    private final String passwordUri = 
        HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_PASSWORD;
    private final String certificateUri = 
        HTTP_SCHEMAS_MICROSOFT_COM_OFFICE_2006_KEY_ENCRYPTOR_CERTIFICATE;
    
    protected EncryptionDocument createEncryptionDocument() {
        AgileEncryptionVerifier ver = builder.getVerifier();
        AgileEncryptionHeader header = builder.getHeader(); 
        
        EncryptionDocument ed = new EncryptionDocument();
        CTEncryption edRoot = ed.addNewEncryption();
        
        CTKeyData keyData = new CTKeyData();
        edRoot.setKeyData(keyData);
        
        CTKeyEncryptors keyEncList = new CTKeyEncryptors();
        edRoot.setKeyEncryptors(keyEncList);
        
        CTKeyEncryptor keyEnc = new CTKeyEncryptor();
        keyEncList.getKeyEncryptor().add(keyEnc);
        keyEnc.setUri(passwordUri);
        
        CTPasswordKeyEncryptor keyPass = new CTPasswordKeyEncryptor();
        keyEnc.setEncryptedPasswordKey(keyPass);

        keyPass.setSpinCount(ver.getSpinCount());
        
        keyData.setSaltSize(header.getBlockSize());
        keyPass.setSaltSize(header.getBlockSize());
        
        keyData.setBlockSize(header.getBlockSize());
        keyPass.setBlockSize(header.getBlockSize());


        keyPass.setKeyBits(header.getKeySize());

        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        keyData.setHashSize(hashAlgo.hashSize);
        keyPass.setHashSize(hashAlgo.hashSize);

        
        String xmlCipherAlgo = header.getCipherAlgorithm().xmlId;
        if (xmlCipherAlgo == null) {
            throw new EncryptedDocumentException("CipherAlgorithm "+header.getCipherAlgorithm()+" not supported.");
        }
        keyData.setCipherAlgorithm(xmlCipherAlgo);
        keyPass.setCipherAlgorithm(xmlCipherAlgo);
        
        switch (header.getChainingMode()) {
        case cbc: 
            keyData.setCipherChaining(STCipherChaining.CHAINING_MODE_CBC);
            keyPass.setCipherChaining(STCipherChaining.CHAINING_MODE_CBC);
            break;
        case cfb:
            keyData.setCipherChaining(STCipherChaining.CHAINING_MODE_CFB);
            keyPass.setCipherChaining(STCipherChaining.CHAINING_MODE_CFB);
            break;
        default:
            throw new EncryptedDocumentException("ChainingMode "+header.getChainingMode()+" not supported.");
        }
        
        STHashAlgorithm xmlHashAlgo = STHashAlgorithm.fromValue(hashAlgo.ecmaString);
        if (xmlHashAlgo == null) {
            throw new EncryptedDocumentException("HashAlgorithm "+hashAlgo+" not supported.");
        }
        keyData.setHashAlgorithm(xmlHashAlgo);
        keyPass.setHashAlgorithm(xmlHashAlgo);

        keyData.setSaltValue(header.getKeySalt());
        keyPass.setSaltValue(ver.getSalt());
        keyPass.setEncryptedVerifierHashInput(ver.getEncryptedVerifier());
        keyPass.setEncryptedVerifierHashValue(ver.getEncryptedVerifierHash());
        keyPass.setEncryptedKeyValue(ver.getEncryptedKey());
        
        CTDataIntegrity hmacData = new CTDataIntegrity();
        edRoot.setDataIntegrity(hmacData);
        
        hmacData.setEncryptedHmacKey(header.getEncryptedHmacKey());
        hmacData.setEncryptedHmacValue(header.getEncryptedHmacValue());
        
        for (AgileCertificateEntry ace : ver.getCertificates()) {
            keyEnc = new CTKeyEncryptor();
            keyEncList.getKeyEncryptor().add(keyEnc);
            keyEnc.setUri(certificateUri);
            
            CTCertificateKeyEncryptor certData = new CTCertificateKeyEncryptor();
            keyEnc.setEncryptedCertificateKey(certData);
            try {
                certData.setX509Certificate(ace.x509.getEncoded());
            } catch (CertificateEncodingException e) {
                throw new EncryptedDocumentException(e);
            }
            certData.setEncryptedKeyValue(ace.encryptedKey);
            certData.setCertVerifier(ace.certVerifier);
        }
        
        return ed;
    }
    
























    protected void marshallEncryptionDocument(EncryptionDocument ed, LittleEndianByteArrayOutputStream os) {

		try {
			Marshaller marshaller = Context.jcXmlDSig.createMarshaller();
			marshaller.setProperty("jaxb.formatted.output", true);
			
			NamespacePrefixMapperUtils.setProperty(marshaller, NamespacePrefixMapperUtils.getPrefixMapper());
			


			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			marshaller.marshal(ed, baos);
			
			os.write(baos.toByteArray());

		} catch (JAXBException e) {
            throw new EncryptedDocumentException("error marshalling encryption info document", e);
		}        
    }
    
    protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
    throws IOException, GeneralSecurityException {
        DataSpaceMapUtils.addDefaultDataSpace(dir);

        final EncryptionInfo info = builder.getInfo();

        EncryptionRecord er = new EncryptionRecord(){
            public void write(LittleEndianByteArrayOutputStream bos) {
                
                
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                
                bos.writeInt(info.getEncryptionFlags());

                EncryptionDocument ed = createEncryptionDocument();
                marshallEncryptionDocument(ed, bos);
            }
        };
        
        createEncryptionEntry(dir, "EncryptionInfo", er);
    }
    
    
    
    private class AgileCipherOutputStream extends ChunkedCipherOutputStream {
        public AgileCipherOutputStream(DirectoryNode dir) throws IOException, GeneralSecurityException {
            super(dir, 4096);
        }
        
        @Override
        protected Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk)
        throws GeneralSecurityException {
            return AgileDecryptor.initCipherForBlock(existing, block, lastChunk, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
        }

        @Override
        protected void calculateChecksum(File fileOut, int oleStreamSize)
        throws GeneralSecurityException, IOException {
            
            updateIntegrityHMAC(fileOut, oleStreamSize); 
        }
        
        @Override
        protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
        throws IOException, GeneralSecurityException {
            AgileEncryptor.this.createEncryptionInfoEntry(dir, tmpFile);
        }
    }

}

<code block>

package org.apache.poi.poifs.crypt.agile;

import static org.apache.poi.poifs.crypt.CryptoFunctions.generateIv;
import static org.apache.poi.poifs.crypt.CryptoFunctions.generateKey;
import static org.apache.poi.poifs.crypt.CryptoFunctions.getBlock0;
import static org.apache.poi.poifs.crypt.CryptoFunctions.getCipher;
import static org.apache.poi.poifs.crypt.CryptoFunctions.getMessageDigest;
import static org.apache.poi.poifs.crypt.CryptoFunctions.hashPassword;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.MessageDigest;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.RC2ParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChunkedCipherInputStream;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.Decryptor;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.EncryptionInfoBuilder;
import org.apache.poi.poifs.crypt.EncryptionVerifier;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.agile.AgileEncryptionVerifier.AgileCertificateEntry;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.util.LittleEndian;


public class AgileDecryptor extends Decryptor {
    private long _length = -1;

    protected static final byte[] kVerifierInputBlock;
    protected static final byte[] kHashedVerifierBlock;
    protected static final byte[] kCryptoKeyBlock;
    protected static final byte[] kIntegrityKeyBlock;
    protected static final byte[] kIntegrityValueBlock;

    static {
        kVerifierInputBlock =
            new byte[] { (byte)0xfe, (byte)0xa7, (byte)0xd2, (byte)0x76,
                         (byte)0x3b, (byte)0x4b, (byte)0x9e, (byte)0x79 };
        kHashedVerifierBlock =
            new byte[] { (byte)0xd7, (byte)0xaa, (byte)0x0f, (byte)0x6d,
                         (byte)0x30, (byte)0x61, (byte)0x34, (byte)0x4e };
        kCryptoKeyBlock =
            new byte[] { (byte)0x14, (byte)0x6e, (byte)0x0b, (byte)0xe7,
                         (byte)0xab, (byte)0xac, (byte)0xd0, (byte)0xd6 };
        kIntegrityKeyBlock =
            new byte[] { (byte)0x5f, (byte)0xb2, (byte)0xad, (byte)0x01, 
                         (byte)0x0c, (byte)0xb9, (byte)0xe1, (byte)0xf6 };
        kIntegrityValueBlock =
            new byte[] { (byte)0xa0, (byte)0x67, (byte)0x7f, (byte)0x02,
                         (byte)0xb2, (byte)0x2c, (byte)0x84, (byte)0x33 };
    }

    protected AgileDecryptor(AgileEncryptionInfoBuilder builder) {
        super(builder);
    }
    
    
    public boolean verifyPassword(String password) throws GeneralSecurityException {
        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)builder.getVerifier();
        AgileEncryptionHeader header = (AgileEncryptionHeader)builder.getHeader(); 
        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();
        int blockSize = header.getBlockSize();
        int keySize = header.getKeySize()/8;

        byte[] pwHash = hashPassword(password, ver.getHashAlgorithm(), ver.getSalt(), ver.getSpinCount());

        
        byte verfierInputEnc[] = hashInput(builder, pwHash, kVerifierInputBlock, ver.getEncryptedVerifier(), Cipher.DECRYPT_MODE);
        setVerifier(verfierInputEnc);
        MessageDigest hashMD = getMessageDigest(hashAlgo);
        byte[] verifierHash = hashMD.digest(verfierInputEnc);

        
        byte verifierHashDec[] = hashInput(builder, pwHash, kHashedVerifierBlock, ver.getEncryptedVerifierHash(), Cipher.DECRYPT_MODE);
        verifierHashDec = getBlock0(verifierHashDec, hashAlgo.hashSize);
        
        
        byte keyspec[] = hashInput(builder, pwHash, kCryptoKeyBlock, ver.getEncryptedKey(), Cipher.DECRYPT_MODE);
        keyspec = getBlock0(keyspec, keySize);
        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);

        
        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); 
        Cipher cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());
        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);

        
        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());
        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);
        
        if (Arrays.equals(verifierHashDec, verifierHash)) {
            setSecretKey(secretKey);
            setIntegrityHmacKey(hmacKey);
            setIntegrityHmacValue(hmacValue);
            return true;
        } else {
            return false;
        }
    }

    
    public boolean verifyPassword(KeyPair keyPair, X509Certificate x509) throws GeneralSecurityException {
        AgileEncryptionVerifier ver = (AgileEncryptionVerifier)builder.getVerifier();
        AgileEncryptionHeader header = (AgileEncryptionHeader)builder.getHeader();
        HashAlgorithm hashAlgo = header.getHashAlgorithmEx();
        CipherAlgorithm cipherAlgo = header.getCipherAlgorithm();
        int blockSize = header.getBlockSize();
        
        AgileCertificateEntry ace = null;
        for (AgileCertificateEntry aceEntry : ver.getCertificates()) {
            if (x509.equals(aceEntry.x509)) {
                ace = aceEntry;
                break;
            }
        }
        if (ace == null) return false;
        
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
        byte keyspec[] = cipher.doFinal(ace.encryptedKey);
        SecretKeySpec secretKey = new SecretKeySpec(keyspec, ver.getCipherAlgorithm().jceId);
        
        Mac x509Hmac = CryptoFunctions.getMac(hashAlgo);
        x509Hmac.init(secretKey);
        byte certVerifier[] = x509Hmac.doFinal(ace.x509.getEncoded());

        byte vec[] = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityKeyBlock, blockSize); 
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacKey[] = cipher.doFinal(header.getEncryptedHmacKey());
        hmacKey = getBlock0(hmacKey, hashAlgo.hashSize);

        vec = CryptoFunctions.generateIv(hashAlgo, header.getKeySalt(), kIntegrityValueBlock, blockSize);
        cipher = getCipher(secretKey, cipherAlgo, ver.getChainingMode(), vec, Cipher.DECRYPT_MODE);
        byte hmacValue[] = cipher.doFinal(header.getEncryptedHmacValue());
        hmacValue = getBlock0(hmacValue, hashAlgo.hashSize);
        
        
        if (Arrays.equals(ace.certVerifier, certVerifier)) {
            setSecretKey(secretKey);
            setIntegrityHmacKey(hmacKey);
            setIntegrityHmacValue(hmacValue);
            return true;
        } else {
            return false;
        }
    }

    protected static int getNextBlockSize(int inputLen, int blockSize) {
        int fillSize;
        for (fillSize=blockSize; fillSize<inputLen; fillSize+=blockSize);
        return fillSize;
    }

    protected static byte[] hashInput(EncryptionInfoBuilder builder, byte pwHash[], byte blockKey[], byte inputKey[], int cipherMode) {
        EncryptionVerifier ver = builder.getVerifier();
        AgileDecryptor dec = (AgileDecryptor)builder.getDecryptor();
        int keySize = dec.getKeySizeInBytes();
        int blockSize = dec.getBlockSizeInBytes();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte[] salt = ver.getSalt();

        byte intermedKey[] = generateKey(pwHash, hashAlgo, blockKey, keySize);
        SecretKey skey = new SecretKeySpec(intermedKey, ver.getCipherAlgorithm().jceId);
        byte[] iv = generateIv(hashAlgo, salt, null, blockSize);
        Cipher cipher = getCipher(skey, ver.getCipherAlgorithm(), ver.getChainingMode(), iv, cipherMode);
        byte[] hashFinal;
        
        try {
            inputKey = getBlock0(inputKey, getNextBlockSize(inputKey.length, blockSize));
            hashFinal = cipher.doFinal(inputKey);
            return hashFinal;
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException, GeneralSecurityException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);
        _length = dis.readLong();
        
        ChunkedCipherInputStream cipherStream = new AgileCipherInputStream(dis, _length);
        return cipherStream;
    }

    public long getLength(){
        if(_length == -1) throw new IllegalStateException("EcmaDecryptor.getDataStream() was not called");
        return _length;
    }


    protected static Cipher initCipherForBlock(Cipher existing, int block, boolean lastChunk, EncryptionInfoBuilder builder, SecretKey skey, int encryptionMode)
    throws GeneralSecurityException {
        EncryptionHeader header = builder.getHeader();
        if (existing == null || lastChunk) {
            String padding = (lastChunk ? "PKCS5Padding" : "NoPadding");
            existing = getCipher(skey, header.getCipherAlgorithm(), header.getChainingMode(), header.getKeySalt(), encryptionMode, padding);
        }

        byte[] blockKey = new byte[4];
        LittleEndian.putInt(blockKey, 0, block);
        byte[] iv = generateIv(header.getHashAlgorithmEx(), header.getKeySalt(), blockKey, header.getBlockSize());

        AlgorithmParameterSpec aps;
        if (header.getCipherAlgorithm() == CipherAlgorithm.rc2) {
            aps = new RC2ParameterSpec(skey.getEncoded().length*8, iv);
        } else {
            aps = new IvParameterSpec(iv);
        }
            
        existing.init(encryptionMode, skey, aps);
        
        return existing;
    }

    
    private class AgileCipherInputStream extends ChunkedCipherInputStream {
        public AgileCipherInputStream(DocumentInputStream stream, long size)
        throws GeneralSecurityException {
            super(stream, size, 4096);
        }

        
        
        
        protected Cipher initCipherForBlock(Cipher cipher, int block)
        throws GeneralSecurityException {
            return AgileDecryptor.initCipherForBlock(cipher, block, false, builder, getSecretKey(), Cipher.DECRYPT_MODE);
        }
    }
}

<code block>

package org.apache.poi.poifs.crypt.agile;

import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChainingMode;
import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.HashAlgorithm;

import com.microsoft.schemas.office.x2006.encryption.CTDataIntegrity;
import com.microsoft.schemas.office.x2006.encryption.CTKeyData;
import com.microsoft.schemas.office.x2006.encryption.STCipherChaining;

public class AgileEncryptionHeader extends EncryptionHeader {
    private byte encryptedHmacKey[], encryptedHmacValue[];
    
    public AgileEncryptionHeader(String descriptor) {
        this(AgileEncryptionInfoBuilder.parseDescriptor(descriptor));
    }
    
    protected AgileEncryptionHeader(EncryptionDocument ed) {
        CTKeyData keyData;
        try {
            keyData = ed.getEncryption().getKeyData();
            if (keyData == null) {
                throw new NullPointerException("keyData not set");
            }
        } catch (Exception e) {
            throw new EncryptedDocumentException("Unable to parse keyData");
        }

        setKeySize((int)keyData.getKeyBits());
        setFlags(0);
        setSizeExtra(0);
        setCspName(null);
        setBlockSize((int)keyData.getBlockSize());

        int keyBits = (int)keyData.getKeyBits();
        
        CipherAlgorithm ca = CipherAlgorithm.fromXmlId(keyData.getCipherAlgorithm().toString(), keyBits);
        setCipherAlgorithm(ca);
        setCipherProvider(ca.provider);

        if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CBC) {
            setChainingMode(ChainingMode.cbc);
        } else if (keyData.getCipherChaining()==STCipherChaining.CHAINING_MODE_CFB) {
            setChainingMode(ChainingMode.cfb);
        } else {
            throw new EncryptedDocumentException("Unsupported chaining mode - "+keyData.getCipherChaining().toString());
        }
    
        int hashSize = (int)keyData.getHashSize();
        
        HashAlgorithm ha = HashAlgorithm.fromEcmaId(keyData.getHashAlgorithm().toString());
        setHashAlgorithm(ha);

        if (getHashAlgorithmEx().hashSize != hashSize) {
            throw new EncryptedDocumentException("Unsupported hash algorithm: " + 
                    keyData.getHashAlgorithm() + " @ " + hashSize + " bytes");
        }

        int saltLength = (int)keyData.getSaltSize();
        setKeySalt(keyData.getSaltValue());
        if (getKeySalt().length != saltLength) {
            throw new EncryptedDocumentException("Invalid salt length");
        }
        
        CTDataIntegrity di = ed.getEncryption().getDataIntegrity();
        setEncryptedHmacKey(di.getEncryptedHmacKey());
        setEncryptedHmacValue(di.getEncryptedHmacValue());
    }
    
    
    public AgileEncryptionHeader(CipherAlgorithm algorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode) {
        setCipherAlgorithm(algorithm);
        setHashAlgorithm(hashAlgorithm);
        setKeySize(keyBits);
        setBlockSize(blockSize);
        setChainingMode(chainingMode);
    }

    
    protected void setKeySalt(byte salt[]) {
        if (salt == null || salt.length != getBlockSize()) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        super.setKeySalt(salt);
    }

    public byte[] getEncryptedHmacKey() {
        return encryptedHmacKey;
    }

    protected void setEncryptedHmacKey(byte[] encryptedHmacKey) {
        this.encryptedHmacKey = encryptedHmacKey;
    }

    public byte[] getEncryptedHmacValue() {
        return encryptedHmacValue;
    }

    protected void setEncryptedHmacValue(byte[] encryptedHmacValue) {
        this.encryptedHmacValue = encryptedHmacValue;
    }
}

<code block>
package org.apache.poi.poifs.crypt.agile;

import com.microsoft.schemas.office.x2006.encryption.CTEncryption;



public class EncryptionDocument 
{
	CTEncryption  encryption = null;
	
    
    public com.microsoft.schemas.office.x2006.encryption.CTEncryption getEncryption()
    {
    	return encryption;
    }
    
    
    public void setEncryption(com.microsoft.schemas.office.x2006.encryption.CTEncryption encryption)
    {
        this.encryption = encryption;
    }
    
    
    public com.microsoft.schemas.office.x2006.encryption.CTEncryption addNewEncryption()
    {
    	encryption = new CTEncryption();
    	return encryption;
    }
}

<code block>


package org.apache.poi.poifs.crypt.binaryrc4;

import java.io.IOException;
import org.apache.poi.poifs.crypt.*;
import org.apache.poi.util.LittleEndianInput;

public class BinaryRC4EncryptionInfoBuilder implements EncryptionInfoBuilder {

    EncryptionInfo info;
    BinaryRC4EncryptionHeader header;
    BinaryRC4EncryptionVerifier verifier;
    BinaryRC4Decryptor decryptor;
    BinaryRC4Encryptor encryptor;

    public BinaryRC4EncryptionInfoBuilder() {
    }

    public void initialize(EncryptionInfo info, LittleEndianInput dis)
    throws IOException {
        this.info = info;
        int vMajor = info.getVersionMajor();
        int vMinor = info.getVersionMinor();
        assert (vMajor == 1 && vMinor == 1);

        header = new BinaryRC4EncryptionHeader();
        verifier = new BinaryRC4EncryptionVerifier(dis);
        decryptor = new BinaryRC4Decryptor(this);
        encryptor = new BinaryRC4Encryptor(this);
    }

    public void initialize(EncryptionInfo info,
        CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm,
        int keyBits, int blockSize, ChainingMode chainingMode) {
        this.info = info;
        header = new BinaryRC4EncryptionHeader();
        verifier = new BinaryRC4EncryptionVerifier();
        decryptor = new BinaryRC4Decryptor(this);
        encryptor = new BinaryRC4Encryptor(this);
    }

    public BinaryRC4EncryptionHeader getHeader() {
        return header;
    }

    public BinaryRC4EncryptionVerifier getVerifier() {
        return verifier;
    }

    public BinaryRC4Decryptor getDecryptor() {
        return decryptor;
    }

    public BinaryRC4Encryptor getEncryptor() {
        return encryptor;
    }

    public EncryptionInfo getEncryptionInfo() {
        return info;
    }
}

<code block>


package org.apache.poi.poifs.crypt.binaryrc4;

import org.apache.poi.poifs.crypt.CipherAlgorithm;
import org.apache.poi.poifs.crypt.CipherProvider;
import org.apache.poi.poifs.crypt.EncryptionHeader;
import org.apache.poi.poifs.crypt.HashAlgorithm;
import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;

public class BinaryRC4EncryptionHeader extends EncryptionHeader implements
        EncryptionRecord {

    protected BinaryRC4EncryptionHeader() {
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setKeySize(40);
        setBlockSize(-1);
        setCipherProvider(CipherProvider.rc4);
        setHashAlgorithm(HashAlgorithm.md5);
        setSizeExtra(0);
        setFlags(0);
        setCspName("");
        setChainingMode(null);
    }

    public void write(LittleEndianByteArrayOutputStream littleendianbytearrayoutputstream) {
    }
}

<code block>


package org.apache.poi.poifs.crypt.binaryrc4;


import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.*;
import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;
import org.apache.poi.util.LittleEndianInput;

public class BinaryRC4EncryptionVerifier extends EncryptionVerifier implements EncryptionRecord {

    protected BinaryRC4EncryptionVerifier() {
        setSpinCount(-1);
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setChainingMode(null);
        setEncryptedKey(null);
        setHashAlgorithm(HashAlgorithm.md5);
    }

    protected BinaryRC4EncryptionVerifier(LittleEndianInput is) {
        byte salt[] = new byte[16];
        is.readFully(salt);
        setSalt(salt);
        byte encryptedVerifier[] = new byte[16];
        is.readFully(encryptedVerifier);
        setEncryptedVerifier(encryptedVerifier);
        byte encryptedVerifierHash[] = new byte[16];
        is.readFully(encryptedVerifierHash);
        setEncryptedVerifierHash(encryptedVerifierHash);
        setSpinCount(-1);
        setCipherAlgorithm(CipherAlgorithm.rc4);
        setChainingMode(null);
        setEncryptedKey(null);
        setHashAlgorithm(HashAlgorithm.md5);
    }

    protected void setSalt(byte salt[]) {
        if (salt == null || salt.length != 16) {
            throw new EncryptedDocumentException("invalid verifier salt");
        }
        
        super.setSalt(salt);
    }

    protected void setEncryptedVerifier(byte encryptedVerifier[]) {
        super.setEncryptedVerifier(encryptedVerifier);
    }

    protected void setEncryptedVerifierHash(byte encryptedVerifierHash[]) {
        super.setEncryptedVerifierHash(encryptedVerifierHash);
    }

    public void write(LittleEndianByteArrayOutputStream bos) {
        byte salt[] = getSalt();
        assert (salt.length == 16);
        bos.write(salt);
        byte encryptedVerifier[] = getEncryptedVerifier();
        assert (encryptedVerifier.length == 16);
        bos.write(encryptedVerifier);
        byte encryptedVerifierHash[] = getEncryptedVerifierHash();
        assert (encryptedVerifierHash.length == 16);
        bos.write(encryptedVerifierHash);
    }

}

<code block>


package org.apache.poi.poifs.crypt.binaryrc4;

import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.poifs.crypt.*;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentInputStream;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.StringUtil;

public class BinaryRC4Decryptor extends Decryptor {
    private long _length = -1L;
    
    private class BinaryRC4CipherInputStream extends ChunkedCipherInputStream {

        protected Cipher initCipherForBlock(Cipher existing, int block)
                throws GeneralSecurityException {
            return BinaryRC4Decryptor.initCipherForBlock(existing, block, builder, getSecretKey(), Cipher.DECRYPT_MODE);
        }

        public BinaryRC4CipherInputStream(DocumentInputStream stream, long size)
                throws GeneralSecurityException {
            super(stream, size, 512);
        }
    }

    protected BinaryRC4Decryptor(BinaryRC4EncryptionInfoBuilder builder) {
        super(builder);
    }

    public boolean verifyPassword(String password) {
        EncryptionVerifier ver = builder.getVerifier();
        SecretKey skey = generateSecretKey(password, ver);
        try {
            Cipher cipher = initCipherForBlock(null, 0, builder, skey, Cipher.DECRYPT_MODE);
            byte encryptedVerifier[] = ver.getEncryptedVerifier();
            byte verifier[] = new byte[encryptedVerifier.length];
            cipher.update(encryptedVerifier, 0, encryptedVerifier.length, verifier);
            setVerifier(verifier);
            byte encryptedVerifierHash[] = ver.getEncryptedVerifierHash();
            byte verifierHash[] = cipher.doFinal(encryptedVerifierHash);
            HashAlgorithm hashAlgo = ver.getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            if (Arrays.equals(calcVerifierHash, verifierHash)) {
                setSecretKey(skey);
                return true;
            }
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException(e);
        }
        return false;
    }

    protected static Cipher initCipherForBlock(Cipher cipher, int block,
        EncryptionInfoBuilder builder, SecretKey skey, int encryptMode)
    throws GeneralSecurityException {
        EncryptionVerifier ver = builder.getVerifier();
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        byte blockKey[] = new byte[4];
        LittleEndian.putUInt(blockKey, 0, block);
        byte encKey[] = CryptoFunctions.generateKey(skey.getEncoded(), hashAlgo, blockKey, 16);
        SecretKey key = new SecretKeySpec(encKey, skey.getAlgorithm());
        if (cipher == null) {
            EncryptionHeader em = builder.getHeader();
            cipher = CryptoFunctions.getCipher(key, em.getCipherAlgorithm(), null, null, encryptMode);
        } else {
            cipher.init(encryptMode, key);
        }
        return cipher;
    }

    protected static SecretKey generateSecretKey(String password,
            EncryptionVerifier ver) {
        if (password.length() > 255)
            password = password.substring(0, 255);
        HashAlgorithm hashAlgo = ver.getHashAlgorithm();
        MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
        byte hash[] = hashAlg.digest(StringUtil.getToUnicodeLE(password));
        byte salt[] = ver.getSalt();
        hashAlg.reset();
        for (int i = 0; i < 16; i++) {
            hashAlg.update(hash, 0, 5);
            hashAlg.update(salt);
        }

        hash = new byte[5];
        System.arraycopy(hashAlg.digest(), 0, hash, 0, 5);
        SecretKey skey = new SecretKeySpec(hash, ver.getCipherAlgorithm().jceId);
        return skey;
    }

    public InputStream getDataStream(DirectoryNode dir) throws IOException,
            GeneralSecurityException {
        DocumentInputStream dis = dir.createDocumentInputStream(DEFAULT_POIFS_ENTRY);
        _length = dis.readLong();
        BinaryRC4CipherInputStream cipherStream = new BinaryRC4CipherInputStream(dis, _length);
        return cipherStream;
    }

    public long getLength() {
        if (_length == -1L) {
            throw new IllegalStateException("Decryptor.getDataStream() was not called");
        }
        
        return _length;
    }
}

<code block>


package org.apache.poi.poifs.crypt.binaryrc4;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;



import org.apache.poi.EncryptedDocumentException;
import org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
import org.apache.poi.poifs.crypt.CryptoFunctions;
import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.crypt.Encryptor;
import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.util.LittleEndianByteArrayOutputStream;

public class BinaryRC4Encryptor extends Encryptor {

    private final BinaryRC4EncryptionInfoBuilder builder;
    
    protected class BinaryRC4CipherOutputStream extends ChunkedCipherOutputStream {

        protected Cipher initCipherForBlock(Cipher cipher, int block, boolean lastChunk)
        throws GeneralSecurityException {
            return BinaryRC4Decryptor.initCipherForBlock(cipher, block, builder, getSecretKey(), Cipher.ENCRYPT_MODE);
        }

        protected void calculateChecksum(File file, int i) {
        }

        protected void createEncryptionInfoEntry(DirectoryNode dir, File tmpFile)
        throws IOException, GeneralSecurityException {
            BinaryRC4Encryptor.this.createEncryptionInfoEntry(dir);
        }

        public BinaryRC4CipherOutputStream(DirectoryNode dir)
        throws IOException, GeneralSecurityException {
            super(dir, 512);
        }
    }

    protected BinaryRC4Encryptor(BinaryRC4EncryptionInfoBuilder builder) {
        this.builder = builder;
    }

    public void confirmPassword(String password) {
        Random r = new SecureRandom();
        byte salt[] = new byte[16];
        byte verifier[] = new byte[16];
        r.nextBytes(salt);
        r.nextBytes(verifier);
        confirmPassword(password, null, null, verifier, salt, null);
    }

    public void confirmPassword(String password, byte keySpec[],
            byte keySalt[], byte verifier[], byte verifierSalt[],
            byte integritySalt[]) {
        BinaryRC4EncryptionVerifier ver = builder.getVerifier();
        ver.setSalt(verifierSalt);
        SecretKey skey = BinaryRC4Decryptor.generateSecretKey(password, ver);
        setSecretKey(skey);
        try {
            Cipher cipher = BinaryRC4Decryptor.initCipherForBlock(null, 0, builder, skey, Cipher.ENCRYPT_MODE);
            byte encryptedVerifier[] = new byte[16];
            cipher.update(verifier, 0, 16, encryptedVerifier);
            ver.setEncryptedVerifier(encryptedVerifier);
            org.apache.poi.poifs.crypt.HashAlgorithm hashAlgo = ver
                    .getHashAlgorithm();
            MessageDigest hashAlg = CryptoFunctions.getMessageDigest(hashAlgo);
            byte calcVerifierHash[] = hashAlg.digest(verifier);
            byte encryptedVerifierHash[] = cipher.doFinal(calcVerifierHash);
            ver.setEncryptedVerifierHash(encryptedVerifierHash);
        } catch (GeneralSecurityException e) {
            throw new EncryptedDocumentException("Password confirmation failed", e);
        }
    }

    public OutputStream getDataStream(DirectoryNode dir)
    throws IOException, GeneralSecurityException {
        OutputStream countStream = new BinaryRC4CipherOutputStream(dir);
        return countStream;
    }

    protected int getKeySizeInBytes() {
        return builder.getHeader().getKeySize() / 8;
    }

    protected void createEncryptionInfoEntry(DirectoryNode dir) throws IOException {
        DataSpaceMapUtils.addDefaultDataSpace(dir);
        final EncryptionInfo info = builder.getEncryptionInfo();
        final BinaryRC4EncryptionHeader header = builder.getHeader();
        final BinaryRC4EncryptionVerifier verifier = builder.getVerifier();
        EncryptionRecord er = new EncryptionRecord() {
            public void write(LittleEndianByteArrayOutputStream bos) {
                bos.writeShort(info.getVersionMajor());
                bos.writeShort(info.getVersionMinor());
                header.write(bos);
                verifier.write(bos);
            }
        };
        DataSpaceMapUtils.createEncryptionEntry(dir, "EncryptionInfo", er);
    }
}

<code block>


package org.apache.poi.poifs.nio;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

import org.apache.poi.util.IOUtils;


public class FileBackedDataSource extends DataSource {
   private FileChannel channel;
   private boolean writable;
   
   private RandomAccessFile srcFile;

   public FileBackedDataSource(File file) throws FileNotFoundException {
       this(newSrcFile(file, "r"), true);
   }

   public FileBackedDataSource(File file, boolean readOnly) throws FileNotFoundException {
       this(newSrcFile(file, readOnly ? "r" : "rw"), readOnly);
   }

   public FileBackedDataSource(RandomAccessFile srcFile, boolean readOnly) {
       this(srcFile.getChannel(), readOnly);
       this.srcFile = srcFile;
   }   
   
   public FileBackedDataSource(FileChannel channel, boolean readOnly) {
      this.channel = channel;
      this.writable = !readOnly;
   }
   
   public boolean isWriteable() {
       return this.writable;
   }
   
   public FileChannel getChannel() {
       return this.channel;
   }

   @Override
   public ByteBuffer read(int length, long position) throws IOException {
      if(position >= size()) {
         throw new IllegalArgumentException("Position " + position + " past the end of the file");
      }
      
      
      ByteBuffer dst;
      int worked = -1;
      if (writable) {
          dst = channel.map(FileChannel.MapMode.READ_WRITE, position, length);
          worked = 0;
      } else {
          
          channel.position(position);
          dst = ByteBuffer.allocate(length);
          worked = IOUtils.readFully(channel, dst);
      }

      
      if(worked == -1) {
         throw new IllegalArgumentException("Position " + position + " past the end of the file");
      }

      
      dst.position(0);

      
      return dst;
   }

   @Override
   public void write(ByteBuffer src, long position) throws IOException {
      channel.write(src, position);
   }

   @Override
   public void copyTo(OutputStream stream) throws IOException {
      
      WritableByteChannel out = Channels.newChannel(stream);
      
      channel.transferTo(0, channel.size(), out);
   }

   @Override
   public long size() throws IOException {
      return channel.size();
   }

   @Override
   public void close() throws IOException {
      if (srcFile != null) {
          
          srcFile.close();
      } else {
          channel.close();
      }
   }

   private static RandomAccessFile newSrcFile(File file, String mode) throws FileNotFoundException {
       if(!file.exists()) {
           throw new FileNotFoundException(file.toString());
        }
        return new RandomAccessFile(file, mode);
   }
}

<code block>


package org.apache.poi.poifs.nio;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;


public abstract class DataSource {
   public abstract ByteBuffer read(int length, long position) throws IOException;
   public abstract void write(ByteBuffer src, long position) throws IOException;
   public abstract long size() throws IOException;
   
   public abstract void close() throws IOException;
   
   public abstract void copyTo(OutputStream stream) throws IOException;
}

<code block>


package org.apache.poi.poifs.nio;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;


public class ByteArrayBackedDataSource extends DataSource {
   private byte[] buffer;
   private long size;
   
   public ByteArrayBackedDataSource(byte[] data, int size) {
      this.buffer = data;
      this.size = size;
   }
   public ByteArrayBackedDataSource(byte[] data) {
      this(data, data.length);
   }
                
   @Override
   public ByteBuffer read(int length, long position) {
      if(position >= size) {
         throw new IndexOutOfBoundsException(
               "Unable to read " + length + " bytes from " +
               position + " in stream of length " + size
         );
      }
      
      int toRead = (int)Math.min(length, size - position);
      return ByteBuffer.wrap(buffer, (int)position, toRead);
   }
   
   @Override
   public void write(ByteBuffer src, long position) {
      
      long endPosition = position + src.capacity(); 
      if(endPosition > buffer.length) {
         extend(endPosition);
      }
      
      
      src.get(buffer, (int)position, src.capacity());
      
      
      if(endPosition > size) {
         size = endPosition;
      }
   }
   
   private void extend(long length) {
      
      long difference = length - buffer.length;
      if(difference < buffer.length*0.25) {
         difference = (long)(buffer.length*0.25);
      }
      if(difference < 4096) {
         difference = 4096;
      }

      byte[] nb = new byte[(int)(difference+buffer.length)];
      System.arraycopy(buffer, 0, nb, 0, (int)size);
      buffer = nb;
   }
   
   @Override
   public void copyTo(OutputStream stream) throws IOException {
      stream.write(buffer, 0, (int)size);
   }
   
   @Override
   public long size() {
      return size;
   }
   
   @Override
   public void close() {
      buffer = null;
      size = -1;
   }
}

<code block>

package org.apache.poi.hssf;

import org.apache.poi.OldFileFormatException;

public class OldExcelFormatException extends OldFileFormatException {
	public OldExcelFormatException(String s) {
		super(s);
	}
}
<code block>


package org.apache.poi.util;


public final class PngUtils {

    
    private static final byte[] PNG_FILE_HEADER =
        new byte[] { (byte) 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A };

    private PngUtils() {
        
    }

    
    public static boolean matchesPngHeader(byte[] data, int offset) {
        if (data == null || data.length - offset < PNG_FILE_HEADER.length) {
            return false;
        }

        for (int i = 0; i < PNG_FILE_HEADER.length; i++) {
            if (PNG_FILE_HEADER[i] != data[i + offset]) {
                return false;
            }
        }

        return true;
    }
}

<code block>


package org.apache.poi.util;

import java.io.UnsupportedEncodingException;


public class CodePageUtil
{
    
    public static final int CP_037 = 37;

    
    public static final int CP_SJIS = 932;

    
    public static final int CP_GBK = 936;

    
    public static final int CP_MS949 = 949;

    
    public static final int CP_UTF16 = 1200;

    
    public static final int CP_UTF16_BE = 1201;

    
    public static final int CP_WINDOWS_1250 = 1250;

    
    public static final int CP_WINDOWS_1251 = 1251;

    
    public static final int CP_WINDOWS_1252 = 1252;
    public static final int CP_WINDOWS_1252_BIFF23 = 32769;

    
    public static final int CP_WINDOWS_1253 = 1253;

    
    public static final int CP_WINDOWS_1254 = 1254;

    
    public static final int CP_WINDOWS_1255 = 1255;

    
    public static final int CP_WINDOWS_1256 = 1256;

    
    public static final int CP_WINDOWS_1257 = 1257;

    
    public static final int CP_WINDOWS_1258 = 1258;

    
    public static final int CP_JOHAB = 1361;

    
    public static final int CP_MAC_ROMAN = 10000;
    public static final int CP_MAC_ROMAN_BIFF23 = 32768;

    
    public static final int CP_MAC_JAPAN = 10001;

    
    public static final int CP_MAC_CHINESE_TRADITIONAL = 10002;

    
    public static final int CP_MAC_KOREAN = 10003;

    
    public static final int CP_MAC_ARABIC = 10004;

    
    public static final int CP_MAC_HEBREW = 10005;

    
    public static final int CP_MAC_GREEK = 10006;

    
    public static final int CP_MAC_CYRILLIC = 10007;

    
    public static final int CP_MAC_CHINESE_SIMPLE = 10008;

    
    public static final int CP_MAC_ROMANIA = 10010;

    
    public static final int CP_MAC_UKRAINE = 10017;

    
    public static final int CP_MAC_THAI = 10021;

    
    public static final int CP_MAC_CENTRAL_EUROPE = 10029;

    
    public static final int CP_MAC_ICELAND = 10079;

    
    public static final int CP_MAC_TURKISH = 10081;

    
    public static final int CP_MAC_CROATIAN = 10082;

    
    public static final int CP_US_ACSII = 20127;

    
    public static final int CP_KOI8_R = 20866;

    
    public static final int CP_ISO_8859_1 = 28591;

    
    public static final int CP_ISO_8859_2 = 28592;

    
    public static final int CP_ISO_8859_3 = 28593;

    
    public static final int CP_ISO_8859_4 = 28594;

    
    public static final int CP_ISO_8859_5 = 28595;

    
    public static final int CP_ISO_8859_6 = 28596;

    
    public static final int CP_ISO_8859_7 = 28597;

    
    public static final int CP_ISO_8859_8 = 28598;

    
    public static final int CP_ISO_8859_9 = 28599;

    
    public static final int CP_ISO_2022_JP1 = 50220;

    
    public static final int CP_ISO_2022_JP2 = 50221;

    
    public static final int CP_ISO_2022_JP3 = 50222;

    
    public static final int CP_ISO_2022_KR = 50225;

    
    public static final int CP_EUC_JP = 51932;

    
    public static final int CP_EUC_KR = 51949;

    
    public static final int CP_GB2312 = 52936;

    
    public static final int CP_GB18030 = 54936;

    
    public static final int CP_US_ASCII2 = 65000;

    
    public static final int CP_UTF8 = 65001;

    
    public static final int CP_UNICODE = CP_UTF16;
    
    
    public static byte[] getBytesInCodePage(final String string, final int codepage) 
    throws UnsupportedEncodingException 
    {
        String encoding = codepageToEncoding(codepage);
        return string.getBytes(encoding);
    }

    
    public static String getStringFromCodePage(final byte[] string, final int codepage)
    throws UnsupportedEncodingException 
    {
        return getStringFromCodePage(string, 0, string.length, codepage);
    }
    
    
    public static String getStringFromCodePage(final byte[] string, final int offset, 
            final int length, final int codepage) throws UnsupportedEncodingException 
    {
        String encoding = codepageToEncoding(codepage);
        return new String(string, offset, length, encoding);
    }
    
    
    public static String codepageToEncoding(final int codepage)
    throws UnsupportedEncodingException
    {
        return codepageToEncoding(codepage, false);
    }
    
    
    public static String codepageToEncoding(final int codepage, boolean javaLangFormat)
    throws UnsupportedEncodingException
    {
        if (codepage <= 0)
            throw new UnsupportedEncodingException("Codepage number may not be " + codepage);
        
        switch (codepage) {
            case CP_UTF16:
                return "UTF-16";
            case CP_UTF16_BE:
                return "UTF-16BE";
            case CP_UTF8:
                return "UTF-8";
            case CP_037:
                return "cp037";
            case CP_GBK:
                return "GBK";
            case CP_MS949:
                return "ms949";
            case CP_WINDOWS_1250:
                if (javaLangFormat)
                    return "Cp1250";
                else
                    return "windows-1250";
            case CP_WINDOWS_1251:
                if (javaLangFormat)
                    return "Cp1251";
                else
                    return "windows-1251";
            case CP_WINDOWS_1252:
            case CP_WINDOWS_1252_BIFF23:
                if (javaLangFormat)
                    return "Cp1252";
                else
                    return "windows-1252";
            case CP_WINDOWS_1253:
                if (javaLangFormat)
                    return "Cp1253";
                else
                    return "windows-1253";
            case CP_WINDOWS_1254:
                if (javaLangFormat)
                    return "Cp1254";
                else
                    return "windows-1254";
            case CP_WINDOWS_1255:
                if (javaLangFormat)
                    return "Cp1255";
                else
                    return "windows-1255";
            case CP_WINDOWS_1256:
                if (javaLangFormat)
                    return "Cp1255";
                else
                    return "windows-1256";
            case CP_WINDOWS_1257:
                if (javaLangFormat)
                    return "Cp1257";
                else
                    return "windows-1257";
            case CP_WINDOWS_1258:
                if (javaLangFormat)
                    return "Cp1258";
                else
                    return "windows-1258";
            case CP_JOHAB:
                return "johab";
            case CP_MAC_ROMAN:
            case CP_MAC_ROMAN_BIFF23:
                return "MacRoman";
            case CP_MAC_JAPAN:
                return "SJIS";
            case CP_MAC_CHINESE_TRADITIONAL:
                return "Big5";
            case CP_MAC_KOREAN:
                return "EUC-KR";
            case CP_MAC_ARABIC:
                return "MacArabic";
            case CP_MAC_HEBREW:
                return "MacHebrew";
            case CP_MAC_GREEK:
                return "MacGreek";
            case CP_MAC_CYRILLIC:
                return "MacCyrillic";
            case CP_MAC_CHINESE_SIMPLE:
                return "EUC_CN";
            case CP_MAC_ROMANIA:
                return "MacRomania";
            case CP_MAC_UKRAINE:
                return "MacUkraine";
            case CP_MAC_THAI:
                return "MacThai";
            case CP_MAC_CENTRAL_EUROPE:
                return "MacCentralEurope";
            case CP_MAC_ICELAND:
                  return "MacIceland";
            case CP_MAC_TURKISH:
                return "MacTurkish";
            case CP_MAC_CROATIAN:
                return "MacCroatian";
            case CP_US_ACSII:
            case CP_US_ASCII2:
                return "US-ASCII";
            case CP_KOI8_R:
                return "KOI8-R";
            case CP_ISO_8859_1:
                if (javaLangFormat)
                    return "ISO8859_1";
                else
                    return "ISO-8859-1";
            case CP_ISO_8859_2:
                if (javaLangFormat)
                    return "ISO8859_2";
                else
                    return "ISO-8859-2";
            case CP_ISO_8859_3:
                if (javaLangFormat)
                    return "ISO8859_3";
                else
                    return "ISO-8859-3";
            case CP_ISO_8859_4:
                if (javaLangFormat)
                    return "ISO8859_4";
                else
                    return "ISO-8859-4";
            case CP_ISO_8859_5:
                if (javaLangFormat)
                    return "ISO8859_5";
                else
                    return "ISO-8859-5";
            case CP_ISO_8859_6:
                if (javaLangFormat)
                    return "ISO8859_6";
                else
                    return "ISO-8859-6";
            case CP_ISO_8859_7:
                if (javaLangFormat)
                    return "ISO8859_7";
                else
                    return "ISO-8859-7";
            case CP_ISO_8859_8:
                if (javaLangFormat)
                    return "ISO8859_8";
                else
                    return "ISO-8859-8";
            case CP_ISO_8859_9:
                if (javaLangFormat)
                    return "ISO8859_9";
                else
                    return "ISO-8859-9";
            case CP_ISO_2022_JP1:
            case CP_ISO_2022_JP2:
            case CP_ISO_2022_JP3:
                return "ISO-2022-JP";
            case CP_ISO_2022_KR:
                return "ISO-2022-KR";
            case CP_EUC_JP:
                return "EUC-JP";
            case CP_EUC_KR:
                return "EUC-KR";
            case CP_GB2312:
                return "GB2312";
            case CP_GB18030:
                return "GB18030";
            case CP_SJIS:
                return "SJIS";
            default:
                return "cp" + codepage;
        }
    }
}

<code block>


        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class IntegerField
    implements FixedField
{
    private int       _value;
    private final int _offset;

    

    public IntegerField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("negative offset");
        }
        _offset = offset;
    }

    

    public IntegerField(final int offset, final int value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public IntegerField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public IntegerField(final int offset, final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public int get()
    {
        return _value;
    }

    

    public void set(final int value)
    {
        _value = value;
    }

    

    public void set(final int value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getInt(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readInt(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putInt(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.apache.poi.util;


public class IntList
{
    private int[]            _array;
    private int              _limit;
    private int              fillval = 0;
    private static final int _default_size = 128;

    

    public IntList()
    {
        this(_default_size);
    }

    public IntList(final int initialCapacity)
    {
        this(initialCapacity,0);
    }


    

    public IntList(final IntList list)
    {
        this(list._array.length);
        System.arraycopy(list._array, 0, _array, 0, _array.length);
        _limit = list._limit;
    }

    

    public IntList(final int initialCapacity, int fillvalue)
    {
        _array = new int[ initialCapacity ];
        if (fillval != 0) {
            fillval = fillvalue;
            fillArray(fillval, _array, 0);
        }
        _limit = 0;
    }

    private void fillArray(int val, int[] array, int index) {
      for (int k = index; k < array.length; k++) {
        array[k] = val;
      }
    }

    

    public void add(final int index, final int value)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (index == _limit)
        {
            add(value);
        }
        else
        {

            
            if (_limit == _array.length)
            {
                growArray(_limit * 2);
            }
            System.arraycopy(_array, index, _array, index + 1,
                             _limit - index);
            _array[ index ] = value;
            _limit++;
        }
    }

    

    public boolean add(final int value)
    {
        if (_limit == _array.length)
        {
            growArray(_limit * 2);
        }
        _array[ _limit++ ] = value;
        return true;
    }

    

    public boolean addAll(final IntList c)
    {
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }
            System.arraycopy(c._array, 0, _array, _limit, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public boolean addAll(final int index, final IntList c)
    {
        if (index > _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        if (c._limit != 0)
        {
            if ((_limit + c._limit) > _array.length)
            {
                growArray(_limit + c._limit);
            }

            
            System.arraycopy(_array, index, _array, index + c._limit,
                             _limit - index);

            
            System.arraycopy(c._array, 0, _array, index, c._limit);
            _limit += c._limit;
        }
        return true;
    }

    

    public void clear()
    {
        _limit = 0;
    }

    

    public boolean contains(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (_array[ j ] == o)
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean containsAll(final IntList c)
    {
        boolean rval = true;

        if (this != c)
        {
            for (int j = 0; rval && (j < c._limit); j++)
            {
                if (!contains(c._array[ j ]))
                {
                    rval = false;
                }
            }
        }
        return rval;
    }

    

    public boolean equals(final Object o)
    {
        boolean rval = this == o;

        if (!rval && (o != null) && (o.getClass() == this.getClass()))
        {
            IntList other = ( IntList ) o;

            if (other._limit == _limit)
            {

                
                rval = true;
                for (int j = 0; rval && (j < _limit); j++)
                {
                    rval = _array[ j ] == other._array[ j ];
                }
            }
        }
        return rval;
    }

    

    public int get(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException(
                  index + " not accessible in a list of length " + _limit
            );
        }
        return _array[ index ];
    }

    

    public int hashCode()
    {
        int hash = 0;

        for (int j = 0; j < _limit; j++)
        {
            hash = (31 * hash) + _array[ j ];
        }
        return hash;
    }

    

    public int indexOf(final int o)
    {
        int rval = 0;

        for (; rval < _limit; rval++)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        if (rval == _limit)
        {
            rval = -1;   
        }
        return rval;
    }

    

    public boolean isEmpty()
    {
        return _limit == 0;
    }

    

    public int lastIndexOf(final int o)
    {
        int rval = _limit - 1;

        for (; rval >= 0; rval--)
        {
            if (o == _array[ rval ])
            {
                break;
            }
        }
        return rval;
    }

    

    public int remove(final int index)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        System.arraycopy(_array, index + 1, _array, index, _limit - index);
        _limit--;
        return rval;
    }

    

    public boolean removeValue(final int o)
    {
        boolean rval = false;

        for (int j = 0; !rval && (j < _limit); j++)
        {
            if (o == _array[ j ])
            {
                if (j+1 < _limit) {
                    System.arraycopy(_array, j + 1, _array, j, _limit - j);
                }
                _limit--;
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean removeAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < c._limit; j++)
        {
            if (removeValue(c._array[ j ]))
            {
                rval = true;
            }
        }
        return rval;
    }

    

    public boolean retainAll(final IntList c)
    {
        boolean rval = false;

        for (int j = 0; j < _limit; )
        {
            if (!c.contains(_array[ j ]))
            {
                remove(j);
                rval = true;
            }
            else
            {
                j++;
            }
        }
        return rval;
    }

    

    public int set(final int index, final int element)
    {
        if (index >= _limit)
        {
            throw new IndexOutOfBoundsException();
        }
        int rval = _array[ index ];

        _array[ index ] = element;
        return rval;
    }

    

    public int size()
    {
        return _limit;
    }

    

    public int [] toArray()
    {
        int[] rval = new int[ _limit ];

        System.arraycopy(_array, 0, rval, 0, _limit);
        return rval;
    }

    

    public int [] toArray(final int [] a)
    {
        int[] rval;

        if (a.length == _limit)
        {
            System.arraycopy(_array, 0, a, 0, _limit);
            rval = a;
        }
        else
        {
            rval = toArray();
        }
        return rval;
    }

    private void growArray(final int new_size)
    {
        int   size      = (new_size == _array.length) ? new_size + 1
                                                      : new_size;
        int[] new_array = new int[ size ];

        if (fillval != 0) {
          fillArray(fillval, new_array, _array.length);
        }

        System.arraycopy(_array, 0, new_array, 0, _limit);
        _array = new_array;
    }
}   


<code block>


package org.apache.poi.util;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

import org.apache.poi.EmptyFileException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class IOUtils {

	private static Logger logger = LoggerFactory.getLogger(IOUtils.class);
    

    private IOUtils() {
        
    }

    
    public static byte[] peekFirst8Bytes(InputStream stream) throws IOException, EmptyFileException {
        
        stream.mark(8);

        byte[] header = new byte[8];
        int read = IOUtils.readFully(stream, header);

        if (read < 1)
            throw new EmptyFileException();

        
        if(stream instanceof PushbackInputStream) {
            PushbackInputStream pin = (PushbackInputStream)stream;
            pin.unread(header);
        } else {
            stream.reset();
        }

        return header;
    }

    
    public static byte[] toByteArray(InputStream stream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        byte[] buffer = new byte[4096];
        int read = 0;
        while (read != -1) {
            read = stream.read(buffer);
            if (read > 0) {
                baos.write(buffer, 0, read);
            }
        }

        return baos.toByteArray();
    }

    
    public static byte[] toByteArray(ByteBuffer buffer, int length) {
        if(buffer.hasArray() && buffer.arrayOffset() == 0) {
            
            return buffer.array();
        }

        byte[] data = new byte[length];
        buffer.get(data);
        return data;
    }

    
    public static int readFully(InputStream in, byte[] b) throws IOException {
        return readFully(in, b, 0, b.length);
    }

    
    public static int readFully(InputStream in, byte[] b, int off, int len) throws IOException {
        int total = 0;
        while (true) {
            int got = in.read(b, off + total, len - total);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == len) {
                return total;
            }
        }
    }

    
    public static int readFully(ReadableByteChannel channel, ByteBuffer b) throws IOException {
        int total = 0;
        while (true) {
            int got = channel.read(b);
            if (got < 0) {
                return (total == 0) ? -1 : total;
            }
            total += got;
            if (total == b.capacity() || b.position() == b.capacity()) {
                return total;
            }
        }
    }

    
    public static void copy(InputStream inp, OutputStream out) throws IOException {
        byte[] buff = new byte[4096];
        int count;
        while ((count = inp.read(buff)) != -1) {
            if (count > 0) {
                out.write(buff, 0, count);
            }
        }
    }

    public static long calculateChecksum(byte[] data) {
        Checksum sum = new CRC32();
        sum.update(data, 0, data.length);
        return sum.getValue();
    }

    
    public static void closeQuietly( final Closeable closeable ) {
        try {
            closeable.close();
        } catch ( Exception exc ) {
            logger.error( "Unable to close resource: " + exc,
                    exc );
        }
    }
}

<code block>


        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class LongField
    implements FixedField
{
    private long      _value;
    private final int _offset;

    

    public LongField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("Illegal offset: "
                                                     + offset);
        }
        _offset = offset;
    }

    

    public LongField(final int offset, final long value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public LongField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public LongField(final int offset, final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public long get()
    {
        return _value;
    }

    

    public void set(final long value)
    {
        _value = value;
    }

    

    public void set(final long value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getLong(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readLong(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putLong(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.apache.poi.util;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;


public final class LittleEndianOutputStream extends FilterOutputStream implements LittleEndianOutput {
	public LittleEndianOutputStream(OutputStream out) {
		super(out);
	}

	@Override
    public void writeByte(int v) {
		try {
			out.write(v);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
    public void writeDouble(double v) {
		writeLong(Double.doubleToLongBits(v));
	}

	@Override
    public void writeInt(int v) {
		int b3 = (v >>> 24) & 0xFF;
		int b2 = (v >>> 16) & 0xFF;
		int b1 = (v >>>  8) & 0xFF;
		int b0 = (v >>>  0) & 0xFF;
		try {
			out.write(b0);
			out.write(b1);
			out.write(b2);
			out.write(b3);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
    public void writeLong(long v) {
		writeInt((int)(v >>  0));
		writeInt((int)(v >> 32));
	}

	@Override
    public void writeShort(int v) {
		int b1 = (v >>>  8) & 0xFF;
		int b0 = (v >>>  0) & 0xFF;
		try {
			out.write(b0);
			out.write(b1);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	@Override
    public void write(byte[] b) {
		
		try {
			super.write(b);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	@Override
    public void write(byte[] b, int off, int len) {
		
		try {
			super.write(b, off, len);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
}

<code block>


        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public class ShortField
    implements FixedField
{
    private short     _value;
    private final int _offset;

    

    public ShortField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException("Illegal offset: "
                                                     + offset);
        }
        _offset = offset;
    }

    

    public ShortField(final int offset, final short value)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value);
    }

    

    public ShortField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ShortField(final int offset, final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        set(value, data);
    }

    

    public short get()
    {
        return _value;
    }

    

    public void set(final short value)
    {
        _value = value;
    }

    

    public void set(final short value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = value;
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = LittleEndian.getShort(data, _offset);
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
        _value = LittleEndian.readShort(stream);
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        LittleEndian.putShort(data, _offset, _value);
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.apache.poi.util;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.text.DecimalFormat;


public class HexDump {
    public static final String EOL = System.getProperty("line.separator");
    private static final char _hexcodes[] = "0123456789ABCDEF".toCharArray();
    private static final int _shifts[]   =
    {
        60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0
    };

    private HexDump() {
        
    }

    
    public static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index, final int length)
            throws IOException, ArrayIndexOutOfBoundsException,
                    IllegalArgumentException
    {
        if (data.length == 0)
        {
            stream.write( ("No Data" + EOL).getBytes() );
            stream.flush();
            return;
        }
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                "illegal index: " + index + " into array of length "
                + data.length);
        }
        if (stream == null)
        {
            throw new IllegalArgumentException("cannot write to nullstream");
        }

        long         display_offset = offset + index;
        StringBuffer buffer         = new StringBuffer(74);


        int data_length = Math.min(data.length,index+length);
        for (int j = index; j < data_length; j += 16)
        {
            int chars_read = data_length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(
                        dump(display_offset)
                         ).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            stream.write(buffer.toString().getBytes());
            stream.flush();
            buffer.setLength(0);
            display_offset += chars_read;
        }

    }

    

    public synchronized static void dump(final byte [] data, final long offset,
                            final OutputStream stream, final int index)
        throws IOException, ArrayIndexOutOfBoundsException,
                IllegalArgumentException
    {
        dump(data, offset, stream, index, data.length-index);
    }

    

    public static String dump(final byte [] data, final long offset,
                            final int index) {
        StringBuffer buffer;
        if ((index < 0) || (index >= data.length))
        {
            throw new ArrayIndexOutOfBoundsException(
                "illegal index: " + index + " into array of length "
                + data.length);
        }
        long         display_offset = offset + index;
        buffer         = new StringBuffer(74);

        for (int j = index; j < data.length; j += 16)
        {
            int chars_read = data.length - j;

            if (chars_read > 16)
            {
                chars_read = 16;
            }
            buffer.append(dump(display_offset)).append(' ');
            for (int k = 0; k < 16; k++)
            {
                if (k < chars_read)
                {
                    buffer.append(dump(data[ k + j ]));
                }
                else
                {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (int k = 0; k < chars_read; k++)
            {
                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))
                {
                    buffer.append(( char ) data[ k + j ]);
                }
                else
                {
                    buffer.append('.');
                }
            }
            buffer.append(EOL);
            display_offset += chars_read;
        }
        return buffer.toString();
    }


    private static String dump(final long value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 8; j++)
        {
            buf.append( _hexcodes[ (( int ) (value >> _shifts[ j + _shifts.length - 8 ])) & 15 ]);
        }
        return buf.toString();
    }

    private static String dump(final byte value)
    {
        StringBuffer buf = new StringBuffer();
        buf.setLength(0);
        for (int j = 0; j < 2; j++)
        {
            buf.append(_hexcodes[ (value >> _shifts[ j + 6 ]) & 15 ]);
        }
        return buf.toString();
    }

    
    public static String toHex(final byte[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final short[] value)
    {
        StringBuffer retVal = new StringBuffer();
        retVal.append('[');
        for(int x = 0; x < value.length; x++)
        {
            if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        retVal.append(']');
        return retVal.toString();
    }

    
    public static String toHex(final byte[] value, final int bytesPerLine)
    {
        final int digits =
            (int) Math.round(Math.log(value.length) / Math.log(10) + 0.5);
        final StringBuffer formatString = new StringBuffer();
        for (int i = 0; i < digits; i++)
            formatString.append('0');
        formatString.append(": ");
        final DecimalFormat format = new DecimalFormat(formatString.toString());
        StringBuffer retVal = new StringBuffer();
        retVal.append(format.format(0));
        int i = -1;
        for(int x = 0; x < value.length; x++)
        {
            if (++i == bytesPerLine)
            {
                retVal.append('\n');
                retVal.append(format.format(x));
                i = 0;
            } else if (x>0) {
                retVal.append(", ");
            }
            retVal.append(toHex(value[x]));
        }
        return retVal.toString();
    }

    
    public static String toHex(final short value)
    {
        return toHex(value, 4);
    }

    
    public static String toHex(final byte value)
    {
        return toHex(value, 2);
    }

    
    public static String toHex(final int value)
    {
        return toHex(value, 8);
    }

    
    public static String toHex(final long value)
    {
        return toHex(value, 16);
    }


    private static String toHex(final long value, final int digits)
    {
        StringBuffer result = new StringBuffer(digits);
        for (int j = 0; j < digits; j++)
        {
            result.append( _hexcodes[ (int) ((value >> _shifts[ j + (16 - digits) ]) & 15)]);
        }
        return result.toString();
    }

    
    public static void dump( InputStream in, PrintStream out, int start, int bytesToDump ) throws IOException
    {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        if (bytesToDump == -1)
        {
            int c = in.read();
            while (c != -1)
            {
                buf.write(c);
                c = in.read();
            }
        }
        else
        {
            int bytesRemaining = bytesToDump;
            while (bytesRemaining-- > 0)
            {
                int c = in.read();
                if (c == -1) {
                    break;
                }
                buf.write(c);
            }
        }

        byte[] data = buf.toByteArray();
        dump(data, 0, out, start, data.length);
    }
    
    private static char[] toHexChars(long pValue, int nBytes) {
        int charPos = 2 + nBytes*2;
        
        
        char[] result = new char[charPos];

        long value = pValue;
        do {
            result[--charPos] = _hexcodes[(int) (value & 0x0F)];
            value >>>= 4;
        } while (charPos > 1);

        
        result[0] = '0';
        result[1] = 'x';
        return result;
    }
    
    public static char[] longToHex(long value) {
        return toHexChars(value, 8);
    }
    
    public static char[] intToHex(int value) {
        return toHexChars(value, 4);
    }
    
    public static char[] shortToHex(int value) {
        return toHexChars(value, 2);
    }
    
    public static char[] byteToHex(int value) {
        return toHexChars(value, 1);
    }

    public static void main(String[] args) throws Exception {
        File file = new File(args[0]);
        InputStream in = new BufferedInputStream(new FileInputStream(file));
        byte[] b = new byte[(int)file.length()];
        in.read(b);
        System.out.println(HexDump.dump(b, 0, 0));
        in.close();
    }
}

<code block>


package org.apache.poi.util;

import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;
import java.lang.annotation.Documented;



@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Internal {
    String value() default "";    
}

<code block>


package org.apache.poi.util;

import java.io.File;
import java.io.IOException;


public interface TempFileCreationStrategy {
    
    public File createTempFile(String prefix, String suffix) throws IOException;
}

<code block>


        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;
import java.nio.BufferUnderflowException;



public class ByteField
    implements FixedField
{
    private static final byte _default_value = 0;
    private byte              _value;
    private final int         _offset;

    

    public ByteField(final int offset)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, _default_value);
    }

    

    public ByteField(final int offset, final byte value)
        throws ArrayIndexOutOfBoundsException
    {
        if (offset < 0)
        {
            throw new ArrayIndexOutOfBoundsException(
                "offset cannot be negative");
        }
        _offset = offset;
        set(value);
    }

    

    public ByteField(final int offset, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset);
        readFromBytes(data);
    }

    

    public ByteField(final int offset, final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        this(offset, value);
        writeToBytes(data);
    }

    

    public byte get()
    {
        return _value;
    }

    

    public void set(final byte value)
    {
        _value = value;
    }

    

    public void set(final byte value, final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        set(value);
        writeToBytes(data);
    }

    

    

    public void readFromBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        _value = data[ _offset ];
    }

    

    public void readFromStream(final InputStream stream)
        throws IOException, BufferUnderrunException
    {
    	
    	int ib = stream.read();
    	if (ib < 0) {
    		throw new BufferUnderflowException();
    	}
        _value = (byte) ib;
    }

    

    public void writeToBytes(final byte [] data)
        throws ArrayIndexOutOfBoundsException
    {
        data[ _offset ] = _value;
    }

    

    public String toString()
    {
        return String.valueOf(_value);
    }

    
}   


<code block>


package org.apache.poi.util;

public interface LittleEndianInput {
	int available();
	byte readByte();
	int readUByte();
	short readShort();
	int readUShort();
	int readInt();
	long readLong();
	double readDouble();
	void readFully(byte[] buf);
	void readFully(byte[] buf, int off, int len);
}

<code block>


package org.apache.poi.util;

public interface DelayableLittleEndianOutput extends LittleEndianOutput {
	
	LittleEndianOutput createDelayedOutput(int size);
}

<code block>



package org.apache.poi.util;

import java.util.*;



public class BitFieldFactory {
    private static Map<Integer, BitField> instances = new HashMap<Integer, BitField>();

    public static BitField getInstance(int mask) {
      BitField f = instances.get(Integer.valueOf(mask));
      if (f == null) {
        f = new BitField(mask);
        instances.put(Integer.valueOf(mask), f);
      }
      return f;
    }
}

<code block>


package org.apache.poi.util;

import java.io.FilterInputStream;
import java.io.InputStream;


public class CloseIgnoringInputStream extends FilterInputStream {
   public CloseIgnoringInputStream(InputStream in) {
      super(in);
   }

   public void close() {
      
      return;
   }
}

<code block>


package org.apache.poi.util;

public interface LittleEndianOutput {
	void writeByte(int v);
	void writeShort(int v);
	void writeInt(int v);
	void writeLong(long v);
	void writeDouble(double v);
	void write(byte[] b);
	void write(byte[] b, int offset, int len);
}

<code block>


package org.apache.poi.util;

import java.io.*;
import java.util.List;
import java.util.ArrayList;


public class HexRead
{
    
    public static byte[] readData( String filename ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        try
        {
            return readData( stream, -1 );
        }
        finally
        {
            stream.close();
        }
    }

    
    public static byte[] readData(InputStream stream, String section ) throws IOException {

        try
        {
            StringBuffer sectionText = new StringBuffer();
            boolean inSection = false;
            int c = stream.read();
            while ( c != -1 )
            {
                switch ( c )
                {
                    case '[':
                        inSection = true;
                        break;
                    case '\n':
                    case '\r':
                        inSection = false;
                        sectionText = new StringBuffer();
                        break;
                    case ']':
                        inSection = false;
                        if ( sectionText.toString().equals( section ) ) return readData( stream, '[' );
                        sectionText = new StringBuffer();
                        break;
                    default:
                        if ( inSection ) sectionText.append( (char) c );
                }
                c = stream.read();
            }
        }
        finally
        {
            stream.close();
        }
        throw new IOException( "Section '" + section + "' not found" );
    }
    public static byte[] readData( String filename, String section ) throws IOException
    {
        File file = new File( filename );
        FileInputStream stream = new FileInputStream( file );
        return readData(stream, section);
    }

    static public byte[] readData( InputStream stream, int eofChar )
            throws IOException
    {
        int characterCount = 0;
        byte b = (byte) 0;
        List<Byte> bytes = new ArrayList<Byte>();
        boolean done = false;
        while ( !done )
        {
            int count = stream.read();
            char baseChar = 'a';
            if ( count == eofChar ) break;
            switch ( count )
            {
                case '#':
                    readToEOL( stream );
                    break;
                case '0': case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    b <<= 4;
                    b += (byte) ( count - '0' );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                    baseChar = 'A';
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                    b <<= 4;
                    b += (byte) ( count + 10 - baseChar );
                    characterCount++;
                    if ( characterCount == 2 )
                    {
                        bytes.add( Byte.valueOf( b ) );
                        characterCount = 0;
                        b = (byte) 0;
                    }
                    break;
                case -1:
                    done = true;
                    break;
                default :
                    break;
            }
        }
        Byte[] polished = bytes.toArray( new Byte[0] );
        byte[] rval = new byte[polished.length];
        for ( int j = 0; j < polished.length; j++ )
        {
            rval[j] = polished[j].byteValue();
        }
        return rval;
    }

    static public byte[] readFromString(String data) {
        try {
            return readData(new ByteArrayInputStream( data.getBytes() ), -1);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    static private void readToEOL( InputStream stream ) throws IOException
    {
        int c = stream.read();
        while ( c != -1 && c != '\n' && c != '\r' )
        {
            c = stream.read();
        }
    }
}

<code block>


package org.apache.poi.util;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Method;

import javax.xml.XMLConstants;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;



public final class SAXHelper {

	private static Logger logger = LoggerFactory.getLogger(SAXHelper.class);	
	

    private SAXHelper() {}

    
    public static synchronized XMLReader newXMLReader() throws SAXException, ParserConfigurationException {
        XMLReader xmlReader = saxFactory.newSAXParser().getXMLReader();
        xmlReader.setEntityResolver(IGNORING_ENTITY_RESOLVER);
        trySetSAXFeature(xmlReader, XMLConstants.FEATURE_SECURE_PROCESSING, true);
        trySetXercesSecurityManager(xmlReader);
        return xmlReader;
    }
    
    static final EntityResolver IGNORING_ENTITY_RESOLVER = new EntityResolver() {
        @Override
        public InputSource resolveEntity(String publicId, String systemId)
                throws SAXException, IOException {
            return new InputSource(new StringReader(""));
        }
    };
    
    private static final SAXParserFactory saxFactory;
    static {
        saxFactory = SAXParserFactory.newInstance();
        saxFactory.setValidating(false);
        saxFactory.setNamespaceAware(true);
    }
            
    private static void trySetSAXFeature(XMLReader xmlReader, String feature, boolean enabled) {
        try {
            xmlReader.setFeature(feature, enabled);
        } catch (Exception e) {
            logger.warn("SAX Feature unsupported "+ feature, e);
        } catch (AbstractMethodError ame) {
            logger.warn( "Cannot set SAX feature because outdated XML parser in classpath" + feature, ame);
        }
    }
    
    private static void trySetXercesSecurityManager(XMLReader xmlReader) {
        
        for (String securityManagerClassName : new String[] {
                "com.sun.org.apache.xerces.internal.util.SecurityManager",
                "org.apache.xerces.util.SecurityManager"
        }) {
            try {
                Object mgr = Class.forName(securityManagerClassName).newInstance();
                Method setLimit = mgr.getClass().getMethod("setEntityExpansionLimit", Integer.TYPE);
                setLimit.invoke(mgr, 4096);
                xmlReader.setProperty("http:
                
                return;
            } catch (Exception e) {
                logger.warn( "SAX Security Manager could not be setup", e);
            }
        }
    }
}

<code block>


package org.apache.poi.util;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;


public class LittleEndianInputStream extends FilterInputStream implements LittleEndianInput {
	public LittleEndianInputStream(InputStream is) {
		super(is);
	}
	
	public int available() {
		try {
			return super.available();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	
	public byte readByte() {
		return (byte)readUByte();
	}
	
	public int readUByte() {
		byte buf[] = new byte[1];
		try {
			checkEOF(read(buf), 1);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getUByte(buf);
	}
	
	public double readDouble() {
		return Double.longBitsToDouble(readLong());
	}
	
	public int readInt() {
	    byte buf[] = new byte[LittleEndianConsts.INT_SIZE];
		try {
		    checkEOF(read(buf), buf.length);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getInt(buf);
	}
	
    
    public long readUInt() {
       long retNum = readInt();
       return retNum & 0x00FFFFFFFFl;
    }
	
	public long readLong() {
		byte buf[] = new byte[LittleEndianConsts.LONG_SIZE];
		try {
		    checkEOF(read(buf), LittleEndianConsts.LONG_SIZE);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getLong(buf);
	}
	
	public short readShort() {
		return (short)readUShort();
	}
	
	public int readUShort() {
		byte buf[] = new byte[LittleEndianConsts.SHORT_SIZE];
		try {
		    checkEOF(read(buf), LittleEndianConsts.SHORT_SIZE);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return LittleEndian.getUShort(buf);
	}
	
	private static void checkEOF(int actualBytes, int expectedBytes) {
		if (expectedBytes != 0 && (actualBytes == -1 || actualBytes != expectedBytes)) {
			throw new RuntimeException("Unexpected end-of-file");
		}
	}

	public void readFully(byte[] buf) {
		readFully(buf, 0, buf.length);
	}

	public void readFully(byte[] buf, int off, int len) {
	    try {
	        checkEOF(read(buf, off, len), len);
	    } catch (IOException e) {
            throw new RuntimeException(e);
        }
	}
}

<code block>


package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.events.Namespace;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;

public final class DocumentHelper {

	private static Logger logger = LoggerFactory.getLogger(DocumentHelper.class);	
	
    
    private DocumentHelper() {}

    
    public static synchronized DocumentBuilder newDocumentBuilder() {
        try {
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            documentBuilder.setEntityResolver(SAXHelper.IGNORING_ENTITY_RESOLVER);
            return documentBuilder;
        } catch (ParserConfigurationException e) {
            throw new IllegalStateException("cannot create a DocumentBuilder", e);
        }
    }

    private static final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
    static {
        documentBuilderFactory.setNamespaceAware(true);
        documentBuilderFactory.setValidating(false);
        trySetSAXFeature(documentBuilderFactory, XMLConstants.FEATURE_SECURE_PROCESSING, true);
        trySetXercesSecurityManager(documentBuilderFactory);
    }

    private static void trySetSAXFeature(DocumentBuilderFactory documentBuilderFactory, String feature, boolean enabled) {
        try {
            documentBuilderFactory.setFeature(feature, enabled);
        } catch (Exception e) {
            logger.warn( "SAX Feature unsupported " + feature, e);
        } catch (AbstractMethodError ame) {
            logger.warn("Cannot set SAX feature because outdated XML parser in classpath " + feature, ame);
        }
    }
    
    private static void trySetXercesSecurityManager(DocumentBuilderFactory documentBuilderFactory) {
        
        for (String securityManagerClassName : new String[] {
                "com.sun.org.apache.xerces.internal.util.SecurityManager",
                "org.apache.xerces.util.SecurityManager"
        }) {
            try {
                Object mgr = Class.forName(securityManagerClassName).newInstance();
                Method setLimit = mgr.getClass().getMethod("setEntityExpansionLimit", Integer.TYPE);
                setLimit.invoke(mgr, 4096);
                documentBuilderFactory.setAttribute("http:
                
                return;
            } catch (Throwable t) {
                logger.warn( "SAX Security Manager could not be setup", t);
            }
        }
    }

    
    public static Document readDocument(InputStream inp) throws IOException, SAXException {
        return newDocumentBuilder().parse(inp);
    }

    
    private static final DocumentBuilder documentBuilderSingleton = newDocumentBuilder();

    
    public static synchronized Document createDocument() {
        return documentBuilderSingleton.newDocument();
    }

    
    public static void addNamespaceDeclaration(Element element, String namespacePrefix, String namespaceURI) {
        element.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI,
                XMLConstants.XMLNS_ATTRIBUTE + ':' + namespacePrefix,
                namespaceURI);
    }

    
    public static void addNamespaceDeclaration(Element element, Namespace namespace) {
        addNamespaceDeclaration(element, namespace.getPrefix(), namespace.getNamespaceURI());
    }

}

<code block>

package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;


public class BoundedInputStream extends InputStream {

    
    private final InputStream in;

    
    private final long max;

    
    private long pos = 0;

    
    private long mark = -1;

    
    private boolean propagateClose = true;

    
    public BoundedInputStream(InputStream in, long size) {
        
        
        this.max = size;
        this.in = in;
    }

    
    public BoundedInputStream(InputStream in) {
        this(in, -1);
    }

    
    @Override
    public int read() throws IOException {
        if (max>=0 && pos==max) {
            return -1;
        }
        int result = in.read();
        pos++;
        return result;
    }

    
    @Override
    public int read(byte[] b) throws IOException {
        return this.read(b, 0, b.length);
    }

    
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        if (max>=0 && pos>=max) {
            return -1;
        }
        long maxRead = max>=0 ? Math.min(len, max-pos) : len;
        int bytesRead = in.read(b, off, (int)maxRead);

        if (bytesRead==-1) {
            return -1;
        }

        pos+=bytesRead;
        return bytesRead;
    }

    
    @Override
    public long skip(long n) throws IOException {
        long toSkip = max>=0 ? Math.min(n, max-pos) : n;
        long skippedBytes = in.skip(toSkip);
        pos+=skippedBytes;
        return skippedBytes;
    }

    
    @Override
    public int available() throws IOException {
        if (max>=0 && pos>=max) {
            return 0;
        }
        return in.available();
    }

    
    @Override
    public String toString() {
        return in.toString();
    }

    
    @Override
    public void close() throws IOException {
        if (propagateClose) {
            in.close();
        }
    }

    
    @Override
    public synchronized void reset() throws IOException {
        in.reset();
        pos = mark;
    }

    
    @Override
    public synchronized void mark(int readlimit) {
        in.mark(readlimit);
        mark = pos;
    }

    
    @Override
    public boolean markSupported() {
        return in.markSupported();
    }

    
    public boolean isPropagateClose() {
        return propagateClose;
    }

    
    public void setPropagateClose(boolean propagateClose) {
        this.propagateClose = propagateClose;
    }
}

<code block>


package org.apache.poi.util;



public final class LittleEndianByteArrayOutputStream implements LittleEndianOutput, DelayableLittleEndianOutput {
	private final byte[] _buf;
	private final int _endIndex;
	private int _writeIndex;

	public LittleEndianByteArrayOutputStream(byte[] buf, int startOffset, int maxWriteLen) {
		if (startOffset < 0 || startOffset > buf.length) {
			throw new IllegalArgumentException("Specified startOffset (" + startOffset 
					+ ") is out of allowable range (0.." + buf.length + ")");
		}
		_buf = buf;
		_writeIndex = startOffset;
		_endIndex = startOffset + maxWriteLen;
		if (_endIndex < startOffset ||  _endIndex > buf.length) {
			throw new IllegalArgumentException("calculated end index (" + _endIndex 
					+ ") is out of allowable range (" + _writeIndex + ".." + buf.length + ")");
		}
	}
	public LittleEndianByteArrayOutputStream(byte[] buf, int startOffset) {
		this(buf, startOffset, buf.length - startOffset);
	}

	private void checkPosition(int i) {
		if (i > _endIndex - _writeIndex) {
			throw new RuntimeException("Buffer overrun");
		}
	}

	public void writeByte(int v) {
		checkPosition(1);
		_buf[_writeIndex++] = (byte)v;
	}

	public void writeDouble(double v) {
		writeLong(Double.doubleToLongBits(v));
	}

	public void writeInt(int v) {
		checkPosition(4);
		int i = _writeIndex;
		_buf[i++] = (byte)((v >>>  0) & 0xFF);
		_buf[i++] = (byte)((v >>>  8) & 0xFF);
		_buf[i++] = (byte)((v >>> 16) & 0xFF);
		_buf[i++] = (byte)((v >>> 24) & 0xFF);
		_writeIndex = i;
	}

	public void writeLong(long v) {
		writeInt((int)(v >>  0));
		writeInt((int)(v >> 32));
	}

	public void writeShort(int v) {
		checkPosition(2);
		int i = _writeIndex;
		_buf[i++] = (byte)((v >>>  0) & 0xFF);
		_buf[i++] = (byte)((v >>>  8) & 0xFF);
		_writeIndex = i;
	}
	public void write(byte[] b) {
		int len = b.length;
		checkPosition(len);
		System.arraycopy(b, 0, _buf, _writeIndex, len);
		_writeIndex += len;
	}
	public void write(byte[] b, int offset, int len) {
		checkPosition(len);
		System.arraycopy(b, offset, _buf, _writeIndex, len);
		_writeIndex += len;
	}
	public int getWriteIndex() {
		return _writeIndex;
	}
	public LittleEndianOutput createDelayedOutput(int size) {
		checkPosition(size);
		LittleEndianOutput result = new LittleEndianByteArrayOutputStream(_buf, _writeIndex, size);
		_writeIndex += size;
		return result;
	}
}

<code block>


        

package org.apache.poi.util;



public interface LittleEndianConsts
{

    
    public static final int BYTE_SIZE   = 1;
    public static final int SHORT_SIZE  = 2;
    public static final int INT_SIZE    = 4;
    public static final int LONG_SIZE   = 8;
    public static final int DOUBLE_SIZE = 8;
}   


<code block>


        

package org.apache.poi.util;

import org.apache.poi.util.LittleEndian.BufferUnderrunException;

import java.io.*;



public interface FixedField
{

    

    public void readFromBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public void readFromStream(InputStream stream)
        throws IOException, BufferUnderrunException;

    

    public void writeToBytes(byte [] data)
        throws ArrayIndexOutOfBoundsException;

    

    public String toString();
}   


<code block>


        

package org.apache.poi.util;



public class BitField
{
    private final int _mask;
    private final int _shift_count;

    

    public BitField(final int mask)
    {
        _mask = mask;
        int count       = 0;
        int bit_pattern = mask;

        if (bit_pattern != 0)
        {
            while ((bit_pattern & 1) == 0)
            {
                count++;
                bit_pattern >>= 1;
            }
        }
        _shift_count = count;
    }

    

    public int getValue(final int holder)
    {
        return getRawValue(holder) >>> _shift_count;
    }

    

    public short getShortValue(final short holder)
    {
        return ( short ) getValue(holder);
    }

    

    public int getRawValue(final int holder)
    {
        return (holder & _mask);
    }

    

    public short getShortRawValue(final short holder)
    {
        return ( short ) getRawValue(holder);
    }

    

    public boolean isSet(final int holder)
    {
        return (holder & _mask) != 0;
    }

    

    public boolean isAllSet(final int holder)
    {
        return (holder & _mask) == _mask;
    }

    

    public int setValue(final int holder, final int value)
    {
        return (holder & ~_mask) | ((value << _shift_count) & _mask);
    }

    

    public short setShortValue(final short holder, final short value)
    {
        return ( short ) setValue(holder, value);
    }

    

    public int clear(final int holder)
    {
        return holder & ~_mask;
    }

    

    public short clearShort(final short holder)
    {
        return ( short ) clear(holder);
    }

    

    public byte clearByte(final byte holder)
    {
        return ( byte ) clear(holder);
    }

    

    public int set(final int holder)
    {
        return holder | _mask;
    }

    

    public short setShort(final short holder)
    {
        return ( short ) set(holder);
    }

    

    public byte setByte(final byte holder)
    {
        return ( byte ) set(holder);
    }

    

    public int setBoolean(final int holder, final boolean flag)
    {
        return flag ? set(holder)
                    : clear(holder);
    }

    

    public short setShortBoolean(final short holder, final boolean flag)
    {
        return flag ? setShort(holder)
                    : clearShort(holder);
    }

    

    public byte setByteBoolean(final byte holder, final boolean flag)
    {
        return flag ? setByte(holder)
                    : clearByte(holder);
    }
}   


<code block>


        

package org.apache.poi.util;


public class RecordFormatException
    extends RuntimeException
{
    public RecordFormatException(String exception)
    {
        super(exception);
    }
    
    public RecordFormatException(String exception, Throwable thr) {
      super(exception, thr);
    }
    
    public RecordFormatException(Throwable thr) {
      super(thr);
    }
}

<code block>


package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;


public class LittleEndian implements LittleEndianConsts
{

    
    public static final class BufferUnderrunException extends IOException
    {
        
        private static final long serialVersionUID = 8736973884877006145L;

        BufferUnderrunException()
        {
            super( "buffer underrun" );
        }
    }

    
    public static byte[] getByteArray( byte[] data, int offset, int size )
    {
        byte[] copy = new byte[size];
        System.arraycopy( data, offset, copy, 0, size );

        return copy;
    }

    
    public static double getDouble( byte[] data )
    {
        return Double.longBitsToDouble( getLong( data, 0 ) );
    }

    
    public static double getDouble( byte[] data, int offset )
    {
        return Double.longBitsToDouble( getLong( data, offset ) );
    }

    
    public static float getFloat( byte[] data )
    {
        return getFloat( data, 0 );
    }

    
    public static float getFloat( byte[] data, int offset )
    {
        return Float.intBitsToFloat( getInt( data, offset ) );
    }

    
    public static int getInt( byte[] data )
    {
        return getInt( data, 0 );
    }

    
    public static int getInt( byte[] data, int offset )
    {
        int i = offset;
        int b0 = data[i++] & 0xFF;
        int b1 = data[i++] & 0xFF;
        int b2 = data[i++] & 0xFF;
        int b3 = data[i++] & 0xFF;
        return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static long getLong( byte[] data )
    {
        return getLong( data, 0 );
    }

    
    public static long getLong( byte[] data, int offset )
    {
        long result = 0xff & data[offset + 7];

        for ( int j = offset + LONG_SIZE - 1; j >= offset; j-- )
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    
    public static short getShort( byte[] data )
    {
        return getShort( data, 0 );
    }

    
    public static short getShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return (short) ( ( b1 << 8 ) + ( b0 << 0 ) );
    }

    
    public static short[] getShortArray( byte[] data, int offset, int size )
    {
        short[] result = new short[size / SHORT_SIZE];
        for ( int i = 0; i < result.length; i++ )
        {
            result[i] = getShort( data, offset + i * SHORT_SIZE );
        }
        return result;
    }

    
    public static short getUByte( byte[] data )
    {
        return (short) ( data[0] & 0xFF );
    }

    
    public static short getUByte( byte[] data, int offset )
    {
        return (short) ( data[offset] & 0xFF );
    }

    
    public static long getUInt( byte[] data )
    {
        return getUInt( data, 0 );
    }

    
    public static long getUInt( byte[] data, int offset )
    {
        long retNum = getInt( data, offset );
        return retNum & 0x00FFFFFFFFl;
    }

    
    @Deprecated
    public static int getUnsignedByte( byte[] data, int offset )
    {
        return data[offset] & 0xFF;
    }

    
    public static int getUShort( byte[] data )
    {
        return getUShort( data, 0 );
    }

    
    public static int getUShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return ( b1 << 8 ) + ( b0 << 0 );
    }

    
    public static void putByte( byte[] data, int offset, int value )
    {
        data[offset] = (byte) value;
    }

    
    public static void putDouble( byte[] data, int offset, double value )
    {
        putLong( data, offset, Double.doubleToLongBits( value ) );
    }

    
    public static void putDouble( double value, OutputStream outputStream )
            throws IOException
    {
        putLong( Double.doubleToLongBits( value ), outputStream );
    }

    
    public static void putFloat( byte[] data, int offset, float value )
    {
        putInt( data, offset, Float.floatToIntBits( value ) );
    }

    
    public static void putFloat( float value, OutputStream outputStream )
            throws IOException
    {
        putInt( Float.floatToIntBits( value ), outputStream );
    }

    
    @Deprecated
    public static void putInt( byte[] data, int value )
    {
        putInt( data, 0, value );
    }

    
    public static void putInt( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    public static void putInt( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putLong( byte[] data, int offset, long value )
    {
        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );
        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );
        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );
        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );
        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );
    }

    
    public static void putLong( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );
    }

    
    public static void putShort( byte[] data, int offset, short value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    @Deprecated
    public static void putShort( byte[] data, short value )
    {
        putShort( data, 0, value );
    }

    
    public static void putShort( OutputStream outputStream, short value )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static void putShortArray( byte[] data, int startOffset,
            short[] value )
    {
        int offset = startOffset;
        for ( short s : value )
        {
            putShort( data, offset, s );
            offset += SHORT_SIZE;
        }
    }

    
    public static void putUByte( byte[] data, int offset, short value )
    {
        data[offset] = (byte) ( value & 0xFF );
    }

    
    public static void putUInt( byte[] data, int offset, long value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    
    @Deprecated
    public static void putUInt( byte[] data, long value )
    {
        putUInt( data, 0, value );
    }

    
    public static void putUInt( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    
    public static void putUShort( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    
    public static void putUShort( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    
    public static int readInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }
    
    
    public static long readUInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
       long retNum = readInt(stream);
       return retNum & 0x00FFFFFFFFl;
    }

    
    public static long readLong( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        int ch5 = stream.read();
        int ch6 = stream.read();
        int ch7 = stream.read();
        int ch8 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 ) < 0 )
        {
            throw new BufferUnderrunException();
        }

        return ( (long) ch8 << 56 ) + ( (long) ch7 << 48 )
                + ( (long) ch6 << 40 ) + ( (long) ch5 << 32 )
                + ( (long) ch4 << 24 ) + 
                                         
                ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static short readShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        return (short) readUShort( stream );
    }

    public static int readUShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        if ( ( ch1 | ch2 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch2 << 8 ) + ( ch1 << 0 );
    }

    
    public static int ubyteToInt( byte b )
    {
        return b & 0xFF;
    }

    private LittleEndian()
    {
        
    }
}

<code block>


package org.apache.poi.util;

import java.io.File;
import java.io.IOException;


public final class TempFile {
    
    
    private static TempFileCreationStrategy strategy = new DefaultTempFileCreationStrategy();
    
    
    public static void setTempFileCreationStrategy(TempFileCreationStrategy strategy) {
        if (strategy == null) {
            throw new IllegalArgumentException("strategy == null");
        }
        TempFile.strategy = strategy;
    }
    
    
    public static File createTempFile(String prefix, String suffix) throws IOException {
        return strategy.createTempFile(prefix, suffix);
    }
    
    
    public static class DefaultTempFileCreationStrategy implements TempFileCreationStrategy {
        
        
        private File dir;
        
        
        public DefaultTempFileCreationStrategy() {
            this(null);
        }
        
        
        public DefaultTempFileCreationStrategy(File dir) {
            this.dir = dir;
        }
        
        @Override
        public File createTempFile(String prefix, String suffix) throws IOException {
            
            if (dir == null)
            {
                dir = new File(System.getProperty("java.io.tmpdir"), "poifiles");
                dir.mkdir();
                if (System.getProperty("poi.keep.tmp.files") == null)
                    dir.deleteOnExit();
            }

            
            File newFile = File.createTempFile(prefix, suffix, dir);

            
            if (System.getProperty("poi.keep.tmp.files") == null)
                newFile.deleteOnExit();

            
            return newFile;
        }
        
    }
}

<code block>


package org.apache.poi.util;

import java.nio.charset.Charset;
import java.text.FieldPosition;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;



public class StringUtil {
	private static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
	private static final Charset UTF16LE = Charset.forName("UTF-16LE");
    private static Map<Integer,Integer> msCodepointToUnicode;

	private StringUtil() {
		
	}

	
	public static String getFromUnicodeLE(
		final byte[] string,
		final int offset,
		final int len)
		throws ArrayIndexOutOfBoundsException, IllegalArgumentException {
		if ((offset < 0) || (offset >= string.length)) {
			throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");
		}
		if ((len < 0) || (((string.length - offset) / 2) < len)) {
			throw new IllegalArgumentException("Illegal length " + len);
		}

		return new String(string, offset, len * 2, UTF16LE);
	}

	
	public static String getFromUnicodeLE(byte[] string) {
        if(string.length == 0) { return ""; }
        return getFromUnicodeLE(string, 0, string.length / 2);
	}
	
	
	public static byte[] getToUnicodeLE(String string) {
	    return string.getBytes(UTF16LE);
	}

	
	public static String getFromCompressedUnicode(
		final byte[] string,
		final int offset,
		final int len) {
		int len_to_use = Math.min(len, string.length - offset);
		return new String(string, offset, len_to_use, ISO_8859_1);
	}
	
	public static String readCompressedUnicode(LittleEndianInput in, int nChars) {
		byte[] buf = new byte[nChars];
		in.readFully(buf);
		return new String(buf, ISO_8859_1);
	}
	
	
	public static String readUnicodeString(LittleEndianInput in) {

		int nChars = in.readUShort();
		byte flag = in.readByte();
		if ((flag & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static String readUnicodeString(LittleEndianInput in, int nChars) {
		byte is16Bit = in.readByte();
		if ((is16Bit & 0x01) == 0) {
			return readCompressedUnicode(in, nChars);
		}
		return readUnicodeLE(in, nChars);
	}
	
	public static void writeUnicodeString(LittleEndianOutput out, String value) {

		int nChars = value.length();
		out.writeShort(nChars);
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}
	
	public static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {
		boolean is16Bit = hasMultibyte(value);
		out.writeByte(is16Bit ? 0x01 : 0x00);
		if (is16Bit) {
			putUnicodeLE(value, out);
		} else {
			putCompressedUnicode(value, out);
		}
	}

	
	public static int getEncodedSize(String value) {
		int result = 2 + 1;
		result += value.length() * (StringUtil.hasMultibyte(value) ? 2 : 1);
		return result;
	}

	
	public static void putCompressedUnicode(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}

	public static void putCompressedUnicode(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(ISO_8859_1);
		out.write(bytes);
	}

	
	public static void putUnicodeLE(String input, byte[] output, int offset) {
		byte[] bytes = input.getBytes(UTF16LE);
		System.arraycopy(bytes, 0, output, offset, bytes.length);
	}
	public static void putUnicodeLE(String input, LittleEndianOutput out) {
		byte[] bytes = input.getBytes(UTF16LE);
		out.write(bytes);
	}

	public static String readUnicodeLE(LittleEndianInput in, int nChars) {
        byte[] bytes = new byte[nChars*2];
        in.readFully(bytes);
        return new String(bytes, UTF16LE);
	}

	
	public static String format(String message, Object[] params) {
		int currentParamNumber = 0;
		StringBuffer formattedMessage = new StringBuffer();
		for (int i = 0; i < message.length(); i++) {
			if (message.charAt(i) == '%') {
				if (currentParamNumber >= params.length) {
					formattedMessage.append("?missing data?");
				} else if (
					(params[currentParamNumber] instanceof Number)
						&& (i + 1 < message.length())) {
					i
						+= matchOptionalFormatting(
							(Number) params[currentParamNumber++],
							message.substring(i + 1),
							formattedMessage);
				} else {
					formattedMessage.append(
						params[currentParamNumber++].toString());
				}
			} else {
				if ((message.charAt(i) == '\\')
					&& (i + 1 < message.length())
					&& (message.charAt(i + 1) == '%')) {
					formattedMessage.append('%');
					i++;
				} else {
					formattedMessage.append(message.charAt(i));
				}
			}
		}
		return formattedMessage.toString();
	}


	private static int matchOptionalFormatting(
		Number number,
		String formatting,
		StringBuffer outputTo) {
		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
		if ((0 < formatting.length())
			&& Character.isDigit(formatting.charAt(0))) {
			numberFormat.setMinimumIntegerDigits(
				Integer.parseInt(formatting.charAt(0) + ""));
			if ((2 < formatting.length())
				&& (formatting.charAt(1) == '.')
				&& Character.isDigit(formatting.charAt(2))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(2) + ""));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 3;
			}
			numberFormat.format(number, outputTo, new FieldPosition(0));
			return 1;
		} else if (
			(0 < formatting.length()) && (formatting.charAt(0) == '.')) {
			if ((1 < formatting.length())
				&& Character.isDigit(formatting.charAt(1))) {
				numberFormat.setMaximumFractionDigits(
					Integer.parseInt(formatting.charAt(1) + ""));
				numberFormat.format(number, outputTo, new FieldPosition(0));
				return 2;
			}
		}
		numberFormat.format(number, outputTo, new FieldPosition(0));
		return 1;
	}

	
	public static String getPreferredEncoding() {
		return ISO_8859_1.name();
	}

	
	public static boolean hasMultibyte(String value) {
		if (value == null)
			return false;
		for (int i = 0; i < value.length(); i++) {
			char c = value.charAt(i);
			if (c > 0xFF) {
				return true;
			}
		}
		return false;
	}

	
	public static boolean isUnicodeString(final String value) {
        return !value.equals(new String(value.getBytes(ISO_8859_1), ISO_8859_1));
	}
	
   
   public static class StringsIterator implements Iterator<String> {
      private String[] strings;
      private int position = 0;
      public StringsIterator(String[] strings) {
         if(strings != null) {
            this.strings = strings;
         } else {
            this.strings = new String[0];
         }
      }

      public boolean hasNext() {
         return position < strings.length;
      }
      public String next() {
         int ourPos = position++;
         if(ourPos >= strings.length)
            throw new ArrayIndexOutOfBoundsException(ourPos);
         return strings[ourPos];
      }
      public void remove() {}
   }


   
   public static String mapMsCodepointString(String string) {
       if (string == null || "".equals(string)) return string;
       initMsCodepointMap();
       
       StringBuilder sb = new StringBuilder();
       final int length = string.length();
       for (int offset = 0; offset < length; ) {
          Integer msCodepoint = string.codePointAt(offset);
          Integer uniCodepoint = msCodepointToUnicode.get(msCodepoint);
          sb.appendCodePoint(uniCodepoint == null ? msCodepoint : uniCodepoint);
          offset += Character.charCount(msCodepoint);
       }
       
       return sb.toString();
   }
   
   public static synchronized void mapMsCodepoint(int msCodepoint, int unicodeCodepoint) {
       initMsCodepointMap();
       msCodepointToUnicode.put(msCodepoint, unicodeCodepoint);
   }
   
   private static synchronized void initMsCodepointMap() {
       if (msCodepointToUnicode != null) return;
       msCodepointToUnicode = new HashMap<Integer,Integer>();
       int i=0xF020;
       for (int ch : symbolMap_f020) {
           msCodepointToUnicode.put(i++, ch);
       }
       i = 0xf0a0;
       for (int ch : symbolMap_f0a0) {
           msCodepointToUnicode.put(i++, ch);
       }       
   }
   
   private static final int symbolMap_f020[] = {
       ' ', 
       '!', 
       8704, 
       '#', 
       8707, 
       '%', 
       '&', 
       8717, 
       '(', 
       ')', 
       8727, 
       '+', 
       ',', 
       8722, 
       '.', 
       '/', 
       '0', 
       '1', 
       '2', 
       '3', 
       '4', 
       '5', 
       '6', 
       '7', 
       '8', 
       '9', 
       ':', 
       ';', 
       '<', 
       '=', 
       '>', 
       '?', 
       8773, 
       913, 
       914, 
       935, 
       916, 
       917, 
       934, 
       915, 
       919, 
       921, 
       977, 
       922, 
       923, 
       924, 
       925, 
       927, 
       928, 
       920, 
       929, 
       931, 
       932, 
       933, 
       962, 
       937, 
       926, 
       936, 
       918, 
       '[', 
       8765, 
       ']', 
       8869, 
       '_', 
       ' ', 
       945, 
       946, 
       967, 
       948, 
       949, 
       966, 
       947, 
       951, 
       953, 
       981, 
       954, 
       955, 
       956, 
       957, 
       959, 
       960, 
       952, 
       961, 
       963, 
       964, 
       965, 
       982, 
       969, 
       958, 
       968, 
       950, 
       '{', 
       '|', 
       '}', 
       8764, 
       ' ', 
   };

   private static final int symbolMap_f0a0[] = {
       8364, 
       978, 
       8242, 
       8804, 
       8260, 
       8734, 
       402, 
       9827, 
       9830, 
       9829, 
       9824, 
       8596, 
       8591, 
       8593, 
       8594, 
       8595, 
       176, 
       177, 
       8243, 
       8805, 
       215, 
       181, 
       8706, 
       8729, 
       247, 
       8800, 
       8801, 
       8776, 
       8230, 
       9168, 
       9135, 
       8629, 
       8501, 
       8475, 
       8476, 
       8472, 
       8855, 
       8853, 
       8709, 
       8745, 
       8746, 
       8835, 
       8839, 
       8836, 
       8834, 
       8838, 
       8712, 
       8713, 
       8736, 
       8711, 
       174, 
       169, 
       8482, 
       8719, 
       8730, 
       8901, 
       172, 
       8743, 
       8744, 
       8660, 
       8656, 
       8657, 
       8658, 
       8659, 
       9674, 
       9001, 
       174, 
       169, 
       8482, 
       8721, 
       9115, 
       9116, 
       9117, 
       9121, 
       9122, 
       9123, 
       9127, 
       9128, 
       9129, 
       9130, 
       ' ', 
       9002, 
       8747, 
       8992, 
       9134, 
       8993, 
       9118, 
       9119, 
       9120, 
       9124, 
       9125, 
       9126, 
       9131, 
       9132, 
       9133, 
       ' ', 
   };
}

<code block>


package org.apache.poi.hpsf;


public abstract class VariantTypeException extends HPSFException
{

    private Object value;

    private long variantType;



    
    public VariantTypeException(final long variantType, final Object value,
                                final String msg)
    {
        super(msg);
        this.variantType = variantType;
        this.value = value;
    }



    
    public long getVariantType()
    {
        return variantType;
    }



    
    public Object getValue()
    {
        return value;
    }

}

<code block>


package org.apache.poi.hpsf;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.LinkedList;

import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.Entry;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.util.LittleEndianConsts;


public class MutablePropertySet extends PropertySet
{

    
    public MutablePropertySet()
    {
        
        byteOrder = LittleEndian.getUShort(BYTE_ORDER_ASSERTION);

        
        format = LittleEndian.getUShort(FORMAT_ASSERTION);

        
        osVersion = (OS_WIN32 << 16) | 0x0A04;

        
        classID = new ClassID();

        
        sections = new LinkedList<Section>();
        sections.add(new MutableSection());
    }



    
    public MutablePropertySet(final PropertySet ps)
    {
        byteOrder = ps.getByteOrder();
        format = ps.getFormat();
        osVersion = ps.getOSVersion();
        setClassID(ps.getClassID());
        clearSections();
        if (sections == null)
            sections = new LinkedList<Section>();
        for (final Section section : ps.getSections())
        {
            final MutableSection s = new MutableSection(section);
            addSection(s);
        }
    }



    
    private final int OFFSET_HEADER =
        BYTE_ORDER_ASSERTION.length + 
        FORMAT_ASSERTION.length +     
        LittleEndianConsts.INT_SIZE + 
        ClassID.LENGTH +              
        LittleEndianConsts.INT_SIZE;  



    
    public void setByteOrder(final int byteOrder)
    {
        this.byteOrder = byteOrder;
    }



    
    public void setFormat(final int format)
    {
        this.format = format;
    }



    
    public void setOSVersion(final int osVersion)
    {
        this.osVersion = osVersion;
    }



    
    public void setClassID(final ClassID classID)
    {
        this.classID = classID;
    }



    
    public void clearSections()
    {
        sections = null;
    }



    
    public void addSection(final Section section)
    {
        if (sections == null)
            sections = new LinkedList<Section>();
        sections.add(section);
    }



    
    public void write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        final int nrSections = sections.size();
        int length = 0;

        
        length += TypeWriter.writeToStream(out, (short) getByteOrder());
        length += TypeWriter.writeToStream(out, (short) getFormat());
        length += TypeWriter.writeToStream(out, getOSVersion());
        length += TypeWriter.writeToStream(out, getClassID());
        length += TypeWriter.writeToStream(out, nrSections);
        int offset = OFFSET_HEADER;

        
        offset += nrSections * (ClassID.LENGTH + LittleEndian.INT_SIZE);
        final int sectionsBegin = offset;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            final ClassID formatID = s.getFormatID();
            if (formatID == null)
                throw new NoFormatIDException();
            length += TypeWriter.writeToStream(out, s.getFormatID());
            length += TypeWriter.writeUIntToStream(out, offset);
            try
            {
                offset += s.getSize();
            }
            catch (HPSFRuntimeException ex)
            {
                final Throwable cause = ex.getReason();
                if (cause instanceof UnsupportedEncodingException) {
                    throw new IllegalPropertySetDataException(cause);
                }
                throw ex;
            }
        }

        
        offset = sectionsBegin;
        for (final Section section : sections)
        {
            final MutableSection s = (MutableSection)section;
            offset += s.write(out);
        }
        
        
        out.close();
    }



    
    public InputStream toInputStream()
        throws IOException, WritingNotSupportedException
    {
        final ByteArrayOutputStream psStream = new ByteArrayOutputStream();
        try {
            write(psStream);
        } finally {
            psStream.close();
        }
        final byte[] streamData = psStream.toByteArray();
        return new ByteArrayInputStream(streamData);
    }

    
    public void write(final DirectoryEntry dir, final String name)
    throws WritingNotSupportedException, IOException
    {
        
        try
        {
            final Entry e = dir.getEntry(name);
            e.delete();
        }
        catch (FileNotFoundException ex)
        {
            
        }
        
        dir.createDocument(name, toInputStream());
    }

}

<code block>


package org.apache.poi.hpsf;


public class IllegalPropertySetDataException extends HPSFRuntimeException
{

    
    public IllegalPropertySetDataException()
    {
        super();
    }



    
    public IllegalPropertySetDataException(final String msg)
    {
        super(msg);
    }



    
    public IllegalPropertySetDataException(final Throwable reason)
    {
        super(reason);
    }



    
    public IllegalPropertySetDataException(final String msg,
                                           final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


@Internal
class Vector
{
    private final short _type;

    private TypedPropertyValue[] _values;

    Vector( byte[] data, int startOffset, short type )
    {
        this._type = type;
        read( data, startOffset );
    }

    Vector( short type )
    {
        this._type = type;
    }

    int read( byte[] data, int startOffset )
    {
        int offset = startOffset;

        final long longLength = LittleEndian.getUInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        if ( longLength > Integer.MAX_VALUE )
            throw new UnsupportedOperationException( "Vector is too long -- "
                    + longLength );
        final int length = (int) longLength;

        _values = new TypedPropertyValue[length];

        if ( _type == Variant.VT_VARIANT )
        {
            for ( int i = 0; i < length; i++ )
            {
                TypedPropertyValue value = new TypedPropertyValue();
                offset += value.read( data, offset );
                _values[i] = value;
            }
        }
        else
        {
            for ( int i = 0; i < length; i++ )
            {
                TypedPropertyValue value = new TypedPropertyValue( _type, null );
                
                offset += value.readValue( data, offset );
                _values[i] = value;
            }
        }
        return offset - startOffset;
    }

    TypedPropertyValue[] getValues(){
        return _values;
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.LittleEndian;


public class TypeWriter
{

    
    public static int writeToStream( final OutputStream out, final short n )
            throws IOException
    {
        LittleEndian.putShort( out, n ); 
        return LittleEndian.SHORT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final int n )
            throws IOException
    {
        LittleEndian.putInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream( final OutputStream out, final long n )
            throws IOException
    {
        LittleEndian.putLong( n, out );
        return LittleEndian.LONG_SIZE;
    }

    
    public static void writeUShortToStream( final OutputStream out, final int n )
            throws IOException
    {
        int high = n & 0xFFFF0000;
        if ( high != 0 )
            throw new IllegalPropertySetDataException( "Value " + n
                    + " cannot be represented by 2 bytes." );
        LittleEndian.putUShort( n, out );
    }

    
    public static int writeUIntToStream( final OutputStream out, final long n )
            throws IOException
    {
        long high = n & 0xFFFFFFFF00000000L;
        if ( high != 0 && high != 0xFFFFFFFF00000000L )
            throw new IllegalPropertySetDataException( "Value " + n
                    + " cannot be represented by 4 bytes." );
        LittleEndian.putUInt( n, out );
        return LittleEndian.INT_SIZE;
    }

    
    public static int writeToStream(final OutputStream out, final ClassID n)
        throws IOException
    {
        byte[] b = new byte[16];
        n.write(b, 0);
        out.write(b, 0, b.length);
        return b.length;
    }



    
    public static void writeToStream(final OutputStream out,
                                     final Property[] properties,
                                     final int codepage)
        throws IOException, UnsupportedVariantTypeException
    {
        
        if (properties == null)
            return;

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            writeUIntToStream(out, p.getID());
            writeUIntToStream(out, p.getSize());
        }

        
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            long type = p.getType();
            writeUIntToStream(out, type);
            VariantSupport.write(out, (int) type, p.getValue(), codepage);
        }
    }



    
    public static int writeToStream( final OutputStream out, final double n )
            throws IOException
    {
        LittleEndian.putDouble( n, out );
        return LittleEndian.DOUBLE_SIZE;
    }

}

<code block>


package org.apache.poi.hpsf;


public class MarkUnsupportedException extends HPSFException
{

    
    public MarkUnsupportedException()
    {
        super();
    }


    
    public MarkUnsupportedException(final String msg)
    {
        super(msg);
    }


    
    public MarkUnsupportedException(final Throwable reason)
    {
        super(reason);
    }


   
    public MarkUnsupportedException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.apache.poi.hpsf;


public class ReadingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public ReadingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class Currency
{
    static final int SIZE = 8;

    private byte[] _value;

    Currency( byte[] data, int offset )
    {
        _value = LittleEndian.getByteArray( data, offset, SIZE );
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class VariantBool
{


	private static Logger logger = LoggerFactory.getLogger(VariantBool.class);

    static final int SIZE = 2;

    private boolean _value;

    VariantBool( byte[] data, int offset )
    {
        short value = LittleEndian.getShort( data, offset );
        if ( value == 0x0000 )
        {
            _value = false;
            return;
        }

        if ( value == 0xffff )
        {
            _value = true;
            return;
        }

        logger.warn(  "VARIANT_BOOL value '",
                Short.valueOf( value ), "' is incorrect" );
        _value = value != 0;
    }

    boolean getValue()
    {
        return _value;
    }

    void setValue( boolean value )
    {
        this._value = value;
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.util.LittleEndian;


public abstract class SpecialPropertySet extends MutablePropertySet
{
    
    public abstract PropertyIDMap getPropertySetIDMap();

    
    private MutablePropertySet delegate;



    
    public SpecialPropertySet(final PropertySet ps)
    {
        delegate = new MutablePropertySet(ps);
    }



    
    public SpecialPropertySet(final MutablePropertySet ps)
    {
        delegate = ps;
    }



    
    public int getByteOrder()
    {
        return delegate.getByteOrder();
    }



    
    public int getFormat()
    {
        return delegate.getFormat();
    }



    
    public int getOSVersion()
    {
        return delegate.getOSVersion();
    }



    
    public ClassID getClassID()
    {
        return delegate.getClassID();
    }



    
    public int getSectionCount()
    {
        return delegate.getSectionCount();
    }



    
    public List<Section> getSections()
    {
        return delegate.getSections();
    }



    
    public boolean isSummaryInformation()
    {
        return delegate.isSummaryInformation();
    }



    
    public boolean isDocumentSummaryInformation()
    {
        return delegate.isDocumentSummaryInformation();
    }



    
    public Section getFirstSection()
    {
        return delegate.getFirstSection();
    }


    
    public void addSection(final Section section)
    {
        delegate.addSection(section);
    }



    
    public void clearSections()
    {
        delegate.clearSections();
    }



    
    public void setByteOrder(final int byteOrder)
    {
        delegate.setByteOrder(byteOrder);
    }



    
    public void setClassID(final ClassID classID)
    {
        delegate.setClassID(classID);
    }



    
    public void setFormat(final int format)
    {
        delegate.setFormat(format);
    }



    
    public void setOSVersion(final int osVersion)
    {
        delegate.setOSVersion(osVersion);
    }



    
    public InputStream toInputStream() throws IOException, WritingNotSupportedException
    {
        return delegate.toInputStream();
    }



    
    public void write(final DirectoryEntry dir, final String name) throws WritingNotSupportedException, IOException
    {
        delegate.write(dir, name);
    }

    
    public void write(final OutputStream out) throws WritingNotSupportedException, IOException
    {
        delegate.write(out);
    }

    
    public boolean equals(final Object o)
    {
        return delegate.equals(o);
    }

    
    public Property[] getProperties() throws NoSingleSectionException
    {
        return delegate.getProperties();
    }

    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return delegate.getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id) throws NoSingleSectionException
    {
        return delegate.getPropertyIntValue(id);
    }


    
    
    protected String getPropertyStringValue(final int propertyId) {
        Object propertyValue = getProperty(propertyId);
        return getPropertyStringValue(propertyValue);
    }
    protected static String getPropertyStringValue(final Object propertyValue) {
        
        if (propertyValue == null) return null;
        if (propertyValue instanceof String) return (String)propertyValue;
        
        
        if (propertyValue instanceof byte[]) {
            byte[] b = (byte[])propertyValue;
            if (b.length == 0) {
                return "";
            }
            if (b.length == 1) {
                return Byte.toString(b[0]);
            }
            if (b.length == 2) {
                return Integer.toString( LittleEndian.getUShort(b) );
            }
            if (b.length == 4) {
                return Long.toString( LittleEndian.getUInt(b) );
            }
            
            return new String(b);
        }
        return propertyValue.toString();
    }


    
    public int hashCode()
    {
        return delegate.hashCode();
    }



    
    public String toString()
    {
        return delegate.toString();
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return delegate.wasNull();
    }

}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import org.apache.poi.util.CodePageUtil;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class VariantSupport extends Variant
{
	private static Logger logger = LoggerFactory.getLogger(VariantSupport.class);	

    private static boolean logUnsupportedTypes = false;

    
    public static void setLogUnsupportedTypes(final boolean logUnsupportedTypes)
    {
        VariantSupport.logUnsupportedTypes = logUnsupportedTypes;
    }

    
    public static boolean isLogUnsupportedTypes()
    {
        return logUnsupportedTypes;
    }



    
    protected static List<Long> unsupportedMessage;

    
    protected static void writeUnsupportedTypeMessage
        (final UnsupportedVariantTypeException ex)
    {
        if (isLogUnsupportedTypes())
        {
            if (unsupportedMessage == null)
                unsupportedMessage = new LinkedList<Long>();
            Long vt = Long.valueOf(ex.getVariantType());
            if (!unsupportedMessage.contains(vt))
            {
            	logger.error( ex.getMessage());
                unsupportedMessage.add(vt);
            }
        }
    }


    
    final static public int[] SUPPORTED_TYPES = { Variant.VT_EMPTY,
            Variant.VT_I2, Variant.VT_I4, Variant.VT_I8, Variant.VT_R8,
            Variant.VT_FILETIME, Variant.VT_LPSTR, Variant.VT_LPWSTR,
            Variant.VT_CF, Variant.VT_BOOL };



    
    public boolean isSupportedType(final int variantType)
    {
        for (int i = 0; i < SUPPORTED_TYPES.length; i++)
            if (variantType == SUPPORTED_TYPES[i])
                return true;
        return false;
    }



    
    public static Object read( final byte[] src, final int offset,
            final int length, final long type, final int codepage )
            throws ReadingNotSupportedException, UnsupportedEncodingException
    {
        TypedPropertyValue typedPropertyValue = new TypedPropertyValue(
                (int) type, null );
        int unpadded;
        try
        {
            unpadded = typedPropertyValue.readValue( src, offset );
        }
        catch ( UnsupportedOperationException exc )
        {
            int propLength = Math.min( length, src.length - offset );
            final byte[] v = new byte[propLength];
            System.arraycopy( src, offset, v, 0, propLength );
            throw new ReadingNotSupportedException( type, v );
        }

        switch ( (int) type )
        {
        case Variant.VT_EMPTY:
        case Variant.VT_I4:
        case Variant.VT_I8:
        case Variant.VT_R8:
            
            return typedPropertyValue.getValue();

        case Variant.VT_I2:
        {
            
            return Integer.valueOf( ( (Short) typedPropertyValue.getValue() )
                    .intValue() );
        }
        case Variant.VT_FILETIME:
        {
            Filetime filetime = (Filetime) typedPropertyValue.getValue();
            return Util.filetimeToDate( (int) filetime.getHigh(),
                    (int) filetime.getLow() );
        }
        case Variant.VT_LPSTR:
        {
            CodePageString string = (CodePageString) typedPropertyValue
                    .getValue();
            return string.getJavaValue( codepage );
        }
        case Variant.VT_LPWSTR:
        {
            UnicodeString string = (UnicodeString) typedPropertyValue
                    .getValue();
            return string.toJavaString();
        }
        case Variant.VT_CF:
        {
            
            
            
            
            
            
            
            
            ClipboardData clipboardData = (ClipboardData) typedPropertyValue
                    .getValue();
            return clipboardData.toByteArray();
        }

        case Variant.VT_BOOL:
        {
            VariantBool bool = (VariantBool) typedPropertyValue.getValue();
            return Boolean.valueOf( bool.getValue() );
        }

        default:
        {
            
            final byte[] v = new byte[unpadded];
            System.arraycopy( src, offset, v, 0, unpadded );
            throw new ReadingNotSupportedException( type, v );
        }
        }
    }

    
    public static String codepageToEncoding(final int codepage)
    throws UnsupportedEncodingException
    {
        return CodePageUtil.codepageToEncoding(codepage);
    }


    
    public static int write(final OutputStream out, final long type,
                            final Object value, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        switch ((int) type)
        {
            case Variant.VT_BOOL:
            {
                if ( ( (Boolean) value ).booleanValue() )
                {
                    out.write( 0xff );
                    out.write( 0xff );
                }
                else
                {
                    out.write( 0x00 );
                    out.write( 0x00 );
                }
                length += 2;
                break;
            }
            case Variant.VT_LPSTR:
            {
                CodePageString codePageString = new CodePageString( (String) value,
                        codepage );
                length += codePageString.write( out );
                break;
            }
            case Variant.VT_LPWSTR:
            {
                final int nrOfChars = ( (String) value ).length() + 1;
                length += TypeWriter.writeUIntToStream( out, nrOfChars );
                char[] s = ( (String) value ).toCharArray();
                for ( int i = 0; i < s.length; i++ )
                {
                    final int high = ( ( s[i] & 0x0000ff00 ) >> 8 );
                    final int low = ( s[i] & 0x000000ff );
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write( lowb );
                    out.write( highb );
                    length += 2;
                }
                
                out.write( 0x00 );
                out.write( 0x00 );
                length += 2;
                break;
            }
            case Variant.VT_CF:
            {
                final byte[] b = (byte[]) value;
                out.write(b);
                length = b.length;
                break;
            }
            case Variant.VT_EMPTY:
            {
                length += TypeWriter.writeUIntToStream( out, Variant.VT_EMPTY );
                break;
            }
            case Variant.VT_I2:
            {
                length += TypeWriter.writeToStream( out,
                        ( (Integer) value ).shortValue() );
                break;
            }
            case Variant.VT_I4:
            {
                if (!(value instanceof Integer))
                {
                    throw new ClassCastException("Could not cast an object to "
                            + Integer.class.toString() + ": "
                            + value.getClass().toString() + ", "
                            + value.toString());
                }
                length += TypeWriter.writeToStream(out,
                          ((Integer) value).intValue());
                break;
            }
            case Variant.VT_I8:
            {
                length += TypeWriter.writeToStream(out, ((Long) value).longValue());
                break;
            }
            case Variant.VT_R8:
            {
                length += TypeWriter.writeToStream(out,
                          ((Double) value).doubleValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0x00000000FFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                Filetime filetimeValue = new Filetime( low, high);
                length += filetimeValue.write( out );
                break;
            }
            default:
            {
                
                if (value instanceof byte[])
                {
                    final byte[] b = (byte[]) value;
                    out.write(b);
                    length = b.length;
                    writeUnsupportedTypeMessage
                        (new WritingNotSupportedException(type, value));
                }
                else
                    throw new WritingNotSupportedException(type, value);
                break;
            }
        }

        
        while ( ( length & 0x3 ) != 0 )
        {
            out.write( 0x00 );
            length++;
        }

        return length;
    }
}

<code block>


package org.apache.poi.hpsf;

import org.apache.poi.util.HexDump;


public class ClassID
{
    public static final ClassID OLE10_PACKAGE = new ClassID("{0003000C-0000-0000-C000-000000000046}");
    public static final ClassID PPT_SHOW = new ClassID("{64818D10-4F9B-11CF-86EA-00AA00B929E8}");
    public static final ClassID XLS_WORKBOOK = new ClassID("{00020841-0000-0000-C000-000000000046}");
    public static final ClassID TXT_ONLY = new ClassID("{5e941d80-bf96-11cd-b579-08002b30bfeb}"); 
    public static final ClassID EXCEL97      = new ClassID("{00020820-0000-0000-C000-000000000046}");
    public static final ClassID EXCEL95      = new ClassID("{00020810-0000-0000-C000-000000000046}");
    public static final ClassID WORD97       = new ClassID("{00020906-0000-0000-C000-000000000046}");
    public static final ClassID WORD95       = new ClassID("{00020900-0000-0000-C000-000000000046}");
    public static final ClassID POWERPOINT97 = new ClassID("{64818D10-4F9B-11CF-86EA-00AA00B929E8}");
    public static final ClassID POWERPOINT95 = new ClassID("{EA7BAE70-FB3B-11CD-A903-00AA00510EA3}");
    public static final ClassID EQUATION30   = new ClassID("{0002CE02-0000-0000-C000-000000000046}");
	
	
    
    protected byte[] bytes;



    
    public ClassID(final byte[] src, final int offset)
    {
        read(src, offset);
    }


    
    public ClassID()
    {
        bytes = new byte[LENGTH];
        for (int i = 0; i < LENGTH; i++)
            bytes[i] = 0x00;
    }


    
    public ClassID(String externalForm) {
    	bytes = new byte[LENGTH];
        String clsStr = externalForm.replaceAll("[{}-]", "");
        for (int i=0; i<clsStr.length(); i+=2) {
        	bytes[i/2] = (byte)Integer.parseInt(clsStr.substring(i, i+2), 16);
        }
    }
    

    
    public static final int LENGTH = 16;

    
    public int length()
    {
        return LENGTH;
    }



    
    public byte[] getBytes()
    {
        return bytes;
    }



    
    public void setBytes(final byte[] bytes)
    {
        for (int i = 0; i < this.bytes.length; i++)
            this.bytes[i] = bytes[i];
    }



    
    public byte[] read(final byte[] src, final int offset)
    {
        bytes = new byte[16];

        
        bytes[0] = src[3 + offset];
        bytes[1] = src[2 + offset];
        bytes[2] = src[1 + offset];
        bytes[3] = src[0 + offset];

        
        bytes[4] = src[5 + offset];
        bytes[5] = src[4 + offset];

        
        bytes[6] = src[7 + offset];
        bytes[7] = src[6 + offset];

        
        for (int i = 8; i < 16; i++)
            bytes[i] = src[i + offset];

        return bytes;
    }



    
    public void write(final byte[] dst, final int offset)
    throws ArrayStoreException
    {
        
        if (dst.length < 16)
            throw new ArrayStoreException
                ("Destination byte[] must have room for at least 16 bytes, " +
                 "but has a length of only " + dst.length + ".");
        
        dst[0 + offset] = bytes[3];
        dst[1 + offset] = bytes[2];
        dst[2 + offset] = bytes[1];
        dst[3 + offset] = bytes[0];

        
        dst[4 + offset] = bytes[5];
        dst[5 + offset] = bytes[4];

        
        dst[6 + offset] = bytes[7];
        dst[7 + offset] = bytes[6];

        
        for (int i = 8; i < 16; i++)
            dst[i + offset] = bytes[i];
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof ClassID))
            return false;
        final ClassID cid = (ClassID) o;
        if (bytes.length != cid.bytes.length)
            return false;
        for (int i = 0; i < bytes.length; i++)
            if (bytes[i] != cid.bytes[i])
                return false;
        return true;
    }



    
    public int hashCode()
    {
        return new String(bytes).hashCode();
    }



    
    public String toString()
    {
        StringBuffer sbClassId = new StringBuffer(38);
        sbClassId.append('{');
        for (int i = 0; i < 16; i++)
        {
            sbClassId.append(HexDump.toHex(bytes[i]));
            if (i == 3 || i == 5 || i == 7 || i == 9)
                sbClassId.append('-');
        }
        sbClassId.append('}');
        return sbClassId.toString();
    }

}

<code block>


package org.apache.poi.hpsf;


public class MissingSectionException extends HPSFRuntimeException
{

    
    public MissingSectionException()
    {
        super();
    }


    
    public MissingSectionException(final String msg)
    {
        super(msg);
    }


    
    public MissingSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public MissingSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collection;
import java.util.Date;


public class Util
{

    
    public static boolean equal(final byte[] a, final byte[] b)
    {
        if (a.length != b.length)
            return false;
        for (int i = 0; i < a.length; i++)
            if (a[i] != b[i])
                return false;
        return true;
    }



    
    public static void copy(final byte[] src, final int srcOffset,
                            final int length, final byte[] dst,
                            final int dstOffset)
    {
        for (int i = 0; i < length; i++)
            dst[dstOffset + i] = src[srcOffset + i];
    }



    
    public static byte[] cat(final byte[][] byteArrays)
    {
        int capacity = 0;
        for (int i = 0; i < byteArrays.length; i++)
            capacity += byteArrays[i].length;
        final byte[] result = new byte[capacity];
        int r = 0;
        for (int i = 0; i < byteArrays.length; i++)
            for (int j = 0; j < byteArrays[i].length; j++)
                result[r++] = byteArrays[i][j];
        return result;
    }



    
    public static byte[] copy(final byte[] src, final int offset,
                              final int length)
    {
        final byte[] result = new byte[length];
        copy(src, offset, length, result, 0);
        return result;
    }



    
    public static final long EPOCH_DIFF = 11644473600000L;


    
    public static Date filetimeToDate(final int high, final int low)
    {
        final long filetime = ((long) high) << 32 | (low & 0xffffffffL);
        return filetimeToDate(filetime);
    }

    
    public static Date filetimeToDate(final long filetime)
    {
        final long ms_since_16010101 = filetime / (1000 * 10);
        final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF;
        return new Date(ms_since_19700101);
    }



    
    public static long dateToFileTime(final Date date)
    {
        long ms_since_19700101 = date.getTime();
        long ms_since_16010101 = ms_since_19700101 + EPOCH_DIFF;
        return ms_since_16010101 * (1000 * 10);
    }


    
    public static boolean equals(Collection<?> c1, Collection<?> c2)
    {
        Object[] o1 = c1.toArray();
        Object[] o2 = c2.toArray();
        return internalEquals(o1, o2);
    }



    
    public static boolean equals(Object[] c1, Object[] c2)
    {
        final Object[] o1 = c1.clone();
        final Object[] o2 = c2.clone();
        return internalEquals(o1, o2);
    }

    private static boolean internalEquals(Object[] o1, Object[] o2)
    {
        for (int i1 = 0; i1 < o1.length; i1++)
        {
            final Object obj1 = o1[i1];
            boolean matchFound = false;
            for (int i2 = 0; !matchFound && i2 < o1.length; i2++)
            {
                final Object obj2 = o2[i2];
                if (obj1.equals(obj2))
                {
                    matchFound = true;
                    o2[i2] = null;
                }
            }
            if (!matchFound)
                return false;
        }
        return true;
    }



    
    public static byte[] pad4(final byte[] ba)
    {
        final int PAD = 4;
        final byte[] result;
        int l = ba.length % PAD;
        if (l == 0)
            result = ba;
        else
        {
            l = PAD - l;
            result = new byte[ba.length + l];
            System.arraycopy(ba, 0, result, 0, ba.length);
        }
        return result;
    }



    
    public static char[] pad4(final char[] ca)
    {
        final int PAD = 4;
        final char[] result;
        int l = ca.length % PAD;
        if (l == 0)
            result = ca;
        else
        {
            l = PAD - l;
            result = new char[ca.length + l];
            System.arraycopy(ca, 0, result, 0, ca.length);
        }
        return result;
    }



    
    public static char[] pad4(final String s)
    {
        return pad4(s.toCharArray());
    }



    
    public static String toString(final Throwable t)
    {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        t.printStackTrace(pw);
        pw.close();
        try
        {
            sw.close();
            return sw.toString();
        }
        catch (IOException e)
        {
            final StringBuffer b = new StringBuffer(t.getMessage());
            b.append("\n");
            b.append("Could not create a stacktrace. Reason: ");
            b.append(e.getMessage());
            return b.toString();
        }
    }

}

<code block>


package org.apache.poi.hpsf;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class Variant
{

    
    public static final int VT_EMPTY = 0;

    
    public static final int VT_NULL = 1;

    
    public static final int VT_I2 = 2;

    
    public static final int VT_I4 = 3;

    
    public static final int VT_R4 = 4;

    
    public static final int VT_R8 = 5;

    
    public static final int VT_CY = 6;

    
    public static final int VT_DATE = 7;

    
    public static final int VT_BSTR = 8;

    
    public static final int VT_DISPATCH = 9;

    
    public static final int VT_ERROR = 10;

    
    public static final int VT_BOOL = 11;

    
    public static final int VT_VARIANT = 12;

    
    public static final int VT_UNKNOWN = 13;

    
    public static final int VT_DECIMAL = 14;

    
    public static final int VT_I1 = 16;

    
    public static final int VT_UI1 = 17;

    
    public static final int VT_UI2 = 18;

    
    public static final int VT_UI4 = 19;

    
    public static final int VT_I8 = 20;

    
    public static final int VT_UI8 = 21;

    
    public static final int VT_INT = 22;

    
    public static final int VT_UINT = 23;

    
    public static final int VT_VOID = 24;

    
    public static final int VT_HRESULT = 25;

    
    public static final int VT_PTR = 26;

    
    public static final int VT_SAFEARRAY = 27;

    
    public static final int VT_CARRAY = 28;

    
    public static final int VT_USERDEFINED = 29;

    
    public static final int VT_LPSTR = 30;

    
    public static final int VT_LPWSTR = 31;

    
    public static final int VT_FILETIME = 64;

    
    public static final int VT_BLOB = 65;

    
    public static final int VT_STREAM = 66;

    
    public static final int VT_STORAGE = 67;

    
    public static final int VT_STREAMED_OBJECT = 68;

    
    public static final int VT_STORED_OBJECT = 69;

    
    public static final int VT_BLOB_OBJECT = 70;

    
    public static final int VT_CF = 71;

    
    public static final int VT_CLSID = 72;

    
    public static final int VT_VERSIONED_STREAM = 0x0049;

    
    public static final int VT_VECTOR = 0x1000;

    
    public static final int VT_ARRAY = 0x2000;

    
    public static final int VT_BYREF = 0x4000;

    
    public static final int VT_RESERVED = 0x8000;

    
    public static final int VT_ILLEGAL = 0xFFFF;

    
    public static final int VT_ILLEGALMASKED = 0xFFF;

    
    public static final int VT_TYPEMASK = 0xFFF;



    
    private static Map<Long,String> numberToName;

    private static Map<Long,Integer> numberToLength;

    
    public static final Integer LENGTH_UNKNOWN = Integer.valueOf(-2);

    
    public static final Integer LENGTH_VARIABLE = Integer.valueOf(-1);

    
    public static final Integer LENGTH_0 = Integer.valueOf(0);

    
    public static final Integer LENGTH_2 = Integer.valueOf(2);

    
    public static final Integer LENGTH_4 = Integer.valueOf(4);

    
    public static final Integer LENGTH_8 = Integer.valueOf(8);



    static
    {
        
        Map<Long,String> tm1 = new HashMap<Long,String>();
        tm1.put(Long.valueOf(0), "VT_EMPTY");
        tm1.put(Long.valueOf(1), "VT_NULL");
        tm1.put(Long.valueOf(2), "VT_I2");
        tm1.put(Long.valueOf(3), "VT_I4");
        tm1.put(Long.valueOf(4), "VT_R4");
        tm1.put(Long.valueOf(5), "VT_R8");
        tm1.put(Long.valueOf(6), "VT_CY");
        tm1.put(Long.valueOf(7), "VT_DATE");
        tm1.put(Long.valueOf(8), "VT_BSTR");
        tm1.put(Long.valueOf(9), "VT_DISPATCH");
        tm1.put(Long.valueOf(10), "VT_ERROR");
        tm1.put(Long.valueOf(11), "VT_BOOL");
        tm1.put(Long.valueOf(12), "VT_VARIANT");
        tm1.put(Long.valueOf(13), "VT_UNKNOWN");
        tm1.put(Long.valueOf(14), "VT_DECIMAL");
        tm1.put(Long.valueOf(16), "VT_I1");
        tm1.put(Long.valueOf(17), "VT_UI1");
        tm1.put(Long.valueOf(18), "VT_UI2");
        tm1.put(Long.valueOf(19), "VT_UI4");
        tm1.put(Long.valueOf(20), "VT_I8");
        tm1.put(Long.valueOf(21), "VT_UI8");
        tm1.put(Long.valueOf(22), "VT_INT");
        tm1.put(Long.valueOf(23), "VT_UINT");
        tm1.put(Long.valueOf(24), "VT_VOID");
        tm1.put(Long.valueOf(25), "VT_HRESULT");
        tm1.put(Long.valueOf(26), "VT_PTR");
        tm1.put(Long.valueOf(27), "VT_SAFEARRAY");
        tm1.put(Long.valueOf(28), "VT_CARRAY");
        tm1.put(Long.valueOf(29), "VT_USERDEFINED");
        tm1.put(Long.valueOf(30), "VT_LPSTR");
        tm1.put(Long.valueOf(31), "VT_LPWSTR");
        tm1.put(Long.valueOf(64), "VT_FILETIME");
        tm1.put(Long.valueOf(65), "VT_BLOB");
        tm1.put(Long.valueOf(66), "VT_STREAM");
        tm1.put(Long.valueOf(67), "VT_STORAGE");
        tm1.put(Long.valueOf(68), "VT_STREAMED_OBJECT");
        tm1.put(Long.valueOf(69), "VT_STORED_OBJECT");
        tm1.put(Long.valueOf(70), "VT_BLOB_OBJECT");
        tm1.put(Long.valueOf(71), "VT_CF");
        tm1.put(Long.valueOf(72), "VT_CLSID");
        Map<Long,String> tm2 = new HashMap<Long,String>(tm1.size(), 1.0F);
        tm2.putAll(tm1);
        numberToName = Collections.unmodifiableMap(tm2);

        
        Map<Long,Integer> tm3 = new HashMap<Long,Integer>();
        tm3.put(Long.valueOf(0), LENGTH_0);
        tm3.put(Long.valueOf(1), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(2), LENGTH_2);
        tm3.put(Long.valueOf(3), LENGTH_4);
        tm3.put(Long.valueOf(4), LENGTH_4);
        tm3.put(Long.valueOf(5), LENGTH_8);
        tm3.put(Long.valueOf(6), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(7), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(8), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(9), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(10), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(11), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(12), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(13), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(14), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(16), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(17), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(18), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(19), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(20), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(21), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(22), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(23), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(24), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(25), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(26), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(27), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(28), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(29), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(30), LENGTH_VARIABLE);
        tm3.put(Long.valueOf(31), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(64), LENGTH_8);
        tm3.put(Long.valueOf(65), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(66), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(67), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(68), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(69), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(70), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(71), LENGTH_UNKNOWN);
        tm3.put(Long.valueOf(72), LENGTH_UNKNOWN);
        Map<Long,Integer> tm4 = new HashMap<Long,Integer>(tm1.size(), 1.0F);
        tm4.putAll(tm3);
        numberToLength = Collections.unmodifiableMap(tm4);
    }



    
    public static String getVariantName(final long variantType)
    {
        final String name = numberToName.get(Long.valueOf(variantType));
        return name != null ? name : "unknown variant type";
    }

    
    public static int getVariantLength(final long variantType)
    {
        final Long key = Long.valueOf((int) variantType);
        final Integer length = numberToLength.get(key);
        if (length == null)
            return -2;
        return length.intValue();
    }

}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class Date
{
    static final int SIZE = 8;

    private byte[] _value;

    Date( byte[] data, int offset )
    {
        _value = LittleEndian.getByteArray( data, offset, SIZE );
    }
}

<code block>


package org.apache.poi.hpsf;

import java.util.Date;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;


public final class SummaryInformation extends SpecialPropertySet {

    
    public static final String DEFAULT_STREAM_NAME = "\005SummaryInformation";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getSummaryInformationProperties();
    }


    
    public SummaryInformation(final PropertySet ps)
            throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isSummaryInformation())
            throw new UnexpectedPropertySetTypeException("Not a "
                    + getClass().getName());
    }



    
    public String getTitle()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TITLE);
    }



    
    public void setTitle(final String title)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TITLE, title);
    }



    
    public void removeTitle()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TITLE);
    }



    
    public String getSubject()
    {
        return getPropertyStringValue(PropertyIDMap.PID_SUBJECT);
    }



    
    public void setSubject(final String subject)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SUBJECT, subject);
    }



    
    public void removeSubject()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SUBJECT);
    }



    
    public String getAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_AUTHOR);
    }



    
    public void setAuthor(final String author)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_AUTHOR, author);
    }



    
    public void removeAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_AUTHOR);
    }



    
    public String getKeywords()
    {
        return getPropertyStringValue(PropertyIDMap.PID_KEYWORDS);
    }



    
    public void setKeywords(final String keywords)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_KEYWORDS, keywords);
    }



    
    public void removeKeywords()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_KEYWORDS);
    }



    
    public String getComments()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMMENTS);
    }



    
    public void setComments(final String comments)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMMENTS, comments);
    }



    
    public void removeComments()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMMENTS);
    }



    
    public String getTemplate()
    {
        return getPropertyStringValue(PropertyIDMap.PID_TEMPLATE);
    }



    
    public void setTemplate(final String template)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_TEMPLATE, template);
    }



    
    public void removeTemplate()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_TEMPLATE);
    }



    
    public String getLastAuthor()
    {
        return getPropertyStringValue(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public void setLastAuthor(final String lastAuthor)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTAUTHOR, lastAuthor);
    }



    
    public void removeLastAuthor()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTAUTHOR);
    }



    
    public String getRevNumber()
    {
        return getPropertyStringValue(PropertyIDMap.PID_REVNUMBER);
    }



    
    public void setRevNumber(final String revNumber)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_REVNUMBER, revNumber);
    }



    
    public void removeRevNumber()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_REVNUMBER);
    }



    
    public long getEditTime()
    {
        final Date d = (Date) getProperty(PropertyIDMap.PID_EDITTIME);
        if (d == null) {
            return 0;
        }
        return Util.dateToFileTime(d);
    }



    
    public void setEditTime(final long time)
    {
        final Date d = Util.filetimeToDate(time);
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_EDITTIME, Variant.VT_FILETIME, d);
    }



    
    public void removeEditTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_EDITTIME);
    }



    
    public Date getLastPrinted()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public void setLastPrinted(final Date lastPrinted)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LASTPRINTED, Variant.VT_FILETIME,
                lastPrinted);
    }



    
    public void removeLastPrinted()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTPRINTED);
    }



    
    public Date getCreateDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public void setCreateDateTime(final Date createDateTime)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CREATE_DTM, Variant.VT_FILETIME,
                createDateTime);
    }



    
    public void removeCreateDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CREATE_DTM);
    }



    
    public Date getLastSaveDateTime()
    {
        return (Date) getProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public void setLastSaveDateTime(final Date time)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s
                .setProperty(PropertyIDMap.PID_LASTSAVE_DTM,
                        Variant.VT_FILETIME, time);
    }



    
    public void removeLastSaveDateTime()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LASTSAVE_DTM);
    }



    
    public int getPageCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public void setPageCount(final int pageCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PAGECOUNT, pageCount);
    }



    
    public void removePageCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PAGECOUNT);
    }



    
    public int getWordCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public void setWordCount(final int wordCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_WORDCOUNT, wordCount);
    }



    
    public void removeWordCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_WORDCOUNT);
    }



    
    public int getCharCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public void setCharCount(final int charCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CHARCOUNT, charCount);
    }



    
    public void removeCharCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CHARCOUNT);
    }



    
    public byte[] getThumbnail()
    {
        return (byte[]) getProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public void setThumbnail(final byte[] thumbnail)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_THUMBNAIL, 
                Variant.VT_LPSTR, thumbnail);
    }



    
    public void removeThumbnail()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_THUMBNAIL);
    }



    
    public String getApplicationName()
    {
        return getPropertyStringValue(PropertyIDMap.PID_APPNAME);
    }



    
    public void setApplicationName(final String applicationName)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_APPNAME, applicationName);
    }



    
    public void removeApplicationName()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_APPNAME);
    }



    
    public int getSecurity()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SECURITY);
    }



    
    public void setSecurity(final int security)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SECURITY, security);
    }



    
    public void removeSecurity()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SECURITY);
    }

}

<code block>


package org.apache.poi.hpsf;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.LittleEndian;


public class MutableSection extends Section
{
    
    private boolean dirty = true;



    
    private List<Property> preprops;



    
    private byte[] sectionBytes;



    
    public MutableSection()
    {
        dirty = true;
        formatID = null;
        offset = -1;
        preprops = new LinkedList<Property>();
    }



    
    public MutableSection(final Section s)
    {
        setFormatID(s.getFormatID());
        final Property[] pa = s.getProperties();
        final MutableProperty[] mpa = new MutableProperty[pa.length];
        for (int i = 0; i < pa.length; i++)
            mpa[i] = new MutableProperty(pa[i]);
        setProperties(mpa);
        setDictionary(s.getDictionary());
    }



    
    public void setFormatID(final ClassID formatID)
    {
        this.formatID = formatID;
    }



    
    public void setFormatID(final byte[] formatID)
    {
        ClassID fid = getFormatID();
        if (fid == null)
        {
            fid = new ClassID();
            setFormatID(fid);
        }
        fid.setBytes(formatID);
    }



    
    public void setProperties(final Property[] properties)
    {
        this.properties = properties;
        preprops = new LinkedList<Property>();
        for (int i = 0; i < properties.length; i++)
            preprops.add(properties[i]);
        dirty = true;
    }



    
    public void setProperty(final int id, final String value)
    {
        setProperty(id, Variant.VT_LPWSTR, value);
        dirty = true;
    }



    
    public void setProperty(final int id, final int value)
    {
        setProperty(id, Variant.VT_I4, Integer.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long value)
    {
        setProperty(id, Variant.VT_I8, Long.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
        dirty = true;
    }



    
    public void setProperty(final int id, final long variantType,
                            final Object value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(id);
        p.setType(variantType);
        p.setValue(value);
        setProperty(p);
        dirty = true;
    }



    
    public void setProperty(final Property p)
    {
        final long id = p.getID();
        removeProperty(id);
        preprops.add(p);
        dirty = true;
    }



    
    public void removeProperty(final long id)
    {
        for (final Iterator<Property> i = preprops.iterator(); i.hasNext();)
            if (i.next().getID() == id)
            {
                i.remove();
                break;
            }
        dirty = true;
    }



    
    protected void setPropertyBooleanValue(final int id, final boolean value)
    {
        setProperty(id, Variant.VT_BOOL, Boolean.valueOf(value));
    }



    
    public int getSize()
    {
        if (dirty)
        {
            try
            {
                size = calcSize();
                dirty = false;
            }
            catch (HPSFRuntimeException ex)
            {
                throw ex;
            }
            catch (Exception ex)
            {
                throw new HPSFRuntimeException(ex);
            }
        }
        return size;
    }



    
    private int calcSize() throws WritingNotSupportedException, IOException
    {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        write(out);
        out.close();
        
        sectionBytes = Util.pad4(out.toByteArray());
        return sectionBytes.length;
    }



    
    public int write(final OutputStream out)
        throws WritingNotSupportedException, IOException
    {
        
        if (!dirty && sectionBytes != null)
        {
            out.write(sectionBytes);
            return sectionBytes.length;
        }

        
        final ByteArrayOutputStream propertyStream =
            new ByteArrayOutputStream();

        
        final ByteArrayOutputStream propertyListStream =
            new ByteArrayOutputStream();

        
        int position = 0;

        
        position += 2 * LittleEndian.INT_SIZE +
                    getPropertyCount() * 2 * LittleEndian.INT_SIZE;

        
        int codepage = -1;
        if (getProperty(PropertyIDMap.PID_DICTIONARY) != null)
        {
            final Object p1 = getProperty(PropertyIDMap.PID_CODEPAGE);
            if (p1 != null)
            {
                if (!(p1 instanceof Integer))
                    throw new IllegalPropertySetDataException
                        ("The codepage property (ID = 1) must be an " +
                         "Integer object.");
            }
            else
                
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
            codepage = getCodepage();
        }

        
        Collections.sort(preprops, new Comparator<Property>()
            {
                public int compare(final Property p1, final Property p2)
                {
                    if (p1.getID() < p2.getID())
                        return -1;
                    else if (p1.getID() == p2.getID())
                        return 0;
                    else
                        return 1;
                }
            });

        
        for (final ListIterator<Property> i = preprops.listIterator(); i.hasNext();)
        {
            final MutableProperty p = (MutableProperty) i.next();
            final long id = p.getID();

            
            TypeWriter.writeUIntToStream(propertyListStream, p.getID());
            TypeWriter.writeUIntToStream(propertyListStream, position);

            
            if (id != 0)
                
                position += p.write(propertyStream, getCodepage());
            else
            {
                if (codepage == -1)
                    throw new IllegalPropertySetDataException
                        ("Codepage (property 1) is undefined.");
                position += writeDictionary(propertyStream, dictionary,
                                            codepage);
            }
        }
        propertyStream.close();
        propertyListStream.close();

        
        byte[] pb1 = propertyListStream.toByteArray();
        byte[] pb2 = propertyStream.toByteArray();

        
        TypeWriter.writeToStream(out, LittleEndian.INT_SIZE * 2 +
                                      pb1.length + pb2.length);

        
        TypeWriter.writeToStream(out, getPropertyCount());

        
        out.write(pb1);

        
        out.write(pb2);

        int streamLength = LittleEndian.INT_SIZE * 2 + pb1.length + pb2.length;
        return streamLength;
    }



    
    private static int writeDictionary(final OutputStream out,
                                       final Map<Long,String> dictionary, final int codepage)
        throws IOException
    {
        int length = TypeWriter.writeUIntToStream(out, dictionary.size());
        for (final Iterator<Long> i = dictionary.keySet().iterator(); i.hasNext();)
        {
            final Long key = i.next();
            final String value = dictionary.get(key);

            if (codepage == CodePageUtil.CP_UNICODE)
            {
                
                int sLength = value.length() + 1;
                if (sLength % 2 == 1)
                    sLength++;
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, sLength);
                final byte[] ca = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 2; j < ca.length; j += 2)
                {
                    out.write(ca[j+1]);
                    out.write(ca[j]);
                    length += 2;
                }
                sLength -= value.length();
                while (sLength > 0)
                {
                    out.write(0x00);
                    out.write(0x00);
                    length += 2;
                    sLength--;
                }
            }
            else
            {
                
                length += TypeWriter.writeUIntToStream(out, key.longValue());
                length += TypeWriter.writeUIntToStream(out, value.length() + 1);
                final byte[] ba = CodePageUtil.getBytesInCodePage(value, codepage);
                for (int j = 0; j < ba.length; j++)
                {
                    out.write(ba[j]);
                    length++;
                }
                out.write(0x00);
                length++;
            }
        }
        return length;
    }



    
    public int getPropertyCount()
    {
        return preprops.size();
    }



    
    public Property[] getProperties()
    {
        properties = preprops.toArray(new Property[0]);
        return properties;
    }



    
    public Object getProperty(final long id)
    {
        
        getProperties();
        return super.getProperty(id);
    }



    
    public void setDictionary(final Map<Long,String> dictionary)
        throws IllegalPropertySetDataException
    {
        if (dictionary != null)
        {
            this.dictionary = dictionary;

            
            setProperty(PropertyIDMap.PID_DICTIONARY, -1, dictionary);

            
            final Integer codepage =
                (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
            if (codepage == null)
                setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                            Integer.valueOf(CodePageUtil.CP_UNICODE));
        }
        else
            
            removeProperty(PropertyIDMap.PID_DICTIONARY);
    }



    
    public void setProperty(final int id, final Object value)
    {
        if (value instanceof String)
            setProperty(id, (String) value);
        else if (value instanceof Long)
            setProperty(id, ((Long) value).longValue());
        else if (value instanceof Integer)
            setProperty(id, ((Integer) value).intValue());
        else if (value instanceof Short)
            setProperty(id, ((Short) value).intValue());
        else if (value instanceof Boolean)
            setProperty(id, ((Boolean) value).booleanValue());
        else if (value instanceof Date)
            setProperty(id, Variant.VT_FILETIME, value);
        else
            throw new HPSFRuntimeException(
                    "HPSF does not support properties of type " +
                    value.getClass().getName() + ".");
    }



    
    public void clear()
    {
        final Property[] properties = getProperties();
        for (int i = 0; i < properties.length; i++)
        {
            final Property p = properties[i];
            removeProperty(p.getID());
        }
    }

    
    public void setCodepage(final int codepage)
    {
        setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,
                Integer.valueOf(codepage));
    }
}

<code block>


package org.apache.poi.hpsf;

import org.apache.poi.util.HexDump;


public abstract class UnsupportedVariantTypeException
extends VariantTypeException
{

    
    public UnsupportedVariantTypeException(final long variantType,
                                           final Object value)
    {
        super(variantType, value,
              "HPSF does not yet support the variant type " + variantType + 
              " (" + Variant.getVariantName(variantType) + ", " +
              HexDump.toHex(variantType) + "). If you want support for " +
              "this variant type in one of the next POI releases please " +
              "submit a request for enhancement (RFE) to " +
              "<http:
    }



}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class Array
{
    static class ArrayDimension
    {
        static final int SIZE = 8;

        private int _indexOffset;
        private long _size;

        ArrayDimension( byte[] data, int offset )
        {
            _size = LittleEndian.getUInt( data, offset );
            _indexOffset = LittleEndian.getInt( data, offset
                    + LittleEndian.INT_SIZE );
        }
    }

    static class ArrayHeader
    {
        private ArrayDimension[] _dimensions;
        private int _type;

        ArrayHeader( byte[] data, int startOffset )
        {
            int offset = startOffset;

            _type = LittleEndian.getInt( data, offset );
            offset += LittleEndian.INT_SIZE;

            long numDimensionsUnsigned = LittleEndian.getUInt( data, offset );
            offset += LittleEndian.INT_SIZE;

            if ( !( 1 <= numDimensionsUnsigned && numDimensionsUnsigned <= 31 ) )
                throw new IllegalPropertySetDataException(
                        "Array dimension number " + numDimensionsUnsigned
                                + " is not in [1; 31] range" );
            int numDimensions = (int) numDimensionsUnsigned;

            _dimensions = new ArrayDimension[numDimensions];
            for ( int i = 0; i < numDimensions; i++ )
            {
                _dimensions[i] = new ArrayDimension( data, offset );
                offset += ArrayDimension.SIZE;
            }
        }

        long getNumberOfScalarValues()
        {
            long result = 1;
            for ( ArrayDimension dimension : _dimensions )
                result *= dimension._size;
            return result;
        }

        int getSize()
        {
            return LittleEndian.INT_SIZE * 2 + _dimensions.length
                    * ArrayDimension.SIZE;
        }

        int getType()
        {
            return _type;
        }
    }

    private ArrayHeader _header;
    private TypedPropertyValue[] _values;

    Array()
    {
    }

    Array( final byte[] data, final int offset )
    {
        read( data, offset );
    }

    int read( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        _header = new ArrayHeader( data, offset );
        offset += _header.getSize();

        long numberOfScalarsLong = _header.getNumberOfScalarValues();
        if ( numberOfScalarsLong > Integer.MAX_VALUE )
            throw new UnsupportedOperationException(
                    "Sorry, but POI can't store array of properties with size of "
                            + numberOfScalarsLong + " in memory" );
        int numberOfScalars = (int) numberOfScalarsLong;

        _values = new TypedPropertyValue[numberOfScalars];
        final int type = _header._type;
        if ( type == Variant.VT_VARIANT )
        {
            for ( int i = 0; i < numberOfScalars; i++ )
            {
                TypedPropertyValue typedPropertyValue = new TypedPropertyValue();
                offset += typedPropertyValue.read( data, offset );
            }
        }
        else
        {
            for ( int i = 0; i < numberOfScalars; i++ )
            {
                TypedPropertyValue typedPropertyValue = new TypedPropertyValue(
                        type, null );
                offset += typedPropertyValue.readValuePadded( data, offset );
            }
        }

        return offset - startOffset;
    }
}

<code block>


package org.apache.poi.hpsf;


public class NoSingleSectionException extends HPSFRuntimeException
{

    
    public NoSingleSectionException()
    {
        super();
    }


    
    public NoSingleSectionException(final String msg)
    {
        super(msg);
    }


    
    public NoSingleSectionException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoSingleSectionException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.apache.poi.hpsf;


public class NoPropertySetStreamException extends HPSFException
{

    
    public NoPropertySetStreamException()
    {
        super();
    }



    
    public NoPropertySetStreamException(final String msg)
    {
        super(msg);
    }



    
    public NoPropertySetStreamException(final Throwable reason)
    {
        super(reason);
    }



    
    public NoPropertySetStreamException(final String msg,
                                        final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class ClipboardData
{


	private static Logger logger = LoggerFactory.getLogger(ClipboardData.class);

    private int _format;
    private byte[] _value;

    ClipboardData( byte[] data, int offset )
    {
        int size = LittleEndian.getInt( data, offset );

        if ( size < 4 )
        {
            logger.warn( "ClipboardData at offset ",
                    Integer.valueOf( offset ), " size less than 4 bytes "
                            + "(doesn't even have format field!). "
                            + "Setting to format == 0 and hope for the best" );
            _format = 0;
            _value = new byte[0];
            return;
        }

        _format = LittleEndian.getInt( data, offset + LittleEndian.INT_SIZE );
        _value = LittleEndian.getByteArray( data, offset
                + LittleEndian.INT_SIZE * 2, size - LittleEndian.INT_SIZE );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE * 2 + _value.length;
    }

    byte[] getValue()
    {
        return _value;
    }

    byte[] toByteArray()
    {
        byte[] result = new byte[getSize()];
        LittleEndian.putInt( result, 0 * LittleEndian.INT_SIZE,
                LittleEndian.INT_SIZE + _value.length );
        LittleEndian.putInt( result, 1 * LittleEndian.INT_SIZE, _format );
        System.arraycopy( _value, 0, result, LittleEndian.INT_SIZE
                + LittleEndian.INT_SIZE, _value.length );
        return result;
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( LittleEndian.INT_SIZE + _value.length, out );
        LittleEndian.putInt( _format, out );
        out.write( _value );
        return 2 * LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class Blob
{
    private byte[] _value;

    Blob( byte[] data, int offset )
    {
        int size = LittleEndian.getInt( data, offset );

        if ( size == 0 )
        {
            _value = new byte[0];
            return;
        }

        _value = LittleEndian.getByteArray( data, offset
                + LittleEndian.INT_SIZE, size );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>


package org.apache.poi.hpsf;


public class WritingNotSupportedException
    extends UnsupportedVariantTypeException
{

    
    public WritingNotSupportedException(final long variantType,
                                        final Object value)
    {
        super(variantType, value);
    }

}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.LittleEndian;


public class PropertySet
{

    
    static final byte[] BYTE_ORDER_ASSERTION =
        new byte[] {(byte) 0xFE, (byte) 0xFF};

    
    protected int byteOrder;

    
    public int getByteOrder()
    {
        return byteOrder;
    }



    
    static final byte[] FORMAT_ASSERTION =
        new byte[]{(byte) 0x00, (byte) 0x00};

    
    protected int format;

    
    public int getFormat()
    {
        return format;
    }


 
    
    protected int osVersion;


    
    public static final int OS_WIN16     = 0x0000;

    
    public static final int OS_MACINTOSH = 0x0001;

    
    public static final int OS_WIN32     = 0x0002;

    
    public int getOSVersion()
    {
        return osVersion;
    }



    
    protected ClassID classID;

    
    public ClassID getClassID()
    {
        return classID;
    }



    
    public int getSectionCount()
    {
        return sections.size();
    }



    
    protected List<Section> sections;

    
    public List<Section> getSections()
    {
        return sections;
    }



    
    protected PropertySet()
    { }



    
    public PropertySet(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               IOException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream))
        {
            final int avail = stream.available();
            final byte[] buffer = new byte[avail];
            stream.read(buffer, 0, buffer.length);
            init(buffer, 0, buffer.length);
        }
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream, final int offset, final int length)
        throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        if (isPropertySetStream(stream, offset, length))
            init(stream, offset, length);
        else
            throw new NoPropertySetStreamException();
    }



    
    public PropertySet(final byte[] stream)
    throws NoPropertySetStreamException, UnsupportedEncodingException
    {
        this(stream, 0, stream.length);
    }



    
    public static boolean isPropertySetStream(final InputStream stream)
        throws MarkUnsupportedException, IOException
    {
        
        final int BUFFER_SIZE = 50;

        
        if (!stream.markSupported())
            throw new MarkUnsupportedException(stream.getClass().getName());
        stream.mark(BUFFER_SIZE);

        
        final byte[] buffer = new byte[BUFFER_SIZE];
        final int bytes =
            stream.read(buffer, 0,
                        Math.min(buffer.length, stream.available()));
        final boolean isPropertySetStream =
            isPropertySetStream(buffer, 0, bytes);
        stream.reset();
        return isPropertySetStream;
    }



    
    public static boolean isPropertySetStream(final byte[] src,
                                              final int offset,
                                              final int length)
    {
        

        
        int o = offset;
        final int byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        byte[] temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) byteOrder);
        if (!Util.equal(temp, BYTE_ORDER_ASSERTION))
            return false;
        final int format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        temp = new byte[LittleEndian.SHORT_SIZE];
        LittleEndian.putShort(temp, 0, (short) format);
        if (!Util.equal(temp, FORMAT_ASSERTION))
            return false;
        
        o += LittleEndian.INT_SIZE;
        
        o += ClassID.LENGTH;
        final long sectionCount = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            return false;
        return true;
    }



    
    private void init(final byte[] src, final int offset, final int length)
    throws UnsupportedEncodingException
    {
        
        
        
        int o = offset;
        byteOrder = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        format = LittleEndian.getUShort(src, o);
        o += LittleEndian.SHORT_SIZE;
        osVersion = (int) LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;
        classID = new ClassID(src, o);
        o += ClassID.LENGTH;
        final int sectionCount = LittleEndian.getInt(src, o);
        o += LittleEndian.INT_SIZE;
        if (sectionCount < 0)
            throw new HPSFRuntimeException("Section count " + sectionCount +
                                           " is negative.");

        
        
        sections = new ArrayList<Section>( sectionCount );

        
        for (int i = 0; i < sectionCount; i++)
        {
            final Section s = new Section(src, o);
            o += ClassID.LENGTH + LittleEndian.INT_SIZE;
            sections.add(s);
        }
    }



    
    public boolean isSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.SUMMARY_INFORMATION_ID);
    }



    
    public boolean isDocumentSummaryInformation()
    {
        if (sections.size() <= 0)
            return false;
        return Util.equal(sections.get(0).getFormatID().getBytes(),
                          SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
    }



    
    public Property[] getProperties()
        throws NoSingleSectionException
    {
        return getFirstSection().getProperties();
    }



    
    protected Object getProperty(final int id) throws NoSingleSectionException
    {
        return getFirstSection().getProperty(id);
    }



    
    protected boolean getPropertyBooleanValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyBooleanValue(id);
    }



    
    protected int getPropertyIntValue(final int id)
        throws NoSingleSectionException
    {
        return getFirstSection().getPropertyIntValue(id);
    }



    
    public boolean wasNull() throws NoSingleSectionException
    {
        return getFirstSection().wasNull();
    }



    
    public Section getFirstSection()
    {
        if (getSectionCount() < 1)
            throw new MissingSectionException("Property set does not contain any sections.");
        return sections.get(0);
    }



    
    public Section getSingleSection()
    {
        final int sectionCount = getSectionCount();
        if (sectionCount != 1)
            throw new NoSingleSectionException
                ("Property set contains " + sectionCount + " sections.");
        return sections.get(0);
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof PropertySet))
            return false;
        final PropertySet ps = (PropertySet) o;
        int byteOrder1 = ps.getByteOrder();
        int byteOrder2 = getByteOrder();
        ClassID classID1 = ps.getClassID();
        ClassID classID2 = getClassID();
        int format1 = ps.getFormat();
        int format2 = getFormat();
        int osVersion1 = ps.getOSVersion();
        int osVersion2 = getOSVersion();
        int sectionCount1 = ps.getSectionCount();
        int sectionCount2 = getSectionCount();
        if (byteOrder1 != byteOrder2      ||
            !classID1.equals(classID2)    ||
            format1 != format2            ||
            osVersion1 != osVersion2      ||
            sectionCount1 != sectionCount2)
            return false;

        
        return Util.equals(getSections(), ps.getSections());
    }



    
    public int hashCode()
    {
        throw new UnsupportedOperationException("FIXME: Not yet implemented.");
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final int sectionCount = getSectionCount();
        b.append(getClass().getName());
        b.append('[');
        b.append("byteOrder: ");
        b.append(getByteOrder());
        b.append(", classID: ");
        b.append(getClassID());
        b.append(", format: ");
        b.append(getFormat());
        b.append(", OSVersion: ");
        b.append(getOSVersion());
        b.append(", sectionCount: ");
        b.append(sectionCount);
        b.append(", sections: [\n");
        for (Section section: getSections())
            b.append(section);
        b.append(']');
        b.append(']');
        return b.toString();
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


import org.apache.poi.util.StringUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class UnicodeString {


	private static Logger logger = LoggerFactory.getLogger(UnicodeString.class);
	

    private byte[] _value;

    UnicodeString(byte[] data, int offset) {
        int length = LittleEndian.getInt( data, offset );
        int dataOffset = offset + LittleEndian.INT_SIZE;
        
        if (! validLength(length, data, dataOffset)) {
            
            
            
            boolean valid = false;
            int past4byte = offset % 4;
            if (past4byte != 0) {
                offset = offset + past4byte;
                length = LittleEndian.getInt( data, offset );
                dataOffset = offset + LittleEndian.INT_SIZE;
                
                valid = validLength(length, data, dataOffset);
            }
            
            if (!valid) {
                throw new IllegalPropertySetDataException(
                        "UnicodeString started at offset #" + offset +
                        " is not NULL-terminated" );
            }
        }

        if ( length == 0 )
        {
            _value = new byte[0];
            return;
        }

        _value = LittleEndian.getByteArray( data, dataOffset, length * 2 );
    }
    
    
    boolean validLength(int length, byte[] data, int offset) {
        if (length == 0) {
            return true;
        }

        int endOffset = offset + (length * 2);
        if (endOffset <= data.length) {
            
            if (data[endOffset-1] == 0 && data[endOffset-2] == 0) {
                
                return true;
            }
        }

        
        return false;
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }

    byte[] getValue()
    {
        return _value;
    }

    String toJavaString()
    {
        if ( _value.length == 0 )
            return null;

        String result = StringUtil.getFromUnicodeLE( _value, 0,
                _value.length >> 1 );

        final int terminator = result.indexOf( '\0' );
        if ( terminator == -1 )
        {
            logger.warn(
                    "String terminator (\\0) for UnicodeString property value not found."
                            + "Continue without trimming and hope for the best." );
            return result;
        }
        if ( terminator != result.length() - 1 )
        {
            logger.warn(
                    "String terminator (\\0) for UnicodeString property value occured before the end of string. "
                            + "Trimming and hope for the best." );
        }
        return result.substring( 0, terminator );
    }
}

<code block>

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.LittleEndian;

class Filetime
{
    static final int SIZE = LittleEndian.INT_SIZE * 2;

    private int _dwHighDateTime;
    private int _dwLowDateTime;

    Filetime( byte[] data, int offset )
    {
        _dwLowDateTime = LittleEndian.getInt( data, offset + 0
                * LittleEndian.INT_SIZE );
        _dwHighDateTime = LittleEndian.getInt( data, offset + 1
                * LittleEndian.INT_SIZE );
    }

    Filetime( int low, int high )
    {
        _dwLowDateTime = low;
        _dwHighDateTime = high;
    }

    long getHigh()
    {
        return _dwHighDateTime;
    }

    long getLow()
    {
        return _dwLowDateTime;
    }

    byte[] toByteArray()
    {
        byte[] result = new byte[SIZE];
        LittleEndian.putInt( result, 0 * LittleEndian.INT_SIZE, _dwLowDateTime );
        LittleEndian
                .putInt( result, 1 * LittleEndian.INT_SIZE, _dwHighDateTime );
        return result;
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( _dwLowDateTime, out );
        LittleEndian.putInt( _dwHighDateTime, out );
        return SIZE;
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class GUID
{
    static final int SIZE = 16;

    private int _data1;
    private short _data2;
    private short _data3;
    private long _data4;

    GUID( byte[] data, int offset )
    {
        _data1 = LittleEndian.getInt( data, offset + 0 );
        _data2 = LittleEndian.getShort( data, offset + 4 );
        _data3 = LittleEndian.getShort( data, offset + 6 );
        _data4 = LittleEndian.getLong( data, offset + 8 );
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;

import org.apache.poi.util.CodePageUtil;


public class MutableProperty extends Property
{

    
    public MutableProperty()
    { }



    
    public MutableProperty(final Property p)
    {
        setID(p.getID());
        setType(p.getType());
        setValue(p.getValue());
    }


    
    public void setID(final long id)
    {
        this.id = id;
    }



    
    public void setType(final long type)
    {
        this.type = type;
    }



    
    public void setValue(final Object value)
    {
        this.value = value;
    }



    
    public int write(final OutputStream out, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        long variantType = getType();

        
        if (codepage == CodePageUtil.CP_UNICODE && variantType == Variant.VT_LPSTR)
            variantType = Variant.VT_LPWSTR;

        length += TypeWriter.writeUIntToStream(out, variantType);
        length += VariantSupport.write(out, variantType, getValue(), codepage);
        return length;
    }

}

<code block>


package org.apache.poi.hpsf;



public class HPSFRuntimeException extends RuntimeException
{
	private static final long serialVersionUID = -7804271670232727159L;
	
    private Throwable reason;



    
    public HPSFRuntimeException()
    {
        super();
    }



    
    public HPSFRuntimeException(final String msg)
    {
        super(msg);
    }



    
    public HPSFRuntimeException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFRuntimeException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }











































}

<code block>


package org.apache.poi.hpsf;

import java.util.Iterator;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.CodePageUtil;


public class DocumentSummaryInformation extends SpecialPropertySet
{
    
    public static final String DEFAULT_STREAM_NAME =
        "\005DocumentSummaryInformation";

    public PropertyIDMap getPropertySetIDMap() {
    	return PropertyIDMap.getDocumentSummaryInformationProperties();
    }


    
    public DocumentSummaryInformation(final PropertySet ps)
        throws UnexpectedPropertySetTypeException
    {
        super(ps);
        if (!isDocumentSummaryInformation())
            throw new UnexpectedPropertySetTypeException
                ("Not a " + getClass().getName());
    }

    
    
    public String getCategory()
    {
        return getPropertyStringValue(PropertyIDMap.PID_CATEGORY);
    }

    
    public void setCategory(final String category)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_CATEGORY, category);
    }

    
    public void removeCategory()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_CATEGORY);
    }



    
    public String getPresentationFormat()
    {
        return getPropertyStringValue(PropertyIDMap.PID_PRESFORMAT);
    }

    
    public void setPresentationFormat(final String presentationFormat)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PRESFORMAT, presentationFormat);
    }

    
    public void removePresentationFormat()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PRESFORMAT);
    }



    
    public int getByteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_BYTECOUNT);
    }

    
    public void setByteCount(final int byteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_BYTECOUNT, byteCount);
    }

    
    public void removeByteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_BYTECOUNT);
    }



    
    public int getLineCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_LINECOUNT);
    }

    
    public void setLineCount(final int lineCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINECOUNT, lineCount);
    }

    
    public void removeLineCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINECOUNT);
    }



    
    public int getParCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_PARCOUNT);
    }

    
    public void setParCount(final int parCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_PARCOUNT, parCount);
    }

    
    public void removeParCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_PARCOUNT);
    }



    
    public int getSlideCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_SLIDECOUNT);
    }

    
    public void setSlideCount(final int slideCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SLIDECOUNT, slideCount);
    }

    
    public void removeSlideCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SLIDECOUNT);
    }



    
    public int getNoteCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_NOTECOUNT);
    }

    
    public void setNoteCount(final int noteCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_NOTECOUNT, noteCount);
    }

    
    public void removeNoteCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_NOTECOUNT);
    }



    
    public int getHiddenCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_HIDDENCOUNT);
    }

    
    public void setHiddenCount(final int hiddenCount)
    {
        final MutableSection s = (MutableSection) getSections().get(0);
        s.setProperty(PropertyIDMap.PID_HIDDENCOUNT, hiddenCount);
    }

    
    public void removeHiddenCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HIDDENCOUNT);
    }



    
    public int getMMClipCount()
    {
        return getPropertyIntValue(PropertyIDMap.PID_MMCLIPCOUNT);
    }

    
    public void setMMClipCount(final int mmClipCount)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MMCLIPCOUNT, mmClipCount);
    }

    
    public void removeMMClipCount()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MMCLIPCOUNT);
    }



    
    public boolean getScale()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_SCALE);
    }

    
    public void setScale(final boolean scale)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_SCALE, scale);
    }

    
    public void removeScale()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_SCALE);
    }



    
    public byte[] getHeadingPair()
    {
        notYetImplemented("Reading byte arrays ");
        return (byte[]) getProperty(PropertyIDMap.PID_HEADINGPAIR);
    }

    
    public void setHeadingPair(final byte[] headingPair)
    {
        notYetImplemented("Writing byte arrays ");
    }

    
    public void removeHeadingPair()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_HEADINGPAIR);
    }



    
    public byte[] getDocparts()
    {
        notYetImplemented("Reading byte arrays");
        return (byte[]) getProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public void setDocparts(final byte[] docparts)
    {
        notYetImplemented("Writing byte arrays");
    }

    
    public void removeDocparts()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_DOCPARTS);
    }



    
    public String getManager()
    {
        return getPropertyStringValue(PropertyIDMap.PID_MANAGER);
    }

    
    public void setManager(final String manager)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_MANAGER, manager);
    }

    
    public void removeManager()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_MANAGER);
    }



    
    public String getCompany()
    {
        return getPropertyStringValue(PropertyIDMap.PID_COMPANY);
    }

    
    public void setCompany(final String company)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_COMPANY, company);
    }

    
    public void removeCompany()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_COMPANY);
    }


    
    public boolean getLinksDirty()
    {
        return getPropertyBooleanValue(PropertyIDMap.PID_LINKSDIRTY);
    }

    
    public void setLinksDirty(final boolean linksDirty)
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.setProperty(PropertyIDMap.PID_LINKSDIRTY, linksDirty);
    }

    
    public void removeLinksDirty()
    {
        final MutableSection s = (MutableSection) getFirstSection();
        s.removeProperty(PropertyIDMap.PID_LINKSDIRTY);
    }


    
    public CustomProperties getCustomProperties()
    {
        CustomProperties cps = null;
        if (getSectionCount() >= 2)
        {
            cps = new CustomProperties();
            final Section section = getSections().get(1);
            final Map<Long,String> dictionary = section.getDictionary();
            final Property[] properties = section.getProperties();
            int propertyCount = 0;
            for (int i = 0; i < properties.length; i++)
            {
                final Property p = properties[i];
                final long id = p.getID();
                if (id != 0 && id != 1)
                {
                    propertyCount++;
                    final CustomProperty cp = new CustomProperty(p,
                            dictionary.get(Long.valueOf(id)));
                    cps.put(cp.getName(), cp);
                }
            }
            if (cps.size() != propertyCount)
                cps.setPure(false);
        }
        return cps;
    }

    
    public void setCustomProperties(final CustomProperties customProperties)
    {
        ensureSection2();
        final MutableSection section = (MutableSection) getSections().get(1);
        final Map<Long,String> dictionary = customProperties.getDictionary();
        section.clear();

        
        int cpCodepage = customProperties.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = section.getCodepage();
        if (cpCodepage < 0)
            cpCodepage = CodePageUtil.CP_UNICODE;
        customProperties.setCodepage(cpCodepage);
        section.setCodepage(cpCodepage);
        section.setDictionary(dictionary);
        for (final Iterator<CustomProperty> i = customProperties.values().iterator(); i.hasNext();)
        {
            final Property p = i.next();
            section.setProperty(p);
        }
    }

    
    private void ensureSection2()
    {
        if (getSectionCount() < 2)
        {
            MutableSection s2 = new MutableSection();
            s2.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[1]);
            addSection(s2);
        }
    }

    
    public void removeCustomProperties()
    {
        if (getSectionCount() >= 2)
            getSections().remove(1);
        else
            throw new HPSFRuntimeException("Illegal internal format of Document SummaryInformation stream: second section is missing.");
    }


    
    private void notYetImplemented(final String msg)
    {
        throw new UnsupportedOperationException(msg + " is not yet implemented.");
    }
}

<code block>


package org.apache.poi.hpsf;


public class HPSFException extends Exception
{

    
    private Throwable reason;



    
    public HPSFException()
    {
        super();
    }



    
    public HPSFException(final String msg)
    {
        super(msg);
    }



    
    public HPSFException(final Throwable reason)
    {
        super();
        this.reason = reason;
    }



    
    public HPSFException(final String msg, final Throwable reason)
    {
        super(msg);
        this.reason = reason;
    }



    
    public Throwable getReason()
    {
        return reason;
    }

}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;

@Internal
class VersionedStream
{
    private GUID _versionGuid;
    private IndirectPropertyName _streamName;

    VersionedStream( byte[] data, int offset )
    {
        _versionGuid = new GUID( data, offset );
        _streamName = new IndirectPropertyName( data, offset + GUID.SIZE );
    }

    int getSize()
    {
        return GUID.SIZE + _streamName.getSize();
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;

@Internal
class Decimal
{
    static final int SIZE = 16;

    private short field_1_wReserved;
    private byte field_2_scale;
    private byte field_3_sign;
    private int field_4_hi32;
    private long field_5_lo64;

    Decimal( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        field_1_wReserved = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;

        field_2_scale = data[offset];
        offset += LittleEndian.BYTE_SIZE;

        field_3_sign = data[offset];
        offset += LittleEndian.BYTE_SIZE;

        field_4_hi32 = LittleEndian.getInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        field_5_lo64 = LittleEndian.getLong( data, offset );
        offset += LittleEndian.LONG_SIZE;
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;
import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.util.LittleEndian;


public class Section
{

    
    protected Map<Long,String> dictionary;

    
    protected ClassID formatID;


    
    public ClassID getFormatID()
    {
        return formatID;
    }



    
    protected long offset;


    
    public long getOffset()
    {
        return offset;
    }



    
    protected int size;


    
    public int getSize()
    {
        return size;
    }



    
    public int getPropertyCount()
    {
        return properties.length;
    }



    
    protected Property[] properties;


    
    public Property[] getProperties()
    {
        return properties;
    }



    
    protected Section()
    { }



    
    public Section(final byte[] src, final int offset)
    throws UnsupportedEncodingException
    {
        int o1 = offset;

        
        formatID = new ClassID(src, o1);
        o1 += ClassID.LENGTH;

        
        this.offset = LittleEndian.getUInt(src, o1);
        o1 = (int) this.offset;

        
        size = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        final int propertyCount = (int) LittleEndian.getUInt(src, o1);
        o1 += LittleEndian.INT_SIZE;

        
        properties = new Property[propertyCount];

        
        int pass1Offset = o1;
        final List<PropertyListEntry> propertyList = new ArrayList<PropertyListEntry>(propertyCount);
        PropertyListEntry ple;
        for (int i = 0; i < properties.length; i++)
        {
            ple = new PropertyListEntry();

            
            ple.id = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            ple.offset = (int) LittleEndian.getUInt(src, pass1Offset);
            pass1Offset += LittleEndian.INT_SIZE;

            
            propertyList.add(ple);
        }

        
        Collections.sort(propertyList);

        
        for (int i = 0; i < propertyCount - 1; i++)
        {
            PropertyListEntry ple1 = propertyList.get(i);
            PropertyListEntry ple2 = propertyList.get(i + 1);
            ple1.length = ple2.offset - ple1.offset;
        }
        if (propertyCount > 0)
        {
            ple = propertyList.get(propertyCount - 1);
            ple.length = size - ple.offset;
        }

        
        int codepage = -1;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator();
             codepage == -1 && i.hasNext();)
        {
            ple = i.next();

            
            if (ple.id == PropertyIDMap.PID_CODEPAGE)
            {
                
                int o = (int) (this.offset + ple.offset);
                final long type = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                if (type != Variant.VT_I2)
                    throw new HPSFRuntimeException
                        ("Value type of property ID 1 is not VT_I2 but " +
                         type + ".");

                
                codepage = LittleEndian.getUShort(src, o);
            }
        }

        
        int i1 = 0;
        for (final Iterator<PropertyListEntry> i = propertyList.iterator(); i.hasNext();)
        {
            ple = i.next();
            Property p = new Property(ple.id, src,
                    this.offset + ple.offset,
                    ple.length, codepage);
            if (p.getID() == PropertyIDMap.PID_CODEPAGE)
                p = new Property(p.getID(), p.getType(), Integer.valueOf(codepage));
            properties[i1++] = p;
        }

        
        dictionary = (Map) getProperty(0);
    }



    
    static class PropertyListEntry implements Comparable<PropertyListEntry>
    {
        int id;
        int offset;
        int length;

        
        public int compareTo(final PropertyListEntry o)
        {
            final int otherOffset = o.offset;
            if (offset < otherOffset)
                return -1;
            else if (offset == otherOffset)
                return 0;
            else
                return 1;
        }

        public String toString()
        {
            final StringBuffer b = new StringBuffer();
            b.append(getClass().getName());
            b.append("[id=");
            b.append(id);
            b.append(", offset=");
            b.append(offset);
            b.append(", length=");
            b.append(length);
            b.append(']');
            return b.toString();
        }
    }



    
    public Object getProperty(final long id)
    {
        wasNull = false;
        for (int i = 0; i < properties.length; i++)
            if (id == properties[i].getID())
                return properties[i].getValue();
        wasNull = true;
        return null;
    }



    
    protected int getPropertyIntValue(final long id)
    {
        final Number i;
        final Object o = getProperty(id);
        if (o == null)
            return 0;
        if (!(o instanceof Long || o instanceof Integer))
            throw new HPSFRuntimeException
                ("This property is not an integer type, but " +
                 o.getClass().getName() + ".");
        i = (Number) o;
        return i.intValue();
    }



    
    protected boolean getPropertyBooleanValue(final int id)
    {
        final Boolean b = (Boolean) getProperty(id);
        if (b == null) {
            return false;
        }
        return b.booleanValue();
        }



    
    private boolean wasNull;


    
    public boolean wasNull()
    {
        return wasNull;
    }



    
    public String getPIDString(final long pid)
    {
        String s = null;
        if (dictionary != null)
            s = dictionary.get(Long.valueOf(pid));
        if (s == null)
            s = SectionIDMap.getPIDString(getFormatID().getBytes(), pid);
        if (s == null)
            s = SectionIDMap.UNDEFINED;
        return s;
    }



    
    public boolean equals(final Object o)
    {
        if (o == null || !(o instanceof Section))
            return false;
        final Section s = (Section) o;
        if (!s.getFormatID().equals(getFormatID()))
            return false;

        
        Property[] pa1 = new Property[getProperties().length];
        Property[] pa2 = new Property[s.getProperties().length];
        System.arraycopy(getProperties(), 0, pa1, 0, pa1.length);
        System.arraycopy(s.getProperties(), 0, pa2, 0, pa2.length);

        
        Property p10 = null;
        Property p20 = null;
        for (int i = 0; i < pa1.length; i++)
        {
            final long id = pa1[i].getID();
            if (id == 0)
            {
                p10 = pa1[i];
                pa1 = remove(pa1, i);
                i--;
            }
            if (id == 1)
            {
                
                pa1 = remove(pa1, i);
                i--;
            }
        }
        for (int i = 0; i < pa2.length; i++)
        {
            final long id = pa2[i].getID();
            if (id == 0)
            {
                p20 = pa2[i];
                pa2 = remove(pa2, i);
                i--;
            }
            if (id == 1)
            {
                
                pa2 = remove(pa2, i);
                i--;
            }
        }

        
        if (pa1.length != pa2.length)
            return false;

        
        boolean dictionaryEqual = true;
        if (p10 != null && p20 != null)
            dictionaryEqual = p10.getValue().equals(p20.getValue());
        else if (p10 != null || p20 != null)
            dictionaryEqual = false;
        if (dictionaryEqual) {
            return Util.equals(pa1, pa2);
        }
        return false;
    }



    
    private Property[] remove(final Property[] pa, final int i)
    {
        final Property[] h = new Property[pa.length - 1];
        if (i > 0)
            System.arraycopy(pa, 0, h, 0, i);
        System.arraycopy(pa, i + 1, h, i, h.length - i);
        return h;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += getFormatID().hashCode();
        final Property[] pa = getProperties();
        for (int i = 0; i < pa.length; i++)
            hashCode += pa[i].hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL);
        return returnHashCode;
    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        final Property[] pa = getProperties();
        b.append(getClass().getName());
        b.append('[');
        b.append("formatID: ");
        b.append(getFormatID());
        b.append(", offset: ");
        b.append(getOffset());
        b.append(", propertyCount: ");
        b.append(getPropertyCount());
        b.append(", size: ");
        b.append(getSize());
        b.append(", properties: [\n");
        for (int i = 0; i < pa.length; i++)
        {
            b.append(pa[i].toString());
            b.append(",\n");
        }
        b.append(']');
        b.append(']');
        return b.toString();
    }



    
    public Map<Long,String> getDictionary()
    {
        return dictionary;
    }



    
    public int getCodepage()
    {
        final Integer codepage =
            (Integer) getProperty(PropertyIDMap.PID_CODEPAGE);
        if (codepage == null)
            return -1;
        int cp = codepage.intValue();
        return cp;
    }

}

<code block>


package org.apache.poi.hpsf;


public class UnexpectedPropertySetTypeException extends HPSFException
{

    
    public UnexpectedPropertySetTypeException()
    {
        super();
    }


    
    public UnexpectedPropertySetTypeException(final String msg)
    {
        super(msg);
    }


    
    public UnexpectedPropertySetTypeException(final Throwable reason)
    {
        super(reason);
    }


    
    public UnexpectedPropertySetTypeException(final String msg,
                                              final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>

package org.apache.poi.hpsf;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class CodePageString
{


	private static Logger logger = LoggerFactory.getLogger(CodePageString.class);

    private byte[] _value;

    CodePageString( final byte[] data, final int startOffset )
    {
        int offset = startOffset;

        int size = LittleEndian.getInt( data, offset );
        offset += LittleEndian.INT_SIZE;

        _value = LittleEndian.getByteArray( data, offset, size );
        if ( size != 0 && _value[size - 1] != 0 ) {
            
            
            
            logger.warn("CodePageString started at offset #" + offset
                        + " is not NULL-terminated" );



        }
    }

    CodePageString( String string, int codepage )
            throws UnsupportedEncodingException
    {
        setJavaValue( string, codepage );
    }

    String getJavaValue( int codepage ) throws UnsupportedEncodingException
    {
        String result;
        if ( codepage == -1 )
            result = new String( _value );
        else
            result = CodePageUtil.getStringFromCodePage(_value, codepage);
        final int terminator = result.indexOf( '\0' );
        if ( terminator == -1 )
        {
            logger.warn(
                    "String terminator (\\0) for CodePageString property value not found."
                            + "Continue without trimming and hope for the best." );
            return result;
        }
        if ( terminator != result.length() - 1 )
        {
            logger.warn(
                    "String terminator (\\0) for CodePageString property value occured before the end of string. "
                            + "Trimming and hope for the best." );
        }
        return result.substring( 0, terminator );
    }

    int getSize()
    {
        return LittleEndian.INT_SIZE + _value.length;
    }

    void setJavaValue( String string, int codepage )
            throws UnsupportedEncodingException
    {
        String stringNT = string + "\0";
        if ( codepage == -1 )
            _value = stringNT.getBytes();
        else
            _value = CodePageUtil.getBytesInCodePage(stringNT, codepage);
    }

    int write( OutputStream out ) throws IOException
    {
        LittleEndian.putInt( _value.length, out );
        out.write( _value );
        return LittleEndian.INT_SIZE + _value.length;
    }
}

<code block>


package org.apache.poi.hpsf;


public class NoFormatIDException extends HPSFRuntimeException
{

    
    public NoFormatIDException()
    {
        super();
    }


    
    public NoFormatIDException(final String msg)
    {
        super(msg);
    }


    
    public NoFormatIDException(final Throwable reason)
    {
        super(reason);
    }


    
    public NoFormatIDException(final String msg, final Throwable reason)
    {
        super(msg, reason);
    }

}

<code block>


package org.apache.poi.hpsf;


public class CustomProperty extends MutableProperty
{

    private String name;

    
    public CustomProperty()
    {
        this.name = null;
    }

    
    public CustomProperty(final Property property)
    {
        this(property, null);
    }

    
    public CustomProperty(final Property property, final String name)
    {
        super(property);
        this.name = name;
    }

    
    public String getName()
    {
        return name;
    }

    
    public void setName(final String name)
    {
        this.name = name;
    }


    
    public boolean equalsContents(final Object o)
    {
        final CustomProperty c = (CustomProperty) o;
        final String name1 = c.getName();
        final String name2 = this.getName();
        boolean equalNames = true;
        if (name1 == null)
            equalNames = name2 == null;
        else
            equalNames = name1.equals(name2);
        return equalNames && c.getID() == this.getID()
                && c.getType() == this.getType()
                && c.getValue().equals(this.getValue());
    }

    
    @Override
    public int hashCode()
    {
        return (int) this.getID();
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof CustomProperty) ? equalsContents(o) : false;
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;
import org.apache.poi.util.LittleEndian;


import org.docx4j.TraversalUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Internal
class TypedPropertyValue
{



	private static Logger logger = LoggerFactory.getLogger(TraversalUtil.class);

	
    private int _type;

    private Object _value;

    TypedPropertyValue()
    {
    }

    TypedPropertyValue( byte[] data, int startOffset )
    {
        read( data, startOffset );
    }

    TypedPropertyValue( int type, Object value )
    {
        _type = type;
        _value = value;
    }

    Object getValue()
    {
        return _value;
    }

    int read( byte[] data, int startOffset )
    {
        int offset = startOffset;

        _type = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;

        short padding = LittleEndian.getShort( data, offset );
        offset += LittleEndian.SHORT_SIZE;
        if ( padding != 0 )
        {
            logger.warn(  "TypedPropertyValue padding at offset "
                    + offset + " MUST be 0, but it's value is " + padding );
        }

        offset += readValue( data, offset );

        return offset - startOffset;
    }

    int readValue( byte[] data, int offset )
    {
        switch ( _type )
        {
        case Variant.VT_EMPTY:
        case Variant.VT_NULL:
            _value = null;
            return 0;

        case Variant.VT_I2:
            _value = Short.valueOf( LittleEndian.getShort( data, offset ) );
            return 4;

        case Variant.VT_I4:
            _value = Integer.valueOf( LittleEndian.getInt( data, offset ) );
            return 4;

        case Variant.VT_R4:
            _value = Short.valueOf( LittleEndian.getShort( data, offset ) );
            return 4;

        case Variant.VT_R8:
            _value = Double.valueOf( LittleEndian.getDouble( data, offset ) );
            return 8;

        case Variant.VT_CY:
            _value = new Currency( data, offset );
            return Currency.SIZE;

        case Variant.VT_DATE:
            _value = new Date( data, offset );
            return Date.SIZE;

        case Variant.VT_BSTR:
            _value = new CodePageString( data, offset );
            return ( (CodePageString) _value ).getSize();

        case Variant.VT_ERROR:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_BOOL:
            _value = new VariantBool( data, offset );
            return VariantBool.SIZE;

        case Variant.VT_DECIMAL:
            _value = new Decimal( data, offset );
            return Decimal.SIZE;

        case Variant.VT_I1:
            _value = Byte.valueOf( data[offset] );
            return 1;

        case Variant.VT_UI1:
            _value = Short.valueOf( LittleEndian.getUByte( data, offset ) );
            return 2;

        case Variant.VT_UI2:
            _value = Integer.valueOf( LittleEndian.getUShort( data, offset ) );
            return 4;

        case Variant.VT_UI4:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_I8:
            _value = Long.valueOf( LittleEndian.getLong( data, offset ) );
            return 8;

        case Variant.VT_UI8:
            _value = LittleEndian.getByteArray( data, offset, 8 );
            return 8;

        case Variant.VT_INT:
            _value = Integer.valueOf( LittleEndian.getInt( data, offset ) );
            return 4;

        case Variant.VT_UINT:
            _value = Long.valueOf( LittleEndian.getUInt( data, offset ) );
            return 4;

        case Variant.VT_LPSTR:
            _value = new CodePageString( data, offset );
            return ( (CodePageString) _value ).getSize();

        case Variant.VT_LPWSTR:
            _value = new UnicodeString( data, offset );
            return ( (UnicodeString) _value ).getSize();

        case Variant.VT_FILETIME:
            _value = new Filetime( data, offset );
            return Filetime.SIZE;

        case Variant.VT_BLOB:
            _value = new Blob( data, offset );
            return ( (Blob) _value ).getSize();

        case Variant.VT_STREAM:
        case Variant.VT_STORAGE:
        case Variant.VT_STREAMED_OBJECT:
        case Variant.VT_STORED_OBJECT:
            _value = new IndirectPropertyName( data, offset );
            return ( (IndirectPropertyName) _value ).getSize();

        case Variant.VT_BLOB_OBJECT:
            _value = new Blob( data, offset );
            return ( (Blob) _value ).getSize();

        case Variant.VT_CF:
            _value = new ClipboardData( data, offset );
            return ( (ClipboardData) _value ).getSize();

        case Variant.VT_CLSID:
            _value = new GUID( data, offset );
            return GUID.SIZE;

        case Variant.VT_VERSIONED_STREAM:
            _value = new VersionedStream( data, offset );
            return ( (VersionedStream) _value ).getSize();

        case Variant.VT_VECTOR | Variant.VT_I2:
        case Variant.VT_VECTOR | Variant.VT_I4:
        case Variant.VT_VECTOR | Variant.VT_R4:
        case Variant.VT_VECTOR | Variant.VT_R8:
        case Variant.VT_VECTOR | Variant.VT_CY:
        case Variant.VT_VECTOR | Variant.VT_DATE:
        case Variant.VT_VECTOR | Variant.VT_BSTR:
        case Variant.VT_VECTOR | Variant.VT_ERROR:
        case Variant.VT_VECTOR | Variant.VT_BOOL:
        case Variant.VT_VECTOR | Variant.VT_VARIANT:
        case Variant.VT_VECTOR | Variant.VT_I1:
        case Variant.VT_VECTOR | Variant.VT_UI1:
        case Variant.VT_VECTOR | Variant.VT_UI2:
        case Variant.VT_VECTOR | Variant.VT_UI4:
        case Variant.VT_VECTOR | Variant.VT_I8:
        case Variant.VT_VECTOR | Variant.VT_UI8:
        case Variant.VT_VECTOR | Variant.VT_LPSTR:
        case Variant.VT_VECTOR | Variant.VT_LPWSTR:
        case Variant.VT_VECTOR | Variant.VT_FILETIME:
        case Variant.VT_VECTOR | Variant.VT_CF:
        case Variant.VT_VECTOR | Variant.VT_CLSID:
            _value = new Vector( (short) ( _type & 0x0FFF ) );
            return ( (Vector) _value ).read( data, offset );

        case Variant.VT_ARRAY | Variant.VT_I2:
        case Variant.VT_ARRAY | Variant.VT_I4:
        case Variant.VT_ARRAY | Variant.VT_R4:
        case Variant.VT_ARRAY | Variant.VT_R8:
        case Variant.VT_ARRAY | Variant.VT_CY:
        case Variant.VT_ARRAY | Variant.VT_DATE:
        case Variant.VT_ARRAY | Variant.VT_BSTR:
        case Variant.VT_ARRAY | Variant.VT_ERROR:
        case Variant.VT_ARRAY | Variant.VT_BOOL:
        case Variant.VT_ARRAY | Variant.VT_VARIANT:
        case Variant.VT_ARRAY | Variant.VT_DECIMAL:
        case Variant.VT_ARRAY | Variant.VT_I1:
        case Variant.VT_ARRAY | Variant.VT_UI1:
        case Variant.VT_ARRAY | Variant.VT_UI2:
        case Variant.VT_ARRAY | Variant.VT_UI4:
        case Variant.VT_ARRAY | Variant.VT_INT:
        case Variant.VT_ARRAY | Variant.VT_UINT:
            _value = new Array();
            return ( (Array) _value ).read( data, offset );

        default:
            throw new UnsupportedOperationException(
                    "Unknown (possibly, incorrect) TypedPropertyValue type: "
                            + _type );
        }
    }

    int readValuePadded( byte[] data, int offset )
    {
        int nonPadded = readValue( data, offset );
        return ( nonPadded & 0x03 ) == 0 ? nonPadded : nonPadded
                + ( 4 - ( nonPadded & 0x03 ) );
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.UnsupportedEncodingException;
import java.util.LinkedHashMap;
import java.util.Map;

import org.apache.poi.util.CodePageUtil;
import org.apache.poi.util.HexDump;
import org.apache.poi.util.LittleEndian;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Property
{
	
	private static Logger logger = LoggerFactory.getLogger(Property.class);
	

    
    protected long id;


    
    public long getID()
    {
        return id;
    }



    
    protected long type;


    
    public long getType()
    {
        return type;
    }



    
    protected Object value;


    
    public Object getValue()
    {
        return value;
    }



    
    public Property(final long id, final long type, final Object value)
    {
        this.id = id;
        this.type = type;
        this.value = value;
    }



    
    public Property(final long id, final byte[] src, final long offset,
                    final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        this.id = id;

        
        if (id == 0)
        {
            value = readDictionary(src, offset, length, codepage);
            return;
        }

        int o = (int) offset;
        type = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        try
        {
            value = VariantSupport.read(src, o, length, (int) type, codepage);
        }
        catch (UnsupportedVariantTypeException ex)
        {
            VariantSupport.writeUnsupportedTypeMessage(ex);
            value = ex.getValue();
        }
    }



    
    protected Property()
    { }



    
    protected Map<?, ?> readDictionary(final byte[] src, final long offset,
                                 final int length, final int codepage)
    throws UnsupportedEncodingException
    {
        
        if (offset < 0 || offset > src.length)
            throw new HPSFRuntimeException
                ("Illegal offset " + offset + " while HPSF stream contains " +
                 length + " bytes.");
        int o = (int) offset;

        
        final long nrEntries = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        final Map<Object, Object> m = new LinkedHashMap<Object, Object>(
                (int) nrEntries, (float) 1.0 );

        try
        {
            for (int i = 0; i < nrEntries; i++)
            {
                
                final Long id = Long.valueOf(LittleEndian.getUInt(src, o));
                o += LittleEndian.INT_SIZE;

                
                long sLength = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;

                
                final StringBuffer b = new StringBuffer();
                switch (codepage)
                {
                    case -1:
                    {
                        
                        b.append(new String(src, o, (int) sLength));
                        break;
                    }
                    case CodePageUtil.CP_UNICODE:
                    {
                        
                        final int nrBytes = (int) (sLength * 2);
                        final byte[] h = new byte[nrBytes];
                        for (int i2 = 0; i2 < nrBytes; i2 += 2)
                        {
                            h[i2] = src[o + i2 + 1];
                            h[i2 + 1] = src[o + i2];
                        }
                        b.append(new String(h, 0, nrBytes,
                                CodePageUtil.codepageToEncoding(codepage)));
                        break;
                    }
                    default:
                    {
                        
                        b.append(new String(src, o, (int) sLength,
                                 VariantSupport.codepageToEncoding(codepage)));
                        break;
                    }
                }

                
                while (b.length() > 0 && b.charAt(b.length() - 1) == 0x00)
                    b.setLength(b.length() - 1);
                if (codepage == CodePageUtil.CP_UNICODE)
                {
                    if (sLength % 2 == 1)
                        sLength++;
                    o += (sLength + sLength);
                }
                else
                    o += sLength;
                m.put(id, b.toString());
            }
        }
        catch (RuntimeException ex)
        {
            logger.warn(
                    "The property set's dictionary contains bogus data. "
                    + "All dictionary entries starting with the one with ID "
                    + id + " will be ignored.", ex);
        }
        return m;
    }



    
    protected int getSize() throws WritingNotSupportedException
    {
        int length = VariantSupport.getVariantLength(type);
        if (length >= 0)
            return length; 
        if (length == -2)
            
            throw new WritingNotSupportedException(type, null);

        
        final int PADDING = 4; 
        switch ((int) type)
        {
            case Variant.VT_LPSTR:
            {
                int l = ((String) value).length() + 1;
                int r = l % PADDING;
                if (r > 0)
                    l += PADDING - r;
                length += l;
                break;
            }
            case Variant.VT_EMPTY:
                break;
            default:
                throw new WritingNotSupportedException(type, value);
        }
        return length;
    }



    
    public boolean equals(final Object o)
    {
        if (!(o instanceof Property)) {
            return false;
        }
        final Property p = (Property) o;
        final Object pValue = p.getValue();
        final long pId = p.getID();
        if (id != pId || (id != 0 && !typesAreEqual(type, p.getType())))
            return false;
        if (value == null && pValue == null)
            return true;
        if (value == null || pValue == null)
            return false;

        
        final Class<?> valueClass = value.getClass();
        final Class<?> pValueClass = pValue.getClass();
        if (!(valueClass.isAssignableFrom(pValueClass)) &&
            !(pValueClass.isAssignableFrom(valueClass)))
            return false;

        if (value instanceof byte[])
            return Util.equal((byte[]) value, (byte[]) pValue);

        return value.equals(pValue);
    }



    private boolean typesAreEqual(final long t1, final long t2)
    {
        if (t1 == t2 ||
            (t1 == Variant.VT_LPSTR && t2 == Variant.VT_LPWSTR) ||
            (t2 == Variant.VT_LPSTR && t1 == Variant.VT_LPWSTR)) {
            return true;
        }
        return false;
    }



    
    public int hashCode()
    {
        long hashCode = 0;
        hashCode += id;
        hashCode += type;
        if (value != null)
            hashCode += value.hashCode();
        final int returnHashCode = (int) (hashCode & 0x0ffffffffL );
        return returnHashCode;

    }



    
    public String toString()
    {
        final StringBuffer b = new StringBuffer();
        b.append(getClass().getName());
        b.append('[');
        b.append("id: ");
        b.append(getID());
        b.append(", type: ");
        b.append(getType());
        final Object value = getValue();
        b.append(", value: ");
        if (value instanceof String)
        {
            b.append(value.toString());
            final String s = (String) value;
            final int l = s.length();
            final byte[] bytes = new byte[l * 2];
            for (int i = 0; i < l; i++)
            {
                final char c = s.charAt(i);
                final byte high = (byte) ((c & 0x00ff00) >> 8);
                final byte low  = (byte) ((c & 0x0000ff) >> 0);
                bytes[i * 2]     = high;
                bytes[i * 2 + 1] = low;
            }
            b.append(" [");
            if(bytes.length > 0) {
                final String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
            b.append("]");
        }
        else if (value instanceof byte[])
        {
            byte[] bytes = (byte[])value;
            if(bytes.length > 0) {
                String hex = HexDump.dump(bytes, 0L, 0);
                b.append(hex);
            }
        }
        else
        {
            b.append(value.toString());
        }
        b.append(']');
        return b.toString();
    }

}

<code block>


package org.apache.poi.hpsf;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.apache.poi.hpsf.wellknown.PropertyIDMap;


@SuppressWarnings("serial")
public class CustomProperties extends HashMap<Object,CustomProperty>
{

    
    private Map<Long,String> dictionaryIDToName = new HashMap<Long,String>();

    
    private Map<String,Long> dictionaryNameToID = new HashMap<String,Long>();

    
    private boolean isPure = true;


    
    public CustomProperty put(final String name, final CustomProperty cp)
    {
        if (name == null)
        {
            
            isPure = false;
            return null;
        }
        if (!(name.equals(cp.getName())))
            throw new IllegalArgumentException("Parameter \"name\" (" + name +
                    ") and custom property's name (" + cp.getName() +
                    ") do not match.");

        
        final Long idKey = Long.valueOf(cp.getID());
        final Long oldID = dictionaryNameToID.get(name);
        dictionaryIDToName.remove(oldID);
        dictionaryNameToID.put(name, idKey);
        dictionaryIDToName.put(idKey, name);

        
        final CustomProperty oldCp = super.remove(oldID);
        super.put(idKey, cp);
        return oldCp;
    }



    
    private Object put(final CustomProperty customProperty) throws ClassCastException
    {
        final String name = customProperty.getName();

        
        final Long oldId = dictionaryNameToID.get(name);
        if (oldId != null)
            customProperty.setID(oldId.longValue());
        else
        {
            long max = 1;
            for (final Iterator<Long> i = dictionaryIDToName.keySet().iterator(); i.hasNext();)
            {
                final long id = i.next().longValue();
                if (id > max)
                    max = id;
            }
            customProperty.setID(max + 1);
        }
        return this.put(name, customProperty);
    }



    
    public Object remove(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        if (id == null)
            return null;
        dictionaryIDToName.remove(id);
        dictionaryNameToID.remove(name);
        return super.remove(id);
    }

    
    public Object put(final String name, final String value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_LPWSTR);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Long value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Double value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_R8);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Integer value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_I4);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Object put(final String name, final Boolean value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_BOOL);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }


    
    public Object get(final String name)
    {
        final Long id = dictionaryNameToID.get(name);
        final CustomProperty cp = super.get(id);
        return cp != null ? cp.getValue() : null;
    }



    
    public Object put(final String name, final Date value)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(-1);
        p.setType(Variant.VT_FILETIME);
        p.setValue(value);
        final CustomProperty cp = new CustomProperty(p, name);
        return put(cp);
    }

    
    public Set keySet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> nameSet() {
        return dictionaryNameToID.keySet();
    }

    
    public Set<String> idSet() {
        return dictionaryNameToID.keySet();
    }


    
    public void setCodepage(final int codepage)
    {
        final MutableProperty p = new MutableProperty();
        p.setID(PropertyIDMap.PID_CODEPAGE);
        p.setType(Variant.VT_I2);
        p.setValue(Integer.valueOf(codepage));
        put(new CustomProperty(p));
    }



    
    Map<Long,String> getDictionary()
    {
        return dictionaryIDToName;
    }


    
   public boolean containsKey(Object key) {
      if(key instanceof Long) {
         return super.containsKey(key);
      }
      if(key instanceof String) {
         return super.containsKey(dictionaryNameToID.get(key));
      }
      return false;
   }

   
   public boolean containsValue(Object value) {
      if(value instanceof CustomProperty) {
         return super.containsValue(value);
      } else {
         for(CustomProperty cp : super.values()) {
            if(cp.getValue() == value) {
               return true;
            }
         }
      }
      return false;
   }



   
    public int getCodepage()
    {
        int codepage = -1;
        for (final Iterator<CustomProperty> i = this.values().iterator(); codepage == -1 && i.hasNext();)
        {
            final CustomProperty cp = i.next();
            if (cp.getID() == PropertyIDMap.PID_CODEPAGE)
                codepage = ((Integer) cp.getValue()).intValue();
        }
        return codepage;
    }



    
    public boolean isPure()
    {
        return isPure;
    }

    
    public void setPure(final boolean isPure)
    {
        this.isPure = isPure;
    }
}

<code block>

package org.apache.poi.hpsf;

import org.apache.poi.util.Internal;

@Internal
class IndirectPropertyName
{
    private CodePageString _value;

    IndirectPropertyName( byte[] data, int offset )
    {
        _value = new CodePageString( data, offset );
    }

    int getSize()
    {
        return _value.getSize();
    }
}

<code block>


package org.apache.poi.hpsf;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;

import org.apache.poi.hpsf.wellknown.SectionIDMap;
import org.apache.poi.poifs.filesystem.DirectoryEntry;
import org.apache.poi.poifs.filesystem.DocumentEntry;
import org.apache.poi.poifs.filesystem.DocumentInputStream;


public class PropertySetFactory
{
    
    public static PropertySet create(final DirectoryEntry dir, final String name)
        throws FileNotFoundException, NoPropertySetStreamException,
               IOException, UnsupportedEncodingException
    {
        InputStream inp = null;
        try {
            DocumentEntry entry = (DocumentEntry)dir.getEntry(name);
            inp = new DocumentInputStream(entry);
            try {
                return create(inp);
            } catch (MarkUnsupportedException e) { return null; }
        } finally {
            if (inp != null) inp.close();
        }
    }

    
    public static PropertySet create(final InputStream stream)
        throws NoPropertySetStreamException, MarkUnsupportedException,
               UnsupportedEncodingException, IOException
    {
        final PropertySet ps = new PropertySet(stream);
        try
        {
            if (ps.isSummaryInformation())
                return new SummaryInformation(ps);
            else if (ps.isDocumentSummaryInformation())
                return new DocumentSummaryInformation(ps);
            else
                return ps;
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new IllegalStateException(ex);
        }
    }

    
    public static SummaryInformation newSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.SUMMARY_INFORMATION_ID);
        try
        {
            return new SummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }

    
    public static DocumentSummaryInformation newDocumentSummaryInformation()
    {
        final MutablePropertySet ps = new MutablePropertySet();
        final MutableSection s = (MutableSection) ps.getFirstSection();
        s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);
        try
        {
            return new DocumentSummaryInformation(ps);
        }
        catch (UnexpectedPropertySetTypeException ex)
        {
            
            throw new HPSFRuntimeException(ex);
        }
    }
}
<code block>


package org.apache.poi.hpsf.wellknown;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


public class PropertyIDMap extends HashMap<Long,String> {

    

    
    public static final int PID_TITLE = 2;

    
    public static final int PID_SUBJECT = 3;

    
    public static final int PID_AUTHOR = 4;

    
    public static final int PID_KEYWORDS = 5;

    
    public static final int PID_COMMENTS = 6;

    
    public static final int PID_TEMPLATE = 7;

    
    public static final int PID_LASTAUTHOR = 8;

    
    public static final int PID_REVNUMBER = 9;

    
    public static final int PID_EDITTIME = 10;

    
    public static final int PID_LASTPRINTED = 11;

    
    public static final int PID_CREATE_DTM = 12;

    
    public static final int PID_LASTSAVE_DTM = 13;

    
    public static final int PID_PAGECOUNT = 14;

    
    public static final int PID_WORDCOUNT = 15;

    
    public static final int PID_CHARCOUNT = 16;

    
    public static final int PID_THUMBNAIL = 17;

    
    public static final int PID_APPNAME = 18;

    
    public static final int PID_SECURITY = 19;



    

    
    public static final int PID_DICTIONARY = 0;

    
    public static final int PID_CODEPAGE = 1;

    
    public static final int PID_CATEGORY = 2;

    
    public static final int PID_PRESFORMAT = 3;

    
    public static final int PID_BYTECOUNT = 4;

    
    public static final int PID_LINECOUNT = 5;

    
    public static final int PID_PARCOUNT = 6;

    
    public static final int PID_SLIDECOUNT = 7;

    
    public static final int PID_NOTECOUNT = 8;

    
    public static final int PID_HIDDENCOUNT = 9;

    
    public static final int PID_MMCLIPCOUNT = 10;

    
    public static final int PID_SCALE = 11;

    
    public static final int PID_HEADINGPAIR = 12;

    
    public static final int PID_DOCPARTS = 13;

    
    public static final int PID_MANAGER = 14;

    
    public static final int PID_COMPANY = 15;

    
    public static final int PID_LINKSDIRTY = 16;

    
    public static final int PID_MAX = PID_LINKSDIRTY;



    
    private static PropertyIDMap summaryInformationProperties;

    
    private static PropertyIDMap documentSummaryInformationProperties;



    
    public PropertyIDMap(final int initialCapacity, final float loadFactor)
    {
        super(initialCapacity, loadFactor);
    }



    
    public PropertyIDMap(final Map<Long,String> map)
    {
        super(map);
    }



    
    public Object put(final long id, final String idString)
    {
        return put(Long.valueOf(id), idString);
    }



    
    public Object get(final long id)
    {
        return get(Long.valueOf(id));
    }



    
    public static PropertyIDMap getSummaryInformationProperties()
    {
        if (summaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);
            m.put(PID_TITLE, "PID_TITLE");
            m.put(PID_SUBJECT, "PID_SUBJECT");
            m.put(PID_AUTHOR, "PID_AUTHOR");
            m.put(PID_KEYWORDS, "PID_KEYWORDS");
            m.put(PID_COMMENTS, "PID_COMMENTS");
            m.put(PID_TEMPLATE, "PID_TEMPLATE");
            m.put(PID_LASTAUTHOR, "PID_LASTAUTHOR");
            m.put(PID_REVNUMBER, "PID_REVNUMBER");
            m.put(PID_EDITTIME, "PID_EDITTIME");
            m.put(PID_LASTPRINTED, "PID_LASTPRINTED");
            m.put(PID_CREATE_DTM, "PID_CREATE_DTM");
            m.put(PID_LASTSAVE_DTM, "PID_LASTSAVE_DTM");
            m.put(PID_PAGECOUNT, "PID_PAGECOUNT");
            m.put(PID_WORDCOUNT, "PID_WORDCOUNT");
            m.put(PID_CHARCOUNT, "PID_CHARCOUNT");
            m.put(PID_THUMBNAIL, "PID_THUMBNAIL");
            m.put(PID_APPNAME, "PID_APPNAME");
            m.put(PID_SECURITY, "PID_SECURITY");
            summaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return summaryInformationProperties;
    }



    
    public static PropertyIDMap getDocumentSummaryInformationProperties()
    {
        if (documentSummaryInformationProperties == null)
        {
            PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);
            m.put(PID_DICTIONARY, "PID_DICTIONARY");
            m.put(PID_CODEPAGE, "PID_CODEPAGE");
            m.put(PID_CATEGORY, "PID_CATEGORY");
            m.put(PID_PRESFORMAT, "PID_PRESFORMAT");
            m.put(PID_BYTECOUNT, "PID_BYTECOUNT");
            m.put(PID_LINECOUNT, "PID_LINECOUNT");
            m.put(PID_PARCOUNT, "PID_PARCOUNT");
            m.put(PID_SLIDECOUNT, "PID_SLIDECOUNT");
            m.put(PID_NOTECOUNT, "PID_NOTECOUNT");
            m.put(PID_HIDDENCOUNT, "PID_HIDDENCOUNT");
            m.put(PID_MMCLIPCOUNT, "PID_MMCLIPCOUNT");
            m.put(PID_SCALE, "PID_SCALE");
            m.put(PID_HEADINGPAIR, "PID_HEADINGPAIR");
            m.put(PID_DOCPARTS, "PID_DOCPARTS");
            m.put(PID_MANAGER, "PID_MANAGER");
            m.put(PID_COMPANY, "PID_COMPANY");
            m.put(PID_LINKSDIRTY, "PID_LINKSDIRTY");
            documentSummaryInformationProperties =
                new PropertyIDMap(Collections.unmodifiableMap(m));
        }
        return documentSummaryInformationProperties;
    }



    
    public static void main(final String[] args)
    {
        PropertyIDMap s1 = getSummaryInformationProperties();
        PropertyIDMap s2 = getDocumentSummaryInformationProperties();
        System.out.println("s1: " + s1);
        System.out.println("s2: " + s2);
    }
}

<code block>


package org.apache.poi.hpsf.wellknown;

import java.util.HashMap;


public class SectionIDMap extends HashMap {

    
    public static final byte[] SUMMARY_INFORMATION_ID = new byte[]
    {
        (byte) 0xF2, (byte) 0x9F, (byte) 0x85, (byte) 0xE0,
        (byte) 0x4F, (byte) 0xF9, (byte) 0x10, (byte) 0x68,
        (byte) 0xAB, (byte) 0x91, (byte) 0x08, (byte) 0x00,
        (byte) 0x2B, (byte) 0x27, (byte) 0xB3, (byte) 0xD9
    };

    
    public static final byte[][] DOCUMENT_SUMMARY_INFORMATION_ID = new byte[][]
    {
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x02,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        },
        {
            (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x05,
            (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,
            (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,
            (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE
        }
    };

    
    public static final String UNDEFINED = "[undefined]";

    
    private static SectionIDMap defaultMap;



    
    public static SectionIDMap getInstance()
    {
        if (defaultMap == null)
        {
            final SectionIDMap m = new SectionIDMap();
            m.put(SUMMARY_INFORMATION_ID,
                  PropertyIDMap.getSummaryInformationProperties());
            m.put(DOCUMENT_SUMMARY_INFORMATION_ID[0],
                  PropertyIDMap.getDocumentSummaryInformationProperties());
            defaultMap = m;
        }
        return defaultMap;
    }



    
    public static String getPIDString(final byte[] sectionFormatID,
                                      final long pid)
    {
        final PropertyIDMap m = getInstance().get(sectionFormatID);
        if (m == null) {
            return UNDEFINED;
        }
        final String s = (String) m.get(pid);
        if (s == null)
            return UNDEFINED;
        return s;
    }



    
    public PropertyIDMap get(final byte[] sectionFormatID)
    {
        return (PropertyIDMap) super.get(new String(sectionFormatID));
    }



    
    public Object get(final Object sectionFormatID)
    {
        return get((byte[]) sectionFormatID);
    }



    
    public Object put(final byte[] sectionFormatID,
                      final PropertyIDMap propertyIDMap)
    {
        return super.put(new String(sectionFormatID), propertyIDMap);
    }



    
    public Object put(final Object key, final Object value)
    {
        return put((byte[]) key, (PropertyIDMap) value);
    }

}

<code block>

package org.docx4j;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicInteger;

import net.engio.mbassy.bus.MBassador;

import org.docx4j.convert.out.FOSettings;
import org.docx4j.convert.out.HTMLSettings;
import org.docx4j.convert.out.common.Exporter;
import org.docx4j.convert.out.common.preprocess.PartialDeepCopy;
import org.docx4j.convert.out.fo.FOExporterVisitor;
import org.docx4j.convert.out.fo.FOExporterXslt;
import org.docx4j.convert.out.html.HTMLExporterVisitor;
import org.docx4j.convert.out.html.HTMLExporterXslt;
import org.docx4j.events.Docx4jEvent;
import org.docx4j.events.EventFinished;
import org.docx4j.events.PackageIdentifier;
import org.docx4j.events.StartEvent;
import org.docx4j.events.WellKnownJobTypes;
import org.docx4j.events.WellKnownProcessSteps;
import org.docx4j.model.datastorage.BindingHandler;
import org.docx4j.model.datastorage.CustomXmlDataStoragePartSelector;
import org.docx4j.model.datastorage.OpenDoPEHandler;
import org.docx4j.model.datastorage.RemovalHandler;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.packages.OpcPackage;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
import org.docx4j.openpackaging.parts.CustomXmlDataStoragePart;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.WordprocessingML.FooterPart;
import org.docx4j.openpackaging.parts.WordprocessingML.HeaderPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.openpackaging.parts.relationships.RelationshipsPart;
import org.docx4j.relationships.Relationship;
import org.docx4j.utils.TraversalUtilVisitor;
import org.docx4j.wml.SdtElement;
import org.docx4j.wml.SdtPr;
import org.w3c.dom.Document;



public class Docx4J {
	
	public static final String MIME_PDF = FOSettings.MIME_PDF;
	public static final String MIME_FO = FOSettings.INTERNAL_FO_MIME;
	
	
	public static final int FLAG_NONE = 0;
	
	
	public static final int FLAG_EXPORT_PREFER_XSL = 1;
	
	
	public static final int FLAG_EXPORT_PREFER_NONXSL = 2;

	
	public static final int FLAG_SAVE_ZIP_FILE = 1;
	
	
	public static final int FLAG_SAVE_FLAT_XML = 2;

	
	public static final int FLAG_BIND_INSERT_XML = 1;
	
	
	public static final int FLAG_BIND_BIND_XML = 2;
	
	
	public static final int FLAG_BIND_REMOVE_SDT = 4;
	
	
	public static final int FLAG_BIND_REMOVE_XML = 8;
	
	private static MBassador<Docx4jEvent> bus;
	public static void setEventNotifier(MBassador<Docx4jEvent> eventbus) {
		bus = eventbus;
	}
	
	protected static class FindContentControlsVisitor extends TraversalUtilVisitor<SdtElement> {
		public static class BreakException extends RuntimeException {
		}
		
		protected Set<String> definedStoreItemIds = null;
		protected String storeItemId = null;
		public FindContentControlsVisitor(Set<String> definedStoreItemIds) {
			this.definedStoreItemIds = definedStoreItemIds;
		}
		
		@Override
		public void apply(SdtElement element) {
		SdtPr sdtPr = element.getSdtPr();
			
			if ((sdtPr.getDataBinding() != null) &&
				(sdtPr.getDataBinding().getStoreItemID() != null)) {
				String tmp = sdtPr.getDataBinding().getStoreItemID().toLowerCase();
				if (definedStoreItemIds.contains(tmp)) {
					storeItemId = tmp;
					throw new BreakException();
				}
			}
		}
		
		public String getdefinedStoreItemId() {
			return storeItemId;
		}
	}
	
	protected static final String NS_CONDITIONS = "http:
	protected static final String NS_XPATHS = "http:
	protected static final String NS_QUESTIONS = "http:
	protected static final String NS_COMPONENTS = "http:
	protected static final Set<String> PART_TO_REMOVE_SCHEMA_TYPES = new TreeSet<String>();
	
	static {
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_CONDITIONS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_XPATHS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_QUESTIONS);
		PART_TO_REMOVE_SCHEMA_TYPES.add(NS_COMPONENTS);
	}


		
	public static WordprocessingMLPackage load(File inFile) throws Docx4JException {
		
		return WordprocessingMLPackage.load(inFile);
	}

		
	public static WordprocessingMLPackage load(PackageIdentifier pkgIdentifier, File inFile) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(pkgIdentifier, inFile);
	}
	
		
	public static WordprocessingMLPackage load(InputStream inStream) throws Docx4JException {
		return WordprocessingMLPackage.load(inStream);
	}

		
	public static WordprocessingMLPackage load(PackageIdentifier pkgIdentifier, InputStream inStream) throws Docx4JException {
		return (WordprocessingMLPackage)OpcPackage.load(pkgIdentifier, inStream);
	}
	
	
		
	public static void save(WordprocessingMLPackage wmlPackage, File outFile, int flags) throws Docx4JException {
		
		wmlPackage.save(outFile, flags);
	}
	
		
	public static void save(WordprocessingMLPackage wmlPackage, OutputStream outStream, int flags) throws Docx4JException {
		
		wmlPackage.save(outStream, flags);
		
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, String xmlDocument, int flags) throws Docx4JException {
		
		ByteArrayInputStream xmlStream = null;
		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
			try {
				xmlStream = new ByteArrayInputStream(xmlDocument.getBytes("UTF-8"));
			} catch (UnsupportedEncodingException e1) {
				xmlStream = new ByteArrayInputStream(xmlDocument.getBytes());
			}
		}
        bind(wmlPackage, xmlStream, flags);
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, InputStream xmlDocument, int flags) throws Docx4JException {
		
		StartEvent bindJobStartEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage );
		bindJobStartEvent.publish();
		
		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
	    Document xmlDoc = null;
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
				try {
		            xmlDoc = XmlUtils.getNewDocumentBuilder().parse(xmlDocument);
				} catch (Exception e) {
					throw new Docx4JException("Problems creating a org.w3c.dom.Document for the passed input stream.", e);
				}
		}
        bind(wmlPackage, xmlDoc, flags);
        
		new EventFinished(bindJobStartEvent).publish();
        
	}
	
		
	public static void bind(WordprocessingMLPackage wmlPackage, Document xmlDocument, int flags) throws Docx4JException {
		
		OpenDoPEHandler	openDoPEHandler = null;
		CustomXmlDataStoragePart customXmlDataStoragePart = null;
		RemovalHandler removalHandler = null;
		
		
		AtomicInteger bookmarkId = null;

		if (flags == FLAG_NONE) {
			
			flags = (FLAG_BIND_INSERT_XML |
					 FLAG_BIND_BIND_XML |
					 FLAG_BIND_REMOVE_SDT |
					 FLAG_BIND_REMOVE_XML);
		}
		
		customXmlDataStoragePart 
			= CustomXmlDataStoragePartSelector.getCustomXmlDataStoragePart(wmlPackage);
		if (customXmlDataStoragePart==null) {
			throw new Docx4JException("Couldn't find CustomXmlDataStoragePart! exiting..");
		}
	
		if ((flags & FLAG_BIND_INSERT_XML) == FLAG_BIND_INSERT_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_INSERT_XML );
			startEvent.publish();
			
			insertXMLData(customXmlDataStoragePart, xmlDocument);
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_BIND_XML) == FLAG_BIND_BIND_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_BIND_XML );
			startEvent.publish();
			
			
			
			openDoPEHandler = new OpenDoPEHandler(wmlPackage);
			openDoPEHandler.preprocess();
			
			BindingHandler bh = new BindingHandler(wmlPackage);
			bh.setStartingIdForNewBookmarks(openDoPEHandler.getNextBookmarkId());
			bh.applyBindings();
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_REMOVE_SDT) == FLAG_BIND_REMOVE_SDT) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_REMOVE_SDT );
			startEvent.publish();

			removeSDTs(wmlPackage);
			
			new EventFinished(startEvent).publish();
		}
		if ((flags & FLAG_BIND_REMOVE_XML) == FLAG_BIND_REMOVE_XML) {
			
			StartEvent startEvent = new StartEvent( WellKnownJobTypes.BIND, wmlPackage, WellKnownProcessSteps.BIND_REMOVE_XML );
			startEvent.publish();
			
			removeDefinedCustomXmlParts(wmlPackage, customXmlDataStoragePart);
			
			new EventFinished(startEvent).publish();
		}
	}

	protected static void insertXMLData(CustomXmlDataStoragePart customXmlDataStoragePart, Document xmlDocument) throws Docx4JException {
		
		customXmlDataStoragePart.getData().setDocument(xmlDocument);
	}


	protected static String findXPathStorageItemIdInContentControls(WordprocessingMLPackage wmlPackage) {
	FindContentControlsVisitor visitor = null;
		if ((wmlPackage.getCustomXmlDataStorageParts() != null) && 
			(!wmlPackage.getCustomXmlDataStorageParts().isEmpty())) {
			try {
				visitor = new FindContentControlsVisitor(wmlPackage.getCustomXmlDataStorageParts().keySet());
				TraversalUtil.visit(wmlPackage, false, visitor);
			}
			catch (FindContentControlsVisitor.BreakException be) {
			}
		}
		return (visitor != null ? visitor.getdefinedStoreItemId() : null);
	}

	protected static void removeSDTs(WordprocessingMLPackage wmlPackage)throws Docx4JException {
	RemovalHandler removalHandler;
	removalHandler = new RemovalHandler();
	removalHandler.removeSDTs(wmlPackage.getMainDocumentPart(), RemovalHandler.Quantifier.ALL, (String[])null);
		for (Part part:wmlPackage.getParts().getParts().values()) {
			if (part instanceof HeaderPart) {
				removalHandler.removeSDTs((HeaderPart)part, RemovalHandler.Quantifier.ALL, (String[])null);
			}
			else if (part instanceof FooterPart) {
				removalHandler.removeSDTs((FooterPart)part, RemovalHandler.Quantifier.ALL, (String[])null);
			}
		}
	}

	protected static void removeDefinedCustomXmlParts(WordprocessingMLPackage wmlPackage, CustomXmlDataStoragePart customXmlDataStoragePart) {
	List<PartName> partsToRemove = new ArrayList<PartName>();
	RelationshipsPart relationshipsPart = wmlPackage.getMainDocumentPart().getRelationshipsPart();
	List<Relationship> relationshipsList = ((relationshipsPart != null) && 
										    (relationshipsPart.getRelationships() != null) ?
										    relationshipsPart.getRelationships().getRelationship() : null);
	Part part = null;
		if (relationshipsList != null) {
			for (Relationship relationship : relationshipsList) {
				if (Namespaces.CUSTOM_XML_DATA_STORAGE.equals(relationship.getType())) {
					part = relationshipsPart.getPart(relationship);
					if (part==customXmlDataStoragePart) {
						partsToRemove.add(part.getPartName());
					}
				}
			}
		}
		if (!partsToRemove.isEmpty()) {
			for (int i=0; i<partsToRemove.size(); i++) {
				relationshipsPart.removePart(partsToRemove.get(i));
			}
		}
	}







































	
		
	public static WordprocessingMLPackage clone(WordprocessingMLPackage wmlPackage) throws Docx4JException {
		
		return (WordprocessingMLPackage)PartialDeepCopy.process(wmlPackage, null);
	}
	
		
	public static FOSettings createFOSettings() {
		return new FOSettings();
	}
	
		
	public static void toFO(FOSettings settings, OutputStream outputStream, int flags) throws Docx4JException {
		
		Exporter<FOSettings> exporter = getFOExporter(flags);
		exporter.export(settings, outputStream);
	}
	
		
	public static void toPDF(WordprocessingMLPackage wmlPackage, OutputStream outputStream) throws Docx4JException {
		
		StartEvent startEvent = new StartEvent( wmlPackage, WellKnownProcessSteps.PDF );
		startEvent.publish();
		
		FOSettings settings = createFOSettings();
		settings.setWmlPackage(wmlPackage);
		settings.setApacheFopMime("application/pdf");
		toFO(settings, outputStream, FLAG_NONE);
		
		new EventFinished(startEvent).publish();
	}
	
	protected static Exporter<FOSettings> getFOExporter(int flags) {
		switch (flags) {
			case FLAG_EXPORT_PREFER_NONXSL:
				return FOExporterVisitor.getInstance();
			case FLAG_EXPORT_PREFER_XSL:
			default:
				return FOExporterXslt.getInstance();
		}
	}

		
	public static HTMLSettings createHTMLSettings() {
		return new HTMLSettings();
	}
	
		
	public static void toHTML(HTMLSettings settings, OutputStream outputStream, int flags) throws Docx4JException {

		StartEvent startEvent = new StartEvent( settings.getWmlPackage(), WellKnownProcessSteps.HTML_OUT );
		startEvent.publish();
		
		Exporter<HTMLSettings> exporter = getHTMLExporter(flags);
		exporter.export(settings, outputStream);
		
		new EventFinished(startEvent).publish();
	}
	
		
	public static void toHTML(WordprocessingMLPackage wmlPackage, String imageDirPath, String imageTargetUri, OutputStream outputStream) throws Docx4JException {

		StartEvent startEvent = new StartEvent( wmlPackage, WellKnownProcessSteps.HTML_OUT );
		startEvent.publish();
		
		HTMLSettings settings = createHTMLSettings();
		settings.setWmlPackage(wmlPackage);
		if (imageDirPath != null) {
			settings.setImageDirPath(imageDirPath);
		}
		if (imageTargetUri != null) {
			settings.setImageTargetUri(imageTargetUri);
		}
		toHTML(settings, outputStream, FLAG_NONE);
		
		new EventFinished(startEvent).publish();
	}
	
	protected static Exporter<HTMLSettings> getHTMLExporter(int flags) {
		switch (flags) {
			case FLAG_EXPORT_PREFER_NONXSL:
				return HTMLExporterVisitor.getInstance();
			case FLAG_EXPORT_PREFER_XSL:
			default:
				return HTMLExporterXslt.getInstance();
		}
	}
}

<code block>

package org.docx4j.jaxb;


import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;

import org.apache.commons.io.IOUtils;
import org.docx4j.utils.ResourceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Context {
	
	public static final JAXBContext jc;
	
	




	@Deprecated
	public static JAXBContext jcThemePart;
	
	public static JAXBContext jcDocPropsCore;
	public static JAXBContext jcDocPropsCustom;
	public static JAXBContext jcDocPropsExtended;
	public static JAXBContext jcRelationships;
	public static JAXBContext jcCustomXmlProperties;
	public static JAXBContext jcContentTypes;

	public static JAXBContext jcXmlPackage;
	
	private static JAXBContext jcXslFo;
	public static JAXBContext jcSectionModel;

	public static JAXBContext jcXmlDSig;

	
	public static JAXBContext jcMCE;
	
	private static Logger log = LoggerFactory.getLogger(Context.class);
		
	static {
		JAXBContext tempContext = null;

		
		log.info("java.vendor="+System.getProperty("java.vendor"));
		log.info("java.version="+System.getProperty("java.version"));
		
		
		try {
			searchManifestsForJAXBImplementationInfo( ClassLoader.getSystemClassLoader());
			if (Thread.currentThread().getContextClassLoader()==null) {
				log.warn("ContextClassLoader is null for current thread");
				
			} else if (ClassLoader.getSystemClassLoader()!=Thread.currentThread().getContextClassLoader()) {
				searchManifestsForJAXBImplementationInfo(Thread.currentThread().getContextClassLoader());
			}
		} catch ( java.security.AccessControlException e) {
			
			log.warn("Caught/ignored " + e.getMessage());
		}
		
		
		InputStream jaxbPropsIS=null;
		try {
			
			jaxbPropsIS = ResourceUtils.getResource("org/docx4j/wml/jaxb.properties");
			log.info("MOXy JAXB implementation intended..");
		} catch (Exception e3) {
			log.info("No MOXy JAXB config found; assume not intended..");
			log.debug(e3.getMessage());
		}
		if (jaxbPropsIS==null) {
			
			try {
				Object namespacePrefixMapper = NamespacePrefixMapperUtils.getPrefixMapper();
				if ( namespacePrefixMapper.getClass().getName().equals("org.docx4j.jaxb.NamespacePrefixMapperSunInternal") ) {
					
					log.info("Using Java 6/7 JAXB implementation");
				} else {
					log.info("Using JAXB Reference Implementation");			
				}
				
			} catch (JAXBException e) {
				log.error("PANIC! No suitable JAXB implementation available");
				log.error(e.getMessage(), e);
				e.printStackTrace();
			}
		}
      
      try { 
			
			
			
			
			
    	  	
    	  	
    	  	
    	  	
			
			java.lang.ClassLoader classLoader = Context.class.getClassLoader();

			tempContext = JAXBContext.newInstance("org.docx4j.wml:org.docx4j.w14:org.docx4j.w15:" +
					"org.docx4j.schemas.microsoft.com.office.word_2006.wordml:" +
					"org.docx4j.dml:org.docx4j.dml.chart:org.docx4j.dml.chartDrawing:org.docx4j.dml.compatibility:org.docx4j.dml.diagram:org.docx4j.dml.lockedCanvas:org.docx4j.dml.picture:org.docx4j.dml.wordprocessingDrawing:org.docx4j.dml.spreadsheetdrawing:org.docx4j.dml.diagram2008:" +
					
					"org.docx4j.vml:org.docx4j.vml.officedrawing:org.docx4j.vml.wordprocessingDrawing:org.docx4j.vml.presentationDrawing:org.docx4j.vml.spreadsheetDrawing:org.docx4j.vml.root:" +
					"org.docx4j.docProps.coverPageProps:" +
					"org.opendope.xpaths:org.opendope.conditions:org.opendope.questions:org.opendope.answers:org.opendope.components:org.opendope.SmartArt.dataHierarchy:" +
					"org.docx4j.math:" +
					"org.docx4j.sharedtypes:org.docx4j.bibliography",classLoader );
			
			if (tempContext.getClass().getName().equals("org.eclipse.persistence.jaxb.JAXBContext")) {
				log.info("MOXy JAXB implementation is in use!");
			} else {
				log.info("Not using MOXy; using " + tempContext.getClass().getName());				
			}
			
			jcThemePart = tempContext; 
			jcDocPropsCore = JAXBContext.newInstance("org.docx4j.docProps.core:org.docx4j.docProps.core.dc.elements:org.docx4j.docProps.core.dc.terms",classLoader );
			jcDocPropsCustom = JAXBContext.newInstance("org.docx4j.docProps.custom",classLoader );
			jcDocPropsExtended = JAXBContext.newInstance("org.docx4j.docProps.extended",classLoader );
			jcXmlPackage = JAXBContext.newInstance("org.docx4j.xmlPackage",classLoader );
			jcRelationships = JAXBContext.newInstance("org.docx4j.relationships",classLoader );
			jcCustomXmlProperties = JAXBContext.newInstance("org.docx4j.customXmlProperties",classLoader );
			jcContentTypes = JAXBContext.newInstance("org.docx4j.openpackaging.contenttype",classLoader );
			
			jcSectionModel = JAXBContext.newInstance("org.docx4j.model.structure.jaxb",classLoader );
			
			jcXmlDSig = JAXBContext.newInstance("org.plutext.jaxb.xmldsig",classLoader );

			jcMCE = JAXBContext.newInstance("org.docx4j.mce",classLoader );
			
			log.debug(".. other contexts loaded ..");
										
			
		} catch (Exception ex) {
			log.error("Cannot initialize context", ex);
		}				
      jc = tempContext;
	}
	
	private static org.docx4j.wml.ObjectFactory wmlObjectFactory;
	
	public static org.docx4j.wml.ObjectFactory getWmlObjectFactory() {
		
		if (wmlObjectFactory==null) {
			wmlObjectFactory = new org.docx4j.wml.ObjectFactory();
		}
		return wmlObjectFactory;
		
	}

	public static JAXBContext getXslFoContext() {
		if (jcXslFo==null) {
			try {	
				Context tmp = new Context();
				java.lang.ClassLoader classLoader = tmp.getClass().getClassLoader();

				jcXslFo = JAXBContext.newInstance("org.plutext.jaxb.xslfo",classLoader );
				
			} catch (JAXBException ex) {
	      log.error("Cannot determine XSL-FO context", ex);
			}						
		}
		return jcXslFo;		
	}
	
	public static void searchManifestsForJAXBImplementationInfo(ClassLoader loader) {
	    Enumeration resEnum;
	    try {
	        resEnum = loader.getResources(JarFile.MANIFEST_NAME);
	        while (resEnum.hasMoreElements()) {
	        	InputStream is = null;
	            try {
	                URL url = (URL)resEnum.nextElement();

	                is = url.openStream();
	                if (is != null) {
	                    Manifest manifest = new Manifest(is);

                    	Attributes mainAttribs = manifest.getMainAttributes();
                    	String impTitle = mainAttribs.getValue("Implementation-Title");
                    	if (impTitle!=null
                    			&& impTitle.contains("JAXB Reference Implementation")
                    					|| impTitle.contains("org.eclipse.persistence") ) {
	                    
        	                log.info("\n" + url);
		                    for(Object key2  : mainAttribs.keySet() ) {
		                    	
		                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
		                    }
                    	}
                    	
	                    
	                    for(String key  :  manifest.getEntries().keySet() ) {
	    	                
	    	                if (key.equals("com.sun.xml.bind.v2.runtime")) {
		    	                log.info("Found JAXB reference implementation in " + url);
		                    	mainAttribs = manifest.getAttributes((String)key);
		                    
			                    for(Object key2  : mainAttribs.keySet() ) {
			                    	log.info(key2 + " : " + mainAttribs.getValue((java.util.jar.Attributes.Name)key2));
			                    }
		                    }
	                    }
	                    
	                }
	            }
	            catch (Exception e) {
	                

	            } finally {
	            	IOUtils.closeQuietly(is);
	            }
	        }
	    } catch (IOException e1) {
	        

	    }
	     
	}	
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.poi.poifs.dev.POIFSViewEngine;
import org.apache.poi.poifs.filesystem.DirectoryNode;
import org.apache.poi.poifs.filesystem.DocumentNode;
import org.apache.poi.poifs.filesystem.Entry;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;



public class OleObjectBinaryPart extends BinaryPart {

	private static Logger log = LoggerFactory.getLogger(OleObjectBinaryPart.class);		
	
	public OleObjectBinaryPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();				
	}

	
	public OleObjectBinaryPart() throws InvalidFormatException {
		super( new PartName("/word/embeddings/oleObject1.bin") );
		init();				
	}
	
	public void init() {
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.OFFICEDOCUMENT_OLE_OBJECT));
			

		
		setRelationshipType(Namespaces.OLE_OBJECT);
		
		
	}

	POIFSFileSystem fs;
	public POIFSFileSystem getFs() throws IOException {
		if (fs==null) {
			initPOIFSFileSystem();
		}
		return fs;
	}
	
	public void initPOIFSFileSystem() throws IOException {
		
		if (getBuffer()!=null) {

			
			
			

			log.info("initing POIFSFileSystem from existing data");
			ByteArrayInputStream bais = new ByteArrayInputStream(this.getBytes());
			fs = new POIFSFileSystem(bais);
			
		} else {

			log.info("creating new empty POIFSFileSystem");
			fs = new POIFSFileSystem();
			writePOIFSFileSystem();
		}
	}
	
	
	public void writePOIFSFileSystem() throws IOException {
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream(); 

		getFs().writeFilesystem(baos);
		
		
		byte[] bytes = baos.toByteArray();
		
		
		setBinaryData( ByteBuffer.wrap(bytes) );
		
	}
	
	
    
    
    public void viewFile(boolean verbose) throws IOException
    {
    	viewFile(System.out, verbose);
    }

    
    public void viewFile(OutputStream os, boolean verbose) throws IOException
    {
    	String indent="";
    	boolean withSizes = true;    	
    	displayDirectory(getFs().getRoot(), os, indent, withSizes);
    	
    	if (verbose) {
	        List strings = POIFSViewEngine.inspectViewable(fs, true, 0, "  ");
			Iterator iter = strings.iterator();
	
			while (iter.hasNext()) {
				os.write( ((String)iter.next()).getBytes());
			}
    	}
    }
    
    
    private void displayDirectory(DirectoryNode dir, OutputStream os, String indent, boolean withSizes) throws IOException {
        System.out.println(indent + dir.getName() + " -");
        String newIndent = indent + "  ";

        boolean hadChildren = false;
        for(Iterator<Entry> it = dir.getEntries(); it.hasNext();) {
           hadChildren = true;
           Entry entry = it.next();
           if (entry instanceof DirectoryNode) {
              displayDirectory((DirectoryNode) entry, os, newIndent, withSizes);
           } else {
              DocumentNode doc = (DocumentNode) entry;
              String name = doc.getName();
              String size = "";
              if (name.charAt(0) < 10) {
                 String altname = "(0x0" + (int) name.charAt(0) + ")" + name.substring(1);
                 name = name.substring(1) + " <" + altname + ">";
              }
              if (withSizes) {
                 size = " [" + doc.getSize() + " / 0x" + 
                        Integer.toHexString(doc.getSize()) + "]";
              }
              os.write((newIndent + name + size + "\n").getBytes() );
           }
        }
        if (!hadChildren) {
        	os.write((newIndent + "(no children)").getBytes());
        }
     }
	
}

<code block>



package org.docx4j.openpackaging.packages;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringWriter;
import java.util.HashMap;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.apache.poi.poifs.crypt.Decryptor;
import org.apache.poi.poifs.crypt.EncryptionInfo;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;
import org.docx4j.Docx4J;
import org.docx4j.TextUtils;
import org.docx4j.convert.in.FlatOpcXmlImporter;
import org.docx4j.convert.out.flatOpcXml.FlatOpcXmlCreator;
import org.docx4j.docProps.core.dc.elements.SimpleLiteral;
import org.docx4j.events.EventFinished;
import org.docx4j.events.PackageIdentifier;
import org.docx4j.events.PackageIdentifierTransient;
import org.docx4j.events.StartEvent;
import org.docx4j.events.WellKnownProcessSteps;
import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.NamespacePrefixMapperUtils;
import org.docx4j.openpackaging.Base;
import org.docx4j.openpackaging.contenttype.ContentTypeManager;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.io.LoadFromZipNG;
import org.docx4j.openpackaging.io.SaveToZipFile;
import org.docx4j.openpackaging.io3.Load3;
import org.docx4j.openpackaging.io3.Save;
import org.docx4j.openpackaging.io3.stores.PartStore;
import org.docx4j.openpackaging.io3.stores.ZipPartStore;
import org.docx4j.openpackaging.parts.CustomXmlPart;
import org.docx4j.openpackaging.parts.DocPropsCorePart;
import org.docx4j.openpackaging.parts.DocPropsCustomPart;
import org.docx4j.openpackaging.parts.DocPropsExtendedPart;
import org.docx4j.openpackaging.parts.ExternalTarget;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.Parts;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public class OpcPackage extends Base implements PackageIdentifier {

	private static Logger log = LoggerFactory.getLogger(OpcPackage.class);

	
	public HashMap<String, String> handled = new HashMap<String, String>();
	
	
	protected Parts parts = new Parts();

	
	public Parts getParts() {

		
		
		
		return parts;		
	}
	
	
	protected HashMap<ExternalTarget, Part> externalResources 
		= new HashMap<ExternalTarget, Part>();
	public HashMap<ExternalTarget, Part> getExternalResources() {
		return externalResources;		
	}	
	
	protected HashMap<String, CustomXmlPart> customXmlDataStorageParts
		= new HashMap<String, CustomXmlPart>(); 
	
	public HashMap<String, CustomXmlPart> getCustomXmlDataStorageParts() {
		return customXmlDataStorageParts;
	}	
	
	protected ContentTypeManager contentTypeManager;

	public ContentTypeManager getContentTypeManager() {
		return contentTypeManager;
	}

	public void setContentTypeManager(ContentTypeManager contentTypeManager) {
		this.contentTypeManager = contentTypeManager;
	}
	
	private PartStore sourcePartStore;	
	
	
	public PartStore getSourcePartStore() {
		return sourcePartStore;
	}

	
	public void setSourcePartStore(PartStore partStore) {
		this.sourcePartStore = partStore;
	}

	private PartStore targetPartStore;	
	
	
	public PartStore getTargetPartStore() {
		return targetPartStore;
	}

	
	public void setTargetPartStore(PartStore partStore) {
		this.targetPartStore = partStore;
	}
	
	
	public OpcPackage() {
		try {
			this.setPartName(new PartName("/", false));
			
			contentTypeManager = new ContentTypeManager();
		} catch (Exception e) {
			log.error(e.getMessage());
			
		}
	}

	
	public OpcPackage(ContentTypeManager contentTypeManager) {
		try {
			this.setPartName(new PartName("/", false));
			
			this.contentTypeManager = contentTypeManager;
		} catch (Exception e) {
			log.error(e.getMessage());
			
		}
	}
	
	public OpcPackage getPackage() {
		return this;
	}
		
	
	protected DocPropsCorePart docPropsCorePart;

	protected DocPropsExtendedPart docPropsExtendedPart;
	
	protected DocPropsCustomPart docPropsCustomPart;
	
		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final java.io.File docxFile) throws Docx4JException {
		return load(pkgIdentifier, docxFile, null);
	}
	
		
	public static OpcPackage load(final java.io.File docxFile) throws Docx4JException {
		return load(docxFile, null);
	}
	
		
	public static OpcPackage load(final java.io.File docxFile, String password) throws Docx4JException {
		
		PackageIdentifier name = new PackageIdentifierTransient(docxFile.getName());
		
		try {
			return OpcPackage.load(name, new FileInputStream(docxFile), password );
		} catch (final FileNotFoundException e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load file from " + docxFile.getAbsolutePath(), e);
		}
	}

		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final java.io.File docxFile, String password) throws Docx4JException {
		
		try {
			return OpcPackage.load(pkgIdentifier, new FileInputStream(docxFile), password );
		} catch (final FileNotFoundException e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load file from " + docxFile.getAbsolutePath(), e);
		}
	}
	
		
	public static OpcPackage load(final InputStream inputStream) throws Docx4JException {
		return load(inputStream, "");
	}

		
	public static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream inputStream) throws Docx4JException {
		return load(pkgIdentifier, inputStream, "");
	}
	
		
	public static OpcPackage load(final InputStream inputStream, String password) throws Docx4JException {

		return load(null, inputStream,  password);
	}
	
		
	private static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream inputStream, String password) throws Docx4JException {
		
		
		final BufferedInputStream bis = new BufferedInputStream(inputStream);
		bis.mark(0);
		final byte[] firstTwobytes=new byte[2];
		int read=0;
		try {
			read = bis.read(firstTwobytes);
			bis.reset();
		} catch (final IOException e) {
			throw new Docx4JException("Error reading from the stream", e);
		}
		if (read!=2){
			throw new Docx4JException("Error reading from the stream (no bytes available)");
		}
		if (firstTwobytes[0]=='P' && firstTwobytes[1]=='K') { 
			return OpcPackage.load(pkgIdentifier, bis, Filetype.ZippedPackage, null);
		} else if  (firstTwobytes[0]==(byte)0xD0 && firstTwobytes[1]==(byte)0xCF) {
			
			log.info("Detected compound file");
			return OpcPackage.load(pkgIdentifier, bis, Filetype.Compound, password);
		} else {
			
			log.info("Assuming Flat OPC XML");
			return OpcPackage.load(pkgIdentifier, bis, Filetype.FlatOPC, null);
		}
	}
	
	
	
	@Deprecated
	public static OpcPackage load(final InputStream is, final boolean docxFormat) throws Docx4JException {
		return load(is);  
	}

	
	public static OpcPackage load(final InputStream is, Filetype type) throws Docx4JException {
		return load(is, type, null);
	}

	
	public static OpcPackage load(final InputStream is, Filetype type, String password) throws Docx4JException {

		return load(null, is, type, password);
	}
	
	
	private static OpcPackage load(PackageIdentifier pkgIdentifier, final InputStream is, Filetype type, String password) throws Docx4JException {

		if (pkgIdentifier==null) {
			pkgIdentifier = new PackageIdentifierTransient("pkg_" + System.currentTimeMillis());
		}
		
		StartEvent startEvent = new StartEvent( pkgIdentifier,  WellKnownProcessSteps.PKG_LOAD );
		startEvent.publish();			
		
		if (type.equals(Filetype.ZippedPackage)){
			
			final ZipPartStore partLoader = new ZipPartStore(is);
			final Load3 loader = new Load3(partLoader);
			OpcPackage opcPackage = loader.get();
			
			if (pkgIdentifier!=null) {
				opcPackage.setName(pkgIdentifier.name());
			}
			
			new EventFinished(startEvent).publish();						
			return opcPackage;
			


			
		} else if (type.equals(Filetype.Compound)){
			
	        try {
				POIFSFileSystem fs = new POIFSFileSystem(is);
				EncryptionInfo info = new EncryptionInfo(fs); 
		        Decryptor d = Decryptor.getInstance(info); 
		        d.verifyPassword(password); 
		        
				InputStream is2 = d.getDataStream(fs);
				final LoadFromZipNG loader = new LoadFromZipNG();
				return loader.get(is2);				
				
			} catch (java.security.InvalidKeyException e) {
		        
				throw new Docx4JException("Problem reading compound file: wrong password?", e);
			} catch (Exception e) {
				throw new Docx4JException("Problem reading compound file", e);
			} finally {
				new EventFinished(startEvent).publish();				
			}
		}
		
		try {
			FlatOpcXmlImporter xmlPackage = new FlatOpcXmlImporter(is); 
			return xmlPackage.get(); 
		} catch (final Exception e) {
			OpcPackage.log.error(e.getMessage(), e);
			throw new Docx4JException("Couldn't load xml from stream ",e);
		} finally {
			new EventFinished(startEvent).publish();									
		}
	}

		
	public void save(java.io.File file) throws Docx4JException {
		if (file.getName().endsWith(".xml")) {
			save(file, Docx4J.FLAG_SAVE_FLAT_XML);			
		} else {
			save(file, Docx4J.FLAG_SAVE_ZIP_FILE);						
		}
	}	

	
	









	
		
	public void save(File outFile, int flags) throws Docx4JException {
		
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(outFile);
			save(outStream, flags);
		} catch (FileNotFoundException e) {
			throw new Docx4JException("Exception creating output stream: " + e.getMessage(), e);
		}
		finally {
			if (outStream != null) {
				try {
					outStream.close();
				} catch (IOException e) {}
				outStream = null;
			}
		}
		
	}	

		
	public void save(OutputStream outStream) throws Docx4JException {
		save(outStream, Docx4J.FLAG_SAVE_ZIP_FILE);						
	}

	
		
	public void save(OutputStream outStream, int flags) throws Docx4JException {
		
		StartEvent startEvent = new StartEvent( this,  WellKnownProcessSteps.PKG_SAVE );
		startEvent.publish();
		
		if (flags == Docx4J.FLAG_SAVE_FLAT_XML) {
			JAXBContext jc = Context.jcXmlPackage;
			FlatOpcXmlCreator opcXmlCreator = new FlatOpcXmlCreator(this);
			org.docx4j.xmlPackage.Package pkg = opcXmlCreator.get();
			Marshaller marshaller;
			try {
				marshaller = jc.createMarshaller();
				NamespacePrefixMapperUtils.setProperty(marshaller, 
						NamespacePrefixMapperUtils.getPrefixMapper());			
				marshaller.marshal(pkg, outStream);				
			} catch (JAXBException e) {
				throw new Docx4JException("Exception marshalling document for output: " + e.getMessage(), e);
			}
		}
		else {

			Save saver = new Save(this);
			saver.save(outStream);
		}
		new EventFinished(startEvent).publish();
	}	
	
	
	

	@Override
	public boolean setPartShortcut(Part part, String relationshipType) {
		if (relationshipType.equals(Namespaces.PROPERTIES_CORE)) {
			docPropsCorePart = (DocPropsCorePart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_CUSTOM)) {
			docPropsCustomPart = (DocPropsCustomPart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_EXTENDED)) {
			docPropsExtendedPart = (DocPropsExtendedPart)part;
			return true;			
		} else {	
			return false;
		}
	}

	public DocPropsCorePart getDocPropsCorePart() {















		return docPropsCorePart;
	}

	public DocPropsExtendedPart getDocPropsExtendedPart() {















		return docPropsExtendedPart;
	}

	
	public DocPropsCustomPart getDocPropsCustomPart() {
		


















		
		return docPropsCustomPart;
	}
	
		
	public void setTitle(String title) {
		
		if (this.getDocPropsCorePart()==null) {
			DocPropsCorePart core;
			try {
				core = new DocPropsCorePart();
				org.docx4j.docProps.core.ObjectFactory coreFactory = new org.docx4j.docProps.core.ObjectFactory();
				core.setJaxbElement(coreFactory.createCoreProperties() );
				this.addTargetPart(core);			
			} catch (InvalidFormatException e) {
				log.error(e.getMessage(), e);
			}
		}
		
		org.docx4j.docProps.core.dc.elements.ObjectFactory of = new org.docx4j.docProps.core.dc.elements.ObjectFactory();
		SimpleLiteral literal = of.createSimpleLiteral();
		literal.getContent().add(title);
		this.getDocPropsCorePart().getJaxbElement().setTitle(of.createTitle(literal) );				
	}
	
		
	public String getTitle() {
		
		if (this.getDocPropsCorePart()==null) {
			return null;
		}
		
		JAXBElement<SimpleLiteral> sl = this.getDocPropsCorePart().getJaxbElement().getTitle();
		if (sl == null) return null;
		
		StringWriter sw = new StringWriter(); 
		 try {
			TextUtils.extractText(sl, sw, Context.jcDocPropsCore);
		} catch (Exception e) {
			log.error(e.getMessage(), e);
		}
		return sw.toString();				
	}
	

	
	public OpcPackage clone() {
		
		OpcPackage result = null;
		
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		SaveToZipFile saver = new SaveToZipFile(this);
		try {
			saver.save(baos);
			result = load(new ByteArrayInputStream(baos.toByteArray()));
		} catch (Docx4JException e) {
			
			e.printStackTrace();
		}

		return result;
		
	}

	@Override
	public String name() {
		return name;
	}
	private String name;
	
	public void setName(String name) {
		this.name = name;
	}
	
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;

import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import org.docx4j.XmlUtils;
import org.docx4j.jaxb.Context;
import org.docx4j.model.styles.BrokenStyleRemediator;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.utils.ResourceUtils;
import org.docx4j.wml.BooleanDefaultTrue;
import org.docx4j.wml.DocDefaults;
import org.docx4j.wml.HpsMeasure;
import org.docx4j.wml.PPr;
import org.docx4j.wml.PPrBase.Spacing;
import org.docx4j.wml.RPr;
import org.docx4j.wml.Style;
import org.docx4j.wml.Style.BasedOn;
import org.docx4j.wml.Styles;
import org.docx4j.wml.Styles.LatentStyles.LsdException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;


public final class StyleDefinitionsPart extends JaxbXmlPartXPathAware<Styles> {
	
	private static Logger log = LoggerFactory.getLogger(StyleDefinitionsPart.class);		
	
	public StyleDefinitionsPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}

	public StyleDefinitionsPart() throws InvalidFormatException {
		super(new PartName("/word/styles.xml"));
		init();
	}
	
	public void init() {
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.WORDPROCESSINGML_STYLES));

		
		setRelationshipType(Namespaces.STYLES);
	}
	
	
	private static java.util.Map<String, org.docx4j.wml.Style>  knownStyles = null;
	
	
	
	@Override
	public void setJaxbElement(Styles jaxbElement) {
		super.setJaxbElement(jaxbElement);
		
		styleDocDefaults=null;
	    defaultCharacterStyle = null;
	    defaultParagraphStyle = null;
	    defaultTableStyle = null;
	    css=null;
	}
	
    






















    
    
    public Object unmarshalDefaultStyles() throws JAXBException {
    	
    	


    	  
    		java.io.InputStream is = null;
			try {
				
				
				
				
				is = ResourceUtils.getResourceViaProperty("docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.DefaultStyles",
						"org/docx4j/openpackaging/parts/WordprocessingML/styles.xml");
				
					
					
				
			} catch (IOException e) {
				
				e.printStackTrace();
			}    		
    	
    	return unmarshal( is );    
    }
    
    private static void initKnownStyles() {



    	
		java.io.InputStream is = null;
		try {
			is = ResourceUtils.getResourceViaProperty("docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.KnownStyles",
					"org/docx4j/openpackaging/parts/WordprocessingML/KnownStyles.xml");						
			
			JAXBContext jc = Context.jc;
			Unmarshaller u = jc.createUnmarshaller();			
			u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());

			org.docx4j.wml.Styles styles = (org.docx4j.wml.Styles)u.unmarshal( is );			
			
			knownStyles = new java.util.HashMap<String, org.docx4j.wml.Style>();
			
			for ( org.docx4j.wml.Style s : styles.getStyle() ) {				
				knownStyles.put(s.getStyleId(), s);				
			}
			
		} catch (Exception e) {
			
			e.printStackTrace();
		}    		
    	
		
    }

	
	public static java.util.Map<String, org.docx4j.wml.Style> getKnownStyles() {
		if (knownStyles==null) {
			initKnownStyles();
		}
		return knownStyles;
	}
    
	private Style styleDocDefaults;
	
	
    public void createVirtualStylesForDocDefaults() throws Docx4JException {
    	
    	if (styleDocDefaults!=null) return; 
    	
    	String ROOT_NAME = "DocDefaults";

    	
    	styleDocDefaults = getStyleById(this.getJaxbElement().getStyle(), ROOT_NAME);
    	if (styleDocDefaults==null) {

        	styleDocDefaults = Context.getWmlObjectFactory().createStyle();
        	styleDocDefaults.setStyleId(ROOT_NAME);
        	
    		this.getJaxbElement().getStyle().add(styleDocDefaults);
    		
    	} else {
    		
    		log.debug("Found existing style named " + ROOT_NAME);
    		log.debug(XmlUtils.marshaltoString(styleDocDefaults, true, true));
    		
        	
    		
    		
    		if (styleDocDefaults.getRPr()!=null) {
        		log.debug(".. reusing");
    			return;
    		} else {
        		log.debug(".. but no rPr, so re-creating");    			
    		}
    	}
    	
    	styleDocDefaults.setType("paragraph");
    	
		org.docx4j.wml.Style.Name n = Context.getWmlObjectFactory().createStyleName();
    	n.setVal(ROOT_NAME);
    	styleDocDefaults.setName(n);
    			
		
		DocDefaults docDefaults = this.getJaxbElement().getDocDefaults(); 		
		
		if (docDefaults == null) {
			log.info("No DocDefaults present");
			
			
			
			
			
			try {

				docDefaults = (DocDefaults) XmlUtils
						.unmarshalString(docDefaultsString);
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ docDefaultsString, e);
			}
		}

		
		PPr documentDefaultPPr;
		if (docDefaults.getPPrDefault() == null) {
			log.info("No PPrDefault present");
			try {
				documentDefaultPPr = (PPr) XmlUtils
						.unmarshalString(pPrDefaultsString);
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ pPrDefaultsString, e);
			}

		} else {
			documentDefaultPPr = docDefaults.getPPrDefault().getPPr();
			if (documentDefaultPPr==null) {
				documentDefaultPPr = Context.getWmlObjectFactory().createPPr();
			}
		}
		
		
		
		if (documentDefaultPPr.getSpacing()==null) {
			Spacing spacing = Context.getWmlObjectFactory().createPPrBaseSpacing();
			documentDefaultPPr.setSpacing(spacing);
			spacing.setBefore(BigInteger.ZERO);
			spacing.setAfter(BigInteger.ZERO);
			spacing.setLine(BigInteger.valueOf(240));
		}

		
		RPr documentDefaultRPr;
		if (docDefaults.getRPrDefault() == null) {
			log.info("No RPrDefault present");
			try {
				documentDefaultRPr = (RPr) XmlUtils
						.unmarshalString(rPrDefaultsString);
					
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ rPrDefaultsString, e);
			}
		} else {
			documentDefaultRPr = docDefaults.getRPrDefault().getRPr();
			if (documentDefaultRPr==null) {
				documentDefaultRPr = Context.getWmlObjectFactory().createRPr();
			}
			
			


			if (documentDefaultRPr.getSz()==null) {
				HpsMeasure s10pt = Context.getWmlObjectFactory().createHpsMeasure();
				s10pt.setVal(BigInteger.valueOf(20));
				documentDefaultRPr.setSz(s10pt);
			}
			if (documentDefaultRPr.getSzCs()==null) {
				HpsMeasure s10pt = Context.getWmlObjectFactory().createHpsMeasure();
				s10pt.setVal(BigInteger.valueOf(20));
				documentDefaultRPr.setSzCs(s10pt);
			}
		}
    	
		styleDocDefaults.setPPr(documentDefaultPPr);
		styleDocDefaults.setRPr(documentDefaultRPr);
		
		
		Style normal = getDefaultParagraphStyle();
		if (normal==null) {
			log.info("No default paragraph style!!");
			normal = Context.getWmlObjectFactory().createStyle();
			normal.setType("paragraph");
			normal.setStyleId("Normal");
			
			n = Context.getWmlObjectFactory().createStyleName();
			n.setVal("Normal");
			normal.setName(n);
			this.getJaxbElement().getStyle().add(normal);	
			
			normal.setDefault(Boolean.TRUE); 
		}
		
		BasedOn based = Context.getWmlObjectFactory().createStyleBasedOn();
		based.setVal(ROOT_NAME);		
		normal.setBasedOn(based);
		
		log.debug("Set virtual style, id '" + styleDocDefaults.getStyleId() + "', name '"+ styleDocDefaults.getName().getVal() + "'");
		
		log.debug(XmlUtils.marshaltoString(styleDocDefaults, true, true));
		
		
    	
    }
    
    
    public Style getStyleById(String id) {
    	
		return getStyleById( this.getJaxbElement().getStyle(), id ); 				

    }

    
    private static Style getStyleById(List<Style> styles, String id) {
    	
		for ( org.docx4j.wml.Style s : styles ) {	
			
			if (s.getStyleId()==null) {
				BrokenStyleRemediator.remediate(s);
			}
			
			if( s.getStyleId()!=null
					&& s.getStyleId().equals(id) ) {
				return s;
			}
		}
    	return null;
    }
    
    private Style defaultCharacterStyle;
    public Style getDefaultCharacterStyle() {
    	
    	if (defaultCharacterStyle==null) {
    		defaultCharacterStyle = getDefaultStyle("character");
    	}
    	
    	
    	
    	if (defaultCharacterStyle==null) {
    		try {
				defaultCharacterStyle = (Style)XmlUtils.unmarshalString(DEFAULT_CHARACTER_STYLE_DEFAULT);
				this.getJaxbElement().getStyle().add(defaultCharacterStyle);
			} catch (JAXBException e) {
				e.printStackTrace();
			}
    	}
		return defaultCharacterStyle;
    }
    
    private final static String DEFAULT_CHARACTER_STYLE_DEFAULT = "<w:style w:type=\"character\" w:default=\"1\" w:styleId=\"DefaultParagraphFont\" " + Namespaces.W_NAMESPACE_DECLARATION + "><w:name w:val=\"Default Paragraph Font\" /></w:style>";
    
    
    
    private Style defaultParagraphStyle;
    
    public Style getDefaultParagraphStyle() {
    	
    	if (defaultParagraphStyle==null) {
    		defaultParagraphStyle = getDefaultStyle("paragraph");
    	}
    	
    	
    	
    	if (defaultParagraphStyle==null) {
    		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
    			if( s.getType().equals("paragraph")
    					&& s.getName()!=null
    					&& s.getName().getVal().equals("Default") ) {
    				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
    				defaultParagraphStyle=s;
    				break;
    			}
    		}    		
    	}
    	
    	if (defaultParagraphStyle==null) {
    		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
    			if( s.getType().equals("paragraph")
    					&& s.getStyleId().equals("style0") ) {
    				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
    				defaultParagraphStyle=s;
    				break;
    			}
    		}    		
    	}
    
    	
		return defaultParagraphStyle;
    }
    
    private Style defaultTableStyle;
    
    public Style getDefaultTableStyle() {
    	
    	if (defaultTableStyle==null) {
    		defaultTableStyle = getDefaultStyle("table");
    	}
		return defaultTableStyle;
    }
    
    private Style getDefaultStyle(String type) {
    	
		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
			if( s.isDefault() && s.getType().equals(type)) {
				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
				return s;
			}
		}
		return null;
    }
    
    
	final static String wNamespaceDec = " xmlns:w=\"" + Namespaces.NS_WORD12 + "\""; 

	public final static String rPrDefaultsString = "<w:rPr" + wNamespaceDec + ">"
		
        
        + "<w:sz w:val=\"20\" />"  
        + "<w:szCs w:val=\"20\" />"
        + "<w:lang w:val=\"en-US\" w:eastAsia=\"en-US\" w:bidi=\"ar-SA\" />"
      + "</w:rPr>";
	public final static String pPrDefaultsString = "<w:pPr" + wNamespaceDec + ">"
	        + "<w:spacing w:after=\"200\" w:line=\"276\" w:lineRule=\"auto\" />"
	      + "</w:pPr>";
	public final static String docDefaultsString = "<w:docDefaults" + wNamespaceDec + ">"
	    + "<w:rPrDefault>"
	    + 	rPrDefaultsString
	    + "</w:rPrDefault>"
	    + "<w:pPrDefault>"
	    + 	pPrDefaultsString
	    + "</w:pPrDefault>"
	  + "</w:docDefaults>";
	

	
	private String css;
	public String getCss() {
		return css;
	}
	public void setCss(String css) {
		this.css = css;
	}
	
	
	public Style getLinkedStyle(String rStyleVal) {
		
		Style rStyle = getStyleById(rStyleVal);
		if (rStyle==null) {
			log.info("Couldn't find rStyle " + rStyleVal);
			return null;
		} else {
			
			Style.Link linkedStyle = rStyle.getLink();
			if (linkedStyle==null) {
				log.info("No linked style for rStyle " + rStyleVal);							
				return null;
			} else {
				String pStyleVal = linkedStyle.getVal();
				log.debug(rStyleVal + " is linked to style " + pStyleVal );
				Style pStyle = getStyleById(pStyleVal);
				
				if (pStyle==null) {
					log.info("Couldn't find linked pStyle " + pStyleVal 
							+ " for rStyle " + rStyleVal);		
				}
				return pStyle;
			}
		}
	}

	
	
	public void protectRestrictFormatting(List<String> allowedStyleNames, boolean removedNotAllowedFormatting,
			Set<String> stylesInUse) throws Docx4JException {

		
		if (this.getJaxbElement()==null) 
			throw new Docx4JException("StyleDefinitionsPart null content");
		
		if (this.getJaxbElement().getLatentStyles()==null) 
			throw new Docx4JException("StyleDefinitionsPart content missing latentStyles");
		
		
		this.getJaxbElement().getLatentStyles().setDefLockedState(Boolean.TRUE);
		
		
		
		Map<String, LsdException> lsdExceptions = new HashMap<String, LsdException>(); 
		for (LsdException lsdException : this.getJaxbElement().getLatentStyles().getLsdException()) {
			
			lsdExceptions.put(lsdException.getName(), lsdException);
			
			lsdException.setLocked(true); 
		}
		
		
		getDefaultParagraphStyle();
		String defaultParagraphStyleName = "Normal";
		if (defaultParagraphStyle!=null) {
			defaultParagraphStyleName=defaultParagraphStyle.getName().getVal();
		}
		LsdException defaultLsd = lsdExceptions.get(defaultParagraphStyleName);
		if (defaultLsd==null) {
			log.warn("No lsdException for " + defaultParagraphStyleName);
		} else {
			defaultLsd.setLocked(false);
		}
		
		
		for (String styleName : allowedStyleNames) {

			LsdException lsdEx = lsdExceptions.get(styleName);
			if (lsdEx==null) {
				log.debug("No lsdException for " + styleName);
			} else {
				lsdEx.setLocked(false);
			}			
		}
		
		 		
		for (String styleName : stylesInUse) {

			LsdException lsdEx = lsdExceptions.get(styleName);
			if (lsdEx==null) {
				log.debug("No lsdException for " + styleName);
			} else {
				lsdEx.setLocked(false);
				lsdEx.setSemiHidden(false);
			}			
		}
		
		
		
		allowedStyleNames.add(defaultParagraphStyleName);
		List<Style> deletions = new ArrayList<Style>(); 
		for (Style s : this.getJaxbElement().getStyle()) {
			
			if (!allowedStyleNames.contains(s.getName().getVal())) {

				if (stylesInUse.contains(s.getName().getVal())) {
					
					s.setLocked(new BooleanDefaultTrue());
					
				} else {				
					deletions.add(s);
				}
			}
		}
		this.getJaxbElement().getStyle().removeAll(deletions);
		
	}
	
	private BiMap<String,String> styleIdToName; 
	private BiMap<String,String> styleNameToId;
	
	
	public String getNameForStyleID(String id) {
		
		if (styleIdToName==null) {
			refreshNameIdBiMaps();
		}
		
		return styleIdToName.get(id);
	}
	
	
	public String getIDForStyleName(String name) {

		if (styleIdToName==null) {
			refreshNameIdBiMaps();
		}
		
		return styleNameToId.get(name);
	}

	
	public void refreshNameIdBiMaps() {
		
		styleIdToName= HashBiMap.create();
		for (Style s : this.getJaxbElement().getStyle()) {
			if (s.getName()==null
					|| s.getName().getVal()==null) {
				log.info("style has no name!");
			} else if (s.getStyleId()==null
					|| s.getStyleId().trim().length()==0) {
				log.info("style has no id!");				
			} else {
				styleIdToName.put(s.getStyleId(), s.getName().getVal());
			}
		}
		styleNameToId = styleIdToName.inverse();
	}
	
    






}

<code block>




package org.docx4j.openpackaging.parts.WordprocessingML;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;

import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.McIgnorableNamespaceDeclarator;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.wml.BooleanDefaultTrue;
import org.docx4j.wml.CTCompat;
import org.docx4j.wml.CTCompatSetting;
import org.docx4j.wml.CTDocProtect;
import org.docx4j.wml.CTSettings;
import org.docx4j.wml.STAlgClass;
import org.docx4j.wml.STAlgType;
import org.docx4j.wml.STCryptProv;
import org.docx4j.wml.STDocProtect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public final class DocumentSettingsPart extends JaxbXmlPartXPathAware<CTSettings> { 
	
	private final static Logger log = LoggerFactory.getLogger(DocumentSettingsPart.class);
	
	
	
	public DocumentSettingsPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}

	public DocumentSettingsPart() throws InvalidFormatException {
		super(new PartName("/word/settings.xml"));
		init();
	}
	
	public void init() {		
		
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.WORDPROCESSINGML_SETTINGS));

		
		setRelationshipType(Namespaces.SETTINGS);
				
	}
	
	@Override
    protected void setMceIgnorable(McIgnorableNamespaceDeclarator namespacePrefixMapper) {

		

		boolean needW14 = false;
		if (this.jaxbElement.getDocId14()!=null) {
			needW14 = true;
		} else if (this.jaxbElement.getConflictMode() !=null) {
			needW14 = true;
		} else if (this.jaxbElement.getDiscardImageEditingData() !=null) {
			needW14 = true;
		} else if (this.jaxbElement.getDefaultImageDpi() !=null) {
			needW14 = true;
		}
		
		boolean needW15 = false;		
		if (this.jaxbElement.getChartTrackingRefBased()!=null) {
			needW15 = true;
		} else if (this.jaxbElement.getDocId15() !=null) {
			needW15 = true;
		}
		
		String mceIgnorableVal = "";
		if (needW14) {
			mceIgnorableVal = "w14";
		}
		
		if (needW15) {
			mceIgnorableVal += " w15";
		} 
		log.debug(mceIgnorableVal);
		
		this.jaxbElement.setIgnorable(mceIgnorableVal);
				
    }
	
	
	public CTCompatSetting getWordCompatSetting(String name) throws Docx4JException {
	
		CTCompat compat = this.getContents().getCompat();
		if (compat==null) {
			log.warn("No w:settings/w:compat element");
			return null;
		}
		
		CTCompatSetting theSetting = null;
		for (CTCompatSetting setting : compat.getCompatSetting() ) {
			if (setting.getUri().equals("http:
					&& setting.getName().equals(name)) {
				theSetting = setting;
				break;
			}
		}
		
		return theSetting;
	}

	public void setWordCompatSetting(String name, String val) throws Docx4JException {
		
		CTCompat compat = this.getContents().getCompat();
		if (compat==null) {
			log.debug("No w:settings/w:compat element; creating..");
		}
		compat = Context.getWmlObjectFactory().createCTCompat();
		this.getContents().setCompat(compat);
		
		CTCompatSetting theSetting = null;
		for (CTCompatSetting setting : compat.getCompatSetting() ) {
			if (setting.getUri().equals("http:
					&& setting.getName().equals(name)) {
				theSetting = setting;
				break;
			}
		}
		
		if (theSetting==null) {
			theSetting = Context.getWmlObjectFactory().createCTCompatSetting();
			theSetting.setUri("http:
			theSetting.setName(name);
			compat.getCompatSetting().add(theSetting);
		}
		theSetting.setVal(val);
	}
	
	
	public void protectRestrictFormatting( boolean autoFormatOverride, boolean styleLockTheme, boolean styleLockQFSet,
			String password, HashAlgorithm hashAlgo) throws Docx4JException {
		
		if (password==null && hashAlgo!=null) throw new IllegalArgumentException("Unless you set a password, a HashAlgorithm makes no sense");
		
		if (password!=null && hashAlgo==null) throw new IllegalArgumentException("If you set a password, a HashAlgorithm must be specified");
		
		

        safeGetDocumentProtection().setFormatting(true);
        safeGetDocumentProtection().setEnforcement(true);  
        
        if (autoFormatOverride) {
        	if (this.jaxbElement.getAutoFormatOverride()==null) {
        		this.jaxbElement.setAutoFormatOverride(new BooleanDefaultTrue());
        	}        	
        }

        if (styleLockTheme) {
        	if (this.jaxbElement.getStyleLockTheme()==null) {
        		this.jaxbElement.setStyleLockTheme(new BooleanDefaultTrue());
        	}        	
        }

        if (styleLockQFSet) {
        	if (this.jaxbElement.getStyleLockQFSet()==null) {
        		this.jaxbElement.setStyleLockQFSet(new BooleanDefaultTrue());
        	}        	
        }
        
        if (password!=null) {
        	
        	
        	setProtectionPassword(password, hashAlgo);
        }

	}
	
	
    
    public boolean isEnforcedWith(STDocProtect editValue) {
        CTDocProtect ctDocProtect = this.jaxbElement.getDocumentProtection();

        if (ctDocProtect == null) {
            return false;
        }

        return ctDocProtect.isEnforcement() && ctDocProtect.getEdit().equals(editValue);
    }
    

    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue) {
    	
    	setEnforcementEditValue(editValue, null, null);
    }

    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,
                                        String password) {

    	setEnforcementEditValue(editValue, password, HashAlgorithm.sha1);
    }

    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,
                                        String password, HashAlgorithm hashAlgo) {
    	
        safeGetDocumentProtection().setEnforcement(true);    	
        safeGetDocumentProtection().setEdit(editValue);
        
        
        
        if (editValue==STDocProtect.TRACKED_CHANGES) {
        	if (this.jaxbElement.getTrackRevisions()==null) {
        		this.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());
        	}
        }

        setProtectionPassword(password, hashAlgo);
    }
    
    
    private void setProtectionPassword(String password, HashAlgorithm hashAlgo) {

        if (password == null) {
        	
            safeGetDocumentProtection().setCryptProviderType(null);
            safeGetDocumentProtection().setCryptAlgorithmClass(null);
            safeGetDocumentProtection().setCryptAlgorithmType(null);
            safeGetDocumentProtection().setCryptAlgorithmSid(null);
            safeGetDocumentProtection().setSalt(null);
            safeGetDocumentProtection().setCryptSpinCount(null);
            safeGetDocumentProtection().setHash(null);
            
            return;
            
        } else {
            final STCryptProv providerType;
            final int sid;
            switch (hashAlgo) {
                case md2:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 1;
                    break;
                case md4:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 2;
                    break;
                case md5:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 3;
                    break;
                case sha1:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 4;
                    break;
                case sha256:
                    providerType = STCryptProv.RSA_AES;
                    sid = 12;
                    break;
                case sha384:
                    providerType = STCryptProv.RSA_AES;
                    sid = 13;
                    break;
                case sha512:
                    providerType = STCryptProv.RSA_AES;
                    sid = 14;
                    break;
                default:
                    throw new EncryptedDocumentException
                            ("Hash algorithm '" + hashAlgo + "' is not supported for document write protection.");
            }


            SecureRandom random = new SecureRandom();
            byte salt[] = random.generateSeed(16);

            
            
            int spinCount = 100000;

            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;

            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);
            
            
            
            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);

            safeGetDocumentProtection().setSalt(salt);
            safeGetDocumentProtection().setHash(hash);
            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));
            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);
            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);
            safeGetDocumentProtection().setCryptProviderType(providerType);
            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));
        }
    }

    
    public boolean validateProtectionPassword(String password) {
        BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();
        byte hash[] = safeGetDocumentProtection().getHash();
        byte salt[] = safeGetDocumentProtection().getSalt();
        BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();

        if (sid == null || hash == null || salt == null || spinCount == null) return false;

        HashAlgorithm hashAlgo;
        switch (sid.intValue()) {
            case 1:
                hashAlgo = HashAlgorithm.md2;
                break;
            case 2:
                hashAlgo = HashAlgorithm.md4;
                break;
            case 3:
                hashAlgo = HashAlgorithm.md5;
                break;
            case 4:
                hashAlgo = HashAlgorithm.sha1;
                break;
            case 12:
                hashAlgo = HashAlgorithm.sha256;
                break;
            case 13:
                hashAlgo = HashAlgorithm.sha384;
                break;
            case 14:
                hashAlgo = HashAlgorithm.sha512;
                break;
            default:
                return false;
        }

        String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);
        
        
        
        byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);

        return Arrays.equals(hash, hash2);
    }

    
    public void removeEnforcement() {
        safeGetDocumentProtection().setEnforcement(false);    	
    }	
    
    private CTDocProtect safeGetDocumentProtection() {
    	
    	if (this.getJaxbElement()==null) {
    		this.jaxbElement=new CTSettings();
    	}
    	
        CTDocProtect documentProtection = this.jaxbElement.getDocumentProtection();
        if (documentProtection == null) {
            documentProtection = Context.getWmlObjectFactory().createCTDocProtect();
            this.jaxbElement.setDocumentProtection(documentProtection);
        }
        return this.jaxbElement.getDocumentProtection();
    }    
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;


import org.docx4j.XmlUtils;
import org.docx4j.jaxb.Context;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
import org.docx4j.openpackaging.parts.JaxbXmlPartAltChunkHost;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.ThemePart;
import org.docx4j.openpackaging.parts.opendope.ComponentsPart;
import org.docx4j.openpackaging.parts.opendope.ConditionsPart;
import org.docx4j.openpackaging.parts.opendope.QuestionsPart;
import org.docx4j.openpackaging.parts.opendope.XPathsPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.wml.CTEndnotes;
import org.docx4j.wml.CTFootnotes;
import org.docx4j.wml.CTFtnEdn;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;



public abstract class DocumentPart<E> extends JaxbXmlPartAltChunkHost<E> {
	
	protected static Logger log = LoggerFactory.getLogger(DocumentPart.class);
	
	
	 
	
	protected CommentsPart commentsPart; 	
	protected DocumentSettingsPart documentSettingsPart;	
	protected EndnotesPart endNotesPart; 	
	protected FontTablePart fontTablePart; 
	protected ThemePart themePart;  
	protected FootnotesPart footnotesPart; 
	protected NumberingDefinitionsPart numberingDefinitionsPart; 	
	protected StyleDefinitionsPart styleDefinitionsPart; 	
	protected WebSettingsPart webSettingsPart;
	
	
	


	public boolean setPartShortcut(Part part) {
		
		if (part == null ){
			return false;
		} else {
			return setPartShortcut(part, part.getRelationshipType() );
		}
		
	}	
		
	public boolean setPartShortcut(Part part, String relationshipType) {
		
		
		
		
		
		
		
		
		
		if (relationshipType==null) {
			log.warn("trying to set part shortcut against a null relationship type.");
			return false;
		}
		
		if (relationshipType.equals(Namespaces.FONT_TABLE)) {
			fontTablePart = (FontTablePart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.THEME)) {
			themePart = (ThemePart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.STYLES)) {
			styleDefinitionsPart = (StyleDefinitionsPart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.WEB_SETTINGS)) {
			webSettingsPart = (WebSettingsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.SETTINGS)) {
			documentSettingsPart = (DocumentSettingsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.COMMENTS)) {
			commentsPart = (CommentsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.ENDNOTES)) {
			endNotesPart = (EndnotesPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.FOOTNOTES)) {
			footnotesPart = (FootnotesPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.NUMBERING)) {
			numberingDefinitionsPart = (NumberingDefinitionsPart)part;
			return true;	
		} else if (part instanceof ConditionsPart) {
			conditionsPart = ((ConditionsPart)part);
			return true;
		} else if (part instanceof QuestionsPart) {
			questionsPart = ((QuestionsPart)part);
			return true;
		} else if (part instanceof XPathsPart) {
			xPathsPart = ((XPathsPart)part);
			return true;
		} else if (part instanceof ComponentsPart) {
			componentsPart = ((ComponentsPart)part);
			return true;
		} else if (part instanceof BibliographyPart) {
			bibliographyPart = ((BibliographyPart)part);
			return true;
			
			
		} else {	
			return false;
		}
	}
	
	
	 
	
	
	
	public DocumentPart(PartName partName) throws InvalidFormatException {
		super(partName);
	}

	

	public CommentsPart getCommentsPart() {
		return commentsPart;
	}


	public DocumentSettingsPart getDocumentSettingsPart() {
		return documentSettingsPart;
	}
	
	
	public DocumentSettingsPart getDocumentSettingsPart(boolean createIfAbsent) throws InvalidFormatException {
		if (documentSettingsPart==null) {
			if (createIfAbsent) {
				documentSettingsPart = new DocumentSettingsPart();
				this.addTargetPart(documentSettingsPart);	
			} else {
				return null;
			}
		} 
		return documentSettingsPart;		
	}
	

	


	public EndnotesPart getEndNotesPart() {
		return endNotesPart;
	}
	
	
	public boolean hasEndnotesPart() {
		if (getEndNotesPart()==null) {
			return false;
		} else {
			
			
			CTEndnotes endnotes = getEndNotesPart().getJaxbElement();
			
			if (endnotes.getEndnote().size()<3) {
				
				
				
				return false;
			}
			return true;
		}
	}

	public FootnotesPart getFootnotesPart() {
		return footnotesPart;
	}
	
	public boolean hasFootnotesPart() {
		if (getFootnotesPart()==null) {
			return false;
		} else {
			return true;
		}
	}

	@Deprecated 
	public static Node getFootnote(WordprocessingMLPackage wmlPackage, String id) {	
		
		CTFootnotes footnotes = wmlPackage.getMainDocumentPart().getFootnotesPart().getJaxbElement();
		int pos = Integer.parseInt(id);
		
		
		CTFtnEdn ftn = (CTFtnEdn)footnotes.getFootnote().get(pos);
		Document d = XmlUtils.marshaltoW3CDomDocument( ftn,
				Context.jc, Namespaces.NS_WORD12, "footnote",  CTFtnEdn.class );
		log.debug("Footnote " + id + ": " + XmlUtils.w3CDomNodeToString(d));
		return d;
	}
	
	public FontTablePart getFontTablePart() {
		return fontTablePart;
	}





	





	public NumberingDefinitionsPart getNumberingDefinitionsPart() {
		return numberingDefinitionsPart;
	}


	public StyleDefinitionsPart getStyleDefinitionsPart() {
		return getStyleDefinitionsPart(false);
	}
	
	public StyleDefinitionsPart getStyleDefinitionsPart(boolean create) {
		if (styleDefinitionsPart==null
				&& create) {
			
			log.info("No StyleDefinitionsPart detected. Adding default part.");
			try {
				styleDefinitionsPart = new StyleDefinitionsPart();
				styleDefinitionsPart.unmarshalDefaultStyles();
				this.addTargetPart(styleDefinitionsPart); 			
				
			} catch (Exception e) {
				log.error(e.getMessage(), e);
			}
		}
		return styleDefinitionsPart;
	}

	public ThemePart getThemePart() {
		return themePart;
	}
	

	public WebSettingsPart getWebSettingsPart() {
		return webSettingsPart;
	}

	private ConditionsPart conditionsPart;
	public ConditionsPart getConditionsPart() {
		return conditionsPart;
	}




	private XPathsPart xPathsPart;
	public XPathsPart getXPathsPart() {
		return xPathsPart;
	}



	
	private QuestionsPart questionsPart;
	public QuestionsPart getQuestionsPart() {
		return questionsPart;
	}
	
	private ComponentsPart componentsPart;
	public ComponentsPart getComponentsPart() {
		return componentsPart;
	}
	
	private BibliographyPart bibliographyPart;
	public BibliographyPart getBibliographyPart() {
		return bibliographyPart;
	}
	
}

<code block>


package org.docx4j.openpackaging.packages;


import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.stream.StreamSource;

import org.docx4j.Docx4jProperties;
import org.docx4j.XmlUtils;
import org.docx4j.convert.out.flatOpcXml.FlatOpcXmlCreator;
import org.docx4j.dml.CTBlip;
import org.docx4j.fonts.IdentityPlusMapper;
import org.docx4j.fonts.Mapper;
import org.docx4j.jaxb.Context;
import org.docx4j.model.structure.DocumentModel;
import org.docx4j.model.structure.HeaderFooterPolicy;
import org.docx4j.model.structure.PageDimensions;
import org.docx4j.model.structure.PageSizePaper;
import org.docx4j.openpackaging.contenttype.ContentType;
import org.docx4j.openpackaging.contenttype.ContentTypeManager;
import org.docx4j.openpackaging.contenttype.ContentTypes;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.DocPropsCorePart;
import org.docx4j.openpackaging.parts.DocPropsCustomPart;
import org.docx4j.openpackaging.parts.DocPropsExtendedPart;
import org.docx4j.openpackaging.parts.JaxbXmlPart;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.WordprocessingML.DocumentSettingsPart;
import org.docx4j.openpackaging.parts.WordprocessingML.FontTablePart;
import org.docx4j.openpackaging.parts.WordprocessingML.GlossaryDocumentPart;
import org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart;
import org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.samples.ImageConvertEmbeddedToLinked.TraversalUtilBlipVisitor;
import org.docx4j.utils.CompoundTraversalUtilVisitorCallback;
import org.docx4j.utils.SingleTraversalUtilVisitorCallback;
import org.docx4j.utils.TraversalUtilVisitor;
import org.docx4j.wml.ContentAccessor;
import org.docx4j.wml.Document;
import org.docx4j.wml.P;
import org.docx4j.wml.R;
import org.docx4j.wml.SectPr;
import org.docx4j.wml.Styles;
import org.docx4j.wml.Tbl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;








public class WordprocessingMLPackage extends OpcPackage {
	
	
	
	
	
	

	
	
	protected static Logger log = LoggerFactory.getLogger(WordprocessingMLPackage.class);
		
	
	
	protected MainDocumentPart mainDoc;
	
	
	protected GlossaryDocumentPart glossaryDoc;
	
	private DocumentModel documentModel;
	public DocumentModel getDocumentModel() {
		if (documentModel==null) {
			documentModel = new DocumentModel(this);
		}
		return documentModel;
	}
	
	private HeaderFooterPolicy headerFooterPolicy;	
	@Deprecated	
	public HeaderFooterPolicy getHeaderFooterPolicy() {
		int last = getDocumentModel().getSections().size();
		if (last>0) {
			
			
			return getDocumentModel().getSections().get(last-1).getHeaderFooterPolicy();
		} else {
			log.error("Unexpected - zero sections?!");
			return null;
		}
	}
	
		
	public WordprocessingMLPackage() {
		super();
		setContentType(new ContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT));
	}
	
	public WordprocessingMLPackage(ContentTypeManager contentTypeManager) {
		super(contentTypeManager);
		setContentType(new ContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT));
	}
	
		
	public static WordprocessingMLPackage load(java.io.File docxFile) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(docxFile);
	}

		
	public static WordprocessingMLPackage load(InputStream is) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(is);
	}
	
	
	public boolean setPartShortcut(Part part, String relationshipType) {
		

		
		if (relationshipType.equals(Namespaces.PROPERTIES_CORE)) {
			docPropsCorePart = (DocPropsCorePart)part;
			log.debug("Set shortcut for docPropsCorePart");
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_EXTENDED)) {
			docPropsExtendedPart = (DocPropsExtendedPart)part;
			log.debug("Set shortcut for docPropsExtendedPart");
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_CUSTOM)) {
			docPropsCustomPart = (DocPropsCustomPart)part;
			log.debug("Set shortcut for docPropsCustomPart");
			return true;			
		} else if (relationshipType.equals(Namespaces.DOCUMENT)) {
			mainDoc = (MainDocumentPart)part;
			log.debug("Set shortcut for mainDoc");
			return true;
		} else {	
			return false;
		}
	}
	
	public MainDocumentPart getMainDocumentPart() {
		return mainDoc;
	}
	
    
        
    public void transform(Templates xslt,
			  Map<String, Object> transformParameters) throws Exception {

    	
    	
		FlatOpcXmlCreator worker = new FlatOpcXmlCreator(this);
		org.docx4j.xmlPackage.Package pkg = worker.get();
    	
		JAXBContext jc = Context.jcXmlPackage;
		Marshaller marshaller=jc.createMarshaller();
		org.w3c.dom.Document doc = org.docx4j.XmlUtils.neww3cDomDocument();
		marshaller.marshal(pkg, doc);
    			

		
		
		
		Unmarshaller u = jc.createUnmarshaller();
		u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());
		javax.xml.bind.util.JAXBResult result = new javax.xml.bind.util.JAXBResult(u );
		
		
		org.docx4j.XmlUtils.transform(doc, xslt, transformParameters, result);
		



		org.docx4j.xmlPackage.Package wmlPackageEl = (org.docx4j.xmlPackage.Package)XmlUtils.unwrap(result.getResult());
		
		org.docx4j.convert.in.FlatOpcXmlImporter xmlPackage = new org.docx4j.convert.in.FlatOpcXmlImporter( wmlPackageEl); 
		
		ContentTypeManager ctm = new ContentTypeManager();
		
		Part tmpDocPart = xmlPackage.getRawPart(ctm,  "/word/document.xml", null);
		Part tmpStylesPart = xmlPackage.getRawPart(ctm,  "/word/styles.xml", null);
		
		
		





		this.getMainDocumentPart().setJaxbElement(
				((JaxbXmlPart<Document>) tmpDocPart).getJaxbElement() );






		this.getMainDocumentPart().getStyleDefinitionsPart(true).setJaxbElement(
				((JaxbXmlPart<Styles>) tmpStylesPart).getJaxbElement() );
    	
    }
    
    @Deprecated
	
	
	
	
	
    public void filter( FilterSettings filterSettings ) throws Exception {

    	if (filterTemplate==null) { 
			Source xsltSource = new StreamSource(
				org.docx4j.utils.ResourceUtils.getResource(
						"org/docx4j/openpackaging/packages/filter.xslt"));
			filterTemplate = XmlUtils.getTransformerTemplate(xsltSource);
    	}
    	transform(filterTemplate, filterSettings.getSettings() );
    	
    }

    static Templates filterTemplate;
    


    public void setFontMapper(Mapper fm) throws Exception {
    	setFontMapper( fm,  true);
    }
    
    
    public void setFontMapper(Mapper fm, boolean populate) throws Exception {
    	log.debug("setFontMapper invoked");
    	
    	
    	
    	if (fm == null) {
    		throw new IllegalArgumentException("Font Substituter cannot be null.");
    	}
		fontMapper = fm;
		org.docx4j.wml.Fonts fonts = null;

		
		Set<String> fontsInUse = this.getMainDocumentPart().fontsInUse();
		

			
			
			
			FontTablePart fontTablePart= this.getMainDocumentPart().getFontTablePart();				
			if (fontTablePart==null) {
				log.warn("FontTable missing; creating default part.");
				fontTablePart= new org.docx4j.openpackaging.parts.WordprocessingML.FontTablePart();
				fontTablePart.unmarshalDefaultFonts();
			}
			
			fontTablePart.processEmbeddings(fontMapper);
			
			fonts = (org.docx4j.wml.Fonts)fontTablePart.getJaxbElement();

		
		if (populate) {
			fontMapper.populateFontMappings(fontsInUse, fonts);
		}
    	
    }

    public Mapper getFontMapper() {
    	if (fontMapper==null) {
    		fontMapper = new IdentityPlusMapper();
    		
    		try {
				setFontMapper(fontMapper);
			} catch (Exception e) {
				
				e.printStackTrace();
			}
    	}
		return fontMapper;
	}

	private Mapper fontMapper;
	
	

	
	public static WordprocessingMLPackage createPackage() throws InvalidFormatException {
		
		String papersize= Docx4jProperties.getProperties().getProperty("docx4j.PageSize", "A4");
		log.info("Using paper size: " + papersize);
		
		String landscapeString = Docx4jProperties.getProperties().getProperty("docx4j.PageOrientationLandscape", "false");
		boolean landscape= Boolean.parseBoolean(landscapeString);
		log.info("Landscape orientation: " + landscape);
		
		return createPackage(
				PageSizePaper.valueOf(papersize), landscape); 
	}
	
	
	public static WordprocessingMLPackage createPackage(PageSizePaper sz, boolean landscape ) throws InvalidFormatException {
		
				
		
		WordprocessingMLPackage wmlPack = new WordprocessingMLPackage();

		
		MainDocumentPart wordDocumentPart = new MainDocumentPart();		
		
		
		org.docx4j.wml.ObjectFactory factory = Context.getWmlObjectFactory();
		org.docx4j.wml.Body  body = factory.createBody();		
		org.docx4j.wml.Document wmlDocumentEl = factory.createDocument();
		
		wmlDocumentEl.setBody(body);
		
		
		PageDimensions page = new PageDimensions();
		page.setPgSize(sz, landscape);
		
		SectPr sectPr = factory.createSectPr();
		body.setSectPr(sectPr);
		sectPr.setPgSz(  page.getPgSz() );
		sectPr.setPgMar( page.getPgMar() );
				
		
		wordDocumentPart.setJaxbElement(wmlDocumentEl);
						
		
		
		wmlPack.addTargetPart(wordDocumentPart);
				
		
		Part stylesPart = new org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart();
		try {
			((org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart) stylesPart)
					.unmarshalDefaultStyles();
			
			
			
			wordDocumentPart.addTargetPart(stylesPart); 
			
		} catch (Exception e) {
			
			
			log.error(e.getMessage(), e);
		}
		
		
		
		DocPropsCorePart core = new DocPropsCorePart();
		org.docx4j.docProps.core.ObjectFactory coreFactory = new org.docx4j.docProps.core.ObjectFactory();
		core.setJaxbElement(coreFactory.createCoreProperties() );
		wmlPack.addTargetPart(core);
			
		
		DocPropsExtendedPart app = new DocPropsExtendedPart();
		org.docx4j.docProps.extended.ObjectFactory extFactory = new org.docx4j.docProps.extended.ObjectFactory();
		app.setJaxbElement(extFactory.createProperties() );
		wmlPack.addTargetPart(app);	
				
		
		return wmlPack;
		
	}

	
	
	public void protectRestrictFormatting(List<String> allowedStyleNames, boolean removedNotAllowedFormatting,
			boolean autoFormatOverride, boolean styleLockTheme, boolean styleLockQFSet) throws Docx4JException {
		
		protectRestrictFormatting(allowedStyleNames, removedNotAllowedFormatting,
				autoFormatOverride, styleLockTheme, styleLockQFSet,
				null, null);
	}

	
	public void protectRestrictFormatting(List<String> allowedStyleNames, boolean removedNotAllowedFormatting,
			boolean autoFormatOverride, boolean styleLockTheme, boolean styleLockQFSet,
			String password) throws Docx4JException {
		
		protectRestrictFormatting(allowedStyleNames, removedNotAllowedFormatting,
				autoFormatOverride, styleLockTheme, styleLockQFSet,
				password, HashAlgorithm.sha1);		
	}
	
	
	public void protectRestrictFormatting(List<String> allowedStyleNames, boolean removedNotAllowedFormatting,
			boolean autoFormatOverride, boolean styleLockTheme, boolean styleLockQFSet,
			String password, HashAlgorithm hashAlgo) throws Docx4JException {

		if (this.getMainDocumentPart()==null) 
			throw new Docx4JException("No MainDocumentPart in this WordprocessingMLPackage");
		
		if (this.getMainDocumentPart().getStyleDefinitionsPart()==null)  
			throw new Docx4JException("No StyleDefinitionsPart in this WordprocessingMLPackage");

		Set<String> stylesInUse = this.getMainDocumentPart().getStylesInUse();
		
		
		StyleDefinitionsPart sdp = this.getMainDocumentPart().getStyleDefinitionsPart();
		sdp.protectRestrictFormatting(allowedStyleNames, removedNotAllowedFormatting, stylesInUse);
		
			

		
		
		if (removedNotAllowedFormatting) {
			
			List<TraversalUtilVisitor> visitors = new ArrayList<TraversalUtilVisitor>();	
			visitors.add(new VisitorRemovePFormatting(sdp, allowedStyleNames));
			visitors.add(new VisitorRemoveRFormatting(sdp, allowedStyleNames));
			visitors.add(new VisitorRemoveTableFormatting(sdp, allowedStyleNames));
			
			CompoundTraversalUtilVisitorCallback compound = new CompoundTraversalUtilVisitorCallback(visitors);
			
			for( Part p : this.getParts().getParts().values()) {
				
				if (p instanceof ContentAccessor) {
					compound.walkJAXBElements(((ContentAccessor)p).getContent());								
				}
			}
			
		}
		
		
		DocumentSettingsPart documentSettingsPart = this.getMainDocumentPart().getDocumentSettingsPart(true);
		documentSettingsPart.protectRestrictFormatting(autoFormatOverride, styleLockTheme, styleLockQFSet, password, hashAlgo);
	}
	
	private static class VisitorRemovePFormatting extends TraversalUtilVisitor<P> {
		
		StyleDefinitionsPart sdp;		
		List<String> allowedStyleNames;
		
		VisitorRemovePFormatting(StyleDefinitionsPart sdp, List<String> allowedStyleNames) {
			this.sdp = sdp;
			this.allowedStyleNames = allowedStyleNames;
		}
		
		@Override
		public void apply(P p, Object parent, List<Object> siblings) {
			
			if (p.getPPr()!=null && p.getPPr().getPStyle()!=null && 
					!allowedStyleNames.contains(sdp.getNameForStyleID(p.getPPr().getPStyle().getVal()))) {
				p.getPPr().setPStyle(null);
			}
		}	
	}	

	private static class VisitorRemoveRFormatting extends TraversalUtilVisitor<R> {
		
		StyleDefinitionsPart sdp;		
		List<String> allowedStyleNames;
		
		VisitorRemoveRFormatting(StyleDefinitionsPart sdp, List<String> allowedStyleNames) {
			this.sdp = sdp;
			this.allowedStyleNames = allowedStyleNames;
		}
		
		@Override
		public void apply(R r, Object parent, List<Object> siblings) {
			
			if (r.getRPr()!=null && r.getRPr().getRStyle()!=null && 
					!allowedStyleNames.contains(sdp.getNameForStyleID(r.getRPr().getRStyle().getVal()))) {
				r.getRPr().setRStyle(null);
			}
		}	
	}	

	private static class VisitorRemoveTableFormatting extends TraversalUtilVisitor<Tbl> {
		
		StyleDefinitionsPart sdp;		
		List<String> allowedStyleNames;
		
		VisitorRemoveTableFormatting(StyleDefinitionsPart sdp, List<String> allowedStyleNames) {
			this.sdp = sdp;
			this.allowedStyleNames = allowedStyleNames;
		}
		
		@Override
		public void apply(Tbl table, Object parent, List<Object> siblings) {
			
			if (table.getTblPr()!=null && table.getTblPr().getTblStyle()!=null && 
					!allowedStyleNames.contains(sdp.getNameForStyleID(table.getTblPr().getTblStyle().getVal()))) {
				table.getTblPr().setTblStyle(null);
			}
		}	
	}	
	
	
	@Override
	protected void finalize() throws Throwable {
		try {
			FontTablePart ftp = this.getMainDocumentPart().getFontTablePart();
			if (ftp != null) {
				ftp.deleteEmbeddedFontTempFiles();
			}
		} finally {
			super.finalize();
		}
		
	}

	public static class FilterSettings {
		
		Boolean removeProofErrors = Boolean.FALSE;		
		public void setRemoveProofErrors(boolean val) {
			removeProofErrors = new Boolean(val);
		}

		Boolean removeContentControls = Boolean.FALSE;		
		public void setRemoveContentControls(boolean val) {
			removeContentControls = new Boolean(val);
		}
		
		Boolean removeRsids = Boolean.FALSE;		
		public void setRemoveRsids(boolean val) {
			removeRsids = new Boolean(val);
		}
		
		Boolean tidyForDocx4all = Boolean.FALSE;		
		public void setTidyForDocx4all(boolean val) {
			tidyForDocx4all = new Boolean(val);
		}
		
		
		public Map<String, Object> getSettings() {
			Map<String, Object> settings = new java.util.HashMap<String, Object>();
			
			settings.put("removeProofErrors", removeProofErrors);
			settings.put("removeContentControls", removeContentControls);
			settings.put("removeRsids", removeRsids);
			settings.put("tidyForDocx4all", tidyForDocx4all);
			
			return settings;
		}
		
		
	}


	
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;

import java.io.IOException;
import java.math.BigInteger;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import org.docx4j.XmlUtils;
import org.docx4j.jaxb.Context;
import org.docx4j.model.styles.BrokenStyleRemediator;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.utils.ResourceUtils;
import org.docx4j.wml.DocDefaults;
import org.docx4j.wml.HpsMeasure;
import org.docx4j.wml.PPr;
import org.docx4j.wml.PPrBase.Spacing;
import org.docx4j.wml.RPr;
import org.docx4j.wml.Style;
import org.docx4j.wml.Style.BasedOn;
import org.docx4j.wml.Styles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public final class StyleDefinitionsPart extends JaxbXmlPartXPathAware<Styles> {
	
	private static Logger log = LoggerFactory.getLogger(StyleDefinitionsPart.class);		
	
	public StyleDefinitionsPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}

	public StyleDefinitionsPart() throws InvalidFormatException {
		super(new PartName("/word/styles.xml"));
		init();
	}
	
	public void init() {
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.WORDPROCESSINGML_STYLES));

		
		setRelationshipType(Namespaces.STYLES);
	}
	
	
	private static java.util.Map<String, org.docx4j.wml.Style>  knownStyles = null;
	
	
	
	@Override
	public void setJaxbElement(Styles jaxbElement) {
		super.setJaxbElement(jaxbElement);
		
		styleDocDefaults=null;
	    defaultCharacterStyle = null;
	    defaultParagraphStyle = null;
	    defaultTableStyle = null;
	    css=null;
	}
	
    






















    
    
    public Object unmarshalDefaultStyles() throws JAXBException {
    	
    	


    	  
    		java.io.InputStream is = null;
			try {
				
				
				
				
				is = ResourceUtils.getResourceViaProperty("docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.DefaultStyles",
						"org/docx4j/openpackaging/parts/WordprocessingML/styles.xml");
				
					
					
				
			} catch (IOException e) {
				
				e.printStackTrace();
			}    		
    	
    	return unmarshal( is );    
    }
    
    private static void initKnownStyles() {



    	
		java.io.InputStream is = null;
		try {
			is = ResourceUtils.getResourceViaProperty("docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart.KnownStyles",
					"org/docx4j/openpackaging/parts/WordprocessingML/KnownStyles.xml");						
			
			JAXBContext jc = Context.jc;
			Unmarshaller u = jc.createUnmarshaller();			
			u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());

			org.docx4j.wml.Styles styles = (org.docx4j.wml.Styles)u.unmarshal( is );			
			
			knownStyles = new java.util.HashMap<String, org.docx4j.wml.Style>();
			
			for ( org.docx4j.wml.Style s : styles.getStyle() ) {				
				knownStyles.put(s.getStyleId(), s);				
			}
			
		} catch (Exception e) {
			
			e.printStackTrace();
		}    		
    	
		
    }

	
	public static java.util.Map<String, org.docx4j.wml.Style> getKnownStyles() {
		if (knownStyles==null) {
			initKnownStyles();
		}
		return knownStyles;
	}
    
	private Style styleDocDefaults;
	
	
    public void createVirtualStylesForDocDefaults() throws Docx4JException {
    	
    	if (styleDocDefaults!=null) return; 
    	
    	String ROOT_NAME = "DocDefaults";

    	
    	styleDocDefaults = getStyleById(this.getJaxbElement().getStyle(), ROOT_NAME);
    	if (styleDocDefaults==null) {

        	styleDocDefaults = Context.getWmlObjectFactory().createStyle();
        	styleDocDefaults.setStyleId(ROOT_NAME);
        	
    		this.getJaxbElement().getStyle().add(styleDocDefaults);
    		
    	} else {
    		
    		log.debug("Found existing style named " + ROOT_NAME);
    		log.debug(XmlUtils.marshaltoString(styleDocDefaults, true, true));
    		
        	
    		
    		
    		if (styleDocDefaults.getRPr()!=null) {
        		log.debug(".. reusing");
    			return;
    		} else {
        		log.debug(".. but no rPr, so re-creating");    			
    		}
    	}
    	
    	styleDocDefaults.setType("paragraph");
    	
		org.docx4j.wml.Style.Name n = Context.getWmlObjectFactory().createStyleName();
    	n.setVal(ROOT_NAME);
    	styleDocDefaults.setName(n);
    			
		
		DocDefaults docDefaults = this.getJaxbElement().getDocDefaults(); 		
		
		if (docDefaults == null) {
			log.info("No DocDefaults present");
			
			
			
			
			
			try {

				docDefaults = (DocDefaults) XmlUtils
						.unmarshalString(docDefaultsString);
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ docDefaultsString, e);
			}
		}

		
		PPr documentDefaultPPr;
		if (docDefaults.getPPrDefault() == null) {
			log.info("No PPrDefault present");
			try {
				documentDefaultPPr = (PPr) XmlUtils
						.unmarshalString(pPrDefaultsString);
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ pPrDefaultsString, e);
			}

		} else {
			documentDefaultPPr = docDefaults.getPPrDefault().getPPr();
			if (documentDefaultPPr==null) {
				documentDefaultPPr = Context.getWmlObjectFactory().createPPr();
			}
		}
		
		
		
		if (documentDefaultPPr.getSpacing()==null) {
			Spacing spacing = Context.getWmlObjectFactory().createPPrBaseSpacing();
			documentDefaultPPr.setSpacing(spacing);
			spacing.setBefore(BigInteger.ZERO);
			spacing.setAfter(BigInteger.ZERO);
			spacing.setLine(BigInteger.valueOf(240));
		}

		
		RPr documentDefaultRPr;
		if (docDefaults.getRPrDefault() == null) {
			log.info("No RPrDefault present");
			try {
				documentDefaultRPr = (RPr) XmlUtils
						.unmarshalString(rPrDefaultsString);
					
			} catch (JAXBException e) {
				throw new Docx4JException("Problem unmarshalling "
						+ rPrDefaultsString, e);
			}
		} else {
			documentDefaultRPr = docDefaults.getRPrDefault().getRPr();
			if (documentDefaultRPr==null) {
				documentDefaultRPr = Context.getWmlObjectFactory().createRPr();
			}
			
			


			if (documentDefaultRPr.getSz()==null) {
				HpsMeasure s10pt = Context.getWmlObjectFactory().createHpsMeasure();
				s10pt.setVal(BigInteger.valueOf(20));
				documentDefaultRPr.setSz(s10pt);
			}
			if (documentDefaultRPr.getSzCs()==null) {
				HpsMeasure s10pt = Context.getWmlObjectFactory().createHpsMeasure();
				s10pt.setVal(BigInteger.valueOf(20));
				documentDefaultRPr.setSzCs(s10pt);
			}
		}
    	
		styleDocDefaults.setPPr(documentDefaultPPr);
		styleDocDefaults.setRPr(documentDefaultRPr);
		
		
		Style normal = getDefaultParagraphStyle();
		if (normal==null) {
			log.info("No default paragraph style!!");
			normal = Context.getWmlObjectFactory().createStyle();
			normal.setType("paragraph");
			normal.setStyleId("Normal");
			
			n = Context.getWmlObjectFactory().createStyleName();
			n.setVal("Normal");
			normal.setName(n);
			this.getJaxbElement().getStyle().add(normal);	
			
			normal.setDefault(Boolean.TRUE); 
		}
		
		BasedOn based = Context.getWmlObjectFactory().createStyleBasedOn();
		based.setVal(ROOT_NAME);		
		normal.setBasedOn(based);
		
		log.debug("Set virtual style, id '" + styleDocDefaults.getStyleId() + "', name '"+ styleDocDefaults.getName().getVal() + "'");
		
		log.debug(XmlUtils.marshaltoString(styleDocDefaults, true, true));
		
		
    	
    }
    
    
    public Style getStyleById(String id) {
    	
		return getStyleById( this.getJaxbElement().getStyle(), id ); 				

    }

    
    private static Style getStyleById(List<Style> styles, String id) {
    	
		for ( org.docx4j.wml.Style s : styles ) {	
			
			if (s.getStyleId()==null) {
				BrokenStyleRemediator.remediate(s);
			}
			
			if( s.getStyleId()!=null
					&& s.getStyleId().equals(id) ) {
				return s;
			}
		}
    	return null;
    }
    
    private Style defaultCharacterStyle;
    public Style getDefaultCharacterStyle() {
    	
    	if (defaultCharacterStyle==null) {
    		defaultCharacterStyle = getDefaultStyle("character");
    	}
    	
    	
    	
    	if (defaultCharacterStyle==null) {
    		try {
				defaultCharacterStyle = (Style)XmlUtils.unmarshalString(DEFAULT_CHARACTER_STYLE_DEFAULT);
				this.getJaxbElement().getStyle().add(defaultCharacterStyle);
			} catch (JAXBException e) {
				e.printStackTrace();
			}
    	}
		return defaultCharacterStyle;
    }
    
    private final static String DEFAULT_CHARACTER_STYLE_DEFAULT = "<w:style w:type=\"character\" w:default=\"1\" w:styleId=\"DefaultParagraphFont\" " + Namespaces.W_NAMESPACE_DECLARATION + "><w:name w:val=\"Default Paragraph Font\" /></w:style>";
    
    
    
    private Style defaultParagraphStyle;
    
    public Style getDefaultParagraphStyle() {
    	
    	if (defaultParagraphStyle==null) {
    		defaultParagraphStyle = getDefaultStyle("paragraph");
    	}
    	
    	
    	
    	if (defaultParagraphStyle==null) {
    		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
    			if( s.getType().equals("paragraph")
    					&& s.getName()!=null
    					&& s.getName().getVal().equals("Default") ) {
    				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
    				defaultParagraphStyle=s;
    				break;
    			}
    		}    		
    	}
    	
    	if (defaultParagraphStyle==null) {
    		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
    			if( s.getType().equals("paragraph")
    					&& s.getStyleId().equals("style0") ) {
    				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
    				defaultParagraphStyle=s;
    				break;
    			}
    		}    		
    	}
    
    	
		return defaultParagraphStyle;
    }
    
    private Style defaultTableStyle;
    
    public Style getDefaultTableStyle() {
    	
    	if (defaultTableStyle==null) {
    		defaultTableStyle = getDefaultStyle("table");
    	}
		return defaultTableStyle;
    }
    
    private Style getDefaultStyle(String type) {
    	
		for ( org.docx4j.wml.Style s : this.getJaxbElement().getStyle() ) {				
			if( s.isDefault() && s.getType().equals(type)) {
				log.debug("Style with name " + s.getName().getVal() + ", id '" + s.getStyleId() + "' is default " + s.getType() + " style");
				return s;
			}
		}
		return null;
    }
    
    
	final static String wNamespaceDec = " xmlns:w=\"" + Namespaces.NS_WORD12 + "\""; 

	public final static String rPrDefaultsString = "<w:rPr" + wNamespaceDec + ">"
		
        
        + "<w:sz w:val=\"20\" />"  
        + "<w:szCs w:val=\"20\" />"
        + "<w:lang w:val=\"en-US\" w:eastAsia=\"en-US\" w:bidi=\"ar-SA\" />"
      + "</w:rPr>";
	public final static String pPrDefaultsString = "<w:pPr" + wNamespaceDec + ">"
	        + "<w:spacing w:after=\"200\" w:line=\"276\" w:lineRule=\"auto\" />"
	      + "</w:pPr>";
	public final static String docDefaultsString = "<w:docDefaults" + wNamespaceDec + ">"
	    + "<w:rPrDefault>"
	    + 	rPrDefaultsString
	    + "</w:rPrDefault>"
	    + "<w:pPrDefault>"
	    + 	pPrDefaultsString
	    + "</w:pPrDefault>"
	  + "</w:docDefaults>";
	

	
	private String css;
	public String getCss() {
		return css;
	}
	public void setCss(String css) {
		this.css = css;
	}
	
	
	public Style getLinkedStyle(String rStyleVal) {
		
		Style rStyle = getStyleById(rStyleVal);
		if (rStyle==null) {
			log.info("Couldn't find rStyle " + rStyleVal);
			return null;
		} else {
			
			Style.Link linkedStyle = rStyle.getLink();
			if (linkedStyle==null) {
				log.info("No linked style for rStyle " + rStyleVal);							
				return null;
			} else {
				String pStyleVal = linkedStyle.getVal();
				log.debug(rStyleVal + " is linked to style " + pStyleVal );
				Style pStyle = getStyleById(pStyleVal);
				
				if (pStyle==null) {
					log.info("Couldn't find linked pStyle " + pStyleVal 
							+ " for rStyle " + rStyleVal);		
				}
				return pStyle;
			}
		}
	}

	
    






}

<code block>




package org.docx4j.openpackaging.parts.WordprocessingML;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;

import org.docx4j.jaxb.Context;
import org.docx4j.jaxb.McIgnorableNamespaceDeclarator;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.JaxbXmlPartXPathAware;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.org.apache.poi.EncryptedDocumentException;
import org.docx4j.org.apache.poi.poifs.crypt.CryptoFunctions;
import org.docx4j.org.apache.poi.poifs.crypt.HashAlgorithm;
import org.docx4j.wml.BooleanDefaultTrue;
import org.docx4j.wml.CTCompat;
import org.docx4j.wml.CTCompatSetting;
import org.docx4j.wml.CTDocProtect;
import org.docx4j.wml.CTSettings;
import org.docx4j.wml.STAlgClass;
import org.docx4j.wml.STAlgType;
import org.docx4j.wml.STCryptProv;
import org.docx4j.wml.STDocProtect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public final class DocumentSettingsPart extends JaxbXmlPartXPathAware<CTSettings> { 
	
	private final static Logger log = LoggerFactory.getLogger(DocumentSettingsPart.class);
	
	
	
	public DocumentSettingsPart(PartName partName) throws InvalidFormatException {
		super(partName);
		init();
	}

	public DocumentSettingsPart() throws InvalidFormatException {
		super(new PartName("/word/settings.xml"));
		init();
	}
	
	public void init() {		
		
		
		setContentType(new  org.docx4j.openpackaging.contenttype.ContentType( 
				org.docx4j.openpackaging.contenttype.ContentTypes.WORDPROCESSINGML_SETTINGS));

		
		setRelationshipType(Namespaces.SETTINGS);
				
	}
	
	@Override
    protected void setMceIgnorable(McIgnorableNamespaceDeclarator namespacePrefixMapper) {

		

		boolean needW14 = false;
		if (this.jaxbElement.getDocId14()!=null) {
			needW14 = true;
		} else if (this.jaxbElement.getConflictMode() !=null) {
			needW14 = true;
		} else if (this.jaxbElement.getDiscardImageEditingData() !=null) {
			needW14 = true;
		} else if (this.jaxbElement.getDefaultImageDpi() !=null) {
			needW14 = true;
		}
		
		boolean needW15 = false;		
		if (this.jaxbElement.getChartTrackingRefBased()!=null) {
			needW15 = true;
		} else if (this.jaxbElement.getDocId15() !=null) {
			needW15 = true;
		}
		
		String mceIgnorableVal = "";
		if (needW14) {
			mceIgnorableVal = "w14";
		}
		
		if (needW15) {
			mceIgnorableVal += " w15";
		} 
		log.debug(mceIgnorableVal);
		
		this.jaxbElement.setIgnorable(mceIgnorableVal);
				
    }
	
	
	public CTCompatSetting getWordCompatSetting(String name) throws Docx4JException {
	
		CTCompat compat = this.getContents().getCompat();
		if (compat==null) {
			log.warn("No w:settings/w:compat element");
			return null;
		}
		
		CTCompatSetting theSetting = null;
		for (CTCompatSetting setting : compat.getCompatSetting() ) {
			if (setting.getUri().equals("http:
					&& setting.getName().equals(name)) {
				theSetting = setting;
				break;
			}
		}
		
		return theSetting;
	}

	public void setWordCompatSetting(String name, String val) throws Docx4JException {
		
		CTCompat compat = this.getContents().getCompat();
		if (compat==null) {
			log.debug("No w:settings/w:compat element; creating..");
		}
		compat = Context.getWmlObjectFactory().createCTCompat();
		this.getContents().setCompat(compat);
		
		CTCompatSetting theSetting = null;
		for (CTCompatSetting setting : compat.getCompatSetting() ) {
			if (setting.getUri().equals("http:
					&& setting.getName().equals(name)) {
				theSetting = setting;
				break;
			}
		}
		
		if (theSetting==null) {
			theSetting = Context.getWmlObjectFactory().createCTCompatSetting();
			theSetting.setUri("http:
			theSetting.setName(name);
			compat.getCompatSetting().add(theSetting);
		}
		theSetting.setVal(val);
	}
	
	
    
    public boolean isEnforcedWith(STDocProtect editValue) {
        CTDocProtect ctDocProtect = this.jaxbElement.getDocumentProtection();

        if (ctDocProtect == null) {
            return false;
        }

        return ctDocProtect.isEnforcement() && ctDocProtect.getEdit().equals(editValue);
    }
    

    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue) {
    	
    	setEnforcementEditValue(editValue, null, null);
    }

    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,
                                        String password) {

    	setEnforcementEditValue(editValue, password, HashAlgorithm.sha1);
    }
    
    
    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,
                                        String password, HashAlgorithm hashAlgo) {
    	
        safeGetDocumentProtection().setEnforcement(true);    	
        safeGetDocumentProtection().setEdit(editValue);
        
        
        
        if (editValue==STDocProtect.TRACKED_CHANGES) {
        	if (this.jaxbElement.getTrackRevisions()==null) {
        		this.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());
        	}
        }

        if (password == null) {
        	
            safeGetDocumentProtection().setCryptProviderType(null);
            safeGetDocumentProtection().setCryptAlgorithmClass(null);
            safeGetDocumentProtection().setCryptAlgorithmType(null);
            safeGetDocumentProtection().setCryptAlgorithmSid(null);
            safeGetDocumentProtection().setSalt(null);
            safeGetDocumentProtection().setCryptSpinCount(null);
            safeGetDocumentProtection().setHash(null);
            
            return;
            
        } else {
            final STCryptProv providerType;
            final int sid;
            switch (hashAlgo) {
                case md2:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 1;
                    break;
                case md4:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 2;
                    break;
                case md5:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 3;
                    break;
                case sha1:
                    providerType = STCryptProv.RSA_FULL;
                    sid = 4;
                    break;
                case sha256:
                    providerType = STCryptProv.RSA_AES;
                    sid = 12;
                    break;
                case sha384:
                    providerType = STCryptProv.RSA_AES;
                    sid = 13;
                    break;
                case sha512:
                    providerType = STCryptProv.RSA_AES;
                    sid = 14;
                    break;
                default:
                    throw new EncryptedDocumentException
                            ("Hash algorithm '" + hashAlgo + "' is not supported for document write protection.");
            }


            SecureRandom random = new SecureRandom();
            byte salt[] = random.generateSeed(16);

            
            
            int spinCount = 100000;

            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;

            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);
            
            
            
            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);

            safeGetDocumentProtection().setSalt(salt);
            safeGetDocumentProtection().setHash(hash);
            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));
            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);
            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);
            safeGetDocumentProtection().setCryptProviderType(providerType);
            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));
        }
    }

    
    public boolean validateProtectionPassword(String password) {
        BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();
        byte hash[] = safeGetDocumentProtection().getHash();
        byte salt[] = safeGetDocumentProtection().getSalt();
        BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();

        if (sid == null || hash == null || salt == null || spinCount == null) return false;

        HashAlgorithm hashAlgo;
        switch (sid.intValue()) {
            case 1:
                hashAlgo = HashAlgorithm.md2;
                break;
            case 2:
                hashAlgo = HashAlgorithm.md4;
                break;
            case 3:
                hashAlgo = HashAlgorithm.md5;
                break;
            case 4:
                hashAlgo = HashAlgorithm.sha1;
                break;
            case 12:
                hashAlgo = HashAlgorithm.sha256;
                break;
            case 13:
                hashAlgo = HashAlgorithm.sha384;
                break;
            case 14:
                hashAlgo = HashAlgorithm.sha512;
                break;
            default:
                return false;
        }

        String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);
        
        
        
        byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);

        return Arrays.equals(hash, hash2);
    }

    
    public void removeEnforcement() {

        safeGetDocumentProtection().setEnforcement(false);    	
    }	
    
    private CTDocProtect safeGetDocumentProtection() {
    	
    	if (this.getJaxbElement()==null) {
    		this.jaxbElement=new CTSettings();
    	}
    	
        CTDocProtect documentProtection = this.jaxbElement.getDocumentProtection();
        if (documentProtection == null) {
            documentProtection = Context.getWmlObjectFactory().createCTDocProtect();
            this.jaxbElement.setDocumentProtection(documentProtection);
        }
        return this.jaxbElement.getDocumentProtection();
    }    
}

<code block>


package org.docx4j.openpackaging.parts.WordprocessingML;


import org.docx4j.XmlUtils;
import org.docx4j.jaxb.Context;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
import org.docx4j.openpackaging.parts.JaxbXmlPartAltChunkHost;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.PartName;
import org.docx4j.openpackaging.parts.ThemePart;
import org.docx4j.openpackaging.parts.opendope.ComponentsPart;
import org.docx4j.openpackaging.parts.opendope.ConditionsPart;
import org.docx4j.openpackaging.parts.opendope.QuestionsPart;
import org.docx4j.openpackaging.parts.opendope.XPathsPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.wml.CTEndnotes;
import org.docx4j.wml.CTFootnotes;
import org.docx4j.wml.CTFtnEdn;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;



public abstract class DocumentPart<E> extends JaxbXmlPartAltChunkHost<E> {
	
	protected static Logger log = LoggerFactory.getLogger(DocumentPart.class);
	
	
	 
	
	protected CommentsPart commentsPart; 	
	protected DocumentSettingsPart documentSettingsPart;	
	protected EndnotesPart endNotesPart; 	
	protected FontTablePart fontTablePart; 
	protected ThemePart themePart;  
	protected FootnotesPart footnotesPart; 
	protected NumberingDefinitionsPart numberingDefinitionsPart; 	
	protected StyleDefinitionsPart styleDefinitionsPart; 	
	protected WebSettingsPart webSettingsPart;
	
	
	


	public boolean setPartShortcut(Part part) {
		
		if (part == null ){
			return false;
		} else {
			return setPartShortcut(part, part.getRelationshipType() );
		}
		
	}	
		
	public boolean setPartShortcut(Part part, String relationshipType) {
		
		
		
		
		
		
		
		
		
		if (relationshipType==null) {
			log.warn("trying to set part shortcut against a null relationship type.");
			return false;
		}
		
		if (relationshipType.equals(Namespaces.FONT_TABLE)) {
			fontTablePart = (FontTablePart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.THEME)) {
			themePart = (ThemePart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.STYLES)) {
			styleDefinitionsPart = (StyleDefinitionsPart)part;
			return true;			
		} else if (relationshipType.equals(Namespaces.WEB_SETTINGS)) {
			webSettingsPart = (WebSettingsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.SETTINGS)) {
			documentSettingsPart = (DocumentSettingsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.COMMENTS)) {
			commentsPart = (CommentsPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.ENDNOTES)) {
			endNotesPart = (EndnotesPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.FOOTNOTES)) {
			footnotesPart = (FootnotesPart)part;
			return true;	
		} else if (relationshipType.equals(Namespaces.NUMBERING)) {
			numberingDefinitionsPart = (NumberingDefinitionsPart)part;
			return true;	
		} else if (part instanceof ConditionsPart) {
			conditionsPart = ((ConditionsPart)part);
			return true;
		} else if (part instanceof QuestionsPart) {
			questionsPart = ((QuestionsPart)part);
			return true;
		} else if (part instanceof XPathsPart) {
			xPathsPart = ((XPathsPart)part);
			return true;
		} else if (part instanceof ComponentsPart) {
			componentsPart = ((ComponentsPart)part);
			return true;
		} else if (part instanceof BibliographyPart) {
			bibliographyPart = ((BibliographyPart)part);
			return true;
			
			
		} else {	
			return false;
		}
	}
	
	
	 
	
	
	
	public DocumentPart(PartName partName) throws InvalidFormatException {
		super(partName);
	}

	

	public CommentsPart getCommentsPart() {
		return commentsPart;
	}


	public DocumentSettingsPart getDocumentSettingsPart() {
		return documentSettingsPart;
	}


	public EndnotesPart getEndNotesPart() {
		return endNotesPart;
	}
	
	
	public boolean hasEndnotesPart() {
		if (getEndNotesPart()==null) {
			return false;
		} else {
			
			
			CTEndnotes endnotes = getEndNotesPart().getJaxbElement();
			
			if (endnotes.getEndnote().size()<3) {
				
				
				
				return false;
			}
			return true;
		}
	}

	public FootnotesPart getFootnotesPart() {
		return footnotesPart;
	}
	
	public boolean hasFootnotesPart() {
		if (getFootnotesPart()==null) {
			return false;
		} else {
			return true;
		}
	}

	@Deprecated 
	public static Node getFootnote(WordprocessingMLPackage wmlPackage, String id) {	
		
		CTFootnotes footnotes = wmlPackage.getMainDocumentPart().getFootnotesPart().getJaxbElement();
		int pos = Integer.parseInt(id);
		
		
		CTFtnEdn ftn = (CTFtnEdn)footnotes.getFootnote().get(pos);
		Document d = XmlUtils.marshaltoW3CDomDocument( ftn,
				Context.jc, Namespaces.NS_WORD12, "footnote",  CTFtnEdn.class );
		log.debug("Footnote " + id + ": " + XmlUtils.w3CDomNodeToString(d));
		return d;
	}
	
	public FontTablePart getFontTablePart() {
		return fontTablePart;
	}





	





	public NumberingDefinitionsPart getNumberingDefinitionsPart() {
		return numberingDefinitionsPart;
	}


	public StyleDefinitionsPart getStyleDefinitionsPart() {
		return getStyleDefinitionsPart(false);
	}
	
	public StyleDefinitionsPart getStyleDefinitionsPart(boolean create) {
		if (styleDefinitionsPart==null
				&& create) {
			
			log.info("No StyleDefinitionsPart detected. Adding default part.");
			try {
				styleDefinitionsPart = new StyleDefinitionsPart();
				styleDefinitionsPart.unmarshalDefaultStyles();
				this.addTargetPart(styleDefinitionsPart); 			
				
			} catch (Exception e) {
				log.error(e.getMessage(), e);
			}
		}
		return styleDefinitionsPart;
	}

	public ThemePart getThemePart() {
		return themePart;
	}
	

	public WebSettingsPart getWebSettingsPart() {
		return webSettingsPart;
	}

	private ConditionsPart conditionsPart;
	public ConditionsPart getConditionsPart() {
		return conditionsPart;
	}




	private XPathsPart xPathsPart;
	public XPathsPart getXPathsPart() {
		return xPathsPart;
	}



	
	private QuestionsPart questionsPart;
	public QuestionsPart getQuestionsPart() {
		return questionsPart;
	}
	
	private ComponentsPart componentsPart;
	public ComponentsPart getComponentsPart() {
		return componentsPart;
	}
	
	private BibliographyPart bibliographyPart;
	public BibliographyPart getBibliographyPart() {
		return bibliographyPart;
	}
	
}

<code block>


package org.docx4j.openpackaging.packages;


import java.io.InputStream;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.stream.StreamSource;

import org.docx4j.Docx4jProperties;
import org.docx4j.XmlUtils;
import org.docx4j.convert.out.flatOpcXml.FlatOpcXmlCreator;
import org.docx4j.fonts.IdentityPlusMapper;
import org.docx4j.fonts.Mapper;
import org.docx4j.jaxb.Context;
import org.docx4j.model.structure.DocumentModel;
import org.docx4j.model.structure.HeaderFooterPolicy;
import org.docx4j.model.structure.PageDimensions;
import org.docx4j.model.structure.PageSizePaper;
import org.docx4j.openpackaging.contenttype.ContentType;
import org.docx4j.openpackaging.contenttype.ContentTypeManager;
import org.docx4j.openpackaging.contenttype.ContentTypes;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.exceptions.InvalidFormatException;
import org.docx4j.openpackaging.parts.DocPropsCorePart;
import org.docx4j.openpackaging.parts.DocPropsCustomPart;
import org.docx4j.openpackaging.parts.DocPropsExtendedPart;
import org.docx4j.openpackaging.parts.JaxbXmlPart;
import org.docx4j.openpackaging.parts.Part;
import org.docx4j.openpackaging.parts.WordprocessingML.FontTablePart;
import org.docx4j.openpackaging.parts.WordprocessingML.GlossaryDocumentPart;
import org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart;
import org.docx4j.openpackaging.parts.relationships.Namespaces;
import org.docx4j.wml.Document;
import org.docx4j.wml.SectPr;
import org.docx4j.wml.Styles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;








public class WordprocessingMLPackage extends OpcPackage {
	
	
	
	
	
	

	
	
	protected static Logger log = LoggerFactory.getLogger(WordprocessingMLPackage.class);
		
	
	
	protected MainDocumentPart mainDoc;
	
	
	protected GlossaryDocumentPart glossaryDoc;
	
	private DocumentModel documentModel;
	public DocumentModel getDocumentModel() {
		if (documentModel==null) {
			documentModel = new DocumentModel(this);
		}
		return documentModel;
	}
	
	private HeaderFooterPolicy headerFooterPolicy;	
	@Deprecated	
	public HeaderFooterPolicy getHeaderFooterPolicy() {
		int last = getDocumentModel().getSections().size();
		if (last>0) {
			
			
			return getDocumentModel().getSections().get(last-1).getHeaderFooterPolicy();
		} else {
			log.error("Unexpected - zero sections?!");
			return null;
		}
	}
	
		
	public WordprocessingMLPackage() {
		super();
		setContentType(new ContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT));
	}
	
	public WordprocessingMLPackage(ContentTypeManager contentTypeManager) {
		super(contentTypeManager);
		setContentType(new ContentType(ContentTypes.WORDPROCESSINGML_DOCUMENT));
	}
	
		
	public static WordprocessingMLPackage load(java.io.File docxFile) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(docxFile);
	}

		
	public static WordprocessingMLPackage load(InputStream is) throws Docx4JException {
		
		return (WordprocessingMLPackage)OpcPackage.load(is);
	}
	
	
	public boolean setPartShortcut(Part part, String relationshipType) {
		

		
		if (relationshipType.equals(Namespaces.PROPERTIES_CORE)) {
			docPropsCorePart = (DocPropsCorePart)part;
			log.debug("Set shortcut for docPropsCorePart");
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_EXTENDED)) {
			docPropsExtendedPart = (DocPropsExtendedPart)part;
			log.debug("Set shortcut for docPropsExtendedPart");
			return true;			
		} else if (relationshipType.equals(Namespaces.PROPERTIES_CUSTOM)) {
			docPropsCustomPart = (DocPropsCustomPart)part;
			log.debug("Set shortcut for docPropsCustomPart");
			return true;			
		} else if (relationshipType.equals(Namespaces.DOCUMENT)) {
			mainDoc = (MainDocumentPart)part;
			log.debug("Set shortcut for mainDoc");
			return true;
		} else {	
			return false;
		}
	}
	
	public MainDocumentPart getMainDocumentPart() {
		return mainDoc;
	}
	
    
        
    public void transform(Templates xslt,
			  Map<String, Object> transformParameters) throws Exception {

    	
    	
		FlatOpcXmlCreator worker = new FlatOpcXmlCreator(this);
		org.docx4j.xmlPackage.Package pkg = worker.get();
    	
		JAXBContext jc = Context.jcXmlPackage;
		Marshaller marshaller=jc.createMarshaller();
		org.w3c.dom.Document doc = org.docx4j.XmlUtils.neww3cDomDocument();
		marshaller.marshal(pkg, doc);
    			

		
		
		
		Unmarshaller u = jc.createUnmarshaller();
		u.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler());
		javax.xml.bind.util.JAXBResult result = new javax.xml.bind.util.JAXBResult(u );
		
		
		org.docx4j.XmlUtils.transform(doc, xslt, transformParameters, result);
		



		org.docx4j.xmlPackage.Package wmlPackageEl = (org.docx4j.xmlPackage.Package)XmlUtils.unwrap(result.getResult());
		
		org.docx4j.convert.in.FlatOpcXmlImporter xmlPackage = new org.docx4j.convert.in.FlatOpcXmlImporter( wmlPackageEl); 
		
		ContentTypeManager ctm = new ContentTypeManager();
		
		Part tmpDocPart = xmlPackage.getRawPart(ctm,  "/word/document.xml", null);
		Part tmpStylesPart = xmlPackage.getRawPart(ctm,  "/word/styles.xml", null);
		
		
		





		this.getMainDocumentPart().setJaxbElement(
				((JaxbXmlPart<Document>) tmpDocPart).getJaxbElement() );






		this.getMainDocumentPart().getStyleDefinitionsPart(true).setJaxbElement(
				((JaxbXmlPart<Styles>) tmpStylesPart).getJaxbElement() );
    	
    }
    
    @Deprecated
	
	
	
	
	
    public void filter( FilterSettings filterSettings ) throws Exception {

    	if (filterTemplate==null) { 
			Source xsltSource = new StreamSource(
				org.docx4j.utils.ResourceUtils.getResource(
						"org/docx4j/openpackaging/packages/filter.xslt"));
			filterTemplate = XmlUtils.getTransformerTemplate(xsltSource);
    	}
    	transform(filterTemplate, filterSettings.getSettings() );
    	
    }

    static Templates filterTemplate;
    


    public void setFontMapper(Mapper fm) throws Exception {
    	setFontMapper( fm,  true);
    }
    
    
    public void setFontMapper(Mapper fm, boolean populate) throws Exception {
    	log.debug("setFontMapper invoked");
    	
    	
    	
    	if (fm == null) {
    		throw new IllegalArgumentException("Font Substituter cannot be null.");
    	}
		fontMapper = fm;
		org.docx4j.wml.Fonts fonts = null;

		
		Set<String> fontsInUse = this.getMainDocumentPart().fontsInUse();
		

			
			
			
			FontTablePart fontTablePart= this.getMainDocumentPart().getFontTablePart();				
			if (fontTablePart==null) {
				log.warn("FontTable missing; creating default part.");
				fontTablePart= new org.docx4j.openpackaging.parts.WordprocessingML.FontTablePart();
				fontTablePart.unmarshalDefaultFonts();
			}
			
			fontTablePart.processEmbeddings(fontMapper);
			
			fonts = (org.docx4j.wml.Fonts)fontTablePart.getJaxbElement();

		
		if (populate) {
			fontMapper.populateFontMappings(fontsInUse, fonts);
		}
    	
    }

    public Mapper getFontMapper() {
    	if (fontMapper==null) {
    		fontMapper = new IdentityPlusMapper();
    		
    		try {
				setFontMapper(fontMapper);
			} catch (Exception e) {
				
				e.printStackTrace();
			}
    	}
		return fontMapper;
	}

	private Mapper fontMapper;
	
	

	
	public static WordprocessingMLPackage createPackage() throws InvalidFormatException {
		
		String papersize= Docx4jProperties.getProperties().getProperty("docx4j.PageSize", "A4");
		log.info("Using paper size: " + papersize);
		
		String landscapeString = Docx4jProperties.getProperties().getProperty("docx4j.PageOrientationLandscape", "false");
		boolean landscape= Boolean.parseBoolean(landscapeString);
		log.info("Landscape orientation: " + landscape);
		
		return createPackage(
				PageSizePaper.valueOf(papersize), landscape); 
	}
	
	public static WordprocessingMLPackage createPackage(PageSizePaper sz, boolean landscape ) throws InvalidFormatException {
		
				
		
		WordprocessingMLPackage wmlPack = new WordprocessingMLPackage();

		
		MainDocumentPart wordDocumentPart = new MainDocumentPart();		
		
		
		org.docx4j.wml.ObjectFactory factory = Context.getWmlObjectFactory();
		org.docx4j.wml.Body  body = factory.createBody();		
		org.docx4j.wml.Document wmlDocumentEl = factory.createDocument();
		
		wmlDocumentEl.setBody(body);
		
		
		PageDimensions page = new PageDimensions();
		page.setPgSize(sz, landscape);
		
		SectPr sectPr = factory.createSectPr();
		body.setSectPr(sectPr);
		sectPr.setPgSz(  page.getPgSz() );
		sectPr.setPgMar( page.getPgMar() );
				
		
		wordDocumentPart.setJaxbElement(wmlDocumentEl);
						
		
		
		wmlPack.addTargetPart(wordDocumentPart);
				
		
		Part stylesPart = new org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart();
		try {
			((org.docx4j.openpackaging.parts.WordprocessingML.StyleDefinitionsPart) stylesPart)
					.unmarshalDefaultStyles();
			
			
			
			wordDocumentPart.addTargetPart(stylesPart); 
			
		} catch (Exception e) {
			
			
			log.error(e.getMessage(), e);
		}
		
		
		
		DocPropsCorePart core = new DocPropsCorePart();
		org.docx4j.docProps.core.ObjectFactory coreFactory = new org.docx4j.docProps.core.ObjectFactory();
		core.setJaxbElement(coreFactory.createCoreProperties() );
		wmlPack.addTargetPart(core);
			
		
		DocPropsExtendedPart app = new DocPropsExtendedPart();
		org.docx4j.docProps.extended.ObjectFactory extFactory = new org.docx4j.docProps.extended.ObjectFactory();
		app.setJaxbElement(extFactory.createProperties() );
		wmlPack.addTargetPart(app);	
				
		
		return wmlPack;
		
	}
	
	
	@Override
	protected void finalize() throws Throwable {
		try {
			FontTablePart ftp = this.getMainDocumentPart().getFontTablePart();
			if (ftp != null) {
				ftp.deleteEmbeddedFontTempFiles();
			}
		} finally {
			super.finalize();
		}
		
	}

	public static class FilterSettings {
		
		Boolean removeProofErrors = Boolean.FALSE;		
		public void setRemoveProofErrors(boolean val) {
			removeProofErrors = new Boolean(val);
		}

		Boolean removeContentControls = Boolean.FALSE;		
		public void setRemoveContentControls(boolean val) {
			removeContentControls = new Boolean(val);
		}
		
		Boolean removeRsids = Boolean.FALSE;		
		public void setRemoveRsids(boolean val) {
			removeRsids = new Boolean(val);
		}
		
		Boolean tidyForDocx4all = Boolean.FALSE;		
		public void setTidyForDocx4all(boolean val) {
			tidyForDocx4all = new Boolean(val);
		}
		
		
		public Map<String, Object> getSettings() {
			Map<String, Object> settings = new java.util.HashMap<String, Object>();
			
			settings.put("removeProofErrors", removeProofErrors);
			settings.put("removeContentControls", removeContentControls);
			settings.put("removeRsids", removeRsids);
			settings.put("tidyForDocx4all", tidyForDocx4all);
			
			return settings;
		}
		
		
	}


	
}
