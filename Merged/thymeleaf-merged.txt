
package org.thymeleaf.templateparser.markup;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;


public final class ThymeleafMarkupTemplateReader extends Reader {

    private final static char[] PROTOTYPE_ONLY_COMMENT_PREFIX = "<!--/*/".toCharArray();
    private final static char[] PROTOTYPE_ONLY_COMMENT_SUFFIX = "/*/-->".toCharArray();
    private final static char[] PARSER_LEVEL_COMMENT_PREFIX = "<!--/*".toCharArray();
    private final static char[] PARSER_LEVEL_COMMENT_SUFFIX = "*/-->".toCharArray();

    private final static int PREFIX_MAX_SIZE = Math.max(PROTOTYPE_ONLY_COMMENT_PREFIX.length, PARSER_LEVEL_COMMENT_PREFIX.length);
    private final static int SUFFIX_MAX_SIZE = Math.max(PROTOTYPE_ONLY_COMMENT_SUFFIX.length, PARSER_LEVEL_COMMENT_SUFFIX.length);
    private final static int STRUCTURE_MAX_SIZE = Math.max(PREFIX_MAX_SIZE, SUFFIX_MAX_SIZE);

    
    private final Reader reader;

    private char[] overflowBuffer = null;
    private int overflowBufferLen = 0;

    private boolean insideComment = false;
    private int discardFrom = -1;
    private int index = 0;


    public ThymeleafMarkupTemplateReader(final Reader reader) {
        super();
        this.reader = reader;
    }





    @Override
    public int read(final char[] cbuf, final int off, final int len) throws IOException {

        int read;



        if (this.overflowBufferLen == 0) {


            read = this.reader.read(cbuf, off, len);

        } else {

            if (this.overflowBufferLen >= len) {


                if ()

            }

            if (this.overflowBufferLen < len) {


                System.arraycopy(this.overflowBuffer, 0, cbuf, off, this.overflowBufferLen);
                read = this.overflowBufferLen;
                final int delegateRead =
                        this.reader.read(cbuf, (off + this.overflowBufferLen), (len - this.overflowBufferLen));
                if (delegateRead > 0) {
                    read += delegateRead;
                }
                this.overflowBufferLen = 0;

            } else {

                System.arraycopy(this.overflowBuffer, 0, cbuf, off, len);
                read = len;
                this.overflowBufferLen -= len;

                return read;

            }

        }




        if (read > 0) {

            int maxi = off + read;

            char c;
            int i = off;
            while (i < maxi) {

                c = cbuf[i++];

                if (this.index == 0 && c != '<' && c != '/' && c != '*') {


                    continue;
                }

                if (!this.insideComment) {

                    if (c == PROTOTYPE_ONLY_COMMENT_PREFIX[this.index]) {
                        this.index++;
                        if (this.index == PROTOTYPE_ONLY_COMMENT_PREFIX.length) {

                            if (i < maxi) {
                                System.arraycopy(cbuf, i, cbuf, i - PROTOTYPE_ONLY_COMMENT_PREFIX.length, (maxi - i));
                            }
                            this.insideComment = true;
                            this.index = 0;
                            read -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                            maxi -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                            i -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                        }
                    } else if (this.index == PARSER_LEVEL_COMMENT_PREFIX.length){



                        this.discardFrom = ((i - 1) - PARSER_LEVEL_COMMENT_PREFIX.length);
                        this.insideComment = true;
                        this.index = 0;
                        i--; 
                    } else {
                        this.index = 0;
                    }

                } else {

                    if (this.discardFrom < 0 && c == PROTOTYPE_ONLY_COMMENT_SUFFIX[this.index]) {
                        this.index++;
                        if (this.index == PROTOTYPE_ONLY_COMMENT_SUFFIX.length) {

                            if (i < maxi) {
                                System.arraycopy(cbuf, i, cbuf, i - PROTOTYPE_ONLY_COMMENT_SUFFIX.length, (maxi - i));
                            }
                            this.insideComment = false;
                            this.index = 0;
                            read -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                            maxi -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                            i -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                        }
                    } else if (this.discardFrom >= 0 && c == PARSER_LEVEL_COMMENT_SUFFIX[this.index]) {
                        if (this.index == 0 && (i - 2 >= off)) {

                            final char cprev = cbuf[i - 2];
                            if (cprev == PROTOTYPE_ONLY_COMMENT_SUFFIX[0]) {

                                continue;
                            }
                        }
                        this.index++;
                        if (this.index == PARSER_LEVEL_COMMENT_SUFFIX.length) {

                            System.arraycopy(cbuf, i, cbuf, this.discardFrom, (maxi - i));
                            read -= (i - this.discardFrom);
                            maxi -= (i - this.discardFrom);
                            i = this.discardFrom;
                            this.discardFrom = -1;
                            this.insideComment = false;
                            this.index = 0;
                        }
                    } else {
                        this.index = 0;
                    }

                }

            }



            final int shouldDiscardFrom = (this.insideComment && this.discardFrom >= 0 ? this.discardFrom : -1);



            if (this.index > 0) {



                if (this.overflowBuffer == null) {

                    this.overflowBuffer = new char[STRUCTURE_MAX_SIZE];
                }


                this.overflowBufferLen = this.index;
                System.arraycopy(cbuf, maxi - this.overflowBufferLen, this.overflowBuffer, 0, this.overflowBufferLen);
                read -= this.overflowBufferLen;
                maxi -= this.overflowBufferLen;



                while (this.overflowBufferLen < this.overflowBuffer.length) {
                    final int overflowRead =
                            this.reader.read(this.overflowBuffer, this.overflowBufferLen, (this.overflowBuffer.length - this.overflowBufferLen));
                    if (overflowRead < 0) {

                        break;
                    } else {
                        this.overflowBufferLen += overflowRead;
                    }
                }



                if (!this.insideComment) {

                    if (isArrayEquals(PROTOTYPE_ONLY_COMMENT_PREFIX, this.overflowBuffer, 0, Math.min(this.overflowBufferLen, PROTOTYPE_ONLY_COMMENT_PREFIX.length))) {



                        this.insideComment = true;
                        this.overflowBufferLen -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                        if (this.overflowBufferLen > 0) {
                            System.arraycopy(this.overflowBuffer, PROTOTYPE_ONLY_COMMENT_PREFIX.length, this.overflowBuffer, 0, this.overflowBufferLen);
                        }

                    } else if (isArrayEquals(PARSER_LEVEL_COMMENT_PREFIX, this.overflowBuffer, 0, Math.min(this.overflowBufferLen, PARSER_LEVEL_COMMENT_PREFIX.length))) {





                        this.insideComment = true;
                        this.overflowBufferLen -= PARSER_LEVEL_COMMENT_PREFIX.length;
                        if (this.overflowBufferLen > 0) {
                            System.arraycopy(this.overflowBuffer, PARSER_LEVEL_COMMENT_PREFIX.length, this.overflowBuffer, 0, this.overflowBufferLen);
                        }
                        this.discardFrom = 0;

                    }

                } else {

                    if (this.discardFrom < 0 && isArrayEquals(PROTOTYPE_ONLY_COMMENT_SUFFIX, this.overflowBuffer, 0, Math.min(this.overflowBufferLen, PROTOTYPE_ONLY_COMMENT_SUFFIX.length))) {



                        this.insideComment = false;
                        this.overflowBufferLen -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                        if (this.overflowBufferLen > 0) {
                            System.arraycopy(this.overflowBuffer, PROTOTYPE_ONLY_COMMENT_SUFFIX.length, this.overflowBuffer, 0, this.overflowBufferLen);
                        }

                    } else if (this.discardFrom >= 0 && isArrayEquals(PARSER_LEVEL_COMMENT_SUFFIX, this.overflowBuffer, 0, Math.min(this.overflowBufferLen, PARSER_LEVEL_COMMENT_SUFFIX.length))) {




                        this.insideComment = false;
                        this.discardFrom = -1;
                        this.overflowBufferLen -= PARSER_LEVEL_COMMENT_SUFFIX.length;
                        if (this.overflowBufferLen > 0) {
                            System.arraycopy(this.overflowBuffer, PARSER_LEVEL_COMMENT_SUFFIX.length, this.overflowBuffer, 0, this.overflowBufferLen);
                        }

                    }

                }

                this.index = 0;

            }



            if (shouldDiscardFrom >= 0) {
                read -= (maxi - shouldDiscardFrom);
            }

        }

        return read;

    }


    private static boolean isArrayEquals(final char[] target, final char[] array, final int offset, final int len) {
        if (array.length == len && offset == 0) {
            return Arrays.equals(target, array);
        }
        if (target.length != len) {
            return false;
        }
        int n = target.length;
        while (n-- != 0) {
            if (target[n] != array[offset + n]) {
                return false;
            }
        }
        return true;
    }



    @Override
    public void close() throws IOException {
        this.reader.close();
    }




}

<code block>

package org.thymeleaf.templateparser.markup;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;


public final class ThymeleafMarkupTemplateReader extends Reader {

    private final static char[] PROTOTYPE_ONLY_COMMENT_PREFIX = "<!--/*/".toCharArray();
    private final static char[] PROTOTYPE_ONLY_COMMENT_SUFFIX = "/*/-->".toCharArray();
    private final static char[] PARSER_LEVEL_COMMENT_PREFIX = "<!--/*".toCharArray();
    private final static char[] PARSER_LEVEL_COMMENT_SUFFIX = "*/-->".toCharArray();

    private final static int PREFIX_MAX_SIZE = Math.max(PROTOTYPE_ONLY_COMMENT_PREFIX.length, PARSER_LEVEL_COMMENT_PREFIX.length);
    private final static int SUFFIX_MAX_SIZE = Math.max(PROTOTYPE_ONLY_COMMENT_SUFFIX.length, PARSER_LEVEL_COMMENT_SUFFIX.length);
    private final static int STRUCTURE_MAX_SIZE = Math.max(PREFIX_MAX_SIZE, SUFFIX_MAX_SIZE);


    private final Reader reader;

    private boolean inputClosed = false;

    private char[] overflowBuffer = null;
    private int overflowBufferLen = 0;

    private boolean insideComment = false;
    private int discardFrom = -1;
    private int index = 0;


    public ThymeleafMarkupTemplateReader(final Reader reader) {
        super();
        this.reader = reader;
    }





    @Override
    public int read(final char[] cbuf, final int off, final int len) throws IOException {

        int read;



        if (this.overflowBufferLen == 0) {


            read = this.reader.read(cbuf, off, len);
            this.inputClosed = (read < 0);

        } else {

            if (this.overflowBufferLen >= len) {




            }

            if (this.overflowBufferLen < len) {


                System.arraycopy(this.overflowBuffer, 0, cbuf, off, this.overflowBufferLen);
                read = this.overflowBufferLen;
                final int delegateRead =
                        this.reader.read(cbuf, (off + this.overflowBufferLen), (len - this.overflowBufferLen));
                if (delegateRead > 0) {
                    read += delegateRead;
                }
                this.inputClosed = (delegateRead < 0);
                this.overflowBufferLen = 0;

            } else {

                System.arraycopy(this.overflowBuffer, 0, cbuf, off, len);
                read = len;
                this.overflowBufferLen -= len;

                return read;

            }

        }


        if (read == 0) {
            return 0;
        }



        read = processReadBuffer(cbuf, off, read);
        if (this.index == 0 && (!this.insideComment || this.discardFrom < 0)) {
            return read;
        }



        final int shouldDiscardFrom = (this.insideComment && this.discardFrom >= 0 ? this.discardFrom : -1);



        if (this.index > 0) {




            if (this.overflowBuffer == null) {

                this.overflowBuffer = new char[STRUCTURE_MAX_SIZE];
            }
            this.overflowBufferLen = this.index;
            System.arraycopy(cbuf, (off + read) - this.overflowBufferLen, this.overflowBuffer, 0, this.overflowBufferLen);
            read -= this.index;



            fillUpOverflow();



            final int overflowRead = processReadBuffer(this.overflowBuffer, 0, this.overflowBufferLen);






            if (overflowRead < this.overflowBufferLen) {


                if (this.index > 0) {



                } else if (this.discardFrom >= 0) {

                }


            }


            this.index = 0;

        }



        if (shouldDiscardFrom >= 0) {
            read -= ((off + read) - shouldDiscardFrom);
        }

        return read;

    }




    private int processReadBuffer(final char[] buffer, final int off, final int len) {

        if (len == 0) {
            return 0;
        }

        int read = len;
        int maxi = off + len;

        boolean foundPrototypeOnlyPrefix = false;
        boolean foundParserLevelPrefix = false;

        char c;
        int i = off;
        while (i < maxi) {

            c = buffer[i++];

            if (this.index == 0 && c != '<' && c != '/' && c != '*') {


                continue;
            }

            if (!this.insideComment) {

                if (c == PROTOTYPE_ONLY_COMMENT_PREFIX[this.index]) {
                    this.index++;
                    if (this.index == PROTOTYPE_ONLY_COMMENT_PREFIX.length) {
                        foundPrototypeOnlyPrefix = true;
                    } else if (this.index == PARSER_LEVEL_COMMENT_PREFIX.length && i >= maxi && this.inputClosed) {

                        foundParserLevelPrefix = true;
                    }
                } else if (this.index == PARSER_LEVEL_COMMENT_PREFIX.length) {
                    foundParserLevelPrefix = true;
                    i--; 
                }

                if (foundPrototypeOnlyPrefix) {

                    if (i < maxi) {
                        System.arraycopy(buffer, i, buffer, i - PROTOTYPE_ONLY_COMMENT_PREFIX.length, (maxi - i));
                    }
                    this.insideComment = true;
                    this.index = 0;
                    read -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                    maxi -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                    i -= PROTOTYPE_ONLY_COMMENT_PREFIX.length;
                    foundPrototypeOnlyPrefix = false;
                } else if (foundParserLevelPrefix) {





                    System.arraycopy(buffer, i, buffer, i - PARSER_LEVEL_COMMENT_PREFIX.length, (maxi - i));
                    this.insideComment = true;
                    this.index = 0;
                    read -= PARSER_LEVEL_COMMENT_PREFIX.length;
                    maxi -= PARSER_LEVEL_COMMENT_PREFIX.length;
                    i -= PARSER_LEVEL_COMMENT_PREFIX.length ;
                    this.discardFrom = i - PARSER_LEVEL_COMMENT_PREFIX.length;
                    foundParserLevelPrefix = false;
                } else {
                    this.index = 0;
                }

            } else {

                if (this.discardFrom < 0 && c == PROTOTYPE_ONLY_COMMENT_SUFFIX[this.index]) {
                    this.index++;
                    if (this.index == PROTOTYPE_ONLY_COMMENT_SUFFIX.length) {

                        if (i < maxi) {
                            System.arraycopy(buffer, i, buffer, i - PROTOTYPE_ONLY_COMMENT_SUFFIX.length, (maxi - i));
                        }
                        this.insideComment = false;
                        this.index = 0;
                        read -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                        maxi -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                        i -= PROTOTYPE_ONLY_COMMENT_SUFFIX.length;
                    }
                } else if (this.discardFrom >= 0 && c == PARSER_LEVEL_COMMENT_SUFFIX[this.index]) {
                    if (this.index == 0 && (i - 2 >= off) && (i - 2 >= this.discardFrom)) {

                        if (buffer[i - 2] == PROTOTYPE_ONLY_COMMENT_SUFFIX[0]) {

                            continue;
                        }
                    }
                    this.index++;
                    if (this.index == PARSER_LEVEL_COMMENT_SUFFIX.length) {

                        if (i < maxi) {
                            System.arraycopy(buffer, i, buffer, this.discardFrom, (maxi - i));
                        }
                        this.insideComment = false;
                        this.index = 0;
                        read -= (i - this.discardFrom);
                        maxi -= (i - this.discardFrom);
                        i = this.discardFrom;
                        this.discardFrom = -1;
                    }
                } else {
                    this.index = 0;
                }

            }

        }

        return read;

    }



    private void fillUpOverflow() throws IOException {
        while (this.overflowBufferLen < this.overflowBuffer.length) {
            final int overflowRead =
                    this.reader.read(this.overflowBuffer, this.overflowBufferLen, (this.overflowBuffer.length - this.overflowBufferLen));
            if (overflowRead < 0) {

                this.inputClosed = true;
                break;
            } else {
                this.overflowBufferLen += overflowRead;
            }
        }
    }





    private static boolean isArrayEquals(final char[] target, final char[] array, final int offset, final int len) {
        if (array.length == len && offset == 0) {
            return Arrays.equals(target, array);
        }
        if (target.length != len) {
            return false;
        }
        int n = target.length;
        while (n-- != 0) {
            if (target[n] != array[offset + n]) {
                return false;
            }
        }
        return true;
    }



    @Override
    public void close() throws IOException {
        this.reader.close();
    }




}

<code block>

package org.thymeleaf.templateparser.reader;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;


abstract class BlockAwareReader extends Reader {

    public enum BlockAction { DISCARD_ALL, DISCARD_CONTAINER }


    private final Reader reader;
    private final BlockAction action;
    private final char[] prefix;
    private final char[] suffix;

    
    private char[] overflowBuffer = null;
    private int overflowBufferLen = 0;

    private boolean insideComment = false;
    private int index = 0;
    private int discardFrom = -1;


    protected BlockAwareReader(final Reader reader, final BlockAction action, final char[] prefix, final char[] suffix) {
        super();
        this.reader = reader;
        this.action = action;
        this.prefix = prefix;
        this.suffix = suffix;
    }





    @Override
    public int read(final char[] cbuf, final int off, final int len) throws IOException {


        int read = readBytes(cbuf, off, len);
        if (read <= 0) {
            return read;
        }



        this.discardFrom = (this.discardFrom < 0? this.discardFrom : Math.max(off, this.discardFrom));

        int maxi = off + read;

        char c;
        int i = off;
        while (i < maxi) { 

            c = cbuf[i++];

            if (this.index == 0 && c != this.prefix[0] && c != this.suffix[0]) {

                continue;
            }

            if (!this.insideComment) {

                if (c == this.prefix[this.index]) {
                    this.index++;
                    if (this.index == this.prefix.length) {

                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.prefix.length, (maxi - i));
                        }
                        this.insideComment = true;
                        this.index = 0;
                        read -= this.prefix.length;
                        maxi -= this.prefix.length;
                        i -= this.prefix.length;
                        this.discardFrom = (this.action == BlockAction.DISCARD_ALL? i : -1);
                    }
                } else if (c == this.prefix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            } else {

                if (c == this.suffix[this.index]) {
                    this.index++;
                    if (this.index == this.suffix.length) {


                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.suffix.length, (maxi - i));
                        }
                        this.insideComment = false;
                        this.index = 0;
                        read -= this.suffix.length;
                        maxi -= this.suffix.length;
                        i -= this.suffix.length;



                        if (this.discardFrom >= 0) {
                            if (i < maxi) {
                                System.arraycopy(cbuf, i, cbuf, this.discardFrom, (maxi - i));
                            }
                            read -= (i - this.discardFrom);
                            maxi -= (i - this.discardFrom);
                            i = this.discardFrom;
                            this.discardFrom = -1;
                        }

                    }
                } else if (c == this.suffix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            }

        }


        if (this.index > 0) {



            overflowLastBytes(cbuf, maxi, this.index);
            read -= this.index;
            maxi -= this.index;



            if (!this.insideComment) {

                int overflowRead = 0;
                while (overflowRead >= 0 && this.overflowBufferLen < this.prefix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.prefix[this.overflowBufferLen - 1]) {
                    overflowRead = readBytes(this.overflowBuffer, this.overflowBufferLen++, 1); 
                }


                if (this.overflowBufferLen == this.prefix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.prefix[this.overflowBufferLen - 1]) {
                    this.insideComment = true;

                    this.overflowBufferLen = 0;
                    this.index = 0;
                }

            } else {

                int overflowRead = 0;
                while (overflowRead >= 0 && this.overflowBufferLen < this.suffix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.suffix[this.overflowBufferLen - 1]) {
                    overflowRead = readBytes(this.overflowBuffer, this.overflowBufferLen++, 1); 
                }


                if (this.overflowBufferLen == this.suffix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.suffix[this.overflowBufferLen - 1]) {
                    this.insideComment = false;

                    this.overflowBufferLen = 0;
                    this.index = 0;
                }

            }

            if (this.overflowBufferLen > 0) {




                System.arraycopy(this.overflowBuffer, 0, cbuf, maxi, this.index);
                read += this.index;
                maxi += this.index;
                System.arraycopy(this.overflowBuffer, this.index, this.overflowBuffer, 0, (this.overflowBufferLen - this.index));
                this.overflowBufferLen -= this.index;
                this.index = 0;
            }

        }


        if (this.discardFrom >= 0) {
            read -= (maxi - this.discardFrom);
            this.discardFrom = 0;
        }

        this.discardFrom = (this.insideComment && this.action == BlockAction.DISCARD_ALL? 0 : -1);

        return read;

    }




    private int readBytes(final char[] buffer, final int off, final int len) throws IOException {

        if (len == 0) {
            return 0;
        }

        if (this.overflowBufferLen == 0) {
            return this.reader.read(buffer, off, len);
        }

        if (buffer == this.overflowBuffer && this.overflowBufferLen > 1) {


            throw new IllegalStateException(
                    "Cannot read bytes: trying to write to overflow buffer, when the overflow buffer is not empty (or size 1) yet!");
        }

        if (this.overflowBufferLen <= len) {


            System.arraycopy(this.overflowBuffer, 0, buffer, off, this.overflowBufferLen);
            int read = this.overflowBufferLen;
            this.overflowBufferLen = 0;

            if (read < len) {
                final int delegateRead = this.reader.read(buffer, (off + read), (len - read));
                if (delegateRead > 0) {
                    read += delegateRead;
                }
            }

            return read;

        }



        System.arraycopy(this.overflowBuffer, 0, buffer, off, len);
        if (len < this.overflowBufferLen) {
            System.arraycopy(this.overflowBuffer, len, this.overflowBuffer, 0, (this.overflowBufferLen - len));
        }
        this.overflowBufferLen -= len;
        return len;

    }




    private void overflowLastBytes(final char[] buffer, final int maxi, final int overflowCount) {
        if (this.overflowBuffer == null) {
            this.overflowBuffer = new char[Math.max(this.prefix.length, this.suffix.length)];
        }
        if (this.overflowBufferLen > 0) {
            System.arraycopy(this.overflowBuffer, 0, this.overflowBuffer, overflowCount, this.overflowBufferLen);
        }
        System.arraycopy(buffer, maxi - overflowCount, this.overflowBuffer, 0, overflowCount);
        this.overflowBufferLen += overflowCount;
    }




    private static boolean isArrayEquals(final char[] target, final char[] array, final int offset, final int len) {
        if (array.length == len && offset == 0) {
            return Arrays.equals(target, array);
        }
        if (target.length != len) {
            return false;
        }
        int n = target.length;
        while (n-- != 0) {
            if (target[n] != array[offset + n]) {
                return false;
            }
        }
        return true;
    }



    @Override
    public void close() throws IOException {
        this.reader.close();
    }




}

<code block>

package org.thymeleaf.templateparser.reader;

import java.io.Reader;


public final class PrototypeOnlyCommentMarkupReader extends BlockAwareReader {

    private final static char[] PREFIX = "<!--/*/".toCharArray();
    private final static char[] SUFFIX = "/*/-->".toCharArray();


    public PrototypeOnlyCommentMarkupReader(final Reader reader) {
        super(reader, BlockAwareReader.BlockAction.DISCARD_CONTAINER, PREFIX, SUFFIX);
    }

}

<code block>

package org.thymeleaf.templateparser.reader;

import java.io.Reader;


public final class ParserLevelCommentMarkupReader extends BlockAwareReader {

    private final static char[] PREFIX = "<!--/*".toCharArray();
    private final static char[] SUFFIX = "*/-->".toCharArray();


    public ParserLevelCommentMarkupReader(final Reader reader) {
        super(reader, BlockAction.DISCARD_ALL, PREFIX, SUFFIX);
    }

}

<code block>

package org.thymeleaf.templateparser.reader;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;


abstract class BlockAwareReader extends Reader {

    public enum BlockAction { DISCARD_ALL, DISCARD_CONTAINER }


    private final Reader reader;
    private final BlockAction action;
    private final char[] prefix;
    private final char[] suffix;

    
    private char[] overflowBuffer = null;
    private int overflowBufferLen = 0;

    private boolean insideComment = false;
    private int index = 0;
    private int discardFrom = -1;


    protected BlockAwareReader(final Reader reader, final BlockAction action, final char[] prefix, final char[] suffix) {
        super();
        this.reader = reader;
        this.action = action;
        this.prefix = prefix;
        this.suffix = suffix;
    }





    @Override
    public int read(final char[] cbuf, final int off, final int len) throws IOException {


        int read = readBytes(cbuf, off, len);
        if (read <= 0) {
            return read;
        }



        this.discardFrom = (this.discardFrom < 0? this.discardFrom : Math.max(off, this.discardFrom));

        int maxi = off + read;

        char c;
        int i = off;
        while (i < maxi) { 

            c = cbuf[i++];

            if (this.index == 0 && c != this.prefix[0] && c != this.suffix[0]) {

                continue;
            }

            if (!this.insideComment) {

                if (c == this.prefix[this.index]) {
                    this.index++;
                    if (this.index == this.prefix.length) {

                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.prefix.length, (maxi - i));
                        }
                        this.insideComment = true;
                        this.index = 0;
                        read -= this.prefix.length;
                        maxi -= this.prefix.length;
                        i -= this.prefix.length;
                        this.discardFrom = (this.action == BlockAction.DISCARD_ALL? i : -1);
                    }
                } else if (c == this.prefix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            } else {

                if (c == this.suffix[this.index]) {
                    this.index++;
                    if (this.index == this.suffix.length) {


                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.suffix.length, (maxi - i));
                        }
                        this.insideComment = false;
                        this.index = 0;
                        read -= this.suffix.length;
                        maxi -= this.suffix.length;
                        i -= this.suffix.length;



                        if (this.discardFrom >= 0) {
                            if (i < maxi) {
                                System.arraycopy(cbuf, i, cbuf, this.discardFrom, (maxi - i));
                            }
                            read -= (i - this.discardFrom);
                            maxi -= (i - this.discardFrom);
                            i = this.discardFrom;
                            this.discardFrom = -1;
                        }

                    }
                } else if (c == this.suffix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            }

        }


        if (this.index > 0) {



            overflowLastBytes(cbuf, maxi, this.index);
            read -= this.index;
            maxi -= this.index;



            if (!this.insideComment) {

                int overflowRead = 0;
                while (overflowRead >= 0 && this.overflowBufferLen < this.prefix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.prefix[this.overflowBufferLen - 1]) {
                    overflowRead = readBytes(this.overflowBuffer, this.overflowBufferLen++, 1); 
                }


                if (this.overflowBufferLen == this.prefix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.prefix[this.overflowBufferLen - 1]) {
                    this.insideComment = true;

                    this.overflowBufferLen = 0;
                    this.index = 0;
                }

            } else {

                int overflowRead = 0;
                while (overflowRead >= 0 && this.overflowBufferLen < this.suffix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.suffix[this.overflowBufferLen - 1]) {
                    overflowRead = readBytes(this.overflowBuffer, this.overflowBufferLen++, 1); 
                }


                if (this.overflowBufferLen == this.suffix.length && this.overflowBuffer[this.overflowBufferLen - 1] == this.suffix[this.overflowBufferLen - 1]) {
                    this.insideComment = false;

                    this.overflowBufferLen = 0;
                    this.index = 0;
                }

            }

            if (this.overflowBufferLen > 0) {




                System.arraycopy(this.overflowBuffer, 0, cbuf, maxi, this.index);
                read += this.index;
                maxi += this.index;
                System.arraycopy(this.overflowBuffer, this.index, this.overflowBuffer, 0, (this.overflowBufferLen - this.index));
                this.overflowBufferLen -= this.index;
                this.index = 0;
            }

        }


        if (this.discardFrom >= 0) {
            read -= (maxi - this.discardFrom);
            this.discardFrom = 0;
        }

        this.discardFrom = (this.insideComment && this.action == BlockAction.DISCARD_ALL? 0 : -1);

        return read;

    }




    private int readBytes(final char[] buffer, final int off, final int len) throws IOException {

        if (len == 0) {
            return 0;
        }

        if (this.overflowBufferLen == 0) {
            return this.reader.read(buffer, off, len);
        }

        if (buffer == this.overflowBuffer && this.overflowBufferLen > 1) {


            throw new IllegalStateException(
                    "Cannot read bytes: trying to write to overflow buffer, when the overflow buffer is not empty (or size 1) yet!");
        }

        if (this.overflowBufferLen <= len) {


            System.arraycopy(this.overflowBuffer, 0, buffer, off, this.overflowBufferLen);
            int read = this.overflowBufferLen;
            this.overflowBufferLen = 0;

            if (read < len) {
                final int delegateRead = this.reader.read(buffer, (off + read), (len - read));
                if (delegateRead > 0) {
                    read += delegateRead;
                }
            }

            return read;

        }



        System.arraycopy(this.overflowBuffer, 0, buffer, off, len);
        if (len < this.overflowBufferLen) {
            System.arraycopy(this.overflowBuffer, len, this.overflowBuffer, 0, (this.overflowBufferLen - len));
        }
        this.overflowBufferLen -= len;
        return len;

    }




    private void overflowLastBytes(final char[] buffer, final int maxi, final int overflowCount) {
        if (this.overflowBuffer == null) {
            this.overflowBuffer = new char[Math.max(this.prefix.length, this.suffix.length)];
        }
        if (this.overflowBufferLen > 0) {
            System.arraycopy(this.overflowBuffer, 0, this.overflowBuffer, overflowCount, this.overflowBufferLen);
        }
        System.arraycopy(buffer, maxi - overflowCount, this.overflowBuffer, 0, overflowCount);
        this.overflowBufferLen += overflowCount;
    }




    private static boolean isArrayEquals(final char[] target, final char[] array, final int offset, final int len) {
        if (array.length == len && offset == 0) {
            return Arrays.equals(target, array);
        }
        if (target.length != len) {
            return false;
        }
        int n = target.length;
        while (n-- != 0) {
            if (target[n] != array[offset + n]) {
                return false;
            }
        }
        return true;
    }



    @Override
    public void close() throws IOException {
        this.reader.close();
    }




}

<code block>

package org.thymeleaf.templateparser.reader;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;


abstract class BlockAwareReader extends Reader {

    public enum BlockAction { DISCARD_ALL, DISCARD_CONTAINER }


    private final Reader reader;
    private final BlockAction action;
    private final char[] prefix;
    private final char[] suffix;

    
    private char[] overflowBuffer = null;
    private int overflowBufferLen = 0;

    private boolean insideComment = false;
    private int index = 0;
    private int discardFrom = -1;


    protected BlockAwareReader(final Reader reader, final BlockAction action, final char[] prefix, final char[] suffix) {
        super();
        this.reader = reader;
        this.action = action;
        this.prefix = prefix;
        this.suffix = suffix;
    }





    @Override
    public int read(final char[] cbuf, final int off, final int len) throws IOException {


        int read = readBytes(cbuf, off, len);
        if (read <= 0) {
            return read;
        }



        this.discardFrom = (this.discardFrom < 0? this.discardFrom : Math.max(off, this.discardFrom));

        int maxi = off + read;

        char c;
        int i = off;
        while (i < maxi) { 

            c = cbuf[i++];

            if (this.index == 0 && c != this.prefix[0] && c != this.suffix[0]) {

                continue;
            }

            if (!this.insideComment) {

                if (c == this.prefix[this.index]) {
                    this.index++;
                    if (this.index == this.prefix.length) {

                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.prefix.length, (maxi - i));
                        }
                        this.insideComment = true;
                        this.index = 0;
                        read -= this.prefix.length;
                        maxi -= this.prefix.length;
                        i -= this.prefix.length;
                        this.discardFrom = (this.action == BlockAction.DISCARD_ALL? i : -1);
                    }
                } else if (c == this.prefix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            } else {

                if (c == this.suffix[this.index]) {
                    this.index++;
                    if (this.index == this.suffix.length) {


                        if (i < maxi) {
                            System.arraycopy(cbuf, i, cbuf, i - this.suffix.length, (maxi - i));
                        }
                        this.insideComment = false;
                        this.index = 0;
                        read -= this.suffix.length;
                        maxi -= this.suffix.length;
                        i -= this.suffix.length;



                        if (this.discardFrom >= 0) {
                            if (i < maxi) {
                                System.arraycopy(cbuf, i, cbuf, this.discardFrom, (maxi - i));
                            }
                            read -= (i - this.discardFrom);
                            maxi -= (i - this.discardFrom);
                            i = this.discardFrom;
                            this.discardFrom = -1;
                        }

                    }
                } else if (c == this.suffix[0]) {
                    this.index = 1;
                } else {
                    this.index = 0;
                }

            }

        }


        if (this.index > 0) {



            overflowLastBytes(cbuf, maxi, this.index);
            read -= this.index;
            maxi -= this.index;



            final char[] structure = (this.insideComment? this.suffix : this.prefix);


            if (matchOverflow(structure)) {

                this.insideComment = !this.insideComment;

                this.overflowBufferLen -= structure.length;
                this.index = 0;

            } else {





                System.arraycopy(this.overflowBuffer, 0, cbuf, maxi, this.index);
                read += this.index;
                maxi += this.index;
                System.arraycopy(this.overflowBuffer, this.index, this.overflowBuffer, 0, (this.overflowBufferLen - this.index));
                this.overflowBufferLen -= this.index;
                this.index = 0;

            }

        }


        if (this.discardFrom >= 0) {
            read -= (maxi - this.discardFrom);
            this.discardFrom = 0;
        }

        this.discardFrom = (this.insideComment && this.action == BlockAction.DISCARD_ALL? 0 : -1);

        return read;

    }




    private int readBytes(final char[] buffer, final int off, final int len) throws IOException {

        if (len == 0) {
            return 0;
        }

        if (this.overflowBufferLen == 0) {
            return this.reader.read(buffer, off, len);
        }

        if (this.overflowBufferLen <= len) {


            System.arraycopy(this.overflowBuffer, 0, buffer, off, this.overflowBufferLen);
            int read = this.overflowBufferLen;
            this.overflowBufferLen = 0;

            if (read < len) {
                final int delegateRead = this.reader.read(buffer, (off + read), (len - read));
                if (delegateRead > 0) {
                    read += delegateRead;
                }
            }

            return read;

        }



        System.arraycopy(this.overflowBuffer, 0, buffer, off, len);
        if (len < this.overflowBufferLen) {
            System.arraycopy(this.overflowBuffer, len, this.overflowBuffer, 0, (this.overflowBufferLen - len));
        }
        this.overflowBufferLen -= len;
        return len;

    }




    private void overflowLastBytes(final char[] buffer, final int maxi, final int overflowCount) {
        if (this.overflowBuffer == null) {
            this.overflowBuffer = new char[Math.max(this.prefix.length, this.suffix.length)];
        }
        if (this.overflowBufferLen > 0) {
            System.arraycopy(this.overflowBuffer, 0, this.overflowBuffer, overflowCount, this.overflowBufferLen);
        }
        System.arraycopy(buffer, maxi - overflowCount, this.overflowBuffer, 0, overflowCount);
        this.overflowBufferLen += overflowCount;
    }




    private boolean matchOverflow(final char[] structure) throws IOException {

        if (this.overflowBufferLen > 0) {
            for (int i = 0; i < this.overflowBufferLen; i++) {
                if (this.overflowBuffer[i] != structure[i]) {
                    return false;
                }
            }
        }

        int overflowRead = 0;
        while (overflowRead >= 0 && this.overflowBufferLen < structure.length) {
            overflowRead = this.reader.read(this.overflowBuffer, this.overflowBufferLen, 1); 
            if (overflowRead > 0) {
                this.overflowBufferLen++;
                if (this.overflowBuffer[this.overflowBufferLen - 1] != structure[this.overflowBufferLen - 1]) {
                    return false;
                }
            }
        }

        return (this.overflowBufferLen == structure.length);

    }




    @Override
    public void close() throws IOException {
        this.reader.close();
    }




}
