
package jetbrains.mps.smodel;

import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.module.SDependencyImpl;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.project.ModelsAutoImportsManager;
import jetbrains.mps.project.ModelsAutoImportsManager.AutoImportsContributor;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.project.dependency.modules.LanguageDependenciesManager;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingConfig_AbstractRef;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingPriorityRule;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.vfs.IFile;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Generator extends ReloadableModuleBase {
  public static final Logger LOG = LogManager.getLogger(Generator.class);

  static {
    ModelsAutoImportsManager.registerContributor(new GeneratorModelsAutoImports());
  }

  @NotNull private Language mySourceLanguage;
  private GeneratorDescriptor myGeneratorDescriptor;

  public Generator(@NotNull Language sourceLanguage, GeneratorDescriptor generatorDescriptor) {
    mySourceLanguage = sourceLanguage;
    initGeneratorDescriptor(generatorDescriptor);
  }
  
  @Override
  
  public void rename(String newName) {
    int sharp = newName.indexOf("#");
    newName = sharp < 0 ? newName : newName.substring(sharp);
    renameModels(getSourceLanguage().getModuleName(), newName);
    myGeneratorDescriptor.setGeneratorUID(newName);
  }

  @Override
  public boolean isPackaged() {
    return getSourceLanguage().isPackaged();
  }

  public List<SModel> getOwnTemplateModels() {
    List<SModel> templateModels = new ArrayList<SModel>();
    for (SModel modelDescriptor : getModels()) {
      if (SModelStereotype.isGeneratorModel(modelDescriptor)) {
        templateModels.add(modelDescriptor);
      }
    }
    return templateModels;
  }

  @Override
  public GeneratorDescriptor getModuleDescriptor() {
    return myGeneratorDescriptor;
  }

  @Override
  public IFile getModuleSourceDir() {
    return mySourceLanguage.getModuleSourceDir();
  }

  @Override
  public IFile getDescriptorFile() {
    return null;
  }

  @Override
  protected void doSetModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    assert moduleDescriptor instanceof GeneratorDescriptor;
    LanguageDescriptor languageDescriptor = getSourceLanguage().getModuleDescriptor();
    int index = languageDescriptor.getGenerators().indexOf(getModuleDescriptor());
    languageDescriptor.getGenerators().remove(index);
    languageDescriptor.getGenerators().add(index, (GeneratorDescriptor) moduleDescriptor);
    getSourceLanguage().setModuleDescriptor(languageDescriptor);
  }

  public String getAlias() {
    String name = myGeneratorDescriptor.getNamespace();
    return getSourceLanguage().getModuleName() + "/" + (name == null ? "<no name>" : name);
  }

  public static String generateGeneratorUID(Language sourceLanguage) {
    return sourceLanguage.getModuleName() + "#" + jetbrains.mps.smodel.SModel.generateUniqueId();
  }

  public Language getSourceLanguage() {
    return mySourceLanguage;
  }

  
  public boolean generateTemplates() {
    return myGeneratorDescriptor.isGenerateTemplates();
  }

  public String toString() {
    return getAlias() + " [generator]";
  }

  @Override
  public void save() {
    super.save();
    mySourceLanguage.save();
  }

  @Override
  public Iterable<SDependency> getDeclaredDependencies() {
    HashSet<SDependency> rv = new HashSet<SDependency>(IterableUtil.asCollection(super.getDeclaredDependencies()));
    final SRepository repo = getRepository();

    
    rv.add(new SDependencyImpl(mySourceLanguage.getModuleReference(), repo, SDependencyScope.DEFAULT, false));
    for (SModuleReference rt : mySourceLanguage.getRuntimeModulesReferences()) {
      rv.add(new SDependencyImpl(rt, repo, SDependencyScope.RUNTIME, false));
    }

    
    for (SModuleReference refGenerator : getReferencedGeneratorUIDs()) {
      
      
      
      
      rv.add(new SDependencyImpl(refGenerator, repo, SDependencyScope.EXTENDS, false));
    }
    return rv;
  }

  public List<SModuleReference> getReferencedGeneratorUIDs() {
    return new ArrayList<SModuleReference>(myGeneratorDescriptor.getDepGenerators());
  }

  
  @Deprecated
  @ToRemove(version = 3.2)
  public List<Generator> getReferencedGenerators() {
    List<Generator> result = new ArrayList<Generator>();
    for (SModuleReference guid : getReferencedGeneratorUIDs()) {
      SModule module = guid.resolve(MPSModuleRepository.getInstance());
      if (module instanceof Generator) {
        result.add((Generator) module);
      }
    }
    return result;
  }

  public boolean deleteReferenceFromPriorities(org.jetbrains.mps.openapi.model.SModelReference ref) {
    boolean[] descriptorChanged = new boolean[]{false};
    Iterator<MappingPriorityRule> it = myGeneratorDescriptor.getPriorityRules().iterator();
    while (it.hasNext()) {
      MappingPriorityRule rule = it.next();
      MappingConfig_AbstractRef right = rule.getRight();
      MappingConfig_AbstractRef left = rule.getLeft();
      if (right.removeModelReference(ref, descriptorChanged) || left.removeModelReference(ref, descriptorChanged)) {
        it.remove();
      }
    }
    return descriptorChanged[0];
  }

  
  final void updateGeneratorDescriptor(GeneratorDescriptor generatorDescriptor) {
    initGeneratorDescriptor(generatorDescriptor);
    reloadAfterDescriptorChange();
  }

  private void initGeneratorDescriptor(GeneratorDescriptor generatorDescriptor) {
    myGeneratorDescriptor = generatorDescriptor;

    String uid = myGeneratorDescriptor.getGeneratorUID();
    if (uid == null) {
      myGeneratorDescriptor.setGeneratorUID(generateGeneratorUID(mySourceLanguage));
    }

    ModuleId uuid = myGeneratorDescriptor.getId();
    if (uuid == null) {
      uuid = ModuleId.regular();
      myGeneratorDescriptor.setId(uuid);
    }
    SModuleReference mp = new jetbrains.mps.project.structure.modules.ModuleReference(myGeneratorDescriptor.getGeneratorUID(), uuid);
    setModuleReference(mp);
  }

  private static class GeneratorModelsAutoImports extends AutoImportsContributor<Generator> {
    @Override
    public Class<Generator> getApplicableSModuleClass() {
      return Generator.class;
    }

    @Override
    public Set<Language> getAutoImportedLanguages(Generator contextGenerator, org.jetbrains.mps.openapi.model.SModel model) {
      if (SModelStereotype.isGeneratorModel(model)) {
        Language sourceLanguage = contextGenerator.getSourceLanguage();

        Set<Language> result = new LinkedHashSet<Language>();
        result.add(BootstrapLanguages.generatorLanguage());
        result.add(BootstrapLanguages.generatorContextLanguage());

        result.addAll(LanguageDependenciesManager.getAllExtendedLanguages(sourceLanguage));

        return result;
      } else {
        return Collections.emptySet();
      }
    }

    @Override
    public Set<DevKit> getAutoImportedDevKits(Generator contextModule, org.jetbrains.mps.openapi.model.SModel model) {
      return Collections.singleton(BootstrapLanguages.generalDevKit());
    }
  }

  @Override
  public ClassLoader getRootClassLoader() {
    return mySourceLanguage.getRootClassLoader();
  }
}

<code block>

package jetbrains.mps.project;

import jetbrains.mps.extapi.module.EditableSModule;
import jetbrains.mps.extapi.module.ModuleFacetBase;
import jetbrains.mps.extapi.module.SModuleBase;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.module.SDependencyImpl;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager.Deptype;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.project.structure.modules.Dependency;
import jetbrains.mps.project.structure.modules.DeploymentDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.ModuleFacetDescriptor;
import jetbrains.mps.smodel.BootstrapLanguages;
import jetbrains.mps.smodel.DefaultScope;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SuspiciousModelHandler;
import jetbrains.mps.util.EqualUtil;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.MacroHelper;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.util.iterable.TranslatingIterator;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.FileSystemListener;
import jetbrains.mps.vfs.IFile;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.module.FacetsFacade;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleFacet;
import org.jetbrains.mps.openapi.module.SModuleId;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.persistence.Memento;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelRootFactory;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.util.ProgressMonitor;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.jetbrains.mps.openapi.module.FacetsFacade.FacetFactory;

public abstract class AbstractModule extends SModuleBase implements EditableSModule, FileSystemListener {
  private static final Logger LOG = LogManager.getLogger(AbstractModule.class);

  public static final String MODULE_DIR = "module";
  public static final String CLASSES_GEN = "classes_gen";
  public static final String CLASSES = "classes";

  @Nullable
  protected final IFile myDescriptorFile;
  private SModuleReference myModuleReference;
  private Set<ModelRoot> mySModelRoots = new LinkedHashSet<ModelRoot>();
  private Set<ModuleFacetBase> myFacets = new LinkedHashSet<ModuleFacetBase>();
  private ModuleScope myScope = new ModuleScope();

  protected boolean myChanged = false;

  

  protected AbstractModule() {
    this(null);
  }

  protected AbstractModule(@Nullable IFile myDescriptorFile) {
    this.myDescriptorFile = myDescriptorFile;
  }

  
  @Override
  public SModuleId getModuleId() {

    return getModuleReference().getModuleId();
  }

  @Override
  public String getModuleName() {

    return getModuleReference().getModuleName();
  }

  @Override
  public Iterable<SDependency> getDeclaredDependencies() {
    assertCanRead();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return Collections.emptyList();
    }
    HashSet<SDependency> result = new HashSet<SDependency>();
    final SRepository repo = getRepository();
    if (repo == null) {
      throw new IllegalStateException("It is not possible to resolve all declared dependencies with a null repository : module " + this);
    }

    
    for (Dependency d : descriptor.getDependencies()) {
      result.add(new SDependencyImpl(d.getModuleRef(), repo, d.getScope(), d.isReexport()));
    }

    
    for (SModuleReference usedDevkit : descriptor.getUsedDevkits()) {
      final SModule devkit = usedDevkit.resolve(repo);
      if (DevKit.class.isInstance(devkit)) {
        for (Solution solution : ((DevKit) devkit).getAllExportedSolutions()) {
          result.add(new SDependencyImpl(solution.getModuleReference(), repo, SDependencyScope.DEFAULT, false));
        }
      }
    }
    return result;
  }


  
  @Deprecated
  @ToRemove(version = 3.3)
  public Set<SLanguage> getAllUsedLanguages() {
    return new SLanguageHierarchy(getUsedLanguages()).getExtended();
  }

  @Override
  public Set<SLanguage> getUsedLanguages() {
    assertCanRead();

    LinkedHashSet<SLanguage> usedLanguages = new LinkedHashSet<SLanguage>();
    LinkedHashSet<SModuleReference> devkits = new LinkedHashSet<SModuleReference>();
    for (SModel m : getModels()) {
      final SModelInternal modelInternal = (SModelInternal) m;
      usedLanguages.addAll(modelInternal.importedLanguageIds());
      devkits.addAll(modelInternal.importedDevkits());
    }
    final SRepository repository = getRepository();
    if (repository != null) {
      for (SModuleReference devkitRef : devkits) {
        final SModule module = devkitRef.resolve(repository);
        if (module instanceof DevKit) {
          for (SLanguage l : ((DevKit) module).getAllExportedLanguageIds()) {
            usedLanguages.add(l);
          }
        }
      }
    }
    usedLanguages.add(BootstrapLanguages.getLangCore());

    return usedLanguages;
  }

  @Override
  public SModel resolveInDependencies(SModelId ref) {
    assertCanRead();
    SModel rv = getModel(ref);
    if (rv != null) {
      return rv;
    }
    for (SModule visibleModule : new GlobalModuleDependenciesManager(this).getModules(Deptype.VISIBLE)) {
      rv = visibleModule.getModel(ref);
      if (rv != null) {
        return rv;
      }
    }








    return SModelRepository.getInstance().getModelDescriptor(ref);
  }

  protected void setModuleReference(@NotNull SModuleReference reference) {
    assertCanChange();

    assert reference.getModuleId() != null : "module must have an id";
    assert myModuleReference == null || reference.getModuleId().equals(myModuleReference.getModuleId()) : "module id can't be changed";

    SModuleReference oldValue = myModuleReference;
    myModuleReference = reference;
    if (oldValue != null &&
        oldValue.getModuleName() != null &&
        !oldValue.getModuleName().equals(myModuleReference.getModuleName())) {

      MPSModuleRepository.getInstance().moduleFqNameChanged(this, oldValue.getModuleName());
    }
  }

  @Override
  @NotNull
  
  public SModuleReference getModuleReference() {

    return myModuleReference;
  }

  

  
  @Nullable
  public ModuleDescriptor getModuleDescriptor() {
    assertCanRead();

    return null;
  }

  
  public final void setModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    assertCanChange();
    doSetModuleDescriptor(moduleDescriptor);
    setChanged();
    reloadAfterDescriptorChange();
    fireChanged();
    dependenciesChanged();
  }

  
  protected void doSetModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setChanged() {
    assertCanChange();
    myChanged = true;
  }

  @Override
  public void save() {
    assertCanChange();
    validateLanguageVersions();
    myChanged = false;
  }

  

  @Nullable
  public Dependency addDependency(@NotNull SModuleReference moduleRef, boolean reexport) {
    assertCanChange();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return null;
    for (Dependency dep : descriptor.getDependencies()) {
      if (!EqualUtil.equals(dep.getModuleRef(), moduleRef)) continue;

      if (reexport && !dep.isReexport()) {
        dep.setReexport(true);
        dependenciesChanged();
        setChanged();
      }
      return dep;
    }

    Dependency dep = new Dependency();
    dep.setModuleRef(moduleRef);
    dep.setReexport(reexport);
    descriptor.getDependencies().add(dep);

    dependenciesChanged();
    setChanged();
    return dep;
  }

  public void removeDependency(@NotNull Dependency dependency) {
    assertCanChange();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return;
    if (!descriptor.getDependencies().contains(dependency)) return;

    descriptor.getDependencies().remove(dependency);

    dependenciesChanged();
    setChanged();
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void addUsedLanguage(SModuleReference langRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void removeUsedLanguage(SModuleReference langRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void addUsedDevkit(SModuleReference devkitRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void removeUsedDevkit(SModuleReference devkitRef) {
    
  }

  

  
  @Deprecated
  public final Collection<SModuleReference> getUsedLanguagesReferences() {
    assertCanRead();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return Collections.emptySet();
    return Collections.unmodifiableCollection(descriptor.getUsedLanguages());
  }

  

  
  
  protected void updatePackagedDescriptor() {
    
    
    
    

    
    
    
    

    if (!isPackaged()) return;

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return;
    DeploymentDescriptor deplDescriptor = descriptor.getDeploymentDescriptor();
    if (deplDescriptor == null) return;

    final IFile bundleHomeFile = FileSystem.getInstance().getBundleHome(getDescriptorFile());
    if (bundleHomeFile == null) return;

    IFile bundleParent = bundleHomeFile.getParent();
    if (bundleParent == null || !bundleParent.exists()) return;

    IFile sourcesDescriptorFile = ModulesMiner.getRealDescriptorFile(getDescriptorFile().getPath(), deplDescriptor);
    if (sourcesDescriptorFile == null) {
      
      assert descriptor instanceof DeploymentDescriptor;
    } else {
      assert !(descriptor instanceof DeploymentDescriptor);
    }

    
    if (sourcesDescriptorFile != null) {
      
      
      
      descriptor.getAdditionalJavaStubPaths().clear();

      
      List<ModelRootDescriptor> toRemove = new ArrayList<ModelRootDescriptor>();
      List<ModelRootDescriptor> toAdd = new ArrayList<ModelRootDescriptor>();
      for (ModelRootDescriptor rootDescriptor : descriptor.getModelRootDescriptors()) {
        String rootDescriptorType = rootDescriptor.getType();
        if (rootDescriptorType.equals(PersistenceRegistry.JAVA_CLASSES_ROOT)) {
          
          String pathElement = rootDescriptor.getMemento().get("path");
          boolean update = false;
          Memento newMemento = new MementoImpl();
          if (pathElement != null) {
            
            String convertedPath = convertPath(pathElement, bundleHomeFile, sourcesDescriptorFile, descriptor);

            if (convertedPath != null) {
              newMemento.put("path", convertedPath);
              update = true;
            }
          } else {
            
            String contentPath = rootDescriptor.getMemento().get("contentPath");
            List<String> paths = new LinkedList<String>();
            for (Memento sourceRoot : rootDescriptor.getMemento().getChildren("sourceRoot")) {
              paths.add(contentPath + File.separator + sourceRoot.get("location"));
            }
            newMemento.put("contentPath", bundleParent.getPath());
            Memento newMementoChild = newMemento.createChild("sourceRoot");
            for (String path : paths) {
              String convertedPath = convertPath(path, bundleHomeFile, sourcesDescriptorFile, descriptor);
              if (convertedPath != null) {
                newMementoChild.put("location", convertedPath.replace(newMemento.get("contentPath"), ""));
                update = true;
              }
            }
          }
          if (update) toAdd.add(new ModelRootDescriptor(rootDescriptorType, newMemento));
          toRemove.add(rootDescriptor);
        }
      }
      descriptor.getModelRootDescriptors().removeAll(toRemove);
      descriptor.getModelRootDescriptors().addAll(toAdd);
    }

    
    for (String jarFile : deplDescriptor.getLibraries()) {
      IFile jar = jarFile.startsWith("/")
          ? FileSystem.getInstance().getFileByPath(PathManager.getHomePath() + jarFile)
          : bundleParent.getDescendant(jarFile);
      if (jar.exists()) {
        String path = jar.getPath();
        descriptor.getAdditionalJavaStubPaths().add(path);
        descriptor.getModelRootDescriptors().add(ModelRootDescriptor.getJavaStubsModelRoot(path));
      }
    }
  }

  
  @Nullable
  private String convertPath(String originalPath, IFile bundleHome, IFile sourcesDescriptorFile, ModuleDescriptor descriptor) {
    MacroHelper macroHelper = MacrosFactory.forModuleFile(sourcesDescriptorFile);

    String canonicalPath = FileUtil.getCanonicalPath(originalPath).toLowerCase();

    
    String suffix = descriptor.getCompileInMPS() ? CLASSES_GEN : CLASSES;
    if (canonicalPath.endsWith(suffix)) {
      
      String classes = macroHelper.expandPath("${module}/" + suffix);
      if (FileUtil.getCanonicalPath(classes).equalsIgnoreCase(canonicalPath)) {
        return bundleHome.getPath();
      }
    } else if (FileUtil.getCanonicalPath(bundleHome.getPath()).equalsIgnoreCase(canonicalPath)) {
      return bundleHome.getPath();
    }

    
    String mpsHomeLibPath = FileUtil.getCanonicalPath(PathManager.getHomePath() + File.separator + "lib").toLowerCase();
    if (canonicalPath.startsWith(mpsHomeLibPath)) {
      return canonicalPath;
    }

    if (MacrosFactory.containsNonMPSMacros(macroHelper.shrinkPath(originalPath))) {
      return originalPath;
    } else {
      
      return null;
    }
  }




  @Override
  public Iterable<ModelRoot> getModelRoots() {
    
    assertCanRead();
    return Collections.unmodifiableCollection(mySModelRoots);
  }

  protected void reloadAfterDescriptorChange() {
    initFacetsAndModels();
  }

  private void initFacetsAndModels() {
    updatePackagedDescriptor();
    updateFacets();
    updateModelsSet();
  }

  protected void collectFacetTypes(Set<String> types) {
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return;
    }

    types.addAll(FacetsFacade.getInstance().getApplicableFacetTypes(
        new TranslatingIterator<SModuleReference, String>(descriptor.getUsedLanguages().iterator()) {
          @Override
          protected String translate(SModuleReference node) {
            return node.getModuleName();
          }
        }));

    types.add(JavaModuleFacet.FACET_TYPE);
  }

  protected ModuleFacetBase setupFacet(ModuleFacetBase facet, Memento memento) {
    if (!facet.setModule(this)) {
      return null;
    }
    facet.load(memento != null ? memento : new MementoImpl());
    facet.attach();
    return facet;
  }

  protected void updateFacets() {
    assertCanChange();

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return;
    }

    for (ModuleFacetBase facet : myFacets) {
      facet.dispose();
    }
    myFacets.clear();

    Map<String, Memento> config = new HashMap<String, Memento>();
    for (ModuleFacetDescriptor facetDescriptors : descriptor.getModuleFacetDescriptors()) {
      config.put(facetDescriptors.getType(), facetDescriptors.getMemento());
    }

    Set<String> types = new HashSet<String>();
    collectFacetTypes(types);
    types.addAll(config.keySet());

    for (String facetType : types) {
      FacetFactory factory = FacetsFacade.getInstance().getFacetFactory(facetType);
      if (factory == null) {
        LOG.error("no registered factory for a facet with type=`" + facetType + "'");
        continue;
      }
      SModuleFacet newFacet = factory.create();
      if (!(newFacet instanceof ModuleFacetBase)) {
        LOG.error("broken facet factory: " + factory.getClass().getName());
        continue;
      }

      ModuleFacetBase facet = (ModuleFacetBase) newFacet;
      Memento m = config.get(facetType);
      facet = setupFacet(facet, m);
      if (facet != null) {
        myFacets.add(facet);
      }
    }
  }

  public void onModuleLoad() {
    updateSModelReferences();
    updateModuleReferences();
  }

  @Override
  public boolean isReadOnly() {

    return isPackaged();
  }

  @Override
  public boolean isPackaged() {

    return getModuleSourceDir() == null || FileSystem.getInstance().isPackaged(getModuleSourceDir());
  }

  
  public IFile getModuleSourceDir() {
    return myDescriptorFile != null ? myDescriptorFile.getParent() : null;
  }

  public IFile getDescriptorFile() {

    return myDescriptorFile;
  }

  public void rename(String newName) {
    renameModels(getModuleName(), newName);

    
    getRepository().saveAll();

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (myDescriptorFile != null) {
      myDescriptorFile.rename(newName + "." + FileUtil.getExtension(myDescriptorFile.getName()));
    }

    descriptor.setNamespace(newName);
    setModuleDescriptor(descriptor);
  }

  protected void renameModels(String oldName, String newName) {
    
    for (SModel m : getModels()) {
      if (m.isReadOnly()) continue;
      if (!m.getModelName().startsWith(oldName + ".")) continue;
      if (!(m instanceof EditableSModel)) continue;

      ((EditableSModel) m).rename(newName + m.getModelName().substring(getModuleName().length()), true);
    }
  }

  @NotNull
  public SearchScope getScope() {
    assertCanRead();
    return myScope;
  }

  @Override
  public void attach(@NotNull SRepository repository) {
    super.attach(repository);
    if (myDescriptorFile != null) {
      FileSystem.getInstance().addListener(this);
    }
    initFacetsAndModels();
  }

  @Nullable
  @Override
  public IFile getFileToListen() {
    return myDescriptorFile;
  }

  @Override
  public Iterable<FileSystemListener> getListenerDependencies() {
    List<FileSystemListener> listeners = new ArrayList<FileSystemListener>();
    for (MPSModuleOwner owner : MPSModuleRepository.getInstance().getOwners(this)) {
      if (owner instanceof FileSystemListener) {
        listeners.add((FileSystemListener) owner);
      }
    }
    return listeners.isEmpty() ? null : listeners;
  }

  @Override
  public void update(ProgressMonitor monitor, FileSystemEvent event) {
    assertCanChange();
    for (IFile file : event.getRemoved()) {
      if (file.equals(myDescriptorFile)) {
        ModuleRepositoryFacade.getInstance().removeModuleForced(this);
        return;
      }
    }
    for (IFile file : event.getChanged()) {
      if (file.equals(myDescriptorFile)) {
        SModuleOperations.reloadFromDisk(this);
        return;
      }
    }
  }

  @Override
  public String toString() {
    String namespace = getModuleName();
    return namespace + " [module]";
  }

  
  @Deprecated
  public String getName() {
    return getModuleName();
  }

  @Override
  public void dispose() {
    assertCanChange();
    LOG.trace("Disposing the module " + this);
    FileSystem.getInstance().removeListener(this);
    for (ModuleFacetBase f : myFacets) {
      f.dispose();
    }
    myFacets.clear();
    for (ModelRoot m : mySModelRoots) {
      ((ModelRootBase) m).dispose();
    }
    mySModelRoots.clear();
    super.dispose();
  }

  public List<String> getSourcePaths() {
    assertCanRead();
    return new ArrayList<String>(SModuleOperations.getAllSourcePaths(this));
  }

  public void updateModelsSet() {
    doUpdateModelsSet();
  }

  protected Iterable<ModelRoot> loadRoots() {
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return Collections.emptyList();
    }

    List<ModelRoot> result = new ArrayList<ModelRoot>();
    for (ModelRootDescriptor modelRoot : descriptor.getModelRootDescriptors()) {
      try {
        ModelRootFactory modelRootFactory = PersistenceFacade.getInstance().getModelRootFactory(modelRoot.getType());
        if (modelRootFactory == null) {
          LOG.error("Unknown model root type: `" + modelRoot.getType() + "'. Requested by: " + this);
          continue;
        }

        ModelRoot root = modelRootFactory.create();
        root.load(modelRoot.getMemento());
        result.add(root);
      } catch (Exception e) {
        LOG.error("Error loading models from root with type: `" + modelRoot.getType() + "'. Requested by: " + this, e);
      }
    }
    return result;
  }

  private void doUpdateModelsSet() {
    assertCanChange();

    for (SModel model : getModels()) {
      if (model instanceof EditableSModel && ((EditableSModel) model).isChanged()) {
        LOG.error(
            "Trying to reload module " + getModuleName() + " which contains a non-saved model" +
                model.getModelName() + "To prevent data loss, MPS will not update models in this module. " +
                "Please save your work and restart MPS. See MPS-18743 for details."
        );
        return;
      }
    }

    Set<ModelRoot> toRemove = new HashSet<ModelRoot>(mySModelRoots);
    Set<ModelRoot> toUpdate = new HashSet<ModelRoot>(mySModelRoots);
    Set<ModelRoot> toAttach = new HashSet<ModelRoot>();

    for (ModelRoot root : loadRoots()) {
      try {
        if (mySModelRoots.contains(root)) {
          toRemove.remove(root);
        } else {
          toAttach.add(root);
        }
      } catch (Exception e) {
        LOG.error("Error loading models from root `" + root.getPresentation() + "'. Requested by: " + this, e);
      }
    }
    toUpdate.removeAll(toRemove);

    for (ModelRoot modelRoot : toRemove) {
      ((ModelRootBase) modelRoot).dispose();
    }
    mySModelRoots.removeAll(toRemove);
    for (ModelRoot modelRoot : toAttach) {
      ModelRootBase rootBase = (ModelRootBase) modelRoot;
      rootBase.setModule(this);
      mySModelRoots.add(modelRoot);
      rootBase.attach();
    }
    for (ModelRoot modelRoot : toUpdate) {
      ((ModelRootBase) modelRoot).update();
    }
  }

  public static void handleReadProblem(AbstractModule module, Exception e, boolean isInConflict) {
    SuspiciousModelHandler.getHandler().handleSuspiciousModule(module, isInConflict);
    LOG.error(e.getMessage());
    e.printStackTrace();
  }

  public void updateSModelReferences() {
    ModuleDescriptor moduleDescriptor = getModuleDescriptor();
    if (moduleDescriptor == null) return;
    if (moduleDescriptor.updateModelRefs()) {
      setChanged();
    }
  }

  public void updateModuleReferences() {
    ModuleDescriptor moduleDescriptor = getModuleDescriptor();
    if (moduleDescriptor == null) return;
    if (moduleDescriptor.updateModuleRefs()) {
      setChanged();
    }
  }

  protected void dependenciesChanged() {
    

    
    
    

    

    myScope.invalidateCaches();
  }

  protected ModuleDescriptor loadDescriptor() {
    return null;
  }

  @Override
  public boolean isChanged() {
    return myChanged;
  }

  @Nullable
  @Override
  public <T extends SModuleFacet> T getFacet(Class<T> clazz) {
    for (SModuleFacet facet : getFacets()) {
      if (clazz.isInstance(facet)) {
        return (T) facet;
      }
    }
    return null;
  }

  @Override
  public Iterable<SModuleFacet> getFacets() {
    return Collections.<SModuleFacet>unmodifiableSet(myFacets);
  }

  public class ModuleScope extends DefaultScope {
    protected ModuleScope() {
    }

    public AbstractModule getModule() {
      return AbstractModule.this;
    }

    @Override
    protected Set<SModule> getInitialModules() {
      Set<SModule> result = new HashSet<SModule>();
      result.add(AbstractModule.this);
      return result;
    }

    @Override
    protected Set<Language> getInitialUsedLanguages() {
      HashSet<Language> result = new HashSet<Language>();
      for (SLanguage l : AbstractModule.this.getUsedLanguages()) {
        SModule langModule = l.getSourceModule();
        if (langModule instanceof Language) {
          result.add((Language) langModule);
        }
      }
      if (AbstractModule.this instanceof Language) {
        result.add((Language) AbstractModule.this);
        
        result.add(ModuleRepositoryFacade.getInstance().getModule(BootstrapLanguages.descriptorLanguageRef(), Language.class));
      }
      if (AbstractModule.this instanceof Generator) {
        result.add(((Generator) AbstractModule.this).getSourceLanguage());
      }
      return result;
    }

    public String toString() {
      return "Scope of module " + AbstractModule.this;
    }
  }

  public IFile getOutputPath() {
    return ProjectPathUtil.getGeneratorOutputPath(getModuleSourceDir(), getModuleDescriptor());
  }

  @Deprecated
  public final String getGeneratorOutputPath() {
    IFile outputPath = getOutputPath();
    return outputPath != null ? outputPath.getPath() : null;
  }

  @Deprecated
  public final String getTestsGeneratorOutputPath() {
    TestsFacet testsFacet = this.getFacet(TestsFacet.class);
    if (testsFacet == null) {
      return null;
    }
    IFile testsOutputPath = testsFacet.getTestsOutputPath();
    if (testsOutputPath == null) {
      return null;
    }
    return testsOutputPath.getPath();
  }

  public void validateLanguageVersions() {
    assertCanChange();
    ModuleDescriptor md = getModuleDescriptor();
    Map<SLanguage, Integer> oldLanguageVersions = md.getLanguageVersions();
    Map<SLanguage, Integer> newLanguageVersions = new HashMap<SLanguage, Integer>();
    if (!md.hasLanguageVersions()) {
      for (SLanguage lang : getAllUsedLanguages()) {
        newLanguageVersions.put(lang, 0);
      }
      md.setHasLanguageVersions(true);
    } else {
      for (SLanguage lang : getAllUsedLanguages()) {
        if (oldLanguageVersions.containsKey(lang)) {
          newLanguageVersions.put(lang, oldLanguageVersions.get(lang));
        } else {
          newLanguageVersions.put(lang, lang.getLanguageVersion());
        }
      }
    }
    oldLanguageVersions.clear();
    oldLanguageVersions.putAll(newLanguageVersions);
  }

  @Override
  public int getUsedLanguageVersion(SLanguage usedLanguage) {
    Integer res = getModuleDescriptor().getLanguageVersions().get(usedLanguage);
    if (res == null) {
      LOG.error(
          "getUsedLanguageVersion can't find a version for language " + usedLanguage.getQualifiedName() +
              " in module " + getModuleName() + "." +
              " This can either mean that the language is not imported into this module or that " +
              "validateLanguageVersions was not called on this module in appropriate moment.",
          new Throwable());
      return usedLanguage.getLanguageVersion();
    }
    return res;
  }
}

<code block>

package jetbrains.mps.smodel;

import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.module.SDependencyImpl;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.project.ModelsAutoImportsManager;
import jetbrains.mps.project.ModelsAutoImportsManager.AutoImportsContributor;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.project.dependency.modules.LanguageDependenciesManager;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingConfig_AbstractRef;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingPriorityRule;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.vfs.IFile;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Generator extends ReloadableModuleBase {
  public static final Logger LOG = LogManager.getLogger(Generator.class);

  static {
    ModelsAutoImportsManager.registerContributor(new GeneratorModelsAutoImports());
  }

  @NotNull private Language mySourceLanguage;
  private GeneratorDescriptor myGeneratorDescriptor;

  public Generator(@NotNull Language sourceLanguage, GeneratorDescriptor generatorDescriptor) {
    mySourceLanguage = sourceLanguage;
    initGeneratorDescriptor(generatorDescriptor);
  }
  
  @Override
  
  public void rename(String newName) {
    int sharp = newName.indexOf("#");
    super.rename(sharp < 0 ? newName : newName.substring(sharp));
    myGeneratorDescriptor.setGeneratorUID(newName);
  }

  @Override
  public boolean isPackaged() {
    return getSourceLanguage().isPackaged();
  }

  public List<SModel> getOwnTemplateModels() {
    List<SModel> templateModels = new ArrayList<SModel>();
    for (SModel modelDescriptor : getModels()) {
      if (SModelStereotype.isGeneratorModel(modelDescriptor)) {
        templateModels.add(modelDescriptor);
      }
    }
    return templateModels;
  }

  @Override
  public GeneratorDescriptor getModuleDescriptor() {
    return myGeneratorDescriptor;
  }

  @Override
  public IFile getModuleSourceDir() {
    return mySourceLanguage.getModuleSourceDir();
  }

  @Override
  public IFile getDescriptorFile() {
    return null;
  }

  @Override
  protected void doSetModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    assert moduleDescriptor instanceof GeneratorDescriptor;
    LanguageDescriptor languageDescriptor = getSourceLanguage().getModuleDescriptor();
    int index = languageDescriptor.getGenerators().indexOf(getModuleDescriptor());
    languageDescriptor.getGenerators().remove(index);
    languageDescriptor.getGenerators().add(index, (GeneratorDescriptor) moduleDescriptor);
    getSourceLanguage().setModuleDescriptor(languageDescriptor);
  }

  public String getAlias() {
    String name = myGeneratorDescriptor.getNamespace();
    return getSourceLanguage().getModuleName() + "/" + (name == null ? "<no name>" : name);
  }

  public static String generateGeneratorUID(Language sourceLanguage) {
    return sourceLanguage.getModuleName() + "#" + jetbrains.mps.smodel.SModel.generateUniqueId();
  }

  public Language getSourceLanguage() {
    return mySourceLanguage;
  }

  
  public boolean generateTemplates() {
    return myGeneratorDescriptor.isGenerateTemplates();
  }

  public String toString() {
    return getAlias() + " [generator]";
  }

  @Override
  public void save() {
    super.save();
    mySourceLanguage.save();
  }

  @Override
  public Iterable<SDependency> getDeclaredDependencies() {
    HashSet<SDependency> rv = new HashSet<SDependency>(IterableUtil.asCollection(super.getDeclaredDependencies()));
    final SRepository repo = getRepository();

    
    rv.add(new SDependencyImpl(mySourceLanguage.getModuleReference(), repo, SDependencyScope.DEFAULT, false));
    for (SModuleReference rt : mySourceLanguage.getRuntimeModulesReferences()) {
      rv.add(new SDependencyImpl(rt, repo, SDependencyScope.RUNTIME, false));
    }

    
    for (SModuleReference refGenerator : getReferencedGeneratorUIDs()) {
      
      
      
      
      rv.add(new SDependencyImpl(refGenerator, repo, SDependencyScope.EXTENDS, false));
    }
    return rv;
  }

  public List<SModuleReference> getReferencedGeneratorUIDs() {
    return new ArrayList<SModuleReference>(myGeneratorDescriptor.getDepGenerators());
  }

  
  @Deprecated
  @ToRemove(version = 3.2)
  public List<Generator> getReferencedGenerators() {
    List<Generator> result = new ArrayList<Generator>();
    for (SModuleReference guid : getReferencedGeneratorUIDs()) {
      SModule module = guid.resolve(MPSModuleRepository.getInstance());
      if (module instanceof Generator) {
        result.add((Generator) module);
      }
    }
    return result;
  }

  public boolean deleteReferenceFromPriorities(org.jetbrains.mps.openapi.model.SModelReference ref) {
    boolean[] descriptorChanged = new boolean[]{false};
    Iterator<MappingPriorityRule> it = myGeneratorDescriptor.getPriorityRules().iterator();
    while (it.hasNext()) {
      MappingPriorityRule rule = it.next();
      MappingConfig_AbstractRef right = rule.getRight();
      MappingConfig_AbstractRef left = rule.getLeft();
      if (right.removeModelReference(ref, descriptorChanged) || left.removeModelReference(ref, descriptorChanged)) {
        it.remove();
      }
    }
    return descriptorChanged[0];
  }

  
  final void updateGeneratorDescriptor(GeneratorDescriptor generatorDescriptor) {
    initGeneratorDescriptor(generatorDescriptor);
    reloadAfterDescriptorChange();
  }

  private void initGeneratorDescriptor(GeneratorDescriptor generatorDescriptor) {
    myGeneratorDescriptor = generatorDescriptor;

    String uid = myGeneratorDescriptor.getGeneratorUID();
    if (uid == null) {
      myGeneratorDescriptor.setGeneratorUID(generateGeneratorUID(mySourceLanguage));
    }

    ModuleId uuid = myGeneratorDescriptor.getId();
    if (uuid == null) {
      uuid = ModuleId.regular();
      myGeneratorDescriptor.setId(uuid);
    }
    SModuleReference mp = new jetbrains.mps.project.structure.modules.ModuleReference(myGeneratorDescriptor.getGeneratorUID(), uuid);
    setModuleReference(mp);
  }

  private static class GeneratorModelsAutoImports extends AutoImportsContributor<Generator> {
    @Override
    public Class<Generator> getApplicableSModuleClass() {
      return Generator.class;
    }

    @Override
    public Set<Language> getAutoImportedLanguages(Generator contextGenerator, org.jetbrains.mps.openapi.model.SModel model) {
      if (SModelStereotype.isGeneratorModel(model)) {
        Language sourceLanguage = contextGenerator.getSourceLanguage();

        Set<Language> result = new LinkedHashSet<Language>();
        result.add(BootstrapLanguages.generatorLanguage());
        result.add(BootstrapLanguages.generatorContextLanguage());

        result.addAll(LanguageDependenciesManager.getAllExtendedLanguages(sourceLanguage));

        return result;
      } else {
        return Collections.emptySet();
      }
    }

    @Override
    public Set<DevKit> getAutoImportedDevKits(Generator contextModule, org.jetbrains.mps.openapi.model.SModel model) {
      return Collections.singleton(BootstrapLanguages.generalDevKit());
    }
  }

  @Override
  public ClassLoader getRootClassLoader() {
    return mySourceLanguage.getRootClassLoader();
  }
}

<code block>

package jetbrains.mps.project;

import jetbrains.mps.extapi.module.EditableSModule;
import jetbrains.mps.extapi.module.ModuleFacetBase;
import jetbrains.mps.extapi.module.SModuleBase;
import jetbrains.mps.extapi.persistence.ModelRootBase;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.module.SDependencyImpl;
import jetbrains.mps.persistence.MementoImpl;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager;
import jetbrains.mps.project.dependency.GlobalModuleDependenciesManager.Deptype;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.project.structure.model.ModelRootDescriptor;
import jetbrains.mps.project.structure.modules.Dependency;
import jetbrains.mps.project.structure.modules.DeploymentDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.project.structure.modules.ModuleFacetDescriptor;
import jetbrains.mps.smodel.BootstrapLanguages;
import jetbrains.mps.smodel.DefaultScope;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SuspiciousModelHandler;
import jetbrains.mps.util.EqualUtil;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.MacroHelper;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.util.iterable.TranslatingIterator;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.FileSystemListener;
import jetbrains.mps.vfs.IFile;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.module.FacetsFacade;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleFacet;
import org.jetbrains.mps.openapi.module.SModuleId;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.persistence.Memento;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelRootFactory;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.util.ProgressMonitor;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.jetbrains.mps.openapi.module.FacetsFacade.FacetFactory;

public abstract class AbstractModule extends SModuleBase implements EditableSModule, FileSystemListener {
  private static final Logger LOG = LogManager.getLogger(AbstractModule.class);

  public static final String MODULE_DIR = "module";
  public static final String CLASSES_GEN = "classes_gen";
  public static final String CLASSES = "classes";

  @Nullable
  protected final IFile myDescriptorFile;
  private SModuleReference myModuleReference;
  private Set<ModelRoot> mySModelRoots = new LinkedHashSet<ModelRoot>();
  private Set<ModuleFacetBase> myFacets = new LinkedHashSet<ModuleFacetBase>();
  private ModuleScope myScope = new ModuleScope();

  protected boolean myChanged = false;

  

  protected AbstractModule() {
    this(null);
  }

  protected AbstractModule(@Nullable IFile myDescriptorFile) {
    this.myDescriptorFile = myDescriptorFile;
  }

  
  @Override
  public SModuleId getModuleId() {

    return getModuleReference().getModuleId();
  }

  @Override
  public String getModuleName() {

    return getModuleReference().getModuleName();
  }

  @Override
  public Iterable<SDependency> getDeclaredDependencies() {
    assertCanRead();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return Collections.emptyList();
    }
    HashSet<SDependency> result = new HashSet<SDependency>();
    final SRepository repo = getRepository();
    if (repo == null) {
      throw new IllegalStateException("It is not possible to resolve all declared dependencies with a null repository : module " + this);
    }

    
    for (Dependency d : descriptor.getDependencies()) {
      result.add(new SDependencyImpl(d.getModuleRef(), repo, d.getScope(), d.isReexport()));
    }

    
    for (SModuleReference usedDevkit : descriptor.getUsedDevkits()) {
      final SModule devkit = usedDevkit.resolve(repo);
      if (DevKit.class.isInstance(devkit)) {
        for (Solution solution : ((DevKit) devkit).getAllExportedSolutions()) {
          result.add(new SDependencyImpl(solution.getModuleReference(), repo, SDependencyScope.DEFAULT, false));
        }
      }
    }
    return result;
  }


  
  @Deprecated
  @ToRemove(version = 3.3)
  public Set<SLanguage> getAllUsedLanguages() {
    return new SLanguageHierarchy(getUsedLanguages()).getExtended();
  }

  @Override
  public Set<SLanguage> getUsedLanguages() {
    assertCanRead();

    LinkedHashSet<SLanguage> usedLanguages = new LinkedHashSet<SLanguage>();
    LinkedHashSet<SModuleReference> devkits = new LinkedHashSet<SModuleReference>();
    for (SModel m : getModels()) {
      final SModelInternal modelInternal = (SModelInternal) m;
      usedLanguages.addAll(modelInternal.importedLanguageIds());
      devkits.addAll(modelInternal.importedDevkits());
    }
    final SRepository repository = getRepository();
    if (repository != null) {
      for (SModuleReference devkitRef : devkits) {
        final SModule module = devkitRef.resolve(repository);
        if (module instanceof DevKit) {
          for (SLanguage l : ((DevKit) module).getAllExportedLanguageIds()) {
            usedLanguages.add(l);
          }
        }
      }
    }
    usedLanguages.add(BootstrapLanguages.getLangCore());

    return usedLanguages;
  }

  @Override
  public SModel resolveInDependencies(SModelId ref) {
    assertCanRead();
    SModel rv = getModel(ref);
    if (rv != null) {
      return rv;
    }
    for (SModule visibleModule : new GlobalModuleDependenciesManager(this).getModules(Deptype.VISIBLE)) {
      rv = visibleModule.getModel(ref);
      if (rv != null) {
        return rv;
      }
    }








    return SModelRepository.getInstance().getModelDescriptor(ref);
  }

  protected void setModuleReference(@NotNull SModuleReference reference) {
    assertCanChange();

    assert reference.getModuleId() != null : "module must have an id";
    assert myModuleReference == null || reference.getModuleId().equals(myModuleReference.getModuleId()) : "module id can't be changed";

    SModuleReference oldValue = myModuleReference;
    myModuleReference = reference;
    if (oldValue != null &&
        oldValue.getModuleName() != null &&
        !oldValue.getModuleName().equals(myModuleReference.getModuleName())) {

      MPSModuleRepository.getInstance().moduleFqNameChanged(this, oldValue.getModuleName());
    }
  }

  @Override
  @NotNull
  
  public SModuleReference getModuleReference() {

    return myModuleReference;
  }

  

  
  @Nullable
  public ModuleDescriptor getModuleDescriptor() {
    assertCanRead();

    return null;
  }

  
  public final void setModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    assertCanChange();
    doSetModuleDescriptor(moduleDescriptor);
    setChanged();
    reloadAfterDescriptorChange();
    fireChanged();
    dependenciesChanged();
  }

  
  protected void doSetModuleDescriptor(ModuleDescriptor moduleDescriptor) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setChanged() {
    assertCanChange();
    myChanged = true;
  }

  @Override
  public void save() {
    assertCanChange();
    validateLanguageVersions();
    myChanged = false;
  }

  

  @Nullable
  public Dependency addDependency(@NotNull SModuleReference moduleRef, boolean reexport) {
    assertCanChange();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return null;
    for (Dependency dep : descriptor.getDependencies()) {
      if (!EqualUtil.equals(dep.getModuleRef(), moduleRef)) continue;

      if (reexport && !dep.isReexport()) {
        dep.setReexport(true);
        dependenciesChanged();
        setChanged();
      }
      return dep;
    }

    Dependency dep = new Dependency();
    dep.setModuleRef(moduleRef);
    dep.setReexport(reexport);
    descriptor.getDependencies().add(dep);

    dependenciesChanged();
    setChanged();
    return dep;
  }

  public void removeDependency(@NotNull Dependency dependency) {
    assertCanChange();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return;
    if (!descriptor.getDependencies().contains(dependency)) return;

    descriptor.getDependencies().remove(dependency);

    dependenciesChanged();
    setChanged();
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void addUsedLanguage(SModuleReference langRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void removeUsedLanguage(SModuleReference langRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void addUsedDevkit(SModuleReference devkitRef) {
    
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public void removeUsedDevkit(SModuleReference devkitRef) {
    
  }

  

  
  @Deprecated
  public final Collection<SModuleReference> getUsedLanguagesReferences() {
    assertCanRead();
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return Collections.emptySet();
    return Collections.unmodifiableCollection(descriptor.getUsedLanguages());
  }

  

  
  
  protected void updatePackagedDescriptor() {
    
    
    
    

    
    
    
    

    if (!isPackaged()) return;

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) return;
    DeploymentDescriptor deplDescriptor = descriptor.getDeploymentDescriptor();
    if (deplDescriptor == null) return;

    final IFile bundleHomeFile = FileSystem.getInstance().getBundleHome(getDescriptorFile());
    if (bundleHomeFile == null) return;

    IFile bundleParent = bundleHomeFile.getParent();
    if (bundleParent == null || !bundleParent.exists()) return;

    IFile sourcesDescriptorFile = ModulesMiner.getRealDescriptorFile(getDescriptorFile().getPath(), deplDescriptor);
    if (sourcesDescriptorFile == null) {
      
      assert descriptor instanceof DeploymentDescriptor;
    } else {
      assert !(descriptor instanceof DeploymentDescriptor);
    }

    
    if (sourcesDescriptorFile != null) {
      
      
      
      descriptor.getAdditionalJavaStubPaths().clear();

      
      List<ModelRootDescriptor> toRemove = new ArrayList<ModelRootDescriptor>();
      List<ModelRootDescriptor> toAdd = new ArrayList<ModelRootDescriptor>();
      for (ModelRootDescriptor rootDescriptor : descriptor.getModelRootDescriptors()) {
        String rootDescriptorType = rootDescriptor.getType();
        if (rootDescriptorType.equals(PersistenceRegistry.JAVA_CLASSES_ROOT)) {
          
          String pathElement = rootDescriptor.getMemento().get("path");
          boolean update = false;
          Memento newMemento = new MementoImpl();
          if (pathElement != null) {
            
            String convertedPath = convertPath(pathElement, bundleHomeFile, sourcesDescriptorFile, descriptor);

            if (convertedPath != null) {
              newMemento.put("path", convertedPath);
              update = true;
            }
          } else {
            
            String contentPath = rootDescriptor.getMemento().get("contentPath");
            List<String> paths = new LinkedList<String>();
            for (Memento sourceRoot : rootDescriptor.getMemento().getChildren("sourceRoot")) {
              paths.add(contentPath + File.separator + sourceRoot.get("location"));
            }
            newMemento.put("contentPath", bundleParent.getPath());
            Memento newMementoChild = newMemento.createChild("sourceRoot");
            for (String path : paths) {
              String convertedPath = convertPath(path, bundleHomeFile, sourcesDescriptorFile, descriptor);
              if (convertedPath != null) {
                newMementoChild.put("location", convertedPath.replace(newMemento.get("contentPath"), ""));
                update = true;
              }
            }
          }
          if (update) toAdd.add(new ModelRootDescriptor(rootDescriptorType, newMemento));
          toRemove.add(rootDescriptor);
        }
      }
      descriptor.getModelRootDescriptors().removeAll(toRemove);
      descriptor.getModelRootDescriptors().addAll(toAdd);
    }

    
    for (String jarFile : deplDescriptor.getLibraries()) {
      IFile jar = jarFile.startsWith("/")
          ? FileSystem.getInstance().getFileByPath(PathManager.getHomePath() + jarFile)
          : bundleParent.getDescendant(jarFile);
      if (jar.exists()) {
        String path = jar.getPath();
        descriptor.getAdditionalJavaStubPaths().add(path);
        descriptor.getModelRootDescriptors().add(ModelRootDescriptor.getJavaStubsModelRoot(path));
      }
    }
  }

  
  @Nullable
  private String convertPath(String originalPath, IFile bundleHome, IFile sourcesDescriptorFile, ModuleDescriptor descriptor) {
    MacroHelper macroHelper = MacrosFactory.forModuleFile(sourcesDescriptorFile);

    String canonicalPath = FileUtil.getCanonicalPath(originalPath).toLowerCase();

    
    String suffix = descriptor.getCompileInMPS() ? CLASSES_GEN : CLASSES;
    if (canonicalPath.endsWith(suffix)) {
      
      String classes = macroHelper.expandPath("${module}/" + suffix);
      if (FileUtil.getCanonicalPath(classes).equalsIgnoreCase(canonicalPath)) {
        return bundleHome.getPath();
      }
    } else if (FileUtil.getCanonicalPath(bundleHome.getPath()).equalsIgnoreCase(canonicalPath)) {
      return bundleHome.getPath();
    }

    
    String mpsHomeLibPath = FileUtil.getCanonicalPath(PathManager.getHomePath() + File.separator + "lib").toLowerCase();
    if (canonicalPath.startsWith(mpsHomeLibPath)) {
      return canonicalPath;
    }

    if (MacrosFactory.containsNonMPSMacros(macroHelper.shrinkPath(originalPath))) {
      return originalPath;
    } else {
      
      return null;
    }
  }




  @Override
  public Iterable<ModelRoot> getModelRoots() {
    
    assertCanRead();
    return Collections.unmodifiableCollection(mySModelRoots);
  }

  protected void reloadAfterDescriptorChange() {
    initFacetsAndModels();
  }

  private void initFacetsAndModels() {
    updatePackagedDescriptor();
    updateFacets();
    updateModelsSet();
  }

  protected void collectFacetTypes(Set<String> types) {
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return;
    }

    types.addAll(FacetsFacade.getInstance().getApplicableFacetTypes(
        new TranslatingIterator<SModuleReference, String>(descriptor.getUsedLanguages().iterator()) {
          @Override
          protected String translate(SModuleReference node) {
            return node.getModuleName();
          }
        }));

    types.add(JavaModuleFacet.FACET_TYPE);
  }

  protected ModuleFacetBase setupFacet(ModuleFacetBase facet, Memento memento) {
    if (!facet.setModule(this)) {
      return null;
    }
    facet.load(memento != null ? memento : new MementoImpl());
    facet.attach();
    return facet;
  }

  protected void updateFacets() {
    assertCanChange();

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return;
    }

    for (ModuleFacetBase facet : myFacets) {
      facet.dispose();
    }
    myFacets.clear();

    Map<String, Memento> config = new HashMap<String, Memento>();
    for (ModuleFacetDescriptor facetDescriptors : descriptor.getModuleFacetDescriptors()) {
      config.put(facetDescriptors.getType(), facetDescriptors.getMemento());
    }

    Set<String> types = new HashSet<String>();
    collectFacetTypes(types);
    types.addAll(config.keySet());

    for (String facetType : types) {
      FacetFactory factory = FacetsFacade.getInstance().getFacetFactory(facetType);
      if (factory == null) {
        LOG.error("no registered factory for a facet with type=`" + facetType + "'");
        continue;
      }
      SModuleFacet newFacet = factory.create();
      if (!(newFacet instanceof ModuleFacetBase)) {
        LOG.error("broken facet factory: " + factory.getClass().getName());
        continue;
      }

      ModuleFacetBase facet = (ModuleFacetBase) newFacet;
      Memento m = config.get(facetType);
      facet = setupFacet(facet, m);
      if (facet != null) {
        myFacets.add(facet);
      }
    }
  }

  public void onModuleLoad() {
    updateSModelReferences();
    updateModuleReferences();
  }

  @Override
  public boolean isReadOnly() {

    return isPackaged();
  }

  @Override
  public boolean isPackaged() {

    return getModuleSourceDir() == null || FileSystem.getInstance().isPackaged(getModuleSourceDir());
  }

  
  public IFile getModuleSourceDir() {
    return myDescriptorFile != null ? myDescriptorFile.getParent() : null;
  }

  public IFile getDescriptorFile() {

    return myDescriptorFile;
  }

  public void rename(String newName) {
    
    for (SModel m : getModels()) {
      if (m.isReadOnly()) continue;
      if (!m.getModelName().startsWith(getModuleName() + ".")) continue;
      if (!(m instanceof EditableSModel)) continue;

      ((EditableSModel) m).rename(newName + m.getModelName().substring(getModuleName().length()), true);
    }

    
    getRepository().saveAll();

    ModuleDescriptor descriptor = getModuleDescriptor();
    if (myDescriptorFile != null) {
      myDescriptorFile.rename(newName + "." + FileUtil.getExtension(myDescriptorFile.getName()));
    }

    descriptor.setNamespace(newName);
    setModuleDescriptor(descriptor);
  }

  @NotNull
  public SearchScope getScope() {
    assertCanRead();
    return myScope;
  }

  @Override
  public void attach(@NotNull SRepository repository) {
    super.attach(repository);
    if (myDescriptorFile != null) {
      FileSystem.getInstance().addListener(this);
    }
    initFacetsAndModels();
  }

  @Nullable
  @Override
  public IFile getFileToListen() {
    return myDescriptorFile;
  }

  @Override
  public Iterable<FileSystemListener> getListenerDependencies() {
    List<FileSystemListener> listeners = new ArrayList<FileSystemListener>();
    for (MPSModuleOwner owner : MPSModuleRepository.getInstance().getOwners(this)) {
      if (owner instanceof FileSystemListener) {
        listeners.add((FileSystemListener) owner);
      }
    }
    return listeners.isEmpty() ? null : listeners;
  }

  @Override
  public void update(ProgressMonitor monitor, FileSystemEvent event) {
    assertCanChange();
    for (IFile file : event.getRemoved()) {
      if (file.equals(myDescriptorFile)) {
        ModuleRepositoryFacade.getInstance().removeModuleForced(this);
        return;
      }
    }
    for (IFile file : event.getChanged()) {
      if (file.equals(myDescriptorFile)) {
        SModuleOperations.reloadFromDisk(this);
        return;
      }
    }
  }

  @Override
  public String toString() {
    String namespace = getModuleName();
    return namespace + " [module]";
  }

  
  @Deprecated
  public String getName() {
    return getModuleName();
  }

  @Override
  public void dispose() {
    assertCanChange();
    LOG.trace("Disposing the module " + this);
    FileSystem.getInstance().removeListener(this);
    for (ModuleFacetBase f : myFacets) {
      f.dispose();
    }
    myFacets.clear();
    for (ModelRoot m : mySModelRoots) {
      ((ModelRootBase) m).dispose();
    }
    mySModelRoots.clear();
    super.dispose();
  }

  public List<String> getSourcePaths() {
    assertCanRead();
    return new ArrayList<String>(SModuleOperations.getAllSourcePaths(this));
  }

  public void updateModelsSet() {
    doUpdateModelsSet();
  }

  protected Iterable<ModelRoot> loadRoots() {
    ModuleDescriptor descriptor = getModuleDescriptor();
    if (descriptor == null) {
      return Collections.emptyList();
    }

    List<ModelRoot> result = new ArrayList<ModelRoot>();
    for (ModelRootDescriptor modelRoot : descriptor.getModelRootDescriptors()) {
      try {
        ModelRootFactory modelRootFactory = PersistenceFacade.getInstance().getModelRootFactory(modelRoot.getType());
        if (modelRootFactory == null) {
          LOG.error("Unknown model root type: `" + modelRoot.getType() + "'. Requested by: " + this);
          continue;
        }

        ModelRoot root = modelRootFactory.create();
        root.load(modelRoot.getMemento());
        result.add(root);
      } catch (Exception e) {
        LOG.error("Error loading models from root with type: `" + modelRoot.getType() + "'. Requested by: " + this, e);
      }
    }
    return result;
  }

  private void doUpdateModelsSet() {
    assertCanChange();

    for (SModel model : getModels()) {
      if (model instanceof EditableSModel && ((EditableSModel) model).isChanged()) {
        LOG.error(
            "Trying to reload module " + getModuleName() + " which contains a non-saved model" +
                model.getModelName() + "To prevent data loss, MPS will not update models in this module. " +
                "Please save your work and restart MPS. See MPS-18743 for details."
        );
        return;
      }
    }

    Set<ModelRoot> toRemove = new HashSet<ModelRoot>(mySModelRoots);
    Set<ModelRoot> toUpdate = new HashSet<ModelRoot>(mySModelRoots);
    Set<ModelRoot> toAttach = new HashSet<ModelRoot>();

    for (ModelRoot root : loadRoots()) {
      try {
        if (mySModelRoots.contains(root)) {
          toRemove.remove(root);
        } else {
          toAttach.add(root);
        }
      } catch (Exception e) {
        LOG.error("Error loading models from root `" + root.getPresentation() + "'. Requested by: " + this, e);
      }
    }
    toUpdate.removeAll(toRemove);

    for (ModelRoot modelRoot : toRemove) {
      ((ModelRootBase) modelRoot).dispose();
    }
    mySModelRoots.removeAll(toRemove);
    for (ModelRoot modelRoot : toAttach) {
      ModelRootBase rootBase = (ModelRootBase) modelRoot;
      rootBase.setModule(this);
      mySModelRoots.add(modelRoot);
      rootBase.attach();
    }
    for (ModelRoot modelRoot : toUpdate) {
      ((ModelRootBase) modelRoot).update();
    }
  }

  public static void handleReadProblem(AbstractModule module, Exception e, boolean isInConflict) {
    SuspiciousModelHandler.getHandler().handleSuspiciousModule(module, isInConflict);
    LOG.error(e.getMessage());
    e.printStackTrace();
  }

  public void updateSModelReferences() {
    ModuleDescriptor moduleDescriptor = getModuleDescriptor();
    if (moduleDescriptor == null) return;
    if (moduleDescriptor.updateModelRefs()) {
      setChanged();
    }
  }

  public void updateModuleReferences() {
    ModuleDescriptor moduleDescriptor = getModuleDescriptor();
    if (moduleDescriptor == null) return;
    if (moduleDescriptor.updateModuleRefs()) {
      setChanged();
    }
  }

  protected void dependenciesChanged() {
    

    
    
    

    

    myScope.invalidateCaches();
  }

  protected ModuleDescriptor loadDescriptor() {
    return null;
  }

  @Override
  public boolean isChanged() {
    return myChanged;
  }

  @Nullable
  @Override
  public <T extends SModuleFacet> T getFacet(Class<T> clazz) {
    for (SModuleFacet facet : getFacets()) {
      if (clazz.isInstance(facet)) {
        return (T) facet;
      }
    }
    return null;
  }

  @Override
  public Iterable<SModuleFacet> getFacets() {
    return Collections.<SModuleFacet>unmodifiableSet(myFacets);
  }

  public class ModuleScope extends DefaultScope {
    protected ModuleScope() {
    }

    public AbstractModule getModule() {
      return AbstractModule.this;
    }

    @Override
    protected Set<SModule> getInitialModules() {
      Set<SModule> result = new HashSet<SModule>();
      result.add(AbstractModule.this);
      return result;
    }

    @Override
    protected Set<Language> getInitialUsedLanguages() {
      HashSet<Language> result = new HashSet<Language>();
      for (SLanguage l : AbstractModule.this.getUsedLanguages()) {
        SModule langModule = l.getSourceModule();
        if (langModule instanceof Language) {
          result.add((Language) langModule);
        }
      }
      if (AbstractModule.this instanceof Language) {
        result.add((Language) AbstractModule.this);
        
        result.add(ModuleRepositoryFacade.getInstance().getModule(BootstrapLanguages.descriptorLanguageRef(), Language.class));
      }
      if (AbstractModule.this instanceof Generator) {
        result.add(((Generator) AbstractModule.this).getSourceLanguage());
      }
      return result;
    }

    public String toString() {
      return "Scope of module " + AbstractModule.this;
    }
  }

  public IFile getOutputPath() {
    return ProjectPathUtil.getGeneratorOutputPath(getModuleSourceDir(), getModuleDescriptor());
  }

  @Deprecated
  public final String getGeneratorOutputPath() {
    IFile outputPath = getOutputPath();
    return outputPath != null ? outputPath.getPath() : null;
  }

  @Deprecated
  public final String getTestsGeneratorOutputPath() {
    TestsFacet testsFacet = this.getFacet(TestsFacet.class);
    if (testsFacet == null) {
      return null;
    }
    IFile testsOutputPath = testsFacet.getTestsOutputPath();
    if (testsOutputPath == null) {
      return null;
    }
    return testsOutputPath.getPath();
  }

  public void validateLanguageVersions() {
    assertCanChange();
    ModuleDescriptor md = getModuleDescriptor();
    Map<SLanguage, Integer> oldLanguageVersions = md.getLanguageVersions();
    Map<SLanguage, Integer> newLanguageVersions = new HashMap<SLanguage, Integer>();
    if (!md.hasLanguageVersions()) {
      for (SLanguage lang : getAllUsedLanguages()) {
        newLanguageVersions.put(lang, 0);
      }
      md.setHasLanguageVersions(true);
    } else {
      for (SLanguage lang : getAllUsedLanguages()) {
        if (oldLanguageVersions.containsKey(lang)) {
          newLanguageVersions.put(lang, oldLanguageVersions.get(lang));
        } else {
          newLanguageVersions.put(lang, lang.getLanguageVersion());
        }
      }
    }
    oldLanguageVersions.clear();
    oldLanguageVersions.putAll(newLanguageVersions);
  }

  @Override
  public int getUsedLanguageVersion(SLanguage usedLanguage) {
    Integer res = getModuleDescriptor().getLanguageVersions().get(usedLanguage);
    if (res == null) {
      LOG.error(
          "getUsedLanguageVersion can't find a version for language " + usedLanguage.getQualifiedName() +
              " in module " + getModuleName() + "." +
              " This can either mean that the language is not imported into this module or that " +
              "validateLanguageVersions was not called on this module in appropriate moment.",
          new Throwable());
      return usedLanguage.getLanguageVersion();
    }
    return res;
  }
}

<code block>
package jetbrains.mps.lang.textGen.structure;



import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.runtime.StaticScope;
import java.util.Collection;
import java.util.Arrays;
import org.jetbrains.annotations.Nullable;

public class StructureAspectDescriptor extends BaseStructureAspectDescriptor {

   final ConceptDescriptor myConceptAbstractAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).abstract_().create();
   final ConceptDescriptor myConceptAbstractTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier", "jetbrains.mps.lang.core.structure.InterfacePart").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL), MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a3afa8c0dL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x12509ddfaa98f128L)).abstract_().create();
   final ConceptDescriptor myConceptAbstractTextGenParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101c66e2c0bL)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101c66e2c0bL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x19796fa16a19888bL)).abstract_().staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptAppendOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AppendOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x120153077caL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1237306115446L, "part", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L), false, true, false)).children(new String[]{"part"}, new boolean[]{true}).alias("append", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptAttributedNodePart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AttributedNodePart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x7c096989aaf957c1L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).alias("attributedNode", "attributed node").create();
   final ConceptDescriptor myConceptBufferParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.BufferParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f65197df2L)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("buffer", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptCollectionAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.CollectionAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201527819cL)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237306003719L, "separator"), new ConceptDescriptorBuilder.Prop(1237983969951L, "withSeparator")).properties("separator", "withSeparator").childDescriptors(new ConceptDescriptorBuilder.Link(1237305945551L, "list", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"list"}, new boolean[]{false}).alias("$list{", "collection").create();
   final ConceptDescriptor myConceptConceptTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f3c776369L)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", "jetbrains.mps.lang.structure.structure.IConceptAspect").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L), MetaIdFactory.conceptId(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1233670257997L, "conceptDeclaration", MetaIdFactory.conceptId(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL), false)).references("conceptDeclaration").childDescriptors(new ConceptDescriptorBuilder.Link(7991274449437422201L, "extension", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x7bf48616723f681dL), true, false, false), new ConceptDescriptorBuilder.Link(1224137887853744062L, "encoding", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL), true, false, false), new ConceptDescriptorBuilder.Link(1233749296504L, "textGenBlock", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f412f8790L), false, false, false), new ConceptDescriptorBuilder.Link(45307784116711884L, "filename", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0xa0f73089d40b8eL), true, false, false)).children(new String[]{"extension", "encoding", "textGenBlock", "filename"}, new boolean[]{false, false, false, false}).create();
   final ConceptDescriptor myConceptConstantStringAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015288286L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237305576108L, "value"), new ConceptDescriptorBuilder.Prop(1237306361677L, "withIndent")).properties("value", "withIndent").alias("constant", "constant string").create();
   final ConceptDescriptor myConceptContextParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ContextParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60cd534bL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("context", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptDecreaseDepthOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4165704bL)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("decrease depth", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptEncodingDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8f93L)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L), MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).alias("encoding", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptEncodingDeclarationBase = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).interface_().create();
   final ConceptDescriptor myConceptEncodingLiteral = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingLiteral", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x63754d97e1c86b8cL)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL), MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(7166719696753421197L, "encoding")).properties("encoding").alias("encoding literal", "").create();
   final ConceptDescriptor myConceptExtensionDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x7bf48616723f681dL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).alias("extension", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptFilenameFunction = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.FilenameFunction", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0xa0f73089d40b8eL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).final_().alias("filename", "name of output file").create();
   final ConceptDescriptor myConceptFoundErrorOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.FoundErrorOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f7f7ff1bdL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1237470722868L, "text", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, false, false)).children(new String[]{"text"}, new boolean[]{false}).alias("found error", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptGenerateTextDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f412f8790L)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).alias("do generate text", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptIncreaseDepthOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f41648039L)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("increase depth", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptIndentBufferOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.IndentBufferOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b64a5c9L)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("indent buffer", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptLanguageTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b71f51fL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234781160172L, "baseTextGen", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b71f51fL), true)).references("baseTextGen").childDescriptors(new ConceptDescriptorBuilder.Link(1233922432965L, "operation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), true, true, false), new ConceptDescriptorBuilder.Link(1234526822589L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L), true, true, false)).children(new String[]{"operation", "function"}, new boolean[]{true, true}).create();
   final ConceptDescriptor myConceptNewLineAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NewLineAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015232fd0L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).alias("\\n", "new line").create();
   final ConceptDescriptor myConceptNodeAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NodeAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015251a28L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237306318654L, "withIndent")).properties("withIndent").childDescriptors(new ConceptDescriptorBuilder.Link(1237305790512L, "value", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"value"}, new boolean[]{false}).alias("${", "node or property").create();
   final ConceptDescriptor myConceptNodeParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NodeParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f411d576bL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("node", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptOperationCall = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.OperationCall", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4ba6faaaL)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234190664409L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), false)).references("function").childDescriptors(new ConceptDescriptorBuilder.Link(1234191323697L, "parameter", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, true, false)).children(new String[]{"parameter"}, new boolean[]{true}).create();
   final ConceptDescriptor myConceptOperationDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.OperationDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L)).super_("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).parents("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "jetbrains.mps.lang.core.structure.ImplementationWithStubPart").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x612410e32cf46136L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1234264079341L, "operationName")).properties("operationName").alias("new operation", "").create();
   final ConceptDescriptor myConceptReferenceAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x5fec1f33fd3007f8L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(4809320654438971908L, "uniqNameInFile")).properties("uniqNameInFile").childDescriptors(new ConceptDescriptorBuilder.Link(6911933836258445307L, "reference", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"reference"}, new boolean[]{false}).alias("$ref{", "reference").create();
   final ConceptDescriptor myConceptSimpleTextGenOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).abstract_().staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptStubOperationDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x2bacbf19e457bd3bL)).super_("jetbrains.mps.lang.textGen.structure.OperationDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L)).parents("jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault", "jetbrains.mps.lang.core.structure.ISuppressErrors", "jetbrains.mps.lang.core.structure.IStubForAnotherConcept").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x19796fa16a19888bL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2f16f1b357e19f43L), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x226fb4c3ba26d45L)).create();
   final ConceptDescriptor myConceptUtilityMethodCall = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.UtilityMethodCall", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6faa8c98L)).super_("jetbrains.mps.baseLanguage.structure.Expression").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL)).parents("jetbrains.mps.baseLanguage.structure.Expression").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234529163244L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L), false)).references("function").childDescriptors(new ConceptDescriptorBuilder.Link(1234529174917L, "parameter", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, true, false)).children(new String[]{"parameter"}, new boolean[]{true}).staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptUtilityMethodDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L)).super_("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).parents("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).alias("new private function", "").create();
   final ConceptDescriptor myConceptWithIndentOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.WithIndentOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11fd28e1146L)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1236188238861L, "list", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L), false, false, false)).children(new String[]{"list"}, new boolean[]{false}).alias("with indent {", "code block").staticScope(StaticScope.NONE).create();

  @Override
  public Collection<ConceptDescriptor> getDescriptors() {
    return Arrays.asList(myConceptAbstractAppendPart, myConceptAbstractTextGenDeclaration, myConceptAbstractTextGenParameter, myConceptAppendOperation, myConceptAttributedNodePart, myConceptBufferParameter, myConceptCollectionAppendPart, myConceptConceptTextGenDeclaration, myConceptConstantStringAppendPart, myConceptContextParameter, myConceptDecreaseDepthOperation, myConceptEncodingDeclaration, myConceptEncodingDeclarationBase, myConceptEncodingLiteral, myConceptExtensionDeclaration, myConceptFilenameFunction, myConceptFoundErrorOperation, myConceptGenerateTextDeclaration, myConceptIncreaseDepthOperation, myConceptIndentBufferOperation, myConceptLanguageTextGenDeclaration, myConceptNewLineAppendPart, myConceptNodeAppendPart, myConceptNodeParameter, myConceptOperationCall, myConceptOperationDeclaration, myConceptReferenceAppendPart, myConceptSimpleTextGenOperation, myConceptStubOperationDeclaration, myConceptUtilityMethodCall, myConceptUtilityMethodDeclaration, myConceptWithIndentOperation);
  }

  @Override
  @Nullable
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0kb, conceptFqName)) {
      case 0:
        return myConceptAbstractAppendPart;
      case 1:
        return myConceptAbstractTextGenDeclaration;
      case 2:
        return myConceptAbstractTextGenParameter;
      case 3:
        return myConceptAppendOperation;
      case 4:
        return myConceptAttributedNodePart;
      case 5:
        return myConceptBufferParameter;
      case 6:
        return myConceptCollectionAppendPart;
      case 7:
        return myConceptConceptTextGenDeclaration;
      case 8:
        return myConceptConstantStringAppendPart;
      case 9:
        return myConceptContextParameter;
      case 10:
        return myConceptDecreaseDepthOperation;
      case 11:
        return myConceptEncodingDeclaration;
      case 12:
        return myConceptEncodingDeclarationBase;
      case 13:
        return myConceptEncodingLiteral;
      case 14:
        return myConceptExtensionDeclaration;
      case 15:
        return myConceptFilenameFunction;
      case 16:
        return myConceptFoundErrorOperation;
      case 17:
        return myConceptGenerateTextDeclaration;
      case 18:
        return myConceptIncreaseDepthOperation;
      case 19:
        return myConceptIndentBufferOperation;
      case 20:
        return myConceptLanguageTextGenDeclaration;
      case 21:
        return myConceptNewLineAppendPart;
      case 22:
        return myConceptNodeAppendPart;
      case 23:
        return myConceptNodeParameter;
      case 24:
        return myConceptOperationCall;
      case 25:
        return myConceptOperationDeclaration;
      case 26:
        return myConceptReferenceAppendPart;
      case 27:
        return myConceptSimpleTextGenOperation;
      case 28:
        return myConceptStubOperationDeclaration;
      case 29:
        return myConceptUtilityMethodCall;
      case 30:
        return myConceptUtilityMethodDeclaration;
      case 31:
        return myConceptWithIndentOperation;
      default:
        return null;
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0kb = new String[]{"jetbrains.mps.lang.textGen.structure.AbstractAppendPart", "jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter", "jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.AttributedNodePart", "jetbrains.mps.lang.textGen.structure.BufferParameter", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.ContextParameter", "jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.EncodingDeclaration", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", "jetbrains.mps.lang.textGen.structure.FilenameFunction", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", "jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.IndentBufferOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.NodeParameter", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>
package jetbrains.mps.lang.textGen.editor;



import jetbrains.mps.openapi.editor.descriptor.EditorAspectDescriptor;
import java.util.Collection;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import java.util.Arrays;
import java.util.Collections;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditorComponent;

public class EditorAspectDescriptorImpl implements EditorAspectDescriptor {

  public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {
    switch (Arrays.binarySearch(stringSwitchCases_xbvbvu_a0a0b, descriptor.getConceptFqName())) {
      case 0:
        return Collections.<ConceptEditor>singletonList(new AppendOperation_Editor());
      case 1:
        return Collections.<ConceptEditor>singletonList(new AttributedNodePart_Editor());
      case 2:
        return Collections.<ConceptEditor>singletonList(new CollectionAppendPart_Editor());
      case 3:
        return Collections.<ConceptEditor>singletonList(new ConceptTextGenDeclaration_Editor());
      case 4:
        return Collections.<ConceptEditor>singletonList(new ConstantStringAppendPart_Editor());
      case 5:
        return Collections.<ConceptEditor>singletonList(new EncodingLiteral_Editor());
      case 6:
        return Collections.<ConceptEditor>singletonList(new FoundErrorOperation_Editor());
      case 7:
        return Collections.<ConceptEditor>singletonList(new LanguageTextGenDeclaration_Editor());
      case 8:
        return Collections.<ConceptEditor>singletonList(new NewLineAppendPart_Editor());
      case 9:
        return Collections.<ConceptEditor>singletonList(new NodeAppendPart_Editor());
      case 10:
        return Collections.<ConceptEditor>singletonList(new OperationCall_Editor());
      case 11:
        return Collections.<ConceptEditor>singletonList(new OperationDeclaration_Editor());
      case 12:
        return Collections.<ConceptEditor>singletonList(new ReferenceAppendPart_Editor());
      case 13:
        return Collections.<ConceptEditor>singletonList(new SimpleTextGenOperation_Editor());
      case 14:
        return Collections.<ConceptEditor>singletonList(new StubOperationDeclaration_Editor());
      case 15:
        return Collections.<ConceptEditor>singletonList(new UtilityMethodCall_Editor());
      case 16:
        return Collections.<ConceptEditor>singletonList(new UtilityMethodDeclaration_Editor());
      case 17:
        return Collections.<ConceptEditor>singletonList(new WithIndentOperation_Editor());
      default:
    }
    return Collections.<ConceptEditor>emptyList();
  }
  public Collection<ConceptEditorComponent> getEditorComponents(ConceptDescriptor descriptor, String editorComponentId) {
    return Collections.<ConceptEditorComponent>emptyList();
  }


  private static String[] stringSwitchCases_xbvbvu_a0a0b = new String[]{"jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.AttributedNodePart", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>
package jetbrains.mps.lang.textGen.editor;



import jetbrains.mps.nodeEditor.DefaultNodeEditor;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.openapi.editor.style.Style;
import jetbrains.mps.editor.runtime.style.StyleImpl;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.baseLanguage.editor.BaseLanguageStyle_StyleSheet;

public class AttributedNodePart_Editor extends DefaultNodeEditor {
  public EditorCell createEditorCell(EditorContext editorContext, SNode node) {
    return this.createCollection_x8rx6f_a(editorContext, node);
  }
  private EditorCell createCollection_x8rx6f_a(EditorContext editorContext, SNode node) {
    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);
    editorCell.setCellId("Collection_x8rx6f_a");
    editorCell.setBig(true);
    editorCell.addEditorCell(this.createConstant_x8rx6f_a0(editorContext, node));
    editorCell.addEditorCell(this.createConstant_x8rx6f_b0(editorContext, node));
    editorCell.addEditorCell(this.createConstant_x8rx6f_c0(editorContext, node));
    return editorCell;
  }
  private EditorCell createConstant_x8rx6f_a0(EditorContext editorContext, SNode node) {
    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, "${");
    editorCell.setCellId("Constant_x8rx6f_a0");
    Style style = new StyleImpl();
    TextGenStyles_StyleSheet.apply_AppendPart(style, editorCell);
    style.set(StyleAttributes.EDITABLE, 0, false);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createConstant_x8rx6f_b0(EditorContext editorContext, SNode node) {
    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, "attributed node");
    editorCell.setCellId("Constant_x8rx6f_b0");
    Style style = new StyleImpl();
    BaseLanguageStyle_StyleSheet.apply_KeyWord(style, editorCell);
    style.set(StyleAttributes.EDITABLE, 0, false);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
  private EditorCell createConstant_x8rx6f_c0(EditorContext editorContext, SNode node) {
    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, "}$");
    editorCell.setCellId("Constant_x8rx6f_c0");
    Style style = new StyleImpl();
    TextGenStyles_StyleSheet.apply_AppendPart(style, editorCell);
    style.set(StyleAttributes.EDITABLE, 0, false);
    editorCell.getStyle().putAll(style);
    editorCell.setDefaultText("");
    return editorCell;
  }
}

<code block>
package jetbrains.mps.lang.textGen.behavior;




public class AttributedNodePart_BehaviorDescriptor extends AbstractAppendPart_BehaviorDescriptor {
  public AttributedNodePart_BehaviorDescriptor() {
  }
  @Override
  public String getConceptFqName() {
    return "jetbrains.mps.lang.textGen.structure.AttributedNodePart";
  }
}

<code block>
package jetbrains.mps.lang.textGen.behavior;



import jetbrains.mps.smodel.runtime.BehaviorDescriptor;
import java.util.Arrays;
import jetbrains.mps.smodel.runtime.interpreted.BehaviorAspectInterpreted;

public class BehaviorAspectDescriptor implements jetbrains.mps.smodel.runtime.BehaviorAspectDescriptor {
  public BehaviorAspectDescriptor() {
  }
  public BehaviorDescriptor getDescriptor(String fqName) {
    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0b, fqName)) {
      case 4:
        return new ConceptTextGenDeclaration_BehaviorDescriptor();
      case 19:
        return new NodeParameter_BehaviorDescriptor();
      case 13:
        return new GenerateTextDeclaration_BehaviorDescriptor();
      case 14:
        return new IncreaseDepthOperation_BehaviorDescriptor();
      case 7:
        return new DecreaseDepthOperation_BehaviorDescriptor();
      case 15:
        return new IndentBufferOperation_BehaviorDescriptor();
      case 16:
        return new LanguageTextGenDeclaration_BehaviorDescriptor();
      case 21:
        return new OperationDeclaration_BehaviorDescriptor();
      case 20:
        return new OperationCall_BehaviorDescriptor();
      case 6:
        return new ContextParameter_BehaviorDescriptor();
      case 2:
        return new BufferParameter_BehaviorDescriptor();
      case 25:
        return new UtilityMethodDeclaration_BehaviorDescriptor();
      case 24:
        return new UtilityMethodCall_BehaviorDescriptor();
      case 12:
        return new FoundErrorOperation_BehaviorDescriptor();
      case 26:
        return new WithIndentOperation_BehaviorDescriptor();
      case 17:
        return new NewLineAppendPart_BehaviorDescriptor();
      case 18:
        return new NodeAppendPart_BehaviorDescriptor();
      case 3:
        return new CollectionAppendPart_BehaviorDescriptor();
      case 5:
        return new ConstantStringAppendPart_BehaviorDescriptor();
      case 0:
        return new AppendOperation_BehaviorDescriptor();
      case 10:
        return new ExtensionDeclaration_BehaviorDescriptor();
      case 22:
        return new ReferenceAppendPart_BehaviorDescriptor();
      case 9:
        return new EncodingLiteral_BehaviorDescriptor();
      case 8:
        return new EncodingDeclaration_BehaviorDescriptor();
      case 11:
        return new FilenameFunction_BehaviorDescriptor();
      case 23:
        return new StubOperationDeclaration_BehaviorDescriptor();
      case 1:
        return new AttributedNodePart_BehaviorDescriptor();
      default:
        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);
    }
  }
  private static String[] stringSwitchCases_846f5o_a0a0b = new String[]{"jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.AttributedNodePart", "jetbrains.mps.lang.textGen.structure.BufferParameter", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.ContextParameter", "jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.EncodingDeclaration", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", "jetbrains.mps.lang.textGen.structure.FilenameFunction", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", "jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.IndentBufferOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.NodeParameter", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>

package jetbrains.mps.textGen;

import jetbrains.mps.messages.IMessage;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.text.BufferSnapshot;
import jetbrains.mps.text.MissingTextGenDescriptor;
import jetbrains.mps.text.impl.TextGenSupport;
import jetbrains.mps.text.impl.TextGenTransitionContext;
import jetbrains.mps.text.impl.TraceInfoCollector;
import jetbrains.mps.text.rt.TextGenDescriptor;
import jetbrains.mps.textgen.trace.ScopePositionInfo;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.UnitPositionInfo;
import jetbrains.mps.util.EncodingUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


@Deprecated
@ToRemove(version = 3.3)
public class TextGen {
  public static final String PACKAGE_NAME = "PACKAGE_NAME";
  public static final String DEPENDENCY = "DEPENDENCY";
  public static final String EXTENDS = "EXTENDS";
  public static final String OUTPUT_ENCODING = "OUTPUT_ENCODING";
  public static final String ROOT_NODE = "ROOT_NODE";

  public static final String NO_TEXTGEN = "\33\33NO TEXTGEN\33\33";

  
  public static TextGenerationResult generateText(SNode node) {
    return generateText(node, false, false, null);
  }

  public static boolean canGenerateTextFor(SNode node) {
    return !(getTextGenForNode(node) instanceof MissingTextGenDescriptor);
  }

  public static String getExtension(@NotNull SNode node) {
    return getLegacyTextGen(node).getExtension(node);
  }

  public static String getFileName(@NotNull SNode node) {
    final SNodeTextGen tg = getLegacyTextGen(node);
    String fname = tg.getFilename(node);
    String extension = tg.getExtension(node);
    return (extension == null) ? fname : fname + '.' + extension;
  }

  public static TextGenerationResult generateText(SNode node, boolean failIfNoTextgen, boolean withDebugInfo, @Nullable StringBuilder[] buffers) {
    if (canGenerateTextFor(node)) {
      return generateText(node, withDebugInfo, buffers);
    } else if (failIfNoTextgen) {
      String error = "Can't generate text from " + node;
      Message m = new Message(MessageKind.ERROR, error);
      if (node != null) {
        m.setHintObject(node.getReference());
      }
      return new TextGenerationResult(node, NO_TEXTGEN, true, Collections.<IMessage>singleton(m), null, null, null, null);
    } else {
      return new TextGenerationResult(node, NO_TEXTGEN, false, Collections.<IMessage>emptyList(), null, null, null, null);
    }
  }

  public static TextGenerationResult generateText(SNode node, boolean withDebugInfo, @Nullable StringBuilder[] buffers) {
    TextGenBuffer buffer = new TextGenBuffer(withDebugInfo, buffers);
    buffer.putUserObject(PACKAGE_NAME, jetbrains.mps.util.SNodeOperations.getModelLongName(node.getModel()));
    buffer.putUserObject(ROOT_NODE, node);
    final TraceInfoCollector tic;
    if (withDebugInfo)  {
      tic = new TraceInfoCollector();
      TraceInfoGenerationUtil.setTraceInfoCollector(buffer, tic);
    } else {
      tic = null;
    }

    appendNodeText(buffer, node);

    
    Map<SNode, TraceablePositionInfo> positionInfo = null;
    Map<SNode, ScopePositionInfo> scopeInfo = null;
    Map<SNode, UnitPositionInfo> unitInfo = null;
    final BufferSnapshot textSnapshot = buffer.getTextSnapshot();
    if (tic != null) {
      tic.populatePositions(textSnapshot);
      
      positionInfo = tic.getTracePositions();
      scopeInfo = tic.getScopePositions();
      unitInfo = tic.getUnitPositions();
    }

    
    List<String> dependencies = getUserObjectCollection(DEPENDENCY, node, buffer, (Set<String>) buffer.getUserObject(EXTENDS));
    List<String> extend = getUserObjectCollection(EXTENDS, node, buffer, null);

    Map<String, List<String>> deps = new HashMap<String, List<String>>(2);
    deps.put(DEPENDENCY, dependencies);
    deps.put(EXTENDS, extend);

    final String bufferOutcome = textSnapshot.getText().toString();
    Object result = bufferOutcome;
    String outputEncoding = (String) buffer.getUserObject(OUTPUT_ENCODING);
    if (outputEncoding != null) {
      if (outputEncoding.equals("binary")) {
        result = EncodingUtil.decodeBase64(bufferOutcome);
      } else {
        try {
          result = EncodingUtil.encode(bufferOutcome, outputEncoding);
        } catch (IOException ex) {
          buffer.foundError("cannot encode the output stream", null, ex);
        }
      }
    }
    return new TextGenerationResult(node, result, buffer.hasErrors(), buffer.problems(), positionInfo, scopeInfo, unitInfo, deps);
  }

  private static void appendNodeText(TextGenBuffer buffer, SNode node) {
    if (node == null) {
      buffer.append("???");
      return;
    }

    TextGenSupport tgs = new TextGenSupport(new TextGenTransitionContext(node, buffer));
    tgs.appendNode(node);
  }

  
  @NotNull
   static TextGenDescriptor getTextGenForNode(@NotNull SNode node) {
    return TextGenRegistry.getInstance().getTextGenDescriptor(node);
  }

  
  private static SNodeTextGen getLegacyTextGen(@NotNull SNode node) {
    try {
      Class<? extends SNodeTextGen> textgenClass = TextGenRegistry.getInstance().getLegacyTextGenClass(node.getConcept());
      if (textgenClass != null && SNodeTextGen.class.isAssignableFrom(textgenClass)) {
        return textgenClass.newInstance();
      }
    } catch (InstantiationException ex) {
      Logger.getLogger(TextGen.class).error("Failed to instantiate textgen", ex);
      
    } catch (IllegalAccessException ex) {
      Logger.getLogger(TextGen.class).error("Failed to instantiate textgen", ex);
      
    }
    return new DefaultTextGen();
  }

  private static List<String> getUserObjectCollection(String key, SNode node, TextGenBuffer buffer, Set<String> skipSet) {
    Set<String> dependenciesObject = (Set<String>) buffer.getUserObject(key);
    final String nodeFQName = NameUtil.nodeFQName(node);
    if (dependenciesObject != null) {
      List<String> dependencies = new ArrayList<String>(dependenciesObject.size());
      for (String dependObj : dependenciesObject) {
        if (dependObj == null || nodeFQName.equals(dependObj)) {
          continue;
        }
        if (skipSet != null && skipSet.contains(dependObj)) {
          continue;
        }
        dependencies.add(dependObj);
      }
      Collections.sort(dependencies);
      return dependencies;
    }
    return Collections.emptyList();
  }
}

<code block>

package jetbrains.mps.textGen;

import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.ModelDependencyScanner;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.smodel.adapter.ids.MetaIdHelper;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRegistryListener;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.structure.DescriptorUtils;
import jetbrains.mps.text.LegacyTextGenAdapter;
import jetbrains.mps.text.MissingTextGenDescriptor;
import jetbrains.mps.text.rt.TextGenAspectDescriptor;
import jetbrains.mps.text.rt.TextGenDescriptor;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.util.ImmediateParentConceptIterator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public class TextGenRegistry implements CoreComponent, LanguageRegistryListener {
  private static TextGenRegistry INSTANCE;

  private final Map<String, TextGenDescriptor> textGenDescriptors = new ConcurrentHashMap<String, TextGenDescriptor>();
  private final LanguageRegistry myLanguageRegistry;

  
  public TextGenRegistry(@NotNull LanguageRegistry languageRegistry) {
    myLanguageRegistry = languageRegistry;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myLanguageRegistry.addRegistryListener(this);
  }

  @Override
  public void dispose() {
    myLanguageRegistry.removeRegistryListener(this);
    INSTANCE = null;
  }

  public static TextGenRegistry getInstance() {
    return INSTANCE;
  }

  
  public boolean hasTextGen(@NotNull SNode node) {
    return !(getTextGenDescriptor(node.getConcept()) instanceof MissingTextGenDescriptor);
  }

  @NotNull
  public TextGenDescriptor getTextGenDescriptor(@Nullable SNode node) {
    if (node == null) {
      
      return new MissingTextGenDescriptor();
    }
    return getTextGenDescriptor(node.getConcept());
  }

  private TextGenDescriptor getTextGenDescriptor(SConcept concept) {
    final String fqName = concept.getQualifiedName();

    TextGenDescriptor descriptor = textGenDescriptors.get(fqName);

    if (descriptor != null) {
      return descriptor;
    }

    
    
    
    
    for (SConcept next : new ImmediateParentConceptIterator(concept, SNodeUtil.concept_BaseConcept)) {
      TextGenAspectDescriptor textGenAspectDescriptor = getAspect(next);
      if (textGenAspectDescriptor == null) {
        continue;
      }
      descriptor = textGenAspectDescriptor.getDescriptor(MetaIdHelper.getConcept(next));
      if (descriptor != null) {
        break;
      }
    }

    if (descriptor == null) {
      
      
      final Class<? extends SNodeTextGen> legacyTextGenClass = getLegacyTextGenClass(concept);
      if (legacyTextGenClass != null) {
        return new LegacyTextGenAdapter(legacyTextGenClass);
      }
      descriptor = new MissingTextGenDescriptor();
    }

    textGenDescriptors.put(fqName, descriptor);

    return descriptor;
  }

  @Nullable
  private TextGenAspectDescriptor getAspect(SConcept concept) {
    LanguageRuntime languageRuntime = myLanguageRegistry.getLanguage(concept.getLanguage());
    if (languageRuntime == null) {
      
      Logger.getLogger(TextGenRegistry.class).warn(String.format("No language for concept %s, while looking for textgen descriptor.", concept));
      return null;
    } else {
      return languageRuntime.getAspect(TextGenAspectDescriptor.class);
    }
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public Class<? extends SNodeTextGen> getLegacyTextGenClass(SConcept c) {
    for (SConcept next : new ImmediateParentConceptIterator(c, SNodeUtil.concept_BaseConcept)) {
      String languageName = next.getLanguage().getQualifiedName();
      Language l = ModuleRepositoryFacade.getInstance().getModule(languageName, Language.class);
      String textgenClassname = LanguageAspect.TEXT_GEN.getAspectQualifiedClassName(next) + "_TextGen";
      Class<? extends SNodeTextGen> textgenClass = DescriptorUtils.getClassFromLanguage(textgenClassname, l);
      if (textgenClass != null) {
        return textgenClass;
      }
    }
    return null;
  }

  
  @NotNull
  public Collection<TextGenAspectDescriptor> getAspects(@NotNull SModel model) {
    
    
    
    ArrayList<TextGenAspectDescriptor> rv = new ArrayList<TextGenAspectDescriptor>(5);
    final ModelDependencyScanner modelScanner = new ModelDependencyScanner();
    modelScanner.crossModelReferences(false).usedLanguages(true).walk(model);
    for (SLanguage l : modelScanner.getUsedLanguages()) {
      final LanguageRuntime lr = myLanguageRegistry.getLanguage(l);
      if (lr == null) {
        
        continue;
      }
      final TextGenAspectDescriptor rtAspect = lr.getAspect(TextGenAspectDescriptor.class);
      if (rtAspect != null) {
        rv.add(rtAspect);
      }
    }
    return rv;
  }

  @Override
  public void beforeLanguagesUnloaded(Iterable<LanguageRuntime> languages) {
    
  }

  @Override
  public void afterLanguagesLoaded(Iterable<LanguageRuntime> languages) {
    textGenDescriptors.clear();
  }

}

<code block>

package jetbrains.mps.text.impl;

import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.text.TextArea;
import jetbrains.mps.text.TextMark;
import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.textGen.TextGen;
import jetbrains.mps.textGen.TextGenBuffer;
import jetbrains.mps.textGen.TextGenRegistry;
import jetbrains.mps.textGen.TraceInfoGenerationUtil;
import jetbrains.mps.textgen.trace.ScopePositionInfo;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.UnitPositionInfo;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SReference;

import java.util.List;


public final class TextGenSupport implements TextArea {
  private final TextGenContext myContext;
  private final TraceInfoCollector myTraceInfoCollector;

  public TextGenSupport(@NotNull TextGenContext context) {
    myContext = context;
    final TextGenBuffer buffer = ((TextGenTransitionContext) context).getLegacyBuffer();
    myTraceInfoCollector = TraceInfoGenerationUtil.getTraceInfoCollector(buffer);
  }

  public boolean needPositions() {
    return getTraceInfoCollector() != null;
  }

  public void createPositionInfo() {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void createScopeInfo( ) {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void createUnitInfo() {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void fillPositionInfo(String propertyString) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final TraceablePositionInfo pi = tic.createTracePosition(m, myContext.getPrimaryInput());
    pi.setPropertyString(propertyString);
  }

  public void fillScopeInfo(List<SNode> vars) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final ScopePositionInfo pi = tic.createScopePosition(m, myContext.getPrimaryInput());
    for (SNode var : vars) {
      if (var != null) {
        pi.addVarInfo(var);
      }
    }
  }

  public void fillUnitInfo(String unitName) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final UnitPositionInfo pi = tic.createUnitPosition(m, myContext.getPrimaryInput());
    pi.setUnitName(unitName);
    TraceInfoGenerationUtil.warnIfUnitNameInvalid(unitName, myContext.getPrimaryInput());
  }

  private TraceInfoCollector getTraceInfoCollector() {
    return myTraceInfoCollector;
  }

  public void appendAttributedNode() {
    final SNode currentNode = myContext.getPrimaryInput();
    if (!SNodeUtil.link_BaseConcept_smodelAttribute.equals(currentNode.getContainmentLink())) {
      throw new IllegalStateException("Attempt to reference attributed node from a non-attribute node");
    }
    SNode attributedNode = currentNode.getParent();
    boolean found = false;
    for (SNode attribute : attributedNode.getChildren(SNodeUtil.link_BaseConcept_smodelAttribute)) {
      if (attribute == currentNode) {
        found = true;
        break;
      }
      attributedNode = attribute;
    }
    assert found;
    
    
    doAppendNode(attributedNode);
  }

  public void appendNode(@Nullable SNode node) {
    if (node == null) {
      append("???");
      reportError("possible broken reference");
      return;
    }
    
    SNode n = node;
    for (SNode attribute : node.getChildren(SNodeUtil.link_BaseConcept_smodelAttribute)) {
      if (TextGenRegistry.getInstance().hasTextGen(attribute)) {
        n = attribute;
      }
    }
    doAppendNode(n);
  }

  private void doAppendNode(SNode node) {
    final TextGenBuffer buffer = getLegacyBuffer();
    TextGenRegistry.getInstance().getTextGenDescriptor(node).generateText(new TextGenTransitionContext(node, buffer));
  }

  
  public void reportError(String info) {
    String message = info != null ?
        "textgen error: '" + info + "' in " + SNodeOperations.getDebugText(myContext.getPrimaryInput()) :
        "textgen error in " + SNodeOperations.getDebugText(myContext.getPrimaryInput());
    getLegacyBuffer().foundError(message, myContext.getPrimaryInput(), null);
  }

  
  public void setEncoding(@Nullable String encoding) {
    getLegacyBuffer().putUserObject(TextGen.OUTPUT_ENCODING, encoding);
  }

  
  public void appendReferentText(SReference reference) {
    if (reference == null) {
      reportError("null reference");
      append("<err:null reference>");
      return;
    }

    String shortName;
    if (reference instanceof DynamicReference) {
      shortName = ((DynamicReference) reference).getResolveInfo();
      if (shortName.startsWith("[")) {
        
        shortName = shortName.substring(shortName.lastIndexOf("]") + 1).trim();
      } else {
        final SModelReference modelReference = reference.getTargetSModelReference();
        if (modelReference == null) {
          int lastDot = shortName.lastIndexOf('.');
          if (lastDot >= 0) {
            shortName = shortName.substring(lastDot + 1);
            if (shortName.indexOf('$') >= 0) {
              shortName = shortName.replace('$', '.');
            }
          }
        }
      }
    } else {
      SNode targetNode = reference.getTargetNode();
      if (targetNode == null) {
        reportError(String.format("Unknown target for role %s", reference.getRole()));
        append("???");
        return;
      }
      shortName = jetbrains.mps.util.SNodeOperations.getResolveInfo(targetNode);
    }
    append(shortName);
  }

  
  @ToRemove(version = 3.3)
  public TextGenBuffer getLegacyBuffer() {
    return ((TextGenTransitionContext) myContext).getLegacyBuffer();
  }

  
  

  @Override
  public TextArea append(CharSequence text) {
    return myContext.getBuffer().area().append(text);
  }

  @Override
  public TextArea newLine() {
    return myContext.getBuffer().area().newLine();
  }

  @Override
  public TextArea indent() {
    return myContext.getBuffer().area().indent();
  }

  @Override
  public TextArea increaseIndent() {
    return myContext.getBuffer().area().increaseIndent();
  }

  @Override
  public TextArea decreaseIndent() {
    return myContext.getBuffer().area().decreaseIndent();
  }

  @Override
  public int length() {
    return myContext.getBuffer().area().length();
  }
}

<code block>
package jetbrains.mps.lang.textGen.structure;



import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.runtime.StaticScope;
import java.util.Collection;
import java.util.Arrays;
import org.jetbrains.annotations.Nullable;

public class StructureAspectDescriptor extends BaseStructureAspectDescriptor {

   final ConceptDescriptor myConceptAbstractAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).abstract_().create();
   final ConceptDescriptor myConceptAbstractTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier", "jetbrains.mps.lang.core.structure.InterfacePart").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL), MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11a3afa8c0dL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x12509ddfaa98f128L)).abstract_().create();
   final ConceptDescriptor myConceptAbstractTextGenParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101c66e2c0bL)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101c66e2c0bL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x19796fa16a19888bL)).abstract_().staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptAppendOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.AppendOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x120153077caL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1237306115446L, "part", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L), false, true, false)).children(new String[]{"part"}, new boolean[]{true}).alias("append", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptBufferParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.BufferParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f65197df2L)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("buffer", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptCollectionAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.CollectionAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201527819cL)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237306003719L, "separator"), new ConceptDescriptorBuilder.Prop(1237983969951L, "withSeparator")).properties("separator", "withSeparator").childDescriptors(new ConceptDescriptorBuilder.Link(1237305945551L, "list", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"list"}, new boolean[]{false}).alias("$list{", "collection").create();
   final ConceptDescriptor myConceptConceptTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f3c776369L)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", "jetbrains.mps.lang.structure.structure.IConceptAspect").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L), MetaIdFactory.conceptId(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1233670257997L, "conceptDeclaration", MetaIdFactory.conceptId(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL), false)).references("conceptDeclaration").childDescriptors(new ConceptDescriptorBuilder.Link(7991274449437422201L, "extension", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x7bf48616723f681dL), true, false, false), new ConceptDescriptorBuilder.Link(1224137887853744062L, "encoding", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL), true, false, false), new ConceptDescriptorBuilder.Link(1233749296504L, "textGenBlock", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f412f8790L), false, false, false), new ConceptDescriptorBuilder.Link(45307784116711884L, "filename", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0xa0f73089d40b8eL), true, false, false)).children(new String[]{"extension", "encoding", "textGenBlock", "filename"}, new boolean[]{false, false, false, false}).create();
   final ConceptDescriptor myConceptConstantStringAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015288286L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237305576108L, "value"), new ConceptDescriptorBuilder.Prop(1237306361677L, "withIndent")).properties("value", "withIndent").alias("constant", "constant string").create();
   final ConceptDescriptor myConceptContextParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ContextParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60cd534bL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("context", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptDecreaseDepthOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4165704bL)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("decrease depth", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptEncodingDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8f93L)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L), MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).alias("encoding", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptEncodingDeclarationBase = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).interface_().create();
   final ConceptDescriptor myConceptEncodingLiteral = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.EncodingLiteral", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x63754d97e1c86b8cL)).super_("jetbrains.mps.lang.core.structure.BaseConcept").super_(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL)).parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase").parentIds(MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL), MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x10fd02ec599e8fbbL)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(7166719696753421197L, "encoding")).properties("encoding").alias("encoding literal", "").create();
   final ConceptDescriptor myConceptExtensionDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x7bf48616723f681dL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).alias("extension", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptFilenameFunction = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.FilenameFunction", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0xa0f73089d40b8eL)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).final_().alias("filename", "name of output file").create();
   final ConceptDescriptor myConceptFoundErrorOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.FoundErrorOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f7f7ff1bdL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1237470722868L, "text", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, false, false)).children(new String[]{"text"}, new boolean[]{false}).alias("found error", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptGenerateTextDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f412f8790L)).super_("jetbrains.mps.baseLanguage.structure.ConceptFunction").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).parents("jetbrains.mps.baseLanguage.structure.ConceptFunction").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x108bbca0f48L)).alias("do generate text", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptIncreaseDepthOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f41648039L)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("increase depth", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptIndentBufferOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.IndentBufferOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b64a5c9L)).super_("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).parents("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).alias("indent buffer", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptLanguageTextGenDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b71f51fL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f60f06a49L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234781160172L, "baseTextGen", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b71f51fL), true)).references("baseTextGen").childDescriptors(new ConceptDescriptorBuilder.Link(1233922432965L, "operation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), true, true, false), new ConceptDescriptorBuilder.Link(1234526822589L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L), true, true, false)).children(new String[]{"operation", "function"}, new boolean[]{true, true}).create();
   final ConceptDescriptor myConceptNewLineAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NewLineAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015232fd0L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).alias("\\n", "new line").create();
   final ConceptDescriptor myConceptNodeAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NodeAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x12015251a28L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1237306318654L, "withIndent")).properties("withIndent").childDescriptors(new ConceptDescriptorBuilder.Link(1237305790512L, "value", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"value"}, new boolean[]{false}).alias("${", "node or property").create();
   final ConceptDescriptor myConceptNodeParameter = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.NodeParameter", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f411d576bL)).super_("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).parents("jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f84e1988dL)).alias("node", "").staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptOperationCall = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.OperationCall", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4ba6faaaL)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234190664409L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), false)).references("function").childDescriptors(new ConceptDescriptorBuilder.Link(1234191323697L, "parameter", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, true, false)).children(new String[]{"parameter"}, new boolean[]{true}).create();
   final ConceptDescriptor myConceptOperationDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.OperationDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L)).super_("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).parents("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration", "jetbrains.mps.lang.core.structure.ImplementationWithStubPart").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x612410e32cf46136L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(1234264079341L, "operationName")).properties("operationName").alias("new operation", "").create();
   final ConceptDescriptor myConceptReferenceAppendPart = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x5fec1f33fd3007f8L)).super_("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).parents("jetbrains.mps.lang.textGen.structure.AbstractAppendPart").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x1201521c456L)).propertyDescriptors(new ConceptDescriptorBuilder.Prop(4809320654438971908L, "uniqNameInFile")).properties("uniqNameInFile").childDescriptors(new ConceptDescriptorBuilder.Link(6911933836258445307L, "reference", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), false, false, false)).children(new String[]{"reference"}, new boolean[]{false}).alias("$ref{", "reference").create();
   final ConceptDescriptor myConceptSimpleTextGenOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4153bc8cL)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).abstract_().staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptStubOperationDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x2bacbf19e457bd3bL)).super_("jetbrains.mps.lang.textGen.structure.OperationDeclaration").super_(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L)).parents("jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault", "jetbrains.mps.lang.core.structure.ISuppressErrors", "jetbrains.mps.lang.core.structure.IStubForAnotherConcept").parentIds(MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f4b80e9d3L), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x19796fa16a19888bL), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2f16f1b357e19f43L), MetaIdFactory.conceptId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x226fb4c3ba26d45L)).create();
   final ConceptDescriptor myConceptUtilityMethodCall = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.UtilityMethodCall", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6faa8c98L)).super_("jetbrains.mps.baseLanguage.structure.Expression").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL)).parents("jetbrains.mps.baseLanguage.structure.Expression").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL)).referenceDescriptors(new ConceptDescriptorBuilder.Ref(1234529163244L, "function", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L), false)).references("function").childDescriptors(new ConceptDescriptorBuilder.Link(1234529174917L, "parameter", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37f506fL), true, true, false)).children(new String[]{"parameter"}, new boolean[]{true}).staticScope(StaticScope.NONE).create();
   final ConceptDescriptor myConceptUtilityMethodDeclaration = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11f6f6a18e4L)).super_("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).parents("jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL)).alias("new private function", "").create();
   final ConceptDescriptor myConceptWithIndentOperation = new ConceptDescriptorBuilder("jetbrains.mps.lang.textGen.structure.WithIndentOperation", MetaIdFactory.conceptId(0xb83431fe5c8f40bcL, 0x8a3665e25f4dd253L, 0x11fd28e1146L)).super_("jetbrains.mps.baseLanguage.structure.Statement").super_(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).parents("jetbrains.mps.baseLanguage.structure.Statement").parentIds(MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b215L)).childDescriptors(new ConceptDescriptorBuilder.Link(1236188238861L, "list", MetaIdFactory.conceptId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L), false, false, false)).children(new String[]{"list"}, new boolean[]{false}).alias("with indent {", "code block").staticScope(StaticScope.NONE).create();

  @Override
  public Collection<ConceptDescriptor> getDescriptors() {
    return Arrays.asList(myConceptAbstractAppendPart, myConceptAbstractTextGenDeclaration, myConceptAbstractTextGenParameter, myConceptAppendOperation, myConceptBufferParameter, myConceptCollectionAppendPart, myConceptConceptTextGenDeclaration, myConceptConstantStringAppendPart, myConceptContextParameter, myConceptDecreaseDepthOperation, myConceptEncodingDeclaration, myConceptEncodingDeclarationBase, myConceptEncodingLiteral, myConceptExtensionDeclaration, myConceptFilenameFunction, myConceptFoundErrorOperation, myConceptGenerateTextDeclaration, myConceptIncreaseDepthOperation, myConceptIndentBufferOperation, myConceptLanguageTextGenDeclaration, myConceptNewLineAppendPart, myConceptNodeAppendPart, myConceptNodeParameter, myConceptOperationCall, myConceptOperationDeclaration, myConceptReferenceAppendPart, myConceptSimpleTextGenOperation, myConceptStubOperationDeclaration, myConceptUtilityMethodCall, myConceptUtilityMethodDeclaration, myConceptWithIndentOperation);
  }

  @Override
  @Nullable
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0jb, conceptFqName)) {
      case 0:
        return myConceptAbstractAppendPart;
      case 1:
        return myConceptAbstractTextGenDeclaration;
      case 2:
        return myConceptAbstractTextGenParameter;
      case 3:
        return myConceptAppendOperation;
      case 4:
        return myConceptBufferParameter;
      case 5:
        return myConceptCollectionAppendPart;
      case 6:
        return myConceptConceptTextGenDeclaration;
      case 7:
        return myConceptConstantStringAppendPart;
      case 8:
        return myConceptContextParameter;
      case 9:
        return myConceptDecreaseDepthOperation;
      case 10:
        return myConceptEncodingDeclaration;
      case 11:
        return myConceptEncodingDeclarationBase;
      case 12:
        return myConceptEncodingLiteral;
      case 13:
        return myConceptExtensionDeclaration;
      case 14:
        return myConceptFilenameFunction;
      case 15:
        return myConceptFoundErrorOperation;
      case 16:
        return myConceptGenerateTextDeclaration;
      case 17:
        return myConceptIncreaseDepthOperation;
      case 18:
        return myConceptIndentBufferOperation;
      case 19:
        return myConceptLanguageTextGenDeclaration;
      case 20:
        return myConceptNewLineAppendPart;
      case 21:
        return myConceptNodeAppendPart;
      case 22:
        return myConceptNodeParameter;
      case 23:
        return myConceptOperationCall;
      case 24:
        return myConceptOperationDeclaration;
      case 25:
        return myConceptReferenceAppendPart;
      case 26:
        return myConceptSimpleTextGenOperation;
      case 27:
        return myConceptStubOperationDeclaration;
      case 28:
        return myConceptUtilityMethodCall;
      case 29:
        return myConceptUtilityMethodDeclaration;
      case 30:
        return myConceptWithIndentOperation;
      default:
        return null;
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0jb = new String[]{"jetbrains.mps.lang.textGen.structure.AbstractAppendPart", "jetbrains.mps.lang.textGen.structure.AbstractTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.AbstractTextGenParameter", "jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.BufferParameter", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.ContextParameter", "jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.EncodingDeclaration", "jetbrains.mps.lang.textGen.structure.EncodingDeclarationBase", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", "jetbrains.mps.lang.textGen.structure.FilenameFunction", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", "jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.IndentBufferOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.NodeParameter", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>
package jetbrains.mps.lang.textGen.editor;



import jetbrains.mps.openapi.editor.descriptor.EditorAspectDescriptor;
import java.util.Collection;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import java.util.Arrays;
import java.util.Collections;
import jetbrains.mps.openapi.editor.descriptor.ConceptEditorComponent;

public class EditorAspectDescriptorImpl implements EditorAspectDescriptor {

  public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {
    switch (Arrays.binarySearch(stringSwitchCases_xbvbvu_a0a0b, descriptor.getConceptFqName())) {
      case 0:
        return Collections.<ConceptEditor>singletonList(new AppendOperation_Editor());
      case 1:
        return Collections.<ConceptEditor>singletonList(new CollectionAppendPart_Editor());
      case 2:
        return Collections.<ConceptEditor>singletonList(new ConceptTextGenDeclaration_Editor());
      case 3:
        return Collections.<ConceptEditor>singletonList(new ConstantStringAppendPart_Editor());
      case 4:
        return Collections.<ConceptEditor>singletonList(new EncodingLiteral_Editor());
      case 5:
        return Collections.<ConceptEditor>singletonList(new FoundErrorOperation_Editor());
      case 6:
        return Collections.<ConceptEditor>singletonList(new LanguageTextGenDeclaration_Editor());
      case 7:
        return Collections.<ConceptEditor>singletonList(new NewLineAppendPart_Editor());
      case 8:
        return Collections.<ConceptEditor>singletonList(new NodeAppendPart_Editor());
      case 9:
        return Collections.<ConceptEditor>singletonList(new OperationCall_Editor());
      case 10:
        return Collections.<ConceptEditor>singletonList(new OperationDeclaration_Editor());
      case 11:
        return Collections.<ConceptEditor>singletonList(new ReferenceAppendPart_Editor());
      case 12:
        return Collections.<ConceptEditor>singletonList(new SimpleTextGenOperation_Editor());
      case 13:
        return Collections.<ConceptEditor>singletonList(new StubOperationDeclaration_Editor());
      case 14:
        return Collections.<ConceptEditor>singletonList(new UtilityMethodCall_Editor());
      case 15:
        return Collections.<ConceptEditor>singletonList(new UtilityMethodDeclaration_Editor());
      case 16:
        return Collections.<ConceptEditor>singletonList(new WithIndentOperation_Editor());
      default:
    }
    return Collections.<ConceptEditor>emptyList();
  }
  public Collection<ConceptEditorComponent> getEditorComponents(ConceptDescriptor descriptor, String editorComponentId) {
    return Collections.<ConceptEditorComponent>emptyList();
  }


  private static String[] stringSwitchCases_xbvbvu_a0a0b = new String[]{"jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.SimpleTextGenOperation", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>
package jetbrains.mps.lang.textGen.behavior;



import jetbrains.mps.smodel.runtime.BehaviorDescriptor;
import java.util.Arrays;
import jetbrains.mps.smodel.runtime.interpreted.BehaviorAspectInterpreted;

public class BehaviorAspectDescriptor implements jetbrains.mps.smodel.runtime.BehaviorAspectDescriptor {
  public BehaviorAspectDescriptor() {
  }
  public BehaviorDescriptor getDescriptor(String fqName) {
    switch (Arrays.binarySearch(stringSwitchCases_846f5o_a0a0b, fqName)) {
      case 3:
        return new ConceptTextGenDeclaration_BehaviorDescriptor();
      case 18:
        return new NodeParameter_BehaviorDescriptor();
      case 12:
        return new GenerateTextDeclaration_BehaviorDescriptor();
      case 13:
        return new IncreaseDepthOperation_BehaviorDescriptor();
      case 6:
        return new DecreaseDepthOperation_BehaviorDescriptor();
      case 14:
        return new IndentBufferOperation_BehaviorDescriptor();
      case 15:
        return new LanguageTextGenDeclaration_BehaviorDescriptor();
      case 20:
        return new OperationDeclaration_BehaviorDescriptor();
      case 19:
        return new OperationCall_BehaviorDescriptor();
      case 5:
        return new ContextParameter_BehaviorDescriptor();
      case 1:
        return new BufferParameter_BehaviorDescriptor();
      case 24:
        return new UtilityMethodDeclaration_BehaviorDescriptor();
      case 23:
        return new UtilityMethodCall_BehaviorDescriptor();
      case 11:
        return new FoundErrorOperation_BehaviorDescriptor();
      case 25:
        return new WithIndentOperation_BehaviorDescriptor();
      case 16:
        return new NewLineAppendPart_BehaviorDescriptor();
      case 17:
        return new NodeAppendPart_BehaviorDescriptor();
      case 2:
        return new CollectionAppendPart_BehaviorDescriptor();
      case 4:
        return new ConstantStringAppendPart_BehaviorDescriptor();
      case 0:
        return new AppendOperation_BehaviorDescriptor();
      case 9:
        return new ExtensionDeclaration_BehaviorDescriptor();
      case 21:
        return new ReferenceAppendPart_BehaviorDescriptor();
      case 8:
        return new EncodingLiteral_BehaviorDescriptor();
      case 7:
        return new EncodingDeclaration_BehaviorDescriptor();
      case 10:
        return new FilenameFunction_BehaviorDescriptor();
      case 22:
        return new StubOperationDeclaration_BehaviorDescriptor();
      default:
        return BehaviorAspectInterpreted.getInstance().getDescriptor(fqName);
    }
  }
  private static String[] stringSwitchCases_846f5o_a0a0b = new String[]{"jetbrains.mps.lang.textGen.structure.AppendOperation", "jetbrains.mps.lang.textGen.structure.BufferParameter", "jetbrains.mps.lang.textGen.structure.CollectionAppendPart", "jetbrains.mps.lang.textGen.structure.ConceptTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.ConstantStringAppendPart", "jetbrains.mps.lang.textGen.structure.ContextParameter", "jetbrains.mps.lang.textGen.structure.DecreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.EncodingDeclaration", "jetbrains.mps.lang.textGen.structure.EncodingLiteral", "jetbrains.mps.lang.textGen.structure.ExtensionDeclaration", "jetbrains.mps.lang.textGen.structure.FilenameFunction", "jetbrains.mps.lang.textGen.structure.FoundErrorOperation", "jetbrains.mps.lang.textGen.structure.GenerateTextDeclaration", "jetbrains.mps.lang.textGen.structure.IncreaseDepthOperation", "jetbrains.mps.lang.textGen.structure.IndentBufferOperation", "jetbrains.mps.lang.textGen.structure.LanguageTextGenDeclaration", "jetbrains.mps.lang.textGen.structure.NewLineAppendPart", "jetbrains.mps.lang.textGen.structure.NodeAppendPart", "jetbrains.mps.lang.textGen.structure.NodeParameter", "jetbrains.mps.lang.textGen.structure.OperationCall", "jetbrains.mps.lang.textGen.structure.OperationDeclaration", "jetbrains.mps.lang.textGen.structure.ReferenceAppendPart", "jetbrains.mps.lang.textGen.structure.StubOperationDeclaration", "jetbrains.mps.lang.textGen.structure.UtilityMethodCall", "jetbrains.mps.lang.textGen.structure.UtilityMethodDeclaration", "jetbrains.mps.lang.textGen.structure.WithIndentOperation"};
}

<code block>

package jetbrains.mps.textGen;

import jetbrains.mps.messages.IMessage;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.text.BufferSnapshot;
import jetbrains.mps.text.MissingTextGenDescriptor;
import jetbrains.mps.text.impl.TextGenTransitionContext;
import jetbrains.mps.text.impl.TraceInfoCollector;
import jetbrains.mps.text.rt.TextGenDescriptor;
import jetbrains.mps.textgen.trace.ScopePositionInfo;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.UnitPositionInfo;
import jetbrains.mps.util.EncodingUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


@Deprecated
@ToRemove(version = 3.3)
public class TextGen {
  public static final String PACKAGE_NAME = "PACKAGE_NAME";
  public static final String DEPENDENCY = "DEPENDENCY";
  public static final String EXTENDS = "EXTENDS";
  public static final String OUTPUT_ENCODING = "OUTPUT_ENCODING";
  public static final String ROOT_NODE = "ROOT_NODE";

  public static final String NO_TEXTGEN = "\33\33NO TEXTGEN\33\33";

  
  public static TextGenerationResult generateText(SNode node) {
    return generateText(node, false, false, null);
  }

  public static boolean canGenerateTextFor(SNode node) {
    return !(getTextGenForNode(node) instanceof MissingTextGenDescriptor);
  }

  public static String getExtension(@NotNull SNode node) {
    return getLegacyTextGen(node).getExtension(node);
  }

  public static String getFileName(@NotNull SNode node) {
    final SNodeTextGen tg = getLegacyTextGen(node);
    String fname = tg.getFilename(node);
    String extension = tg.getExtension(node);
    return (extension == null) ? fname : fname + '.' + extension;
  }

  public static TextGenerationResult generateText(SNode node, boolean failIfNoTextgen, boolean withDebugInfo, @Nullable StringBuilder[] buffers) {
    if (canGenerateTextFor(node)) {
      return generateText(node, withDebugInfo, buffers);
    } else if (failIfNoTextgen) {
      String error = "Can't generate text from " + node;
      Message m = new Message(MessageKind.ERROR, error);
      if (node != null) {
        m.setHintObject(node.getReference());
      }
      return new TextGenerationResult(node, NO_TEXTGEN, true, Collections.<IMessage>singleton(m), null, null, null, null);
    } else {
      return new TextGenerationResult(node, NO_TEXTGEN, false, Collections.<IMessage>emptyList(), null, null, null, null);
    }
  }

  public static TextGenerationResult generateText(SNode node, boolean withDebugInfo, @Nullable StringBuilder[] buffers) {
    TextGenBuffer buffer = new TextGenBuffer(withDebugInfo, buffers);
    buffer.putUserObject(PACKAGE_NAME, jetbrains.mps.util.SNodeOperations.getModelLongName(node.getModel()));
    buffer.putUserObject(ROOT_NODE, node);
    final TraceInfoCollector tic;
    if (withDebugInfo)  {
      tic = new TraceInfoCollector();
      TraceInfoGenerationUtil.setTraceInfoCollector(buffer, tic);
    } else {
      tic = null;
    }

    appendNodeText(buffer, node);

    
    Map<SNode, TraceablePositionInfo> positionInfo = null;
    Map<SNode, ScopePositionInfo> scopeInfo = null;
    Map<SNode, UnitPositionInfo> unitInfo = null;
    final BufferSnapshot textSnapshot = buffer.getTextSnapshot();
    if (tic != null) {
      tic.populatePositions(textSnapshot);
      
      positionInfo = tic.getTracePositions();
      scopeInfo = tic.getScopePositions();
      unitInfo = tic.getUnitPositions();
    }

    
    List<String> dependencies = getUserObjectCollection(DEPENDENCY, node, buffer, (Set<String>) buffer.getUserObject(EXTENDS));
    List<String> extend = getUserObjectCollection(EXTENDS, node, buffer, null);

    Map<String, List<String>> deps = new HashMap<String, List<String>>(2);
    deps.put(DEPENDENCY, dependencies);
    deps.put(EXTENDS, extend);

    final String bufferOutcome = textSnapshot.getText().toString();
    Object result = bufferOutcome;
    String outputEncoding = (String) buffer.getUserObject(OUTPUT_ENCODING);
    if (outputEncoding != null) {
      if (outputEncoding.equals("binary")) {
        result = EncodingUtil.decodeBase64(bufferOutcome);
      } else {
        try {
          result = EncodingUtil.encode(bufferOutcome, outputEncoding);
        } catch (IOException ex) {
          buffer.foundError("cannot encode the output stream", null, ex);
        }
      }
    }
    return new TextGenerationResult(node, result, buffer.hasErrors(), buffer.problems(), positionInfo, scopeInfo, unitInfo, deps);
  }

  private static void appendNodeText(TextGenBuffer buffer, SNode node) {
    if (node == null) {
      buffer.append("???");
      return;
    }

    getTextGenForNode(node).generateText(new TextGenTransitionContext(node, buffer));
  }

  
  @NotNull
   static TextGenDescriptor getTextGenForNode(@NotNull SNode node) {
    return TextGenRegistry.getInstance().getTextGenDescriptor(node);
  }

  
  private static SNodeTextGen getLegacyTextGen(@NotNull SNode node) {
    try {
      Class<? extends SNodeTextGen> textgenClass = TextGenRegistry.getInstance().getLegacyTextGenClass(node.getConcept());
      if (textgenClass != null && SNodeTextGen.class.isAssignableFrom(textgenClass)) {
        return textgenClass.newInstance();
      }
    } catch (InstantiationException ex) {
      Logger.getLogger(TextGen.class).error("Failed to instantiate textgen", ex);
      
    } catch (IllegalAccessException ex) {
      Logger.getLogger(TextGen.class).error("Failed to instantiate textgen", ex);
      
    }
    return new DefaultTextGen();
  }

  private static List<String> getUserObjectCollection(String key, SNode node, TextGenBuffer buffer, Set<String> skipSet) {
    Set<String> dependenciesObject = (Set<String>) buffer.getUserObject(key);
    final String nodeFQName = NameUtil.nodeFQName(node);
    if (dependenciesObject != null) {
      List<String> dependencies = new ArrayList<String>(dependenciesObject.size());
      for (String dependObj : dependenciesObject) {
        if (dependObj == null || nodeFQName.equals(dependObj)) {
          continue;
        }
        if (skipSet != null && skipSet.contains(dependObj)) {
          continue;
        }
        dependencies.add(dependObj);
      }
      Collections.sort(dependencies);
      return dependencies;
    }
    return Collections.emptyList();
  }
}

<code block>

package jetbrains.mps.textGen;

import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.ModelDependencyScanner;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SNodeUtil;
import jetbrains.mps.smodel.adapter.ids.MetaIdHelper;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRegistryListener;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.structure.DescriptorUtils;
import jetbrains.mps.text.LegacyTextGenAdapter;
import jetbrains.mps.text.MissingTextGenDescriptor;
import jetbrains.mps.text.rt.TextGenAspectDescriptor;
import jetbrains.mps.text.rt.TextGenDescriptor;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.util.ImmediateParentConceptIterator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public class TextGenRegistry implements CoreComponent, LanguageRegistryListener {
  private static TextGenRegistry INSTANCE;

  private final Map<String, TextGenDescriptor> textGenDescriptors = new ConcurrentHashMap<String, TextGenDescriptor>();
  private final LanguageRegistry myLanguageRegistry;

  
  public TextGenRegistry(@NotNull LanguageRegistry languageRegistry) {
    myLanguageRegistry = languageRegistry;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myLanguageRegistry.addRegistryListener(this);
  }

  @Override
  public void dispose() {
    myLanguageRegistry.removeRegistryListener(this);
    INSTANCE = null;
  }

  public static TextGenRegistry getInstance() {
    return INSTANCE;
  }

  @NotNull
  public TextGenDescriptor getTextGenDescriptor(@Nullable SNode node) {
    if (node == null) {
      
      return new MissingTextGenDescriptor();
    }
    return getTextGenDescriptor(node.getConcept());
  }

  private TextGenDescriptor getTextGenDescriptor(SConcept concept) {
    final String fqName = concept.getQualifiedName();

    TextGenDescriptor descriptor = textGenDescriptors.get(fqName);

    if (descriptor != null) {
      return descriptor;
    }

    
    
    
    
    for (SConcept next : new ImmediateParentConceptIterator(concept, SNodeUtil.concept_BaseConcept)) {
      TextGenAspectDescriptor textGenAspectDescriptor = getAspect(next);
      if (textGenAspectDescriptor == null) {
        continue;
      }
      descriptor = textGenAspectDescriptor.getDescriptor(MetaIdHelper.getConcept(next));
      if (descriptor != null) {
        break;
      }
    }

    if (descriptor == null) {
      
      
      final Class<? extends SNodeTextGen> legacyTextGenClass = getLegacyTextGenClass(concept);
      if (legacyTextGenClass != null) {
        return new LegacyTextGenAdapter(legacyTextGenClass);
      }
      descriptor = new MissingTextGenDescriptor();
    }

    textGenDescriptors.put(fqName, descriptor);

    return descriptor;
  }

  @Nullable
  private TextGenAspectDescriptor getAspect(SConcept concept) {
    LanguageRuntime languageRuntime = myLanguageRegistry.getLanguage(concept.getLanguage());
    if (languageRuntime == null) {
      
      Logger.getLogger(TextGenRegistry.class).warn(String.format("No language for concept %s, while looking for textgen descriptor.", concept));
      return null;
    } else {
      return languageRuntime.getAspect(TextGenAspectDescriptor.class);
    }
  }

  
  @Deprecated
  @ToRemove(version = 3.3)
  public Class<? extends SNodeTextGen> getLegacyTextGenClass(SConcept c) {
    for (SConcept next : new ImmediateParentConceptIterator(c, SNodeUtil.concept_BaseConcept)) {
      String languageName = next.getLanguage().getQualifiedName();
      Language l = ModuleRepositoryFacade.getInstance().getModule(languageName, Language.class);
      String textgenClassname = LanguageAspect.TEXT_GEN.getAspectQualifiedClassName(next) + "_TextGen";
      Class<? extends SNodeTextGen> textgenClass = DescriptorUtils.getClassFromLanguage(textgenClassname, l);
      if (textgenClass != null) {
        return textgenClass;
      }
    }
    return null;
  }

  
  @NotNull
  public Collection<TextGenAspectDescriptor> getAspects(@NotNull SModel model) {
    
    
    
    ArrayList<TextGenAspectDescriptor> rv = new ArrayList<TextGenAspectDescriptor>(5);
    final ModelDependencyScanner modelScanner = new ModelDependencyScanner();
    modelScanner.crossModelReferences(false).usedLanguages(true).walk(model);
    for (SLanguage l : modelScanner.getUsedLanguages()) {
      final LanguageRuntime lr = myLanguageRegistry.getLanguage(l);
      if (lr == null) {
        
        continue;
      }
      final TextGenAspectDescriptor rtAspect = lr.getAspect(TextGenAspectDescriptor.class);
      if (rtAspect != null) {
        rv.add(rtAspect);
      }
    }
    return rv;
  }

  @Override
  public void beforeLanguagesUnloaded(Iterable<LanguageRuntime> languages) {
    
  }

  @Override
  public void afterLanguagesLoaded(Iterable<LanguageRuntime> languages) {
    textGenDescriptors.clear();
  }

}

<code block>

package jetbrains.mps.text.impl;

import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.text.TextArea;
import jetbrains.mps.text.TextMark;
import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.textGen.TextGen;
import jetbrains.mps.textGen.TextGenBuffer;
import jetbrains.mps.textGen.TextGenRegistry;
import jetbrains.mps.textGen.TraceInfoGenerationUtil;
import jetbrains.mps.textgen.trace.ScopePositionInfo;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import jetbrains.mps.textgen.trace.UnitPositionInfo;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SReference;

import java.util.List;


public final class TextGenSupport implements TextArea {
  private final TextGenContext myContext;
  private final TraceInfoCollector myTraceInfoCollector;

  public TextGenSupport(@NotNull TextGenContext context) {
    myContext = context;
    final TextGenBuffer buffer = ((TextGenTransitionContext) context).getLegacyBuffer();
    myTraceInfoCollector = TraceInfoGenerationUtil.getTraceInfoCollector(buffer);
  }

  public boolean needPositions() {
    return getTraceInfoCollector() != null;
  }

  public void createPositionInfo() {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void createScopeInfo( ) {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void createUnitInfo() {
    if (needPositions()) {
      myContext.getBuffer().pushMark();
    }
  }

  public void fillPositionInfo(String propertyString) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final TraceablePositionInfo pi = tic.createTracePosition(m, myContext.getPrimaryInput());
    pi.setPropertyString(propertyString);
  }

  public void fillScopeInfo(List<SNode> vars) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final ScopePositionInfo pi = tic.createScopePosition(m, myContext.getPrimaryInput());
    for (SNode var : vars) {
      if (var != null) {
        pi.addVarInfo(var);
      }
    }
  }

  public void fillUnitInfo(String unitName) {
    final TraceInfoCollector tic = getTraceInfoCollector();
    if (tic == null) {
      return;
    }
    TextMark m = myContext.getBuffer().popMark();
    final UnitPositionInfo pi = tic.createUnitPosition(m, myContext.getPrimaryInput());
    pi.setUnitName(unitName);
    TraceInfoGenerationUtil.warnIfUnitNameInvalid(unitName, myContext.getPrimaryInput());
  }

  private TraceInfoCollector getTraceInfoCollector() {
    return myTraceInfoCollector;
  }

  public void appendNode(SNode node) {
    final TextGenBuffer buffer = getLegacyBuffer();
    TextGenRegistry.getInstance().getTextGenDescriptor(node).generateText(new TextGenTransitionContext(node, buffer));
  }

  
  public void reportError(String info) {
    String message = info != null ?
        "textgen error: '" + info + "' in " + SNodeOperations.getDebugText(myContext.getPrimaryInput()) :
        "textgen error in " + SNodeOperations.getDebugText(myContext.getPrimaryInput());
    getLegacyBuffer().foundError(message, myContext.getPrimaryInput(), null);
  }

  
  public void setEncoding(@Nullable String encoding) {
    getLegacyBuffer().putUserObject(TextGen.OUTPUT_ENCODING, encoding);
  }

  
  public void appendReferentText(SReference reference) {
    if (reference == null) {
      reportError("null reference");
      append("<err:null reference>");
      return;
    }

    String shortName;
    if (reference instanceof DynamicReference) {
      shortName = ((DynamicReference) reference).getResolveInfo();
      if (shortName.startsWith("[")) {
        
        shortName = shortName.substring(shortName.lastIndexOf("]") + 1).trim();
      } else {
        final SModelReference modelReference = reference.getTargetSModelReference();
        if (modelReference == null) {
          int lastDot = shortName.lastIndexOf('.');
          if (lastDot >= 0) {
            shortName = shortName.substring(lastDot + 1);
            if (shortName.indexOf('$') >= 0) {
              shortName = shortName.replace('$', '.');
            }
          }
        }
      }
    } else {
      SNode targetNode = reference.getTargetNode();
      if (targetNode == null) {
        reportError(String.format("Unknown target for role %s", reference.getRole()));
        append("???");
        return;
      }
      shortName = jetbrains.mps.util.SNodeOperations.getResolveInfo(targetNode);
    }
    append(shortName);
  }

  
  @ToRemove(version = 3.3)
  public TextGenBuffer getLegacyBuffer() {
    return ((TextGenTransitionContext) myContext).getLegacyBuffer();
  }

  
  

  @Override
  public TextArea append(CharSequence text) {
    return myContext.getBuffer().area().append(text);
  }

  @Override
  public TextArea newLine() {
    return myContext.getBuffer().area().newLine();
  }

  @Override
  public TextArea indent() {
    return myContext.getBuffer().area().indent();
  }

  @Override
  public TextArea increaseIndent() {
    return myContext.getBuffer().area().increaseIndent();
  }

  @Override
  public TextArea decreaseIndent() {
    return myContext.getBuffer().area().decreaseIndent();
  }

  @Override
  public int length() {
    return myContext.getBuffer().area().length();
  }
}

<code block>

package jetbrains.mps.text.rt;


public abstract class BaseTextGenAspectDescriptor extends TextGenAspectBase {
}

<code block>

package jetbrains.mps.persistence.binary;

import jetbrains.mps.extapi.model.GeneratableSModel;
import jetbrains.mps.generator.ModelDigestUtil;
import jetbrains.mps.generator.ModelDigestUtil.DigestBuilderOutputStream;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.persistence.IndexAwareModelFactory.Callback;
import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.MetaModelInfoProvider.BaseMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.RegularMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.StuffedMetaModelInfo;
import jetbrains.mps.persistence.registry.AggregationLinkInfo;
import jetbrains.mps.persistence.registry.AssociationLinkInfo;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.persistence.registry.PropertyInfo;
import jetbrains.mps.smodel.DefaultSModel;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.v9.IdInfoCollector;
import jetbrains.mps.smodel.runtime.ConceptKind;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.util.io.ModelInputStream;
import jetbrains.mps.util.io.ModelOutputStream;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.StreamDataSource;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import static jetbrains.mps.smodel.SModel.ImportElement;


public final class BinaryPersistence {

  private final MetaModelInfoProvider myMetaInfoProvider;
  private final SModel myModelData;

  public static SModelHeader readHeader(@NotNull StreamDataSource source) throws ModelReadException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(source.openInputStream());
      return loadHeader(mis);
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.getMessage(), e);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  public static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull StreamDataSource source, boolean interfaceOnly) throws ModelReadException {
    final SModelReference desiredModelRef = header.getModelReference();
    try {
      ModelLoadResult rv = loadModel(source.openInputStream(), interfaceOnly, header.getMetaInfoProvider());
      SModelReference actualModelRef = rv.getModel().getReference();
      if (!actualModelRef.equals(desiredModelRef)) {
        throw new ModelReadException(String.format("Intended to read model %s, actually read %s", desiredModelRef, actualModelRef), null, actualModelRef);
      }
      return rv;
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e, desiredModelRef);
    }
  }

  @NotNull
  public static SModel readModel(@NotNull final InputStream content) throws ModelReadException {
    try {
      return loadModel(content, false, null).getModel();
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e);
    }
  }

  public static void writeModel(@NotNull SModel model, @NotNull StreamDataSource dataSource) throws IOException {
    if (dataSource.isReadOnly()) {
      throw new IOException(String.format("`%s' is read-only", dataSource.getLocation()));
    }
    writeModel(model, dataSource.openOutputStream());
  }
  public static void writeModel(@NotNull SModel model, @NotNull OutputStream stream) throws IOException {
    ModelOutputStream os = null;
    try {
      os = new ModelOutputStream(stream);
      saveModel(model, os);
    } finally {
      FileUtil.closeFileSafe(os);
    }
  }

  public static Map<String, String> getDigestMap(jetbrains.mps.smodel.SModel model) {
    Map<String, String> result = new LinkedHashMap<String, String>();
    IdInfoRegistry meta = null;
    DigestBuilderOutputStream os = ModelDigestUtil.createDigestBuilderOutputStream();
    try {
      BinaryPersistence bp = new BinaryPersistence(new RegularMetaModelInfo(), model);
      ModelOutputStream mos = new ModelOutputStream(os);
      meta = bp.saveModelProperties(mos);
      mos.flush();
    } catch (IOException ignored) {
      assert false;
      
    }
    result.put(GeneratableSModel.HEADER, os.getResult());

    assert meta != null;
    
    
    
    
    

    for (SNode node : model.getRootNodes()) {
      os = ModelDigestUtil.createDigestBuilderOutputStream();
      try {
        ModelOutputStream mos = new ModelOutputStream(os);
        new NodesWriter(model.getReference(), mos, meta).writeNode(node);
        mos.flush();
      } catch (IOException ignored) {
        assert false;
        
      }
      SNodeId nodeId = node.getNodeId();
      if (nodeId != null) {
        result.put(nodeId.toString(), os.getResult());
      }
    }

    return result;
  }


  private static final int HEADER_START   = 0x91ABABA9;
  private static final int STREAM_ID_V1   = 0x00000300;
  private static final int STREAM_ID_V2   = 0x00000400;
  private static final int STREAM_ID      = STREAM_ID_V2;
  private static final byte HEADER_ATTRIBUTES = 0x7e;
  private static final int HEADER_END     = 0xabababab;
  private static final int MODEL_START    = 0xbabababa;
  private static final int REGISTRY_START = 0x5a5a5a5a;
  private static final int REGISTRY_END   = 0xa5a5a5a5;
  private static final byte STUB_NONE     = 0x12;
  private static final byte STUB_ID       = 0x13;



  @NotNull
  private static SModelHeader loadHeader(ModelInputStream is) throws IOException {
    if (is.readInt() != HEADER_START) {
      throw new IOException("bad stream, no header");
    }

    int streamId = is.readInt();
    if (streamId == STREAM_ID_V1) {
      throw new IOException(String.format("Can't read old binary persistence version (%x), please re-save models", streamId));
    }
    if (streamId != STREAM_ID) {
      throw new IOException(String.format("bad stream, unknown version: %x", streamId));
    }

    SModelReference modelRef = is.readModelReference();
    SModelHeader result = new SModelHeader();
    result.setModelReference(modelRef);
    is.readInt(); 
    is.mark(4);
    if (is.readByte() == HEADER_ATTRIBUTES) {
      result.setDoNotGenerate(is.readBoolean());
      int propsCount = is.readShort();
      for (; propsCount > 0; propsCount--) {
        String key = is.readString();
        String value = is.readString();
        result.setOptionalProperty(key, value);
      }
    } else {
      is.reset();
    }
    assertSyncToken(is, HEADER_END);
    return result;
  }
  @NotNull
  private static ModelLoadResult loadModel(InputStream is, boolean interfaceOnly, @Nullable MetaModelInfoProvider mmiProvider) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(is);
      SModelHeader modelHeader = loadHeader(mis);

      DefaultSModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(mmiProvider == null ? new RegularMetaModelInfo() : mmiProvider, model);
      ReadHelper rh = bp.loadModelProperties(mis);
      rh.requestInterfaceOnly(interfaceOnly);

      NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, rh);
      reader.readNodesInto(model);
      return new ModelLoadResult((SModel) model, reader.hasSkippedNodes() ? ModelLoadingState.INTERFACE_LOADED : ModelLoadingState.FULLY_LOADED);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void saveModel(SModel model, ModelOutputStream os) throws IOException {
    final MetaModelInfoProvider mmiProvider;
    if (model instanceof DefaultSModel && ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider() != null) {
      mmiProvider = ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider();
    } else {
      mmiProvider = new RegularMetaModelInfo();
    }
    BinaryPersistence bp = new BinaryPersistence(mmiProvider, model);
    IdInfoRegistry meta = bp.saveModelProperties(os);

    Collection<SNode> roots = IterableUtil.asCollection(model.getRootNodes());
    new NodesWriter(model.getReference(), os, meta).writeNodes(roots);
  }

  private BinaryPersistence(@NotNull MetaModelInfoProvider mmiProvider, SModel modelData) {
    myMetaInfoProvider = mmiProvider;
    myModelData = modelData;
  }

  private ReadHelper loadModelProperties(ModelInputStream is) throws IOException {
    final ReadHelper readHelper = loadRegistry(is);

    loadUsedLanguages(is);

    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addEngagedOnGenerationLanguage(ref);
    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addDevKit(ref);

    for (ImportElement imp : loadImports(is)) myModelData.addModelImport(imp);

    assertSyncToken(is, MODEL_START);

    return readHelper;
  }

  private IdInfoRegistry saveModelProperties(ModelOutputStream os) throws IOException {
    
    os.writeInt(HEADER_START);
    os.writeInt(STREAM_ID);
    os.writeModelReference(myModelData.getReference());
    os.writeInt(-1);  
    if (myModelData instanceof DefaultSModel) {
      os.writeByte(HEADER_ATTRIBUTES);
      SModelHeader mh = ((DefaultSModel) myModelData).getSModelHeader();
      os.writeBoolean(mh.isDoNotGenerate());
      Map<String, String> props = new HashMap<String, String>(mh.getOptionalProperties());
      os.writeShort(props.size());
      for (Entry<String, String> e : props.entrySet()) {
        os.writeString(e.getKey());
        os.writeString(e.getValue());
      }
    }
    os.writeInt(HEADER_END);

    final IdInfoRegistry rv = saveRegistry(os);

    
    saveUsedLanguages(os);
    saveModuleRefList(myModelData.engagedOnGenerationLanguages(), os);
    saveModuleRefList(myModelData.importedDevkits(), os);

    
    saveImports(myModelData.importedModels(), os);
    

    os.writeInt(MODEL_START);
    return rv;
  }

  private IdInfoRegistry saveRegistry(ModelOutputStream os) throws IOException {
    os.writeInt(REGISTRY_START);
    IdInfoRegistry metaInfo = new IdInfoRegistry();
    new IdInfoCollector(metaInfo, myMetaInfoProvider).fill(myModelData.getRootNodes());
    List<LangInfo> languagesInUse = metaInfo.getLanguagesInUse();
    os.writeShort(languagesInUse.size());
    
    
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;
    for(LangInfo ul : languagesInUse) {
      os.writeUUID(ul.getLanguageId().getIdValue());
      os.writeString(ul.getName());
      ul.setIntIndex(langIndex++);
      
      List<ConceptInfo> conceptsInUse = ul.getConceptsInUse();
      os.writeShort(conceptsInUse.size());
      for (ConceptInfo ci : conceptsInUse) {
        os.writeLong(ci.getConceptId().getIdValue());
        assert ul.getName().equals(NameUtil.namespaceFromConceptFQName(ci.getName())) : "We save concept short name. This check ensures we can re-construct fqn based on language name";
        os.writeString(ci.getBriefName());
        os.writeByte(ci.getKind().ordinal() << 4 | ci.getScope().ordinal());
        if (ci.isImplementationWithStub()) {
          os.writeByte(STUB_ID);
          os.writeLong(ci.getStubCounterpart().getIdValue());
        } else {
          os.writeByte(STUB_NONE);
        }
        ci.setIntIndex(conceptIndex++);
        
        List<PropertyInfo> propertiesInUse = ci.getPropertiesInUse();
        os.writeShort(propertiesInUse.size());
        for(PropertyInfo pi : propertiesInUse) {
          os.writeLong(pi.getPropertyId().getIdValue());
          os.writeString(pi.getName());
          pi.setIntIndex(propertyIndex++);
        }
        
        List<AssociationLinkInfo> associationsInUse = ci.getAssociationsInUse();
        os.writeShort(associationsInUse.size());
        for (AssociationLinkInfo li : associationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          li.setIntIndex(associationIndex++);
        }
        
        List<AggregationLinkInfo> aggregationsInUse = ci.getAggregationsInUse();
        os.writeShort(aggregationsInUse.size());
        for (AggregationLinkInfo li : aggregationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          os.writeBoolean(li.isUnordered());
          li.setIntIndex(aggregationIndex++);
        }
      }
    }
    os.writeInt(REGISTRY_END);
    return metaInfo;
  }

  private ReadHelper loadRegistry(ModelInputStream is) throws IOException {
    assertSyncToken(is, REGISTRY_START);
    
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;

    ReadHelper rh = new ReadHelper(myMetaInfoProvider);

    int langCount = is.readShort();
    while (langCount-- > 0) {
      final SLanguageId languageId = new SLanguageId(is.readUUID());
      final String langName = is.readString();
      rh.withLanguage(languageId, langName, langIndex++);
      
      int conceptCount = is.readShort();
      while (conceptCount-- > 0) {
        final SConceptId conceptId = new SConceptId(languageId, is.readLong());
        final String conceptName = NameUtil.conceptFQNameFromNamespaceAndShortName(langName, is.readString());
        int flags = is.readByte();
        int stubToken = is.readByte();
        final SConceptId stubId;
        if (stubToken == STUB_NONE) {
          stubId = null;
        } else {
          assert stubToken == STUB_ID;
          stubId = new SConceptId(languageId, is.readLong());
        }
        rh.withConcept(conceptId, conceptName, StaticScope.values()[flags & 0x0f], ConceptKind.values()[flags >> 4 & 0x0f], stubId, conceptIndex++);
        
        int propertyCount = is.readShort();
        while (propertyCount-- > 0) {
          rh.property(new SPropertyId(conceptId, is.readLong()), is.readString(), propertyIndex++);
        }
        
        int associationCount = is.readShort();
        while (associationCount-- > 0) {
          rh.association(new SReferenceLinkId(conceptId, is.readLong()), is.readString(), associationIndex++);
        }
        
        int aggregationCount = is.readShort();
        while (aggregationCount-- > 0) {
          rh.aggregation(new SContainmentLinkId(conceptId, is.readLong()), is.readString(), is.readBoolean(), aggregationIndex++);
        }
      }
    }
    assertSyncToken(is, REGISTRY_END);
    return rh;
  }

  private void saveUsedLanguages(ModelOutputStream os) throws IOException {
    Collection<SLanguage> refs = myModelData.usedLanguages();
    os.writeShort(refs.size());
    for (SLanguage l : refs) {
      
      os.writeUUID(IdHelper.getLanguageId(l).getIdValue());
      os.writeString(l.getQualifiedName());
    }
  }

  private void loadUsedLanguages(ModelInputStream is) throws IOException {
    int size = is.readShort();
    for (int i = 0; i < size; i++) {
      SLanguageId id = new SLanguageId(is.readUUID());
      String name = is.readString();
      SLanguage l = MetaAdapterFactory.getLanguage(id, name);
      myModelData.addLanguage(l);
      myMetaInfoProvider.setLanguageName(id, name);
    }
  }

  private static void saveModuleRefList(Collection<SModuleReference> refs, ModelOutputStream os) throws IOException {
    os.writeShort(refs.size());
    for (SModuleReference ref : refs) {
      os.writeModuleReference(ref);
    }
  }

  private static Collection<SModuleReference> loadModuleRefList(ModelInputStream is) throws IOException {
    int size = is.readShort();
    List<SModuleReference> result = new ArrayList<SModuleReference>(size);
    for (int i = 0; i < size; i++) {
      result.add(is.readModuleReference());
    }
    return result;
  }

  private static void saveImports(Collection<ImportElement> elements, ModelOutputStream os) throws IOException {
    os.writeInt(elements.size());
    for (ImportElement element : elements) {
      os.writeModelReference(element.getModelReference());
      os.writeInt(element.getUsedVersion());
    }
  }

  private static List<ImportElement> loadImports(ModelInputStream is) throws IOException {
    int size = is.readInt();
    List<ImportElement> result = new ArrayList<ImportElement>();
    for (int i = 0; i < size; i++) {
      SModelReference ref = is.readModelReference();
      result.add(new ImportElement(ref, -1, is.readInt()));
    }
    return result;
  }

  public static void index(InputStream content, final Callback consumer) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(content);
      SModelHeader modelHeader = loadHeader(mis);
      SModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(new StuffedMetaModelInfo(new BaseMetaModelInfo()), model);
      final ReadHelper readHelper = bp.loadModelProperties(mis);
      for (ImportElement element : model.importedModels()) {
        consumer.imports(element.getModelReference());
      }
      for (SConceptId cid : readHelper.getParticipatingConcepts()) {
        consumer.instances(cid);
      }
      readHelper.requestInterfaceOnly(false);
      final NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, readHelper);
      HashSet<SNodeId> externalNodes = new HashSet<SNodeId>();
      HashSet<SNodeId> localNodes = new HashSet<SNodeId>();
      reader.collectExternalTargets(externalNodes);
      reader.collectLocalTargets(localNodes);
      reader.readChildren(null);
      for (SNodeId n : externalNodes) {
        consumer.externalNodeRef(n);
      }
      for (SNodeId n : localNodes) {
        consumer.localNodeRef(n);
      }
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void assertSyncToken(ModelInputStream is, int token) throws IOException {
    if (is.readInt() != token) {
      throw new IOException("bad stream, no sync token");
    }
  }
}

<code block>

package jetbrains.mps.smodel.persistence.def.v9;

import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.runtime.ConceptKind;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;

import java.util.HashMap;
import java.util.Map;


class IdInfoReadHelper {
  private final IdInfoRegistry myMetaRegistry;
  private final IdEncoder myIdEncoder;
  private final MetaModelInfoProvider myMetaInfoProvider;
  private LangInfo myActualLang;
  private ConceptInfo myActualConcept;
  private final Map<String, SConcept> myConcepts = new HashMap<String, SConcept>();
  private final Map<String, SProperty> myProperties = new HashMap<String, SProperty>();
  private final Map<String, SReferenceLink> myAssociations = new HashMap<String, SReferenceLink>();
  private final Map<String, SContainmentLink> myAggregations = new HashMap<String, SContainmentLink>();
  private final boolean myInterfaceOnly;
  private final boolean myStripImplementation;

  public IdInfoReadHelper(@NotNull MetaModelInfoProvider mmiProvider, boolean interfaceOnly, boolean stripImplementation) {
    myMetaInfoProvider = mmiProvider;
    myIdEncoder = new IdEncoder();
    myMetaRegistry = new IdInfoRegistry();
    myInterfaceOnly = interfaceOnly;
    myStripImplementation = stripImplementation;
  }

  @NotNull
  public IdEncoder getIdEncoder() {
    return myIdEncoder;
  }

  public boolean isRequestedInterfaceOnly() {
    return myInterfaceOnly;
  }

  public boolean isRequestedStripImplementation() {
    return myStripImplementation;
  }

  

  public void withLanguage(String id, String name) {
    final SLanguageId languageId = myIdEncoder.parseLanguageId(id);
    myActualLang = myMetaRegistry.registerLanguage(languageId, name);
    myMetaInfoProvider.setLanguageName(languageId, name);
  }

  
  public void withConcept(String id, String name, String index, String nodeInfo, String stub) {
    assert myActualLang != null;
    SConceptId conceptId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), id);
    myActualConcept = myMetaRegistry.registerConcept(conceptId, name);
    myActualConcept.parseImplementationKind(nodeInfo);
    myConcepts.put(index, MetaAdapterFactory.getConcept(conceptId, name));
    myMetaInfoProvider.setConceptName(conceptId, name);
    myMetaInfoProvider.setKind(conceptId, myActualConcept.getKind());
    myMetaInfoProvider.setScope(conceptId, myActualConcept.getScope());
    if (stub != null) {
      
      final SConceptId stubId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), stub);
      myActualConcept.setStubCounterpart(stubId);
      myMetaInfoProvider.setStubConcept(conceptId, stubId);
    }
  }

  public void property(String id, String name, String index) {
    assert myActualConcept != null;
    SPropertyId propertyId = myIdEncoder.parsePropertyId(myActualConcept.getConceptId(), id);
    myActualConcept.addProperty(propertyId, name);
    myProperties.put(index, MetaAdapterFactory.getProperty(propertyId, name));
    myMetaInfoProvider.setPropertyName(propertyId, name);
  }

  public void association(String id, String name, String index) {
    assert myActualConcept != null;
    SReferenceLinkId linkId = myIdEncoder.parseAssociation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name);
    myAssociations.put(index, MetaAdapterFactory.getReferenceLink(linkId, name));
    myMetaInfoProvider.setAssociationName(linkId, name);
  }

  public void aggregation(String id, String name, String index, boolean unordered) {
    assert myActualConcept != null;
    SContainmentLinkId linkId = myIdEncoder.parseAggregation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name, unordered);
    myAggregations.put(index, MetaAdapterFactory.getContainmentLink(linkId, name));
    myMetaInfoProvider.setAggregationName(linkId, name);
    myMetaInfoProvider.setUnordered(linkId, unordered);
  }

  

  public SConcept readConcept(@NotNull String index) {
    assert myConcepts.containsKey(index);
    return myConcepts.get(index);
  }

  public SProperty readProperty(@NotNull String index) {
    assert myProperties.containsKey(index);
    return myProperties.get(index);
  }

  public SReferenceLink readAssociation(@NotNull String index) {
    assert myAssociations.containsKey(index);
    return myAssociations.get(index);
  }

  
  public SContainmentLink readAggregation(@Nullable String index) {
    if (index == null) {
      return null;
    }
    assert myAggregations.containsKey(index);
    return myAggregations.get(index);
  }

  public boolean isInterface(@NotNull SConcept concept) {
    return ConceptKind.INTERFACE == myMetaRegistry.find(concept).getKind();
  }

  public boolean isImplementation(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementation();
  }
  public boolean isImplementationWithStub(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementationWithStub();
  }

  
  @NotNull
  public SConcept getStubConcept(@NotNull SConcept original) {
    final ConceptInfo ci = myMetaRegistry.find(original);
    assert ci.getKind() == ConceptKind.IMPLEMENTATION_WITH_STUB;
    final SConceptId stub = ci.getStubCounterpart();
    assert stub != null;
    return MetaAdapterFactory.getConcept(stub, ci.constructStubConceptName());
  }

  public SLanguage getLanguage(@NotNull SLanguageId langId, @NotNull String langName) {
    
    
    
    
    return MetaAdapterFactory.getLanguage(langId, langName);
  }
}

<code block>
package jetbrains.mps.smodel.persistence.def.v9;



import jetbrains.mps.util.xml.XMLSAXHandler;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import java.util.Stack;
import org.xml.sax.Locator;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.DefaultSModel;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXParseException;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.InterfaceSNode;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.util.Pair;

public class ModelReader9Handler extends XMLSAXHandler<ModelLoadResult> {
  private ModelReader9Handler.ModelElementHandler modelHandler = new ModelReader9Handler.ModelElementHandler();
  private ModelReader9Handler.PersistenceElementHandler persistenceHandler = new ModelReader9Handler.PersistenceElementHandler();
  private ModelReader9Handler.Model_attributeElementHandler model_attributeHandler = new ModelReader9Handler.Model_attributeElementHandler();
  private ModelReader9Handler.RegistryElementHandler registryHandler = new ModelReader9Handler.RegistryElementHandler();
  private ModelReader9Handler.Registry_languageElementHandler registry_languageHandler = new ModelReader9Handler.Registry_languageElementHandler();
  private ModelReader9Handler.Registry_conceptElementHandler registry_conceptHandler = new ModelReader9Handler.Registry_conceptElementHandler();
  private ModelReader9Handler.Registry_propertyElementHandler registry_propertyHandler = new ModelReader9Handler.Registry_propertyElementHandler();
  private ModelReader9Handler.Registry_associationElementHandler registry_associationHandler = new ModelReader9Handler.Registry_associationElementHandler();
  private ModelReader9Handler.Registry_aggregationElementHandler registry_aggregationHandler = new ModelReader9Handler.Registry_aggregationElementHandler();
  private ModelReader9Handler.LanguagesElementHandler languagesHandler = new ModelReader9Handler.LanguagesElementHandler();
  private ModelReader9Handler.Used_languageElementHandler used_languageHandler = new ModelReader9Handler.Used_languageElementHandler();
  private ModelReader9Handler.Module_referenceElementHandler module_referenceHandler = new ModelReader9Handler.Module_referenceElementHandler();
  private ModelReader9Handler.ImportsElementHandler importsHandler = new ModelReader9Handler.ImportsElementHandler();
  private ModelReader9Handler.Model_importElementHandler model_importHandler = new ModelReader9Handler.Model_importElementHandler();
  private ModelReader9Handler.NodeElementHandler nodeHandler = new ModelReader9Handler.NodeElementHandler();
  private ModelReader9Handler.PropertyElementHandler propertyHandler = new ModelReader9Handler.PropertyElementHandler();
  private ModelReader9Handler.ReferenceElementHandler referenceHandler = new ModelReader9Handler.ReferenceElementHandler();
  private ModelReader9Handler.IgnoredNodeElementHandler ignoredNodeHandler = new ModelReader9Handler.IgnoredNodeElementHandler();
  private ModelReader9Handler.IgnoredPropertyElementHandler ignoredPropertyHandler = new ModelReader9Handler.IgnoredPropertyElementHandler();
  private ModelReader9Handler.IgnoredReferenceElementHandler ignoredReferenceHandler = new ModelReader9Handler.IgnoredReferenceElementHandler();
  private Stack<ModelReader9Handler.ElementHandler> myHandlersStack = new Stack<ModelReader9Handler.ElementHandler>();
  private Stack<ModelReader9Handler.ChildHandler> myChildHandlersStack = new Stack<ModelReader9Handler.ChildHandler>();
  private Stack<Object> myValues = new Stack<Object>();
  private Locator myLocator;
  private ModelLoadResult myResult;
  private SModelHeader my_headerParam;
  private IdInfoReadHelper my_readHelperParam;
  private DefaultSModel my_modelField;
  private ImportsHelper my_importHelperField;
  private IdEncoder my_idEncoderField;
  public ModelReader9Handler(SModelHeader header, IdInfoReadHelper readHelper) {
    my_headerParam = header;
    my_readHelperParam = readHelper;
  }
  public ModelLoadResult getResult() {
    return myResult;
  }
  @Override
  public void setDocumentLocator(Locator locator) {
    myLocator = locator;
  }
  @Override
  public void characters(char[] array, int start, int len) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current != null) {
      current.handleText(myValues.peek(), new String(array, start, len));
    }
  }
  @Override
  public void endElement(String uri, String localName, String qName) throws SAXException {
    ModelReader9Handler.ElementHandler current = myHandlersStack.pop();
    Object childValue = myValues.pop();
    current.validate(childValue);
    if (myChildHandlersStack.empty()) {
      myResult = (ModelLoadResult) childValue;
    } else {
      ModelReader9Handler.ChildHandler ch = myChildHandlersStack.pop();
      if (ch != null) {
        ch.apply(myValues.peek(), childValue);
      }
    }
  }
  @Override
  public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current == null) {
      
      current = modelHandler;
    } else {
      current = current.createChild(myValues.peek(), qName, attributes);
    }

    
    for (String attr : current.requiredAttributes()) {
      if (attributes.getValue(attr) == null) {
        throw new SAXParseException("attribute " + attr + " is absent", null);
      }
    }

    Object result = current.createObject(attributes);
    if (myHandlersStack.empty()) {
      myResult = (ModelLoadResult) result;
    }

    
    for (int i = 0; i < attributes.getLength(); i++) {
      String name = attributes.getQName(i);
      String value = attributes.getValue(i);
      current.handleAttribute(result, name, value);
    }
    myHandlersStack.push(current);
    myValues.push(result);
  }
  private static interface ChildHandler {
    public void apply(Object resultObject, Object value) throws SAXException;
  }
  private class ElementHandler {
    private String[] requiredAttributes = new String[0];

    private ElementHandler() {
    }
    protected Object createObject(Attributes attrs) throws SAXException {
      return null;
    }
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
    }
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      throw new SAXParseException("unknown tag: " + tagName, null);
    }
    protected void handleText(Object resultObject, String value) throws SAXException {
      if (value.trim().length() == 0) {
        return;
      }
      throw new SAXParseException("text is not accepted: '" + value + "'", null);
    }
    protected String[] requiredAttributes() {
      return requiredAttributes;
    }
    protected void setRequiredAttributes(String... required) {
      requiredAttributes = required;
    }
    protected void validate(Object resultObject) throws SAXException {
    }
  }
  public class ModelElementHandler extends ModelReader9Handler.ElementHandler {
    public ModelElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected ModelLoadResult createObject(Attributes attrs) throws SAXException {
      my_idEncoderField = my_readHelperParam.getIdEncoder();
      SModelReference ref = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_modelField = new DefaultSModel(ref, my_headerParam);
      my_modelField.getSModelHeader().setPersistenceVersion(9);
      my_importHelperField = new ImportsHelper(ref);
      ModelLoadResult result = new ModelLoadResult((SModel) my_modelField, ModelLoadingState.NOT_LOADED);
      result.setState((my_readHelperParam.isRequestedInterfaceOnly() ? ModelLoadingState.INTERFACE_LOADED : ((my_readHelperParam.isRequestedStripImplementation() ? ModelLoadingState.NO_IMPLEMENTATION : ModelLoadingState.FULLY_LOADED))));
      return result;
    }
    @Override
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
      ModelLoadResult result = (ModelLoadResult) resultObject;
      if ("doNotGenerate".equals(name)) {
        my_modelField.getSModelHeader().setDoNotGenerate(Boolean.parseBoolean(value));
        return;
      }
      if ("content".equals(name)) {
        if ("header".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_HEADER);
        } else if ("root".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_ROOT);
        } else {
          throw new SAXException("unknown content attribute value: " + value);
        }
        return;
      }
      super.handleAttribute(resultObject, name, value);
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("node".equals(tagName) && checknode_8237920533349931304(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931271(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931307(resultObject, value);
          }
        });
        return nodeHandler;
      }
      if ("persistence".equals(tagName)) {
        myChildHandlersStack.push(null);
        return persistenceHandler;
      }
      if ("attribute".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_attributeHandler;
      }
      if ("languages".equals(tagName)) {
        myChildHandlersStack.push(null);
        return languagesHandler;
      }
      if ("imports".equals(tagName)) {
        myChildHandlersStack.push(null);
        return importsHandler;
      }
      if ("registry".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registryHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533349931304(Object resultObject, Attributes attrs) {
      return my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    private void handleChild_8237920533349931271(Object resultObject, Object value) throws SAXException {
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SConcept concept = child._1();
      if (my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        my_modelField.addRootNode(new SNode(stubConcept));
      }
    }
    private void handleChild_8237920533349931307(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      my_modelField.addRootNode(child._0());
    }
  }
  public class PersistenceElementHandler extends ModelReader9Handler.ElementHandler {
    public PersistenceElementHandler() {
    }
  }
  public class Model_attributeElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_attributeElementHandler() {
      setRequiredAttributes("name", "value");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_modelField.getSModelHeader().setOptionalProperty(attrs.getValue("name"), attrs.getValue("value"));
      return null;
    }
  }
  public class RegistryElementHandler extends ModelReader9Handler.ElementHandler {
    public RegistryElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("language".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_languageHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_languageElementHandler() {
      setRequiredAttributes("id", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withLanguage(attrs.getValue("id"), attrs.getValue("name"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("concept".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_conceptHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_conceptElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_conceptElementHandler() {
      setRequiredAttributes("id", "name", "index", "flags");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withConcept(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), attrs.getValue("flags"), attrs.getValue("stub"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_propertyHandler;
      }
      if ("reference".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_associationHandler;
      }
      if ("child".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_aggregationHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_propertyElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_propertyElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.property(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_associationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_associationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.association(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_aggregationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_aggregationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.aggregation(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), Boolean.parseBoolean(attrs.getValue("unordered")));
      return null;
    }
  }
  public class LanguagesElementHandler extends ModelReader9Handler.ElementHandler {
    public LanguagesElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("use".equals(tagName)) {
        myChildHandlersStack.push(null);
        return used_languageHandler;
      }
      if ("generationPart".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804036(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      if ("devkit".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804044(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private void handleChild_5480414999147804036(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addEngagedOnGenerationLanguage(child);
    }
    private void handleChild_5480414999147804044(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addDevKit(child);
    }
  }
  public class Used_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Used_languageElementHandler() {
      setRequiredAttributes("id", "version", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SLanguageId langId = my_idEncoderField.parseLanguageId(attrs.getValue("id"));
      int langVersion = Integer.parseInt(attrs.getValue("version"));
      my_modelField.addLanguage(my_readHelperParam.getLanguage(langId, attrs.getValue("name")),langVersion);
      return null;
    }
  }
  public class Module_referenceElementHandler extends ModelReader9Handler.ElementHandler {
    public Module_referenceElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected SModuleReference createObject(Attributes attrs) throws SAXException {
      return my_idEncoderField.parseModuleReference(attrs.getValue("ref"));
    }
  }
  public class ImportsElementHandler extends ModelReader9Handler.ElementHandler {
    public ImportsElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("import".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_importHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Model_importElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_importElementHandler() {
      setRequiredAttributes("index", "ref");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SModelReference modelRef = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_importHelperField.addModelImport(attrs.getValue("index"), modelRef);
      if (!(Boolean.parseBoolean(attrs.getValue("implicit")))) {
        my_modelField.addModelImport(new SModel.ImportElement(modelRef));
      }
      return null;
    }
  }
  public class NodeElementHandler extends ModelReader9Handler.ElementHandler {
    public NodeElementHandler() {
      setRequiredAttributes("concept", "id");
    }
    @Override
    protected Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> createObject(Attributes attrs) throws SAXException {
      SConcept concept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      boolean interfaceNode = false;
      if (my_readHelperParam.isRequestedInterfaceOnly()) {
        interfaceNode = (my_readHelperParam.isInterface(concept) || attrs.getValue("role") == null);
      }
      SNodeId nodeId;
      try {
        nodeId = my_idEncoderField.parseNodeId(attrs.getValue("id"));
      } catch (IdEncoder.EncodingException e) {
        throw new IllegalArgumentException(e);
      }
      SNode result = (interfaceNode ? new InterfaceSNode(concept, nodeId) : new SNode(concept, nodeId));
      
      return MultiTuple.<org.jetbrains.mps.openapi.model.SNode,SContainmentLink>from(((org.jetbrains.mps.openapi.model.SNode) result), my_readHelperParam.readAggregation(attrs.getValue("role")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804176(resultObject, value);
          }
        });
        return propertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_4968492044127349726(resultObject, value);
          }
        });
        return referenceHandler;
      }
      if ("node".equals(tagName) && checknode_8237920533350080210(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804300(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804248(resultObject, value);
          }
        });
        return nodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533350080210(Object resultObject, Attributes attrs) {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      SConcept childConcept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(childConcept)) {
        return true;
      }
      return result._0() instanceof InterfaceSNode && !(my_readHelperParam.isInterface(childConcept));
    }
    private void handleChild_5480414999147804176(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SProperty, String> child = (Tuples._2<SProperty, String>) value;
      result._0().setProperty(child._0(), child._1());
    }
    private void handleChild_4968492044127349726(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._4<SReferenceLink, SModelReference, SNodeId, String> child = (Tuples._4<SReferenceLink, SModelReference, SNodeId, String>) value;
      SModelReference targetModel = child._1();
      SNodeId nodeId = child._2();
      SReferenceLink link = child._0();
      String resolveInfo = child._3();
      StaticReference ref = new StaticReference(link, result._0(), targetModel, nodeId, resolveInfo);
      result._0().setReference(link, ref);
    }
    private void handleChild_5480414999147804300(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SContainmentLink link = child._0();
      SConcept concept = child._1();
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        SNode childNode = new SNode(stubConcept);
        result._0().addChild(link, childNode);
        return;
      }
      if (result._0() instanceof InterfaceSNode) {
        ((InterfaceSNode) result._0()).skipRole(link);
      }
    }
    private void handleChild_5480414999147804248(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      result._0().addChild(child._1(), child._0());
    }
  }
  public class PropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public PropertyElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._2<SProperty, String> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SProperty,String>from(my_readHelperParam.readProperty(attrs.getValue("role")), attrs.getValue("value"));
    }
  }
  public class ReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public ReferenceElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._4<SReferenceLink, SModelReference, SNodeId, String> createObject(Attributes attrs) throws SAXException {
      SReferenceLink association = my_readHelperParam.readAssociation(attrs.getValue("role"));
      if (attrs.getValue("node") != null) {
        
        SNodeId targetNode = my_idEncoderField.parseLocalNodeReference(attrs.getValue("node"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, my_modelField.getReference(), targetNode, attrs.getValue("resolve"));
      } else {
        Pair<SModelReference, SNodeId> r = my_idEncoderField.parseExternalNodeReference(my_importHelperField, attrs.getValue("to"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, r.o1, r.o2, attrs.getValue("resolve"));
      }
    }
  }
  public class IgnoredNodeElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredNodeElementHandler() {
      setRequiredAttributes("concept");
    }
    @Override
    protected Tuples._2<SContainmentLink, SConcept> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SContainmentLink,SConcept>from(my_readHelperParam.readAggregation(attrs.getValue("role")), my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredPropertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredReferenceHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredNodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class IgnoredPropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredPropertyElementHandler() {
    }
  }
  public class IgnoredReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredReferenceElementHandler() {
    }
  }
}

<code block>

package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.ModelWithDisposeInfo;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.event.SModelListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.Map;

public interface SModelInternal extends ModelWithDisposeInfo  {

  void addModelListener(@NotNull SModelListener listener);

  void removeModelListener(@NotNull SModelListener listener);

  ModelDependenciesManager getModelDepsManager();

  @Deprecated
  List<SModuleReference> importedLanguages();

  @Deprecated
  void deleteLanguage(@NotNull SModuleReference ref);

  @Deprecated
  void addLanguage(SModuleReference ref);

  
  java.util.Collection<SLanguage> importedLanguageIds();

  
  void deleteLanguageId(@NotNull SLanguage ref);

  void addLanguage(Language language);

  void addLanguage(@NotNull SLanguage language);

  void addLanguage(@NotNull SLanguage language, int version);

  
  @Deprecated
  void addLanguageId(SLanguage ref, int version);

  List<SModuleReference> importedDevkits();

  void addDevKit(SModuleReference ref);

  void deleteDevKit(@NotNull SModuleReference ref);

  List<ImportElement> importedModels();

  void addModelImport(SModelReference modelReference, boolean firstVersion);

  void addModelImport(ImportElement importElement);

  void deleteModelImport(SModelReference modelReference);

  
  void calculateImplicitImports();

  List<SModuleReference> engagedOnGenerationLanguages();

  void addEngagedOnGenerationLanguage(SModuleReference ref);

  void removeEngagedOnGenerationLanguage(SModuleReference ref);

  List<ImportElement> getAdditionalModelVersions();

  boolean updateSModelReferences();

  void changeModelReference(SModelReference newModelReference);

  boolean updateModuleReferences();
}

<code block>

package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.nodeidmap.INodeIdToNodeMap;
import jetbrains.mps.smodel.nodeidmap.UniversalOptimizedNodeIdMap;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

public class SModel implements SModelData {
  private static final Logger LOG = LogManager.getLogger(SModel.class);
  private static AtomicLong ourCounter = new AtomicLong();

  static {
    resetIdCounter();
  }

  protected SModelBase myModelDescriptor;
  private Set<SNode> myRoots = new LinkedHashSet<SNode>();
  private SModelReference myReference;
  private boolean myDisposed;
  private List<SModuleReference> myLanguagesEngagedOnGeneration = new ArrayList<SModuleReference>();
  private Map<SLanguage, Integer> myLanguagesIds = new LinkedHashMap<SLanguage, Integer>();
  private List<SModuleReference> myDevKits = new ArrayList<SModuleReference>();
  private List<ImportElement> myImports = new ArrayList<ImportElement>();
  private INodeIdToNodeMap myIdToNodeMap;
  private StackTraceElement[] myDisposedStacktrace = null;
  private ModelDependenciesManager myModelDependenciesManager;
  private ImplicitImportsLegacyHolder myLegacyImplicitImports;
  
  private boolean myIsFullLoadMode = false;
  
  @NotNull
  private final AttachedNodeOwner myNodeOwner;

  public SModel(@NotNull SModelReference modelReference) {
    this(modelReference, new UniversalOptimizedNodeIdMap());
  }

  public SModel(@NotNull SModelReference modelReference, INodeIdToNodeMap map) {
    myReference = modelReference;
    myIdToNodeMap = map;
    myNodeOwner = new AttachedNodeOwner(this);
  }

  static void resetIdCounter() {
    ourCounter.set(Math.abs(new SecureRandom().nextLong()));
  }

  public static SNodeId generateUniqueId() {
    long id = Math.abs(ourCounter.incrementAndGet());
    return new jetbrains.mps.smodel.SNodeId.Regular(id);
  }


  public SModelId getModelId() {
    return myReference.getModelId();
  }

  @NotNull
  public SModelReference getReference() {
    return myReference;
  }

  @Override
  public Iterable<org.jetbrains.mps.openapi.model.SNode> getRootNodes() {
    fireModelNodesReadAccess();
    return new Iterable<org.jetbrains.mps.openapi.model.SNode>() {
      @Override
      public Iterator<org.jetbrains.mps.openapi.model.SNode> iterator() {
        return new Iterator<org.jetbrains.mps.openapi.model.SNode>() {
          private final Iterator<SNode> myIterator = myRoots.iterator();

          @Override
          public boolean hasNext() {
            return myIterator.hasNext();
          }

          @Override
          public org.jetbrains.mps.openapi.model.SNode next() {
            SNode res = myIterator.next();
            if (res != null) {
              res.assertCanRead();
              res.getNodeOwner().fireNodeRead(res, true);
            }

            return res;
          }

          @Override
          public void remove() {
            throw new UnsupportedOperationException("can't change model roots through roots iterator");
          }
        };
      }
    };
  }

  public boolean isRoot(@Nullable org.jetbrains.mps.openapi.model.SNode node) {
    return myRoots.contains(node);
  }

  

  @Override
  public void addRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      
      return;
    }
    org.jetbrains.mps.openapi.model.SModel model = node.getModel();
    
    if (model != null && model != myModelDescriptor && node.getParent() == null) {
      model.removeRootNode(node);
    } else {
      org.jetbrains.mps.openapi.model.SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      }
    }

    SNode sn = (SNode) node;
    myRoots.add(sn);
    sn.attach(myNodeOwner);
    performUndoableAction(new AddRootUndoableAction(node));
    myNodeOwner.fireNodeAdd(null, null, sn, null);
  }

  @Override
  public void removeRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeUnRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      myNodeOwner.fireBeforeNodeRemove(null, null, (SNode) node, null);
      myRoots.remove(node);
      SNode sn = (SNode) node;
      sn.detach(new DetachedNodeOwner(this));
      performUndoableAction(new RemoveRootUndoableAction(node, myModelDescriptor));
      myNodeOwner.fireNodeRemove(null, null, sn, null);
    }
  }

  @Override
  @Nullable
  public SNode getNode(@NotNull org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    SNode res = getNode_(nodeId);
    if (res != null) {
      res.assertCanRead();
      myNodeOwner.fireNodeRead(res, true);
    }
    return res;
  }

  private SNode getNode_(org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    checkNotDisposed();
    if (myDisposed) return null;

    org.jetbrains.mps.openapi.model.SNode node = myIdToNodeMap.get(nodeId);
    if (node != null) return ((SNode) node);
    enforceFullLoad();
    return ((SNode) myIdToNodeMap.get(nodeId));
  }

  @NotNull
  public String toString() {
    return myReference.toString();
  }

  
  public boolean isDisposed() {
    return myDisposed;
  }

  
  public StackTraceElement[] getDisposedStacktrace() {
    return myDisposedStacktrace;
  }

  @Deprecated
  public void addModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().addModelListener(listener);
  }

  @Deprecated
  public void removeModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().removeModelListener(listener);
  }

  
  public SModelBase getModelDescriptor() {
    return myModelDescriptor;
  }

  
  public synchronized void setModelDescriptor(org.jetbrains.mps.openapi.model.SModel modelDescriptor) {
    if (myModelDescriptor == modelDescriptor) {
      
      return;
    }
    myModelDescriptor = ((SModelBase) modelDescriptor);
    myNodeOwner.setEventDispatch(modelDescriptor == null ? null : myModelDescriptor.getEventDispatch());
  }

  protected void enforceFullLoad() {
    org.jetbrains.mps.openapi.model.SModel md = myModelDescriptor;
    if (md != null) {
      md.load();
    }
  }

  private void fireModelNodesReadAccess() {
    if (!canFireReadEvent()) return;
    if (myModelDescriptor != null) {
      NodeReadEventsCaster.fireModelNodesReadAccess(myModelDescriptor);
    }
  }



  
  @Deprecated
  @ToRemove(version = 3.3)
  protected void performUndoableAction(Computable<SNodeUndoableAction> action) {
    if (!canFireEvent()) return;
    if (!UndoHelper.getInstance().needRegisterUndo()) return;
    performUndoableAction(action.compute());
  }

  protected void performUndoableAction(@NotNull SNodeUndoableAction action) {
    if (!canFireEvent()) {
      return;
    }
    final UndoHelper uh = UndoHelper.getInstance();
    if (uh.needRegisterUndo()) {
      uh.addUndoableAction(action);
    }
  }

    

  public boolean canFireEvent() {
    return myModelDescriptor != null && jetbrains.mps.util.SNodeOperations.isRegistered(myModelDescriptor) && !isUpdateMode();
  }

  public boolean canFireReadEvent() {
    return canFireEvent();
  }

  public void dispose() {
    assertLegalChange();
    if (myDisposed) return;

    myDisposed = true;
    myDisposedStacktrace = new Throwable().getStackTrace();
    myIdToNodeMap = null;
    myRoots.clear();
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.dispose();
      myModelDependenciesManager = null;
    }
  }

  private void checkNotDisposed() {
    if (!myDisposed) return;
    LOG.error(new IllegalModelAccessError("accessing disposed model"));
  }

  private List<SModelListener> getModelListeners() {
    if (myModelDescriptor == null) return Collections.emptyList();
    return ((SModelBase) myModelDescriptor).getModelListeners();
  }

  private void fireDevKitAddedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireDevKitRemovedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageAddedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageRemovedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportAddedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportRemovedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireRootAddedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireRootRemovedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireBeforeRootRemovedEvent(org.jetbrains.mps.openapi.model.SNode node) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), node, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeRootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void firePropertyChangedEvent(@NotNull SNode node, @NotNull SProperty property, @Nullable String oldValue, @Nullable String newValue) {
    if (!canFireEvent()) {
      return;
    }
    final SModelPropertyEvent event = new SModelPropertyEvent(getModelDescriptor(), property, node, oldValue, newValue);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.propertyChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildAddedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), true, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireBeforeChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeChildRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceAddedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceRemovedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  public FastNodeFinder createFastNodeFinder() {
    return new DefaultFastNodeFinder(getModelDescriptor());
  }

  

  void registerNode(@NotNull SNode node) {
    checkNotDisposed();
    if (myDisposed) return;

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (id == null) {
      assignNewId(node);
      return;
    }

    org.jetbrains.mps.openapi.model.SNode existingNode = myIdToNodeMap.get(id);
    if (existingNode == null) {
      myIdToNodeMap.put(node.getNodeId(), node);
    }

    if (existingNode != null && existingNode != node) {
      assignNewId(node);
    }
  }

  private void assignNewId(SNode node) {
    SNodeId id;
    id = generateUniqueId();
    while (myIdToNodeMap.containsKey(id)) {
      resetIdCounter();
      id = generateUniqueId();
    }
    node.setId(id);
    myIdToNodeMap.put(id, node);
  }

  

  void unregisterNode(@NotNull SNode node) {
    checkNotDisposed();

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (myDisposed || id == null) return;
    myIdToNodeMap.remove(id);
  }

  public ModelDependenciesManager getModelDepsManager() {
    if (myModelDependenciesManager == null) {
      myModelDependenciesManager = new ModelDependenciesManager(getModelDescriptor());
      
      SRepository repo = getRepository();
      if (repo != null) {
        myModelDependenciesManager.trackRepositoryChanges(repo);
      }
    }
    return myModelDependenciesManager;
  }

  private void invalidateModelDepsManager() {
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.invalidate();
    }
  }

  

  public Collection<SLanguage> usedLanguages() {
    return Collections.unmodifiableSet(myLanguagesIds.keySet());
  }

  public Map<SLanguage, Integer> usedLanguagesWithVersions() {
    return Collections.unmodifiableMap(myLanguagesIds);
  }

  public void deleteLanguage(@NotNull SLanguage id) {
    assertLegalChange();
    if (myLanguagesIds.remove(id) != null) {
      invalidateModelDepsManager();
      fireLanguageRemovedEvent(id);
      markChanged();
    }
  }

  public void addLanguage(@NotNull SLanguage language) {
    addLanguage(language, language.getLanguageVersion());
  }

  public void addLanguage(SLanguage id, int version) {
    assertLegalChange();

    Integer existingVersion = myLanguagesIds.get(id);
    if (existingVersion != null) {
      if (version == -1 || existingVersion == version) {
        return;
      }
      if (existingVersion == -1) {
        myLanguagesIds.remove(id);
      } else {
        throw new IllegalStateException("Can't add language import with different version. Old version: " + existingVersion + "; new version: " + version);
      }
    }

    myLanguagesIds.put(id, version);
    invalidateModelDepsManager();
    fireLanguageAddedEvent(id);
    markChanged();
  }

  

  public List<SModuleReference> importedDevkits() {
    return Collections.unmodifiableList(myDevKits);
  }

  public void addDevKit(SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.add(ref)) {
      invalidateModelDepsManager();
      fireDevKitAddedEvent(ref);
      markChanged();
    }
  }

  public void deleteDevKit(@NotNull SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.remove(ref)) {
      invalidateModelDepsManager();
      fireDevKitRemovedEvent(ref);
      markChanged();
    }
  }

  

  public List<ImportElement> importedModels() {
    return Collections.unmodifiableList(myImports);
  }

  public void addModelImport(ImportElement importElement) {
    assertLegalChange();

    myImports.add(importElement);
    fireImportAddedEvent(importElement.getModelReference());
    markChanged();
  }

  public void deleteModelImport(SModelReference modelReference) {
    assertLegalChange();

    ImportElement importElement = SModelOperations.getImportElement(this, modelReference);
    if (importElement != null) {
      myImports.remove(importElement);
      if (myLegacyImplicitImports != null) {
        
        myLegacyImplicitImports.addAdditionalModelVersion(importElement);  
      }
      fireImportRemovedEvent(modelReference);
      markChanged();
    }
  }

  
  @NotNull
  public ImplicitImportsLegacyHolder getImplicitImportsSupport() {
    if (myLegacyImplicitImports == null) {
      myLegacyImplicitImports = new ImplicitImportsLegacyHolder(this);
    }
    return myLegacyImplicitImports;
  }
  
  
  Iterable<org.jetbrains.mps.openapi.model.SNode> allNodes() {
    return myIdToNodeMap.values();
  }

  
  
  @ToRemove(version = 3.2)
  List<ImportElement> getAllImportElements() {
    List<ImportElement> result = new ArrayList<ImportElement>();
    result.addAll(myImports);
    if (myLegacyImplicitImports != null) {
      result.addAll(myLegacyImplicitImports.getAdditionalModelVersions());
    }
    return result;
  }

  public List<SModuleReference> engagedOnGenerationLanguages() {
    return myLanguagesEngagedOnGeneration;
  }

  private void markChanged() {
    if (myModelDescriptor == null) return;
    org.jetbrains.mps.openapi.model.SModel model = getModelDescriptor();
    if (model instanceof EditableSModel) {
      ((EditableSModel) model).setChanged(true);
    }
  }

  public void addEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (!myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.add(ref);
      
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  public void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.remove(ref);
      
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  

  public boolean isUpdateMode() {
    return myIsFullLoadMode;
  }

  public void setUpdateMode(boolean value) {
    
    this.myIsFullLoadMode = value;
  }

  
  protected SRepository getRepository() {
    return myModelDescriptor == null ? null : myModelDescriptor.getRepository();
  }

  private void assertLegalChange() {
    if (myModelDescriptor != null) {
      
      
      ModelChange.assertLegalChange_new(myModelDescriptor);
    }
  }

  

  public boolean updateSModelReferences() {
    assertLegalChange();
    enforceFullLoad();

    boolean changed = false;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        SModelReference oldReference = reference.getTargetSModelReference();
        if (oldReference == null) continue;
        jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) oldReference;
        jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
        if (newRef.differs(oldSRef)) {
          changed = true;
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newRef);
        }
      }
    }

    for (ImportElement e : myImports) {
      jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) e.myModelReference;
      jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
      if (newRef.differs(oldSRef)) {
        changed = true;
        e.myModelReference = newRef;
      }
    }
    if (myLegacyImplicitImports != null) {
      changed |= myLegacyImplicitImports.updateSModelReferences();
    }

    return changed;
  }

  public boolean updateModuleReferences() {
    assertLegalChange();


    boolean changed = false;

    if (updateRefs(myDevKits)) {
      changed = true;
    }
    if (updateRefs(myLanguagesEngagedOnGeneration)) {
      changed = true;
    }

    return changed;
  }

  public void changeModelReference(SModelReference newModelReference) {
    enforceFullLoad();
    SModelReference oldReference = myReference;
    myReference = newModelReference;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        if (oldReference.equals(reference.getTargetSModelReference())) {
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newModelReference);
        }
      }
    }
  }

  public boolean updateRefs(List<SModuleReference> refs) {
    boolean changed = false;
    for (int i = 0; i < refs.size(); i++) {
      SModuleReference ref = refs.get(i);
      SModule module = ModuleRepositoryFacade.getInstance().getModule(ref);
      if (module != null) {
        SModuleReference newRef = module.getModuleReference();
        refs.set(i, newRef);
        changed = changed || ModuleReference.differs(ref, newRef);
      }
    }
    return changed;
  }

  public SModel createEmptyCopy() {
    return new jetbrains.mps.smodel.SModel(getReference());
  }

  public void copyPropertiesTo(SModel to) {
    if (myLegacyImplicitImports != null) {
      for (ImportElement ie : myLegacyImplicitImports.getAdditionalModelVersions()) {
        to.getImplicitImportsSupport().addAdditionalModelVersion(ie.copy());
      }
    }
    for (ImportElement ie : importedModels()) {
      to.addModelImport(ie.copy());
    }
    for (SModuleReference mr : importedDevkits()) {
      to.addDevKit(mr);
    }
    for (SLanguage lang : usedLanguages()) {
      to.addLanguage(lang);
    }
    for (SModuleReference mr : engagedOnGenerationLanguages()) {
      to.addEngagedOnGenerationLanguage(mr);
    }
  }

  public static class ImportElement {
    private SModelReference myModelReference;
    private int myReferenceID;  
    private int myUsedVersion;

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID) {
      this(modelReference, referenceID, -1);
    }

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID, int usedVersion) {
      myModelReference = modelReference;
      myReferenceID = referenceID;
      myUsedVersion = usedVersion;
    }

    public ImportElement(SModelReference modelReference) {
      myModelReference = modelReference;
      myReferenceID = 0;
      myUsedVersion = -1;
    }

    public SModelReference getModelReference() {
      return myModelReference;
    }

    public void setModelReference(SModelReference modelReference) {
      myModelReference = modelReference;
    }

    public int getReferenceID() {
      return myReferenceID;
    }

    public void setReferenceID(int referenceID) {
      myReferenceID = referenceID;
    }

    public int getUsedVersion() {
      return myUsedVersion;
    }

    protected ImportElement copy() {
      return new ImportElement(myModelReference, myReferenceID, myUsedVersion);
    }

    public String toString() {
      return "ImportElement(" +
          "uid=" + myModelReference + ", " +
          "referenceId=" + myReferenceID + ", " +
          "usedVersion=" + myUsedVersion + ")";
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      ImportElement that = (ImportElement) o;

      if (myReferenceID != that.myReferenceID) return false;
      if (myUsedVersion != that.myUsedVersion) return false;
      if (myModelReference != null ? !myModelReference.equals(that.myModelReference) : that.myModelReference != null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      int result = myModelReference != null ? myModelReference.hashCode() : 0;
      result = 31 * result + myReferenceID;
      result = 31 * result + myUsedVersion;
      return result;
    }
  }

}

<code block>

package jetbrains.mps.smodel.language;

import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.classloading.MPSClassesListener;
import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import static java.lang.String.format;


public class LanguageRegistry implements CoreComponent, MPSClassesListener {
  private static final Logger LOG = LogManager.getLogger(LanguageRegistry.class);

  private static LanguageRegistry INSTANCE;

  public static LanguageRegistry getInstance() {
    return INSTANCE;
  }

  private Map<String, LanguageRuntime> myLanguages = new HashMap<String, LanguageRuntime>();
  private Map<SLanguageId, LanguageRuntime> myLanguagesById = new HashMap<SLanguageId, LanguageRuntime>();

  private final List<LanguageRegistryListener> myLanguageListeners = new CopyOnWriteArrayList<LanguageRegistryListener>();

  private final SRepository myRepository;
  private final ClassLoaderManager myClassLoaderManager;

  public LanguageRegistry(SRepository repository, ClassLoaderManager loaderManager) {
    myRepository = repository;
    myClassLoaderManager = loaderManager;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myClassLoaderManager.addClassesHandler(this);
  }

  @Override
  public void dispose() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        notifyUnload(myLanguages.values());
        myLanguages.clear();
        myLanguagesById.clear();
      }
    });
    myClassLoaderManager.removeClassesHandler(this);
    INSTANCE = null;
  }

  private void notifyUnload(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.beforeLanguagesUnloaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language unloading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  private void notifyLoad(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.afterLanguagesLoaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language loading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  @Nullable
  private static LanguageRuntime createRuntime(Language l) {
    final String rtClassName = l.getModuleName() + ".Language";
    
    
    
    
    
    
    
    
    
    try {
      final Class<?> rtClass = l.getOwnClass(rtClassName);
      if (rtClass != null && LanguageRuntime.class.isAssignableFrom(rtClass)) {
        return ((Class<LanguageRuntime>) rtClass).newInstance();
      }
      return new InterpretedLanguageRuntime(l);
    } catch (ClassNotFoundException ex) {
      return new InterpretedLanguageRuntime(l);
    } catch (InstantiationException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    } catch (IllegalAccessException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    }
  }

  public String toString() {
    return "LanguageRegistry";
  }

  public void addRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.add(listener);
  }

  public void removeRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.remove(listener);
  }

  
  public Collection<LanguageRuntime> getAvailableLanguages() {
    myRepository.getModelAccess().checkReadAccess();
    return myLanguages.values();
  }

  public Collection<SLanguage> getAllLanguages() {
    final Collection<LanguageRuntime> languages = getAvailableLanguages();
    ArrayList<SLanguage> rv = new ArrayList<SLanguage>(languages.size());
    for (LanguageRuntime lr : languages) {
      rv.add(MetaAdapterFactory.getLanguage(lr.getId(), lr.getNamespace()));
    }
    return rv;
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguage language) {
    return ((SLanguageAdapter) language).getLanguageDescriptor();
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguageId id) {
    return myLanguagesById.get(id);
  }

  @Nullable
  public LanguageRuntime getLanguage(String namespace) {
    return myLanguages.get(namespace);
  }

  public LanguageRuntime getLanguage(Language language) {
    return getLanguage(language.getModuleName());
  }

  
  public GeneratorRuntime getGenerator(Generator generator) {
    LanguageRuntime lr = getLanguage(generator.getSourceLanguage());
    if (lr == null) {
      return null;
    }
    for (GeneratorRuntime grt : lr.getGenerators()) {
      if (grt.getModuleReference().equals(generator.getModuleReference())) {
        return grt;
      }
    }
    return null;
  }

  
  @Override
  public void beforeClassesUnloaded(Set<? extends ReloadableModuleBase> unloadedModules) {
    Set<LanguageRuntime> languagesToUnload = new HashSet<LanguageRuntime>();
    for (SLanguageId languageId : collectLanguagesToUnload(unloadedModules)) {
      if (!myLanguagesById.containsKey(languageId)) {
        LOG.warn("No language with id " + languageId + " to unload");
      } else {
        languagesToUnload.add(myLanguagesById.get(languageId));
      }
    }

    notifyUnload(languagesToUnload);

    for (LanguageRuntime languageRuntime : languagesToUnload) {
      myLanguages.remove(languageRuntime.getNamespace());
      myLanguagesById.remove(languageRuntime.getId());
    }
    reinitialize();
  }

  @Override
  public void afterClassesLoaded(Set<? extends ReloadableModuleBase> loadedModules) {
    Set<LanguageRuntime> loadedRuntimes = new HashSet<LanguageRuntime>();
    for (Language language : collectLanguagesToLoad(loadedModules)) {
      SLanguageId languageId = MetaIdByDeclaration.getLanguageId(language);
      if (myLanguagesById.containsKey(languageId)) {
        LOG.error("", new IllegalArgumentException(String.format("There is already a language '%s' with id '%s'", myLanguagesById.get(languageId), languageId)));
        continue;
      }
      try {
        LanguageRuntime langRuntime = createRuntime(language);
        if (langRuntime == null) continue;

        String langName = langRuntime.getNamespace();
        if (myLanguages.containsKey(langName)) {
          LOG.warn(String.format("There is already a language '%s' with a name '%s'", myLanguages.get(langName), langName));
        }
        myLanguages.put(langName, langRuntime);
        myLanguagesById.put(languageId, langRuntime);
        loadedRuntimes.add(langRuntime);
      } catch (LinkageError le) {
        processLinkageErrorForLanguage(language, le);
      }
    }
    reinitialize();
    notifyLoad(loadedRuntimes);
  }

  private Iterable<SLanguageId> collectLanguagesToUnload(Set<? extends SModule> unloadedModules) {
    Collection<SLanguageId> languagesToUnload = new ArrayList<SLanguageId>();
    for (SModule unloadedModule : unloadedModules) {
      if (unloadedModule instanceof Language) {
        languagesToUnload.add(MetaIdByDeclaration.getLanguageId((Language) unloadedModule));
      }
    }
    return languagesToUnload;
  }

  private Iterable<Language> collectLanguagesToLoad(Set<? extends SModule> loadedModules) {
    Collection<Language> languagesToLoad = new ArrayList<Language>();
    for (SModule loadedModule : loadedModules) {
      if (loadedModule instanceof Language) {
        languagesToLoad.add((Language) loadedModule);
      }
    }

    return languagesToLoad;
  }

  private void reinitialize() {
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.deinitialize();
    }
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.initialize(this);
    }
  }

  private static void processLinkageErrorForLanguage(Language language, LinkageError linkageError) {
    LOG.error("Caught a linkage error while creating LanguageRuntime for the `" + language + "` language." +
        "Probably the language sources/classes are outdated, try rebuilding the project.", linkageError);
    LOG.warn("MPS will attempt running in a inconsistent state.");
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterById;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterById;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterById;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.util.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.annotations.Immutable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public abstract class MetaAdapterFactory {
  private static final ConcurrentMap<LangKey, SLanguage> ourLanguageIds = new ConcurrentHashMap<LangKey, SLanguage>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SConcept> ourConceptIds = new ConcurrentHashMap<Pair<SConceptId, String>, SConcept>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SInterfaceConcept> ourIntfcConceptIds =
      new ConcurrentHashMap<Pair<SConceptId, String>, SInterfaceConcept>();
  private static final ConcurrentMap<Pair<SPropertyId, String>, SProperty> ourPropertyIds = new ConcurrentHashMap<Pair<SPropertyId, String>, SProperty>();
  private static final ConcurrentMap<Pair<SReferenceLinkId, String>, SReferenceLink> ourRefIds =
      new ConcurrentHashMap<Pair<SReferenceLinkId, String>, SReferenceLink>();
  private static final ConcurrentMap<Pair<SContainmentLinkId, String>, SContainmentLink> ourLinkIds =
      new ConcurrentHashMap<Pair<SContainmentLinkId, String>, SContainmentLink>();

  @NotNull
  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName) {
    SLanguageAdapterById l = new SLanguageAdapterById(id, langName);
    LangKey p = new LangKey(id, langName);
    ourLanguageIds.putIfAbsent(p, l);
    return ourLanguageIds.get(p);
  }

  @NotNull
  public static SLanguage getLanguage(long uuidHigh, long uuidLow, String langName) {
    return getLanguage(MetaIdFactory.langId(uuidHigh, uuidLow), langName);
  }

  @NotNull
  @Deprecated 
  public static SLanguage getLanguage(UUID lang, String langName) {
    return getLanguage(MetaIdFactory.langId(lang), langName);
  }

  @NotNull
  public static SLanguage getLanguage(@NotNull SModuleReference languageModuleRef) {
    return getLanguage(MetaIdByDeclaration.ref2LangId(languageModuleRef), languageModuleRef.getModuleName());
  }

  @NotNull
  public static SConcept getConcept(SConceptId id, String conceptName) {
    SConceptAdapterById c = new SConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourConceptIds.putIfAbsent(p, c);
    return ourConceptIds.get(p);
  }

  @NotNull
  public static SConcept getConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated 
  public static SConcept getConcept(UUID lang, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(SConceptId id, String conceptName) {
    SInterfaceConceptAdapterById c = new SInterfaceConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourIntfcConceptIds.putIfAbsent(p, c);
    return ourIntfcConceptIds.get(p);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated 
  public static SInterfaceConcept getInterfaceConcept(UUID lang, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SProperty getProperty(SPropertyId id, String propName) {
    SPropertyAdapterById c = new SPropertyAdapterById(id, propName);
    Pair<SPropertyId, String> p = new Pair<SPropertyId, String>(id, propName);
    ourPropertyIds.putIfAbsent(p, c);
    return ourPropertyIds.get(p);
  }

  @NotNull
  public static SProperty getProperty(long uuidHigh, long uuidLow, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(uuidHigh, uuidLow, concept, prop), propName);
  }

  @NotNull
  @Deprecated 
  public static SProperty getProperty(UUID lang, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(lang, concept, prop), propName);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(SReferenceLinkId id, String refName) {
    SReferenceLinkAdapterById c = new SReferenceLinkAdapterById(id, refName);
    Pair<SReferenceLinkId, String> p = new Pair<SReferenceLinkId, String>(id, refName);
    ourRefIds.putIfAbsent(p, c);
    return ourRefIds.get(p);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(long uuidHigh, long uuidLow, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(uuidHigh, uuidLow, concept, ref), refName);
  }

  @NotNull
  @Deprecated 
  public static SReferenceLink getReferenceLink(UUID lang, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(lang, concept, ref), refName);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(SContainmentLinkId id, String linkName) {
    SContainmentLinkAdapterById c = new SContainmentLinkAdapterById(id, linkName);
    Pair<SContainmentLinkId, String> p = new Pair<SContainmentLinkId, String>(id, linkName);
    ourLinkIds.putIfAbsent(p, c);
    return ourLinkIds.get(p);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(long uuidHigh, long uuidLow, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(uuidHigh, uuidLow, concept, link), linkName);
  }

  @NotNull
  @Deprecated 
  public static SContainmentLink getContainmentLink(UUID lang, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(lang, concept, link), linkName);
  }

  @NotNull
  public static SAbstractConcept getAbstractConcept(ConceptDescriptor descriptor) {
    if (descriptor.isInterfaceConcept()) {
      return getInterfaceConcept(descriptor.getId(), descriptor.getConceptFqName());
    } else {
      return getConcept(descriptor.getId(), descriptor.getConceptFqName());
    }
  }

  @Immutable
  private static class LangKey {
    private final SLanguageId myId;
    private final String myName;

    public LangKey(SLanguageId id, String name) {
      myId = id;
      myName = name;
    }

    @Override
    public int hashCode() {
      return myId.hashCode() * 31 + myName.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      if (obj instanceof LangKey) {
        LangKey o = (LangKey) obj;
        return myId.equals(o.myId) && myName.equals(o.myName);
      }
      return false;
    }
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterByName;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterByName;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterByName;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterByName;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;


public class MetaAdapterFactoryByName {
  public static SLanguage getLanguage(String langName) {
    return new SLanguageAdapterByName(langName);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  
  public static SConcept getConcept(String conceptName) {
    return new SConceptAdapterByName(conceptName);
  }

  public static SInterfaceConcept getInterfaceConcept(String conceptName) {
    return new SInterfaceConceptAdapterByName(conceptName);
  }

  
  public static SProperty getProperty(String conceptName, String propName) {
    return new SPropertyAdapterByName(conceptName, propName);
  }

  
  public static SReferenceLink getReferenceLink(String conceptName, String refName) {
    return new SReferenceLinkAdapterByName(conceptName, refName);
  }

  
  public static SContainmentLink getContainmentLink(String conceptName, String linkName) {
    return new SContainmentLinkAdapterByName(conceptName, linkName);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  
  
  public static SAbstractConcept getTypedConcept_DoNotUse(String conceptName) {
    final ConceptDescriptor cd = ConceptRegistry.getInstance().getConceptDescriptor(conceptName);
    if (cd instanceof IllegalConceptDescriptor) return MetaAdapterFactoryByName.getConcept(conceptName);
    return MetaAdapterFactory.getAbstractConcept(cd);
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterByName extends SLanguageAdapter {
  public SLanguageAdapterByName(@NotNull String language) {
    super(language);
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguageFqName);
  }

  @Override
  public SLanguageId getId() {
    LanguageRuntime lr = getLanguageDescriptor();
    if (lr != null) {
      return lr.getId();
    }
    Language l = getSourceModule();
    if (l != null) {
      return MetaIdByDeclaration.getLanguageId(l);
    }
    return MetaIdFactory.INVALID_LANGUAGE_ID;
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ModuleRepositoryFacade.getInstance().getModule(myLanguageFqName, Language.class);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return false;
    return myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterById extends SLanguageAdapter {
  private final SLanguageId myLanguage;

  public SLanguageAdapterById(@NotNull SLanguageId language, @NotNull String fqName) {
    super(fqName);
    this.myLanguage = language;
  }

  @NotNull
  public SLanguageId getId() {
    return myLanguage;
  }

  @Override
  public String getQualifiedName() {
    LanguageRuntime ld = getLanguageDescriptor();
    if (ld == null) {
      return myLanguageFqName;
    }
    return ld.getNamespace();
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguage);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return  false;
    return ( obj instanceof SLanguageAdapterById) ? myLanguage.equals(((SLanguageAdapterById) obj).myLanguage) : myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ((Language) MPSModuleRepository.getInstance().getModule(ModuleId.regular(myLanguage.getIdValue())));
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.project.dependency.modules.LanguageDependenciesManager;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.StructureAspectDescriptor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public abstract class SLanguageAdapter implements SLanguage {
  protected final String myLanguageFqName;

  protected SLanguageAdapter(@NotNull String language) {
    this.myLanguageFqName = language;
  }

  @Nullable
  public abstract LanguageRuntime getLanguageDescriptor();

  @NotNull
  public abstract SLanguageId getId();

  @Override
  @Nullable
  public abstract Language getSourceModule();

  @Override
  public String getQualifiedName() {
    return myLanguageFqName;
  }

  @Override
  public Iterable<SAbstractConcept> getConcepts() {
    LanguageRuntime runtime = getLanguageDescriptor();
    if (runtime == null) {
      return Collections.emptySet();
    }

    StructureAspectDescriptor struc = getLanguageDescriptor().getAspect(StructureAspectDescriptor.class);
    if (struc == null) {
      return Collections.emptyList();
    }
    ArrayList<SAbstractConcept> result = new ArrayList<SAbstractConcept>();
    for (ConceptDescriptor cd : ((BaseStructureAspectDescriptor) struc).getDescriptors()) {
      if (cd.isInterfaceConcept()) {
        result.add(new SInterfaceConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      } else {
        result.add(new SConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      }
    }
    return result;
  }

  @Override
  public Iterable<SModuleReference> getLanguageRuntimes() {
    Set<SModuleReference> runtimes = new HashSet<SModuleReference>();
    Language sourceModule = getSourceModule();
    if (sourceModule == null) {
      return Collections.emptyList();
    }
    for (Language language : SetSequence.fromSet(LanguageDependenciesManager.getAllExtendedLanguages(sourceModule))) {
      runtimes.addAll(language.getRuntimeModulesReferences());
      
      
      
      
      for (SDependency dep : language.getDeclaredDependencies()) {
        if (dep.getScope() == SDependencyScope.GENERATES_INTO && dep.getTarget() instanceof Language) {
          runtimes.addAll(((Language) dep.getTarget()).getRuntimeModulesReferences());
        }
      }
    }
    return runtimes;
  }

  public int getLanguageVersion() {
    LanguageRuntime languageDescriptor = getLanguageDescriptor();
    if (languageDescriptor == null) {
      return -1;
    }
    return languageDescriptor.getVersion();
  }

  @Override
  public String toString() {
    return myLanguageFqName;
  }

  @Override
  public int hashCode() {
    return 0;
  }
}

<code block>

package jetbrains.mps.extapi.model;

import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.SModelLegacy;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelListener.SModelListenerPriority;
import jetbrains.mps.smodel.event.SModelRenamedEvent;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;


public abstract class SModelDescriptorStub implements SModelInternal, SModel, FastNodeFinder.Factory {

  private static final Logger LOG = LogManager.getLogger(SModelDescriptorStub.class);

  private final List<SModelListener> myModelListeners = new CopyOnWriteArrayList<SModelListener>();

  private ModelLoadingState myModelLoadState = ModelLoadingState.NOT_LOADED;

  
  @Deprecated
  public abstract jetbrains.mps.smodel.SModel getSModelInternal();

  
  public void replace(SModelData modelData) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void addModelListener(@NotNull SModelListener listener) {
    if (listener.getPriority() == SModelListenerPriority.PLATFORM) {
      myModelListeners.add(0, listener);
    } else {
      myModelListeners.add(listener);
    }
  }

  @Override
  public void removeModelListener(@NotNull SModelListener listener) {
    myModelListeners.remove(listener);
  }

  @NotNull
  public List<SModelListener> getModelListeners() {
    return myModelListeners;
  }

  protected void clearListeners() {
    myModelListeners.clear();
  }

  @NotNull
  protected ModelLoadingState getLoadingState() {
    return myModelLoadState;
  }

  protected void notifyModelReplaced(jetbrains.mps.smodel.SModel oldSModel) {
    SModelRepository.getInstance().notifyModelReplaced(this, oldSModel);
  }

  

  protected void fireBeforeModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireBeforeModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelStateChanged(ModelLoadingState newState) {
    myModelLoadState = newState;
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelLoadingStateChanged(this, newState);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireBeforeModelDisposed(SModel model) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelDisposed(model);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelSaved() {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelSaved(this);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  
  public jetbrains.mps.smodel.SModel getSModel() {
    return getSModelInternal();
  }

  
  @Nullable
  protected abstract jetbrains.mps.smodel.SModel getCurrentModelInternal();

  

  @Override
  public final ModelDependenciesManager getModelDepsManager() {
    return getSModelInternal().getModelDepsManager();
  }

  @Override
  @Deprecated
  public final List<SModuleReference> importedLanguages() {
    return new SModelLegacy(getSModelInternal()).importedLanguages();
  }

  @Override
  public final void deleteLanguage(@NotNull SModuleReference ref) {
    getSModelInternal().deleteLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public final void addLanguage(SModuleReference ref) {
    
    
    
    getSModelInternal().addLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public java.util.Collection<SLanguage> importedLanguageIds() {
    return getSModelInternal().usedLanguages();
  }

  @Override
  public void deleteLanguageId(@NotNull SLanguage ref) {
    getSModel().deleteLanguage(ref);
  }

  @Override
  public void addLanguage(Language language) {
    getSModel().addLanguage(MetaAdapterByDeclaration.getLanguage(language));
  }

  @Override
  public void addLanguage(@NotNull SLanguage language) {
    getSModel().addLanguage(language);
  }

  @Override
  public void addLanguage(@NotNull SLanguage language, int version) {
    getSModel().addLanguage(language, version);
  }

  @Override
  public void addLanguageId(SLanguage ref, int version) {
    getSModelInternal().addLanguage(ref, version);
  }

  @Override
  public final List<SModuleReference> importedDevkits() {
    return getSModelInternal().importedDevkits();
  }

  @Override
  public final void addDevKit(SModuleReference ref) {
    getSModelInternal().addDevKit(ref);
  }

  @Override
  public final void deleteDevKit(@NotNull SModuleReference ref) {
    getSModelInternal().deleteDevKit(ref);
  }

  @Override
  public final List<ImportElement> importedModels() {
    return getSModelInternal().importedModels();
  }

  @Override
  public final void addModelImport(SModelReference modelReference, boolean firstVersion) {
    new SModelLegacy(getSModelInternal()).addModelImport(modelReference, firstVersion);
  }

  @Override
  public final void addModelImport(ImportElement importElement) {
    getSModelInternal().addModelImport(importElement);
  }

  @Override
  public final void deleteModelImport(SModelReference modelReference) {
    getSModelInternal().deleteModelImport(modelReference);
  }

  @Override
  public final void calculateImplicitImports() {
    getSModelInternal().getImplicitImportsSupport().calculateImplicitImports();
  }

  @Override
  public final List<SModuleReference> engagedOnGenerationLanguages() {
    return getSModelInternal().engagedOnGenerationLanguages();
  }

  @Override
  public final void addEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().addEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().removeEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final List<ImportElement> getAdditionalModelVersions() {
    return getSModelInternal().getImplicitImportsSupport().getAdditionalModelVersions();
  }

  @Override
  public boolean isDisposed() {
    return getDisposedStacktrace() != null;
  }

  @Override
  public final StackTraceElement[] getDisposedStacktrace() {
    return getSModelInternal().getDisposedStacktrace();
  }

  @Override
  public FastNodeFinder createNodeFinder(SModel model) {
    assert model == this;
    return getSModel().createFastNodeFinder();
  }

  @Override
  public final boolean updateSModelReferences() {
    return getSModelInternal().updateSModelReferences();
  }

  @Override
  public final boolean updateModuleReferences() {
    return getSModelInternal().updateModuleReferences();
  }

  @Override
  public void changeModelReference(SModelReference newModelReference) {
    getSModelInternal().changeModelReference(newModelReference);
  }
}

<code block>
package jetbrains.mps.smodel;



import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.project.DevKit;

@Deprecated
@ToRemove(version = 3.3)
public class BootstrapLanguages {
  public static final String ACTIONS_NAMESPACE = "jetbrains.mps.lang.actions";
  public static final String BEHAVIOR_NAMESPACE = "jetbrains.mps.lang.behavior";
  public static final String CONSTRAINTS_NAMESPACE = "jetbrains.mps.lang.constraints";
  public static final String CORE_NAMESPACE = "jetbrains.mps.lang.core";
  public static final String DATA_FLOW_NAMESPACE = "jetbrains.mps.lang.dataFlow";
  public static final String DESCRIPTOR_NAMESPACE = "jetbrains.mps.lang.descriptor";
  public static final String EDITOR_NAMESPACE = "jetbrains.mps.lang.editor";
  public static final String FIND_USAGES_NAMESPACE = "jetbrains.mps.lang.findUsages";
  public static final String PROJECT_NAMESPACE = "jetbrains.mps.lang.project";
  public static final String GENERATOR_NAMESPACE = "jetbrains.mps.lang.generator";
  public static final String GENERATOR_CONTEXT_NAMESPACE = "jetbrains.mps.lang.generator.generationContext";
  public static final String GENERATOR_PARAMETERS_NAMESPACE = "jetbrains.mps.lang.generator.generationParameters";
  public static final String INTENTIONS_NAMESPACE = "jetbrains.mps.lang.intentions";
  public static final String PLUGIN_NAMESPACE = "jetbrains.mps.lang.plugin";
  public static final String MAKE_FACET_NAMESPACE = "jetbrains.mps.make.facet";
  public static final String REFACTORING_NAMESPACE = "jetbrains.mps.lang.refactoring";
  public static final String SCRIPT_NAMESPACE = "jetbrains.mps.lang.script";
  public static final String SHARED_CONCEPTS_NAMESPACE = "jetbrains.mps.lang.sharedConcepts";
  public static final String SMODEL_NAMESPACE = "jetbrains.mps.lang.smodel";
  public static final String STRUCTURE_NAMESPACE = "jetbrains.mps.lang.structure";
  public static final String MIGRATION_NAMESPACE = "jetbrains.mps.lang.migration";
  public static final String TEST_NAMESPACE = "jetbrains.mps.lang.test";
  public static final String TEXT_GEN_NAMESPACE = "jetbrains.mps.lang.textGen";
  public static final String TYPESYSTEM_NAMESPACE = "jetbrains.mps.lang.typesystem";
  public static final String BASE_LANGUAGE_NAMESPACE = "jetbrains.mps.baseLanguage";
  public static final String COLLECTIONS_NAMESPACE = "jetbrains.mps.baseLanguage.collections";
  public static final String CLOSURES_NAMESPACE = "jetbrains.mps.baseLanguage.closures";
  public static final String TUPLES_NAMESPACE = "jetbrains.mps.baseLanguage.tuples";
  public static final String UNITTEST_NAMESPACE = "jetbrains.mps.baseLanguage.unitTest";
  public static final String DEVKIT_GENERAL_NAMESPACE = "jetbrains.mps.devkit.general-purpose";
  public static final String DEVKIT_BOOTSTRAP_NAMESPACE = "jetbrains.mps.devkit.bootstrap-languages";
  public static final String DEVKIT_LANGUAGE_DESIGN_NAMESPACE = "jetbrains.mps.devkit.language-design";
  public static final String JDK_NAMESPACE = "JDK";
  public static final String concept_baseLanguage_Annotation = "jetbrains.mps.baseLanguage.structure.Annotation";
  public static final String concept_baseLanguage_ClassConcept = "jetbrains.mps.baseLanguage.structure.ClassConcept";
  public static final String concept_baseLanguage_EnumClass = "jetbrains.mps.baseLanguage.structure.EnumClass";
  public static final String concept_baseLanguage_Interface = "jetbrains.mps.baseLanguage.structure.Interface";
  public static final String concept_generator_MappingConfiguration = "jetbrains.mps.lang.generator.structure.MappingConfiguration";

  private static final SModuleReference descriptorLanguage = PersistenceFacade.getInstance().createModuleReference("f4ad079d-bc71-4ffb-9600-9328705cf998(jetbrains.mps.lang.descriptor)");
  private static final SModuleReference projectLanguage = PersistenceFacade.getInstance().createModuleReference("86ef8290-12bb-4ca7-947f-093788f263a9(jetbrains.mps.lang.project)");
  private static final SModuleReference coreLanguage = PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)");
  private static final SModuleReference structureLanguage = PersistenceFacade.getInstance().createModuleReference("c72da2b9-7cce-4447-8389-f407dc1158b7(jetbrains.mps.lang.structure)");
  private static final SModuleReference editorLanguage = PersistenceFacade.getInstance().createModuleReference("18bc6592-03a6-4e29-a83a-7ff23bde13ba(jetbrains.mps.lang.editor)");
  private static final SModuleReference actionsLanguage = PersistenceFacade.getInstance().createModuleReference("aee9cad2-acd4-4608-aef2-0004f6a1cdbd(jetbrains.mps.lang.actions)");
  private static final SModuleReference constraintsLanguage = PersistenceFacade.getInstance().createModuleReference("3f4bc5f5-c6c1-4a28-8b10-c83066ffa4a1(jetbrains.mps.lang.constraints)");
  private static final SModuleReference behaviorLanguage = PersistenceFacade.getInstance().createModuleReference("af65afd8-f0dd-4942-87d9-63a55f2a9db1(jetbrains.mps.lang.behavior)");
  private static final SModuleReference typesystemLanguage = PersistenceFacade.getInstance().createModuleReference("7a5dda62-9140-4668-ab76-d5ed1746f2b2(jetbrains.mps.lang.typesystem)");
  private static final SModuleReference baseLanguage = PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)");
  private static final SModuleReference jdkModule = PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)");

  @Deprecated
  private BootstrapLanguages() {
  }
  public static SLanguage getLangCore() {
    return MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL), "jetbrains.mps.lang.core");
  }
  public static Language baseLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"), Language.class);
  }
  public static Language smodelLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("7866978e-a0f0-4cc7-81bc-4d213d9375e1(jetbrains.mps.lang.smodel)"), Language.class);
  }
  public static Language collectionsLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("83888646-71ce-4f1c-9c53-c54016f6ad4f(jetbrains.mps.baseLanguage.collections)"), Language.class);
  }
  public static Language generatorLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("b401a680-8325-4110-8fd3-84331ff25bef(jetbrains.mps.lang.generator)"), Language.class);
  }
  public static Language generatorContextLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("d7706f63-9be2-479c-a3da-ae92af1e64d5(jetbrains.mps.lang.generator.generationContext)"), Language.class);
  }
  public static Language generatorParametersLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("289fcc83-6543-41e8-a5ca-768235715ce4(jetbrains.mps.lang.generator.generationParameters)"), Language.class);
  }
  public static Language coreLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)"), Language.class);
  }
  public static DevKit generalDevKit() {
    return (DevKit) ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }
  public static SModuleReference descriptorLanguageRef() {
    return descriptorLanguage;
  }
  public static SModuleReference projectLanguageRef() {
    return projectLanguage;
  }
  public static SModuleReference coreLanguageRef() {
    return coreLanguage;
  }
  public static SModuleReference structureLanguageRef() {
    return structureLanguage;
  }
  public static SModuleReference editorLanguageRef() {
    return editorLanguage;
  }
  public static SModuleReference actionsLanguageRef() {
    return actionsLanguage;
  }
  public static SModuleReference constraintsLanguageRef() {
    return constraintsLanguage;
  }
  public static SModuleReference behaviorLanguageRef() {
    return behaviorLanguage;
  }
  public static SModuleReference typesystemLanguageRef() {
    return typesystemLanguage;
  }
  public static SModuleReference baseLanguageRef() {
    return baseLanguage;
  }
  public static SModuleReference refactoringLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("3ecd7c84-cde3-45de-886c-135ecc69b742(jetbrains.mps.lang.refactoring)");
  }
  public static SModuleReference scriptLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("0eddeefa-c2d6-4437-bc2c-de50fd4ce470(jetbrains.mps.lang.script)");
  }
  public static SModuleReference intentionsLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("d7a92d38-f7db-40d0-8431-763b0c3c9f20(jetbrains.mps.lang.intentions)");
  }
  public static SModuleReference findUsagesLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("64d34fcd-ad02-4e73-aff8-a581124c2e30(jetbrains.mps.lang.findUsages)");
  }
  public static SModuleReference pluginLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("28f9e497-3b42-4291-aeba-0a1039153ab1(jetbrains.mps.lang.plugin)");
  }
  public static SModuleReference dataFlowLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("7fa12e9c-b949-4976-b4fa-19accbc320b4(jetbrains.mps.lang.dataFlow)");
  }
  public static SModuleReference testLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("8585453e-6bfb-4d80-98de-b16074f1d86c(jetbrains.mps.lang.test)");
  }
  public static SModuleReference textGenLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("b83431fe-5c8f-40bc-8a36-65e25f4dd253(jetbrains.mps.lang.textGen)");
  }
  public static SModuleReference migrationLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("90746344-04fd-4286-97d5-b46ae6a81709(jetbrains.mps.lang.migration)");
  }
  public static SModuleReference unitTestLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("f61473f9-130f-42f6-b98d-6c438812c2f6(jetbrains.mps.baseLanguage.unitTest)");
  }
  public static SModuleReference jdkRef() {
    return jdkModule;
  }

}

<code block>
package jetbrains.mps.project.structure;



import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.components.CoreComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelId;
import java.util.concurrent.ConcurrentHashMap;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SModuleAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.DevKit;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.module.SModuleId;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.project.structure.stub.ProjectStructureBuilder;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.BaseFastNodeFinder;

public class ProjectStructureModule extends AbstractModule implements CoreComponent {
  private static final String MODULE_REF = "642f71f8-327a-425b-84f9-44ad58786d27(jetbrains.mps.lang.project.modules)";
  private Map<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor> myModels = new ConcurrentHashMap<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor>();
  private static ProjectStructureModule INSTANCE;
  private final MPSModuleOwner myOwner = new BaseMPSModuleOwner() {};
  private final SModuleListener myModuleListener = new SModuleAdapter() {
    @Override
    public void moduleChanged(SModule module) {
      refreshModule(module, false);
    }
  };
  private final SRepositoryListener myListener = new SRepositoryListenerBase() {
    @Override
    public void moduleAdded(@NotNull SModule module) {
      refreshModule(module, false);
      module.addModuleListener(myModuleListener);
    }
    @Override
    public void beforeModuleRemoved(@NotNull SModule module) {
      module.removeModuleListener(myModuleListener);
      refreshModule(module, true);
    }
  };
  private final MPSModuleRepository myRepository;
  public static ProjectStructureModule getInstance() {
    return INSTANCE;
  }
  public ProjectStructureModule(MPSModuleRepository repository) {
    myRepository = repository;
    setModuleReference(PersistenceFacade.getInstance().createModuleReference(MODULE_REF));
  }
  private void refreshModule(SModule module, boolean isDeleted) {
    assertCanChange();
    if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {
      return;
    }
    SModelReference ref = getSModelReference(module);
    if (isDeleted) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      if (descriptor != null) {
        removeModel(descriptor);
      }
    } else
    if (myModels.containsKey(ref.getModelId())) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      descriptor.dropModel();
    } else {
      createModel(module);
    }
  }
  public SModel getModelByModule(SModule module) {
    myRepository.getModelAccess().checkReadAccess();
    if (module == null) {
      return null;
    }
    SModelReference ref = getSModelReference(module);
    ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
    return (descriptor == null ? null : descriptor);
  }
  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myRepository.addRepositoryListener(myListener);
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.registerModule(ProjectStructureModule.this, myOwner);
      }
    });
  }
  @Override
  public void dispose() {
    
    if (INSTANCE == null) {
      return;
    }
    INSTANCE = null;
    clearAll();
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.unregisterModule(ProjectStructureModule.this, myOwner);
      }
    });
    myRepository.removeRepositoryListener(myListener);
  }
  public void clearAll() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        removeAll();
        dependenciesChanged();
        myModels.clear();
      }
    });
  }
  private void removeAll() {
    List<SModel> models = this.getProjectStructureModels();
    for (SModel model : models) {
      removeModel(model);
    }
  }
  @Override
  public Set<SLanguage> getUsedLanguages() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x86ef829012bb4ca7L, 0x947f093788f263a9L), "jetbrains.mps.lang.project"));
  }
  private void removeModel(SModel md) {
    if (myModels.remove(md.getReference().getModelId()) != null) {
      unregisterModel((SModelBase) md);
      if (md instanceof ProjectStructureModule.ProjectStructureSModelDescriptor) {
        ((ProjectStructureModule.ProjectStructureSModelDescriptor) md).dropModel();
      }
    }
  }
  public ProjectStructureModule.ProjectStructureSModelDescriptor createModel(SModule module) {
    ProjectStructureModule.ProjectStructureSModelDescriptor result = new ProjectStructureModule.ProjectStructureSModelDescriptor(getSModelReference(module), module);
    myModels.put(getSModelReference(module).getModelId(), result);
    registerModel(result);
    return result;
  }
  private SModelReference getSModelReference(SModule module) {
    SModuleId moduleId = module.getModuleReference().getModuleId();
    SModelId id = (moduleId != null ? jetbrains.mps.smodel.SModelId.foreign("project", moduleId.toString()) : null);
    return new jetbrains.mps.smodel.SModelReference(this.getModuleReference(), id, "module." + module.getModuleName() + "@" + SModelStereotype.getStubStereotypeForId("project"));
  }
  public String toString() {
    return getModuleName();
  }
  public List<SModel> getProjectStructureModels() {
    return new ArrayList<SModel>(myModels.values());
  }
  @Override
  protected void collectFacetTypes(Set<String> types) {
    
  }
  @Override
  public SModel resolveInDependencies(SModelId ref) {
    return myModels.get(ref);
  }
  public class ProjectStructureSModelDescriptor extends BaseSpecialModelDescriptor {
    private final SModule myModule;
    private ProjectStructureSModelDescriptor(SModelReference ref, SModule module) {
      super(ref);
      myModule = module;
    }
    @Override
    protected ProjectStructureModule.ProjectStructureSModel createModel() {
      final ProjectStructureModule.ProjectStructureSModel model = new ProjectStructureModule.ProjectStructureSModel(getReference());
      final ModuleDescriptor moduleDescriptor = ((AbstractModule) myModule).getModuleDescriptor();
      final IFile file = ((AbstractModule) myModule).getDescriptorFile();
      if (file != null && moduleDescriptor != null) {
        NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable() {
          @Override
          public void run() {
            new ProjectStructureBuilder(moduleDescriptor, file, model) {
              @Override
              public Iterable<SModelReference> loadReferences(SNode m, ModuleDescriptor descriptor) {
                SModule module = (moduleDescriptor == descriptor ? myModule : ModuleRepositoryFacade.getInstance().getModule(descriptor.getModuleReference()));
                if (module == null) {
                  return Collections.emptyList();
                }
                return Sequence.<SModel>fromIterable(module.getModels()).where(new IWhereFilter<SModel>() {
                  @Override
                  public boolean accept(SModel o) {
                    return SModelStereotype.isUserModel(o);
                  }
                }).select(new ISelector<SModel, SModelReference>() {
                  @Override
                  public SModelReference select(SModel o) {
                    return o.getReference();
                  }
                });
              }
            }.convert();
          }
        });
      }
      return model;
    }
    private void dropModel() {
      if (mySModel == null) {
        return;
      }
      final jetbrains.mps.smodel.SModel oldModel = mySModel;
      mySModel = null;
      replaceModelAndFireEvent(oldModel, null);
    }
  }
  public static class ProjectStructureSModel extends jetbrains.mps.smodel.SModel {
    public ProjectStructureSModel(@NotNull SModelReference modelReference) {
      super(modelReference, new ForeignNodeIdMap());
    }
    @Override
    public boolean canFireEvent() {
      return false;
    }
    @Override
    public FastNodeFinder createFastNodeFinder() {
      return new BaseFastNodeFinder(getModelDescriptor());
    }
  }
}

<code block>
package jetbrains.mps.lang.migration.runtime.base;



import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;

public class MigrationScriptReference {
  private final SLanguage language;
  private final int fromVersion;
  public MigrationScriptReference(SLanguage language, int fromVersion) {
    this.language = language;
    this.fromVersion = fromVersion;
  }
  public SLanguage getLanguage() {
    return language;
  }
  public int getFromVersion() {
    return fromVersion;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    MigrationScriptReference that = (MigrationScriptReference) o;
    if (!(language.equals(that.language))) {
      return false;
    }
    if (fromVersion != that.fromVersion) {
      return false;
    }
    return true;
  }
  @Override
  public int hashCode() {
    return language.hashCode() + 31 * fromVersion;
  }
  public String serialize() {
    return IdHelper.getLanguageId(language).serialize() + "(" + language.getQualifiedName() + ")" + "/" + fromVersion;
  }
  public static MigrationScriptReference deserialize(String s) {
    int version = Integer.parseInt(s.substring(s.indexOf('/') + 1));
    int ix = s.indexOf('(');
    SLanguage language = MetaAdapterFactory.getLanguage(SLanguageId.deserialize(s.substring(0, ix)), s.substring(ix + 1, s.indexOf(')', ix)));
    return new MigrationScriptReference(language, version);
  }
}

<code block>
package jetbrains.mps.persistence.java.library;



import jetbrains.mps.extapi.model.ReloadableSModelBase;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.extapi.persistence.FolderSetDataSource;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.baseLanguage.javastub.ASMModelLoader;
import java.util.Set;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SModelRepository;

public class JavaClassStubModelDescriptor extends ReloadableSModelBase {
  private SModel myModel;
  private boolean mySkipPrivate;
  public JavaClassStubModelDescriptor(SModelReference modelReference, FolderSetDataSource source) {
    super(modelReference, source);
  }
   void setSkipPrivate(boolean skipPrivateMembers) {
    mySkipPrivate = skipPrivateMembers;
  }
  @Override
  protected SModel getCurrentModelInternal() {
    return myModel;
  }
  @NotNull
  @Override
  public FolderSetDataSource getSource() {
    return (FolderSetDataSource) super.getSource();
  }
  @Override
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
      fireModelStateChanged(ModelLoadingState.FULLY_LOADED);
    }
    return myModel;
  }
  @Override
  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }
  private SModel createModel() {
    SModel model = new SModel(getReference(), new ForeignNodeIdMap());
    for (SLanguage l : getLanguagesToImport()) {
      model.addLanguage(l);
    }
    ASMModelLoader loader = new ASMModelLoader(getModelRoot().getModule(), getSource().getPaths());
    loader.skipPrivateMembers(mySkipPrivate);
    loader.update(model);
    return model;
  }
  private Set<SLanguage> getLanguagesToImport() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage"));
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return getLanguagesToImport();
  }
  @Override
  public void reloadFromDiskSafe() {
    assertCanChange();
    if (getSource().getPaths().isEmpty()) {
      SModelRepository.getInstance().deleteModel(this);
      return;
    }
    reload();
    updateTimestamp();
  }
  private void reload() {
    if (myModel == null) {
      return;
    }
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }
}

<code block>

package org.jetbrains.mps.openapi.language;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;


public interface SLanguage {

  
  @NotNull
  String getQualifiedName();

  
  Iterable<SAbstractConcept> getConcepts();

  
  Iterable<SModuleReference> getLanguageRuntimes();

  
  @Nullable
  SModule getSourceModule();

  
  @Deprecated 
  int getLanguageVersion();
}

<code block>
package jetbrains.mps.console.tool;



import javax.swing.JPanel;
import com.intellij.openapi.Disposable;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.fileEditor.FileEditor;
import jetbrains.mps.nodeEditor.UIEditorComponent;
import jetbrains.mps.nodeEditor.Highlighter;
import jetbrains.mps.nodeEditor.EditorComponent;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SLanguageHierarchy;
import java.util.Collections;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.CustomShortcutSet;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import com.intellij.openapi.actionSystem.ShortcutSet;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.ide.PasteProvider;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.apache.log4j.Level;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.DataContext;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.datatransfer.NodePaster;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.util.Base64Converter;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.ide.findusages.model.scopes.ProjectScope;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Scanner;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.MouseShortcut;
import java.awt.event.MouseEvent;
import java.awt.BorderLayout;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import com.intellij.openapi.wm.IdeFocusManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelUtil_new;

public abstract class BaseConsoleTab extends JPanel implements Disposable {
  protected ConsoleTool myTool;
  protected SModel myModel;
  protected SNode myRoot;
  protected FileEditor myFileEditor;
  protected UIEditorComponent myEditor;
  protected Highlighter myHighlighter;
  protected String myTabTitle;

  public String getTitle() {
    return myTabTitle;
  }

  public SModel getConsoleModel() {
    return myModel;
  }

  public EditorComponent getEditorComponent() {
    return myEditor;
  }

  public SNode getRoot() {
    return myRoot;
  }

  public ConsoleTool getConsoleTool() {
    return myTool;
  }

  protected void addBuiltInImports() {
    SLanguage base = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L), "jetbrains.mps.console.base");
    Collection<SLanguage> baseAndExtensions = new SLanguageHierarchy(Collections.singleton(base)).getExtending();
    SModelInternal modelInternal = ((SModelInternal) myModel);
    for (SLanguage l : CollectionSequence.fromCollection(baseAndExtensions)) {
      modelInternal.addLanguage(l);
      Language sourceLangModule = (Language) l.getSourceModule();
      if (sourceLangModule == null) {
        continue;
      }
      modelInternal.addModelImport(sourceLangModule.getStructureModelDescriptor().getReference(), false);
      ((AbstractModule) myModel.getModule()).addDependency(sourceLangModule.getModuleReference(), false);
    }
    modelInternal.addDevKit(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }

  protected void validateImports() {
    SModelInternal modelInternal = (SModelInternal) myModel;
    for (SModuleReference devKit : ListSequence.fromListWithValues(new ArrayList<SModuleReference>(), modelInternal.importedDevkits())) {
      modelInternal.deleteDevKit(devKit);
    }
    for (SLanguage language : ListSequence.fromListWithValues(new ArrayList<SLanguage>(), modelInternal.importedLanguageIds())) {
      modelInternal.deleteLanguageId(language);
    }
    for (jetbrains.mps.smodel.SModel.ImportElement model : ListSequence.fromListWithValues(new ArrayList<jetbrains.mps.smodel.SModel.ImportElement>(), modelInternal.importedModels())) {
      modelInternal.deleteModelImport(model.getModelReference());
    }
    addBuiltInImports();
    TemporaryModels.getInstance().addMissingImports(myModel);
  }

  protected BaseAction registerKeyShortcut(BaseAction a, int key) {
    return registerShortcutSet(a, new CustomShortcutSet(KeyStroke.getKeyStroke(key, KeyEvent.CTRL_MASK)));
  }

  protected BaseAction registerShortcutSet(BaseAction a, ShortcutSet shortcutSet) {
    a.registerCustomShortcutSet(shortcutSet, myEditor);
    return a;
  }

  protected void createEditor() {
    this.myEditor = new UIEditorComponent(check_6q36mf_a0a0a0a62(ProjectHelper.toMPSProject(myTool.getProject())), null) {
      @Nullable
      @Override
      public Object getData(@NonNls String key) {
        if (PlatformDataKeys.FILE_EDITOR.is(key)) {
          return myFileEditor;
        }
        if (PlatformDataKeys.PASTE_PROVIDER.is(key)) {
          PasteProvider parentPasteProvider = as_6q36mf_a0a0a1a0a0a0a0ab(super.getData(key), PasteProvider.class);
          return (myTool.getPasteAsRef() ? new BaseConsoleTab.MyPasteProvider(parentPasteProvider) : parentPasteProvider);
        }
        return super.getData(key);
      }
    };
    myEditor.editNode(myRoot);
  }


  protected void createConsoleModel() {
    this.myModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModuleWithSourceAndClassesGen());
    if (myModel == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error: could not create console model");
      }
      return;
    }
  }

  public void dispose() {
    disposeConsoleTab();
  }

  public void disposeConsoleTab() {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        if (myEditor != null) {
          myEditor.dispose();
        }
        TemporaryModels.getInstance().dispose(myModel);
      }
    });
    myHighlighter.removeAdditionalEditorComponent(myEditor);
  }

  protected class ExecuteClosureAction extends BaseAction {
    public ExecuteClosureAction() {
      super("Execute Closure");
    }
    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      ActionUtils.updateAndPerformAction(((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.console.actions.ExecuteActionAttachedToCurrentNode_Action")), event);
    }
  }

  public class MyPasteProvider implements PasteProvider {

    private PasteProvider myDefaultPasteProvider;

    public MyPasteProvider(PasteProvider defaultPasteProvider) {
      myDefaultPasteProvider = defaultPasteProvider;
    }

    public void performPaste(@NotNull final DataContext context) {
      getProject().getModelAccess().executeCommand(new Runnable() {
        public void run() {
          SNodeReference pastingNodeReference = null;
          try {
            for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
              if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNodeReference)) {
                pastingNodeReference = (SNodeReference) trf.getTransferData(SModelDataFlavor.sNodeReference);
              }
              break;
            }
          } catch (UnsupportedFlavorException ignored) {
          } catch (IOException ignored) {
          }
          EditorCell currentCell = myEditor.getSelectedCell();
          SRepository repository = getProject().getRepository();
          SNode referenceTarget = check_6q36mf_a0e0a0a0a5lb(pastingNodeReference, repository);
          if (referenceTarget != null && currentCell != null && !(check_6q36mf_a0a5a0a0a0f73(check_6q36mf_a0a0f0a0a0a5lb(pastingNodeReference), myModel))) {
            SNode refContainer = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x51132a123c89fa7eL, "jetbrains.mps.console.base.structure.PastedNodeReference")));
            SLinkOperations.setTarget(refContainer, MetaAdapterFactory.getReferenceLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x36ac6f29ae8c1fb5L, 0x4904fd89e74fc6fL, "target"), referenceTarget);
            NodePaster paster = new NodePaster(ListSequence.fromListAndArray(new ArrayList<SNode>(), refContainer));
            if (paster.canPaste(currentCell)) {
              paster.paste(currentCell);
            } else if (paster.canPasteWithRemove(myEditor.getSelectedNodes())) {
              paster.pasteWithRemove(myEditor.getSelectedNodes());
            }
            TemporaryModels.getInstance().addMissingImports(myModel);
          } else {
            check_6q36mf_a0a0f0a0a0a5lb_0(myDefaultPasteProvider, context);
          }
        }
      });
    }
    public boolean isPastePossible(@NotNull DataContext context) {
      return true;
    }
    public boolean isPasteEnabled(@NotNull DataContext context) {
      return true;
    }
  }

  protected abstract void loadHistory(String state);

  @Nullable
  public String saveHistory() {
    final Wrappers._T<String> result = new Wrappers._T<String>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          result.value = (myModel == null ? null : Base64Converter.encode(PersistenceUtil.saveBinaryModel(myModel)));
        } catch (Exception e) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Error on console model saving", e);
          }
        }
      }
    });
    return result.value;
  }

  protected ConsoleContext getConsoleContext() {
    return new ConsoleContext() {
      public Project getProject() {
        return ProjectHelper.toMPSProject(myTool.getProject());
      }
      public SearchScope getDefaultSearchscope() {
        return new ProjectScope(getProject());
      }
      public BaseConsoleTab getConsoleTab() {
        return BaseConsoleTab.this;
      }
    };
  }

  protected SNode getLastReponse() {
    SNode last = SNodeOperations.as(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).last(), MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response"));
    if (last != null) {
      return last;
    }
    return SLinkOperations.addNewChild(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response")));
  }

  protected void addNodeImports(SNode node) {
    final SModelInternal modelInternal = (SModelInternal) myModel;
    final AbstractModule module = ((AbstractModule) myModel.getModule());
    final Collection<SLanguage> importedLanguages = modelInternal.importedLanguageIds();
    for (SNode subNode : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, true, new SAbstractConcept[]{}))) {
      SLanguage usedLanguage = subNode.getConcept().getLanguage();
      if (!(importedLanguages.contains(usedLanguage))) {
        modelInternal.addLanguage(usedLanguage);
      }
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(subNode))) {
        SModel usedModel = SNodeOperations.getModel(SLinkOperations.getTargetNode(ref));
        if (usedModel != null && !(modelInternal.importedModels().contains(usedModel))) {
          modelInternal.addModelImport(usedModel.getReference(), false);
          module.addDependency(SNodeOperations.getModel(SLinkOperations.getTargetNode(ref)).getModule().getModuleReference(), false);
        }
      }
    }
  }

  public ConsoleStream getConsoleStream() {
    return new ConsoleStream() {
      public void addText(String text) {
        Scanner scanner = new Scanner(text);
        while (scanner.hasNextLine()) {
          String line = scanner.nextLine();
          if ((line != null && line.length() > 0)) {
            ListSequence.fromList(SLinkOperations.getChildren(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"))).addElement(createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(line));
          }
          if (scanner.hasNextLine() || text.charAt(text.length() - 1) == '\n') {
            SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35d30L, "jetbrains.mps.console.base.structure.NewLineResponseItem")));
          }
        }
      }
      public void addNode(SNode node) {
        addNodeImports(node);
        SLinkOperations.setTarget(SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, "jetbrains.mps.console.base.structure.NodeResponseItem"))), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, 0x4e3b035171b35c15L, "node"), node);
      }
    };
  }


  public BaseConsoleTab(ConsoleTool tool, String title, @Nullable String history) {
    myTool = tool;
    myTabTitle = title;
    initConsoleTab(history);
  }

  protected void registerActions(DefaultActionGroup group) {
    registerShortcutSet(new BaseConsoleTab.ExecuteClosureAction(), new CustomShortcutSet(new MouseShortcut(MouseEvent.BUTTON1, 0, 1)));
  }

  @NotNull
  private Project getProject() {
    Project mpsProject = ProjectHelper.toMPSProject(this.getConsoleTool().getProject());
    if (mpsProject == null) {
      throw new IllegalStateException("Cannot convert idea project to the mps project");
    }
    return mpsProject;
  }

  protected void initConsoleTab(@Nullable final String history) {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        createConsoleModel();
        addBuiltInImports();
        loadHistory(history);
        createEditor();
        myFileEditor = new ConsoleFileEditor(myEditor);
      }
    });

    this.setLayout(new BorderLayout());


    DefaultActionGroup group = new DefaultActionGroup();
    registerActions(group);
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, false);
    JPanel toolbarComponent = new JPanel(new BorderLayout());
    toolbarComponent.add(toolbar.getComponent(), BorderLayout.CENTER);

    this.add(toolbarComponent, BorderLayout.WEST);
    this.add(myEditor.getExternalComponent(), BorderLayout.CENTER);

    myHighlighter = check_6q36mf_a0o0gc(myTool.getProject());
    myHighlighter.addAdditionalEditorComponent(myEditor);
  }

  public void execute(@Nullable final SNode command, @Nullable final Runnable executeBefore, @Nullable final Runnable executeAfter) {
    myTool.selectTab(this);
    final SNode[] typedCommand = new SNode[1];
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        typedCommand[0] = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, "jetbrains.mps.console.base.structure.CommandHolder")));
        if (command != null) {
          addNodeImports(command);
          SLinkOperations.setTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"))));
          SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(command));
        }
      }
    });
    BehaviorReflection.invokeVirtual(Void.class, SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")), "virtual_execute_6854397602732226506", new Object[]{getConsoleContext(), getConsoleStream(), new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder"))));
            SNodeOperations.deleteNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a2a0a0a0a0a2a0d0ic(executeBefore);
          }
        });
      }
    }, new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SLinkOperations.getTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a1a0a0a0a0a3a0d0ic(executeAfter);
          }
        });
      }
    }});
  }

  public void selectNode(final SNode nodeToSelect) {
    myTool.getToolWindow().activate(new Runnable() {
      public void run() {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myEditor.selectNode(nodeToSelect);
            getEditorComponent().ensureSelectionVisible();
            IdeFocusManager.getInstance(myTool.getProject()).requestFocus(myEditor, false);
          }
        });
      }
    });
    myTool.selectTab(this);
  }

  protected SModel loadHistoryModel(String state) {
    if (state != null) {
      try {
        final Wrappers._T<SModel> loadedModel = new Wrappers._T<SModel>(PersistenceUtil.loadBinaryModel(Base64Converter.decode(state.getBytes())));
        ListSequence.fromList(SModelOperations.nodes(loadedModel.value, null)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(it.getConcept().isValid());
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            if ((SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false) != null)) {
              SNodeOperations.deleteNode(SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false));
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: removing enclosing history item");
              }
            } else {
              loadedModel.value = null;
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: not loading history");
              }
            }
          }
        });
        return loadedModel.value;
      } catch (RuntimeException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Console history was not loaded. Maybe you are opening project from previous MPS versions?");
        }
      } catch (Throwable e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error on loading console history.", e);
        }
      }
    }
    return null;
  }

  protected static Logger LOG = LogManager.getLogger(BaseConsoleTab.class);
  private static SRepository check_6q36mf_a0a0a0a62(Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRepository();
    }
    return null;
  }
  private static SNode check_6q36mf_a0e0a0a0a5lb(SNodeReference checkedDotOperand, SRepository repository) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.resolve(repository);
    }
    return null;
  }
  private static boolean check_6q36mf_a0a5a0a0a0f73(SModelReference checkedDotOperand, SModel myModel) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.equals(myModel.getReference());
    }
    return false;
  }
  private static SModelReference check_6q36mf_a0a0f0a0a0a5lb(SNodeReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelReference();
    }
    return null;
  }
  private static void check_6q36mf_a0a0f0a0a0a5lb_0(PasteProvider checkedDotOperand, DataContext context) {
    if (null != checkedDotOperand) {
      checkedDotOperand.performPaste(context);
    }

  }
  private static SNode createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(Object p0) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, "jetbrains.mps.console.base.structure.TextResponseItem"), null, null, false);
    n1.setProperty(MetaAdapterFactory.getProperty(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, 0x4e3b035171b35d11L, "text"), String.valueOf(p0));
    return n1;
  }
  private static Highlighter check_6q36mf_a0o0gc(com.intellij.openapi.project.Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getComponent(Highlighter.class);
    }
    return null;
  }
  private static void check_6q36mf_a2a0a0a0a0a2a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static void check_6q36mf_a1a0a0a0a0a3a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static <T> T as_6q36mf_a0a0a1a0a0a0a0ab(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

<code block>
package jetbrains.mps.ide.java.sourceStubs;



import jetbrains.mps.extapi.model.ReloadableSModelBase;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSourceListener;
import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSource;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.io.InputStream;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.io.IOException;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import java.util.List;
import java.util.LinkedList;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;

public class JavaSourceStubModelDescriptor extends ReloadableSModelBase implements MultiStreamDataSourceListener {

  private static Logger LOG = Logger.wrap(LogManager.getLogger(JavaSourceStubModelDescriptor.class));

  private SModelReference myModelRef;
  private SModel myModel;
  private Map<String, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());


  public JavaSourceStubModelDescriptor(SModelReference modelRef, MultiStreamDataSource dataSource) {
    super(modelRef, dataSource);
    myModelRef = modelRef;
  }

  private SModel createModel() {
    SModel model = new SModel(myModelRef);
    processStreams(getSource().getAvailableStreams(), model);
    for (SLanguage l : CollectionSequence.fromCollection(importedLanguageIds())) {
      model.addLanguage(l);
    }
    return model;
  }

  @Override
  public void attach(SRepository repository) {
    getSource().addListener(this);
    super.attach(repository);
  }

  @Override
  public void detach() {
    super.detach();
    getSource().removeListener(this);
  }

  @Override
  @NotNull
  public MultiStreamDataSource getSource() {
    return (MultiStreamDataSource) super.getSource();
  }

  @Override
  public void changed(DataSource source, Iterable<String> changedItems) {
    

    assertCanChange();

    
    if (myModel == null) {
      return;
    }
    MapSequence.fromMap(myRootsPerFile).clear();
    MapSequence.fromMap(myRootsById).clear();
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }

  @Override
  public boolean needsReloading() {
    return false;
  }

  @Override
  public void changed(DataSource source) {
    
  }

  public void processStreams(Iterable<String> names, SModelData into) {
    JavaParser parser = new JavaParser();

    for (String fileName : names) {
      try {
        Set<SNode> oldNodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), MapSequence.fromMap(myRootsPerFile).get(fileName));

        InputStream is = getSource().openInputStream(fileName);
        
        if (is == null) {
          SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });
          MapSequence.fromMap(myRootsPerFile).removeKey(fileName);
          continue;
        }
        String code = readInputStream(is);
        try {
          is.close();
        } catch (IOException e) {
          LOG.warning("failed to close file " + fileName, e);
        }

        JavaParser.JavaParseResult parseResult = parser.parse(code, FeatureKind.CLASS_STUB, null, true);
        if (ListSequence.fromList(parseResult.getNodes()).isNotEmpty()) {
          for (SNode newNode : ListSequence.fromList(parseResult.getNodes())) {
            final SNodeId newNodeId = newNode.getNodeId();
            
            SNode oldNode = SetSequence.fromSet(oldNodes).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return it.getNodeId().equals(newNodeId);
              }
            }).first();
            if (oldNode == null) {
              into.addRootNode(newNode);
              SetSequence.fromSet(oldNodes).removeElement(oldNode);
            } else {
              SNodeOperations.replaceWithAnother(oldNode, newNode);
            }
            MapSequence.fromMap(myRootsById).put(newNode.getNodeId(), newNode);
          }
        }

        SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SNodeOperations.deleteNode(it);
          }
        });
        MapSequence.fromMap(myRootsPerFile).put(fileName, SetSequence.fromSetWithValues(new HashSet<SNode>(), parseResult.getNodes()));

      } catch (IOException e) {
        LOG.error("Failed to read java file. " + e.getMessage(), e);
      } catch (JavaParseException e) {
        LOG.error("Failed to parse java file. " + e.getMessage());
      }
    }
  }

  private static final int BUFSIZE = 65536;
  private String readInputStream(InputStream is) throws IOException {

    List<byte[]> blocks = ListSequence.fromList(new LinkedList<byte[]>());

    byte[] buffer = new byte[BUFSIZE];
    int lastRead = -1;
    int read = is.read(buffer);

    while (read > 0) {
      lastRead = read;
      ListSequence.fromList(blocks).addElement(buffer);

      buffer = new byte[BUFSIZE];
      read = is.read(buffer);
    }

    if (lastRead > 0) {
      int blks = ListSequence.fromList(blocks).count();
      byte[] wholeBuffer;

      if (blks == 1) {
        wholeBuffer = ListSequence.fromList(blocks).getElement(0);
      } else {
        int size = (blks - 1) * BUFSIZE + lastRead;
        wholeBuffer = new byte[size];
        int c = 0;
        int p = 0;
        for (byte[] buf : blocks) {
          int n = (c == blks - 1 ? lastRead : BUFSIZE);
          System.arraycopy(buf, 0, wholeBuffer, p, n);
          p = p + BUFSIZE;
          c++;
        }
      }

      
      return new String(wholeBuffer);

    } else {
      return "";
    }
  }

  protected SModel getCurrentModelInternal() {
    return myModel;
  }

  @Deprecated
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
    }
    return myModel;
  }

  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage"));
  }

  public void reloadFromDiskSafe() {
    changed(getSource(), getSource().getAvailableStreams());
  }
}

<code block>
package jetbrains.mps.ide.java.newparser;



import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.ModelAccess;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.io.IOException;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.extapi.model.EditableSModelBase;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vfs.IFileUtils;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.scope.Scope;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelFactory;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.persistence.FilePerRootModelPersistence;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class JavaToMpsConverter {
  private static final Logger LOG = LogManager.getLogger(JavaToMpsConverter.class);

  private SModule myModule;
  private SModel myModel;
  private boolean myCreatePerRoot;
  private boolean myCreateInplace;
  private SRepository myRepository;
  private ModelAccess myModelAccess;


  private JavaParser myJavaParser = new JavaParser();
  private Map<String, Set<SNode>> classesPerPackage = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<String, List<IFile>> filesPerPackage = MapSequence.fromMap(new HashMap<String, List<IFile>>());
  private Map<String, IFile> packageDirs = MapSequence.fromMap(new HashMap<String, IFile>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<SNode> myRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<SNode> myAttachedRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<IFile> mySuccessfulFiles = ListSequence.fromList(new ArrayList<IFile>());

  private boolean wasDefaultPkg = false;
  private int myRootCount = 0;

  public JavaToMpsConverter(SModule module, SRepository repository) {
    this(module, repository, false, false);
  }

  public Set<SNode> getRootsBuilt() {
    return Collections.<SNode>unmodifiableSet(SetSequence.fromSetWithValues(new HashSet<SNode>(), myAttachedRoots));
  }

  public JavaToMpsConverter(SModule module, SRepository repository, boolean perRoot, boolean inPlace) {
    
    
    myModule = module;
    myCreatePerRoot = perRoot;
    myCreateInplace = inPlace;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public JavaToMpsConverter(SModel model, SRepository repository) {
    myModel = model;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {

    progress.start("Converting...", 31);

    
    final ProgressMonitor parseProgress = progress.subTask(1);
    parseProgress.start("Parsing...", ListSequence.fromList(files).count());

    

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (IFile file : ListSequence.fromList(files)) {
          try {
            parseFile(file);
            parseProgress.advance(1);

          } catch (JavaParseException e) {
          } catch (IOException e) {
          }
        }
      }
    });

    parseProgress.done();


    int rootCount = 0;

    

    runCommand("roots creation pass", new Runnable() {
      public void run() {

        SModule module;

        if (myModel == null) {
          ((AbstractModule) myModule).addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);

          for (String pakage : MapSequence.fromMap(classesPerPackage).keySet()) {
            final SModel model = getModel(pakage, MapSequence.fromMap(packageDirs).get(pakage));
            if (model == null) {
              continue;
            }

            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage"));
            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf280165065d5424eL, 0xbb1b463a8781b786L), "jetbrains.mps.baseLanguage.javadoc"));

            Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
            SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
              public void visit(SNode it) {
                model.addRootNode(it);
              }
            });

            ListSequence.fromList(mySuccessfulFiles).addSequence(ListSequence.fromList(MapSequence.fromMap(filesPerPackage).get(pakage)));
            ListSequence.fromList(myAttachedRoots).addSequence(SetSequence.fromSet(roots));

            ((EditableSModelBase) model).save();
            ListSequence.fromList(myModels).addElement(model);
          }
          module = myModule;

        } else {
          
          
          for (SNode root : ListSequence.fromList(myRoots)) {
            
            myModel.addRootNode(root);
          }
          myAttachedRoots = myRoots;
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"));
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f2801650-65d5-424e-bb1b-463a8781b786(jetbrains.mps.baseLanguage.javadoc)"));
          module = myModel.getModule();
        }

        JavaParser.tryResolveUnknowns(myAttachedRoots);
      }
    });

    myRootCount = myAttachedRoots.size();

    ProgressMonitor resolveProgress = progress.subTask(30);
    tryResolveRefs(myAttachedRoots, FeatureKind.CLASS, resolveProgress);
    progress.done();
  }

  public void tryResolveRefs(Iterable<SNode> nodes, FeatureKind level, ProgressMonitor progress) {
    progress.start("Resolving...", 10);

    if (FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("top level references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getTopLevelRefs(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
        }
      }, progress.subTask(1));
    }

    if (FeatureKind.CLASS_CONTENT.equals(level) || FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("field/method type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember")));
        }
      }, progress.subTask(1));
    }

    resolveUpdatePass("type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVarTypeRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("variable references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVariableRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operands", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operations", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")))).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return (SReference) it instanceof DynamicReference;
              }
            })) {
              return ListSequence.fromList(new ArrayList<SReference>());
            } else {
              if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration")));
              } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration")));
              } else {
                return ListSequence.fromList(new ArrayList<SReference>());
              }
            }
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("classifiers in static access", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("static member references", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("remaining references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return deepReferences(node);
      }
    }, progress.subTask(1));

    codeTransformPass(nodes, progress.subTask(1));

    removeJavaImportsPass(nodes, progress.subTask(1));

    progress.done();
  }

  public List<IFile> getSuccessfulFiles() {
    return mySuccessfulFiles;
  }

  public List<SModel> getModels() {
    return myModels;
  }

  private void parseFile(IFile file) throws JavaParseException, IOException {
    String contents = IFileUtils.getTextContents(file);
    JavaParser.JavaParseResult parseResult = myJavaParser.parseCompilationUnit(contents);
    String pkg = parseResult.getPackage();

    if (pkg == null) {
      
      if (!(wasDefaultPkg)) {
        LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
        wasDefaultPkg = true;
      }
      return;
    }

    IFile dir = file.getParent();
    if (!(DirParser.checkPackageMatchesSourceDirectory(pkg, dir))) {
      LOG.error("package " + pkg + " doesn't match directory " + dir.getPath() + " (in file " + file.getName() + ")");
      return;
    }

    IFile currentDir = MapSequence.fromMap(packageDirs).get(pkg);
    
    
    
    if (currentDir == null) {
      MapSequence.fromMap(packageDirs).put(pkg, dir);
    }

    Iterable<SNode> roots = parseResult.getNodes();

    Set<SNode> classesInPackage = MapSequence.fromMap(classesPerPackage).get(pkg);
    if (classesInPackage == null) {
      classesInPackage = SetSequence.fromSet(new HashSet<SNode>(Sequence.fromIterable(roots).count()));
      MapSequence.fromMap(classesPerPackage).put(pkg, classesInPackage);
    }
    SetSequence.fromSet(classesInPackage).addSequence(Sequence.fromIterable(roots));

    List<IFile> files = MapSequence.fromMap(filesPerPackage).get(pkg);
    if (files == null) {
      files = ListSequence.fromList(new ArrayList<IFile>());
      MapSequence.fromMap(filesPerPackage).put(pkg, files);
    }
    ListSequence.fromList(files).addElement(file);

    ListSequence.fromList(myRoots).addSequence(Sequence.fromIterable(roots));
    myRootCount += Sequence.fromIterable(roots).count();

  }

  private void runCommand(String name, final Runnable runnable) {
    if (SwingUtilities.isEventDispatchThread()) {
      myModelAccess.executeCommand(runnable);

    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            myModelAccess.executeCommand(runnable);
          }
        });

      } catch (InterruptedException e) {
        LOG.error(name + " was interrupted", e);
      } catch (InvocationTargetException e) {
        LOG.error("Exception in " + name, e.getCause());
      }
    }
  }

  private Set<SReference> myVisitedRefs = SetSequence.fromSet(new HashSet<SReference>());

  private void resolveUpdatePass(String name, final Iterable<SNode> nodes, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {
    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());
    progress.start(name, Sequence.fromIterable(nodes).count() + 1);

    myModelAccess.runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {

          if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"))) {
            progress.step("class: " + SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }

          Iterable<SReference> refs = extractor.invoke(node);
          resolveRefs(refs, resolveMap);

          SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
          progress.advance(1);
        }

      }
    });

    progress.step("updating references...");

    runCommand(name, new Runnable() {
      public void run() {
        updateReference(resolveMap);
      }
    });

    progress.advance(1);
    progress.done();
  }

  private void codeTransformPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Code transforms", Sequence.fromIterable(nodes).count() * 5 + 1);
    final TypeChecker typeChecker = TypeChecker.getInstance();

    
    final List<SNode> toReplaceWithArrayLength = ListSequence.fromList(new ArrayList<SNode>());
    final List<SNode> toReplaceWithArrayClone = ListSequence.fromList(new ArrayList<SNode>());
    final Map<SNode, SNode> enumConstRefs = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticMethodQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticFieldQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (SNode node : Sequence.fromIterable(nodes)) {

          for (SNode fieldRefOp : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(fieldRefOp, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "length".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(fieldRefOp), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayLength).addElement(fieldRefOp);
            }
          }

          progress.advance(1);

          for (SNode imco : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(imco, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "clone".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(imco), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayClone).addElement(imco);
            }
          }

          progress.advance(1);

          for (SNode localCall : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9404L, "jetbrains.mps.baseLanguage.structure.LocalMethodCall"), false, new SAbstractConcept[]{}))) {
            SNode smc = transformLocalCall(localCall);
            if ((smc == null)) {
              continue;
            }
            MapSequence.fromMap(staticMethodQualifiers).put(localCall, smc);
          }

          progress.advance(1);

          TypeChecker typeChecker = TypeChecker.getInstance();

          for (SNode swicthCase : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, "jetbrains.mps.baseLanguage.structure.SwitchCase"), false, new SAbstractConcept[]{}))) {
            SNode subst = transformUnqualifedEnumUnderSwitch(swicthCase, typeChecker);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(SNodeOperations.cast(SLinkOperations.getTarget(swicthCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), subst);
          }


          progress.advance(1);

          for (SNode varRef : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{}))) {
            SNode exp = transformLocalNameRef(varRef);
            if ((exp != null)) {
              MapSequence.fromMap(staticFieldQualifiers).put(varRef, exp);
              continue;
            }

            SNode subst = transformUnqualifedEnum(varRef);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(varRef, subst);
          }

          progress.advance(1);
        }

      }
    });

    progress.step("updating models...");

    runCommand("Code transforms", new Runnable() {
      public void run() {
        for (SNode fieldRefOp : ListSequence.fromList(toReplaceWithArrayLength)) {
          SNodeOperations.replaceWithNewChild(fieldRefOp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1197781411dL, "jetbrains.mps.baseLanguage.structure.ArrayLengthOperation"));
        }
        for (SNode imco : ListSequence.fromList(toReplaceWithArrayClone)) {
          SNodeOperations.replaceWithNewChild(imco, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x483ee9d7f09580d6L, "jetbrains.mps.baseLanguage.structure.ArrayCloneOperation"));
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(enumConstRefs)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticMethodQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticFieldQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }

      }
    });

    progress.advance(1);
    progress.done();
  }

  private void removeJavaImportsPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Removing java imports", Sequence.fromIterable(nodes).count() + 1);
    final Map<SNode, Iterable<SNode>> toRemove = MapSequence.fromMap(new HashMap<SNode, Iterable<SNode>>());

    myRepository.getModelAccess().runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {
          progress.advance(1);

          if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
            continue;
          }
          if ((AttributeOperations.getAttribute(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))) == null)) {
            continue;
          }

          MapSequence.fromMap(toRemove).put(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), getImportsToRemove(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))));
        }
      }
    });

    runCommand("removing java imports", new Runnable() {
      public void run() {
        for (SNode node : SetSequence.fromSet(MapSequence.fromMap(toRemove).keySet())) {
          Iterable<SNode> imps = MapSequence.fromMap(toRemove).get(node);
          Sequence.fromIterable(imps).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });

          SNode importAnnotation = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
          if (ListSequence.fromList(SLinkOperations.getChildren(importAnnotation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).isEmpty()) {
            SNodeOperations.deleteNode(importAnnotation);
          }
        }
      }
    });

    progress.advance(1);
    progress.done();

  }

  private SNode transformUnqualifedEnum(SNode varRef) {
    

    if (!(SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(varRef)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    if (ref.getTargetNode() != null) {
      return null;
    }

    
    SNode gateway = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved")));

    String enumConstName = ((DynamicReference) ref).getResolveInfo();

    for (SNode enclosingEnum : ListSequence.fromList(SNodeOperations.getNodeAncestors(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass"), false))) {
      SNode enumConstRef = makeEnumConstRef(enclosingEnum, enumConstName);
      if (enumConstRef != null) {
        return enumConstRef;
      }
    }

    SNode root = SNodeOperations.getContainingRoot(varRef);
    if (!(SNodeOperations.isInstanceOf(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
      return null;
    }
    SNode javaImports = AttributeOperations.getAttribute(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
    if ((javaImports == null)) {
      return null;
    }

    for (SNode singleNameImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticSingleName_5230012391903395274", new Object[]{}))) {
      if (!(enumConstName.equals(BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{})))) {
        continue;
      }

      String enumClassCandidateName = BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_withoutLastToken_6148840541591441572", new Object[]{});
      SNode enumClassCandidate = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, enumClassCandidateName});
      if ((enumClassCandidate == null)) {
        
        
        
        return null;
      }
      if (!(SNodeOperations.isInstanceOf(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        return null;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }

    for (SNode onDemandImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticOnDemand_5230012391903366883", new Object[]{}))) {
      SNode claz = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, SPropertyOperations.getString(onDemandImport, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x5a98df4004080866L, 0x1996ec29712bdd92L, "tokens"))});
      if ((claz == null)) {
        continue;
      }
      if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        continue;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }
    return null;
  }
  private SNode makeEnumConstRef(SNode enumClass, final String constName) {
    
    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return constName.equals(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
      }
    });
    if ((enumConst == null)) {
      return null;
    }

    SNode result = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return result;
  }

  private SNode transformUnqualifedEnumUnderSwitch(SNode switchCase, TypeChecker typeChecker) {
    

    SNode caseExp = SLinkOperations.getTarget(switchCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression"));
    if (!(SNodeOperations.isInstanceOf(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(SNodeOperations.cast(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    final String enumConstName = ((DynamicReference) ref).getResolveInfo();

    SNode scrutenee = SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, "jetbrains.mps.baseLanguage.structure.SwitchStatement"), false, false), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, 0x10ef02ec241L, "expression"));
    if ((scrutenee == null)) {
      return null;
    }

    SNode scruteneeType = typeChecker.getTypeOf(scrutenee);
    if (!(SNodeOperations.isInstanceOf(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")))) {
      return null;
    }

    SNode claz = SLinkOperations.getTarget(SNodeOperations.cast(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
    if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
      return null;
    }

    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")).equals(enumConstName);
      }
    });
    SNode enumConstRef = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return enumConstRef;
  }


  private SNode transformLocalCall(SNode localCall) {
    

    SReference ref = SNodeOperations.getReference(localCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")))) {
      return null;
    }

    Scope staticMethodScope = Scope.getScope(SNodeOperations.getParent(localCall), localCall, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration").getDeclarationNode());
    if (staticMethodScope.contains(target)) {
      return null;
    }

    
    SNode smc = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall")));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"), SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")));
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument"))).addElement(SNodeOperations.copyNode(arg));
    }
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument"))).addElement(SNodeOperations.copyNode(arg));
    }

    return smc;
  }

  private SNode transformLocalNameRef(SNode varRef) {
    

    

    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")))) {
      return null;
    }

    
    SNode thisClass = SNodeOperations.getNodeAncestor(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    SNode thatClass = SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    
    if (thisClass == thatClass) {
      
      return null;
    }

    
    SNode sfr = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"), thatClass);
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")));

    return sfr;
  }


  private Iterable<SNode> getImportsToRemove(SNode root) {
    

    final Map<String, SNode> importsByName = MapSequence.fromMap(new HashMap<String, SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SPropertyOperations.getBoolean(it, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x64c0181e603bcfL, 0x64c0181e603bd0L, "onDemand")));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(importsByName).put(BehaviorReflection.invokeNonVirtual(String.class, it, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{}), it);

      }
    });

    boolean unknownPresent = false;
    boolean dynRefsPresent = false;
    Set<SNode> retain = SetSequence.fromSet(new HashSet<SNode>());

    Deque<SNode> stack = DequeSequence.fromDequeNew(new LinkedList<SNode>());
    DequeSequence.fromDequeNew(stack).pushElement(root);

    while (DequeSequence.fromDequeNew(stack).isNotEmpty()) {
      SNode node = DequeSequence.fromDequeNew(stack).popElement();
      DequeSequence.fromDequeNew(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));

      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved"))) {
        unknownPresent = true;
        break;
      }

      Iterable<? extends SReference> refs = node.getReferences();
      for (SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }

        dynRefsPresent = true;

        String resolveInfo = ((DynamicReference) ref).getResolveInfo();
        SetSequence.fromSet(retain).addElement(MapSequence.fromMap(importsByName).get(resolveInfo));
      }
    }

    
    if (unknownPresent) {
      return null;
    }
    
    if (dynRefsPresent == false) {
      
      return SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"));
    }
    
    
    Iterable<SNode> unneeded = Sequence.fromIterable(MapSequence.fromMap(importsByName).values()).subtract(SetSequence.fromSet(retain));
    return unneeded;
  }

  private Iterable<SReference> getTopLevelRefs(SNode node) {
    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")))));
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });

    } else if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });
    }

    for (SNode inner : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, new SAbstractConcept[]{}))) {
      if (SNodeOperations.isInstanceOf(inner, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
        continue;
      }
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));
    }

    return refs;
  }

  private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    Iterable<SNode> members = (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) ? SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, "member")) : Sequence.<SNode>singleton(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember"))));

    for (SNode member : Sequence.fromIterable(members)) {
      if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9408L, "jetbrains.mps.baseLanguage.structure.MethodDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, "returnType")))));
        for (SNode param : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(param, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
        }
        for (SNode thrws : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x10f383d6949L, "throwsItem")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(thrws)));
        }

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(member)));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVarTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    for (SNode block : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, "jetbrains.mps.baseLanguage.structure.StatementList"), false, new SAbstractConcept[]{}))) {

      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getNodeDescendants(block, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"), false, new SAbstractConcept[]{}))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(varDecl, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVariableRefs(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
      }
    }).select(new ISelector<SNode, SReference>() {
      public SReference select(SNode it) {
        return SNodeOperations.getReference(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
      }
    });
  }

  private Iterable<SReference> getDotExpLeftParts(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
      public Iterable<SReference> translate(SNode it) {
        return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
      }
    });
  }

  private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {
    for (SReference ref : refs) {
      if (!(ref instanceof DynamicReference)) {
        continue;
      }
      if (SetSequence.fromSet(myVisitedRefs).contains((SReference) ref)) {
        continue;
      }

      SNode target = ref.getTargetNode();
      if (target == null) {
        continue;
      }

      SNode source = ref.getSourceNode();
      SModelReference targetModel = target.getModel().getReference();

      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId(), ((DynamicReference) ref).getResolveInfo());

      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());
      if (nodeRefs == null) {
        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());
        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);
      }
      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);
    }
  }

  private void updateReference(Map<SNodeReference, List<SReference>> refMap) {
    for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(refMap).keySet())) {
      final SNode node = nodeRef.resolve(myRepository);
      if (node == null) {
        continue;
      }
      final SModel sourceModel = node.getModel();
      ListSequence.fromList(MapSequence.fromMap(refMap).get(nodeRef)).visitAll(new IVisitor<SReference>() {
        public void visit(SReference it) {

          SModelReference targetModelRef = it.getTargetSModelReference();
          if (!(sourceModel.getReference().equals(targetModelRef))) {
            
            ((SModelInternal) sourceModel).addModelImport(targetModelRef, true);
          }

          node.setReference(it.getRole(), it);
        }
      });
    }
  }

  public static Iterable<SReference> deepReferences(SNode node) {

    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(node)));
    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(child)));
    }

    return refs;

    
  }

  private SModel getModel(String pkgFqName, IFile pkgDir) {
    for (SModel model : Sequence.fromIterable(myModule.getModels())) {
      
      
      if (pkgFqName.equals(model.getModelName())) {
        return model;
      }
    }
    return createModel(pkgFqName, pkgDir);
  }
  private SModel createModel(String pkgFqName, IFile pkgDir) {
    SModel modelDescr;
    try {

      if (myCreateInplace) {
        Tuples._2<ModelRoot, String> place = getRootContainingDir(pkgDir);
        ModelRoot modelRoot = place._0();
        String sourceRoot = place._1();
        if (modelRoot == null) {
          LOG.error("Cannot convert to MPS in-place: java sources not under proper model root");
          return null;
        }
        Map<String, String> options = MapSequence.fromMap(new HashMap<String, String>());
        
        
        String fullPath = pkgDir.getPath().replace('\\', '/');
        String sr = sourceRoot.replace('\\', '/');
        MapSequence.fromMap(options).put(ModelFactory.OPTION_RELPATH, FileUtil.getRelativePath(pkgDir.getPath(), sourceRoot, "/"));
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, sourceRoot, options, PersistenceRegistry.getInstance().getFolderModelFactory(FilePerRootModelPersistence.FACTORY_ID));

      } else {
        ModelRoot modelRoot = getFirstRootToCreateModel(pkgFqName);
        if (modelRoot == null) {
          LOG.error("Failed to find model root to create model in");
          return null;
        }
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, null, null, PersistenceRegistry.getInstance().getModelFactory(MPSExtentions.MODEL));
      }

      if (modelDescr == null) {
        LOG.error("Failed to create model: createModel returned null");
        return null;
      }
    } catch (IOException e) {
      LOG.error("Failed to create model", e);
      return null;
    }

    
    
    modelDescr.load();
    ((EditableSModel) modelDescr).setChanged(true);
    ((EditableSModel) modelDescr).save();

    return modelDescr;
  }
  @Nullable
  private ModelRoot getFirstRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (!(root instanceof DefaultModelRoot)) {
        continue;
      }
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }
  private Tuples._2<ModelRoot, String> getRootContainingDir(IFile dir) {
    
    for (ModelRoot modelRoot : Sequence.fromIterable(myModule.getModelRoots())) {
      
      if (!(modelRoot instanceof DefaultModelRoot)) {
        continue;
      }
      for (String sourceRoot : ((DefaultModelRoot) modelRoot).getFiles(FileBasedModelRoot.SOURCE_ROOTS)) {
        if (FileUtil.isSubPath(sourceRoot, dir.getPath())) {
          return MultiTuple.<ModelRoot,String>from(modelRoot, sourceRoot);
        }
      }
    }
    return MultiTuple.<ModelRoot,String>from((ModelRoot) null, (String) null);
  }

}

<code block>
package jetbrains.mps.debugger.java.runtime.evaluation.model;



import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationContainer;
import jetbrains.mps.project.Project;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.debugger.java.runtime.evaluation.container.IEvaluationContainer;
import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.debugger.java.runtime.evaluation.container.BaseLanguagesImportHelper;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.sun.jdi.InvalidStackFrameException;
import org.apache.log4j.Level;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.ide.findusages.model.scopes.ModelsScope;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.CopyUtil;
import com.intellij.openapi.extensions.PluginId;
import com.intellij.ide.plugins.PluginManager;
import jetbrains.mps.debug.api.Debuggers;
import jetbrains.mps.debugger.java.runtime.JavaDebugger;
import java.io.File;
import com.intellij.ide.plugins.IdeaPluginDescriptorImpl;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SNodePointer;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class EvaluationWithContextContainer extends EvaluationContainer {
  private final boolean myIsInWatch;
  private boolean myVariablesInitialized = false;
  protected final EvaluationContext myEvaluationContext;
  public EvaluationWithContextContainer(Project project, DebugSession session, @NotNull SModuleReference containerModule, List<SNodeReference> nodesToImport, boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    super(project, session, containerModule, nodesToImport, onNodeSetUp);
    myIsInWatch = isInWatch;
    myEvaluationContext = new StackFrameContext(session.getUiState());
  }

  @Override
  protected void setUpNode(List<SNodeReference> nodesToImport) {
    EvaluationModule containerModule = (EvaluationModule) myContainerModule.resolve(myDebuggerRepository);
    
    SModel containerModel = SModelRepository.getInstance().getModelDescriptor(myContainerModel);

    setUpDependencies(containerModule, containerModel);


    final SNode evaluatorNode = createEvaluatorNode();
    containerModel.addRootNode(evaluatorNode);
    myNode = evaluatorNode.getReference();

    createVars();
    tryToImport(evaluatorNode, nodesToImport);

    SModelOperations.validateLanguagesAndImports(containerModel, true, true);
  }
  private void setUpDependencies(final EvaluationModule containerModule, SModel containerModel) {
    ListSequence.fromList(myEvaluationContext.getClassPath()).union(ListSequence.fromList(getDebuggerStubPath())).visitAll(new IVisitor<String>() {
      public void visit(String it) {
        containerModule.addClassPathItem(it);
      }
    });
    containerModule.updateModelsSet();

    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x7da4580f9d754603L, 0x816251a896d78375L), "jetbrains.mps.debugger.java.evaluation"));
    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x802088974572437dL, 0xb50e8f050cba9566L), "jetbrains.mps.debugger.java.privateMembers"));
    containerModule.addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);
  }
  private void tryToImport(final SNode evaluatorNode, List<SNodeReference> nodesToImport) {
    BaseLanguagesImportHelper helper = new EvaluationWithContextContainer.MyBaseLanguagesImportHelper(evaluatorNode);
    helper.tryToImport(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), evaluatorNode, "virtual_getCode_317191294093624551", new Object[]{}), nodesToImport);
  }
  @Override
  protected SNode createEvaluatorNode() {
    SNode evaluatorConcept = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")), null);
    SPropertyOperations.set(evaluatorConcept, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (myIsInWatch));
    AttributeOperations.createAndSetAttrbiute(SLinkOperations.getTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x10093bb8b0669700L, "evaluatedStatements")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x4135c73fbe7fc985L, "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation")), "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation");
    return evaluatorConcept;
  }
  private void createVars() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        fillVariables(SNodeOperations.cast(getNode(), MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")));
      }
    });
  }
  private void fillVariables(SNode evaluatorConcept) {
    try {
      _FunctionTypes._return_P1_E0<? extends SNode, ? super String> createClassifierType = new _FunctionTypes._return_P1_E0<SNode, String>() {
        public SNode invoke(String name) {
          return createClassifierType(name);
        }
      };
      Map<String, VariableDescription> contextVariables = myEvaluationContext.getVariables(createClassifierType);

      Map<String, SNode> declaredVariables = MapSequence.fromMap(new LinkedHashMap<String, SNode>(16, (float) 0.75, false));
      for (SNode var : ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables")))) {
        MapSequence.fromMap(declaredVariables).put(SPropertyOperations.getString(var, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x4db8c07036eb94eeL, "lowLevelName")), var);
      }

      final Set<SNode> foundVars = SetSequence.fromSet(new HashSet<SNode>());
      for (String variable : MapSequence.fromMap(contextVariables).keySet()) {

        String name = variable;
        SNode lowLevelVarNode = MapSequence.fromMap(declaredVariables).get(name);

        if (needUpdateVariables()) {
          
          if (lowLevelVarNode == null) {
            lowLevelVarNode = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariable")));
            ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).addElement(lowLevelVarNode);
            MapSequence.fromMap(declaredVariables).put(name, lowLevelVarNode);
          }
          MapSequence.fromMap(contextVariables).get(variable).updateLowLevelVariable(lowLevelVarNode);
        }

        SetSequence.fromSet(foundVars).addElement(lowLevelVarNode);
      }

      
      Sequence.fromIterable(MapSequence.fromMap(declaredVariables).values()).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SPropertyOperations.set(it, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x554b4e03d5950431L, "isOutOfScope"), "" + (!(SetSequence.fromSet(foundVars).contains(it))));
        }
      });

      if (needUpdateVariables()) {
        
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23615L, "contextNode"), myEvaluationContext.getStaticContextType(createClassifierType));
        
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23613L, "thisNode"), myEvaluationContext.getThisClassifierType(createClassifierType));
      }
      
    } catch (InvalidStackFrameException e) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("InvalidStackFrameException", e);
      }
    }
    myVariablesInitialized = true;
  }

  @Override
  public void updateState() {
    super.updateState();
    if (myDebugSession.getEvaluationProvider().canEvaluate()) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          createVars();
        }
      });
    }
  }
  @Nullable
  private SNode createClassifierType(final String unitFqName) {
    SNode unit = findUnit(unitFqName);
    if (unit == null) {
      return null;
    }
    SNode classifierType = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")));
    SLinkOperations.setTarget(classifierType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), SNodeOperations.cast(unit, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
    return classifierType;
  }
  public SNode findUnit(final String unitName) {
    
    
    SModel stub = findStubForFqName(modelFqNameFromUnitName(unitName));
    if (stub != null) {
      SModel model = stub;
      SNode node = ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.nodes(model, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return eq_v5yv3u_a0a0a0a0a0a0b0d0o(BehaviorReflection.invokeVirtual(String.class, it, "virtual_getUnitName_5067982036267369911", new Object[]{}), unitName) && SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      });
      if (node != null) {
        return node;
      }
    }

    FindUsagesFacade findUsages = FindUsagesFacade.getInstance();
    SAbstractConcept concept = MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept");

    Set<SNode> instances = findUsages.findInstances(new ModelsScope(getCandidateNonStubModels(unitName)), Collections.singleton(concept), false, new EmptyProgressMonitor());
    return SNodeOperations.cast(SetSequence.fromSet(instances).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(((SNode) it), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) && BehaviorReflection.invokeVirtual(String.class, SNodeOperations.cast(it, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept")), "virtual_getUnitName_5067982036267369911", new Object[]{}).equals(unitName);
      }
    }), MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"));
  }
  @Nullable
  private SModel findStubForFqName(String fqName) {
    return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(fqName, SModelStereotype.JAVA_STUB));
  }
  private boolean needUpdateVariables() {
    return !(myVariablesInitialized) || !(myIsInWatch);
  }
  @Override
  public EvaluationWithContextContainer copy(final boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    final SNodeReference reference = myNode;
    return new EvaluationWithContextContainer(myProject, myDebugSession, myContainerModule, ListSequence.fromList(new ArrayList<SNodeReference>()), isInWatch, onNodeSetUp) {
      @Override
      protected SNode createEvaluatorNode() {
        SNode newEvaluator = (SNode) CopyUtil.copyAndPreserveId(reference.resolve(myDebuggerRepository), true);
        SPropertyOperations.set(newEvaluator, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (isInWatch));
        return newEvaluator;
      }
    };
  }
  public static List<String> getDebuggerStubPath() {
    PluginId apiPlugin = PluginManager.getPluginByClassName(Debuggers.class.getName());
    PluginId javaPlugin = PluginManager.getPluginByClassName(JavaDebugger.class.getName());

    List<File> paths = ListSequence.fromList(new ArrayList<File>());
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(apiPlugin)).getClassPath()));
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(javaPlugin)).getClassPath()));

    return ListSequence.fromList(paths).select(new ISelector<File, String>() {
      public String select(File it) {
        return (String) it.getAbsolutePath();
      }
    }).toListSequence();
  }
  public static Iterable<SModel> getCandidateNonStubModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }
  public static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ? "" : unitName.substring(0, lastDot)));
  }
  private class MyBaseLanguagesImportHelper extends BaseLanguagesImportHelper {
    private final SNode myEvaluatorNode;
    public MyBaseLanguagesImportHelper(SNode evaluatorNode) {
      myEvaluatorNode = evaluatorNode;
    }
    @Override
    public SNode findVariable(final SReference variableReference) {
      SNode matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode variable) {
          return eq_v5yv3u_a0a0a0a0a0a0a2v(SNodePointer.deserialize(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x6db8b4aef007e84fL, "highLevelNodeId"))), SLinkOperations.getTargetNode(variableReference).getReference());
        }
      });
      if (matchingVar == null) {
        matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode variable) {
            return eq_v5yv3u_a0a0a0a0a0a0a1a2v(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTargetNode(variableReference), MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }
        });
      }
      return matchingVar;
    }
    @Override
    public SNode createVariableReference(SNode variable) {
      SNode newVariableReference = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7d9a547f857a394bL, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariableReference")));
      SLinkOperations.setTarget(newVariableReference, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x4c4b92003e49a704L, 0x4c4b92003e49a705L, "baseVariableDeclaration"), variable);
      return newVariableReference;
    }
  }
  protected static Logger LOG = LogManager.getLogger(EvaluationWithContextContainer.class);
  private static boolean eq_v5yv3u_a0a0a0a0a0a0b0d0o(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a1a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}

<code block>
package jetbrains.mps.migration.component.util;



import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;

import java.util.Map;

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;

import java.util.HashMap;

import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;

import javax.swing.SwingUtilities;

import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.project.AbstractModule;

import java.util.List;

import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;

import java.util.ArrayList;

import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;

import java.util.Collection;

import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + BehaviorReflection.invokeNonVirtualStatic(String.class,
        SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L,
            "jetbrains.mps.lang.migration.structure.MigrationScript").getDeclarationNode()), "call_getGeneratedClassName_8648538385393994830", new Object[]{});
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchScript(MigrationScriptReference scriptReference) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0u(md, current);
    if (script == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static boolean areDepsSatisfied(final ScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        result.value = isMigrationRequired(mpsProject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean languageMig = isLanguageMigrationRequired(modules);
    return projectMig || languageMig;
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (fetchScript(new MigrationScriptReference(lang, v)) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule, SLanguage, Integer>from(module, lang, v));
                
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isLanguageMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
      public boolean accept(final AbstractModule module) {
        return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
          public boolean accept(MigrationScriptReference item) {
            return MigrationsUtil.isMigrationNeeded(item.getLanguage(), item.getFromVersion(), module);
          }
        });
      }
    });
  }

  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(fromLanguage);
      ((SModelInternal) model).addLanguage(fromLanguage, toVersion);
    }

    return true;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }

      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(mpsProject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int languageStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule =
            Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(
                new ISelector<AbstractModule, Integer>() {
                  public Integer select(AbstractModule module) {
                    int scripts = 0;
                    for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
                      int currentLangVersion = lang.getLanguageVersion();
                      int ver = module.getUsedLanguageVersion(lang);

                      ver = Math.max(ver, 0);
                      currentLangVersion = Math.max(currentLangVersion, 0);

                      if (ver < currentLangVersion) {
                        scripts += currentLangVersion - ver;
                      }
                    }
                    return scripts;
                  }
                });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextLanguageStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());

        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).ofType(AbstractModule.class).any(
            new IWhereFilter<AbstractModule>() {
              public boolean accept(final AbstractModule module) {
                return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
                  public boolean accept(MigrationScriptReference it) {
                    if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {
                      return false;
                    }
                    MigrationScript loaded = fetchScript(it);
                    if (loaded == null) {
                      return false;
                    }
                    final ScriptApplied applied = new ScriptApplied(loaded, module);
                    if (!(areDepsSatisfied(applied))) {
                      return false;
                    }
                    result.value = new MigrationManager.MigrationStep() {
                      public String getDescription() {
                        return applied.toString();
                      }

                      public boolean execute() {
                        final Wrappers._boolean res = new Wrappers._boolean();
                        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                          public void run() {
                            res.value = executeScript(applied);
                          }
                        });
                        return res.value;
                      }

                      public void forceExecutionNextTime() {
                        throw new UnsupportedOperationException("not supported for language migrations");
                      }
                    };
                    return true;
                  }
                });
              }
            });
      }
    }));

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);

  private static MigrationScript check_gd1mrb_a0e0u(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}

<code block>

package jetbrains.mps.persistence.binary;

import jetbrains.mps.extapi.model.GeneratableSModel;
import jetbrains.mps.generator.ModelDigestUtil;
import jetbrains.mps.generator.ModelDigestUtil.DigestBuilderOutputStream;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.persistence.IndexAwareModelFactory.Callback;
import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.MetaModelInfoProvider.BaseMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.RegularMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.StuffedMetaModelInfo;
import jetbrains.mps.persistence.registry.AggregationLinkInfo;
import jetbrains.mps.persistence.registry.AssociationLinkInfo;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.persistence.registry.PropertyInfo;
import jetbrains.mps.smodel.DefaultSModel;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.v9.IdInfoCollector;
import jetbrains.mps.smodel.runtime.ConceptKind;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.util.io.ModelInputStream;
import jetbrains.mps.util.io.ModelOutputStream;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.StreamDataSource;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import static jetbrains.mps.smodel.SModel.ImportElement;


public final class BinaryPersistence {

  private final MetaModelInfoProvider myMetaInfoProvider;
  private final SModel myModelData;

  public static SModelHeader readHeader(@NotNull StreamDataSource source) throws ModelReadException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(source.openInputStream());
      return loadHeader(mis);
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.getMessage(), e);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  public static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull StreamDataSource source, boolean interfaceOnly) throws ModelReadException {
    final SModelReference desiredModelRef = header.getModelReference();
    try {
      ModelLoadResult rv = loadModel(source.openInputStream(), interfaceOnly, header.getMetaInfoProvider());
      SModelReference actualModelRef = rv.getModel().getReference();
      if (!actualModelRef.equals(desiredModelRef)) {
        throw new ModelReadException(String.format("Intended to read model %s, actually read %s", desiredModelRef, actualModelRef), null, actualModelRef);
      }
      return rv;
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e, desiredModelRef);
    }
  }

  @NotNull
  public static SModel readModel(@NotNull final InputStream content) throws ModelReadException {
    try {
      return loadModel(content, false, null).getModel();
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e);
    }
  }

  public static void writeModel(@NotNull SModel model, @NotNull StreamDataSource dataSource) throws IOException {
    if (dataSource.isReadOnly()) {
      throw new IOException(String.format("`%s' is read-only", dataSource.getLocation()));
    }
    writeModel(model, dataSource.openOutputStream());
  }
  public static void writeModel(@NotNull SModel model, @NotNull OutputStream stream) throws IOException {
    ModelOutputStream os = null;
    try {
      os = new ModelOutputStream(stream);
      saveModel(model, os);
    } finally {
      FileUtil.closeFileSafe(os);
    }
  }

  public static Map<String, String> getDigestMap(jetbrains.mps.smodel.SModel model) {
    Map<String, String> result = new LinkedHashMap<String, String>();
    IdInfoRegistry meta = null;
    DigestBuilderOutputStream os = ModelDigestUtil.createDigestBuilderOutputStream();
    try {
      BinaryPersistence bp = new BinaryPersistence(new RegularMetaModelInfo(), model);
      ModelOutputStream mos = new ModelOutputStream(os);
      meta = bp.saveModelProperties(mos);
      mos.flush();
    } catch (IOException ignored) {
      assert false;
      
    }
    result.put(GeneratableSModel.HEADER, os.getResult());

    assert meta != null;
    
    
    
    
    

    for (SNode node : model.getRootNodes()) {
      os = ModelDigestUtil.createDigestBuilderOutputStream();
      try {
        ModelOutputStream mos = new ModelOutputStream(os);
        new NodesWriter(model.getReference(), mos, meta).writeNode(node);
        mos.flush();
      } catch (IOException ignored) {
        assert false;
        
      }
      SNodeId nodeId = node.getNodeId();
      if (nodeId != null) {
        result.put(nodeId.toString(), os.getResult());
      }
    }

    return result;
  }


  private static final int HEADER_START   = 0x91ABABA9;
  private static final int STREAM_ID_V1   = 0x00000300;
  private static final int STREAM_ID_V2   = 0x00000400;
  private static final int STREAM_ID      = STREAM_ID_V2;
  private static final byte HEADER_ATTRIBUTES = 0x7e;
  private static final int HEADER_END     = 0xabababab;
  private static final int MODEL_START    = 0xbabababa;
  private static final int REGISTRY_START = 0x5a5a5a5a;
  private static final int REGISTRY_END   = 0xa5a5a5a5;
  private static final byte STUB_NONE     = 0x12;
  private static final byte STUB_ID       = 0x13;



  @NotNull
  private static SModelHeader loadHeader(ModelInputStream is) throws IOException {
    if (is.readInt() != HEADER_START) {
      throw new IOException("bad stream, no header");
    }

    int streamId = is.readInt();
    if (streamId == STREAM_ID_V1) {
      throw new IOException(String.format("Can't read old binary persistence version (%x), please re-save models", streamId));
    }
    if (streamId != STREAM_ID) {
      throw new IOException(String.format("bad stream, unknown version: %x", streamId));
    }

    SModelReference modelRef = is.readModelReference();
    SModelHeader result = new SModelHeader();
    result.setModelReference(modelRef);
    is.readInt(); 
    is.mark(4);
    if (is.readByte() == HEADER_ATTRIBUTES) {
      result.setDoNotGenerate(is.readBoolean());
      int propsCount = is.readShort();
      for (; propsCount > 0; propsCount--) {
        String key = is.readString();
        String value = is.readString();
        result.setOptionalProperty(key, value);
      }
    } else {
      is.reset();
    }
    assertSyncToken(is, HEADER_END);
    return result;
  }
  @NotNull
  private static ModelLoadResult loadModel(InputStream is, boolean interfaceOnly, @Nullable MetaModelInfoProvider mmiProvider) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(is);
      SModelHeader modelHeader = loadHeader(mis);

      DefaultSModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(mmiProvider == null ? new RegularMetaModelInfo() : mmiProvider, model);
      ReadHelper rh = bp.loadModelProperties(mis);
      rh.requestInterfaceOnly(interfaceOnly);

      NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, rh);
      reader.readNodesInto(model);
      return new ModelLoadResult((SModel) model, reader.hasSkippedNodes() ? ModelLoadingState.INTERFACE_LOADED : ModelLoadingState.FULLY_LOADED);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void saveModel(SModel model, ModelOutputStream os) throws IOException {
    final MetaModelInfoProvider mmiProvider;
    if (model instanceof DefaultSModel && ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider() != null) {
      mmiProvider = ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider();
    } else {
      mmiProvider = new RegularMetaModelInfo();
    }
    BinaryPersistence bp = new BinaryPersistence(mmiProvider, model);
    IdInfoRegistry meta = bp.saveModelProperties(os);

    Collection<SNode> roots = IterableUtil.asCollection(model.getRootNodes());
    new NodesWriter(model.getReference(), os, meta).writeNodes(roots);
  }

  private BinaryPersistence(@NotNull MetaModelInfoProvider mmiProvider, SModel modelData) {
    myMetaInfoProvider = mmiProvider;
    myModelData = modelData;
  }

  private ReadHelper loadModelProperties(ModelInputStream is) throws IOException {
    final ReadHelper readHelper = loadRegistry(is);

    loadUsedLanguages(is);

    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addEngagedOnGenerationLanguage(ref);
    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addDevKit(ref);

    for (ImportElement imp : loadImports(is)) myModelData.addModelImport(imp);

    assertSyncToken(is, MODEL_START);

    return readHelper;
  }

  private IdInfoRegistry saveModelProperties(ModelOutputStream os) throws IOException {
    
    os.writeInt(HEADER_START);
    os.writeInt(STREAM_ID);
    os.writeModelReference(myModelData.getReference());
    os.writeInt(-1);  
    if (myModelData instanceof DefaultSModel) {
      os.writeByte(HEADER_ATTRIBUTES);
      SModelHeader mh = ((DefaultSModel) myModelData).getSModelHeader();
      os.writeBoolean(mh.isDoNotGenerate());
      Map<String, String> props = new HashMap<String, String>(mh.getOptionalProperties());
      os.writeShort(props.size());
      for (Entry<String, String> e : props.entrySet()) {
        os.writeString(e.getKey());
        os.writeString(e.getValue());
      }
    }
    os.writeInt(HEADER_END);

    final IdInfoRegistry rv = saveRegistry(os);

    
    saveUsedLanguages(os);
    saveModuleRefList(myModelData.engagedOnGenerationLanguages(), os);
    saveModuleRefList(myModelData.importedDevkits(), os);

    
    saveImports(myModelData.importedModels(), os);
    

    os.writeInt(MODEL_START);
    return rv;
  }

  private IdInfoRegistry saveRegistry(ModelOutputStream os) throws IOException {
    os.writeInt(REGISTRY_START);
    IdInfoRegistry metaInfo = new IdInfoRegistry();
    new IdInfoCollector(metaInfo, myMetaInfoProvider).fill(myModelData.getRootNodes());
    List<LangInfo> languagesInUse = metaInfo.getLanguagesInUse();
    os.writeShort(languagesInUse.size());
    
    
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;
    for(LangInfo ul : languagesInUse) {
      os.writeUUID(ul.getLanguageId().getIdValue());
      os.writeString(ul.getName());
      ul.setIntIndex(langIndex++);
      
      List<ConceptInfo> conceptsInUse = ul.getConceptsInUse();
      os.writeShort(conceptsInUse.size());
      for (ConceptInfo ci : conceptsInUse) {
        os.writeLong(ci.getConceptId().getIdValue());
        assert ul.getName().equals(NameUtil.namespaceFromConceptFQName(ci.getName())) : "We save concept short name. This check ensures we can re-construct fqn based on language name";
        os.writeString(ci.getBriefName());
        os.writeByte(ci.getKind().ordinal() << 4 | ci.getScope().ordinal());
        if (ci.isImplementationWithStub()) {
          os.writeByte(STUB_ID);
          os.writeLong(ci.getStubCounterpart().getIdValue());
        } else {
          os.writeByte(STUB_NONE);
        }
        ci.setIntIndex(conceptIndex++);
        
        List<PropertyInfo> propertiesInUse = ci.getPropertiesInUse();
        os.writeShort(propertiesInUse.size());
        for(PropertyInfo pi : propertiesInUse) {
          os.writeLong(pi.getPropertyId().getIdValue());
          os.writeString(pi.getName());
          pi.setIntIndex(propertyIndex++);
        }
        
        List<AssociationLinkInfo> associationsInUse = ci.getAssociationsInUse();
        os.writeShort(associationsInUse.size());
        for (AssociationLinkInfo li : associationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          li.setIntIndex(associationIndex++);
        }
        
        List<AggregationLinkInfo> aggregationsInUse = ci.getAggregationsInUse();
        os.writeShort(aggregationsInUse.size());
        for (AggregationLinkInfo li : aggregationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          os.writeBoolean(li.isUnordered());
          li.setIntIndex(aggregationIndex++);
        }
      }
    }
    os.writeInt(REGISTRY_END);
    return metaInfo;
  }

  private ReadHelper loadRegistry(ModelInputStream is) throws IOException {
    assertSyncToken(is, REGISTRY_START);
    
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;

    ReadHelper rh = new ReadHelper(myMetaInfoProvider);

    int langCount = is.readShort();
    while (langCount-- > 0) {
      final SLanguageId languageId = new SLanguageId(is.readUUID());
      final String langName = is.readString();
      rh.withLanguage(languageId, langName, langIndex++);
      
      int conceptCount = is.readShort();
      while (conceptCount-- > 0) {
        final SConceptId conceptId = new SConceptId(languageId, is.readLong());
        final String conceptName = NameUtil.conceptFQNameFromNamespaceAndShortName(langName, is.readString());
        int flags = is.readByte();
        int stubToken = is.readByte();
        final SConceptId stubId;
        if (stubToken == STUB_NONE) {
          stubId = null;
        } else {
          assert stubToken == STUB_ID;
          stubId = new SConceptId(languageId, is.readLong());
        }
        rh.withConcept(conceptId, conceptName, StaticScope.values()[flags & 0x0f], ConceptKind.values()[flags >> 4 & 0x0f], stubId, conceptIndex++);
        
        int propertyCount = is.readShort();
        while (propertyCount-- > 0) {
          rh.property(new SPropertyId(conceptId, is.readLong()), is.readString(), propertyIndex++);
        }
        
        int associationCount = is.readShort();
        while (associationCount-- > 0) {
          rh.association(new SReferenceLinkId(conceptId, is.readLong()), is.readString(), associationIndex++);
        }
        
        int aggregationCount = is.readShort();
        while (aggregationCount-- > 0) {
          rh.aggregation(new SContainmentLinkId(conceptId, is.readLong()), is.readString(), is.readBoolean(), aggregationIndex++);
        }
      }
    }
    assertSyncToken(is, REGISTRY_END);
    return rh;
  }

  private void saveUsedLanguages(ModelOutputStream os) throws IOException {
    Collection<SLanguage> refs = myModelData.usedLanguages();
    os.writeShort(refs.size());
    for (SLanguage l : refs) {
      
      os.writeUUID(IdHelper.getLanguageId(l).getIdValue());
      os.writeString(l.getQualifiedName());
      os.writeInt(l.getLanguageVersion());
    }
  }

  private void loadUsedLanguages(ModelInputStream is) throws IOException {
    int size = is.readShort();
    for (int i = 0; i < size; i++) {
      SLanguageId id = new SLanguageId(is.readUUID());
      String name = is.readString();
      int version = is.readInt();
      SLanguage l = MetaAdapterFactory.getLanguage(id, name, version);
      myModelData.addLanguage(l);
      myMetaInfoProvider.setLanguageName(id, name);
    }
  }

  private static void saveModuleRefList(Collection<SModuleReference> refs, ModelOutputStream os) throws IOException {
    os.writeShort(refs.size());
    for (SModuleReference ref : refs) {
      os.writeModuleReference(ref);
    }
  }

  private static Collection<SModuleReference> loadModuleRefList(ModelInputStream is) throws IOException {
    int size = is.readShort();
    List<SModuleReference> result = new ArrayList<SModuleReference>(size);
    for (int i = 0; i < size; i++) {
      result.add(is.readModuleReference());
    }
    return result;
  }

  private static void saveImports(Collection<ImportElement> elements, ModelOutputStream os) throws IOException {
    os.writeInt(elements.size());
    for (ImportElement element : elements) {
      os.writeModelReference(element.getModelReference());
      os.writeInt(element.getUsedVersion());
    }
  }

  private static List<ImportElement> loadImports(ModelInputStream is) throws IOException {
    int size = is.readInt();
    List<ImportElement> result = new ArrayList<ImportElement>();
    for (int i = 0; i < size; i++) {
      SModelReference ref = is.readModelReference();
      result.add(new ImportElement(ref, -1, is.readInt()));
    }
    return result;
  }

  public static void index(InputStream content, final Callback consumer) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(content);
      SModelHeader modelHeader = loadHeader(mis);
      SModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(new StuffedMetaModelInfo(new BaseMetaModelInfo()), model);
      final ReadHelper readHelper = bp.loadModelProperties(mis);
      for (ImportElement element : model.importedModels()) {
        consumer.imports(element.getModelReference());
      }
      for (SConceptId cid : readHelper.getParticipatingConcepts()) {
        consumer.instances(cid);
      }
      readHelper.requestInterfaceOnly(false);
      final NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, readHelper);
      HashSet<SNodeId> externalNodes = new HashSet<SNodeId>();
      HashSet<SNodeId> localNodes = new HashSet<SNodeId>();
      reader.collectExternalTargets(externalNodes);
      reader.collectLocalTargets(localNodes);
      reader.readChildren(null);
      for (SNodeId n : externalNodes) {
        consumer.externalNodeRef(n);
      }
      for (SNodeId n : localNodes) {
        consumer.localNodeRef(n);
      }
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void assertSyncToken(ModelInputStream is, int token) throws IOException {
    if (is.readInt() != token) {
      throw new IOException("bad stream, no sync token");
    }
  }
}

<code block>

package jetbrains.mps.smodel.persistence.def.v9;

import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.runtime.ConceptKind;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;

import java.util.HashMap;
import java.util.Map;


class IdInfoReadHelper {
  private final IdInfoRegistry myMetaRegistry;
  private final IdEncoder myIdEncoder;
  private final MetaModelInfoProvider myMetaInfoProvider;
  private LangInfo myActualLang;
  private ConceptInfo myActualConcept;
  private final Map<String, SConcept> myConcepts = new HashMap<String, SConcept>();
  private final Map<String, SProperty> myProperties = new HashMap<String, SProperty>();
  private final Map<String, SReferenceLink> myAssociations = new HashMap<String, SReferenceLink>();
  private final Map<String, SContainmentLink> myAggregations = new HashMap<String, SContainmentLink>();
  private final boolean myInterfaceOnly;
  private final boolean myStripImplementation;

  public IdInfoReadHelper(@NotNull MetaModelInfoProvider mmiProvider, boolean interfaceOnly, boolean stripImplementation) {
    myMetaInfoProvider = mmiProvider;
    myIdEncoder = new IdEncoder();
    myMetaRegistry = new IdInfoRegistry();
    myInterfaceOnly = interfaceOnly;
    myStripImplementation = stripImplementation;
  }

  @NotNull
  public IdEncoder getIdEncoder() {
    return myIdEncoder;
  }

  public boolean isRequestedInterfaceOnly() {
    return myInterfaceOnly;
  }

  public boolean isRequestedStripImplementation() {
    return myStripImplementation;
  }

  

  public void withLanguage(String id, String name) {
    final SLanguageId languageId = myIdEncoder.parseLanguageId(id);
    myActualLang = myMetaRegistry.registerLanguage(languageId, name);
    myMetaInfoProvider.setLanguageName(languageId, name);
  }

  
  public void withConcept(String id, String name, String index, String nodeInfo, String stub) {
    assert myActualLang != null;
    SConceptId conceptId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), id);
    myActualConcept = myMetaRegistry.registerConcept(conceptId, name);
    myActualConcept.parseImplementationKind(nodeInfo);
    myConcepts.put(index, MetaAdapterFactory.getConcept(conceptId, name));
    myMetaInfoProvider.setConceptName(conceptId, name);
    myMetaInfoProvider.setKind(conceptId, myActualConcept.getKind());
    myMetaInfoProvider.setScope(conceptId, myActualConcept.getScope());
    if (stub != null) {
      
      final SConceptId stubId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), stub);
      myActualConcept.setStubCounterpart(stubId);
      myMetaInfoProvider.setStubConcept(conceptId, stubId);
    }
  }

  public void property(String id, String name, String index) {
    assert myActualConcept != null;
    SPropertyId propertyId = myIdEncoder.parsePropertyId(myActualConcept.getConceptId(), id);
    myActualConcept.addProperty(propertyId, name);
    myProperties.put(index, MetaAdapterFactory.getProperty(propertyId, name));
    myMetaInfoProvider.setPropertyName(propertyId, name);
  }

  public void association(String id, String name, String index) {
    assert myActualConcept != null;
    SReferenceLinkId linkId = myIdEncoder.parseAssociation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name);
    myAssociations.put(index, MetaAdapterFactory.getReferenceLink(linkId, name));
    myMetaInfoProvider.setAssociationName(linkId, name);
  }

  public void aggregation(String id, String name, String index, boolean unordered) {
    assert myActualConcept != null;
    SContainmentLinkId linkId = myIdEncoder.parseAggregation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name, unordered);
    myAggregations.put(index, MetaAdapterFactory.getContainmentLink(linkId, name));
    myMetaInfoProvider.setAggregationName(linkId, name);
    myMetaInfoProvider.setUnordered(linkId, unordered);
  }

  

  public SConcept readConcept(@NotNull String index) {
    assert myConcepts.containsKey(index);
    return myConcepts.get(index);
  }

  public SProperty readProperty(@NotNull String index) {
    assert myProperties.containsKey(index);
    return myProperties.get(index);
  }

  public SReferenceLink readAssociation(@NotNull String index) {
    assert myAssociations.containsKey(index);
    return myAssociations.get(index);
  }

  
  public SContainmentLink readAggregation(@Nullable String index) {
    if (index == null) {
      return null;
    }
    assert myAggregations.containsKey(index);
    return myAggregations.get(index);
  }

  public boolean isInterface(@NotNull SConcept concept) {
    return ConceptKind.INTERFACE == myMetaRegistry.find(concept).getKind();
  }

  public boolean isImplementation(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementation();
  }
  public boolean isImplementationWithStub(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementationWithStub();
  }

  
  @NotNull
  public SConcept getStubConcept(@NotNull SConcept original) {
    final ConceptInfo ci = myMetaRegistry.find(original);
    assert ci.getKind() == ConceptKind.IMPLEMENTATION_WITH_STUB;
    final SConceptId stub = ci.getStubCounterpart();
    assert stub != null;
    return MetaAdapterFactory.getConcept(stub, ci.constructStubConceptName());
  }

  public SLanguage getLanguage(@NotNull SLanguageId langId, @NotNull String langName, int version) {
    
    
    
    
    return MetaAdapterFactory.getLanguage(langId, langName, version);
  }
}

<code block>
package jetbrains.mps.smodel.persistence.def.v9;



import jetbrains.mps.util.xml.XMLSAXHandler;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import java.util.Stack;
import org.xml.sax.Locator;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.DefaultSModel;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXParseException;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.InterfaceSNode;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.util.Pair;

public class ModelReader9Handler extends XMLSAXHandler<ModelLoadResult> {
  private ModelReader9Handler.ModelElementHandler modelHandler = new ModelReader9Handler.ModelElementHandler();
  private ModelReader9Handler.PersistenceElementHandler persistenceHandler = new ModelReader9Handler.PersistenceElementHandler();
  private ModelReader9Handler.Model_attributeElementHandler model_attributeHandler = new ModelReader9Handler.Model_attributeElementHandler();
  private ModelReader9Handler.RegistryElementHandler registryHandler = new ModelReader9Handler.RegistryElementHandler();
  private ModelReader9Handler.Registry_languageElementHandler registry_languageHandler = new ModelReader9Handler.Registry_languageElementHandler();
  private ModelReader9Handler.Registry_conceptElementHandler registry_conceptHandler = new ModelReader9Handler.Registry_conceptElementHandler();
  private ModelReader9Handler.Registry_propertyElementHandler registry_propertyHandler = new ModelReader9Handler.Registry_propertyElementHandler();
  private ModelReader9Handler.Registry_associationElementHandler registry_associationHandler = new ModelReader9Handler.Registry_associationElementHandler();
  private ModelReader9Handler.Registry_aggregationElementHandler registry_aggregationHandler = new ModelReader9Handler.Registry_aggregationElementHandler();
  private ModelReader9Handler.LanguagesElementHandler languagesHandler = new ModelReader9Handler.LanguagesElementHandler();
  private ModelReader9Handler.Used_languageElementHandler used_languageHandler = new ModelReader9Handler.Used_languageElementHandler();
  private ModelReader9Handler.Module_referenceElementHandler module_referenceHandler = new ModelReader9Handler.Module_referenceElementHandler();
  private ModelReader9Handler.ImportsElementHandler importsHandler = new ModelReader9Handler.ImportsElementHandler();
  private ModelReader9Handler.Model_importElementHandler model_importHandler = new ModelReader9Handler.Model_importElementHandler();
  private ModelReader9Handler.NodeElementHandler nodeHandler = new ModelReader9Handler.NodeElementHandler();
  private ModelReader9Handler.PropertyElementHandler propertyHandler = new ModelReader9Handler.PropertyElementHandler();
  private ModelReader9Handler.ReferenceElementHandler referenceHandler = new ModelReader9Handler.ReferenceElementHandler();
  private ModelReader9Handler.IgnoredNodeElementHandler ignoredNodeHandler = new ModelReader9Handler.IgnoredNodeElementHandler();
  private ModelReader9Handler.IgnoredPropertyElementHandler ignoredPropertyHandler = new ModelReader9Handler.IgnoredPropertyElementHandler();
  private ModelReader9Handler.IgnoredReferenceElementHandler ignoredReferenceHandler = new ModelReader9Handler.IgnoredReferenceElementHandler();
  private Stack<ModelReader9Handler.ElementHandler> myHandlersStack = new Stack<ModelReader9Handler.ElementHandler>();
  private Stack<ModelReader9Handler.ChildHandler> myChildHandlersStack = new Stack<ModelReader9Handler.ChildHandler>();
  private Stack<Object> myValues = new Stack<Object>();
  private Locator myLocator;
  private ModelLoadResult myResult;
  private SModelHeader my_headerParam;
  private IdInfoReadHelper my_readHelperParam;
  private DefaultSModel my_modelField;
  private ImportsHelper my_importHelperField;
  private IdEncoder my_idEncoderField;
  public ModelReader9Handler(SModelHeader header, IdInfoReadHelper readHelper) {
    my_headerParam = header;
    my_readHelperParam = readHelper;
  }
  public ModelLoadResult getResult() {
    return myResult;
  }
  @Override
  public void setDocumentLocator(Locator locator) {
    myLocator = locator;
  }
  @Override
  public void characters(char[] array, int start, int len) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current != null) {
      current.handleText(myValues.peek(), new String(array, start, len));
    }
  }
  @Override
  public void endElement(String uri, String localName, String qName) throws SAXException {
    ModelReader9Handler.ElementHandler current = myHandlersStack.pop();
    Object childValue = myValues.pop();
    current.validate(childValue);
    if (myChildHandlersStack.empty()) {
      myResult = (ModelLoadResult) childValue;
    } else {
      ModelReader9Handler.ChildHandler ch = myChildHandlersStack.pop();
      if (ch != null) {
        ch.apply(myValues.peek(), childValue);
      }
    }
  }
  @Override
  public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current == null) {
      
      current = modelHandler;
    } else {
      current = current.createChild(myValues.peek(), qName, attributes);
    }

    
    for (String attr : current.requiredAttributes()) {
      if (attributes.getValue(attr) == null) {
        throw new SAXParseException("attribute " + attr + " is absent", null);
      }
    }

    Object result = current.createObject(attributes);
    if (myHandlersStack.empty()) {
      myResult = (ModelLoadResult) result;
    }

    
    for (int i = 0; i < attributes.getLength(); i++) {
      String name = attributes.getQName(i);
      String value = attributes.getValue(i);
      current.handleAttribute(result, name, value);
    }
    myHandlersStack.push(current);
    myValues.push(result);
  }
  private static interface ChildHandler {
    public void apply(Object resultObject, Object value) throws SAXException;
  }
  private class ElementHandler {
    private String[] requiredAttributes = new String[0];

    private ElementHandler() {
    }
    protected Object createObject(Attributes attrs) throws SAXException {
      return null;
    }
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
    }
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      throw new SAXParseException("unknown tag: " + tagName, null);
    }
    protected void handleText(Object resultObject, String value) throws SAXException {
      if (value.trim().length() == 0) {
        return;
      }
      throw new SAXParseException("text is not accepted: '" + value + "'", null);
    }
    protected String[] requiredAttributes() {
      return requiredAttributes;
    }
    protected void setRequiredAttributes(String... required) {
      requiredAttributes = required;
    }
    protected void validate(Object resultObject) throws SAXException {
    }
  }
  public class ModelElementHandler extends ModelReader9Handler.ElementHandler {
    public ModelElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected ModelLoadResult createObject(Attributes attrs) throws SAXException {
      my_idEncoderField = my_readHelperParam.getIdEncoder();
      SModelReference ref = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_modelField = new DefaultSModel(ref, my_headerParam);
      my_modelField.getSModelHeader().setPersistenceVersion(9);
      my_importHelperField = new ImportsHelper(ref);
      ModelLoadResult result = new ModelLoadResult((SModel) my_modelField, ModelLoadingState.NOT_LOADED);
      result.setState((my_readHelperParam.isRequestedInterfaceOnly() ? ModelLoadingState.INTERFACE_LOADED : ((my_readHelperParam.isRequestedStripImplementation() ? ModelLoadingState.NO_IMPLEMENTATION : ModelLoadingState.FULLY_LOADED))));
      return result;
    }
    @Override
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
      ModelLoadResult result = (ModelLoadResult) resultObject;
      if ("doNotGenerate".equals(name)) {
        my_modelField.getSModelHeader().setDoNotGenerate(Boolean.parseBoolean(value));
        return;
      }
      if ("content".equals(name)) {
        if ("header".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_HEADER);
        } else if ("root".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_ROOT);
        } else {
          throw new SAXException("unknown content attribute value: " + value);
        }
        return;
      }
      super.handleAttribute(resultObject, name, value);
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("node".equals(tagName) && checknode_8237920533349931304(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931271(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931307(resultObject, value);
          }
        });
        return nodeHandler;
      }
      if ("persistence".equals(tagName)) {
        myChildHandlersStack.push(null);
        return persistenceHandler;
      }
      if ("attribute".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_attributeHandler;
      }
      if ("languages".equals(tagName)) {
        myChildHandlersStack.push(null);
        return languagesHandler;
      }
      if ("imports".equals(tagName)) {
        myChildHandlersStack.push(null);
        return importsHandler;
      }
      if ("registry".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registryHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533349931304(Object resultObject, Attributes attrs) {
      return my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    private void handleChild_8237920533349931271(Object resultObject, Object value) throws SAXException {
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SConcept concept = child._1();
      if (my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        my_modelField.addRootNode(new SNode(stubConcept));
      }
    }
    private void handleChild_8237920533349931307(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      my_modelField.addRootNode(child._0());
    }
  }
  public class PersistenceElementHandler extends ModelReader9Handler.ElementHandler {
    public PersistenceElementHandler() {
    }
  }
  public class Model_attributeElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_attributeElementHandler() {
      setRequiredAttributes("name", "value");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_modelField.getSModelHeader().setOptionalProperty(attrs.getValue("name"), attrs.getValue("value"));
      return null;
    }
  }
  public class RegistryElementHandler extends ModelReader9Handler.ElementHandler {
    public RegistryElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("language".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_languageHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_languageElementHandler() {
      setRequiredAttributes("id", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withLanguage(attrs.getValue("id"), attrs.getValue("name"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("concept".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_conceptHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_conceptElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_conceptElementHandler() {
      setRequiredAttributes("id", "name", "index", "flags");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withConcept(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), attrs.getValue("flags"), attrs.getValue("stub"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_propertyHandler;
      }
      if ("reference".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_associationHandler;
      }
      if ("child".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_aggregationHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_propertyElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_propertyElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.property(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_associationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_associationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.association(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_aggregationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_aggregationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.aggregation(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), Boolean.parseBoolean(attrs.getValue("unordered")));
      return null;
    }
  }
  public class LanguagesElementHandler extends ModelReader9Handler.ElementHandler {
    public LanguagesElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("use".equals(tagName)) {
        myChildHandlersStack.push(null);
        return used_languageHandler;
      }
      if ("generationPart".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804036(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      if ("devkit".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804044(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private void handleChild_5480414999147804036(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addEngagedOnGenerationLanguage(child);
    }
    private void handleChild_5480414999147804044(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addDevKit(child);
    }
  }
  public class Used_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Used_languageElementHandler() {
      setRequiredAttributes("id", "version", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SLanguageId langId = my_idEncoderField.parseLanguageId(attrs.getValue("id"));
      int langVersion = Integer.parseInt(attrs.getValue("version"));
      my_modelField.addLanguage(my_readHelperParam.getLanguage(langId, attrs.getValue("name"), langVersion));
      return null;
    }
  }
  public class Module_referenceElementHandler extends ModelReader9Handler.ElementHandler {
    public Module_referenceElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected SModuleReference createObject(Attributes attrs) throws SAXException {
      return my_idEncoderField.parseModuleReference(attrs.getValue("ref"));
    }
  }
  public class ImportsElementHandler extends ModelReader9Handler.ElementHandler {
    public ImportsElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("import".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_importHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Model_importElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_importElementHandler() {
      setRequiredAttributes("index", "ref");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SModelReference modelRef = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_importHelperField.addModelImport(attrs.getValue("index"), modelRef);
      if (!(Boolean.parseBoolean(attrs.getValue("implicit")))) {
        my_modelField.addModelImport(new SModel.ImportElement(modelRef));
      }
      return null;
    }
  }
  public class NodeElementHandler extends ModelReader9Handler.ElementHandler {
    public NodeElementHandler() {
      setRequiredAttributes("concept", "id");
    }
    @Override
    protected Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> createObject(Attributes attrs) throws SAXException {
      SConcept concept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      boolean interfaceNode = false;
      if (my_readHelperParam.isRequestedInterfaceOnly()) {
        interfaceNode = (my_readHelperParam.isInterface(concept) || attrs.getValue("role") == null);
      }
      SNodeId nodeId;
      try {
        nodeId = my_idEncoderField.parseNodeId(attrs.getValue("id"));
      } catch (IdEncoder.EncodingException e) {
        throw new IllegalArgumentException(e);
      }
      SNode result = (interfaceNode ? new InterfaceSNode(concept, nodeId) : new SNode(concept, nodeId));
      
      return MultiTuple.<org.jetbrains.mps.openapi.model.SNode,SContainmentLink>from(((org.jetbrains.mps.openapi.model.SNode) result), my_readHelperParam.readAggregation(attrs.getValue("role")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804176(resultObject, value);
          }
        });
        return propertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_4968492044127349726(resultObject, value);
          }
        });
        return referenceHandler;
      }
      if ("node".equals(tagName) && checknode_8237920533350080210(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804300(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804248(resultObject, value);
          }
        });
        return nodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533350080210(Object resultObject, Attributes attrs) {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      SConcept childConcept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(childConcept)) {
        return true;
      }
      return result._0() instanceof InterfaceSNode && !(my_readHelperParam.isInterface(childConcept));
    }
    private void handleChild_5480414999147804176(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SProperty, String> child = (Tuples._2<SProperty, String>) value;
      result._0().setProperty(child._0(), child._1());
    }
    private void handleChild_4968492044127349726(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._4<SReferenceLink, SModelReference, SNodeId, String> child = (Tuples._4<SReferenceLink, SModelReference, SNodeId, String>) value;
      SModelReference targetModel = child._1();
      SNodeId nodeId = child._2();
      SReferenceLink link = child._0();
      String resolveInfo = child._3();
      StaticReference ref = new StaticReference(link, result._0(), targetModel, nodeId, resolveInfo);
      result._0().setReference(link, ref);
    }
    private void handleChild_5480414999147804300(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SContainmentLink link = child._0();
      SConcept concept = child._1();
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        SNode childNode = new SNode(stubConcept);
        result._0().addChild(link, childNode);
        return;
      }
      if (result._0() instanceof InterfaceSNode) {
        ((InterfaceSNode) result._0()).skipRole(link);
      }
    }
    private void handleChild_5480414999147804248(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      result._0().addChild(child._1(), child._0());
    }
  }
  public class PropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public PropertyElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._2<SProperty, String> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SProperty,String>from(my_readHelperParam.readProperty(attrs.getValue("role")), attrs.getValue("value"));
    }
  }
  public class ReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public ReferenceElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._4<SReferenceLink, SModelReference, SNodeId, String> createObject(Attributes attrs) throws SAXException {
      SReferenceLink association = my_readHelperParam.readAssociation(attrs.getValue("role"));
      if (attrs.getValue("node") != null) {
        
        SNodeId targetNode = my_idEncoderField.parseLocalNodeReference(attrs.getValue("node"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, my_modelField.getReference(), targetNode, attrs.getValue("resolve"));
      } else {
        Pair<SModelReference, SNodeId> r = my_idEncoderField.parseExternalNodeReference(my_importHelperField, attrs.getValue("to"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, r.o1, r.o2, attrs.getValue("resolve"));
      }
    }
  }
  public class IgnoredNodeElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredNodeElementHandler() {
      setRequiredAttributes("concept");
    }
    @Override
    protected Tuples._2<SContainmentLink, SConcept> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SContainmentLink,SConcept>from(my_readHelperParam.readAggregation(attrs.getValue("role")), my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredPropertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredReferenceHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredNodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class IgnoredPropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredPropertyElementHandler() {
    }
  }
  public class IgnoredReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredReferenceElementHandler() {
    }
  }
}

<code block>

package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.ModelWithDisposeInfo;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.event.SModelListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.Map;

public interface SModelInternal extends ModelWithDisposeInfo  {

  void addModelListener(@NotNull SModelListener listener);

  void removeModelListener(@NotNull SModelListener listener);

  ModelDependenciesManager getModelDepsManager();

  @Deprecated
  List<SModuleReference> importedLanguages();

  @Deprecated
  void deleteLanguage(@NotNull SModuleReference ref);

  @Deprecated
  void addLanguage(SModuleReference ref);

  
  java.util.Collection<SLanguage> importedLanguageIds();

  
  void deleteLanguageId(@NotNull SLanguage ref);

  void addLanguage(Language language);

  void addLanguage(@NotNull SLanguage language);

  
  @Deprecated
  void addLanguageId(SLanguage ref, int version);

  List<SModuleReference> importedDevkits();

  void addDevKit(SModuleReference ref);

  void deleteDevKit(@NotNull SModuleReference ref);

  List<ImportElement> importedModels();

  void addModelImport(SModelReference modelReference, boolean firstVersion);

  void addModelImport(ImportElement importElement);

  void deleteModelImport(SModelReference modelReference);

  
  void calculateImplicitImports();

  List<SModuleReference> engagedOnGenerationLanguages();

  void addEngagedOnGenerationLanguage(SModuleReference ref);

  void removeEngagedOnGenerationLanguage(SModuleReference ref);

  List<ImportElement> getAdditionalModelVersions();

  boolean updateSModelReferences();

  void changeModelReference(SModelReference newModelReference);

  boolean updateModuleReferences();
}

<code block>

package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.nodeidmap.INodeIdToNodeMap;
import jetbrains.mps.smodel.nodeidmap.UniversalOptimizedNodeIdMap;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

public class SModel implements SModelData {
  private static final Logger LOG = LogManager.getLogger(SModel.class);
  private static AtomicLong ourCounter = new AtomicLong();

  static {
    resetIdCounter();
  }

  protected SModelBase myModelDescriptor;
  private Set<SNode> myRoots = new LinkedHashSet<SNode>();
  private SModelReference myReference;
  private boolean myDisposed;
  private List<SModuleReference> myLanguagesEngagedOnGeneration = new ArrayList<SModuleReference>();
  private Map<SLanguage, Integer> myLanguagesIds = new LinkedHashMap<SLanguage, Integer>();
  private List<SModuleReference> myDevKits = new ArrayList<SModuleReference>();
  private List<ImportElement> myImports = new ArrayList<ImportElement>();
  private INodeIdToNodeMap myIdToNodeMap;
  private StackTraceElement[] myDisposedStacktrace = null;
  private ModelDependenciesManager myModelDependenciesManager;
  private ImplicitImportsLegacyHolder myLegacyImplicitImports;
  
  private boolean myIsFullLoadMode = false;
  
  @NotNull
  private final AttachedNodeOwner myNodeOwner;

  public SModel(@NotNull SModelReference modelReference) {
    this(modelReference, new UniversalOptimizedNodeIdMap());
  }

  public SModel(@NotNull SModelReference modelReference, INodeIdToNodeMap map) {
    myReference = modelReference;
    myIdToNodeMap = map;
    myNodeOwner = new AttachedNodeOwner(this);
  }

  static void resetIdCounter() {
    ourCounter.set(Math.abs(new SecureRandom().nextLong()));
  }

  public static SNodeId generateUniqueId() {
    long id = Math.abs(ourCounter.incrementAndGet());
    return new jetbrains.mps.smodel.SNodeId.Regular(id);
  }


  public SModelId getModelId() {
    return myReference.getModelId();
  }

  @NotNull
  public SModelReference getReference() {
    return myReference;
  }

  @Override
  public Iterable<org.jetbrains.mps.openapi.model.SNode> getRootNodes() {
    fireModelNodesReadAccess();
    return new Iterable<org.jetbrains.mps.openapi.model.SNode>() {
      @Override
      public Iterator<org.jetbrains.mps.openapi.model.SNode> iterator() {
        return new Iterator<org.jetbrains.mps.openapi.model.SNode>() {
          private final Iterator<SNode> myIterator = myRoots.iterator();

          @Override
          public boolean hasNext() {
            return myIterator.hasNext();
          }

          @Override
          public org.jetbrains.mps.openapi.model.SNode next() {
            SNode res = myIterator.next();
            if (res != null) {
              res.assertCanRead();
              res.getNodeOwner().fireNodeRead(res, true);
            }

            return res;
          }

          @Override
          public void remove() {
            throw new UnsupportedOperationException("can't change model roots through roots iterator");
          }
        };
      }
    };
  }

  public boolean isRoot(@Nullable org.jetbrains.mps.openapi.model.SNode node) {
    return myRoots.contains(node);
  }

  

  @Override
  public void addRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      
      return;
    }
    org.jetbrains.mps.openapi.model.SModel model = node.getModel();
    
    if (model != null && model != myModelDescriptor && node.getParent() == null) {
      model.removeRootNode(node);
    } else {
      org.jetbrains.mps.openapi.model.SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      }
    }

    SNode sn = (SNode) node;
    myRoots.add(sn);
    sn.attach(myNodeOwner);
    performUndoableAction(new AddRootUndoableAction(node));
    myNodeOwner.fireNodeAdd(null, null, sn, null);
  }

  @Override
  public void removeRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeUnRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      myNodeOwner.fireBeforeNodeRemove(null, null, (SNode) node, null);
      myRoots.remove(node);
      SNode sn = (SNode) node;
      sn.detach(new DetachedNodeOwner(this));
      performUndoableAction(new RemoveRootUndoableAction(node, myModelDescriptor));
      myNodeOwner.fireNodeRemove(null, null, sn, null);
    }
  }

  @Override
  @Nullable
  public SNode getNode(@NotNull org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    SNode res = getNode_(nodeId);
    if (res != null) {
      res.assertCanRead();
      myNodeOwner.fireNodeRead(res, true);
    }
    return res;
  }

  private SNode getNode_(org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    checkNotDisposed();
    if (myDisposed) return null;

    org.jetbrains.mps.openapi.model.SNode node = myIdToNodeMap.get(nodeId);
    if (node != null) return ((SNode) node);
    enforceFullLoad();
    return ((SNode) myIdToNodeMap.get(nodeId));
  }

  @NotNull
  public String toString() {
    return myReference.toString();
  }

  
  public boolean isDisposed() {
    return myDisposed;
  }

  
  public StackTraceElement[] getDisposedStacktrace() {
    return myDisposedStacktrace;
  }

  @Deprecated
  public void addModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().addModelListener(listener);
  }

  @Deprecated
  public void removeModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().removeModelListener(listener);
  }

  
  public SModelBase getModelDescriptor() {
    return myModelDescriptor;
  }

  
  public synchronized void setModelDescriptor(org.jetbrains.mps.openapi.model.SModel modelDescriptor) {
    if (myModelDescriptor == modelDescriptor) {
      
      return;
    }
    myModelDescriptor = ((SModelBase) modelDescriptor);
    myNodeOwner.setEventDispatch(modelDescriptor == null ? null : myModelDescriptor.getEventDispatch());
  }

  protected void enforceFullLoad() {
    org.jetbrains.mps.openapi.model.SModel md = myModelDescriptor;
    if (md != null) {
      md.load();
    }
  }

  private void fireModelNodesReadAccess() {
    if (!canFireReadEvent()) return;
    if (myModelDescriptor != null) {
      NodeReadEventsCaster.fireModelNodesReadAccess(myModelDescriptor);
    }
  }



  
  @Deprecated
  @ToRemove(version = 3.3)
  protected void performUndoableAction(Computable<SNodeUndoableAction> action) {
    if (!canFireEvent()) return;
    if (!UndoHelper.getInstance().needRegisterUndo()) return;
    performUndoableAction(action.compute());
  }

  protected void performUndoableAction(@NotNull SNodeUndoableAction action) {
    if (!canFireEvent()) {
      return;
    }
    final UndoHelper uh = UndoHelper.getInstance();
    if (uh.needRegisterUndo()) {
      uh.addUndoableAction(action);
    }
  }

    

  public boolean canFireEvent() {
    return myModelDescriptor != null && jetbrains.mps.util.SNodeOperations.isRegistered(myModelDescriptor) && !isUpdateMode();
  }

  public boolean canFireReadEvent() {
    return canFireEvent();
  }

  public void dispose() {
    assertLegalChange();
    if (myDisposed) return;

    myDisposed = true;
    myDisposedStacktrace = new Throwable().getStackTrace();
    myIdToNodeMap = null;
    myRoots.clear();
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.dispose();
      myModelDependenciesManager = null;
    }
  }

  private void checkNotDisposed() {
    if (!myDisposed) return;
    LOG.error(new IllegalModelAccessError("accessing disposed model"));
  }

  private List<SModelListener> getModelListeners() {
    if (myModelDescriptor == null) return Collections.emptyList();
    return ((SModelBase) myModelDescriptor).getModelListeners();
  }

  private void fireDevKitAddedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireDevKitRemovedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageAddedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageRemovedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportAddedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportRemovedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireRootAddedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireRootRemovedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

   void fireBeforeRootRemovedEvent(org.jetbrains.mps.openapi.model.SNode node) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), node, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeRootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void firePropertyChangedEvent(@NotNull SNode node, @NotNull SProperty property, @Nullable String oldValue, @Nullable String newValue) {
    if (!canFireEvent()) {
      return;
    }
    final SModelPropertyEvent event = new SModelPropertyEvent(getModelDescriptor(), property, node, oldValue, newValue);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.propertyChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildAddedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), true, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireBeforeChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeChildRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceAddedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceRemovedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  public FastNodeFinder createFastNodeFinder() {
    return new DefaultFastNodeFinder(getModelDescriptor());
  }

  

  void registerNode(@NotNull SNode node) {
    checkNotDisposed();
    if (myDisposed) return;

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (id == null) {
      assignNewId(node);
      return;
    }

    org.jetbrains.mps.openapi.model.SNode existingNode = myIdToNodeMap.get(id);
    if (existingNode == null) {
      myIdToNodeMap.put(node.getNodeId(), node);
    }

    if (existingNode != null && existingNode != node) {
      assignNewId(node);
    }
  }

  private void assignNewId(SNode node) {
    SNodeId id;
    id = generateUniqueId();
    while (myIdToNodeMap.containsKey(id)) {
      resetIdCounter();
      id = generateUniqueId();
    }
    node.setId(id);
    myIdToNodeMap.put(id, node);
  }

  

  void unregisterNode(@NotNull SNode node) {
    checkNotDisposed();

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (myDisposed || id == null) return;
    myIdToNodeMap.remove(id);
  }

  public ModelDependenciesManager getModelDepsManager() {
    if (myModelDependenciesManager == null) {
      myModelDependenciesManager = new ModelDependenciesManager(getModelDescriptor());
      
      SRepository repo = getRepository();
      if (repo != null) {
        myModelDependenciesManager.trackRepositoryChanges(repo);
      }
    }
    return myModelDependenciesManager;
  }

  private void invalidateModelDepsManager() {
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.invalidate();
    }
  }

  

  public Collection<SLanguage> usedLanguages() {
    return Collections.unmodifiableSet(myLanguagesIds.keySet());
  }

  public Map<SLanguage, Integer> usedLanguagesWithVersions() {
    return Collections.unmodifiableMap(myLanguagesIds);
  }

  public void deleteLanguage(@NotNull SLanguage id) {
    assertLegalChange();
    if (myLanguagesIds.remove(id) != null) {
      invalidateModelDepsManager();
      fireLanguageRemovedEvent(id);
      markChanged();
    }
  }

  public void addLanguage(@NotNull SLanguage language) {
    addLanguage(language, language.getLanguageVersion());
  }

  
  @Deprecated
  public void addLanguage(SLanguage id, int version) {
    assertLegalChange();

    Integer existingVersion = myLanguagesIds.get(id);
    if (existingVersion != null) {
      if (version == -1 || existingVersion == version) {
        return;
      }
      if (existingVersion == -1) {
        myLanguagesIds.remove(id);
      } else {
        throw new IllegalStateException("Can't add language import with different version. Old version: " + existingVersion + "; new version: " + version);
      }
    }

    myLanguagesIds.put(id, version);
    invalidateModelDepsManager();
    fireLanguageAddedEvent(id);
    markChanged();
  }

  

  public List<SModuleReference> importedDevkits() {
    return Collections.unmodifiableList(myDevKits);
  }

  public void addDevKit(SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.add(ref)) {
      invalidateModelDepsManager();
      fireDevKitAddedEvent(ref);
      markChanged();
    }
  }

  public void deleteDevKit(@NotNull SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.remove(ref)) {
      invalidateModelDepsManager();
      fireDevKitRemovedEvent(ref);
      markChanged();
    }
  }

  

  public List<ImportElement> importedModels() {
    return Collections.unmodifiableList(myImports);
  }

  public void addModelImport(ImportElement importElement) {
    assertLegalChange();

    myImports.add(importElement);
    fireImportAddedEvent(importElement.getModelReference());
    markChanged();
  }

  public void deleteModelImport(SModelReference modelReference) {
    assertLegalChange();

    ImportElement importElement = SModelOperations.getImportElement(this, modelReference);
    if (importElement != null) {
      myImports.remove(importElement);
      if (myLegacyImplicitImports != null) {
        
        myLegacyImplicitImports.addAdditionalModelVersion(importElement);  
      }
      fireImportRemovedEvent(modelReference);
      markChanged();
    }
  }

  
  @NotNull
  public ImplicitImportsLegacyHolder getImplicitImportsSupport() {
    if (myLegacyImplicitImports == null) {
      myLegacyImplicitImports = new ImplicitImportsLegacyHolder(this);
    }
    return myLegacyImplicitImports;
  }
  
  
  Iterable<org.jetbrains.mps.openapi.model.SNode> allNodes() {
    return myIdToNodeMap.values();
  }

  
  
  @ToRemove(version = 3.2)
  List<ImportElement> getAllImportElements() {
    List<ImportElement> result = new ArrayList<ImportElement>();
    result.addAll(myImports);
    if (myLegacyImplicitImports != null) {
      result.addAll(myLegacyImplicitImports.getAdditionalModelVersions());
    }
    return result;
  }

  public List<SModuleReference> engagedOnGenerationLanguages() {
    return myLanguagesEngagedOnGeneration;
  }

  private void markChanged() {
    if (myModelDescriptor == null) return;
    org.jetbrains.mps.openapi.model.SModel model = getModelDescriptor();
    if (model instanceof EditableSModel) {
      ((EditableSModel) model).setChanged(true);
    }
  }

  public void addEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (!myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.add(ref);
      
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  public void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.remove(ref);
      
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  

  public boolean isUpdateMode() {
    return myIsFullLoadMode;
  }

  public void setUpdateMode(boolean value) {
    
    this.myIsFullLoadMode = value;
  }

  
  protected SRepository getRepository() {
    return myModelDescriptor == null ? null : myModelDescriptor.getRepository();
  }

  private void assertLegalChange() {
    if (myModelDescriptor != null) {
      
      
      ModelChange.assertLegalChange_new(myModelDescriptor);
    }
  }

  

  public boolean updateSModelReferences() {
    assertLegalChange();
    enforceFullLoad();

    boolean changed = false;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        SModelReference oldReference = reference.getTargetSModelReference();
        if (oldReference == null) continue;
        jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) oldReference;
        jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
        if (newRef.differs(oldSRef)) {
          changed = true;
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newRef);
        }
      }
    }

    for (ImportElement e : myImports) {
      jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) e.myModelReference;
      jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
      if (newRef.differs(oldSRef)) {
        changed = true;
        e.myModelReference = newRef;
      }
    }
    if (myLegacyImplicitImports != null) {
      changed |= myLegacyImplicitImports.updateSModelReferences();
    }

    return changed;
  }

  public boolean updateModuleReferences() {
    assertLegalChange();


    boolean changed = false;

    if (updateRefs(myDevKits)) {
      changed = true;
    }
    if (updateRefs(myLanguagesEngagedOnGeneration)) {
      changed = true;
    }

    return changed;
  }

  public void changeModelReference(SModelReference newModelReference) {
    enforceFullLoad();
    SModelReference oldReference = myReference;
    myReference = newModelReference;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        if (oldReference.equals(reference.getTargetSModelReference())) {
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newModelReference);
        }
      }
    }
  }

  public boolean updateRefs(List<SModuleReference> refs) {
    boolean changed = false;
    for (int i = 0; i < refs.size(); i++) {
      SModuleReference ref = refs.get(i);
      SModule module = ModuleRepositoryFacade.getInstance().getModule(ref);
      if (module != null) {
        SModuleReference newRef = module.getModuleReference();
        refs.set(i, newRef);
        changed = changed || ModuleReference.differs(ref, newRef);
      }
    }
    return changed;
  }

  public SModel createEmptyCopy() {
    return new jetbrains.mps.smodel.SModel(getReference());
  }

  public void copyPropertiesTo(SModel to) {
    if (myLegacyImplicitImports != null) {
      for (ImportElement ie : myLegacyImplicitImports.getAdditionalModelVersions()) {
        to.getImplicitImportsSupport().addAdditionalModelVersion(ie.copy());
      }
    }
    for (ImportElement ie : importedModels()) {
      to.addModelImport(ie.copy());
    }
    for (SModuleReference mr : importedDevkits()) {
      to.addDevKit(mr);
    }
    for (SLanguage lang : usedLanguages()) {
      to.addLanguage(lang);
    }
    for (SModuleReference mr : engagedOnGenerationLanguages()) {
      to.addEngagedOnGenerationLanguage(mr);
    }
  }

  public static class ImportElement {
    private SModelReference myModelReference;
    private int myReferenceID;  
    private int myUsedVersion;

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID) {
      this(modelReference, referenceID, -1);
    }

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID, int usedVersion) {
      myModelReference = modelReference;
      myReferenceID = referenceID;
      myUsedVersion = usedVersion;
    }

    public ImportElement(SModelReference modelReference) {
      myModelReference = modelReference;
      myReferenceID = 0;
      myUsedVersion = -1;
    }

    public SModelReference getModelReference() {
      return myModelReference;
    }

    public void setModelReference(SModelReference modelReference) {
      myModelReference = modelReference;
    }

    public int getReferenceID() {
      return myReferenceID;
    }

    public void setReferenceID(int referenceID) {
      myReferenceID = referenceID;
    }

    public int getUsedVersion() {
      return myUsedVersion;
    }

    protected ImportElement copy() {
      return new ImportElement(myModelReference, myReferenceID, myUsedVersion);
    }

    public String toString() {
      return "ImportElement(" +
          "uid=" + myModelReference + ", " +
          "referenceId=" + myReferenceID + ", " +
          "usedVersion=" + myUsedVersion + ")";
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      ImportElement that = (ImportElement) o;

      if (myReferenceID != that.myReferenceID) return false;
      if (myUsedVersion != that.myUsedVersion) return false;
      if (myModelReference != null ? !myModelReference.equals(that.myModelReference) : that.myModelReference != null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      int result = myModelReference != null ? myModelReference.hashCode() : 0;
      result = 31 * result + myReferenceID;
      result = 31 * result + myUsedVersion;
      return result;
    }
  }

}

<code block>

package jetbrains.mps.smodel.language;

import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.classloading.MPSClassesListener;
import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import static java.lang.String.format;


public class LanguageRegistry implements CoreComponent, MPSClassesListener {
  private static final Logger LOG = LogManager.getLogger(LanguageRegistry.class);

  private static LanguageRegistry INSTANCE;

  public static LanguageRegistry getInstance() {
    return INSTANCE;
  }

  private Map<String, LanguageRuntime> myLanguages = new HashMap<String, LanguageRuntime>();
  private Map<SLanguageId, LanguageRuntime> myLanguagesById = new HashMap<SLanguageId, LanguageRuntime>();

  private final List<LanguageRegistryListener> myLanguageListeners = new CopyOnWriteArrayList<LanguageRegistryListener>();

  private final SRepository myRepository;
  private final ClassLoaderManager myClassLoaderManager;

  public LanguageRegistry(SRepository repository, ClassLoaderManager loaderManager) {
    myRepository = repository;
    myClassLoaderManager = loaderManager;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myClassLoaderManager.addClassesHandler(this);
  }

  @Override
  public void dispose() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        notifyUnload(myLanguages.values());
        myLanguages.clear();
        myLanguagesById.clear();
      }
    });
    myClassLoaderManager.removeClassesHandler(this);
    INSTANCE = null;
  }

  private void notifyUnload(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.beforeLanguagesUnloaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language unloading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  private void notifyLoad(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.afterLanguagesLoaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language loading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  @Nullable
  private static LanguageRuntime createRuntime(Language l) {
    final String rtClassName = l.getModuleName() + ".Language";
    
    
    
    
    
    
    
    
    
    try {
      final Class<?> rtClass = l.getOwnClass(rtClassName);
      if (rtClass != null && LanguageRuntime.class.isAssignableFrom(rtClass)) {
        return ((Class<LanguageRuntime>) rtClass).newInstance();
      }
      return new InterpretedLanguageRuntime(l);
    } catch (ClassNotFoundException ex) {
      return new InterpretedLanguageRuntime(l);
    } catch (InstantiationException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    } catch (IllegalAccessException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    }
  }

  public String toString() {
    return "LanguageRegistry";
  }

  public void addRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.add(listener);
  }

  public void removeRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.remove(listener);
  }

  
  public Collection<LanguageRuntime> getAvailableLanguages() {
    myRepository.getModelAccess().checkReadAccess();
    return myLanguages.values();
  }

  public Collection<SLanguage> getAllLanguages() {
    final Collection<LanguageRuntime> languages = getAvailableLanguages();
    ArrayList<SLanguage> rv = new ArrayList<SLanguage>(languages.size());
    for (LanguageRuntime lr : languages) {
      rv.add(MetaAdapterFactory.getLanguage(lr.getId(), lr.getNamespace(), lr.getVersion()));
    }
    return rv;
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguage language) {
    return ((SLanguageAdapter) language).getLanguageDescriptor();
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguageId id) {
    return myLanguagesById.get(id);
  }

  @Nullable
  public LanguageRuntime getLanguage(String namespace) {
    return myLanguages.get(namespace);
  }

  public LanguageRuntime getLanguage(Language language) {
    return getLanguage(language.getModuleName());
  }

  
  public GeneratorRuntime getGenerator(Generator generator) {
    LanguageRuntime lr = getLanguage(generator.getSourceLanguage());
    if (lr == null) {
      return null;
    }
    for (GeneratorRuntime grt : lr.getGenerators()) {
      if (grt.getModuleReference().equals(generator.getModuleReference())) {
        return grt;
      }
    }
    return null;
  }

  
  @Override
  public void beforeClassesUnloaded(Set<? extends ReloadableModuleBase> unloadedModules) {
    Set<LanguageRuntime> languagesToUnload = new HashSet<LanguageRuntime>();
    for (SLanguageId languageId : collectLanguagesToUnload(unloadedModules)) {
      if (!myLanguagesById.containsKey(languageId)) {
        LOG.warn("No language with id " + languageId + " to unload");
      } else {
        languagesToUnload.add(myLanguagesById.get(languageId));
      }
    }

    notifyUnload(languagesToUnload);

    for (LanguageRuntime languageRuntime : languagesToUnload) {
      myLanguages.remove(languageRuntime.getNamespace());
      myLanguagesById.remove(languageRuntime.getId());
    }
    reinitialize();
  }

  @Override
  public void afterClassesLoaded(Set<? extends ReloadableModuleBase> loadedModules) {
    Set<LanguageRuntime> loadedRuntimes = new HashSet<LanguageRuntime>();
    for (Language language : collectLanguagesToLoad(loadedModules)) {
      SLanguageId languageId = MetaIdByDeclaration.getLanguageId(language);
      if (myLanguagesById.containsKey(languageId)) {
        LOG.error("", new IllegalArgumentException(String.format("There is already a language '%s' with id '%s'", myLanguagesById.get(languageId), languageId)));
        continue;
      }
      try {
        LanguageRuntime langRuntime = createRuntime(language);
        if (langRuntime == null) continue;

        String langName = langRuntime.getNamespace();
        if (myLanguages.containsKey(langName)) {
          LOG.warn(String.format("There is already a language '%s' with a name '%s'", myLanguages.get(langName), langName));
        }
        myLanguages.put(langName, langRuntime);
        myLanguagesById.put(languageId, langRuntime);
        loadedRuntimes.add(langRuntime);
      } catch (LinkageError le) {
        processLinkageErrorForLanguage(language, le);
      }
    }
    reinitialize();
    notifyLoad(loadedRuntimes);
  }

  private Iterable<SLanguageId> collectLanguagesToUnload(Set<? extends SModule> unloadedModules) {
    Collection<SLanguageId> languagesToUnload = new ArrayList<SLanguageId>();
    for (SModule unloadedModule : unloadedModules) {
      if (unloadedModule instanceof Language) {
        languagesToUnload.add(MetaIdByDeclaration.getLanguageId((Language) unloadedModule));
      }
    }
    return languagesToUnload;
  }

  private Iterable<Language> collectLanguagesToLoad(Set<? extends SModule> loadedModules) {
    Collection<Language> languagesToLoad = new ArrayList<Language>();
    for (SModule loadedModule : loadedModules) {
      if (loadedModule instanceof Language) {
        languagesToLoad.add((Language) loadedModule);
      }
    }

    return languagesToLoad;
  }

  private void reinitialize() {
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.deinitialize();
    }
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.initialize(this);
    }
  }

  private static void processLinkageErrorForLanguage(Language language, LinkageError linkageError) {
    LOG.error("Caught a linkage error while creating LanguageRuntime for the `" + language + "` language." +
        "Probably the language sources/classes are outdated, try rebuilding the project.", linkageError);
    LOG.warn("MPS will attempt running in a inconsistent state.");
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterById;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterById;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterById;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.util.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.annotations.Immutable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public abstract class MetaAdapterFactory {
  private static final ConcurrentMap<LangKey, SLanguage> ourLanguageIds = new ConcurrentHashMap<LangKey, SLanguage>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SConcept> ourConceptIds = new ConcurrentHashMap<Pair<SConceptId, String>, SConcept>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SInterfaceConcept> ourIntfcConceptIds =
      new ConcurrentHashMap<Pair<SConceptId, String>, SInterfaceConcept>();
  private static final ConcurrentMap<Pair<SPropertyId, String>, SProperty> ourPropertyIds = new ConcurrentHashMap<Pair<SPropertyId, String>, SProperty>();
  private static final ConcurrentMap<Pair<SReferenceLinkId, String>, SReferenceLink> ourRefIds =
      new ConcurrentHashMap<Pair<SReferenceLinkId, String>, SReferenceLink>();
  private static final ConcurrentMap<Pair<SContainmentLinkId, String>, SContainmentLink> ourLinkIds =
      new ConcurrentHashMap<Pair<SContainmentLinkId, String>, SContainmentLink>();

  @NotNull
  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName) {
    return getLanguage(id, langName, -1);
  }

  @NotNull
  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName, int version) {
    SLanguageAdapterById l = new SLanguageAdapterById(id, langName, version);
    LangKey p = new LangKey(id, langName, version);
    ourLanguageIds.putIfAbsent(p, l);
    return ourLanguageIds.get(p);
  }

  public static SLanguage getLanguage(@NotNull SLanguage original, int anotherVersion) {
    if (original.getLanguageVersion() == anotherVersion) {
      return original;
    }
    SLanguageId langId = null;
    if (original instanceof SLanguageAdapterById) {
      langId = ((SLanguageAdapterById) original).getId();
    } else if (original instanceof SLanguageAdapter) {
      final LanguageRuntime rt = ((SLanguageAdapter) original).getLanguageDescriptor();
      langId = rt == null ? null : rt.getId();
    }
    if (langId == null) {
      langId = MetaIdByDeclaration.ref2LangId(original.getSourceModule().getModuleReference());
    }
    return getLanguage(langId, original.getQualifiedName(), anotherVersion);
  }

  @NotNull
  public static SLanguage getLanguage(long uuidHigh, long uuidLow, String langName) {
    return getLanguage(MetaIdFactory.langId(uuidHigh, uuidLow), langName);
  }

  @NotNull
  @Deprecated 
  public static SLanguage getLanguage(UUID lang, String langName) {
    return getLanguage(MetaIdFactory.langId(lang), langName);
  }

  @NotNull
  public static SLanguage getLanguage(@NotNull SModuleReference languageModuleRef) {
    return getLanguage(MetaIdByDeclaration.ref2LangId(languageModuleRef), languageModuleRef.getModuleName());
  }

  @NotNull
  public static SConcept getConcept(SConceptId id, String conceptName) {
    SConceptAdapterById c = new SConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourConceptIds.putIfAbsent(p, c);
    return ourConceptIds.get(p);
  }

  @NotNull
  public static SConcept getConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated 
  public static SConcept getConcept(UUID lang, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(SConceptId id, String conceptName) {
    SInterfaceConceptAdapterById c = new SInterfaceConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourIntfcConceptIds.putIfAbsent(p, c);
    return ourIntfcConceptIds.get(p);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated 
  public static SInterfaceConcept getInterfaceConcept(UUID lang, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SProperty getProperty(SPropertyId id, String propName) {
    SPropertyAdapterById c = new SPropertyAdapterById(id, propName);
    Pair<SPropertyId, String> p = new Pair<SPropertyId, String>(id, propName);
    ourPropertyIds.putIfAbsent(p, c);
    return ourPropertyIds.get(p);
  }

  @NotNull
  public static SProperty getProperty(long uuidHigh, long uuidLow, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(uuidHigh, uuidLow, concept, prop), propName);
  }

  @NotNull
  @Deprecated 
  public static SProperty getProperty(UUID lang, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(lang, concept, prop), propName);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(SReferenceLinkId id, String refName) {
    SReferenceLinkAdapterById c = new SReferenceLinkAdapterById(id, refName);
    Pair<SReferenceLinkId, String> p = new Pair<SReferenceLinkId, String>(id, refName);
    ourRefIds.putIfAbsent(p, c);
    return ourRefIds.get(p);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(long uuidHigh, long uuidLow, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(uuidHigh, uuidLow, concept, ref), refName);
  }

  @NotNull
  @Deprecated 
  public static SReferenceLink getReferenceLink(UUID lang, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(lang, concept, ref), refName);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(SContainmentLinkId id, String linkName) {
    SContainmentLinkAdapterById c = new SContainmentLinkAdapterById(id, linkName);
    Pair<SContainmentLinkId, String> p = new Pair<SContainmentLinkId, String>(id, linkName);
    ourLinkIds.putIfAbsent(p, c);
    return ourLinkIds.get(p);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(long uuidHigh, long uuidLow, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(uuidHigh, uuidLow, concept, link), linkName);
  }

  @NotNull
  @Deprecated 
  public static SContainmentLink getContainmentLink(UUID lang, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(lang, concept, link), linkName);
  }

  @NotNull
  public static SAbstractConcept getAbstractConcept(ConceptDescriptor descriptor) {
    if (descriptor.isInterfaceConcept()) {
      return getInterfaceConcept(descriptor.getId(), descriptor.getConceptFqName());
    } else {
      return getConcept(descriptor.getId(), descriptor.getConceptFqName());
    }
  }

  @Immutable
  private static class LangKey {
    private final SLanguageId myId;
    private final String myName;
    private final int myVersion;

    public LangKey(SLanguageId id, String name, int version) {
      myId = id;
      myName = name;
      myVersion = version;
    }

    @Override
    public int hashCode() {
      return myId.hashCode() * 31 + myName.hashCode() + myVersion;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj instanceof LangKey) {
        LangKey o = (LangKey) obj;
        return myVersion == o.myVersion && myId.equals(o.myId) && myName.equals(o.myName);
      }
      return false;
    }
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterByName;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterByName;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterByName;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterByName;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;


public class MetaAdapterFactoryByName {
  public static SLanguage getLanguage(String langName) {
    return new SLanguageAdapterByName(langName);
  }

  public static SLanguage getLanguage(String langName, int version) {
    return new SLanguageAdapterByName(langName, version);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  
  public static SConcept getConcept(String conceptName) {
    return new SConceptAdapterByName(conceptName);
  }

  public static SInterfaceConcept getInterfaceConcept(String conceptName) {
    return new SInterfaceConceptAdapterByName(conceptName);
  }

  
  public static SProperty getProperty(String conceptName, String propName) {
    return new SPropertyAdapterByName(conceptName, propName);
  }

  
  public static SReferenceLink getReferenceLink(String conceptName, String refName) {
    return new SReferenceLinkAdapterByName(conceptName, refName);
  }

  
  public static SContainmentLink getContainmentLink(String conceptName, String linkName) {
    return new SContainmentLinkAdapterByName(conceptName, linkName);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  
  
  public static SAbstractConcept getTypedConcept_DoNotUse(String conceptName) {
    final ConceptDescriptor cd = ConceptRegistry.getInstance().getConceptDescriptor(conceptName);
    if (cd instanceof IllegalConceptDescriptor) return MetaAdapterFactoryByName.getConcept(conceptName);
    return MetaAdapterFactory.getAbstractConcept(cd);
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterByName extends SLanguageAdapter {
  public SLanguageAdapterByName(@NotNull String language) {
    super(language, -1);
  }
  public SLanguageAdapterByName(@NotNull String language, int version) {
    super(language, version);
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguageFqName);
  }

  @Override
  public SLanguageId getId() {
    LanguageRuntime lr = getLanguageDescriptor();
    if (lr != null) {
      return lr.getId();
    }
    Language l = getSourceModule();
    if (l != null) {
      return MetaIdByDeclaration.getLanguageId(l);
    }
    return MetaIdFactory.INVALID_LANGUAGE_ID;
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ModuleRepositoryFacade.getInstance().getModule(myLanguageFqName, Language.class);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return false;
    return myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterById extends SLanguageAdapter {
  private final SLanguageId myLanguage;

  public SLanguageAdapterById(@NotNull SLanguageId language, @NotNull String fqName) {
    this(language, fqName, -1);
  }
  public SLanguageAdapterById(@NotNull SLanguageId language, @NotNull String fqName, int version) {
    super(fqName, version);
    this.myLanguage = language;
  }

  @NotNull
  public SLanguageId getId() {
    return myLanguage;
  }

  @Override
  public String getQualifiedName() {
    LanguageRuntime ld = getLanguageDescriptor();
    if (ld == null) {
      return myLanguageFqName;
    }
    return ld.getNamespace();
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguage);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return  false;
    return ( obj instanceof SLanguageAdapterById) ? myLanguage.equals(((SLanguageAdapterById) obj).myLanguage) : myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ((Language) MPSModuleRepository.getInstance().getModule(ModuleId.regular(myLanguage.getIdValue())));
  }
}

<code block>

package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.project.dependency.modules.LanguageDependenciesManager;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.StructureAspectDescriptor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public abstract class SLanguageAdapter implements SLanguage {
  protected final String myLanguageFqName;
  
  private final int myVersion;

  protected SLanguageAdapter(@NotNull String language, int version) {
    this.myLanguageFqName = language;
    myVersion = version;
  }

  @Nullable
  public abstract LanguageRuntime getLanguageDescriptor();

  @NotNull
  public abstract SLanguageId getId();

  @Override
  @Nullable
  public abstract Language getSourceModule();

  @Override
  public String getQualifiedName() {
    return myLanguageFqName;
  }

  @Override
  public Iterable<SAbstractConcept> getConcepts() {
    LanguageRuntime runtime = getLanguageDescriptor();
    if (runtime == null) {
      return Collections.emptySet();
    }

    StructureAspectDescriptor struc = getLanguageDescriptor().getAspect(StructureAspectDescriptor.class);
    if (struc == null) {
      return Collections.emptyList();
    }
    ArrayList<SAbstractConcept> result = new ArrayList<SAbstractConcept>();
    for (ConceptDescriptor cd : ((BaseStructureAspectDescriptor) struc).getDescriptors()) {
      if (cd.isInterfaceConcept()) {
        result.add(new SInterfaceConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      } else {
        result.add(new SConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      }
    }
    return result;
  }

  @Override
  public Iterable<SModuleReference> getLanguageRuntimes() {
    Set<SModuleReference> runtimes = new HashSet<SModuleReference>();
    Language sourceModule = getSourceModule();
    if (sourceModule == null) {
      return Collections.emptyList();
    }
    for (Language language : SetSequence.fromSet(LanguageDependenciesManager.getAllExtendedLanguages(sourceModule))) {
      runtimes.addAll(language.getRuntimeModulesReferences());
      
      
      
      
      for (SDependency dep : language.getDeclaredDependencies()) {
        if (dep.getScope() == SDependencyScope.GENERATES_INTO && dep.getTarget() instanceof Language) {
          runtimes.addAll(((Language) dep.getTarget()).getRuntimeModulesReferences());
        }
      }
    }
    return runtimes;
  }

  public int getLanguageVersion() {
    if (myVersion >= 0) {
      return myVersion;
    }
    LanguageRuntime languageDescriptor = getLanguageDescriptor();
    if (languageDescriptor == null) {
      return -1;
    }
    return languageDescriptor.getVersion();
  }

  @Override
  public String toString() {
    return myLanguageFqName;
  }

  @Override
  public int hashCode() {
    return 0;
  }
}

<code block>

package jetbrains.mps.extapi.model;

import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.SModelLegacy;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelListener.SModelListenerPriority;
import jetbrains.mps.smodel.event.SModelRenamedEvent;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;


public abstract class SModelDescriptorStub implements SModelInternal, SModel, FastNodeFinder.Factory {

  private static final Logger LOG = LogManager.getLogger(SModelDescriptorStub.class);

  private final List<SModelListener> myModelListeners = new CopyOnWriteArrayList<SModelListener>();

  private ModelLoadingState myModelLoadState = ModelLoadingState.NOT_LOADED;

  
  @Deprecated
  public abstract jetbrains.mps.smodel.SModel getSModelInternal();

  
  public void replace(SModelData modelData) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void addModelListener(@NotNull SModelListener listener) {
    if (listener.getPriority() == SModelListenerPriority.PLATFORM) {
      myModelListeners.add(0, listener);
    } else {
      myModelListeners.add(listener);
    }
  }

  @Override
  public void removeModelListener(@NotNull SModelListener listener) {
    myModelListeners.remove(listener);
  }

  @NotNull
  public List<SModelListener> getModelListeners() {
    return myModelListeners;
  }

  protected void clearListeners() {
    myModelListeners.clear();
  }

  @NotNull
  protected ModelLoadingState getLoadingState() {
    return myModelLoadState;
  }

  protected void notifyModelReplaced(jetbrains.mps.smodel.SModel oldSModel) {
    SModelRepository.getInstance().notifyModelReplaced(this, oldSModel);
  }

  

  protected void fireBeforeModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireBeforeModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelStateChanged(ModelLoadingState newState) {
    myModelLoadState = newState;
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelLoadingStateChanged(this, newState);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireBeforeModelDisposed(SModel model) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelDisposed(model);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelSaved() {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelSaved(this);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  
  public jetbrains.mps.smodel.SModel getSModel() {
    return getSModelInternal();
  }

  
  @Nullable
  protected abstract jetbrains.mps.smodel.SModel getCurrentModelInternal();

  

  @Override
  public final ModelDependenciesManager getModelDepsManager() {
    return getSModelInternal().getModelDepsManager();
  }

  @Override
  @Deprecated
  public final List<SModuleReference> importedLanguages() {
    return new SModelLegacy(getSModelInternal()).importedLanguages();
  }

  @Override
  public final void deleteLanguage(@NotNull SModuleReference ref) {
    getSModelInternal().deleteLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public final void addLanguage(SModuleReference ref) {
    
    
    
    getSModelInternal().addLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public java.util.Collection<SLanguage> importedLanguageIds() {
    return getSModelInternal().usedLanguages();
  }

  @Override
  public void deleteLanguageId(@NotNull SLanguage ref) {
    getSModel().deleteLanguage(ref);
  }

  @Override
  public void addLanguage(Language language) {
    getSModel().addLanguage(MetaAdapterByDeclaration.getLanguage(language));
  }

  @Override
  public void addLanguage(@NotNull SLanguage language) {
    getSModel().addLanguage(language);
  }

  @Override
  public void addLanguageId(SLanguage ref, int version) {
    getSModelInternal().addLanguage(ref, version);
  }

  @Override
  public final List<SModuleReference> importedDevkits() {
    return getSModelInternal().importedDevkits();
  }

  @Override
  public final void addDevKit(SModuleReference ref) {
    getSModelInternal().addDevKit(ref);
  }

  @Override
  public final void deleteDevKit(@NotNull SModuleReference ref) {
    getSModelInternal().deleteDevKit(ref);
  }

  @Override
  public final List<ImportElement> importedModels() {
    return getSModelInternal().importedModels();
  }

  @Override
  public final void addModelImport(SModelReference modelReference, boolean firstVersion) {
    new SModelLegacy(getSModelInternal()).addModelImport(modelReference, firstVersion);
  }

  @Override
  public final void addModelImport(ImportElement importElement) {
    getSModelInternal().addModelImport(importElement);
  }

  @Override
  public final void deleteModelImport(SModelReference modelReference) {
    getSModelInternal().deleteModelImport(modelReference);
  }

  @Override
  public final void calculateImplicitImports() {
    getSModelInternal().getImplicitImportsSupport().calculateImplicitImports();
  }

  @Override
  public final List<SModuleReference> engagedOnGenerationLanguages() {
    return getSModelInternal().engagedOnGenerationLanguages();
  }

  @Override
  public final void addEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().addEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().removeEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final List<ImportElement> getAdditionalModelVersions() {
    return getSModelInternal().getImplicitImportsSupport().getAdditionalModelVersions();
  }

  @Override
  public boolean isDisposed() {
    return getDisposedStacktrace() != null;
  }

  @Override
  public final StackTraceElement[] getDisposedStacktrace() {
    return getSModelInternal().getDisposedStacktrace();
  }

  @Override
  public FastNodeFinder createNodeFinder(SModel model) {
    assert model == this;
    return getSModel().createFastNodeFinder();
  }

  @Override
  public final boolean updateSModelReferences() {
    return getSModelInternal().updateSModelReferences();
  }

  @Override
  public final boolean updateModuleReferences() {
    return getSModelInternal().updateModuleReferences();
  }

  @Override
  public void changeModelReference(SModelReference newModelReference) {
    getSModelInternal().changeModelReference(newModelReference);
  }
}

<code block>
package jetbrains.mps.smodel;



import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.project.DevKit;

@Deprecated
@ToRemove(version = 3.3)
public class BootstrapLanguages {
  public static final String ACTIONS_NAMESPACE = "jetbrains.mps.lang.actions";
  public static final String BEHAVIOR_NAMESPACE = "jetbrains.mps.lang.behavior";
  public static final String CONSTRAINTS_NAMESPACE = "jetbrains.mps.lang.constraints";
  public static final String CORE_NAMESPACE = "jetbrains.mps.lang.core";
  public static final String DATA_FLOW_NAMESPACE = "jetbrains.mps.lang.dataFlow";
  public static final String DESCRIPTOR_NAMESPACE = "jetbrains.mps.lang.descriptor";
  public static final String EDITOR_NAMESPACE = "jetbrains.mps.lang.editor";
  public static final String FIND_USAGES_NAMESPACE = "jetbrains.mps.lang.findUsages";
  public static final String PROJECT_NAMESPACE = "jetbrains.mps.lang.project";
  public static final String GENERATOR_NAMESPACE = "jetbrains.mps.lang.generator";
  public static final String GENERATOR_CONTEXT_NAMESPACE = "jetbrains.mps.lang.generator.generationContext";
  public static final String GENERATOR_PARAMETERS_NAMESPACE = "jetbrains.mps.lang.generator.generationParameters";
  public static final String INTENTIONS_NAMESPACE = "jetbrains.mps.lang.intentions";
  public static final String PLUGIN_NAMESPACE = "jetbrains.mps.lang.plugin";
  public static final String MAKE_FACET_NAMESPACE = "jetbrains.mps.make.facet";
  public static final String REFACTORING_NAMESPACE = "jetbrains.mps.lang.refactoring";
  public static final String SCRIPT_NAMESPACE = "jetbrains.mps.lang.script";
  public static final String SHARED_CONCEPTS_NAMESPACE = "jetbrains.mps.lang.sharedConcepts";
  public static final String SMODEL_NAMESPACE = "jetbrains.mps.lang.smodel";
  public static final String STRUCTURE_NAMESPACE = "jetbrains.mps.lang.structure";
  public static final String MIGRATION_NAMESPACE = "jetbrains.mps.lang.migration";
  public static final String TEST_NAMESPACE = "jetbrains.mps.lang.test";
  public static final String TEXT_GEN_NAMESPACE = "jetbrains.mps.lang.textGen";
  public static final String TYPESYSTEM_NAMESPACE = "jetbrains.mps.lang.typesystem";
  public static final String BASE_LANGUAGE_NAMESPACE = "jetbrains.mps.baseLanguage";
  public static final String COLLECTIONS_NAMESPACE = "jetbrains.mps.baseLanguage.collections";
  public static final String CLOSURES_NAMESPACE = "jetbrains.mps.baseLanguage.closures";
  public static final String TUPLES_NAMESPACE = "jetbrains.mps.baseLanguage.tuples";
  public static final String UNITTEST_NAMESPACE = "jetbrains.mps.baseLanguage.unitTest";
  public static final String DEVKIT_GENERAL_NAMESPACE = "jetbrains.mps.devkit.general-purpose";
  public static final String DEVKIT_BOOTSTRAP_NAMESPACE = "jetbrains.mps.devkit.bootstrap-languages";
  public static final String DEVKIT_LANGUAGE_DESIGN_NAMESPACE = "jetbrains.mps.devkit.language-design";
  public static final String JDK_NAMESPACE = "JDK";
  public static final String concept_baseLanguage_Annotation = "jetbrains.mps.baseLanguage.structure.Annotation";
  public static final String concept_baseLanguage_ClassConcept = "jetbrains.mps.baseLanguage.structure.ClassConcept";
  public static final String concept_baseLanguage_EnumClass = "jetbrains.mps.baseLanguage.structure.EnumClass";
  public static final String concept_baseLanguage_Interface = "jetbrains.mps.baseLanguage.structure.Interface";
  public static final String concept_generator_MappingConfiguration = "jetbrains.mps.lang.generator.structure.MappingConfiguration";

  private static final SModuleReference descriptorLanguage = PersistenceFacade.getInstance().createModuleReference("f4ad079d-bc71-4ffb-9600-9328705cf998(jetbrains.mps.lang.descriptor)");
  private static final SModuleReference projectLanguage = PersistenceFacade.getInstance().createModuleReference("86ef8290-12bb-4ca7-947f-093788f263a9(jetbrains.mps.lang.project)");
  private static final SModuleReference coreLanguage = PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)");
  private static final SModuleReference structureLanguage = PersistenceFacade.getInstance().createModuleReference("c72da2b9-7cce-4447-8389-f407dc1158b7(jetbrains.mps.lang.structure)");
  private static final SModuleReference editorLanguage = PersistenceFacade.getInstance().createModuleReference("18bc6592-03a6-4e29-a83a-7ff23bde13ba(jetbrains.mps.lang.editor)");
  private static final SModuleReference actionsLanguage = PersistenceFacade.getInstance().createModuleReference("aee9cad2-acd4-4608-aef2-0004f6a1cdbd(jetbrains.mps.lang.actions)");
  private static final SModuleReference constraintsLanguage = PersistenceFacade.getInstance().createModuleReference("3f4bc5f5-c6c1-4a28-8b10-c83066ffa4a1(jetbrains.mps.lang.constraints)");
  private static final SModuleReference behaviorLanguage = PersistenceFacade.getInstance().createModuleReference("af65afd8-f0dd-4942-87d9-63a55f2a9db1(jetbrains.mps.lang.behavior)");
  private static final SModuleReference typesystemLanguage = PersistenceFacade.getInstance().createModuleReference("7a5dda62-9140-4668-ab76-d5ed1746f2b2(jetbrains.mps.lang.typesystem)");
  private static final SModuleReference baseLanguage = PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)");
  private static final SModuleReference jdkModule = PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)");

  @Deprecated
  private BootstrapLanguages() {
  }
  public static SLanguage getLangCore() {
    return MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL), "jetbrains.mps.lang.core", -1);
  }
  public static Language baseLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"), Language.class);
  }
  public static Language smodelLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("7866978e-a0f0-4cc7-81bc-4d213d9375e1(jetbrains.mps.lang.smodel)"), Language.class);
  }
  public static Language collectionsLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("83888646-71ce-4f1c-9c53-c54016f6ad4f(jetbrains.mps.baseLanguage.collections)"), Language.class);
  }
  public static Language generatorLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("b401a680-8325-4110-8fd3-84331ff25bef(jetbrains.mps.lang.generator)"), Language.class);
  }
  public static Language generatorContextLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("d7706f63-9be2-479c-a3da-ae92af1e64d5(jetbrains.mps.lang.generator.generationContext)"), Language.class);
  }
  public static Language generatorParametersLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("289fcc83-6543-41e8-a5ca-768235715ce4(jetbrains.mps.lang.generator.generationParameters)"), Language.class);
  }
  public static Language coreLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)"), Language.class);
  }
  public static DevKit generalDevKit() {
    return (DevKit) ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }
  public static SModuleReference descriptorLanguageRef() {
    return descriptorLanguage;
  }
  public static SModuleReference projectLanguageRef() {
    return projectLanguage;
  }
  public static SModuleReference coreLanguageRef() {
    return coreLanguage;
  }
  public static SModuleReference structureLanguageRef() {
    return structureLanguage;
  }
  public static SModuleReference editorLanguageRef() {
    return editorLanguage;
  }
  public static SModuleReference actionsLanguageRef() {
    return actionsLanguage;
  }
  public static SModuleReference constraintsLanguageRef() {
    return constraintsLanguage;
  }
  public static SModuleReference behaviorLanguageRef() {
    return behaviorLanguage;
  }
  public static SModuleReference typesystemLanguageRef() {
    return typesystemLanguage;
  }
  public static SModuleReference baseLanguageRef() {
    return baseLanguage;
  }
  public static SModuleReference refactoringLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("3ecd7c84-cde3-45de-886c-135ecc69b742(jetbrains.mps.lang.refactoring)");
  }
  public static SModuleReference scriptLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("0eddeefa-c2d6-4437-bc2c-de50fd4ce470(jetbrains.mps.lang.script)");
  }
  public static SModuleReference intentionsLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("d7a92d38-f7db-40d0-8431-763b0c3c9f20(jetbrains.mps.lang.intentions)");
  }
  public static SModuleReference findUsagesLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("64d34fcd-ad02-4e73-aff8-a581124c2e30(jetbrains.mps.lang.findUsages)");
  }
  public static SModuleReference pluginLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("28f9e497-3b42-4291-aeba-0a1039153ab1(jetbrains.mps.lang.plugin)");
  }
  public static SModuleReference dataFlowLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("7fa12e9c-b949-4976-b4fa-19accbc320b4(jetbrains.mps.lang.dataFlow)");
  }
  public static SModuleReference testLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("8585453e-6bfb-4d80-98de-b16074f1d86c(jetbrains.mps.lang.test)");
  }
  public static SModuleReference textGenLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("b83431fe-5c8f-40bc-8a36-65e25f4dd253(jetbrains.mps.lang.textGen)");
  }
  public static SModuleReference migrationLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("90746344-04fd-4286-97d5-b46ae6a81709(jetbrains.mps.lang.migration)");
  }
  public static SModuleReference unitTestLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("f61473f9-130f-42f6-b98d-6c438812c2f6(jetbrains.mps.baseLanguage.unitTest)");
  }
  public static SModuleReference jdkRef() {
    return jdkModule;
  }

}

<code block>
package jetbrains.mps.project.structure;



import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.components.CoreComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelId;
import java.util.concurrent.ConcurrentHashMap;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SModuleAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.DevKit;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.module.SModuleId;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.project.structure.stub.ProjectStructureBuilder;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.BaseFastNodeFinder;

public class ProjectStructureModule extends AbstractModule implements CoreComponent {
  private static final String MODULE_REF = "642f71f8-327a-425b-84f9-44ad58786d27(jetbrains.mps.lang.project.modules)";
  private Map<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor> myModels = new ConcurrentHashMap<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor>();
  private static ProjectStructureModule INSTANCE;
  private final MPSModuleOwner myOwner = new BaseMPSModuleOwner() {};
  private final SModuleListener myModuleListener = new SModuleAdapter() {
    @Override
    public void moduleChanged(SModule module) {
      refreshModule(module, false);
    }
  };
  private final SRepositoryListener myListener = new SRepositoryListenerBase() {
    @Override
    public void moduleAdded(@NotNull SModule module) {
      refreshModule(module, false);
      module.addModuleListener(myModuleListener);
    }
    @Override
    public void beforeModuleRemoved(@NotNull SModule module) {
      module.removeModuleListener(myModuleListener);
      refreshModule(module, true);
    }
  };
  private final MPSModuleRepository myRepository;
  public static ProjectStructureModule getInstance() {
    return INSTANCE;
  }
  public ProjectStructureModule(MPSModuleRepository repository) {
    myRepository = repository;
    setModuleReference(PersistenceFacade.getInstance().createModuleReference(MODULE_REF));
  }
  private void refreshModule(SModule module, boolean isDeleted) {
    assertCanChange();
    if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {
      return;
    }
    SModelReference ref = getSModelReference(module);
    if (isDeleted) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      if (descriptor != null) {
        removeModel(descriptor);
      }
    } else
    if (myModels.containsKey(ref.getModelId())) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      descriptor.dropModel();
    } else {
      createModel(module);
    }
  }
  public SModel getModelByModule(SModule module) {
    myRepository.getModelAccess().checkReadAccess();
    if (module == null) {
      return null;
    }
    SModelReference ref = getSModelReference(module);
    ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
    return (descriptor == null ? null : descriptor);
  }
  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myRepository.addRepositoryListener(myListener);
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.registerModule(ProjectStructureModule.this, myOwner);
      }
    });
  }
  @Override
  public void dispose() {
    
    if (INSTANCE == null) {
      return;
    }
    INSTANCE = null;
    clearAll();
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.unregisterModule(ProjectStructureModule.this, myOwner);
      }
    });
    myRepository.removeRepositoryListener(myListener);
  }
  public void clearAll() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        removeAll();
        dependenciesChanged();
        myModels.clear();
      }
    });
  }
  private void removeAll() {
    List<SModel> models = this.getProjectStructureModels();
    for (SModel model : models) {
      removeModel(model);
    }
  }
  @Override
  public Set<SLanguage> getUsedLanguages() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x86ef829012bb4ca7L, 0x947f093788f263a9L), "jetbrains.mps.lang.project", 0));
  }
  private void removeModel(SModel md) {
    if (myModels.remove(md.getReference().getModelId()) != null) {
      unregisterModel((SModelBase) md);
      if (md instanceof ProjectStructureModule.ProjectStructureSModelDescriptor) {
        ((ProjectStructureModule.ProjectStructureSModelDescriptor) md).dropModel();
      }
    }
  }
  public ProjectStructureModule.ProjectStructureSModelDescriptor createModel(SModule module) {
    ProjectStructureModule.ProjectStructureSModelDescriptor result = new ProjectStructureModule.ProjectStructureSModelDescriptor(getSModelReference(module), module);
    myModels.put(getSModelReference(module).getModelId(), result);
    registerModel(result);
    return result;
  }
  private SModelReference getSModelReference(SModule module) {
    SModuleId moduleId = module.getModuleReference().getModuleId();
    SModelId id = (moduleId != null ? jetbrains.mps.smodel.SModelId.foreign("project", moduleId.toString()) : null);
    return new jetbrains.mps.smodel.SModelReference(this.getModuleReference(), id, "module." + module.getModuleName() + "@" + SModelStereotype.getStubStereotypeForId("project"));
  }
  public String toString() {
    return getModuleName();
  }
  public List<SModel> getProjectStructureModels() {
    return new ArrayList<SModel>(myModels.values());
  }
  @Override
  protected void collectFacetTypes(Set<String> types) {
    
  }
  @Override
  public SModel resolveInDependencies(SModelId ref) {
    return myModels.get(ref);
  }
  public class ProjectStructureSModelDescriptor extends BaseSpecialModelDescriptor {
    private final SModule myModule;
    private ProjectStructureSModelDescriptor(SModelReference ref, SModule module) {
      super(ref);
      myModule = module;
    }
    @Override
    protected ProjectStructureModule.ProjectStructureSModel createModel() {
      final ProjectStructureModule.ProjectStructureSModel model = new ProjectStructureModule.ProjectStructureSModel(getReference());
      final ModuleDescriptor moduleDescriptor = ((AbstractModule) myModule).getModuleDescriptor();
      final IFile file = ((AbstractModule) myModule).getDescriptorFile();
      if (file != null && moduleDescriptor != null) {
        NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable() {
          @Override
          public void run() {
            new ProjectStructureBuilder(moduleDescriptor, file, model) {
              @Override
              public Iterable<SModelReference> loadReferences(SNode m, ModuleDescriptor descriptor) {
                SModule module = (moduleDescriptor == descriptor ? myModule : ModuleRepositoryFacade.getInstance().getModule(descriptor.getModuleReference()));
                if (module == null) {
                  return Collections.emptyList();
                }
                return Sequence.<SModel>fromIterable(module.getModels()).where(new IWhereFilter<SModel>() {
                  @Override
                  public boolean accept(SModel o) {
                    return SModelStereotype.isUserModel(o);
                  }
                }).select(new ISelector<SModel, SModelReference>() {
                  @Override
                  public SModelReference select(SModel o) {
                    return o.getReference();
                  }
                });
              }
            }.convert();
          }
        });
      }
      return model;
    }
    private void dropModel() {
      if (mySModel == null) {
        return;
      }
      final jetbrains.mps.smodel.SModel oldModel = mySModel;
      mySModel = null;
      replaceModelAndFireEvent(oldModel, null);
    }
  }
  public static class ProjectStructureSModel extends jetbrains.mps.smodel.SModel {
    public ProjectStructureSModel(@NotNull SModelReference modelReference) {
      super(modelReference, new ForeignNodeIdMap());
    }
    @Override
    public boolean canFireEvent() {
      return false;
    }
    @Override
    public FastNodeFinder createFastNodeFinder() {
      return new BaseFastNodeFinder(getModelDescriptor());
    }
  }
}

<code block>
package jetbrains.mps.lang.migration.runtime.base;



import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;

public class MigrationScriptReference {
  private final SLanguage language;
  private final int fromVersion;
  public MigrationScriptReference(SLanguage language, int fromVersion) {
    this.language = language;
    this.fromVersion = fromVersion;
  }
  public MigrationScriptReference(SLanguage language) {
    this.language = language;
    this.fromVersion = language.getLanguageVersion();
  }
  public SLanguage getLanguage() {
    return language;
  }
  public int getFromVersion() {
    return fromVersion;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    MigrationScriptReference that = (MigrationScriptReference) o;
    if (!(language.equals(that.language))) {
      return false;
    }
    if (fromVersion != that.fromVersion) {
      return false;
    }
    return true;
  }
  @Override
  public int hashCode() {
    return language.hashCode() + 31 * fromVersion;
  }
  public String serialize() {
    return IdHelper.getLanguageId(language).serialize() + "(" + language.getQualifiedName() + ")" + "/" + fromVersion;
  }
  public static MigrationScriptReference deserialize(String s) {
    int version = Integer.parseInt(s.substring(s.indexOf('/') + 1));
    int ix = s.indexOf('(');
    SLanguage language = MetaAdapterFactory.getLanguage(SLanguageId.deserialize(s.substring(0, ix)), s.substring(ix + 1, s.indexOf(')', ix)), version);
    return new MigrationScriptReference(language);
  }
}

<code block>
package jetbrains.mps.persistence.java.library;



import jetbrains.mps.extapi.model.ReloadableSModelBase;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.extapi.persistence.FolderSetDataSource;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.baseLanguage.javastub.ASMModelLoader;
import java.util.Set;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SModelRepository;

public class JavaClassStubModelDescriptor extends ReloadableSModelBase {
  private SModel myModel;
  private boolean mySkipPrivate;
  public JavaClassStubModelDescriptor(SModelReference modelReference, FolderSetDataSource source) {
    super(modelReference, source);
  }
   void setSkipPrivate(boolean skipPrivateMembers) {
    mySkipPrivate = skipPrivateMembers;
  }
  @Override
  protected SModel getCurrentModelInternal() {
    return myModel;
  }
  @NotNull
  @Override
  public FolderSetDataSource getSource() {
    return (FolderSetDataSource) super.getSource();
  }
  @Override
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
      fireModelStateChanged(ModelLoadingState.FULLY_LOADED);
    }
    return myModel;
  }
  @Override
  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }
  private SModel createModel() {
    SModel model = new SModel(getReference(), new ForeignNodeIdMap());
    for (SLanguage l : getLanguagesToImport()) {
      model.addLanguage(l);
    }
    ASMModelLoader loader = new ASMModelLoader(getModelRoot().getModule(), getSource().getPaths());
    loader.skipPrivateMembers(mySkipPrivate);
    loader.update(model);
    return model;
  }
  private Set<SLanguage> getLanguagesToImport() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return getLanguagesToImport();
  }
  @Override
  public void reloadFromDiskSafe() {
    assertCanChange();
    if (getSource().getPaths().isEmpty()) {
      SModelRepository.getInstance().deleteModel(this);
      return;
    }
    reload();
    updateTimestamp();
  }
  private void reload() {
    if (myModel == null) {
      return;
    }
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }
}

<code block>

package org.jetbrains.mps.openapi.language;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;


public interface SLanguage {

  
  @NotNull
  String getQualifiedName();

  
  Iterable<SAbstractConcept> getConcepts();

  
  Iterable<SModuleReference> getLanguageRuntimes();

  
  @Nullable
  SModule getSourceModule();

  
  int getLanguageVersion();
}

<code block>
package jetbrains.mps.console.tool;



import javax.swing.JPanel;
import com.intellij.openapi.Disposable;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.fileEditor.FileEditor;
import jetbrains.mps.nodeEditor.UIEditorComponent;
import jetbrains.mps.nodeEditor.Highlighter;
import jetbrains.mps.nodeEditor.EditorComponent;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SLanguageHierarchy;
import java.util.Collections;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.CustomShortcutSet;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import com.intellij.openapi.actionSystem.ShortcutSet;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.ide.PasteProvider;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.apache.log4j.Level;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.DataContext;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.datatransfer.NodePaster;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.util.Base64Converter;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.ide.findusages.model.scopes.ProjectScope;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Scanner;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.MouseShortcut;
import java.awt.event.MouseEvent;
import java.awt.BorderLayout;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import com.intellij.openapi.wm.IdeFocusManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelUtil_new;

public abstract class BaseConsoleTab extends JPanel implements Disposable {
  protected ConsoleTool myTool;
  protected SModel myModel;
  protected SNode myRoot;
  protected FileEditor myFileEditor;
  protected UIEditorComponent myEditor;
  protected Highlighter myHighlighter;
  protected String myTabTitle;

  public String getTitle() {
    return myTabTitle;
  }

  public SModel getConsoleModel() {
    return myModel;
  }

  public EditorComponent getEditorComponent() {
    return myEditor;
  }

  public SNode getRoot() {
    return myRoot;
  }

  public ConsoleTool getConsoleTool() {
    return myTool;
  }

  protected void addBuiltInImports() {
    SLanguage base = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L), "jetbrains.mps.console.base", -1);
    Collection<SLanguage> baseAndExtensions = new SLanguageHierarchy(Collections.singleton(base)).getExtending();
    SModelInternal modelInternal = ((SModelInternal) myModel);
    for (SLanguage l : CollectionSequence.fromCollection(baseAndExtensions)) {
      modelInternal.addLanguage(l);
      Language sourceLangModule = (Language) l.getSourceModule();
      if (sourceLangModule == null) {
        continue;
      }
      modelInternal.addModelImport(sourceLangModule.getStructureModelDescriptor().getReference(), false);
      ((AbstractModule) myModel.getModule()).addDependency(sourceLangModule.getModuleReference(), false);
    }
    modelInternal.addDevKit(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }

  protected void validateImports() {
    SModelInternal modelInternal = (SModelInternal) myModel;
    for (SModuleReference devKit : ListSequence.fromListWithValues(new ArrayList<SModuleReference>(), modelInternal.importedDevkits())) {
      modelInternal.deleteDevKit(devKit);
    }
    for (SLanguage language : ListSequence.fromListWithValues(new ArrayList<SLanguage>(), modelInternal.importedLanguageIds())) {
      modelInternal.deleteLanguageId(language);
    }
    for (jetbrains.mps.smodel.SModel.ImportElement model : ListSequence.fromListWithValues(new ArrayList<jetbrains.mps.smodel.SModel.ImportElement>(), modelInternal.importedModels())) {
      modelInternal.deleteModelImport(model.getModelReference());
    }
    addBuiltInImports();
    TemporaryModels.getInstance().addMissingImports(myModel);
  }

  protected BaseAction registerKeyShortcut(BaseAction a, int key) {
    return registerShortcutSet(a, new CustomShortcutSet(KeyStroke.getKeyStroke(key, KeyEvent.CTRL_MASK)));
  }

  protected BaseAction registerShortcutSet(BaseAction a, ShortcutSet shortcutSet) {
    a.registerCustomShortcutSet(shortcutSet, myEditor);
    return a;
  }

  protected void createEditor() {
    this.myEditor = new UIEditorComponent(check_6q36mf_a0a0a0a62(ProjectHelper.toMPSProject(myTool.getProject())), null) {
      @Nullable
      @Override
      public Object getData(@NonNls String key) {
        if (PlatformDataKeys.FILE_EDITOR.is(key)) {
          return myFileEditor;
        }
        if (PlatformDataKeys.PASTE_PROVIDER.is(key)) {
          PasteProvider parentPasteProvider = as_6q36mf_a0a0a1a0a0a0a0ab(super.getData(key), PasteProvider.class);
          return (myTool.getPasteAsRef() ? new BaseConsoleTab.MyPasteProvider(parentPasteProvider) : parentPasteProvider);
        }
        return super.getData(key);
      }
    };
    myEditor.editNode(myRoot);
  }


  protected void createConsoleModel() {
    this.myModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModuleWithSourceAndClassesGen());
    if (myModel == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error: could not create console model");
      }
      return;
    }
  }

  public void dispose() {
    disposeConsoleTab();
  }

  public void disposeConsoleTab() {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        if (myEditor != null) {
          myEditor.dispose();
        }
        TemporaryModels.getInstance().dispose(myModel);
      }
    });
    myHighlighter.removeAdditionalEditorComponent(myEditor);
  }

  protected class ExecuteClosureAction extends BaseAction {
    public ExecuteClosureAction() {
      super("Execute Closure");
    }
    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      ActionUtils.updateAndPerformAction(((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.console.actions.ExecuteActionAttachedToCurrentNode_Action")), event);
    }
  }

  public class MyPasteProvider implements PasteProvider {

    private PasteProvider myDefaultPasteProvider;

    public MyPasteProvider(PasteProvider defaultPasteProvider) {
      myDefaultPasteProvider = defaultPasteProvider;
    }

    public void performPaste(@NotNull final DataContext context) {
      getProject().getModelAccess().executeCommand(new Runnable() {
        public void run() {
          SNodeReference pastingNodeReference = null;
          try {
            for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
              if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNodeReference)) {
                pastingNodeReference = (SNodeReference) trf.getTransferData(SModelDataFlavor.sNodeReference);
              }
              break;
            }
          } catch (UnsupportedFlavorException ignored) {
          } catch (IOException ignored) {
          }
          EditorCell currentCell = myEditor.getSelectedCell();
          SRepository repository = getProject().getRepository();
          SNode referenceTarget = check_6q36mf_a0e0a0a0a5lb(pastingNodeReference, repository);
          if (referenceTarget != null && currentCell != null && !(check_6q36mf_a0a5a0a0a0f73(check_6q36mf_a0a0f0a0a0a5lb(pastingNodeReference), myModel))) {
            SNode refContainer = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x51132a123c89fa7eL, "jetbrains.mps.console.base.structure.PastedNodeReference")));
            SLinkOperations.setTarget(refContainer, MetaAdapterFactory.getReferenceLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x36ac6f29ae8c1fb5L, 0x4904fd89e74fc6fL, "target"), referenceTarget);
            NodePaster paster = new NodePaster(ListSequence.fromListAndArray(new ArrayList<SNode>(), refContainer));
            if (paster.canPaste(currentCell)) {
              paster.paste(currentCell);
            } else if (paster.canPasteWithRemove(myEditor.getSelectedNodes())) {
              paster.pasteWithRemove(myEditor.getSelectedNodes());
            }
            TemporaryModels.getInstance().addMissingImports(myModel);
          } else {
            check_6q36mf_a0a0f0a0a0a5lb_0(myDefaultPasteProvider, context);
          }
        }
      });
    }
    public boolean isPastePossible(@NotNull DataContext context) {
      return true;
    }
    public boolean isPasteEnabled(@NotNull DataContext context) {
      return true;
    }
  }

  protected abstract void loadHistory(String state);

  @Nullable
  public String saveHistory() {
    final Wrappers._T<String> result = new Wrappers._T<String>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          result.value = (myModel == null ? null : Base64Converter.encode(PersistenceUtil.saveBinaryModel(myModel)));
        } catch (Exception e) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Error on console model saving", e);
          }
        }
      }
    });
    return result.value;
  }

  protected ConsoleContext getConsoleContext() {
    return new ConsoleContext() {
      public Project getProject() {
        return ProjectHelper.toMPSProject(myTool.getProject());
      }
      public SearchScope getDefaultSearchscope() {
        return new ProjectScope(getProject());
      }
      public BaseConsoleTab getConsoleTab() {
        return BaseConsoleTab.this;
      }
    };
  }

  protected SNode getLastReponse() {
    SNode last = SNodeOperations.as(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).last(), MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response"));
    if (last != null) {
      return last;
    }
    return SLinkOperations.addNewChild(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response")));
  }

  protected void addNodeImports(SNode node) {
    final SModelInternal modelInternal = (SModelInternal) myModel;
    final AbstractModule module = ((AbstractModule) myModel.getModule());
    final Collection<SLanguage> importedLanguages = modelInternal.importedLanguageIds();
    for (SNode subNode : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, true, new SAbstractConcept[]{}))) {
      SLanguage usedLanguage = subNode.getConcept().getLanguage();
      if (!(importedLanguages.contains(usedLanguage))) {
        modelInternal.addLanguage(usedLanguage);
      }
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(subNode))) {
        SModel usedModel = SNodeOperations.getModel(SLinkOperations.getTargetNode(ref));
        if (usedModel != null && !(modelInternal.importedModels().contains(usedModel))) {
          modelInternal.addModelImport(usedModel.getReference(), false);
          module.addDependency(SNodeOperations.getModel(SLinkOperations.getTargetNode(ref)).getModule().getModuleReference(), false);
        }
      }
    }
  }

  public ConsoleStream getConsoleStream() {
    return new ConsoleStream() {
      public void addText(String text) {
        Scanner scanner = new Scanner(text);
        while (scanner.hasNextLine()) {
          String line = scanner.nextLine();
          if ((line != null && line.length() > 0)) {
            ListSequence.fromList(SLinkOperations.getChildren(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"))).addElement(createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(line));
          }
          if (scanner.hasNextLine() || text.charAt(text.length() - 1) == '\n') {
            SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35d30L, "jetbrains.mps.console.base.structure.NewLineResponseItem")));
          }
        }
      }
      public void addNode(SNode node) {
        addNodeImports(node);
        SLinkOperations.setTarget(SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, "jetbrains.mps.console.base.structure.NodeResponseItem"))), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, 0x4e3b035171b35c15L, "node"), node);
      }
    };
  }


  public BaseConsoleTab(ConsoleTool tool, String title, @Nullable String history) {
    myTool = tool;
    myTabTitle = title;
    initConsoleTab(history);
  }

  protected void registerActions(DefaultActionGroup group) {
    registerShortcutSet(new BaseConsoleTab.ExecuteClosureAction(), new CustomShortcutSet(new MouseShortcut(MouseEvent.BUTTON1, 0, 1)));
  }

  @NotNull
  private Project getProject() {
    Project mpsProject = ProjectHelper.toMPSProject(this.getConsoleTool().getProject());
    if (mpsProject == null) {
      throw new IllegalStateException("Cannot convert idea project to the mps project");
    }
    return mpsProject;
  }

  protected void initConsoleTab(@Nullable final String history) {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        createConsoleModel();
        addBuiltInImports();
        loadHistory(history);
        createEditor();
        myFileEditor = new ConsoleFileEditor(myEditor);
      }
    });

    this.setLayout(new BorderLayout());


    DefaultActionGroup group = new DefaultActionGroup();
    registerActions(group);
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, false);
    JPanel toolbarComponent = new JPanel(new BorderLayout());
    toolbarComponent.add(toolbar.getComponent(), BorderLayout.CENTER);

    this.add(toolbarComponent, BorderLayout.WEST);
    this.add(myEditor.getExternalComponent(), BorderLayout.CENTER);

    myHighlighter = check_6q36mf_a0o0gc(myTool.getProject());
    myHighlighter.addAdditionalEditorComponent(myEditor);
  }

  public void execute(@Nullable final SNode command, @Nullable final Runnable executeBefore, @Nullable final Runnable executeAfter) {
    myTool.selectTab(this);
    final SNode[] typedCommand = new SNode[1];
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        typedCommand[0] = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, "jetbrains.mps.console.base.structure.CommandHolder")));
        if (command != null) {
          addNodeImports(command);
          SLinkOperations.setTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"))));
          SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(command));
        }
      }
    });
    BehaviorReflection.invokeVirtual(Void.class, SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")), "virtual_execute_6854397602732226506", new Object[]{getConsoleContext(), getConsoleStream(), new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder"))));
            SNodeOperations.deleteNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a2a0a0a0a0a2a0d0ic(executeBefore);
          }
        });
      }
    }, new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SLinkOperations.getTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a1a0a0a0a0a3a0d0ic(executeAfter);
          }
        });
      }
    }});
  }

  public void selectNode(final SNode nodeToSelect) {
    myTool.getToolWindow().activate(new Runnable() {
      public void run() {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myEditor.selectNode(nodeToSelect);
            getEditorComponent().ensureSelectionVisible();
            IdeFocusManager.getInstance(myTool.getProject()).requestFocus(myEditor, false);
          }
        });
      }
    });
    myTool.selectTab(this);
  }

  protected SModel loadHistoryModel(String state) {
    if (state != null) {
      try {
        final Wrappers._T<SModel> loadedModel = new Wrappers._T<SModel>(PersistenceUtil.loadBinaryModel(Base64Converter.decode(state.getBytes())));
        ListSequence.fromList(SModelOperations.nodes(loadedModel.value, null)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(it.getConcept().isValid());
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            if ((SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false) != null)) {
              SNodeOperations.deleteNode(SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false));
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: removing enclosing history item");
              }
            } else {
              loadedModel.value = null;
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: not loading history");
              }
            }
          }
        });
        return loadedModel.value;
      } catch (RuntimeException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Console history was not loaded. Maybe you are opening project from previous MPS versions?");
        }
      } catch (Throwable e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error on loading console history.", e);
        }
      }
    }
    return null;
  }

  protected static Logger LOG = LogManager.getLogger(BaseConsoleTab.class);
  private static SRepository check_6q36mf_a0a0a0a62(Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRepository();
    }
    return null;
  }
  private static SNode check_6q36mf_a0e0a0a0a5lb(SNodeReference checkedDotOperand, SRepository repository) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.resolve(repository);
    }
    return null;
  }
  private static boolean check_6q36mf_a0a5a0a0a0f73(SModelReference checkedDotOperand, SModel myModel) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.equals(myModel.getReference());
    }
    return false;
  }
  private static SModelReference check_6q36mf_a0a0f0a0a0a5lb(SNodeReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelReference();
    }
    return null;
  }
  private static void check_6q36mf_a0a0f0a0a0a5lb_0(PasteProvider checkedDotOperand, DataContext context) {
    if (null != checkedDotOperand) {
      checkedDotOperand.performPaste(context);
    }

  }
  private static SNode createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(Object p0) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, "jetbrains.mps.console.base.structure.TextResponseItem"), null, null, false);
    n1.setProperty(MetaAdapterFactory.getProperty(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, 0x4e3b035171b35d11L, "text"), String.valueOf(p0));
    return n1;
  }
  private static Highlighter check_6q36mf_a0o0gc(com.intellij.openapi.project.Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getComponent(Highlighter.class);
    }
    return null;
  }
  private static void check_6q36mf_a2a0a0a0a0a2a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static void check_6q36mf_a1a0a0a0a0a3a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static <T> T as_6q36mf_a0a0a1a0a0a0a0ab(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}

<code block>
package jetbrains.mps.ide.java.sourceStubs;



import jetbrains.mps.extapi.model.ReloadableSModelBase;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSourceListener;
import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSource;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.io.InputStream;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.io.IOException;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import java.util.List;
import java.util.LinkedList;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;

public class JavaSourceStubModelDescriptor extends ReloadableSModelBase implements MultiStreamDataSourceListener {

  private static Logger LOG = Logger.wrap(LogManager.getLogger(JavaSourceStubModelDescriptor.class));

  private SModelReference myModelRef;
  private SModel myModel;
  private Map<String, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());


  public JavaSourceStubModelDescriptor(SModelReference modelRef, MultiStreamDataSource dataSource) {
    super(modelRef, dataSource);
    myModelRef = modelRef;
  }

  private SModel createModel() {
    SModel model = new SModel(myModelRef);
    processStreams(getSource().getAvailableStreams(), model);
    for (SLanguage l : CollectionSequence.fromCollection(importedLanguageIds())) {
      model.addLanguage(l);
    }
    return model;
  }

  @Override
  public void attach(SRepository repository) {
    getSource().addListener(this);
    super.attach(repository);
  }

  @Override
  public void detach() {
    super.detach();
    getSource().removeListener(this);
  }

  @Override
  @NotNull
  public MultiStreamDataSource getSource() {
    return (MultiStreamDataSource) super.getSource();
  }

  @Override
  public void changed(DataSource source, Iterable<String> changedItems) {
    

    assertCanChange();

    
    if (myModel == null) {
      return;
    }
    MapSequence.fromMap(myRootsPerFile).clear();
    MapSequence.fromMap(myRootsById).clear();
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }

  @Override
  public boolean needsReloading() {
    return false;
  }

  @Override
  public void changed(DataSource source) {
    
  }

  public void processStreams(Iterable<String> names, SModelData into) {
    JavaParser parser = new JavaParser();

    for (String fileName : names) {
      try {
        Set<SNode> oldNodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), MapSequence.fromMap(myRootsPerFile).get(fileName));

        InputStream is = getSource().openInputStream(fileName);
        
        if (is == null) {
          SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });
          MapSequence.fromMap(myRootsPerFile).removeKey(fileName);
          continue;
        }
        String code = readInputStream(is);
        try {
          is.close();
        } catch (IOException e) {
          LOG.warning("failed to close file " + fileName, e);
        }

        JavaParser.JavaParseResult parseResult = parser.parse(code, FeatureKind.CLASS_STUB, null, true);
        if (ListSequence.fromList(parseResult.getNodes()).isNotEmpty()) {
          for (SNode newNode : ListSequence.fromList(parseResult.getNodes())) {
            final SNodeId newNodeId = newNode.getNodeId();
            
            SNode oldNode = SetSequence.fromSet(oldNodes).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return it.getNodeId().equals(newNodeId);
              }
            }).first();
            if (oldNode == null) {
              into.addRootNode(newNode);
              SetSequence.fromSet(oldNodes).removeElement(oldNode);
            } else {
              SNodeOperations.replaceWithAnother(oldNode, newNode);
            }
            MapSequence.fromMap(myRootsById).put(newNode.getNodeId(), newNode);
          }
        }

        SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SNodeOperations.deleteNode(it);
          }
        });
        MapSequence.fromMap(myRootsPerFile).put(fileName, SetSequence.fromSetWithValues(new HashSet<SNode>(), parseResult.getNodes()));

      } catch (IOException e) {
        LOG.error("Failed to read java file. " + e.getMessage(), e);
      } catch (JavaParseException e) {
        LOG.error("Failed to parse java file. " + e.getMessage());
      }
    }
  }

  private static final int BUFSIZE = 65536;
  private String readInputStream(InputStream is) throws IOException {

    List<byte[]> blocks = ListSequence.fromList(new LinkedList<byte[]>());

    byte[] buffer = new byte[BUFSIZE];
    int lastRead = -1;
    int read = is.read(buffer);

    while (read > 0) {
      lastRead = read;
      ListSequence.fromList(blocks).addElement(buffer);

      buffer = new byte[BUFSIZE];
      read = is.read(buffer);
    }

    if (lastRead > 0) {
      int blks = ListSequence.fromList(blocks).count();
      byte[] wholeBuffer;

      if (blks == 1) {
        wholeBuffer = ListSequence.fromList(blocks).getElement(0);
      } else {
        int size = (blks - 1) * BUFSIZE + lastRead;
        wholeBuffer = new byte[size];
        int c = 0;
        int p = 0;
        for (byte[] buf : blocks) {
          int n = (c == blks - 1 ? lastRead : BUFSIZE);
          System.arraycopy(buf, 0, wholeBuffer, p, n);
          p = p + BUFSIZE;
          c++;
        }
      }

      
      return new String(wholeBuffer);

    } else {
      return "";
    }
  }

  protected SModel getCurrentModelInternal() {
    return myModel;
  }

  @Deprecated
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
    }
    return myModel;
  }

  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
  }

  public void reloadFromDiskSafe() {
    changed(getSource(), getSource().getAvailableStreams());
  }
}

<code block>
package jetbrains.mps.ide.java.newparser;



import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.ModelAccess;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.io.IOException;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.extapi.model.EditableSModelBase;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vfs.IFileUtils;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.scope.Scope;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelFactory;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.persistence.FilePerRootModelPersistence;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class JavaToMpsConverter {
  private static final Logger LOG = LogManager.getLogger(JavaToMpsConverter.class);

  private SModule myModule;
  private SModel myModel;
  private boolean myCreatePerRoot;
  private boolean myCreateInplace;
  private SRepository myRepository;
  private ModelAccess myModelAccess;


  private JavaParser myJavaParser = new JavaParser();
  private Map<String, Set<SNode>> classesPerPackage = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<String, List<IFile>> filesPerPackage = MapSequence.fromMap(new HashMap<String, List<IFile>>());
  private Map<String, IFile> packageDirs = MapSequence.fromMap(new HashMap<String, IFile>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<SNode> myRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<SNode> myAttachedRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<IFile> mySuccessfulFiles = ListSequence.fromList(new ArrayList<IFile>());

  private boolean wasDefaultPkg = false;
  private int myRootCount = 0;

  public JavaToMpsConverter(SModule module, SRepository repository) {
    this(module, repository, false, false);
  }

  public Set<SNode> getRootsBuilt() {
    return Collections.<SNode>unmodifiableSet(SetSequence.fromSetWithValues(new HashSet<SNode>(), myAttachedRoots));
  }

  public JavaToMpsConverter(SModule module, SRepository repository, boolean perRoot, boolean inPlace) {
    
    
    myModule = module;
    myCreatePerRoot = perRoot;
    myCreateInplace = inPlace;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public JavaToMpsConverter(SModel model, SRepository repository) {
    myModel = model;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {

    progress.start("Converting...", 31);

    
    final ProgressMonitor parseProgress = progress.subTask(1);
    parseProgress.start("Parsing...", ListSequence.fromList(files).count());

    

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (IFile file : ListSequence.fromList(files)) {
          try {
            parseFile(file);
            parseProgress.advance(1);

          } catch (JavaParseException e) {
          } catch (IOException e) {
          }
        }
      }
    });

    parseProgress.done();


    int rootCount = 0;

    

    runCommand("roots creation pass", new Runnable() {
      public void run() {

        SModule module;

        if (myModel == null) {
          ((AbstractModule) myModule).addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);

          for (String pakage : MapSequence.fromMap(classesPerPackage).keySet()) {
            final SModel model = getModel(pakage, MapSequence.fromMap(packageDirs).get(pakage));
            if (model == null) {
              continue;
            }

            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf280165065d5424eL, 0xbb1b463a8781b786L), "jetbrains.mps.baseLanguage.javadoc", -1));

            Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
            SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
              public void visit(SNode it) {
                model.addRootNode(it);
              }
            });

            ListSequence.fromList(mySuccessfulFiles).addSequence(ListSequence.fromList(MapSequence.fromMap(filesPerPackage).get(pakage)));
            ListSequence.fromList(myAttachedRoots).addSequence(SetSequence.fromSet(roots));

            ((EditableSModelBase) model).save();
            ListSequence.fromList(myModels).addElement(model);
          }
          module = myModule;

        } else {
          
          
          for (SNode root : ListSequence.fromList(myRoots)) {
            
            myModel.addRootNode(root);
          }
          myAttachedRoots = myRoots;
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"));
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f2801650-65d5-424e-bb1b-463a8781b786(jetbrains.mps.baseLanguage.javadoc)"));
          module = myModel.getModule();
        }

        JavaParser.tryResolveUnknowns(myAttachedRoots);
      }
    });

    myRootCount = myAttachedRoots.size();

    ProgressMonitor resolveProgress = progress.subTask(30);
    tryResolveRefs(myAttachedRoots, FeatureKind.CLASS, resolveProgress);
    progress.done();
  }

  public void tryResolveRefs(Iterable<SNode> nodes, FeatureKind level, ProgressMonitor progress) {
    progress.start("Resolving...", 10);

    if (FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("top level references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getTopLevelRefs(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
        }
      }, progress.subTask(1));
    }

    if (FeatureKind.CLASS_CONTENT.equals(level) || FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("field/method type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember")));
        }
      }, progress.subTask(1));
    }

    resolveUpdatePass("type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVarTypeRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("variable references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVariableRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operands", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operations", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")))).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return (SReference) it instanceof DynamicReference;
              }
            })) {
              return ListSequence.fromList(new ArrayList<SReference>());
            } else {
              if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration")));
              } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration")));
              } else {
                return ListSequence.fromList(new ArrayList<SReference>());
              }
            }
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("classifiers in static access", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("static member references", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("remaining references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return deepReferences(node);
      }
    }, progress.subTask(1));

    codeTransformPass(nodes, progress.subTask(1));

    removeJavaImportsPass(nodes, progress.subTask(1));

    progress.done();
  }

  public List<IFile> getSuccessfulFiles() {
    return mySuccessfulFiles;
  }

  public List<SModel> getModels() {
    return myModels;
  }

  private void parseFile(IFile file) throws JavaParseException, IOException {
    String contents = IFileUtils.getTextContents(file);
    JavaParser.JavaParseResult parseResult = myJavaParser.parseCompilationUnit(contents);
    String pkg = parseResult.getPackage();

    if (pkg == null) {
      
      if (!(wasDefaultPkg)) {
        LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
        wasDefaultPkg = true;
      }
      return;
    }

    IFile dir = file.getParent();
    if (!(DirParser.checkPackageMatchesSourceDirectory(pkg, dir))) {
      LOG.error("package " + pkg + " doesn't match directory " + dir.getPath() + " (in file " + file.getName() + ")");
      return;
    }

    IFile currentDir = MapSequence.fromMap(packageDirs).get(pkg);
    
    
    
    if (currentDir == null) {
      MapSequence.fromMap(packageDirs).put(pkg, dir);
    }

    Iterable<SNode> roots = parseResult.getNodes();

    Set<SNode> classesInPackage = MapSequence.fromMap(classesPerPackage).get(pkg);
    if (classesInPackage == null) {
      classesInPackage = SetSequence.fromSet(new HashSet<SNode>(Sequence.fromIterable(roots).count()));
      MapSequence.fromMap(classesPerPackage).put(pkg, classesInPackage);
    }
    SetSequence.fromSet(classesInPackage).addSequence(Sequence.fromIterable(roots));

    List<IFile> files = MapSequence.fromMap(filesPerPackage).get(pkg);
    if (files == null) {
      files = ListSequence.fromList(new ArrayList<IFile>());
      MapSequence.fromMap(filesPerPackage).put(pkg, files);
    }
    ListSequence.fromList(files).addElement(file);

    ListSequence.fromList(myRoots).addSequence(Sequence.fromIterable(roots));
    myRootCount += Sequence.fromIterable(roots).count();

  }

  private void runCommand(String name, final Runnable runnable) {
    if (SwingUtilities.isEventDispatchThread()) {
      myModelAccess.executeCommand(runnable);

    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            myModelAccess.executeCommand(runnable);
          }
        });

      } catch (InterruptedException e) {
        LOG.error(name + " was interrupted", e);
      } catch (InvocationTargetException e) {
        LOG.error("Exception in " + name, e.getCause());
      }
    }
  }

  private Set<SReference> myVisitedRefs = SetSequence.fromSet(new HashSet<SReference>());

  private void resolveUpdatePass(String name, final Iterable<SNode> nodes, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {
    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());
    progress.start(name, Sequence.fromIterable(nodes).count() + 1);

    myModelAccess.runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {

          if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"))) {
            progress.step("class: " + SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }

          Iterable<SReference> refs = extractor.invoke(node);
          resolveRefs(refs, resolveMap);

          SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
          progress.advance(1);
        }

      }
    });

    progress.step("updating references...");

    runCommand(name, new Runnable() {
      public void run() {
        updateReference(resolveMap);
      }
    });

    progress.advance(1);
    progress.done();
  }

  private void codeTransformPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Code transforms", Sequence.fromIterable(nodes).count() * 5 + 1);
    final TypeChecker typeChecker = TypeChecker.getInstance();

    
    final List<SNode> toReplaceWithArrayLength = ListSequence.fromList(new ArrayList<SNode>());
    final List<SNode> toReplaceWithArrayClone = ListSequence.fromList(new ArrayList<SNode>());
    final Map<SNode, SNode> enumConstRefs = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticMethodQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticFieldQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (SNode node : Sequence.fromIterable(nodes)) {

          for (SNode fieldRefOp : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(fieldRefOp, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "length".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(fieldRefOp), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayLength).addElement(fieldRefOp);
            }
          }

          progress.advance(1);

          for (SNode imco : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(imco, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "clone".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(imco), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayClone).addElement(imco);
            }
          }

          progress.advance(1);

          for (SNode localCall : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9404L, "jetbrains.mps.baseLanguage.structure.LocalMethodCall"), false, new SAbstractConcept[]{}))) {
            SNode smc = transformLocalCall(localCall);
            if ((smc == null)) {
              continue;
            }
            MapSequence.fromMap(staticMethodQualifiers).put(localCall, smc);
          }

          progress.advance(1);

          TypeChecker typeChecker = TypeChecker.getInstance();

          for (SNode swicthCase : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, "jetbrains.mps.baseLanguage.structure.SwitchCase"), false, new SAbstractConcept[]{}))) {
            SNode subst = transformUnqualifedEnumUnderSwitch(swicthCase, typeChecker);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(SNodeOperations.cast(SLinkOperations.getTarget(swicthCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), subst);
          }


          progress.advance(1);

          for (SNode varRef : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{}))) {
            SNode exp = transformLocalNameRef(varRef);
            if ((exp != null)) {
              MapSequence.fromMap(staticFieldQualifiers).put(varRef, exp);
              continue;
            }

            SNode subst = transformUnqualifedEnum(varRef);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(varRef, subst);
          }

          progress.advance(1);
        }

      }
    });

    progress.step("updating models...");

    runCommand("Code transforms", new Runnable() {
      public void run() {
        for (SNode fieldRefOp : ListSequence.fromList(toReplaceWithArrayLength)) {
          SNodeOperations.replaceWithNewChild(fieldRefOp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1197781411dL, "jetbrains.mps.baseLanguage.structure.ArrayLengthOperation"));
        }
        for (SNode imco : ListSequence.fromList(toReplaceWithArrayClone)) {
          SNodeOperations.replaceWithNewChild(imco, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x483ee9d7f09580d6L, "jetbrains.mps.baseLanguage.structure.ArrayCloneOperation"));
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(enumConstRefs)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticMethodQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticFieldQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }

      }
    });

    progress.advance(1);
    progress.done();
  }

  private void removeJavaImportsPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Removing java imports", Sequence.fromIterable(nodes).count() + 1);
    final Map<SNode, Iterable<SNode>> toRemove = MapSequence.fromMap(new HashMap<SNode, Iterable<SNode>>());

    myRepository.getModelAccess().runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {
          progress.advance(1);

          if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
            continue;
          }
          if ((AttributeOperations.getAttribute(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))) == null)) {
            continue;
          }

          MapSequence.fromMap(toRemove).put(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), getImportsToRemove(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))));
        }
      }
    });

    runCommand("removing java imports", new Runnable() {
      public void run() {
        for (SNode node : SetSequence.fromSet(MapSequence.fromMap(toRemove).keySet())) {
          Iterable<SNode> imps = MapSequence.fromMap(toRemove).get(node);
          Sequence.fromIterable(imps).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });

          SNode importAnnotation = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
          if (ListSequence.fromList(SLinkOperations.getChildren(importAnnotation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).isEmpty()) {
            SNodeOperations.deleteNode(importAnnotation);
          }
        }
      }
    });

    progress.advance(1);
    progress.done();

  }

  private SNode transformUnqualifedEnum(SNode varRef) {
    

    if (!(SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(varRef)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    if (ref.getTargetNode() != null) {
      return null;
    }

    
    SNode gateway = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved")));

    String enumConstName = ((DynamicReference) ref).getResolveInfo();

    for (SNode enclosingEnum : ListSequence.fromList(SNodeOperations.getNodeAncestors(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass"), false))) {
      SNode enumConstRef = makeEnumConstRef(enclosingEnum, enumConstName);
      if (enumConstRef != null) {
        return enumConstRef;
      }
    }

    SNode root = SNodeOperations.getContainingRoot(varRef);
    if (!(SNodeOperations.isInstanceOf(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
      return null;
    }
    SNode javaImports = AttributeOperations.getAttribute(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
    if ((javaImports == null)) {
      return null;
    }

    for (SNode singleNameImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticSingleName_5230012391903395274", new Object[]{}))) {
      if (!(enumConstName.equals(BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{})))) {
        continue;
      }

      String enumClassCandidateName = BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_withoutLastToken_6148840541591441572", new Object[]{});
      SNode enumClassCandidate = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, enumClassCandidateName});
      if ((enumClassCandidate == null)) {
        
        
        
        return null;
      }
      if (!(SNodeOperations.isInstanceOf(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        return null;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }

    for (SNode onDemandImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticOnDemand_5230012391903366883", new Object[]{}))) {
      SNode claz = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, SPropertyOperations.getString(onDemandImport, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x5a98df4004080866L, 0x1996ec29712bdd92L, "tokens"))});
      if ((claz == null)) {
        continue;
      }
      if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        continue;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }
    return null;
  }
  private SNode makeEnumConstRef(SNode enumClass, final String constName) {
    
    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return constName.equals(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
      }
    });
    if ((enumConst == null)) {
      return null;
    }

    SNode result = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return result;
  }

  private SNode transformUnqualifedEnumUnderSwitch(SNode switchCase, TypeChecker typeChecker) {
    

    SNode caseExp = SLinkOperations.getTarget(switchCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression"));
    if (!(SNodeOperations.isInstanceOf(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(SNodeOperations.cast(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    final String enumConstName = ((DynamicReference) ref).getResolveInfo();

    SNode scrutenee = SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, "jetbrains.mps.baseLanguage.structure.SwitchStatement"), false, false), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, 0x10ef02ec241L, "expression"));
    if ((scrutenee == null)) {
      return null;
    }

    SNode scruteneeType = typeChecker.getTypeOf(scrutenee);
    if (!(SNodeOperations.isInstanceOf(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")))) {
      return null;
    }

    SNode claz = SLinkOperations.getTarget(SNodeOperations.cast(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
    if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
      return null;
    }

    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")).equals(enumConstName);
      }
    });
    SNode enumConstRef = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return enumConstRef;
  }


  private SNode transformLocalCall(SNode localCall) {
    

    SReference ref = SNodeOperations.getReference(localCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")))) {
      return null;
    }

    Scope staticMethodScope = Scope.getScope(SNodeOperations.getParent(localCall), localCall, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration").getDeclarationNode());
    if (staticMethodScope.contains(target)) {
      return null;
    }

    
    SNode smc = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall")));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"), SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")));
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument"))).addElement(SNodeOperations.copyNode(arg));
    }
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument"))).addElement(SNodeOperations.copyNode(arg));
    }

    return smc;
  }

  private SNode transformLocalNameRef(SNode varRef) {
    

    

    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")))) {
      return null;
    }

    
    SNode thisClass = SNodeOperations.getNodeAncestor(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    SNode thatClass = SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    
    if (thisClass == thatClass) {
      
      return null;
    }

    
    SNode sfr = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"), thatClass);
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")));

    return sfr;
  }


  private Iterable<SNode> getImportsToRemove(SNode root) {
    

    final Map<String, SNode> importsByName = MapSequence.fromMap(new HashMap<String, SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SPropertyOperations.getBoolean(it, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x64c0181e603bcfL, 0x64c0181e603bd0L, "onDemand")));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(importsByName).put(BehaviorReflection.invokeNonVirtual(String.class, it, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{}), it);

      }
    });

    boolean unknownPresent = false;
    boolean dynRefsPresent = false;
    Set<SNode> retain = SetSequence.fromSet(new HashSet<SNode>());

    Deque<SNode> stack = DequeSequence.fromDequeNew(new LinkedList<SNode>());
    DequeSequence.fromDequeNew(stack).pushElement(root);

    while (DequeSequence.fromDequeNew(stack).isNotEmpty()) {
      SNode node = DequeSequence.fromDequeNew(stack).popElement();
      DequeSequence.fromDequeNew(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));

      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved"))) {
        unknownPresent = true;
        break;
      }

      Iterable<? extends SReference> refs = node.getReferences();
      for (SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }

        dynRefsPresent = true;

        String resolveInfo = ((DynamicReference) ref).getResolveInfo();
        SetSequence.fromSet(retain).addElement(MapSequence.fromMap(importsByName).get(resolveInfo));
      }
    }

    
    if (unknownPresent) {
      return null;
    }
    
    if (dynRefsPresent == false) {
      
      return SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"));
    }
    
    
    Iterable<SNode> unneeded = Sequence.fromIterable(MapSequence.fromMap(importsByName).values()).subtract(SetSequence.fromSet(retain));
    return unneeded;
  }

  private Iterable<SReference> getTopLevelRefs(SNode node) {
    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")))));
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });

    } else if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });
    }

    for (SNode inner : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, new SAbstractConcept[]{}))) {
      if (SNodeOperations.isInstanceOf(inner, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
        continue;
      }
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));
    }

    return refs;
  }

  private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    Iterable<SNode> members = (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) ? SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, "member")) : Sequence.<SNode>singleton(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember"))));

    for (SNode member : Sequence.fromIterable(members)) {
      if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9408L, "jetbrains.mps.baseLanguage.structure.MethodDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, "returnType")))));
        for (SNode param : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(param, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
        }
        for (SNode thrws : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x10f383d6949L, "throwsItem")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(thrws)));
        }

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(member)));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVarTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    for (SNode block : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, "jetbrains.mps.baseLanguage.structure.StatementList"), false, new SAbstractConcept[]{}))) {

      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getNodeDescendants(block, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"), false, new SAbstractConcept[]{}))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(varDecl, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVariableRefs(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
      }
    }).select(new ISelector<SNode, SReference>() {
      public SReference select(SNode it) {
        return SNodeOperations.getReference(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
      }
    });
  }

  private Iterable<SReference> getDotExpLeftParts(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
      public Iterable<SReference> translate(SNode it) {
        return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
      }
    });
  }

  private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {
    for (SReference ref : refs) {
      if (!(ref instanceof DynamicReference)) {
        continue;
      }
      if (SetSequence.fromSet(myVisitedRefs).contains((SReference) ref)) {
        continue;
      }

      SNode target = ref.getTargetNode();
      if (target == null) {
        continue;
      }

      SNode source = ref.getSourceNode();
      SModelReference targetModel = target.getModel().getReference();

      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId(), ((DynamicReference) ref).getResolveInfo());

      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());
      if (nodeRefs == null) {
        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());
        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);
      }
      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);
    }
  }

  private void updateReference(Map<SNodeReference, List<SReference>> refMap) {
    for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(refMap).keySet())) {
      final SNode node = nodeRef.resolve(myRepository);
      if (node == null) {
        continue;
      }
      final SModel sourceModel = node.getModel();
      ListSequence.fromList(MapSequence.fromMap(refMap).get(nodeRef)).visitAll(new IVisitor<SReference>() {
        public void visit(SReference it) {

          SModelReference targetModelRef = it.getTargetSModelReference();
          if (!(sourceModel.getReference().equals(targetModelRef))) {
            
            ((SModelInternal) sourceModel).addModelImport(targetModelRef, true);
          }

          node.setReference(it.getRole(), it);
        }
      });
    }
  }

  public static Iterable<SReference> deepReferences(SNode node) {

    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(node)));
    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(child)));
    }

    return refs;

    
  }

  private SModel getModel(String pkgFqName, IFile pkgDir) {
    for (SModel model : Sequence.fromIterable(myModule.getModels())) {
      
      
      if (pkgFqName.equals(model.getModelName())) {
        return model;
      }
    }
    return createModel(pkgFqName, pkgDir);
  }
  private SModel createModel(String pkgFqName, IFile pkgDir) {
    SModel modelDescr;
    try {

      if (myCreateInplace) {
        Tuples._2<ModelRoot, String> place = getRootContainingDir(pkgDir);
        ModelRoot modelRoot = place._0();
        String sourceRoot = place._1();
        if (modelRoot == null) {
          LOG.error("Cannot convert to MPS in-place: java sources not under proper model root");
          return null;
        }
        Map<String, String> options = MapSequence.fromMap(new HashMap<String, String>());
        
        
        String fullPath = pkgDir.getPath().replace('\\', '/');
        String sr = sourceRoot.replace('\\', '/');
        MapSequence.fromMap(options).put(ModelFactory.OPTION_RELPATH, FileUtil.getRelativePath(pkgDir.getPath(), sourceRoot, "/"));
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, sourceRoot, options, PersistenceRegistry.getInstance().getFolderModelFactory(FilePerRootModelPersistence.FACTORY_ID));

      } else {
        ModelRoot modelRoot = getFirstRootToCreateModel(pkgFqName);
        if (modelRoot == null) {
          LOG.error("Failed to find model root to create model in");
          return null;
        }
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, null, null, PersistenceRegistry.getInstance().getModelFactory(MPSExtentions.MODEL));
      }

      if (modelDescr == null) {
        LOG.error("Failed to create model: createModel returned null");
        return null;
      }
    } catch (IOException e) {
      LOG.error("Failed to create model", e);
      return null;
    }

    
    
    modelDescr.load();
    ((EditableSModel) modelDescr).setChanged(true);
    ((EditableSModel) modelDescr).save();

    return modelDescr;
  }
  @Nullable
  private ModelRoot getFirstRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (!(root instanceof DefaultModelRoot)) {
        continue;
      }
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }
  private Tuples._2<ModelRoot, String> getRootContainingDir(IFile dir) {
    
    for (ModelRoot modelRoot : Sequence.fromIterable(myModule.getModelRoots())) {
      
      if (!(modelRoot instanceof DefaultModelRoot)) {
        continue;
      }
      for (String sourceRoot : ((DefaultModelRoot) modelRoot).getFiles(FileBasedModelRoot.SOURCE_ROOTS)) {
        if (FileUtil.isSubPath(sourceRoot, dir.getPath())) {
          return MultiTuple.<ModelRoot,String>from(modelRoot, sourceRoot);
        }
      }
    }
    return MultiTuple.<ModelRoot,String>from((ModelRoot) null, (String) null);
  }

}

<code block>
package jetbrains.mps.debugger.java.runtime.evaluation.model;



import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationContainer;
import jetbrains.mps.project.Project;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.debugger.java.runtime.evaluation.container.IEvaluationContainer;
import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.debugger.java.runtime.evaluation.container.BaseLanguagesImportHelper;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.sun.jdi.InvalidStackFrameException;
import org.apache.log4j.Level;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.ide.findusages.model.scopes.ModelsScope;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.CopyUtil;
import com.intellij.openapi.extensions.PluginId;
import com.intellij.ide.plugins.PluginManager;
import jetbrains.mps.debug.api.Debuggers;
import jetbrains.mps.debugger.java.runtime.JavaDebugger;
import java.io.File;
import com.intellij.ide.plugins.IdeaPluginDescriptorImpl;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SNodePointer;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class EvaluationWithContextContainer extends EvaluationContainer {
  private final boolean myIsInWatch;
  private boolean myVariablesInitialized = false;
  protected final EvaluationContext myEvaluationContext;
  public EvaluationWithContextContainer(Project project, DebugSession session, @NotNull SModuleReference containerModule, List<SNodeReference> nodesToImport, boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    super(project, session, containerModule, nodesToImport, onNodeSetUp);
    myIsInWatch = isInWatch;
    myEvaluationContext = new StackFrameContext(session.getUiState());
  }

  @Override
  protected void setUpNode(List<SNodeReference> nodesToImport) {
    EvaluationModule containerModule = (EvaluationModule) myContainerModule.resolve(myDebuggerRepository);
    
    SModel containerModel = SModelRepository.getInstance().getModelDescriptor(myContainerModel);

    setUpDependencies(containerModule, containerModel);


    final SNode evaluatorNode = createEvaluatorNode();
    containerModel.addRootNode(evaluatorNode);
    myNode = evaluatorNode.getReference();

    createVars();
    tryToImport(evaluatorNode, nodesToImport);

    SModelOperations.validateLanguagesAndImports(containerModel, true, true);
  }
  private void setUpDependencies(final EvaluationModule containerModule, SModel containerModel) {
    ListSequence.fromList(myEvaluationContext.getClassPath()).union(ListSequence.fromList(getDebuggerStubPath())).visitAll(new IVisitor<String>() {
      public void visit(String it) {
        containerModule.addClassPathItem(it);
      }
    });
    containerModule.updateModelsSet();

    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x7da4580f9d754603L, 0x816251a896d78375L), "jetbrains.mps.debugger.java.evaluation", -1));
    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x802088974572437dL, 0xb50e8f050cba9566L), "jetbrains.mps.debugger.java.privateMembers", -1));
    containerModule.addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);
  }
  private void tryToImport(final SNode evaluatorNode, List<SNodeReference> nodesToImport) {
    BaseLanguagesImportHelper helper = new EvaluationWithContextContainer.MyBaseLanguagesImportHelper(evaluatorNode);
    helper.tryToImport(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), evaluatorNode, "virtual_getCode_317191294093624551", new Object[]{}), nodesToImport);
  }
  @Override
  protected SNode createEvaluatorNode() {
    SNode evaluatorConcept = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")), null);
    SPropertyOperations.set(evaluatorConcept, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (myIsInWatch));
    AttributeOperations.createAndSetAttrbiute(SLinkOperations.getTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x10093bb8b0669700L, "evaluatedStatements")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x4135c73fbe7fc985L, "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation")), "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation");
    return evaluatorConcept;
  }
  private void createVars() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        fillVariables(SNodeOperations.cast(getNode(), MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")));
      }
    });
  }
  private void fillVariables(SNode evaluatorConcept) {
    try {
      _FunctionTypes._return_P1_E0<? extends SNode, ? super String> createClassifierType = new _FunctionTypes._return_P1_E0<SNode, String>() {
        public SNode invoke(String name) {
          return createClassifierType(name);
        }
      };
      Map<String, VariableDescription> contextVariables = myEvaluationContext.getVariables(createClassifierType);

      Map<String, SNode> declaredVariables = MapSequence.fromMap(new LinkedHashMap<String, SNode>(16, (float) 0.75, false));
      for (SNode var : ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables")))) {
        MapSequence.fromMap(declaredVariables).put(SPropertyOperations.getString(var, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x4db8c07036eb94eeL, "lowLevelName")), var);
      }

      final Set<SNode> foundVars = SetSequence.fromSet(new HashSet<SNode>());
      for (String variable : MapSequence.fromMap(contextVariables).keySet()) {

        String name = variable;
        SNode lowLevelVarNode = MapSequence.fromMap(declaredVariables).get(name);

        if (needUpdateVariables()) {
          
          if (lowLevelVarNode == null) {
            lowLevelVarNode = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariable")));
            ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).addElement(lowLevelVarNode);
            MapSequence.fromMap(declaredVariables).put(name, lowLevelVarNode);
          }
          MapSequence.fromMap(contextVariables).get(variable).updateLowLevelVariable(lowLevelVarNode);
        }

        SetSequence.fromSet(foundVars).addElement(lowLevelVarNode);
      }

      
      Sequence.fromIterable(MapSequence.fromMap(declaredVariables).values()).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SPropertyOperations.set(it, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x554b4e03d5950431L, "isOutOfScope"), "" + (!(SetSequence.fromSet(foundVars).contains(it))));
        }
      });

      if (needUpdateVariables()) {
        
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23615L, "contextNode"), myEvaluationContext.getStaticContextType(createClassifierType));
        
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23613L, "thisNode"), myEvaluationContext.getThisClassifierType(createClassifierType));
      }
      
    } catch (InvalidStackFrameException e) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("InvalidStackFrameException", e);
      }
    }
    myVariablesInitialized = true;
  }

  @Override
  public void updateState() {
    super.updateState();
    if (myDebugSession.getEvaluationProvider().canEvaluate()) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          createVars();
        }
      });
    }
  }
  @Nullable
  private SNode createClassifierType(final String unitFqName) {
    SNode unit = findUnit(unitFqName);
    if (unit == null) {
      return null;
    }
    SNode classifierType = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")));
    SLinkOperations.setTarget(classifierType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), SNodeOperations.cast(unit, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
    return classifierType;
  }
  public SNode findUnit(final String unitName) {
    
    
    SModel stub = findStubForFqName(modelFqNameFromUnitName(unitName));
    if (stub != null) {
      SModel model = stub;
      SNode node = ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.nodes(model, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return eq_v5yv3u_a0a0a0a0a0a0b0d0o(BehaviorReflection.invokeVirtual(String.class, it, "virtual_getUnitName_5067982036267369911", new Object[]{}), unitName) && SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      });
      if (node != null) {
        return node;
      }
    }

    FindUsagesFacade findUsages = FindUsagesFacade.getInstance();
    SAbstractConcept concept = MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept");

    Set<SNode> instances = findUsages.findInstances(new ModelsScope(getCandidateNonStubModels(unitName)), Collections.singleton(concept), false, new EmptyProgressMonitor());
    return SNodeOperations.cast(SetSequence.fromSet(instances).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(((SNode) it), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) && BehaviorReflection.invokeVirtual(String.class, SNodeOperations.cast(it, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept")), "virtual_getUnitName_5067982036267369911", new Object[]{}).equals(unitName);
      }
    }), MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"));
  }
  @Nullable
  private SModel findStubForFqName(String fqName) {
    return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(fqName, SModelStereotype.JAVA_STUB));
  }
  private boolean needUpdateVariables() {
    return !(myVariablesInitialized) || !(myIsInWatch);
  }
  @Override
  public EvaluationWithContextContainer copy(final boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    final SNodeReference reference = myNode;
    return new EvaluationWithContextContainer(myProject, myDebugSession, myContainerModule, ListSequence.fromList(new ArrayList<SNodeReference>()), isInWatch, onNodeSetUp) {
      @Override
      protected SNode createEvaluatorNode() {
        SNode newEvaluator = (SNode) CopyUtil.copyAndPreserveId(reference.resolve(myDebuggerRepository), true);
        SPropertyOperations.set(newEvaluator, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (isInWatch));
        return newEvaluator;
      }
    };
  }
  public static List<String> getDebuggerStubPath() {
    PluginId apiPlugin = PluginManager.getPluginByClassName(Debuggers.class.getName());
    PluginId javaPlugin = PluginManager.getPluginByClassName(JavaDebugger.class.getName());

    List<File> paths = ListSequence.fromList(new ArrayList<File>());
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(apiPlugin)).getClassPath()));
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(javaPlugin)).getClassPath()));

    return ListSequence.fromList(paths).select(new ISelector<File, String>() {
      public String select(File it) {
        return (String) it.getAbsolutePath();
      }
    }).toListSequence();
  }
  public static Iterable<SModel> getCandidateNonStubModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }
  public static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ? "" : unitName.substring(0, lastDot)));
  }
  private class MyBaseLanguagesImportHelper extends BaseLanguagesImportHelper {
    private final SNode myEvaluatorNode;
    public MyBaseLanguagesImportHelper(SNode evaluatorNode) {
      myEvaluatorNode = evaluatorNode;
    }
    @Override
    public SNode findVariable(final SReference variableReference) {
      SNode matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode variable) {
          return eq_v5yv3u_a0a0a0a0a0a0a2v(SNodePointer.deserialize(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x6db8b4aef007e84fL, "highLevelNodeId"))), SLinkOperations.getTargetNode(variableReference).getReference());
        }
      });
      if (matchingVar == null) {
        matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode variable) {
            return eq_v5yv3u_a0a0a0a0a0a0a1a2v(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTargetNode(variableReference), MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }
        });
      }
      return matchingVar;
    }
    @Override
    public SNode createVariableReference(SNode variable) {
      SNode newVariableReference = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7d9a547f857a394bL, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariableReference")));
      SLinkOperations.setTarget(newVariableReference, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x4c4b92003e49a704L, 0x4c4b92003e49a705L, "baseVariableDeclaration"), variable);
      return newVariableReference;
    }
  }
  protected static Logger LOG = LogManager.getLogger(EvaluationWithContextContainer.class);
  private static boolean eq_v5yv3u_a0a0a0a0a0a0b0d0o(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a1a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}

<code block>
package jetbrains.mps.migration.component.util;



import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.ArrayList;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + BehaviorReflection.invokeNonVirtualStatic(String.class, SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript").getDeclarationNode()), "call_getGeneratedClassName_8648538385393994830", new Object[]{});
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchScript(MigrationScriptReference scriptReference) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0u(md, current);
    if (script == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static boolean areDepsSatisfied(final ScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        result.value = isMigrationRequired(mpsProject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean languageMig = isLanguageMigrationRequired(modules);
    return projectMig || languageMig;
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (fetchScript(new MigrationScriptReference(lang, v)) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule,SLanguage,Integer>from(module, lang, v));
                
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isLanguageMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
      public boolean accept(final AbstractModule module) {
        return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
          public boolean accept(MigrationScriptReference item) {
            return MigrationsUtil.isMigrationNeeded(item.getLanguage(), item.getFromVersion(), module);
          }
        });
      }
    });
  }

  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    final SLanguage toLanguage = MetaAdapterFactory.getLanguage(fromLanguage, toVersion);
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(fromLanguage);
      ((SModelInternal) model).addLanguage(toLanguage);
    }

    return true;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(mpsProject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int languageStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(new ISelector<AbstractModule, Integer>() {
          public Integer select(AbstractModule module) {
            int scripts = 0;
            for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
              int currentLangVersion = lang.getLanguageVersion();
              int ver = module.getUsedLanguageVersion(lang);

              ver = Math.max(ver, 0);
              currentLangVersion = Math.max(currentLangVersion, 0);

              if (ver < currentLangVersion) {
                scripts += currentLangVersion - ver;
              }
            }
            return scripts;
          }
        });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextLanguageStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());

        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
          public boolean accept(final AbstractModule module) {
            return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
              public boolean accept(MigrationScriptReference it) {
                if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {
                  return false;
                }
                MigrationScript loaded = fetchScript(it);
                if (loaded == null) {
                  return false;
                }
                final ScriptApplied applied = new ScriptApplied(loaded, module);
                if (!(areDepsSatisfied(applied))) {
                  return false;
                }
                result.value = new MigrationManager.MigrationStep() {
                  public String getDescription() {
                    return applied.toString();
                  }
                  public boolean execute() {
                    final Wrappers._boolean res = new Wrappers._boolean();
                    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                      public void run() {
                        res.value = executeScript(applied);
                      }
                    });
                    return res.value;
                  }
                  public void forceExecutionNextTime() {
                    throw new UnsupportedOperationException("not supported for language migrations");
                  }
                };
                return true;
              }
            });
          }
        });
      }
    }));

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0u(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}

<code block>
package jetbrains.mps.lang.editor.structure;



import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;

public enum CellActionId {
  RIGHT_TRANSFORM("RIGHT_TRANSFORM", "right_transform_action_id"),
  DELETE("DELETE", "delete_action_id"),
  INSERT("INSERT", "insert_action_id"),
  INSERT_BEFORE("INSERT_BEFORE", "insert_before_action_id"),
  BACKSPACE("BACKSPACE", "backspace_action_id"),
  DELETE_TO_WORD_END("DELETE_TO_WORD_END", "delete_to_word_end_action_id"),
  COPY("COPY", "copy_action_id"),
  CUT("CUT", "cut_action_id"),
  PASTE("PASTE", "paste_action_id"),
  PASTE_BEFORE("PASTE_BEFORE", "paste_before_action_id"),
  PASTE_AFTER("PASTE_AFTER", "paste_after_action_id"),
  LEFT("LEFT", "left_action_id"),
  RIGHT("RIGHT", "right_action_id"),
  UP("UP", "up_action_id"),
  DOWN("DOWN", "down_action_id"),
  NEXT("NEXT", "next_action_id"),
  PREV("PREV", "prev_action_id"),
  HOME("HOME", "home_action_id"),
  END("END", "end_action_id"),
  PAGE_UP("PAGE_UP", "page_up_action_id"),
  PAGE_DOWN("PAGE_DOWN", "page_down_action_id"),
  ROOT_HOME("ROOT_HOME", "root_home_action_id"),
  ROOT_END("ROOT_END", "root_end_action_id"),
  LOCAL_HOME("LOCAL_HOME", "local_home_action_id"),
  LOCAL_END("LOCAL_END", "local_end_action_id"),
  SELECT_LEFT("SELECT_LEFT", "select_left_action_id"),
  SELECT_RIGHT("SELECT_RIGHT", "select_right_action_id"),
  SELECT_UP("SELECT_UP", "select_up_action_id"),
  SELECT_DOWN("SELECT_DOWN", "select_down_action_id"),
  SELECT_HOME("SELECT_HOME", "select_home_action_id"),
  SELECT_END("SELECT_END", "select_end_action_id"),
  SELECT_LOCAL_END("SELECT_LOCAL_END", "select_local_end_action_id"),
  SELECT_LOCAL_HOME("SELECT_LOCAL_HOME", "select_local_home_action_id"),
  SELECT_NEXT("SELECT_NEXT", "select_next_action_id"),
  SELECT_PREVIOUS("SELECT_PREVIOUS", "select_previous_action_id"),
  LEFT_TRANSFORM("LEFT_TRANSFORM", "left_transform_action_id"),
  COMPLETE("COMPLETE", "complete_action_id"),
  COMPLETE_SMART("COMPLETE_SMART", "complete_smart_action_id"),
  FOLD("FOLD", "fold_action_id"),
  UNFOLD("UNFOLD", "unfold_action_id"),
  FOLD_ALL("FOLD_ALL", "fold_all_action_id"),
  UNFOLD_ALL("UNFOLD_ALL", "unfold_all_action_id"),
  TOGGLE_FOLDING("TOGGLE_FOLDING", "toggle_folding_action_id"),
  SHOW_MESSAGE("SHOW_MESSAGE", "show_message_action_id"),
  COMMENT("COMMENT", "comment_out_action_id");

  private String myName;
  public String getName() {
    return this.myName;
  }
  public String getValueAsString() {
    return this.myValue;
  }
  public static List<CellActionId> getConstants() {
    List<CellActionId> list = ListSequence.fromList(new LinkedList<CellActionId>());
    ListSequence.fromList(list).addElement(CellActionId.RIGHT_TRANSFORM);
    ListSequence.fromList(list).addElement(CellActionId.DELETE);
    ListSequence.fromList(list).addElement(CellActionId.INSERT);
    ListSequence.fromList(list).addElement(CellActionId.INSERT_BEFORE);
    ListSequence.fromList(list).addElement(CellActionId.BACKSPACE);
    ListSequence.fromList(list).addElement(CellActionId.DELETE_TO_WORD_END);
    ListSequence.fromList(list).addElement(CellActionId.COPY);
    ListSequence.fromList(list).addElement(CellActionId.CUT);
    ListSequence.fromList(list).addElement(CellActionId.PASTE);
    ListSequence.fromList(list).addElement(CellActionId.PASTE_BEFORE);
    ListSequence.fromList(list).addElement(CellActionId.PASTE_AFTER);
    ListSequence.fromList(list).addElement(CellActionId.LEFT);
    ListSequence.fromList(list).addElement(CellActionId.RIGHT);
    ListSequence.fromList(list).addElement(CellActionId.UP);
    ListSequence.fromList(list).addElement(CellActionId.DOWN);
    ListSequence.fromList(list).addElement(CellActionId.NEXT);
    ListSequence.fromList(list).addElement(CellActionId.PREV);
    ListSequence.fromList(list).addElement(CellActionId.HOME);
    ListSequence.fromList(list).addElement(CellActionId.END);
    ListSequence.fromList(list).addElement(CellActionId.PAGE_UP);
    ListSequence.fromList(list).addElement(CellActionId.PAGE_DOWN);
    ListSequence.fromList(list).addElement(CellActionId.ROOT_HOME);
    ListSequence.fromList(list).addElement(CellActionId.ROOT_END);
    ListSequence.fromList(list).addElement(CellActionId.LOCAL_HOME);
    ListSequence.fromList(list).addElement(CellActionId.LOCAL_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LEFT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_RIGHT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_UP);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_DOWN);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_HOME);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LOCAL_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LOCAL_HOME);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_NEXT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_PREVIOUS);
    ListSequence.fromList(list).addElement(CellActionId.LEFT_TRANSFORM);
    ListSequence.fromList(list).addElement(CellActionId.COMPLETE);
    ListSequence.fromList(list).addElement(CellActionId.COMPLETE_SMART);
    ListSequence.fromList(list).addElement(CellActionId.FOLD);
    ListSequence.fromList(list).addElement(CellActionId.UNFOLD);
    ListSequence.fromList(list).addElement(CellActionId.FOLD_ALL);
    ListSequence.fromList(list).addElement(CellActionId.UNFOLD_ALL);
    ListSequence.fromList(list).addElement(CellActionId.TOGGLE_FOLDING);
    ListSequence.fromList(list).addElement(CellActionId.SHOW_MESSAGE);
    ListSequence.fromList(list).addElement(CellActionId.COMMENT);
    return list;
  }
  public static CellActionId getDefault() {
    return CellActionId.RIGHT_TRANSFORM;
  }
  public static CellActionId parseValue(String value) {
    if (value == null) {
      return CellActionId.getDefault();
    }
    if (value.equals(CellActionId.RIGHT_TRANSFORM.getValueAsString())) {
      return CellActionId.RIGHT_TRANSFORM;
    }
    if (value.equals(CellActionId.DELETE.getValueAsString())) {
      return CellActionId.DELETE;
    }
    if (value.equals(CellActionId.INSERT.getValueAsString())) {
      return CellActionId.INSERT;
    }
    if (value.equals(CellActionId.INSERT_BEFORE.getValueAsString())) {
      return CellActionId.INSERT_BEFORE;
    }
    if (value.equals(CellActionId.BACKSPACE.getValueAsString())) {
      return CellActionId.BACKSPACE;
    }
    if (value.equals(CellActionId.DELETE_TO_WORD_END.getValueAsString())) {
      return CellActionId.DELETE_TO_WORD_END;
    }
    if (value.equals(CellActionId.COPY.getValueAsString())) {
      return CellActionId.COPY;
    }
    if (value.equals(CellActionId.CUT.getValueAsString())) {
      return CellActionId.CUT;
    }
    if (value.equals(CellActionId.PASTE.getValueAsString())) {
      return CellActionId.PASTE;
    }
    if (value.equals(CellActionId.PASTE_BEFORE.getValueAsString())) {
      return CellActionId.PASTE_BEFORE;
    }
    if (value.equals(CellActionId.PASTE_AFTER.getValueAsString())) {
      return CellActionId.PASTE_AFTER;
    }
    if (value.equals(CellActionId.LEFT.getValueAsString())) {
      return CellActionId.LEFT;
    }
    if (value.equals(CellActionId.RIGHT.getValueAsString())) {
      return CellActionId.RIGHT;
    }
    if (value.equals(CellActionId.UP.getValueAsString())) {
      return CellActionId.UP;
    }
    if (value.equals(CellActionId.DOWN.getValueAsString())) {
      return CellActionId.DOWN;
    }
    if (value.equals(CellActionId.NEXT.getValueAsString())) {
      return CellActionId.NEXT;
    }
    if (value.equals(CellActionId.PREV.getValueAsString())) {
      return CellActionId.PREV;
    }
    if (value.equals(CellActionId.HOME.getValueAsString())) {
      return CellActionId.HOME;
    }
    if (value.equals(CellActionId.END.getValueAsString())) {
      return CellActionId.END;
    }
    if (value.equals(CellActionId.PAGE_UP.getValueAsString())) {
      return CellActionId.PAGE_UP;
    }
    if (value.equals(CellActionId.PAGE_DOWN.getValueAsString())) {
      return CellActionId.PAGE_DOWN;
    }
    if (value.equals(CellActionId.ROOT_HOME.getValueAsString())) {
      return CellActionId.ROOT_HOME;
    }
    if (value.equals(CellActionId.ROOT_END.getValueAsString())) {
      return CellActionId.ROOT_END;
    }
    if (value.equals(CellActionId.LOCAL_HOME.getValueAsString())) {
      return CellActionId.LOCAL_HOME;
    }
    if (value.equals(CellActionId.LOCAL_END.getValueAsString())) {
      return CellActionId.LOCAL_END;
    }
    if (value.equals(CellActionId.SELECT_LEFT.getValueAsString())) {
      return CellActionId.SELECT_LEFT;
    }
    if (value.equals(CellActionId.SELECT_RIGHT.getValueAsString())) {
      return CellActionId.SELECT_RIGHT;
    }
    if (value.equals(CellActionId.SELECT_UP.getValueAsString())) {
      return CellActionId.SELECT_UP;
    }
    if (value.equals(CellActionId.SELECT_DOWN.getValueAsString())) {
      return CellActionId.SELECT_DOWN;
    }
    if (value.equals(CellActionId.SELECT_HOME.getValueAsString())) {
      return CellActionId.SELECT_HOME;
    }
    if (value.equals(CellActionId.SELECT_END.getValueAsString())) {
      return CellActionId.SELECT_END;
    }
    if (value.equals(CellActionId.SELECT_LOCAL_END.getValueAsString())) {
      return CellActionId.SELECT_LOCAL_END;
    }
    if (value.equals(CellActionId.SELECT_LOCAL_HOME.getValueAsString())) {
      return CellActionId.SELECT_LOCAL_HOME;
    }
    if (value.equals(CellActionId.SELECT_NEXT.getValueAsString())) {
      return CellActionId.SELECT_NEXT;
    }
    if (value.equals(CellActionId.SELECT_PREVIOUS.getValueAsString())) {
      return CellActionId.SELECT_PREVIOUS;
    }
    if (value.equals(CellActionId.LEFT_TRANSFORM.getValueAsString())) {
      return CellActionId.LEFT_TRANSFORM;
    }
    if (value.equals(CellActionId.COMPLETE.getValueAsString())) {
      return CellActionId.COMPLETE;
    }
    if (value.equals(CellActionId.COMPLETE_SMART.getValueAsString())) {
      return CellActionId.COMPLETE_SMART;
    }
    if (value.equals(CellActionId.FOLD.getValueAsString())) {
      return CellActionId.FOLD;
    }
    if (value.equals(CellActionId.UNFOLD.getValueAsString())) {
      return CellActionId.UNFOLD;
    }
    if (value.equals(CellActionId.FOLD_ALL.getValueAsString())) {
      return CellActionId.FOLD_ALL;
    }
    if (value.equals(CellActionId.UNFOLD_ALL.getValueAsString())) {
      return CellActionId.UNFOLD_ALL;
    }
    if (value.equals(CellActionId.TOGGLE_FOLDING.getValueAsString())) {
      return CellActionId.TOGGLE_FOLDING;
    }
    if (value.equals(CellActionId.SHOW_MESSAGE.getValueAsString())) {
      return CellActionId.SHOW_MESSAGE;
    }
    if (value.equals(CellActionId.COMMENT.getValueAsString())) {
      return CellActionId.COMMENT;
    }
    return CellActionId.getDefault();
  }
  private String myValue;
  CellActionId(String name, String value) {
    this.myName = name;
    this.myValue = value;
  }
  public String getValue() {
    return this.myValue;
  }
}

<code block>
package jetbrains.mps.ide.editor.actions;



import jetbrains.mps.workbench.action.BaseAction;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.ide.editor.MPSEditorDataKeys;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.openapi.editor.cells.CellActionType;

public class Comment_Action extends BaseAction {
  private static final Icon ICON = null;
  public Comment_Action() {
    super("Comment Out", "", ICON);
    this.setIsAlwaysVisible(false);
    this.setExecuteOutsideCommand(false);
  }
  @Override
  public boolean isDumbAware() {
    return true;
  }
  @Override
  public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {
    Selection selection = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT).getSelectionManager().getSelection();
    return selection != null && EditorActionUtils.isWriteActionEnabled(event.getData(MPSEditorDataKeys.EDITOR_COMPONENT), selection.getSelectedCells());
  }
  @Override
  public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {
    this.setEnabledState(event.getPresentation(), this.isApplicable(event, _params));
  }
  @Override
  protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {
    if (!(super.collectActionData(event, _params))) {
      return false;
    }
    {
      EditorComponent editorComponent = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT);
      if (editorComponent != null && editorComponent.isInvalid()) {
        editorComponent = null;
      }
      if (editorComponent == null) {
        return false;
      }
    }
    return true;
  }
  @Override
  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {
    event.getData(MPSEditorDataKeys.EDITOR_COMPONENT).getSelectionManager().getSelection().executeAction(CellActionType.COMMENT);
  }
}

<code block>

package jetbrains.mps.lang.editor.cellProviders;

import jetbrains.mps.editor.runtime.impl.cellActions.CellAction_Comment;
import jetbrains.mps.editor.runtime.impl.cellActions.CellAction_DeleteSmart;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.nodeEditor.cells.EditorCell_Error;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNode;



public abstract class SingleRoleCellProvider {

  protected final SContainmentLink myContainmentLink;
  protected final SNode myOwnerNode;
  protected final EditorContext myEditorContext;

  public SingleRoleCellProvider(final SNode ownerNode, final SContainmentLink containmentLink, EditorContext editorContext) {
    myOwnerNode = ownerNode;
    myContainmentLink = containmentLink;
    myEditorContext = editorContext;
  }

  protected EditorCell createChildCell(EditorContext editorContext, SNode child) {
    EditorCell editorCell = editorContext.getEditorComponent().getUpdater().getCurrentUpdateSession().updateChildNodeCell(child);
    
    editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(myOwnerNode, myContainmentLink.getDeclarationNode(), child));
    editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(myOwnerNode, myContainmentLink.getDeclarationNode(), child));
    return editorCell;
  }

  public EditorCell createCell() {
    EditorCell_Collection resultCell = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(myEditorContext, myOwnerNode);
    resultCell.setSelectable(false);
    for (SNode child : getNodesToPresent()) {
      resultCell.addEditorCell(createChildCell(myEditorContext, child));
    }
    if (isChildEmpty()) {
      resultCell.addEditorCell(createEmptyCell());
    }
    return resultCell;
  }

  private boolean isChildEmpty() {
    return !myOwnerNode.getChildren(myContainmentLink).iterator().hasNext();
  }

  protected EditorCell createEmptyCell() {
    EditorCell_Label result = myContainmentLink.isOptional() ?
        new EditorCell_Constant(myEditorContext, myOwnerNode, "") :
        new EditorCell_Error(myEditorContext, myOwnerNode, getNoTargetText());
    result.setDefaultText(getNoTargetText());
    result.setAction(CellActionType.COMMENT, new CellAction_Comment(myOwnerNode));
    return result;
  }

  protected String getNoTargetText() {
    
    return "<no " + myContainmentLink.getRoleName() + ">";
  }
  protected Iterable<SNode> getNodesToPresent() {
    return AttributeOperations.getChildNodesAndAttributes(myOwnerNode, myContainmentLink);
  }
}


<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class Cell_Action_Uncomment extends AbstractCellAction {
  private final SNode myNode;

  public Cell_Action_Uncomment(@NotNull SNode node) {
    this.myNode = node;
  }

  @Override
  public boolean canExecute(EditorContext context) {
    return SNodeOperations.getParent(myNode) != null;
  }

  public void execute(EditorContext editorContext) {
    SNode commentedNode = CommentUtil.uncomment(myNode);
  }

}

<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;

public class CellAction_Comment extends AbstractCellAction {
  private final SNode myNode;
  private SNode myParent;

  public CellAction_Comment(@NotNull SNode node) {
    this.myNode = node;
    this.myParent = SNodeOperations.getParent(myNode);
  }

  @Override
  public boolean canExecute(EditorContext editorContext) {
    Selection selection = editorContext.getSelectionManager().getSelection();
    return this.myParent != null && selection != null && selection instanceof SingularSelection && needToComment(editorContext);
  }

  public void execute(EditorContext editorContext) {
    Selection selection = editorContext.getSelectionManager().getSelection();
    SNode newComment = CommentUtil.commentOut(myNode);
  }
  private boolean needToComment(EditorContext editorContext) {
    boolean needToComment;
    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(myNode), MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute"))) {
      needToComment = false;
    } else if ((SNodeOperations.getNodeAncestor(myNode, MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute"), false, false) == null)) {
      needToComment = true;
    } else {
      Selection selection = editorContext.getSelectionManager().getSelection();
      if ((selection instanceof EditorCellLabelSelection && !(((EditorCellLabelSelection) selection).hasNonTrivialSelection()))) {
        needToComment = false;
      } else {
        needToComment = true;
      }
    }
    return needToComment;
  }

}

<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;

public class CommentUtil {
  private CommentUtil() {
  }
  
  @NotNull
  public static SNode commentOut(@NotNull SNode node) {
    SNode parent = SNodeOperations.getParent(node);
    if (parent == null) {
      throw new IllegalArgumentException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, node, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + node.getNodeId());
    }
    SContainmentLink containmentLink = node.getContainmentLink();
    assert containmentLink != null;
    SNode newComment = CommentUtil.createAndInsertNewComment(parent, containmentLink, node);
    SAbstractConcept targetConcept = containmentLink.getTargetConcept();
    if (!(containmentLink.isMultiple()) && !(containmentLink.isOptional())) {
      parent.addChild(containmentLink, NodeFactoryManager.createNode(targetConcept, null, parent, SNodeOperations.getModel(parent)));
    }
    return newComment;
  }


  
  public static SNode uncomment(@NotNull SNode attribute) {
    SNode parent = SNodeOperations.getParent(attribute);
    if (parent == null) {
      throw new IllegalArgumentException("Node to uncomment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, attribute, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + attribute.getNodeId());
    }
    SContainmentLink containmentLink = BehaviorReflection.invokeNonVirtual(SContainmentLink.class, attribute, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_getLink_709746936026609871", new Object[]{});
    SNode commentedNode = SLinkOperations.getTarget(attribute, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
    if (containmentLink != null) {
      if (!(containmentLink.isMultiple())) {
        SNode currentChild = ListSequence.fromList(SNodeOperations.getChildren(parent, containmentLink)).first();
        if ((currentChild != null)) {
          createAndInsertNewComment(parent, containmentLink, currentChild);
        }
      }
      if (commentedNode != null) {
        attribute.removeChild(commentedNode);
        insertNodeNearComment(parent, attribute, containmentLink, commentedNode);
      }
    }
    SNodeOperations.deleteNode(attribute);
    return commentedNode;
  }
  @NotNull
  private static SNode createAndInsertNewComment(SNode parent, SContainmentLink containmentLink, SNode anchor) {
    SNode newComment = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
    insertInProperPlace(parent, anchor, containmentLink, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment);
    BehaviorReflection.invokeNonVirtual(Void.class, newComment, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_setLink_709746936026609906", new Object[]{containmentLink});
    SLinkOperations.setTarget(newComment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"), anchor);
    return newComment;
  }


  private static void insertNodeNearComment(SNode parent, SNode anchorComment, SContainmentLink linkToInsert, SNode nodeToInsert) {
    insertInProperPlace(parent, anchorComment, linkToInsert, linkToInsert, nodeToInsert);
  }

  private static void insertInProperPlace(SNode parent, SNode anchor, SContainmentLink anchorLink, SContainmentLink linkToInsert, SNode newChild) {
    SNode prev = getPrevious(parent, anchor, anchorLink);
    SNode next = getNext(parent, anchor, anchorLink);
    if (prev != null) {
      parent.insertChildAfter(linkToInsert, newChild, prev);
    } else if (next != null) {
      parent.insertChildBefore(linkToInsert, newChild, next);
    } else {
      parent.addChild(linkToInsert, newChild);
    }
  }



  private static SNode getPrevious(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    SNode prev = null;
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        return prev;
      }
    }
    return null;
  }
  private static SNode getNext(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        if (iterator.hasNext()) {
          return iterator.next();
        }
      }
    }
    return null;
  }
}

<code block>

package jetbrains.mps.openapi.editor.cells;


public enum CellActionType {
  INSERT,
  INSERT_BEFORE,
  DELETE,
  BACKSPACE,
  DELETE_TO_WORD_END,


  COPY,
  CUT,
  PASTE,
  PASTE_BEFORE,
  PASTE_AFTER,

  LEFT,
  RIGHT,
  UP,
  DOWN,
  NEXT,
  PREV,
  HOME,
  END,
  PAGE_UP,
  PAGE_DOWN,
  ROOT_HOME,
  ROOT_END,
  LOCAL_HOME,
  LOCAL_END,

  SELECT_LEFT,
  SELECT_RIGHT,
  SELECT_UP,
  SELECT_DOWN,
  SELECT_HOME,
  SELECT_END,
  SELECT_LOCAL_END,
  SELECT_LOCAL_HOME,
  SELECT_NEXT,
  SELECT_PREVIOUS,

  RIGHT_TRANSFORM,
  LEFT_TRANSFORM,

  COMPLETE,
  COMPLETE_SMART,

  FOLD,
  UNFOLD,
  FOLD_ALL,
  UNFOLD_ALL,
  TOGGLE_FOLDING,

  SHOW_MESSAGE,
  CLEAR_SELECTION,

  COMMENT
}

<code block>
package jetbrains.mps.lang.editor.structure;



import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;

public enum CellActionId {
  RIGHT_TRANSFORM("RIGHT_TRANSFORM", "right_transform_action_id"),
  DELETE("DELETE", "delete_action_id"),
  INSERT("INSERT", "insert_action_id"),
  INSERT_BEFORE("INSERT_BEFORE", "insert_before_action_id"),
  BACKSPACE("BACKSPACE", "backspace_action_id"),
  DELETE_TO_WORD_END("DELETE_TO_WORD_END", "delete_to_word_end_action_id"),
  COPY("COPY", "copy_action_id"),
  CUT("CUT", "cut_action_id"),
  PASTE("PASTE", "paste_action_id"),
  PASTE_BEFORE("PASTE_BEFORE", "paste_before_action_id"),
  PASTE_AFTER("PASTE_AFTER", "paste_after_action_id"),
  LEFT("LEFT", "left_action_id"),
  RIGHT("RIGHT", "right_action_id"),
  UP("UP", "up_action_id"),
  DOWN("DOWN", "down_action_id"),
  NEXT("NEXT", "next_action_id"),
  PREV("PREV", "prev_action_id"),
  HOME("HOME", "home_action_id"),
  END("END", "end_action_id"),
  PAGE_UP("PAGE_UP", "page_up_action_id"),
  PAGE_DOWN("PAGE_DOWN", "page_down_action_id"),
  ROOT_HOME("ROOT_HOME", "root_home_action_id"),
  ROOT_END("ROOT_END", "root_end_action_id"),
  LOCAL_HOME("LOCAL_HOME", "local_home_action_id"),
  LOCAL_END("LOCAL_END", "local_end_action_id"),
  SELECT_LEFT("SELECT_LEFT", "select_left_action_id"),
  SELECT_RIGHT("SELECT_RIGHT", "select_right_action_id"),
  SELECT_UP("SELECT_UP", "select_up_action_id"),
  SELECT_DOWN("SELECT_DOWN", "select_down_action_id"),
  SELECT_HOME("SELECT_HOME", "select_home_action_id"),
  SELECT_END("SELECT_END", "select_end_action_id"),
  SELECT_LOCAL_END("SELECT_LOCAL_END", "select_local_end_action_id"),
  SELECT_LOCAL_HOME("SELECT_LOCAL_HOME", "select_local_home_action_id"),
  SELECT_NEXT("SELECT_NEXT", "select_next_action_id"),
  SELECT_PREVIOUS("SELECT_PREVIOUS", "select_previous_action_id"),
  LEFT_TRANSFORM("LEFT_TRANSFORM", "left_transform_action_id"),
  COMPLETE("COMPLETE", "complete_action_id"),
  COMPLETE_SMART("COMPLETE_SMART", "complete_smart_action_id"),
  FOLD("FOLD", "fold_action_id"),
  UNFOLD("UNFOLD", "unfold_action_id"),
  FOLD_ALL("FOLD_ALL", "fold_all_action_id"),
  UNFOLD_ALL("UNFOLD_ALL", "unfold_all_action_id"),
  TOGGLE_FOLDING("TOGGLE_FOLDING", "toggle_folding_action_id"),
  SHOW_MESSAGE("SHOW_MESSAGE", "show_message_action_id"),
  COMMENT("COMMENT", "comment_out_action_id"),
  UNCOMMENT("UNCOMMENT", "uncomment_action_id");

  private String myName;
  public String getName() {
    return this.myName;
  }
  public String getValueAsString() {
    return this.myValue;
  }
  public static List<CellActionId> getConstants() {
    List<CellActionId> list = ListSequence.fromList(new LinkedList<CellActionId>());
    ListSequence.fromList(list).addElement(CellActionId.RIGHT_TRANSFORM);
    ListSequence.fromList(list).addElement(CellActionId.DELETE);
    ListSequence.fromList(list).addElement(CellActionId.INSERT);
    ListSequence.fromList(list).addElement(CellActionId.INSERT_BEFORE);
    ListSequence.fromList(list).addElement(CellActionId.BACKSPACE);
    ListSequence.fromList(list).addElement(CellActionId.DELETE_TO_WORD_END);
    ListSequence.fromList(list).addElement(CellActionId.COPY);
    ListSequence.fromList(list).addElement(CellActionId.CUT);
    ListSequence.fromList(list).addElement(CellActionId.PASTE);
    ListSequence.fromList(list).addElement(CellActionId.PASTE_BEFORE);
    ListSequence.fromList(list).addElement(CellActionId.PASTE_AFTER);
    ListSequence.fromList(list).addElement(CellActionId.LEFT);
    ListSequence.fromList(list).addElement(CellActionId.RIGHT);
    ListSequence.fromList(list).addElement(CellActionId.UP);
    ListSequence.fromList(list).addElement(CellActionId.DOWN);
    ListSequence.fromList(list).addElement(CellActionId.NEXT);
    ListSequence.fromList(list).addElement(CellActionId.PREV);
    ListSequence.fromList(list).addElement(CellActionId.HOME);
    ListSequence.fromList(list).addElement(CellActionId.END);
    ListSequence.fromList(list).addElement(CellActionId.PAGE_UP);
    ListSequence.fromList(list).addElement(CellActionId.PAGE_DOWN);
    ListSequence.fromList(list).addElement(CellActionId.ROOT_HOME);
    ListSequence.fromList(list).addElement(CellActionId.ROOT_END);
    ListSequence.fromList(list).addElement(CellActionId.LOCAL_HOME);
    ListSequence.fromList(list).addElement(CellActionId.LOCAL_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LEFT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_RIGHT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_UP);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_DOWN);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_HOME);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LOCAL_END);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_LOCAL_HOME);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_NEXT);
    ListSequence.fromList(list).addElement(CellActionId.SELECT_PREVIOUS);
    ListSequence.fromList(list).addElement(CellActionId.LEFT_TRANSFORM);
    ListSequence.fromList(list).addElement(CellActionId.COMPLETE);
    ListSequence.fromList(list).addElement(CellActionId.COMPLETE_SMART);
    ListSequence.fromList(list).addElement(CellActionId.FOLD);
    ListSequence.fromList(list).addElement(CellActionId.UNFOLD);
    ListSequence.fromList(list).addElement(CellActionId.FOLD_ALL);
    ListSequence.fromList(list).addElement(CellActionId.UNFOLD_ALL);
    ListSequence.fromList(list).addElement(CellActionId.TOGGLE_FOLDING);
    ListSequence.fromList(list).addElement(CellActionId.SHOW_MESSAGE);
    ListSequence.fromList(list).addElement(CellActionId.COMMENT);
    ListSequence.fromList(list).addElement(CellActionId.UNCOMMENT);
    return list;
  }
  public static CellActionId getDefault() {
    return CellActionId.RIGHT_TRANSFORM;
  }
  public static CellActionId parseValue(String value) {
    if (value == null) {
      return CellActionId.getDefault();
    }
    if (value.equals(CellActionId.RIGHT_TRANSFORM.getValueAsString())) {
      return CellActionId.RIGHT_TRANSFORM;
    }
    if (value.equals(CellActionId.DELETE.getValueAsString())) {
      return CellActionId.DELETE;
    }
    if (value.equals(CellActionId.INSERT.getValueAsString())) {
      return CellActionId.INSERT;
    }
    if (value.equals(CellActionId.INSERT_BEFORE.getValueAsString())) {
      return CellActionId.INSERT_BEFORE;
    }
    if (value.equals(CellActionId.BACKSPACE.getValueAsString())) {
      return CellActionId.BACKSPACE;
    }
    if (value.equals(CellActionId.DELETE_TO_WORD_END.getValueAsString())) {
      return CellActionId.DELETE_TO_WORD_END;
    }
    if (value.equals(CellActionId.COPY.getValueAsString())) {
      return CellActionId.COPY;
    }
    if (value.equals(CellActionId.CUT.getValueAsString())) {
      return CellActionId.CUT;
    }
    if (value.equals(CellActionId.PASTE.getValueAsString())) {
      return CellActionId.PASTE;
    }
    if (value.equals(CellActionId.PASTE_BEFORE.getValueAsString())) {
      return CellActionId.PASTE_BEFORE;
    }
    if (value.equals(CellActionId.PASTE_AFTER.getValueAsString())) {
      return CellActionId.PASTE_AFTER;
    }
    if (value.equals(CellActionId.LEFT.getValueAsString())) {
      return CellActionId.LEFT;
    }
    if (value.equals(CellActionId.RIGHT.getValueAsString())) {
      return CellActionId.RIGHT;
    }
    if (value.equals(CellActionId.UP.getValueAsString())) {
      return CellActionId.UP;
    }
    if (value.equals(CellActionId.DOWN.getValueAsString())) {
      return CellActionId.DOWN;
    }
    if (value.equals(CellActionId.NEXT.getValueAsString())) {
      return CellActionId.NEXT;
    }
    if (value.equals(CellActionId.PREV.getValueAsString())) {
      return CellActionId.PREV;
    }
    if (value.equals(CellActionId.HOME.getValueAsString())) {
      return CellActionId.HOME;
    }
    if (value.equals(CellActionId.END.getValueAsString())) {
      return CellActionId.END;
    }
    if (value.equals(CellActionId.PAGE_UP.getValueAsString())) {
      return CellActionId.PAGE_UP;
    }
    if (value.equals(CellActionId.PAGE_DOWN.getValueAsString())) {
      return CellActionId.PAGE_DOWN;
    }
    if (value.equals(CellActionId.ROOT_HOME.getValueAsString())) {
      return CellActionId.ROOT_HOME;
    }
    if (value.equals(CellActionId.ROOT_END.getValueAsString())) {
      return CellActionId.ROOT_END;
    }
    if (value.equals(CellActionId.LOCAL_HOME.getValueAsString())) {
      return CellActionId.LOCAL_HOME;
    }
    if (value.equals(CellActionId.LOCAL_END.getValueAsString())) {
      return CellActionId.LOCAL_END;
    }
    if (value.equals(CellActionId.SELECT_LEFT.getValueAsString())) {
      return CellActionId.SELECT_LEFT;
    }
    if (value.equals(CellActionId.SELECT_RIGHT.getValueAsString())) {
      return CellActionId.SELECT_RIGHT;
    }
    if (value.equals(CellActionId.SELECT_UP.getValueAsString())) {
      return CellActionId.SELECT_UP;
    }
    if (value.equals(CellActionId.SELECT_DOWN.getValueAsString())) {
      return CellActionId.SELECT_DOWN;
    }
    if (value.equals(CellActionId.SELECT_HOME.getValueAsString())) {
      return CellActionId.SELECT_HOME;
    }
    if (value.equals(CellActionId.SELECT_END.getValueAsString())) {
      return CellActionId.SELECT_END;
    }
    if (value.equals(CellActionId.SELECT_LOCAL_END.getValueAsString())) {
      return CellActionId.SELECT_LOCAL_END;
    }
    if (value.equals(CellActionId.SELECT_LOCAL_HOME.getValueAsString())) {
      return CellActionId.SELECT_LOCAL_HOME;
    }
    if (value.equals(CellActionId.SELECT_NEXT.getValueAsString())) {
      return CellActionId.SELECT_NEXT;
    }
    if (value.equals(CellActionId.SELECT_PREVIOUS.getValueAsString())) {
      return CellActionId.SELECT_PREVIOUS;
    }
    if (value.equals(CellActionId.LEFT_TRANSFORM.getValueAsString())) {
      return CellActionId.LEFT_TRANSFORM;
    }
    if (value.equals(CellActionId.COMPLETE.getValueAsString())) {
      return CellActionId.COMPLETE;
    }
    if (value.equals(CellActionId.COMPLETE_SMART.getValueAsString())) {
      return CellActionId.COMPLETE_SMART;
    }
    if (value.equals(CellActionId.FOLD.getValueAsString())) {
      return CellActionId.FOLD;
    }
    if (value.equals(CellActionId.UNFOLD.getValueAsString())) {
      return CellActionId.UNFOLD;
    }
    if (value.equals(CellActionId.FOLD_ALL.getValueAsString())) {
      return CellActionId.FOLD_ALL;
    }
    if (value.equals(CellActionId.UNFOLD_ALL.getValueAsString())) {
      return CellActionId.UNFOLD_ALL;
    }
    if (value.equals(CellActionId.TOGGLE_FOLDING.getValueAsString())) {
      return CellActionId.TOGGLE_FOLDING;
    }
    if (value.equals(CellActionId.SHOW_MESSAGE.getValueAsString())) {
      return CellActionId.SHOW_MESSAGE;
    }
    if (value.equals(CellActionId.COMMENT.getValueAsString())) {
      return CellActionId.COMMENT;
    }
    if (value.equals(CellActionId.UNCOMMENT.getValueAsString())) {
      return CellActionId.UNCOMMENT;
    }
    return CellActionId.getDefault();
  }
  private String myValue;
  CellActionId(String name, String value) {
    this.myName = name;
    this.myValue = value;
  }
  public String getValue() {
    return this.myValue;
  }
}

<code block>
package jetbrains.mps.ide.editor.actions;



import jetbrains.mps.workbench.action.BaseAction;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.ide.editor.MPSEditorDataKeys;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.EditorComponent;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import jetbrains.mps.openapi.editor.selection.MultipleSelection;
import jetbrains.mps.nodeEditor.selection.EditorCellSelection;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.openapi.editor.cells.CellActionType;

public class Comment_Action extends BaseAction {
  private static final Icon ICON = null;
  public Comment_Action() {
    super("Comment Out", "", ICON);
    this.setIsAlwaysVisible(false);
    this.setExecuteOutsideCommand(false);
  }
  @Override
  public boolean isDumbAware() {
    return true;
  }
  @Override
  public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {
    Selection selection = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT).getSelectionManager().getSelection();
    return selection != null && EditorActionUtils.isWriteActionEnabled(event.getData(MPSEditorDataKeys.EDITOR_COMPONENT), selection.getSelectedCells());
  }
  @Override
  public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {
    this.setEnabledState(event.getPresentation(), this.isApplicable(event, _params));
  }
  @Override
  protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {
    if (!(super.collectActionData(event, _params))) {
      return false;
    }
    {
      EditorComponent editorComponent = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT);
      if (editorComponent != null && editorComponent.isInvalid()) {
        editorComponent = null;
      }
      if (editorComponent == null) {
        return false;
      }
    }
    {
      SNode node = event.getData(MPSCommonDataKeys.NODE);
      if (node == null) {
        return false;
      }
    }
    return true;
  }
  @Override
  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {
    Selection selection = event.getData(MPSEditorDataKeys.EDITOR_COMPONENT).getSelectionManager().getSelection();
    boolean uncomment = true;
    if (selection instanceof MultipleSelection || selection instanceof EditorCellSelection || (selection instanceof EditorCellLabelSelection && ((EditorCellLabelSelection) selection).hasNonTrivialSelection())) {
      uncomment = false;
    }
    uncomment = uncomment && SNodeOperations.getNodeAncestor(event.getData(MPSCommonDataKeys.NODE), MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute"), false, false) != null && !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(event.getData(MPSCommonDataKeys.NODE)), MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
    if (uncomment) {
      selection.executeAction(CellActionType.UNCOMMENT);
    } else {
      selection.executeAction(CellActionType.COMMENT);
    }
  }
}

<code block>

package jetbrains.mps.lang.editor.cellProviders;

import jetbrains.mps.editor.runtime.impl.cellActions.CellAction_DeleteSmart;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.nodeEditor.cells.EditorCell_Constant;
import jetbrains.mps.nodeEditor.cells.EditorCell_Error;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNode;

import java.util.Iterator;



public abstract class SingleRoleCellProvider {

  protected final SContainmentLink myContainmentLink;
  protected final SNode myOwnerNode;
  protected final EditorContext myEditorContext;

  public SingleRoleCellProvider(final SNode ownerNode, final SContainmentLink containmentLink, EditorContext editorContext) {
    myOwnerNode = ownerNode;
    myContainmentLink = containmentLink;
    myEditorContext = editorContext;
  }

  protected EditorCell createChildCell(EditorContext editorContext, SNode child) {
    EditorCell editorCell = editorContext.getEditorComponent().getUpdater().getCurrentUpdateSession().updateChildNodeCell(child);
    
    editorCell.setAction(CellActionType.DELETE, new CellAction_DeleteSmart(myOwnerNode, myContainmentLink.getDeclarationNode(), child));
    editorCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteSmart(myOwnerNode, myContainmentLink.getDeclarationNode(), child));
    return editorCell;
  }

  public EditorCell createCell() {
    if (areAttributesEmpty()) {
      return createSingleCell();
    } else {
      return createManyCells();
    }
  }

  private EditorCell_Collection createManyCells() {
    EditorCell_Collection resultCell = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(myEditorContext, myOwnerNode);
    for (SNode child : getNodesToPresent()) {
      resultCell.addEditorCell(createChildCell(myEditorContext, child));
    }
    if (isChildEmpty()) {
      resultCell.addEditorCell(createEmptyCell());
    }
    return resultCell;
  }

  private EditorCell createSingleCell() {
    Iterator<? extends SNode> iterator = myOwnerNode.getChildren(myContainmentLink).iterator();
    if (iterator.hasNext()) {
      return createChildCell(myEditorContext, iterator.next());
    } else {
      return createEmptyCell();
    }
  }

  private boolean areAttributesEmpty() {
    return !AttributeOperations.getChildAttributes(myOwnerNode, myContainmentLink).iterator().hasNext();
  }

  private boolean isChildEmpty() {
    return !myOwnerNode.getChildren(myContainmentLink).iterator().hasNext();
  }

  protected EditorCell createEmptyCell() {
    EditorCell_Label result = myContainmentLink.isOptional() ?
        new EditorCell_Constant(myEditorContext, myOwnerNode, "") :
        new EditorCell_Error(myEditorContext, myOwnerNode, getNoTargetText());
    result.setDefaultText(getNoTargetText());
    return result;
  }

  protected String getNoTargetText() {
    
    return "<no " + myContainmentLink.getRoleName() + ">";
  }
  protected Iterable<SNode> getNodesToPresent() {
    return AttributeOperations.getChildNodesAndAttributes(myOwnerNode, myContainmentLink);
  }
}


<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;

public class Cell_Action_Uncomment extends AbstractCellAction {
  private final SNode myNode;

  
  public Cell_Action_Uncomment(@NotNull SNode node) {
    this.myNode = node;
  }

  
  public void execute(EditorContext editorContext) {
    SNode parent = SNodeOperations.getParent(myNode);
    if (parent == null) {
      throw new IllegalStateException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, myNode, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + myNode.getNodeId());

    }
    SNode commentedNode = CommentUtil.uncomment(myNode);
    editorContext.flushEvents();
    if (commentedNode != null) {
      SelectionUtil.selectNode(editorContext, commentedNode);
    }

  }

}

<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class CellAction_Comment extends AbstractCellAction {
  private final SNode myNode;

  
  public CellAction_Comment(@NotNull SNode node) {
    this.myNode = node;
  }

  
  public void execute(EditorContext editorContext) {
    SNode parent = SNodeOperations.getParent(myNode);
    if (parent == null) {
      throw new IllegalStateException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, myNode, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + myNode.getNodeId());

    }
    SNode newComment = CommentUtil.commentOut(myNode);
    editorContext.flushEvents();
    final SContainmentLink containmentLink = myNode.getContainmentLink();
    assert containmentLink != null;
    if (containmentLink.isMultiple()) {
      SelectionUtil.selectCell(editorContext, newComment, SelectionManager.LAST_CELL);
    } else {
      EditorCell parentCell = editorContext.getEditorComponent().findNodeCell(parent);
      EditorCell cellToSelect = CellFinderUtil.findChildByCondition(parentCell, new Condition<EditorCell>() {
        public boolean met(EditorCell cell) {
          return eq_9lx3n0_a0a0a0a0b0a1a0g0e(cell.getRole(), containmentLink.getRole()) && !(SNodeOperations.isInstanceOf(((SNode) cell.getSNode()), MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
        }
      }, true);
      editorContext.getSelectionManager().setSelection(cellToSelect);
    }
  }
  private static boolean eq_9lx3n0_a0a0a0a0b0a1a0g0e(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}

<code block>
package jetbrains.mps.editor.runtime.impl.cellActions;



import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;

public class CommentUtil {
  private CommentUtil() {
  }
  
  @NotNull
  public static SNode commentOut(@NotNull SNode node) {
    SNode parent = SNodeOperations.getParent(node);
    if (parent == null) {
      throw new IllegalArgumentException("Node to comment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, node, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + node.getNodeId());
    }
    SContainmentLink containmentLink = node.getContainmentLink();
    assert containmentLink != null;
    SNode newComment = CommentUtil.createAndInsertNewComment(parent, containmentLink, node);
    SAbstractConcept targetConcept = containmentLink.getTargetConcept();
    if (!(containmentLink.isMultiple()) && !(containmentLink.isOptional())) {
      parent.addChild(containmentLink, NodeFactoryManager.createNode(targetConcept, null, parent, SNodeOperations.getModel(parent)));
    }
    return newComment;
  }
  @NotNull
  private static SNode createAndInsertNewComment(SNode parent, SContainmentLink containmentLink, SNode anchor) {
    SNode newComment = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
    insertInProperPlace(parent, anchor, containmentLink, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment);
    BehaviorReflection.invokeNonVirtual(Void.class, newComment, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_setLink_709746936026609906", new Object[]{containmentLink});
    SLinkOperations.setTarget(newComment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"), anchor);
    return newComment;
  }


  
  public static SNode uncomment(@NotNull SNode attribute) {
    SNode parent = SNodeOperations.getParent(attribute);
    if (parent == null) {
      throw new IllegalArgumentException("Node to uncomment has no parent. Node: " + BehaviorReflection.invokeVirtual(String.class, attribute, "virtual_getPresentation_1213877396640", new Object[]{}) + " Node id: " + attribute.getNodeId());
    }
    SContainmentLink containmentLink = BehaviorReflection.invokeNonVirtual(SContainmentLink.class, attribute, "jetbrains.mps.lang.core.structure.ChildAttribute", "call_getLink_709746936026609871", new Object[]{});
    SNode commentedNode = SLinkOperations.getTarget(attribute, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
    if (containmentLink != null) {
      if (!(containmentLink.isMultiple())) {
        SNode currentChild = ListSequence.fromList(SNodeOperations.getChildren(parent, containmentLink)).first();
        if ((currentChild != null)) {
          createAndInsertNewComment(parent, containmentLink, currentChild);
        }
      }
      if (commentedNode != null) {
        attribute.removeChild(commentedNode);
        insertNodeNearComment(parent, attribute, containmentLink, commentedNode);
      }
    }
    SNodeOperations.deleteNode(attribute);
    return commentedNode;
  }


  private static void insertNodeNearComment(SNode parent, SNode anchorComment, SContainmentLink linkToInsert, SNode nodeToInsert) {
    insertInProperPlace(parent, anchorComment, linkToInsert, linkToInsert, nodeToInsert);
  }

  private static void insertInProperPlace(SNode parent, SNode anchor, SContainmentLink anchorLink, SContainmentLink linkToInsert, SNode newChild) {
    SNode prev = getPrevious(parent, anchor, anchorLink);
    SNode next = getNext(parent, anchor, anchorLink);
    if (prev != null) {
      parent.insertChildAfter(linkToInsert, newChild, prev);
    } else if (next != null) {
      parent.insertChildBefore(linkToInsert, newChild, next);
    } else {
      parent.addChild(linkToInsert, newChild);
    }
  }



  private static SNode getPrevious(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    SNode prev = null;
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        return prev;
      }
    }
    return null;
  }
  private static SNode getNext(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        if (iterator.hasNext()) {
          return iterator.next();
        }
      }
    }
    return null;
  }

}

<code block>

package jetbrains.mps.openapi.editor.cells;


public enum CellActionType {
  INSERT,
  INSERT_BEFORE,
  DELETE,
  BACKSPACE,
  DELETE_TO_WORD_END,


  COPY,
  CUT,
  PASTE,
  PASTE_BEFORE,
  PASTE_AFTER,

  LEFT,
  RIGHT,
  UP,
  DOWN,
  NEXT,
  PREV,
  HOME,
  END,
  PAGE_UP,
  PAGE_DOWN,
  ROOT_HOME,
  ROOT_END,
  LOCAL_HOME,
  LOCAL_END,

  SELECT_LEFT,
  SELECT_RIGHT,
  SELECT_UP,
  SELECT_DOWN,
  SELECT_HOME,
  SELECT_END,
  SELECT_LOCAL_END,
  SELECT_LOCAL_HOME,
  SELECT_NEXT,
  SELECT_PREVIOUS,

  RIGHT_TRANSFORM,
  LEFT_TRANSFORM,

  COMPLETE,
  COMPLETE_SMART,

  FOLD,
  UNFOLD,
  FOLD_ALL,
  UNFOLD_ALL,
  TOGGLE_FOLDING,

  SHOW_MESSAGE,
  CLEAR_SELECTION,

  COMMENT,
  UNCOMMENT
}

<code block>

package jetbrains.mps.ide.projectPane;

import com.intellij.ide.SelectInTarget;
import com.intellij.ide.dnd.aware.DnDAwareTree;
import com.intellij.ide.projectView.ProjectView;
import com.intellij.ide.projectView.impl.ProjectViewPane;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.fileEditor.FileEditorManagerAdapter;
import com.intellij.openapi.fileEditor.FileEditorManagerEvent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.ActionCallback;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowId;
import com.intellij.openapi.wm.ToolWindowManager;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.icons.MPSIcons;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import jetbrains.mps.ide.platform.watching.ReloadListener;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import jetbrains.mps.ide.projectPane.logicalview.ProjectPaneTree;
import jetbrains.mps.ide.projectPane.logicalview.ProjectTree;
import jetbrains.mps.ide.projectPane.logicalview.ProjectTreeFindHelper;
import jetbrains.mps.ide.projectView.ProjectViewPaneOverride;
import jetbrains.mps.ide.ui.tree.MPSTree;
import jetbrains.mps.ide.ui.tree.MPSTree.TreeState;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.ide.ui.tree.MPSTreeNodeEx;
import jetbrains.mps.ide.ui.tree.TreeHighlighterExtension;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;
import jetbrains.mps.ide.ui.tree.smodel.SNodeTreeNode;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.util.annotation.Hack;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.util.Condition;

import javax.swing.Icon;
import javax.swing.JComponent;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@State(
    name = "MPSProjectPane",
    storages = {
        @Storage(
            id = "other",
            file = "$WORKSPACE_FILE$"
        )
    }
)
public class ProjectPane extends BaseLogicalViewProjectPane implements ProjectViewPaneOverride {
  private static final Logger LOG = LogManager.getLogger(ProjectPane.class);
  private ProjectTreeFindHelper myFindHelper = new ProjectTreeFindHelper() {
    @Override
    protected ProjectTree getTree() {
      return ProjectPane.this.getTree();
    }
  };

  private MyScrollPane myScrollPane;
  private MergingUpdateQueue myUpdateQueue = new MergingUpdateQueue("Project Pane Updates Queue", 500, true, myScrollPane, null, null, true);

  public static final String ID = ProjectViewPane.ID;

  private FileEditorManagerAdapter myEditorListener = new FileEditorManagerAdapter() {
    @Override
    public void selectionChanged(FileEditorManagerEvent event) {
      FileEditor fileEditor = event.getNewEditor();
      if (fileEditor instanceof MPSFileNodeEditor) {
        final MPSFileNodeEditor editor = (MPSFileNodeEditor) fileEditor;
        if (getProjectView().isAutoscrollFromSource(ID)) {
          EditorComponent editorComponent = editor.getNodeEditor().getCurrentEditorComponent();
          if (editorComponent == null) return;
          final SNode sNode = editorComponent.getEditedNode();
          ModelAccess.instance().runReadInEDT(new Runnable() {
            @Override
            public void run() {
              selectNodeWithoutExpansion(sNode);
            }
          });
        }
      }
    }
  };
  private Set<ComponentCreationListener> myComponentCreationListeners;
  private static boolean ourShowGenStatus = true;
  private List<List<String>> myExpandedPathsRaw = Collections.emptyList();
  private List<List<String>> mySelectedPathsRaw = Collections.emptyList();

  public ProjectPane(final Project project, ProjectView projectView) {
    super(project, projectView);
    myUpdateQueue.setRestartTimerOnAdd(true);
    ReloadManager.getInstance().addReloadListener(new ReloadListener() {
      @Override
      public void reloadStarted() {

      }

      @Override
      public void reloadFinished() {
        rebuild();
      }
    });
  }

  @Override
  protected void removeListeners() {
    super.removeListeners();
    FileEditorManager fileEditorManager = getProject().getComponent(FileEditorManager.class);
    fileEditorManager.removeFileEditorManagerListener(myEditorListener);
  }

  @Override
  protected void addListeners() {
    super.addListeners();
    getProject().getComponent(FileEditorManager.class).addFileEditorManagerListener(myEditorListener);
  }

  @Hack
  public static ProjectPane getInstance(Project project) {
    final ProjectView projectView = ProjectView.getInstance(project);

    
    
    projectView.getSelectInTargets();

    return (ProjectPane) projectView.getProjectViewPaneById(ID);
  }

  public static ProjectPane getInstance(jetbrains.mps.project.Project mpsProject) {
    if (mpsProject instanceof MPSProject) {
      return getInstance(((MPSProject) mpsProject).getProject());
    }
    return null;
  }

  @Override
  public ProjectTree getTree() {
    return (jetbrains.mps.ide.projectPane.logicalview.ProjectTree) myTree;
  }

  @Override
  public String getTitle() {
    return "Logical View";
  }

  @Override
  @NotNull
  public String getId() {
    return ID;
  }

  @Override
  public int getWeight() {
    return 0;
  }

  @Override
  public SelectInTarget createSelectInTarget() {
    return new ProjectPaneSelectInTarget(this.myProject, true);
  }

  @Override
  public Icon getIcon() {
    return MPSIcons.ProjectPane.LogicalView;
  }

  @Override
  public ActionCallback updateFromRoot(boolean restoreExpandedPaths) {
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.REBUILD) {
      @Override
      public void run() {
        if (getTree() == null) {
          return;
        }
        getTree().rebuildNow();
      }
    });
    return new ActionCallback(); 
  }

  @Override
  public void select(Object element, final VirtualFile file, final boolean requestFocus) {

  }

  @Override
  public JComponent createComponent() {
    if (isComponentCreated()) return myScrollPane;

    ProjectPaneTree tree = new ProjectPaneTree(this, myProject);
    Disposer.register(this, tree);
    tree.setShowStructureCondition(new Computable<Boolean>() {
      @Override
      public Boolean compute() {
        if (myProject.isDisposed()) return false;
        return ProjectPane.getInstance(myProject).showNodeStructure();
      }
    });
    myTree = tree;

    myScrollPane = new MyScrollPane(getTree());
    addListeners();
    if (!RuntimeFlags.isTestMode()) {
      
      ThreadUtils.runInUIThreadNoWait(new Runnable() {
        @Override
        public void run() {
          rebuildTree();
        }
      });
    }
    TreeHighlighterExtension.attachHighlighters(tree, myProject);
    fireComponentCreated();
    return myScrollPane;
  }

  @Override
  protected boolean isComponentCreated() {
    return myScrollPane != null;
  }

  public void rebuildTree() {
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.REBUILD) {
      @Override
      public void run() {
        if (getTree() == null || getProject().isDisposed()) {
          return;
        }
        getTree().rebuildNow();
        getTree().expandProjectNode();
      }
    });
  }

  public void activate() {
    ThreadUtils.assertEDT();
    activatePane(new PaneActivator(false), true);
  }

  @Override
  public void rebuild() {
    ModelAccess.instance().runReadInEDT(new Runnable() {
      @Override
      public void run() {
        if (isDisposed() || getTree() == null) return;
        rebuildTree();
      }
    });
  }

  @Override
  protected void saveExpandedPaths() {
    
    
    if (myTree != null) {
      myExpandedPathsRaw = ((MPSTree) myTree).getExpandedPathsRaw();
      mySelectedPathsRaw = ((MPSTree) myTree).getSelectedPathsRaw();
    }
    else {
      myExpandedPathsRaw = Collections.emptyList();
      mySelectedPathsRaw = Collections.emptyList();
    }
  }

  @Override
  public void restoreExpandedPathsOverride () {
    
    

    if (myTree != null) {
      myUpdateQueue.queue(new AbstractUpdate(UpdateID.RESTORE_EXPAND) {
        @Override
        public void run() {
          ((MPSTree) myTree).loadState(myExpandedPathsRaw, mySelectedPathsRaw);

        }
      });
    }
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    saveExpandedPaths();

    
    Element subPane = new Element("subPane");
    
    if (getSubId() != null) {
      subPane.setAttribute("subId", getSubId());
    }

    witePaths(subPane, myExpandedPathsRaw, "PATH");
    witePaths(subPane, mySelectedPathsRaw, "SELECTED");

    element.addContent(subPane);
  }

  private void witePaths(Element parentElement, List<List<String>> pathsRaw, String elementName) {
    for (List<String> path: pathsRaw) {
      Element pathElement = new Element(elementName);
      writePath(path, pathElement);
      parentElement.addContent(pathElement);
    }
  }

  private void writePath(List<String> path, Element pathElement) {
    for (String treeNodeId : path) {
      Element elm = new Element("PATH_ELEMENT");
      writeNodeId(treeNodeId, elm);
      pathElement.addContent(elm);
    }
  }

  private void writeNodeId(String treeNodeId, Element elm) {
    Element option1 = new Element("option");
    option1.setAttribute("name", "myItemId");
    option1.setAttribute("value", treeNodeId);
    elm.addContent(option1);
    Element option2 = new Element("option");
    option2.setAttribute("name", "myItemType");
    option2.setAttribute("value", "");
    elm.addContent(option2);
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    
    List<Element> subPanes = element.getChildren("subPane");
    for (Element subPane : subPanes) {
      myExpandedPathsRaw = readPaths(subPane, "PATH");
      mySelectedPathsRaw = readPaths(subPane, "SELECTED");
    }
  }

  private List<List<String>> readPaths(Element parentElement, String name) {
    List<List<String>> result = new ArrayList<List<String>>();

    for (Element pathElement : parentElement.getChildren(name)) {
      List<String> path = readPath(pathElement);
      result.add(path);
    }
    return result;
  }

  @NotNull
  private List<String> readPath(Element pathElement) {
    List<String> path = new ArrayList<String>();
    for (Element elm : pathElement.getChildren("PATH_ELEMENT")) {
      String treeNodeId = readNodeId(elm);
      if (treeNodeId != null) {
        path.add(treeNodeId);
      }
    }
    return path;
  }

  @Nullable
  private String readNodeId(Element elm) {
    List<Element> options = elm.getChildren("option");
    String treeNodeId = null;
    for (Element option : options) {
      if ("myItemId".equals(option.getAttributeValue("name"))) {
        treeNodeId = option.getAttributeValue("value");
        break;
      }
    }
    return treeNodeId;
  }

  

  public void selectModule(@NotNull final SModule module, final boolean autofocus) {
    ModelAccess.instance().runReadInEDT(new Runnable() {
      @Override
      public void run() {
        activatePane(new PaneActivator(true) {
          @Override
          public void doOnPaneActivation() {
            MPSTreeNode moduleTreeNode = myFindHelper.findMostSuitableModuleTreeNode(module);

            if (moduleTreeNode == null) {
              LOG.warn("Couldn't select module \"" + module.getModuleName() + "\" : tree node not found.");
              return;
            }

            getTree().selectNode(moduleTreeNode);
          }
        }, autofocus);
      }
    });
  }

  public void selectModel(@NotNull final SModel model, boolean autofocus) {
    if (!ThreadUtils.isEventDispatchThread()) {
      throw new IllegalStateException("Can't use this outside of EDT");
    }
    activatePane(new PaneActivator(true) {
      @Override
      public void doOnPaneActivation() {
        SModelTreeNode modelTreeNode = myFindHelper.findMostSuitableModelTreeNode(model);
        if (modelTreeNode == null) {
          LOG.warn("Couldn't select model \"" + SNodeOperations.getModelLongName(model) + "\" : tree node not found.");
          return;
        }
        getTree().selectNode(modelTreeNode);
      }
    }, autofocus);
  }

  private void activatePane(PaneActivator activator, boolean autoFocusContents) {
    ToolWindowManager windowManager = ToolWindowManager.getInstance(getProject());
    ToolWindow projectViewToolWindow = windowManager.getToolWindow(ToolWindowId.PROJECT_VIEW);
    
    if(!ApplicationManager.getApplication().isUnitTestMode()) {
      projectViewToolWindow.activate(activator, autoFocusContents);
    }
  }

  public void selectNode(@NotNull final SNode node, boolean autofocus) {
    if (!ThreadUtils.isEventDispatchThread()) {
      throw new IllegalStateException("Can't use this outside of EDT");
    }
    activatePane(new PaneActivator(true) {
      @Override
      public void doOnPaneActivation() {
        selectNodeWithoutExpansion(node);
      }
    }, autofocus);
  }

  private void selectNodeWithoutExpansion(final SNode node) {
    getTree().runWithoutExpansion(new Runnable() {
      @Override
      public void run() {
        MPSTreeNodeEx sNodeNode = myFindHelper.findMostSuitableSNodeTreeNode(node);
        if (sNodeNode == null) {
          LOG.warn("Couldn't select node \"" + node.getName() + "\" : tree node not found.");
          return;
        }
        getTree().selectNode(sNodeNode);
      }
    });
  }

  

  @Override
  public void selectNextModel(SModel modelDescriptor) {
    final MPSTreeNode mpsTreeNode = myFindHelper.findNextTreeNode(modelDescriptor);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      @Override
      public void run() {
        ProjectTree tree = getTree();
        if (tree != null) {
          tree.selectNode(mpsTreeNode);
        }
      }
    });
  }

  public void selectNextNode(SNode node) {
    final MPSTreeNode mpsTreeNode = myFindHelper.findNextTreeNode(node);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      @Override
      public void run() {
        getTree().selectNode(mpsTreeNode);
      }
    });
  }

  

  public MPSTreeNode findNextTreeNode(SNode node) {
    return myFindHelper.findNextTreeNode(node);
  }

  private void fireComponentCreated() {
    if (myComponentCreationListeners == null) {
      return;
    }
    for (ComponentCreationListener l : myComponentCreationListeners.toArray(new ComponentCreationListener[myComponentCreationListeners.size()])) {
      l.componentCreated(this);
    }
  }

  public void addComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      myComponentCreationListeners = new HashSet();
    }
    myComponentCreationListeners.add(l);
  }

  public void removeComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      return;
    }
    myComponentCreationListeners.remove(l);
    if (myComponentCreationListeners.isEmpty()) {
      myComponentCreationListeners = null;
    }
  }

  

  public static void setShowGenStatus(boolean showGenStatusInTree) {
    ourShowGenStatus = showGenStatusInTree;
  }

  public static boolean isShowGenStatus() {
    return ourShowGenStatus;
  }

  

  private class MyScrollPane extends JBScrollPane implements DataProvider {
    private MyScrollPane(Component view) {
      super(view);
    }

    @Override
    @Nullable
    public Object getData(@NonNls String dataId) {
      return ProjectPane.this.getData(dataId);
    }
  }

  private class PaneActivator implements Runnable {
    private boolean myRunReadAction;

    private PaneActivator(boolean runReadAction) {
      myRunReadAction = runReadAction;
    }

    @Override
    public final void run() {
      getProjectView().changeView(getId());
      myUpdateQueue.queue(new AbstractUpdate(UpdateID.SELECT) {
        @Override
        public void run() {
          
          if (myRunReadAction) {
            ModelAccess.instance().runReadAction(new Runnable() {
              @Override
              public void run() {
                doOnPaneActivation();
              }
            });
          } else {
            doOnPaneActivation();
          }
        }
      });
    }

    protected void doOnPaneActivation() {
    }
  }

  public interface ComponentCreationListener {
    void componentCreated(ProjectPane projectPane);
  }

  private enum UpdateID {
    REBUILD(20),
    SELECT(30),
    RESTORE_EXPAND(40);

    private int myPriority;

    UpdateID(int priority) {
      myPriority = priority;
    }

    public int getPriority() {
      return myPriority;
    }
  }

  private abstract class AbstractUpdate extends Update {
    private AbstractUpdate(UpdateID id) {
      super(id, id.getPriority());
    }
  }
}

<code block>

package jetbrains.mps.ide.projectView;

import com.intellij.ide.projectView.impl.AbstractProjectViewPane;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ex.ToolWindowManagerEx;
import com.intellij.ui.content.Content;
import com.intellij.ui.content.ContentManager;
import com.intellij.ui.content.ContentManagerAdapter;
import com.intellij.ui.content.ContentManagerEvent;
import jetbrains.mps.icons.MPSIcons.ProjectPane;
import org.jdom.Element;
import org.jetbrains.annotations.NotNull;

@State(
    name="ProjectView",
    storages= {
        @Storage(
            file = StoragePathMacros.WORKSPACE_FILE
        )}
)
public class ProjectViewImpl extends com.intellij.ide.projectView.impl.ProjectViewImpl {

  public ProjectViewImpl(@NotNull Project project,
      FileEditorManager fileEditorManager, ToolWindowManagerEx toolWindowManager) {
    super(project, fileEditorManager, toolWindowManager);
  }

  @Override
  public synchronized void setupImpl(@NotNull ToolWindow toolWindow, boolean loadPaneExtensions) {
    super.setupImpl(toolWindow, loadPaneExtensions);
    

    toolWindow.getContentManager().addContentManagerListener(new ContentManagerAdapter() {
      @Override
      public void selectionChanged(ContentManagerEvent event) {
        if (event.getOperation() == ContentManagerEvent.ContentOperation.add) {
          viewSelectionChangedOverride();
        }
      }
    });
    viewSelectionChangedOverride();
  }

  @Override
  public synchronized void removeProjectPane(@NotNull AbstractProjectViewPane pane) {
    super.removeProjectPane(pane);
    
    viewSelectionChangedOverride();
  }

  @Override
  public Element getState() {
    
    
    return super.getState();
  }

  @Override
  public void loadState(Element parentNode) {
    
    
    super.loadState(parentNode);
  }

  private boolean viewSelectionChangedOverride() {
    
    final AbstractProjectViewPane newPane = getProjectViewPaneById(getCurrentViewId());
    if (newPane == null) return false;
    if (!(newPane instanceof ProjectViewPaneOverride)) return false;

    ((ProjectViewPaneOverride) newPane).restoreExpandedPathsOverride();
    return true;
  }

  @Override
  protected boolean isShowMembersOptionSupported() {
    return false;
  }
}

<code block>

package jetbrains.mps.ide.projectView;

import com.intellij.ide.projectView.impl.AbstractProjectViewPane;
import com.intellij.openapi.project.Project;


public interface ProjectViewPaneOverride  {

  
  void restoreExpandedPathsOverride ();

}

<code block>

package jetbrains.mps.ide.ui.tree;

import com.intellij.ide.DataManager;
import com.intellij.ide.dnd.aware.DnDAwareTree;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.openapi.wm.impl.IdeFocusManagerHeadless;
import com.intellij.ui.TreeUIHelper;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.ModelAccess;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.AbstractAction;
import javax.swing.JPopupMenu;
import javax.swing.KeyStroke;
import javax.swing.ToolTipManager;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.ExpandVetoException;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public abstract class MPSTree extends DnDAwareTree implements Disposable {
  public static final String PATH = "path";

  protected static final Logger LOG = LogManager.getLogger(MPSTree.class);

  public static final String TREE_PATH_SEPARATOR = "/";

  private int myTooltipManagerRecentInitialDelay;
  private boolean myAutoExpandEnabled = true;
  private boolean myAutoOpen = false;
  private boolean myLoadingDisabled;

  private Set<MPSTreeNode> myExpandingNodes = new HashSet<MPSTreeNode>();

  private List<MPSTreeNodeListener> myTreeNodeListeners = new ArrayList<MPSTreeNodeListener>();

  
  private MergingUpdateQueue myQueue = new MergingUpdateQueue("MPS Tree Rebuild Later Watcher Queue", 500, true, null);
  private final Object myUpdateId = new Object();

  private boolean myDisposed = false;

  protected MPSTree() {
    setRootNode(new TextTreeNode("Empty"));

    new MPSTreeSpeedSearch(this);

    ToolTipManager.sharedInstance().registerComponent(this);

    largeModel = true;

    TreeUIHelper.getInstance().installToolTipHandler(this);

    setCellRenderer(new NewMPSTreeCellRenderer());

    addTreeWillExpandListener(new MyTreeWillExpandListener());
    addTreeExpansionListener(new MyTreeExpansionListener());
    addMouseListener(new MyMouseAdapter());

    registerKeyboardAction(new MyOpenNodeAction(), KeyStroke.getKeyStroke("F4"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    registerKeyboardAction(new MyRefreshAction(), KeyStroke.getKeyStroke("F5"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }

  
  protected void doInit(final MPSTreeNode node) {
    assert ThreadUtils.isInEDT();
    if (myExpandingNodes.contains(node)) {
      return;
    }

    myExpandingNodes.add(node);
    try {
      TextTreeNode progressNode = null;
      if (!myLoadingDisabled && node.isLoadingEnabled()) {
        progressNode = new TextTreeNode("loading...");
        node.add(progressNode);
        ((DefaultTreeModel) getModel()).nodeStructureChanged(node);
        expandPath(new TreePath(progressNode.getPath()));

        Graphics g = getGraphics();
        if (g != null && g.getClipBounds() != null) paint(g);
      }

      ModelAccess.instance().runReadAction(new Runnable() {
        @Override
        public void run() {
          node.doInit();
        }
      });
      ((DefaultTreeModel) getModel()).nodeStructureChanged(node);

      if (!myLoadingDisabled && node.isLoadingEnabled() && node.hasChild(progressNode)) { 
        node.remove(progressNode);
        ((DefaultTreeModel) getModel()).nodeStructureChanged(node);
      }

    } finally {
      myExpandingNodes.remove(node);
    }
  }

  public void addTreeNodeListener(MPSTreeNodeListener listener) {
    myTreeNodeListeners.add(listener);
  }

  public void removeTreeNodeListener(MPSTreeNodeListener listener) {
    myTreeNodeListeners.remove(listener);
  }

  public void fireBeforeTreeDisposed() {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.beforeTreeDisposed(this);
    }
  }

  void fireTreeNodeUpdated(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeUpdated(node, this);
    }
  }

  void fireTreeNodeAdded(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeAdded(node, this);
    }
  }

  void fireTreeNodeRemoved(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeRemoved(node, this);
    }
  }

  void myMouseReleased(MouseEvent e) {
    if (e.isPopupTrigger()) showPopup(e.getX(), e.getY());
  }

  void myMousePressed(final MouseEvent e) {
    Project p = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(this));
    IdeFocusManager focusManager;
    if (p != null) {
      focusManager = IdeFocusManager.getInstance(p);
    } else {
      focusManager = IdeFocusManagerHeadless.INSTANCE;
    }

    focusManager.requestFocus(this, true);

    TreePath path = getClosestPathForLocation(e.getX(), e.getY());
    if (path == null) return;

    Object lastPathComponent = path.getLastPathComponent();
    MPSTreeNode nodeToClick=null;
    if (lastPathComponent instanceof MPSTreeNode && ((MPSTreeNode) lastPathComponent).canBeOpened()) {
      nodeToClick = (MPSTreeNode) lastPathComponent;
      if ((e.getClickCount() == 1 && isAutoOpen())) {
        autoscroll(nodeToClick);
      } else if (e.getClickCount() == 2) {
        e.consume();
      }
    } else if (e.getButton() == MouseEvent.BUTTON3) {
      if (!isPathSelected(path)) {
        setSelectionPath(path);
      }
    }

    
    final MPSTreeNode node2dc = e.getClickCount()==2?nodeToClick:null;
    focusManager.doWhenFocusSettlesDown(new Runnable() {
      @Override
      public void run() {
        if (node2dc != null) {
          doubleClick(node2dc);
        }
        if (e.isPopupTrigger()) showPopup(e.getX(), e.getY());
      }
    });
  }

  
  protected void doubleClick(@NotNull MPSTreeNode nodeToClick) {
    nodeToClick.doubleClick();
  }

  
  protected void autoscroll(@NotNull MPSTreeNode nodeToClick) {
    nodeToClick.autoscroll();
  }

  public void runWithoutExpansion(Runnable r) {
    try {
      myAutoExpandEnabled = false;
      r.run();
    } finally {
      myAutoExpandEnabled = true;
    }
  }

  public boolean isAutoOpen() {
    return myAutoOpen;
  }

  public void setAutoOpen(boolean autoOpen) {
    myAutoOpen = autoOpen;
  }

  @Override
  public String getToolTipText(MouseEvent event) {
    TreePath path = getPathForLocation(event.getX(), event.getY());
    if (path != null && path.getLastPathComponent() instanceof MPSTreeNode) {
      final MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();
      return node.getTooltipText();
    }
    return null;
  }

  protected JPopupMenu createDefaultPopupMenu() {
    return null;
  }

  protected final JPopupMenu createPopupMenu(final MPSTreeNode node) {
    ActionGroup actionGroup = createPopupActionGroup(node);
    if (actionGroup == null) return null;
    return ActionManager.getInstance().createActionPopupMenu(getPopupMenuPlace(), actionGroup).getComponent();
  }

  protected String getPopupMenuPlace() {
    return ActionPlaces.UNKNOWN;
  }

  protected ActionGroup createPopupActionGroup(final MPSTreeNode node) {
    return null;
  }

  private void showPopup(int x, int y) {
    TreePath path = getPathForLocation(x, y);
    if (path != null && path.getLastPathComponent() instanceof MPSTreeNode) {
      final MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();
      JPopupMenu menu = createPopupMenu(node);
      if (menu != null) {
        if (!getSelectedPaths().contains(pathToString(path))) {
          setSelectionPath(path);
        }
        menu.show(this, x, y);
        return;
      }
    }

    JPopupMenu defaultMenu = createDefaultPopupMenu();
    if (defaultMenu == null) return;
    defaultMenu.show(this, x, y);
  }

  @Nullable
  public Comparator<Object> getChildrenComparator() {
    return null;
  }

  protected abstract MPSTreeNode rebuild();

  public void expandAll() {
    MPSTreeNode node = getRootNode();
    expandAll(node);
  }

  public void collapseAll() {
    MPSTreeNode node = getRootNode();
    collapseAll(node);
  }

  public void selectFirstLeaf() {
    List<MPSTreeNode> path = new ArrayList<MPSTreeNode>();
    MPSTreeNode current = getRootNode();

    while (true) {
      path.add(current);
      if (current.getChildCount() == 0) break;
      current = (MPSTreeNode) current.getChildAt(0);
    }

    setSelectionPath(new TreePath(path.toArray()));
  }

  public void expandRoot() {
    expandPath(new TreePath(new Object[]{getRootNode()}));
    getRootNode().init();
  }

  public void expandAll(MPSTreeNode node) {
    boolean wasLoadingDisabled = myLoadingDisabled;
    myLoadingDisabled = true;
    try {
      expandAllImpl(node);
    } finally {
      myLoadingDisabled = wasLoadingDisabled;
    }
  }
  private void expandAllImpl(MPSTreeNode node) {
    expandPath(new TreePath(node.getPath()));
    for (MPSTreeNode c : node) {
      expandAllImpl(c);
    }
  }

  public void collapseAll(MPSTreeNode node) {
    boolean wasAutoExpandEnabled = myAutoExpandEnabled;
    try {
      myAutoExpandEnabled = false;
      collapseAllImpl(node);
    } finally {
      myAutoExpandEnabled = wasAutoExpandEnabled;
    }
  }

  private void collapseAllImpl(MPSTreeNode node) {
    for (MPSTreeNode c : node) {
      collapseAllImpl(c);
    }
    if (node.isInitialized()) {
      super.collapsePath(new TreePath(node.getPath()));
    }
  }

  public void selectNode(TreeNode node) {
    List<TreeNode> nodes = new ArrayList<TreeNode>();
    while (node != null) {
      nodes.add(0, node);
      node = node.getParent();
    }
    if (nodes.size() == 0) return;
    TreePath path = new TreePath(nodes.toArray());
    setSelectionPath(path);
    scrollRowToVisible(getRowForPath(path));
  }

  
  public void runRebuildAction(final Runnable rebuildAction, final boolean saveExpansion) {
    if (RuntimeFlags.isTestMode()) {
      return;
    }
    if (!ThreadUtils.isInEDT()) {
      throw new RuntimeException("Rebuild now can be only called from UI thread");
    }


    myLoadingDisabled = true;
    try {
      Runnable restoreExpansion = null;
      if (saveExpansion) {
        final List<String> expansion = getExpandedPaths();
        final List<String> selection = getSelectedPaths();
        restoreExpansion = new Runnable() {
          @Override
          public void run() {
            expandPaths(expansion);
            selectPaths(selection);
          }
        };
      }
      ModelAccess.instance().runReadAction(rebuildAction);
      if (restoreExpansion != null) {
          runWithoutExpansion(restoreExpansion);
      }
    } finally {
      myLoadingDisabled = false;
    }
  }

  public void rebuildLater() {
    myQueue.queue(new Update(myUpdateId) {
      @Override
      public void run() {
        ThreadUtils.runInUIThreadNoWait(new Runnable() {
          @Override
          public void run() {
            if (MPSTree.this.isDisposed()) return;
            rebuildNow();
          }
        });
      }
    });
  }

  public void rebuildNow() {
    if (!ThreadUtils.isInEDT()) {
      throw new RuntimeException("Rebuild now can be only called from UI thread");
    }
    assert !isDisposed() : "Trying to reconstruct disposed tree. Try finding \"later\" in stacktrace";

    runRebuildAction(new Runnable() {
      @Override
      public void run() {
        setAnchorSelectionPath(null);
        setLeadSelectionPath(null);

        MPSTreeNode root = rebuild();
        setRootNode(root);
      }
    }, true);
  }

  public void clear() {
    setRootNode(new TextTreeNode("Empty"));
  }

  private void setRootNode(@Nullable MPSTreeNode root) {
    final Object oldRoot = getModel().getRoot();
    if (oldRoot instanceof MPSTreeNode) {
      ((MPSTreeNode) oldRoot).removeThisAndChildren();
      ((MPSTreeNode) oldRoot).setTree(null);
    }

    if (root != null) {
      root.setTree(this);
      root.addThisAndChildren();
    }

    DefaultTreeModel model = new DefaultTreeModel(root);
    setModel(model);
  }

  private String pathToString(TreePath path) {
    StringBuilder result = new StringBuilder();
    for (int i = 1; i < path.getPathCount(); i++) {
      MPSTreeNode node = (MPSTreeNode) path.getPathComponent(i);
      result.append(TREE_PATH_SEPARATOR);
      result.append(node.getNodeIdentifier().replaceAll(TREE_PATH_SEPARATOR, "-"));
    }
    if (result.length() == 0) return TREE_PATH_SEPARATOR;
    return result.toString();
  }

  public TreeNode findNodeWith(Object userObject) {
    MPSTreeNode root = getRootNode();
    return findNodeWith(root, userObject);
  }

  public MPSTreeNode getRootNode() {
    return (MPSTreeNode) getModel().getRoot();
  }

  public MPSTreeNode getCurrentNode() {
    javax.swing.tree.TreePath path = getLeadSelectionPath();
    if (path == null) {
      return null;
    }
    Object obj = path.getLastPathComponent();
    if (!(obj instanceof TreeNode)) {
      return null;
    }
    return (MPSTreeNode) obj;
  }

  public void setCurrentNode(MPSTreeNode node) {
    TreePath path = new TreePath(node.getPath());
    setSelectionPath(path);
    this.scrollPathToVisible(path);
  }

  private MPSTreeNode findNodeWith(MPSTreeNode root, Object userObject) {
    if (root.getUserObject() == userObject) return root;
    if (!(root.isInitialized() || root.hasInfiniteSubtree())) root.init();
    for (MPSTreeNode child : root) {
      MPSTreeNode result = findNodeWith(child, userObject);
      if (result != null) return result;
    }
    return null;
  }

  private TreePath listToPath(List<String> pathComponents) {
    return getTreePath(pathComponents, false);
  }

  private TreePath stringToPath(String pathString) {
    List<String> components = Arrays.asList(pathString.split(TREE_PATH_SEPARATOR));

    return getTreePath(components, true);
  }

  @Nullable
  private TreePath getTreePath(List<String> components, boolean escapePathSep) {
    List<Object> path = new ArrayList<Object>();
    MPSTreeNode current = getRootNode();

    current.init();

    path.add(current);

    for (Iterator<String> it = components.iterator(); it.hasNext(); ) {
      String component = it.next();
      assert current.isInitialized();
      if (component == null || component.length() == 0) continue;
      boolean found = false;
      for (int i = 0; i < current.getChildCount(); i++) {
        MPSTreeNode node = (MPSTreeNode) current.getChildAt(i);
        String treeNodeId =
            escapePathSep ? node.getNodeIdentifier().replaceAll(TREE_PATH_SEPARATOR, "-") :
                            node.getNodeIdentifier();
        if (treeNodeId.equals(component)) {
          current = node;
          path.add(current);
          if (!current.isInitialized() && it.hasNext()) {
            current.init();
          }
          found = true;
          break;
        }
      }
      if (!found) {
        return null;
      }
    }
    return new TreePath(path.toArray());
  }

  protected void expandPathsRaw(List<List<String>> paths) {
    for (List<String> path : paths) {
      TreePath treePath = listToPath(path);
      if (treePath != null) {
        ensurePathInitialized(treePath);
        expandPath(treePath);
      }
    }
  }

  protected void expandPaths(List<String> paths) {
    for (String path : paths) {
      TreePath treePath = stringToPath(path);
      if (treePath != null) {
        ensurePathInitialized(treePath);
        expandPath(treePath);
      }
    }
  }

  private void ensurePathInitialized(TreePath path) {
    for (Object item : path.getPath()) {
      MPSTreeNode node = (MPSTreeNode) item;
      node.init();
    }
  }

  protected void selectPaths(List<String> paths) {
    List<TreePath> treePaths = new ArrayList<TreePath>();
    for (String path : paths) {
      treePaths.add(stringToPath(path));
    }
    setSelectionPaths(treePaths.toArray(new TreePath[treePaths.size()]));
  }

  protected void selectPathsRaw(List<List<String>> paths) {
    List<TreePath> treePaths = new ArrayList<TreePath>();
    for (List<String> path : paths) {
      treePaths.add(listToPath(path));
    }
    setSelectionPaths(treePaths.toArray(new TreePath[treePaths.size()]));
  }

  
  public List<List<String>> getExpandedPathsRaw() {
    List<List<String>> result = new ArrayList<List<String>>();
    Enumeration<TreePath> expanded = getExpandedDescendants(new TreePath(new Object[]{getModel().getRoot()}));
    if (expanded == null) return result;
    while (expanded.hasMoreElements()) {
      List<String> path = new ArrayList<String>();
      TreePath expandedPath = expanded.nextElement();
      if (expandedPath.getLastPathComponent() == getModel().getRoot()) {
        continue;
      }
      for (int i = 1; i < expandedPath.getPathCount(); i++) {
        MPSTreeNode node = (MPSTreeNode) expandedPath.getPathComponent(i);
        path.add(node.getNodeIdentifier());
      }
      result.add(path);
    }
    return result;
  }

  private List<String> getExpandedPaths() {
    List<String> result = new ArrayList<String>();
    Enumeration<TreePath> expanded = getExpandedDescendants(new TreePath(new Object[]{getModel().getRoot()}));
    if (expanded == null) return result;
    while (expanded.hasMoreElements()) {
      TreePath path = expanded.nextElement();
      String pathString = pathToString(path);
      if (result.contains(pathString))
        LOG.warn("two expanded paths have the same string representation");
      result.add(pathString);
    }
    return result;
  }

  
  public List<List<String>> getSelectedPathsRaw() {
    List<List<String>> result = new ArrayList<List<String>>();
    if (getSelectionPaths() == null) return result;
    for (TreePath selectedPath: getSelectionPaths()) {
      List<String> path = new ArrayList<String>();
      for (int i = 1; i < selectedPath.getPathCount(); i++) {
        MPSTreeNode node = (MPSTreeNode) selectedPath.getPathComponent(i);
        path.add(node.getNodeIdentifier());
      }
      result.add(path);
    }
    return result;
  }

  private List<String> getSelectedPaths() {
    List<String> result = new ArrayList<String>();
    if (getSelectionPaths() == null) return result;
    for (TreePath selectionPart : getSelectionPaths()) {
      String pathString = pathToString(selectionPart);
      if (result.contains(pathString))
        LOG.warn("two selected paths have the same string representation");
      result.add(pathString);
    }
    return result;
  }

  public TreeState saveState() {
    TreeState result = new TreeState();
    result.myExpansion.addAll(getExpandedPaths());
    result.mySelection.addAll(getSelectedPaths());
    return result;
  }

  public void loadState(TreeState state) {
    selectPaths(state.mySelection);
    expandPaths(state.myExpansion);
  }

  
  public void loadState(List<List<String>> expandedPaths, List<List<String>> selectedPaths) {
    expandPathsRaw(expandedPaths);
    selectPathsRaw(selectedPaths);
  }

  @Override
  public int getToggleClickCount() {
    TreePath selection = getSelectionPath();
    if (selection == null) return -1;
    if (selection.getLastPathComponent() instanceof MPSTreeNode) {
      MPSTreeNode node = (MPSTreeNode) selection.getLastPathComponent();
      return node.getToggleClickCount();
    }
    return -1;
  }

  public boolean isDisposed() {
    return myDisposed;
  }

  @Override
  public void dispose() {
    assert !myDisposed;

    fireBeforeTreeDisposed();
    myDisposed = true;
    setRootNode(null);
    myTreeNodeListeners.clear();
  }

  public static class TreeState {
    private List<String> myExpansion = new ArrayList<String>();
    private List<String> mySelection = new ArrayList<String>();

    public List<String> getExpansion() {
      return myExpansion;
    }

    public void setExpansion(List<String> expansion) {
      myExpansion = expansion;
    }

    public List<String> getSelection() {
      return mySelection;
    }

    public void setSelection(List<String> selection) {
      mySelection = selection;
    }
  }

  private class MyTreeWillExpandListener implements TreeWillExpandListener {
    @Override
    public void treeWillExpand(TreeExpansionEvent event) throws ExpandVetoException {
      TreePath path = event.getPath();
      Object node = path.getLastPathComponent();
      MPSTreeNode treeNode = (MPSTreeNode) node;
      treeNode.init();
    }

    @Override
    public void treeWillCollapse(TreeExpansionEvent event) throws ExpandVetoException {
    }
  }

  private class MyTreeExpansionListener implements TreeExpansionListener {
    @Override
    public void treeExpanded(TreeExpansionEvent event) {
      if (!myAutoExpandEnabled) return;

      TreePath eventPath = event.getPath();
      MPSTreeNode node = (MPSTreeNode) eventPath.getLastPathComponent();

      if (node.getChildCount() == 1) {
        List<MPSTreeNode> path = new ArrayList<MPSTreeNode>();
        for (Object item : eventPath.getPath()) {
          path.add((MPSTreeNode) item);
        }
        MPSTreeNode onlyChild = (MPSTreeNode) node.getChildAt(0);

        if (onlyChild.isAutoExpandable()) {
          path.add(onlyChild);
          expandPath(new TreePath(path.toArray()));
        }
      }
    }

    @Override
    public void treeCollapsed(TreeExpansionEvent event) {
    }
  }

  private class MyMouseAdapter extends MouseAdapter {
    @Override
    public void mousePressed(MouseEvent e) {
      
      if (e.getButton() == 0) {
        TreePath path = getSelectionPath();
        if (path == null) return;
        int rowNum = getRowForPath(path);
        Rectangle r = getRowBounds(rowNum);
        showPopup(r.x, r.y);
      } else {
        requestFocus();
        myMousePressed(e);
      }
    }

    @Override
    public void mouseReleased(MouseEvent e) {
      myMouseReleased(e);
    }

    @Override
    public void mouseEntered(MouseEvent e) {
      myTooltipManagerRecentInitialDelay = ToolTipManager.sharedInstance().getInitialDelay();
      ToolTipManager.sharedInstance().setInitialDelay(10);
    }

    @Override
    public void mouseExited(MouseEvent e) {
      ToolTipManager.sharedInstance().setInitialDelay(myTooltipManagerRecentInitialDelay);
    }
  }

  private class MyOpenNodeAction extends AbstractAction {
    @Override
    public void actionPerformed(ActionEvent e) {
      TreePath selPath = getSelectionPath();
      if (selPath == null) return;
      MPSTreeNode selNode = (MPSTreeNode) selPath.getLastPathComponent();
      doubleClick(selNode);
    }
  }

  private class MyRefreshAction extends AbstractAction {
    @Override
    public void actionPerformed(ActionEvent e) {
      rebuildNow();
    }
  }
}

<code block>

package jetbrains.mps.ide.projectPane;

import com.intellij.ide.SelectInTarget;
import com.intellij.ide.projectView.ProjectView;
import com.intellij.ide.projectView.impl.ProjectViewPane;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.fileEditor.FileEditorManagerAdapter;
import com.intellij.openapi.fileEditor.FileEditorManagerEvent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.ActionCallback;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowId;
import com.intellij.openapi.wm.ToolWindowManager;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.icons.MPSIcons;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.ide.editor.MPSFileNodeEditor;
import jetbrains.mps.ide.platform.watching.ReloadListener;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import jetbrains.mps.ide.projectPane.logicalview.ProjectPaneTree;
import jetbrains.mps.ide.projectPane.logicalview.ProjectTree;
import jetbrains.mps.ide.projectPane.logicalview.ProjectTreeFindHelper;
import jetbrains.mps.ide.ui.tree.MPSTree;
import jetbrains.mps.ide.ui.tree.MPSTreeNode;
import jetbrains.mps.ide.ui.tree.MPSTreeNodeEx;
import jetbrains.mps.ide.ui.tree.TreeHighlighterExtension;
import jetbrains.mps.ide.ui.tree.smodel.SModelTreeNode;
import jetbrains.mps.ide.ui.tree.smodel.SNodeTreeNode;
import jetbrains.mps.openapi.editor.EditorComponent;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.util.annotation.Hack;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.util.Condition;

import javax.swing.Icon;
import javax.swing.JComponent;
import java.awt.Component;
import java.util.HashSet;
import java.util.Set;

@State(
    name = "MPSProjectPane",
    storages = {
        @Storage(
            id = "other",
            file = "$WORKSPACE_FILE$"
        )
    }
)
public class ProjectPane extends BaseLogicalViewProjectPane {
  private static final Logger LOG = LogManager.getLogger(ProjectPane.class);
  private ProjectTreeFindHelper myFindHelper = new ProjectTreeFindHelper() {
    @Override
    protected ProjectTree getTree() {
      return ProjectPane.this.getTree();
    }
  };

  private MyScrollPane myScrollPane;
  private MergingUpdateQueue myUpdateQueue = new MergingUpdateQueue("Project Pane Updates Queue", 500, true, myScrollPane, null, null, true);

  public static final String ID = ProjectViewPane.ID;

  private FileEditorManagerAdapter myEditorListener = new FileEditorManagerAdapter() {
    @Override
    public void selectionChanged(FileEditorManagerEvent event) {
      FileEditor fileEditor = event.getNewEditor();
      if (fileEditor instanceof MPSFileNodeEditor) {
        final MPSFileNodeEditor editor = (MPSFileNodeEditor) fileEditor;
        if (getProjectView().isAutoscrollFromSource(ID)) {
          EditorComponent editorComponent = editor.getNodeEditor().getCurrentEditorComponent();
          if (editorComponent == null) return;
          final SNode sNode = editorComponent.getEditedNode();
          ModelAccess.instance().runReadInEDT(new Runnable() {
            @Override
            public void run() {
              selectNodeWithoutExpansion(sNode);
            }
          });
        }
      }
    }
  };
  private Set<ComponentCreationListener> myComponentCreationListeners;
  private static boolean ourShowGenStatus = true;

  public ProjectPane(final Project project, ProjectView projectView) {
    super(project, projectView);
    myUpdateQueue.setRestartTimerOnAdd(true);
    ReloadManager.getInstance().addReloadListener(new ReloadListener() {
      @Override
      public void reloadStarted() {

      }

      @Override
      public void reloadFinished() {
        rebuild();
      }
    });
  }

  @Override
  protected void removeListeners() {
    super.removeListeners();
    FileEditorManager fileEditorManager = getProject().getComponent(FileEditorManager.class);
    fileEditorManager.removeFileEditorManagerListener(myEditorListener);
  }

  @Override
  protected void addListeners() {
    super.addListeners();
    getProject().getComponent(FileEditorManager.class).addFileEditorManagerListener(myEditorListener);
  }

  @Hack
  public static ProjectPane getInstance(Project project) {
    final ProjectView projectView = ProjectView.getInstance(project);

    
    
    projectView.getSelectInTargets();

    return (ProjectPane) projectView.getProjectViewPaneById(ID);
  }

  public static ProjectPane getInstance(jetbrains.mps.project.Project mpsProject) {
    if (mpsProject instanceof MPSProject) {
      return getInstance(((MPSProject) mpsProject).getProject());
    }
    return null;
  }

  @Override
  public ProjectTree getTree() {
    return (jetbrains.mps.ide.projectPane.logicalview.ProjectTree) myTree;
  }

  @Override
  public String getTitle() {
    return "Logical View";
  }

  @Override
  @NotNull
  public String getId() {
    return ID;
  }

  @Override
  public int getWeight() {
    return 0;
  }

  @Override
  public SelectInTarget createSelectInTarget() {
    return new ProjectPaneSelectInTarget(this.myProject, true);
  }

  @Override
  public Icon getIcon() {
    return MPSIcons.ProjectPane.LogicalView;
  }

  @Override
  public ActionCallback updateFromRoot(boolean restoreExpandedPaths) {
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.REBUILD) {
      @Override
      public void run() {
        if (getTree() == null) {
          return;
        }
        getTree().rebuildNow();
      }
    });
    return new ActionCallback(); 
  }

  @Override
  public void select(Object element, final VirtualFile file, final boolean requestFocus) {

  }

  @Override
  public JComponent createComponent() {
    if (isComponentCreated()) return myScrollPane;

    ProjectPaneTree tree = new ProjectPaneTree(this, myProject);
    Disposer.register(this, tree);
    tree.setShowStructureCondition(new Computable<Boolean>() {
      @Override
      public Boolean compute() {
        if (myProject.isDisposed()) return false;
        return ProjectPane.getInstance(myProject).showNodeStructure();
      }
    });
    myTree = tree;

    myScrollPane = new MyScrollPane(getTree());
    addListeners();
    if (!RuntimeFlags.isTestMode()) {
      
      ThreadUtils.runInUIThreadNoWait(new Runnable() {
        @Override
        public void run() {
          rebuildTree();
        }
      });
    }
    TreeHighlighterExtension.attachHighlighters(tree, myProject);
    fireComponentCreated();
    return myScrollPane;
  }

  @Override
  protected boolean isComponentCreated() {
    return myScrollPane != null;
  }

  public void rebuildTree() {
    myUpdateQueue.queue(new AbstractUpdate(UpdateID.REBUILD) {
      @Override
      public void run() {
        if (getTree() == null || getProject().isDisposed()) {
          return;
        }
        getTree().rebuildNow();
        getTree().expandProjectNode();
      }
    });
  }

  public void activate() {
    ThreadUtils.assertEDT();
    activatePane(new PaneActivator(false), true);
  }

  @Override
  public void rebuild() {
    ModelAccess.instance().runReadInEDT(new Runnable() {
      @Override
      public void run() {
        if (isDisposed() || getTree() == null) return;
        rebuildTree();
      }
    });
  }

  

  public void selectModule(@NotNull final SModule module, final boolean autofocus) {
    ModelAccess.instance().runReadInEDT(new Runnable() {
      @Override
      public void run() {
        activatePane(new PaneActivator(true) {
          @Override
          public void doOnPaneActivation() {
            MPSTreeNode moduleTreeNode = myFindHelper.findMostSuitableModuleTreeNode(module);

            if (moduleTreeNode == null) {
              LOG.warn("Couldn't select module \"" + module.getModuleName() + "\" : tree node not found.");
              return;
            }

            getTree().selectNode(moduleTreeNode);
          }
        }, autofocus);
      }
    });
  }

  public void selectModel(@NotNull final SModel model, boolean autofocus) {
    if (!ThreadUtils.isEventDispatchThread()) {
      throw new IllegalStateException("Can't use this outside of EDT");
    }
    activatePane(new PaneActivator(true) {
      @Override
      public void doOnPaneActivation() {
        SModelTreeNode modelTreeNode = myFindHelper.findMostSuitableModelTreeNode(model);
        if (modelTreeNode == null) {
          LOG.warn("Couldn't select model \"" + SNodeOperations.getModelLongName(model) + "\" : tree node not found.");
          return;
        }
        getTree().selectNode(modelTreeNode);
      }
    }, autofocus);
  }

  private void activatePane(PaneActivator activator, boolean autoFocusContents) {
    ToolWindowManager windowManager = ToolWindowManager.getInstance(getProject());
    ToolWindow projectViewToolWindow = windowManager.getToolWindow(ToolWindowId.PROJECT_VIEW);
    
    if(!ApplicationManager.getApplication().isUnitTestMode()) {
      projectViewToolWindow.activate(activator, autoFocusContents);
    }
  }

  public void selectNode(@NotNull final SNode node, boolean autofocus) {
    if (!ThreadUtils.isEventDispatchThread()) {
      throw new IllegalStateException("Can't use this outside of EDT");
    }
    activatePane(new PaneActivator(true) {
      @Override
      public void doOnPaneActivation() {
        selectNodeWithoutExpansion(node);
      }
    }, autofocus);
  }

  private void selectNodeWithoutExpansion(final SNode node) {
    getTree().runWithoutExpansion(new Runnable() {
      @Override
      public void run() {
        MPSTreeNodeEx sNodeNode = myFindHelper.findMostSuitableSNodeTreeNode(node);
        if (sNodeNode == null) {
          LOG.warn("Couldn't select node \"" + node.getName() + "\" : tree node not found.");
          return;
        }
        getTree().selectNode(sNodeNode);
      }
    });
  }

  

  @Override
  public void selectNextModel(SModel modelDescriptor) {
    final MPSTreeNode mpsTreeNode = myFindHelper.findNextTreeNode(modelDescriptor);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      @Override
      public void run() {
        ProjectTree tree = getTree();
        if (tree != null) {
          tree.selectNode(mpsTreeNode);
        }
      }
    });
  }

  public void selectNextNode(SNode node) {
    final MPSTreeNode mpsTreeNode = myFindHelper.findNextTreeNode(node);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      @Override
      public void run() {
        getTree().selectNode(mpsTreeNode);
      }
    });
  }

  

  public MPSTreeNode findNextTreeNode(SNode node) {
    return myFindHelper.findNextTreeNode(node);
  }

  private void fireComponentCreated() {
    if (myComponentCreationListeners == null) {
      return;
    }
    for (ComponentCreationListener l : myComponentCreationListeners.toArray(new ComponentCreationListener[myComponentCreationListeners.size()])) {
      l.componentCreated(this);
    }
  }

  public void addComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      myComponentCreationListeners = new HashSet();
    }
    myComponentCreationListeners.add(l);
  }

  public void removeComponentCreationListener(@NotNull ComponentCreationListener l) {
    if (myComponentCreationListeners == null) {
      return;
    }
    myComponentCreationListeners.remove(l);
    if (myComponentCreationListeners.isEmpty()) {
      myComponentCreationListeners = null;
    }
  }

  

  public static void setShowGenStatus(boolean showGenStatusInTree) {
    ourShowGenStatus = showGenStatusInTree;
  }

  public static boolean isShowGenStatus() {
    return ourShowGenStatus;
  }

  

  private class MyScrollPane extends JBScrollPane implements DataProvider {
    private MyScrollPane(Component view) {
      super(view);
    }

    @Override
    @Nullable
    public Object getData(@NonNls String dataId) {
      return ProjectPane.this.getData(dataId);
    }
  }

  private class PaneActivator implements Runnable {
    private boolean myRunReadAction;

    private PaneActivator(boolean runReadAction) {
      myRunReadAction = runReadAction;
    }

    @Override
    public final void run() {
      getProjectView().changeView(getId());
      myUpdateQueue.queue(new AbstractUpdate(UpdateID.SELECT) {
        @Override
        public void run() {
          
          if (myRunReadAction) {
            ModelAccess.instance().runReadAction(new Runnable() {
              @Override
              public void run() {
                doOnPaneActivation();
              }
            });
          } else {
            doOnPaneActivation();
          }
        }
      });
    }

    protected void doOnPaneActivation() {
    }
  }

  public interface ComponentCreationListener {
    void componentCreated(ProjectPane projectPane);
  }

  private enum UpdateID {
    REBUILD(20),
    SELECT(30);

    private int myPriority;

    UpdateID(int priority) {
      myPriority = priority;
    }

    public int getPriority() {
      return myPriority;
    }
  }

  private abstract class AbstractUpdate extends Update {
    private AbstractUpdate(UpdateID id) {
      super(id, id.getPriority());
    }
  }
}

<code block>

package jetbrains.mps.ide.projectView;

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.ex.ToolWindowManagerEx;
import org.jetbrains.annotations.NotNull;

@State(
    name="ProjectView",
    storages= {
        @Storage(
            file = StoragePathMacros.WORKSPACE_FILE
        )}
)
public class ProjectViewImpl extends com.intellij.ide.projectView.impl.ProjectViewImpl {
  public ProjectViewImpl(@NotNull Project project,
      FileEditorManager fileEditorManager, ToolWindowManagerEx toolWindowManager) {
    super(project, fileEditorManager, toolWindowManager);
  }

  @Override
  protected boolean isShowMembersOptionSupported() {
    return false;
  }
}

<code block>

package jetbrains.mps.ide.ui.tree;

import com.intellij.ide.DataManager;
import com.intellij.ide.dnd.aware.DnDAwareTree;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionGroup;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.openapi.wm.impl.IdeFocusManagerHeadless;
import com.intellij.ui.TreeUIHelper;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.ModelAccess;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.AbstractAction;
import javax.swing.JPopupMenu;
import javax.swing.KeyStroke;
import javax.swing.ToolTipManager;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.ExpandVetoException;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public abstract class MPSTree extends DnDAwareTree implements Disposable {
  public static final String PATH = "path";

  protected static final Logger LOG = LogManager.getLogger(MPSTree.class);

  public static final String TREE_PATH_SEPARATOR = "/";

  private int myTooltipManagerRecentInitialDelay;
  private boolean myAutoExpandEnabled = true;
  private boolean myAutoOpen = false;
  private boolean myLoadingDisabled;

  private Set<MPSTreeNode> myExpandingNodes = new HashSet<MPSTreeNode>();

  private List<MPSTreeNodeListener> myTreeNodeListeners = new ArrayList<MPSTreeNodeListener>();

  
  private MergingUpdateQueue myQueue = new MergingUpdateQueue("MPS Tree Rebuild Later Watcher Queue", 500, true, null);
  private final Object myUpdateId = new Object();

  private boolean myDisposed = false;

  protected MPSTree() {
    setRootNode(new TextTreeNode("Empty"));

    new MPSTreeSpeedSearch(this);

    ToolTipManager.sharedInstance().registerComponent(this);

    largeModel = true;

    TreeUIHelper.getInstance().installToolTipHandler(this);

    setCellRenderer(new NewMPSTreeCellRenderer());

    addTreeWillExpandListener(new MyTreeWillExpandListener());
    addTreeExpansionListener(new MyTreeExpansionListener());
    addMouseListener(new MyMouseAdapter());

    registerKeyboardAction(new MyOpenNodeAction(), KeyStroke.getKeyStroke("F4"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    registerKeyboardAction(new MyRefreshAction(), KeyStroke.getKeyStroke("F5"), WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }

  
  protected void doInit(final MPSTreeNode node) {
    assert ThreadUtils.isInEDT();
    if (myExpandingNodes.contains(node)) {
      return;
    }

    myExpandingNodes.add(node);
    try {
      TextTreeNode progressNode = null;
      if (!myLoadingDisabled && node.isLoadingEnabled()) {
        progressNode = new TextTreeNode("loading...");
        node.add(progressNode);
        ((DefaultTreeModel) getModel()).nodeStructureChanged(node);
        expandPath(new TreePath(progressNode.getPath()));

        Graphics g = getGraphics();
        if (g != null && g.getClipBounds() != null) paint(g);
      }

      ModelAccess.instance().runReadAction(new Runnable() {
        @Override
        public void run() {
          node.doInit();
        }
      });
      ((DefaultTreeModel) getModel()).nodeStructureChanged(node);

      if (!myLoadingDisabled && node.isLoadingEnabled() && node.hasChild(progressNode)) { 
        node.remove(progressNode);
        ((DefaultTreeModel) getModel()).nodeStructureChanged(node);
      }

    } finally {
      myExpandingNodes.remove(node);
    }
  }

  public void addTreeNodeListener(MPSTreeNodeListener listener) {
    myTreeNodeListeners.add(listener);
  }

  public void removeTreeNodeListener(MPSTreeNodeListener listener) {
    myTreeNodeListeners.remove(listener);
  }

  public void fireBeforeTreeDisposed() {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.beforeTreeDisposed(this);
    }
  }

  void fireTreeNodeUpdated(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeUpdated(node, this);
    }
  }

  void fireTreeNodeAdded(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeAdded(node, this);
    }
  }

  void fireTreeNodeRemoved(MPSTreeNode node) {
    for (MPSTreeNodeListener listener : new HashSet<MPSTreeNodeListener>(myTreeNodeListeners)) {
      listener.treeNodeRemoved(node, this);
    }
  }

  void myMouseReleased(MouseEvent e) {
    if (e.isPopupTrigger()) showPopup(e.getX(), e.getY());
  }

  void myMousePressed(final MouseEvent e) {
    Project p = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(this));
    IdeFocusManager focusManager;
    if (p != null) {
      focusManager = IdeFocusManager.getInstance(p);
    } else {
      focusManager = IdeFocusManagerHeadless.INSTANCE;
    }

    focusManager.requestFocus(this, true);

    TreePath path = getClosestPathForLocation(e.getX(), e.getY());
    if (path == null) return;

    Object lastPathComponent = path.getLastPathComponent();
    MPSTreeNode nodeToClick=null;
    if (lastPathComponent instanceof MPSTreeNode && ((MPSTreeNode) lastPathComponent).canBeOpened()) {
      nodeToClick = (MPSTreeNode) lastPathComponent;
      if ((e.getClickCount() == 1 && isAutoOpen())) {
        autoscroll(nodeToClick);
      } else if (e.getClickCount() == 2) {
        e.consume();
      }
    } else if (e.getButton() == MouseEvent.BUTTON3) {
      if (!isPathSelected(path)) {
        setSelectionPath(path);
      }
    }

    
    final MPSTreeNode node2dc = e.getClickCount()==2?nodeToClick:null;
    focusManager.doWhenFocusSettlesDown(new Runnable() {
      @Override
      public void run() {
        if (node2dc != null) {
          doubleClick(node2dc);
        }
        if (e.isPopupTrigger()) showPopup(e.getX(), e.getY());
      }
    });
  }

  
  protected void doubleClick(@NotNull MPSTreeNode nodeToClick) {
    nodeToClick.doubleClick();
  }

  
  protected void autoscroll(@NotNull MPSTreeNode nodeToClick) {
    nodeToClick.autoscroll();
  }

  public void runWithoutExpansion(Runnable r) {
    try {
      myAutoExpandEnabled = false;
      r.run();
    } finally {
      myAutoExpandEnabled = true;
    }
  }

  public boolean isAutoOpen() {
    return myAutoOpen;
  }

  public void setAutoOpen(boolean autoOpen) {
    myAutoOpen = autoOpen;
  }

  @Override
  public String getToolTipText(MouseEvent event) {
    TreePath path = getPathForLocation(event.getX(), event.getY());
    if (path != null && path.getLastPathComponent() instanceof MPSTreeNode) {
      final MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();
      return node.getTooltipText();
    }
    return null;
  }

  protected JPopupMenu createDefaultPopupMenu() {
    return null;
  }

  protected final JPopupMenu createPopupMenu(final MPSTreeNode node) {
    ActionGroup actionGroup = createPopupActionGroup(node);
    if (actionGroup == null) return null;
    return ActionManager.getInstance().createActionPopupMenu(getPopupMenuPlace(), actionGroup).getComponent();
  }

  protected String getPopupMenuPlace() {
    return ActionPlaces.UNKNOWN;
  }

  protected ActionGroup createPopupActionGroup(final MPSTreeNode node) {
    return null;
  }

  private void showPopup(int x, int y) {
    TreePath path = getPathForLocation(x, y);
    if (path != null && path.getLastPathComponent() instanceof MPSTreeNode) {
      final MPSTreeNode node = (MPSTreeNode) path.getLastPathComponent();
      JPopupMenu menu = createPopupMenu(node);
      if (menu != null) {
        if (!getSelectedPaths().contains(pathToString(path))) {
          setSelectionPath(path);
        }
        menu.show(this, x, y);
        return;
      }
    }

    JPopupMenu defaultMenu = createDefaultPopupMenu();
    if (defaultMenu == null) return;
    defaultMenu.show(this, x, y);
  }

  @Nullable
  public Comparator<Object> getChildrenComparator() {
    return null;
  }

  protected abstract MPSTreeNode rebuild();

  public void expandAll() {
    MPSTreeNode node = getRootNode();
    expandAll(node);
  }

  public void collapseAll() {
    MPSTreeNode node = getRootNode();
    collapseAll(node);
  }

  public void selectFirstLeaf() {
    List<MPSTreeNode> path = new ArrayList<MPSTreeNode>();
    MPSTreeNode current = getRootNode();

    while (true) {
      path.add(current);
      if (current.getChildCount() == 0) break;
      current = (MPSTreeNode) current.getChildAt(0);
    }

    setSelectionPath(new TreePath(path.toArray()));
  }

  public void expandRoot() {
    expandPath(new TreePath(new Object[]{getRootNode()}));
    getRootNode().init();
  }

  public void expandAll(MPSTreeNode node) {
    boolean wasLoadingDisabled = myLoadingDisabled;
    myLoadingDisabled = true;
    try {
      expandAllImpl(node);
    } finally {
      myLoadingDisabled = wasLoadingDisabled;
    }
  }
  private void expandAllImpl(MPSTreeNode node) {
    expandPath(new TreePath(node.getPath()));
    for (MPSTreeNode c : node) {
      expandAllImpl(c);
    }
  }

  public void collapseAll(MPSTreeNode node) {
    boolean wasAutoExpandEnabled = myAutoExpandEnabled;
    try {
      myAutoExpandEnabled = false;
      collapseAllImpl(node);
    } finally {
      myAutoExpandEnabled = wasAutoExpandEnabled;
    }
  }

  private void collapseAllImpl(MPSTreeNode node) {
    for (MPSTreeNode c : node) {
      collapseAllImpl(c);
    }
    if (node.isInitialized()) {
      super.collapsePath(new TreePath(node.getPath()));
    }
  }

  public void selectNode(TreeNode node) {
    List<TreeNode> nodes = new ArrayList<TreeNode>();
    while (node != null) {
      nodes.add(0, node);
      node = node.getParent();
    }
    if (nodes.size() == 0) return;
    TreePath path = new TreePath(nodes.toArray());
    setSelectionPath(path);
    scrollRowToVisible(getRowForPath(path));
  }

  
  public void runRebuildAction(final Runnable rebuildAction, final boolean saveExpansion) {
    if (RuntimeFlags.isTestMode()) {
      return;
    }
    if (!ThreadUtils.isInEDT()) {
      throw new RuntimeException("Rebuild now can be only called from UI thread");
    }


    myLoadingDisabled = true;
    try {
      Runnable restoreExpansion = null;
      if (saveExpansion) {
        final List<String> expansion = getExpandedPaths();
        final List<String> selection = getSelectedPaths();
        restoreExpansion = new Runnable() {
          @Override
          public void run() {
            expandPaths(expansion);
            selectPaths(selection);
          }
        };
      }
      ModelAccess.instance().runReadAction(rebuildAction);
      if (restoreExpansion != null) {
          runWithoutExpansion(restoreExpansion);
      }
    } finally {
      myLoadingDisabled = false;
    }
  }

  public void rebuildLater() {
    myQueue.queue(new Update(myUpdateId) {
      @Override
      public void run() {
        ThreadUtils.runInUIThreadNoWait(new Runnable() {
          @Override
          public void run() {
            if (MPSTree.this.isDisposed()) return;
            rebuildNow();
          }
        });
      }
    });
  }

  public void rebuildNow() {
    if (!ThreadUtils.isInEDT()) {
      throw new RuntimeException("Rebuild now can be only called from UI thread");
    }
    assert !isDisposed() : "Trying to reconstruct disposed tree. Try finding \"later\" in stacktrace";

    runRebuildAction(new Runnable() {
      @Override
      public void run() {
        setAnchorSelectionPath(null);
        setLeadSelectionPath(null);

        MPSTreeNode root = rebuild();
        setRootNode(root);
      }
    }, true);
  }

  public void clear() {
    setRootNode(new TextTreeNode("Empty"));
  }

  private void setRootNode(@Nullable MPSTreeNode root) {
    final Object oldRoot = getModel().getRoot();
    if (oldRoot instanceof MPSTreeNode) {
      ((MPSTreeNode) oldRoot).removeThisAndChildren();
      ((MPSTreeNode) oldRoot).setTree(null);
    }

    if (root != null) {
      root.setTree(this);
      root.addThisAndChildren();
    }

    DefaultTreeModel model = new DefaultTreeModel(root);
    setModel(model);
  }

  private String pathToString(TreePath path) {
    StringBuilder result = new StringBuilder();
    for (int i = 1; i < path.getPathCount(); i++) {
      MPSTreeNode node = (MPSTreeNode) path.getPathComponent(i);
      result.append(TREE_PATH_SEPARATOR);
      result.append(node.getNodeIdentifier().replaceAll(TREE_PATH_SEPARATOR, "-"));
    }
    if (result.length() == 0) return TREE_PATH_SEPARATOR;
    return result.toString();
  }

  public TreeNode findNodeWith(Object userObject) {
    MPSTreeNode root = getRootNode();
    return findNodeWith(root, userObject);
  }

  public MPSTreeNode getRootNode() {
    return (MPSTreeNode) getModel().getRoot();
  }

  public MPSTreeNode getCurrentNode() {
    javax.swing.tree.TreePath path = getLeadSelectionPath();
    if (path == null) {
      return null;
    }
    Object obj = path.getLastPathComponent();
    if (!(obj instanceof TreeNode)) {
      return null;
    }
    return (MPSTreeNode) obj;
  }

  public void setCurrentNode(MPSTreeNode node) {
    TreePath path = new TreePath(node.getPath());
    setSelectionPath(path);
    this.scrollPathToVisible(path);
  }

  private MPSTreeNode findNodeWith(MPSTreeNode root, Object userObject) {
    if (root.getUserObject() == userObject) return root;
    if (!(root.isInitialized() || root.hasInfiniteSubtree())) root.init();
    for (MPSTreeNode child : root) {
      MPSTreeNode result = findNodeWith(child, userObject);
      if (result != null) return result;
    }
    return null;
  }

  private TreePath stringToPath(String pathString) {
    String[] components = pathString.split(TREE_PATH_SEPARATOR);
    List<Object> path = new ArrayList<Object>();
    MPSTreeNode current = getRootNode();

    current.init();

    path.add(current);

    for (int j = 0; j < components.length; j++) {
      String component = components[j];
      assert current.isInitialized();
      if (component == null || component.length() == 0) continue;
      boolean found = false;
      for (int i = 0; i < current.getChildCount(); i++) {
        MPSTreeNode node = (MPSTreeNode) current.getChildAt(i);
        if (node.getNodeIdentifier().replaceAll(TREE_PATH_SEPARATOR, "-").equals(component)) {
          current = node;
          path.add(current);
          if (!current.isInitialized() && j != components.length - 1) {
            current.init();
          }
          found = true;
          break;
        }
      }
      if (!found) {
        return null;
      }
    }
    return new TreePath(path.toArray());
  }

  protected void expandPaths(List<String> paths) {
    for (String path : paths) {
      TreePath treePath = stringToPath(path);
      if (treePath != null) {
        ensurePathInitialized(treePath);
        expandPath(treePath);
      }
    }
  }

  private void ensurePathInitialized(TreePath path) {
    for (Object item : path.getPath()) {
      MPSTreeNode node = (MPSTreeNode) item;
      node.init();
    }
  }

  protected void selectPaths(List<String> paths) {
    List<TreePath> treePaths = new ArrayList<TreePath>();
    for (String path : paths) {
      treePaths.add(stringToPath(path));
    }
    setSelectionPaths(treePaths.toArray(new TreePath[treePaths.size()]));
  }

  private List<String> getExpandedPaths() {
    List<String> result = new ArrayList<String>();
    Enumeration<TreePath> expanded = getExpandedDescendants(new TreePath(new Object[]{getModel().getRoot()}));
    if (expanded == null) return result;
    while (expanded.hasMoreElements()) {
      TreePath path = expanded.nextElement();
      String pathString = pathToString(path);
      if (result.contains(pathString))
        LOG.warn("two expanded paths have the same string representation");
      result.add(pathString);
    }
    return result;
  }

  private List<String> getSelectedPaths() {
    List<String> result = new ArrayList<String>();
    if (getSelectionPaths() == null) return result;
    for (TreePath selectionPart : getSelectionPaths()) {
      String pathString = pathToString(selectionPart);
      if (result.contains(pathString))
        LOG.warn("two selected paths have the same string representation");
      result.add(pathString);
    }
    return result;
  }

  public TreeState saveState() {
    TreeState result = new TreeState();
    result.myExpansion.addAll(getExpandedPaths());
    result.mySelection.addAll(getSelectedPaths());
    return result;
  }

  public void loadState(TreeState state) {
    selectPaths(state.mySelection);
    expandPaths(state.myExpansion);
  }

  @Override
  public int getToggleClickCount() {
    TreePath selection = getSelectionPath();
    if (selection == null) return -1;
    if (selection.getLastPathComponent() instanceof MPSTreeNode) {
      MPSTreeNode node = (MPSTreeNode) selection.getLastPathComponent();
      return node.getToggleClickCount();
    }
    return -1;
  }

  public boolean isDisposed() {
    return myDisposed;
  }

  @Override
  public void dispose() {
    assert !myDisposed;

    fireBeforeTreeDisposed();
    myDisposed = true;
    setRootNode(null);
    myTreeNodeListeners.clear();
  }

  public static class TreeState {
    private List<String> myExpansion = new ArrayList<String>();
    private List<String> mySelection = new ArrayList<String>();

    public List<String> getExpansion() {
      return myExpansion;
    }

    public void setExpansion(List<String> expansion) {
      myExpansion = expansion;
    }

    public List<String> getSelection() {
      return mySelection;
    }

    public void setSelection(List<String> selection) {
      mySelection = selection;
    }
  }

  private class MyTreeWillExpandListener implements TreeWillExpandListener {
    @Override
    public void treeWillExpand(TreeExpansionEvent event) throws ExpandVetoException {
      TreePath path = event.getPath();
      Object node = path.getLastPathComponent();
      MPSTreeNode treeNode = (MPSTreeNode) node;
      treeNode.init();
    }

    @Override
    public void treeWillCollapse(TreeExpansionEvent event) throws ExpandVetoException {
    }
  }

  private class MyTreeExpansionListener implements TreeExpansionListener {
    @Override
    public void treeExpanded(TreeExpansionEvent event) {
      if (!myAutoExpandEnabled) return;

      TreePath eventPath = event.getPath();
      MPSTreeNode node = (MPSTreeNode) eventPath.getLastPathComponent();

      if (node.getChildCount() == 1) {
        List<MPSTreeNode> path = new ArrayList<MPSTreeNode>();
        for (Object item : eventPath.getPath()) {
          path.add((MPSTreeNode) item);
        }
        MPSTreeNode onlyChild = (MPSTreeNode) node.getChildAt(0);

        if (onlyChild.isAutoExpandable()) {
          path.add(onlyChild);
          expandPath(new TreePath(path.toArray()));
        }
      }
    }

    @Override
    public void treeCollapsed(TreeExpansionEvent event) {
    }
  }

  private class MyMouseAdapter extends MouseAdapter {
    @Override
    public void mousePressed(MouseEvent e) {
      
      if (e.getButton() == 0) {
        TreePath path = getSelectionPath();
        if (path == null) return;
        int rowNum = getRowForPath(path);
        Rectangle r = getRowBounds(rowNum);
        showPopup(r.x, r.y);
      } else {
        requestFocus();
        myMousePressed(e);
      }
    }

    @Override
    public void mouseReleased(MouseEvent e) {
      myMouseReleased(e);
    }

    @Override
    public void mouseEntered(MouseEvent e) {
      myTooltipManagerRecentInitialDelay = ToolTipManager.sharedInstance().getInitialDelay();
      ToolTipManager.sharedInstance().setInitialDelay(10);
    }

    @Override
    public void mouseExited(MouseEvent e) {
      ToolTipManager.sharedInstance().setInitialDelay(myTooltipManagerRecentInitialDelay);
    }
  }

  private class MyOpenNodeAction extends AbstractAction {
    @Override
    public void actionPerformed(ActionEvent e) {
      TreePath selPath = getSelectionPath();
      if (selPath == null) return;
      MPSTreeNode selNode = (MPSTreeNode) selPath.getLastPathComponent();
      doubleClick(selNode);
    }
  }

  private class MyRefreshAction extends AbstractAction {
    @Override
    public void actionPerformed(ActionEvent e) {
      rebuildNow();
    }
  }
}

<code block>

package jetbrains.mps.nodeEditor.cellProviders;

import jetbrains.mps.nodeEditor.cellActions.CellAction_InsertIntoCollection;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.model.SNode;

import java.util.Iterator;
import java.util.List;

public abstract class AbstractCellListHandler {
  public static final String ELEMENT_CELL_ACTIONS_SET = "element-cell-actions-set";

  protected SNode myOwnerNode;
  protected EditorContext myEditorContext;
  protected EditorCell_Collection myListEditorCell_Collection;
  protected String myElementRole;

  public AbstractCellListHandler(SNode ownerNode, String elementRole, EditorContext editorContext) {
    myOwnerNode = ownerNode;
    myElementRole = elementRole;
    myEditorContext = editorContext;
  }

  public EditorContext getEditorContext() {
    return myEditorContext;
  }

  public SNode getOwner() {
    return myOwnerNode;
  }

  public String getElementRole() {
    return myElementRole;
  }

  protected abstract SNode getAnchorNode(EditorCell anchorCell);

  
  @Deprecated
  protected void doInsertNode(SNode anchorNode, boolean insertBefore) {
  }

  
  protected void doInsertNode(SNode nodeToInsert, SNode anchorNode, boolean insertBefore) {
    doInsertNode(anchorNode, insertBefore);
  }

  
  @Deprecated
  public void startInsertMode(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {
    SNode anchorNode = getAnchorNode(anchorCell);
    SNode nodeToInsert = createNodeToInsert(editorContext);
    doInsertNode(nodeToInsert, anchorNode, insertBefore);
  }

  public void insertNewChild(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {
    startInsertMode(editorContext, anchorCell, insertBefore);
  }

  public abstract EditorCell createNodeCell(EditorContext editorContext, SNode node);

  protected EditorCell createSeparatorCell(EditorContext editorContext, SNode prevNode, SNode nextNode) {
    return null;
  }

  protected abstract EditorCell createEmptyCell(EditorContext editorContext);

  public abstract SNode createNodeToInsert(EditorContext editorContext);

  public EditorCell_Collection createCells_Vertical(EditorContext editorContext) {
    return createCells(editorContext, new CellLayout_Vertical());
  }

  public EditorCell_Collection createCells_Horizontal(EditorContext editorContext) {
    return createCells(editorContext, new CellLayout_Horizontal());
  }

  public EditorCell_Collection createCells(EditorContext editorContext, CellLayout cellLayout, boolean selectable) {
    EditorCell_Collection cellsCollection = createCells(editorContext, cellLayout);
    if (!selectable) {
      return cellsCollection;
    }

    
    
    EditorCell_Collection wrapperCell = EditorCell_Collection.create(editorContext, myOwnerNode, new CellLayout_Horizontal(), null);
    wrapperCell.setSelectable(true);
    wrapperCell.addEditorCell(cellsCollection);
    return wrapperCell;
  }

  public EditorCell_Collection createCells(EditorContext editorContext, CellLayout cellLayout) {
    myListEditorCell_Collection = EditorCell_Collection.create(editorContext, myOwnerNode, cellLayout, this);
    myListEditorCell_Collection.setSelectable(false);

    createInnerCells(myOwnerNode, editorContext);

    
    myListEditorCell_Collection.setAction(CellActionType.INSERT, new CellAction_InsertIntoCollection(this, false));
    myListEditorCell_Collection.setAction(CellActionType.INSERT_BEFORE, new CellAction_InsertIntoCollection(this, true));

    return myListEditorCell_Collection;
  }

  protected void createInnerCells(SNode node, EditorContext editorContext) {
    Iterator<? extends SNode> listNodes = getNodesForList().iterator();
    if (!listNodes.hasNext()) {
      EditorCell emptyCell = createEmptyCell(editorContext);
      emptyCell.setRole(getElementRole());
      myListEditorCell_Collection.addEditorCell(emptyCell);
    } else {
      SNode prevNode = null;
      while (listNodes.hasNext()) {
        SNode nextNode = listNodes.next();
        addSeparatorCell(editorContext, prevNode, nextNode);
        myListEditorCell_Collection.addEditorCell(createNodeCell(editorContext, nextNode));
        prevNode = nextNode;
      }
    }
  }

  protected abstract List<? extends SNode> getNodesForList();

  private void addSeparatorCell(EditorContext editorContext, SNode prevNode, SNode nextNode) {
    if (prevNode == null) {
      return;
    }
    EditorCell separatorCell = createSeparatorCell(editorContext, prevNode, nextNode);
    if (separatorCell != null) {
      myListEditorCell_Collection.addEditorCell(separatorCell);
    }
  }
}

<code block>

package jetbrains.mps.nodeEditor.cellProviders;

import jetbrains.mps.nodeEditor.cellActions.CellAction_InsertIntoCollection;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Horizontal;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Vertical;
import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.model.SNode;

import java.util.Iterator;
import java.util.List;

public abstract class AbstractCellListHandler {
  public static final String ELEMENT_CELL_ACTIONS_SET = "element-cell-actions-set";

  protected SNode myOwnerNode;
  protected EditorContext myEditorContext;
  protected EditorCell_Collection myListEditorCell_Collection;
  protected String myElementRole;

  public AbstractCellListHandler(SNode ownerNode, String elementRole, EditorContext editorContext) {
    myOwnerNode = ownerNode;
    myElementRole = elementRole;
    myEditorContext = editorContext;
  }

  public EditorContext getEditorContext() {
    return myEditorContext;
  }

  public SNode getOwner() {
    return myOwnerNode;
  }

  public String getElementRole() {
    return myElementRole;
  }

  protected abstract SNode getAnchorNode(EditorCell anchorCell);

  protected abstract void doInsertNode(SNode nodeToInsert, SNode anchorNode, boolean insertBefore);

  public void insertNewChild(EditorContext editorContext, EditorCell anchorCell, boolean insertBefore) {
    SNode anchorNode = getAnchorNode(anchorCell);
    SNode nodeToInsert = createNodeToInsert(editorContext);
    doInsertNode(nodeToInsert, anchorNode, insertBefore);
  }

  public abstract EditorCell createNodeCell(EditorContext editorContext, SNode node);

  protected EditorCell createSeparatorCell(EditorContext editorContext, SNode prevNode, SNode nextNode) {
    return null;
  }

  protected abstract EditorCell createEmptyCell(EditorContext editorContext);

  public abstract SNode createNodeToInsert(EditorContext editorContext);

  public EditorCell_Collection createCells_Vertical(EditorContext editorContext) {
    return createCells(editorContext, new CellLayout_Vertical());
  }

  public EditorCell_Collection createCells_Horizontal(EditorContext editorContext) {
    return createCells(editorContext, new CellLayout_Horizontal());
  }

  public EditorCell_Collection createCells(EditorContext editorContext, CellLayout cellLayout, boolean selectable) {
    EditorCell_Collection cellsCollection = createCells(editorContext, cellLayout);
    if (!selectable) {
      return cellsCollection;
    }

    
    
    EditorCell_Collection wrapperCell = EditorCell_Collection.create(editorContext, myOwnerNode, new CellLayout_Horizontal(), null);
    wrapperCell.setSelectable(true);
    wrapperCell.addEditorCell(cellsCollection);
    return wrapperCell;
  }

  public EditorCell_Collection createCells(EditorContext editorContext, CellLayout cellLayout) {
    myListEditorCell_Collection = EditorCell_Collection.create(editorContext, myOwnerNode, cellLayout, this);
    myListEditorCell_Collection.setSelectable(false);

    createInnerCells(myOwnerNode, editorContext);

    
    myListEditorCell_Collection.setAction(CellActionType.INSERT, new CellAction_InsertIntoCollection(this, false));
    myListEditorCell_Collection.setAction(CellActionType.INSERT_BEFORE, new CellAction_InsertIntoCollection(this, true));

    return myListEditorCell_Collection;
  }

  protected void createInnerCells(SNode node, EditorContext editorContext) {
    Iterator<? extends SNode> listNodes = getNodesForList().iterator();
    if (!listNodes.hasNext()) {
      EditorCell emptyCell = createEmptyCell(editorContext);
      emptyCell.setRole(getElementRole());
      myListEditorCell_Collection.addEditorCell(emptyCell);
    } else {
      SNode prevNode = null;
      while (listNodes.hasNext()) {
        SNode nextNode = listNodes.next();
        addSeparatorCell(editorContext, prevNode, nextNode);
        myListEditorCell_Collection.addEditorCell(createNodeCell(editorContext, nextNode));
        prevNode = nextNode;
      }
    }
  }

  protected abstract List<? extends SNode> getNodesForList();

  private void addSeparatorCell(EditorContext editorContext, SNode prevNode, SNode nextNode) {
    if (prevNode == null) {
      return;
    }
    EditorCell separatorCell = createSeparatorCell(editorContext, prevNode, nextNode);
    if (separatorCell != null) {
      myListEditorCell_Collection.addEditorCell(separatorCell);
    }
  }
}
