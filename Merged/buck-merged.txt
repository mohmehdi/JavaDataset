

package com.facebook.buck.android.aapt;

import static com.google.common.base.Preconditions.checkNotNull;

import com.facebook.buck.android.aapt.RDotTxtEntry.IdType;
import com.facebook.buck.android.aapt.RDotTxtEntry.RType;
import com.google.common.base.Joiner;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.util.Collections;
import java.util.Map;
import java.util.Set;


public class AaptResourceCollector {

  private int currentTypeId;
  private final Map<RType, ResourceIdEnumerator> enumerators;
  private final Set<RDotTxtEntry> resources;

  public AaptResourceCollector() {
    this.enumerators = Maps.newHashMap();
    this.resources = Sets.newHashSet();
    this.currentTypeId = 1;
  }

  public void addIntResourceIfNotPresent(RType rType, String name) {
    if (!enumerators.containsKey(rType)) {
      enumerators.put(rType, new ResourceIdEnumerator(currentTypeId++));
    }

    RDotTxtEntry entry = new FakeRDotTxtEntry(IdType.INT, rType, name);
    if (!resources.contains(entry)) {
      String idValue = String.format("0x%08x", checkNotNull(enumerators.get(rType)).next());
      addResource(rType, IdType.INT, name, idValue);
    }
  }

  public void addIntArrayResourceIfNotPresent(RType rType, String name, int numValues) {


    String idValue = String.format(
        "{ %s }",
        Joiner.on(",").join(Collections.nCopies(numValues, "0x7f000000")));
    addResource(rType, IdType.INT_ARRAY, name, idValue);
  }

  public void addResource(RType rType, IdType idType, String name, String idValue) {
    resources.add(new RDotTxtEntry(idType, rType, name, idValue));
  }

  public Set<RDotTxtEntry> getResources() {
    return Collections.unmodifiableSet(resources);
  }

  private static class ResourceIdEnumerator {

    private int currentId;

    ResourceIdEnumerator(int typeId) {
      this.currentId = 0x7f000000 + 0x10000 * typeId + 1;
    }

    int next() {
      return currentId++;
    }
  }
}

<code block>


package com.facebook.buck.android.aapt;

import static org.hamcrest.Matchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.android.aapt.MiniAapt.ResourceParseException;
import com.facebook.buck.android.aapt.RDotTxtEntry.IdType;
import com.facebook.buck.android.aapt.RDotTxtEntry.RType;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.timing.FakeClock;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

import org.hamcrest.junit.ExpectedException;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;

import javax.xml.xpath.XPathExpressionException;

public class MiniAaptTest {

  private static final ImmutableList<String> RESOURCES = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@id/button2\" ",
        "android:text=\"@string/text\" />",
        "<Button android:id=\"@+id/button3\" ",
        "style:attribute=\"@style/Buck.Theme\" ",
        "android:background=\"@drawable/some_image\" />",
        "<TextView tools:showIn=\"@layout/some_layout\" android:id=\"@id/android:empty\" />",
        "</LinearLayout>")
        .build();

  private final FakeProjectFilesystem filesystem = new FakeProjectFilesystem();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void testFindingResourceIdsInXml()
      throws IOException, XPathExpressionException, ResourceParseException {
    filesystem.writeLinesToPath(RESOURCES, Paths.get("resource.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());

    ImmutableSet.Builder<RDotTxtEntry> references = ImmutableSet.builder();
    aapt.processXmlFile(filesystem, Paths.get("resource.xml"), references);

    Set<RDotTxtEntry> definitions = aapt.getResourceCollector().getResources();

    assertEquals(
        definitions,
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button1"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button3")));

    assertEquals(
        references.build(),
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "some_image"),
            new FakeRDotTxtEntry(IdType.INT, RType.STRING, "text"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLE, "Buck_Theme"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button2")));
  }


  @Test
  public void testParsingFilesUnderValuesDirectory() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<string name=\"hello\">Hello, <xliff:g id=\"name\">%s</xliff:g>!</string>",
        "<plurals name=\"people\">",
        "   <item quantity=\"zero\">ignore1</item>",
        "   <item quantity=\"many\">ignore2</item>",
        "</plurals>",
        "<skip />",
        "<integer name=\"number\">100</integer>",
        "<dimen name=\"dimension\">100sp</dimen>",
        "<declare-styleable name=\"MyNiceView\">",
        "   <attr name=\"titleText\" />",
        "   <attr name=\"subtitleText\" format=\"string\" />",
        "   <attr name=\"complexAttr\">",
        "       <enum name=\"shouldBeIgnored\" value=\"0\" />",
        "       <enum name=\"alsoIgnore\" value=\"1\" />",
        "       <flag name=\"uselessFlag\" value=\"0x00\" />",
        "   </attr>",
        "   <attr name=\"android:layout_gravity\" />",
        "   <item name=\"should_be_ignored\" />",
        "</declare-styleable>",
        "<eat-comment />",
        "<item type=\"id\" name=\"some_id\" />",
        "<style name=\"Widget.Theme\">",
        "  <item name=\"ignoreMe\" />",
        "</style>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));

    Set<RDotTxtEntry> definitions = aapt.getResourceCollector().getResources();

    assertEquals(
        definitions,
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.STRING, "hello"),
            new FakeRDotTxtEntry(IdType.INT, RType.PLURALS, "people"),
            new FakeRDotTxtEntry(IdType.INT, RType.INTEGER, "number"),
            new FakeRDotTxtEntry(IdType.INT, RType.DIMEN, "dimension"),
            new FakeRDotTxtEntry(IdType.INT_ARRAY, RType.STYLEABLE, "MyNiceView"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_titleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_subtitleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_complexAttr"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_android_layout_gravity"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "titleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "subtitleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "complexAttr"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "some_id"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLE, "Widget_Theme")));

    boolean foundElement = false;
    for (RDotTxtEntry definition : definitions) {
      if (definition.name.equals("MyNiceView")) {
        assertEquals(
            "{ 0x7f000000,0x7f000000,0x7f000000,0x7f000000 }",
            definition.idValue);
        foundElement = true;
      }
    }
    assertTrue(foundElement);
  }

  @Test(expected = ResourceParseException.class)
  public void testInvalidResourceType() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<resourcetype name=\"number\">100</resourcetype>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test(expected = ResourceParseException.class)
  public void testInvalidItemResource() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<item name=\"number\">100</item>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test
  public void testInvalidDefinition() throws XPathExpressionException, IOException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+string/button1\" ",
        "android:layout_toLeftOf=\"@id/button2\" ",
        "android:text=\"@string/text\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    try {
      aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
      fail("MiniAapt should throw parsing '@+string/button1'");
    } catch (ResourceParseException e) {
      assertThat(e.getMessage(), containsString("Invalid definition of a resource"));
    }
  }

  @Test
  public void testInvalidReference() throws IOException, XPathExpressionException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@someresource/button2\" ",
        "android:text=\"@string/text\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    try {
      aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
      fail("MiniAapt should throw parsing '@someresource/button2'");
    } catch (ResourceParseException e) {
      assertThat(e.getMessage(), containsString("Invalid reference '@someresource/button2'"));
    }
  }

  @Test
  public void testMissingNameAttribute() throws IOException, ResourceParseException {
    thrown.expect(ResourceParseException.class);
    thrown.expectMessage("Error: expected a 'name' attribute in node 'string' with value 'Howdy!'");

    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<string notname=\"hello\">Howdy!</string>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test
  public void testVerifyReferences()
      throws IOException, XPathExpressionException, ResourceParseException {
    filesystem.writeLinesToPath(RESOURCES, Paths.get("resource.xml"));

    ImmutableList<String> rDotTxt = ImmutableList.of(
        "int string text 0x07010001",
        "int style Buck_Theme 0x07020001",
        "int id button2 0x07030001");

    Path depRTxt = Paths.get("dep/R.txt");
    filesystem.writeLinesToPath(rDotTxt, depRTxt);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.of(depRTxt));
    ImmutableSet.Builder<RDotTxtEntry> references = ImmutableSet.builder();
    aapt.processXmlFile(filesystem, Paths.get("resource.xml"), references);

    Set<RDotTxtEntry> missing = aapt.verifyReferences(filesystem, references.build());

    assertEquals(
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "some_image")),
        missing);
  }

  @Test
  public void testInvalidNodeId() throws
      IOException, XPathExpressionException, ResourceParseException {
    thrown.expect(ResourceParseException.class);
    thrown.expectMessage("Invalid definition of a resource: '@button2'");

    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@button2\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
  }

  @Test
  public void testProcessFileNamesInDirectory() throws IOException, ResourceParseException {
    filesystem.touch(Paths.get("res/drawable/icon.png"));
    filesystem.touch(Paths.get("res/drawable/another_icon.png.orig"));
    filesystem.touch(Paths.get("res/drawable-ldpi/nine_patch.9.png"));
    filesystem.touch(Paths.get("res/drawable-ldpi/.DS_Store"));
    filesystem.touch(Paths.get("res/transition-v19/some_transition.xml"));
    filesystem.writeContentsToPath(
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
            "<resources>" +
            "<bool name=\"v\">false</bool>" +
            "</resources>",
        Paths.get("res/values/value.xml~"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/drawable"));
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/drawable-ldpi"));
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/transition-v19"));
    aapt.processValues(
        filesystem,
        new BuckEventBus(new FakeClock(0), new BuildId("")),
        Paths.get("res/values"));

    assertEquals(
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "icon"),
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "nine_patch"),
            new FakeRDotTxtEntry(IdType.INT, RType.TRANSITION, "some_transition")),
        aapt.getResourceCollector().getResources());
  }
}

<code block>


package com.facebook.buck.android.aapt;

import static com.google.common.base.Preconditions.checkNotNull;

import com.facebook.buck.android.aapt.RDotTxtEntry.IdType;
import com.facebook.buck.android.aapt.RDotTxtEntry.RType;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.util.Collections;
import java.util.Map;
import java.util.Set;


public class AaptResourceCollector {

  private int currentTypeId;
  private final Map<RType, ResourceIdEnumerator> enumerators;
  private final Set<RDotTxtEntry> resources;

  public AaptResourceCollector() {
    this.enumerators = Maps.newHashMap();
    this.resources = Sets.newHashSet();
    this.currentTypeId = 1;
  }

  public void addIntResourceIfNotPresent(RType rType, String name) {
    RDotTxtEntry entry = new FakeRDotTxtEntry(IdType.INT, rType, name);
    if (!resources.contains(entry)) {
      String idValue = String.format("0x%08x", getEnumerator(rType).next());
      addResource(rType, IdType.INT, name, idValue);
    }
  }

  public void addIntArrayResourceIfNotPresent(RType rType, String name, int numValues) {


    ImmutableList.Builder<String> values = ImmutableList.builder();
    for (int id = 0; id < numValues; id++) {
      values.add(String.format("0x%x", getEnumerator(rType).next()));
    }
    String idValue = String.format(
        "{ %s }",
        Joiner.on(",").join(values.build()));
    addResource(rType, IdType.INT_ARRAY, name, idValue);
  }

  public void addResource(RType rType, IdType idType, String name, String idValue) {
    resources.add(new RDotTxtEntry(idType, rType, name, idValue));
  }

  public Set<RDotTxtEntry> getResources() {
    return Collections.unmodifiableSet(resources);
  }

  ResourceIdEnumerator getEnumerator(RType rType) {
    if (!enumerators.containsKey(rType)) {
      enumerators.put(rType, new ResourceIdEnumerator(currentTypeId++));
    }
    return checkNotNull(enumerators.get(rType));
  }

  private static class ResourceIdEnumerator {

    private int currentId;

    ResourceIdEnumerator(int typeId) {
      this.currentId = 0x7f000000 + 0x10000 * typeId + 1;
    }

    int next() {
      return currentId++;
    }
  }
}

<code block>


package com.facebook.buck.android.aapt;

import static org.hamcrest.Matchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.android.aapt.MiniAapt.ResourceParseException;
import com.facebook.buck.android.aapt.RDotTxtEntry.IdType;
import com.facebook.buck.android.aapt.RDotTxtEntry.RType;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.timing.FakeClock;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

import org.hamcrest.junit.ExpectedException;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;

import javax.xml.xpath.XPathExpressionException;

public class MiniAaptTest {

  private static final ImmutableList<String> RESOURCES = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@id/button2\" ",
        "android:text=\"@string/text\" />",
        "<Button android:id=\"@+id/button3\" ",
        "style:attribute=\"@style/Buck.Theme\" ",
        "android:background=\"@drawable/some_image\" />",
        "<TextView tools:showIn=\"@layout/some_layout\" android:id=\"@id/android:empty\" />",
        "</LinearLayout>")
        .build();

  private final FakeProjectFilesystem filesystem = new FakeProjectFilesystem();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void testFindingResourceIdsInXml()
      throws IOException, XPathExpressionException, ResourceParseException {
    filesystem.writeLinesToPath(RESOURCES, Paths.get("resource.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());

    ImmutableSet.Builder<RDotTxtEntry> references = ImmutableSet.builder();
    aapt.processXmlFile(filesystem, Paths.get("resource.xml"), references);

    Set<RDotTxtEntry> definitions = aapt.getResourceCollector().getResources();

    assertEquals(
        definitions,
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button1"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button3")));

    assertEquals(
        references.build(),
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "some_image"),
            new FakeRDotTxtEntry(IdType.INT, RType.STRING, "text"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLE, "Buck_Theme"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "button2")));
  }


  @Test
  public void testParsingFilesUnderValuesDirectory() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<string name=\"hello\">Hello, <xliff:g id=\"name\">%s</xliff:g>!</string>",
        "<plurals name=\"people\">",
        "   <item quantity=\"zero\">ignore1</item>",
        "   <item quantity=\"many\">ignore2</item>",
        "</plurals>",
        "<skip />",
        "<integer name=\"number\">100</integer>",
        "<dimen name=\"dimension\">100sp</dimen>",
        "<declare-styleable name=\"MyNiceView\">",
        "   <attr name=\"titleText\" />",
        "   <attr name=\"subtitleText\" format=\"string\" />",
        "   <attr name=\"complexAttr\">",
        "       <enum name=\"shouldBeIgnored\" value=\"0\" />",
        "       <enum name=\"alsoIgnore\" value=\"1\" />",
        "       <flag name=\"uselessFlag\" value=\"0x00\" />",
        "   </attr>",
        "   <attr name=\"android:layout_gravity\" />",
        "   <item name=\"should_be_ignored\" />",
        "</declare-styleable>",
        "<eat-comment />",
        "<item type=\"id\" name=\"some_id\" />",
        "<style name=\"Widget.Theme\">",
        "  <item name=\"ignoreMe\" />",
        "</style>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));

    Set<RDotTxtEntry> definitions = aapt.getResourceCollector().getResources();

    assertEquals(
        definitions,
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.STRING, "hello"),
            new FakeRDotTxtEntry(IdType.INT, RType.PLURALS, "people"),
            new FakeRDotTxtEntry(IdType.INT, RType.INTEGER, "number"),
            new FakeRDotTxtEntry(IdType.INT, RType.DIMEN, "dimension"),
            new FakeRDotTxtEntry(IdType.INT_ARRAY, RType.STYLEABLE, "MyNiceView"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_titleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_subtitleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_complexAttr"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLEABLE, "MyNiceView_android_layout_gravity"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "titleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "subtitleText"),
            new FakeRDotTxtEntry(IdType.INT, RType.ATTR, "complexAttr"),
            new FakeRDotTxtEntry(IdType.INT, RType.ID, "some_id"),
            new FakeRDotTxtEntry(IdType.INT, RType.STYLE, "Widget_Theme")));

    boolean foundElement = false;
    for (RDotTxtEntry definition : definitions) {
      if (definition.name.equals("MyNiceView")) {
        assertEquals(
            "{ 0x7f060001,0x7f060002,0x7f060003,0x7f060004 }",
            definition.idValue);
        foundElement = true;
      }
    }
    assertTrue(foundElement);
  }

  @Test(expected = ResourceParseException.class)
  public void testInvalidResourceType() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<resourcetype name=\"number\">100</resourcetype>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test(expected = ResourceParseException.class)
  public void testInvalidItemResource() throws IOException, ResourceParseException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<item name=\"number\">100</item>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test
  public void testInvalidDefinition() throws XPathExpressionException, IOException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+string/button1\" ",
        "android:layout_toLeftOf=\"@id/button2\" ",
        "android:text=\"@string/text\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    try {
      aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
      fail("MiniAapt should throw parsing '@+string/button1'");
    } catch (ResourceParseException e) {
      assertThat(e.getMessage(), containsString("Invalid definition of a resource"));
    }
  }

  @Test
  public void testInvalidReference() throws IOException, XPathExpressionException {
    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@someresource/button2\" ",
        "android:text=\"@string/text\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    try {
      aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
      fail("MiniAapt should throw parsing '@someresource/button2'");
    } catch (ResourceParseException e) {
      assertThat(e.getMessage(), containsString("Invalid reference '@someresource/button2'"));
    }
  }

  @Test
  public void testMissingNameAttribute() throws IOException, ResourceParseException {
    thrown.expect(ResourceParseException.class);
    thrown.expectMessage("Error: expected a 'name' attribute in node 'string' with value 'Howdy!'");

    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<resources>",
        "<string notname=\"hello\">Howdy!</string>",
        "</resources>")
        .build();

    filesystem.writeLinesToPath(lines, Paths.get("values.xml"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processValuesFile(filesystem, Paths.get("values.xml"));
  }

  @Test
  public void testVerifyReferences()
      throws IOException, XPathExpressionException, ResourceParseException {
    filesystem.writeLinesToPath(RESOURCES, Paths.get("resource.xml"));

    ImmutableList<String> rDotTxt = ImmutableList.of(
        "int string text 0x07010001",
        "int style Buck_Theme 0x07020001",
        "int id button2 0x07030001");

    Path depRTxt = Paths.get("dep/R.txt");
    filesystem.writeLinesToPath(rDotTxt, depRTxt);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.of(depRTxt));
    ImmutableSet.Builder<RDotTxtEntry> references = ImmutableSet.builder();
    aapt.processXmlFile(filesystem, Paths.get("resource.xml"), references);

    Set<RDotTxtEntry> missing = aapt.verifyReferences(filesystem, references.build());

    assertEquals(
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "some_image")),
        missing);
  }

  @Test
  public void testInvalidNodeId() throws
      IOException, XPathExpressionException, ResourceParseException {
    thrown.expect(ResourceParseException.class);
    thrown.expectMessage("Invalid definition of a resource: '@button2'");

    ImmutableList<String> lines = ImmutableList.<String>builder().add(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<LinearLayout>",
        "<Button android:id=\"@+id/button1\" ",
        "android:layout_toLeftOf=\"@button2\" />",
        "</LinearLayout>")
        .build();

    Path resource = Paths.get("resource.xml");
    filesystem.writeLinesToPath(lines, resource);

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processXmlFile(filesystem, resource, ImmutableSet.<RDotTxtEntry>builder());
  }

  @Test
  public void testProcessFileNamesInDirectory() throws IOException, ResourceParseException {
    filesystem.touch(Paths.get("res/drawable/icon.png"));
    filesystem.touch(Paths.get("res/drawable/another_icon.png.orig"));
    filesystem.touch(Paths.get("res/drawable-ldpi/nine_patch.9.png"));
    filesystem.touch(Paths.get("res/drawable-ldpi/.DS_Store"));
    filesystem.touch(Paths.get("res/transition-v19/some_transition.xml"));
    filesystem.writeContentsToPath(
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
            "<resources>" +
            "<bool name=\"v\">false</bool>" +
            "</resources>",
        Paths.get("res/values/value.xml~"));

    MiniAapt aapt = new MiniAapt(Paths.get("res"), Paths.get("R.txt"), ImmutableSet.<Path>of());
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/drawable"));
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/drawable-ldpi"));
    aapt.processFileNamesInDirectory(filesystem, Paths.get("res/transition-v19"));
    aapt.processValues(
        filesystem,
        new BuckEventBus(new FakeClock(0), new BuildId("")),
        Paths.get("res/values"));

    assertEquals(
        ImmutableSet.<RDotTxtEntry>of(
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "icon"),
            new FakeRDotTxtEntry(IdType.INT, RType.DRAWABLE, "nine_patch"),
            new FakeRDotTxtEntry(IdType.INT, RType.TRANSITION, "some_transition")),
        aapt.getResourceCollector().getResources());
  }
}

<code block>


package com.facebook.buck.event.listener;

import com.facebook.buck.cli.CommandEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ChromeTraceEvent;
import com.facebook.buck.event.CompilerPluginDurationEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEvent;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.io.PathListing;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.java.AnnotationProcessingEvent;
import com.facebook.buck.java.tracing.JavacPhaseEvent;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.ArtifactCacheConnectEvent;
import com.facebook.buck.rules.ArtifactCacheEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.BestCompressionGZIPOutputStream;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Optionals;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.Subscribe;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;


public class ChromeTraceBuildListener implements BuckEventListener {
  private static final Logger LOG = Logger.get(ChromeTraceBuildListener.class);

  private final ProjectFilesystem projectFilesystem;
  private final Clock clock;
  private final int tracesToKeep;
  private final boolean compressTraces;
  private final ObjectMapper mapper;
  private final ThreadLocal<SimpleDateFormat> dateFormat;
  private ConcurrentLinkedQueue<ChromeTraceEvent> eventList =
      new ConcurrentLinkedQueue<ChromeTraceEvent>();

  public ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      int tracesToKeep,
      boolean compressTraces) {
    this(
        projectFilesystem,
        clock,
        objectMapper,
        Locale.US,
        TimeZone.getDefault(),
        tracesToKeep,
        compressTraces);
  }

  @VisibleForTesting
  ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      final Locale locale,
      final TimeZone timeZone,
      int tracesToKeep,
      boolean compressTraces) {
    this.projectFilesystem = projectFilesystem;
    this.clock = clock;
    this.mapper = objectMapper;
    this.dateFormat = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd.HH-mm-ss", locale);
          dateFormat.setTimeZone(timeZone);
          return dateFormat;
      }
    };
    this.tracesToKeep = tracesToKeep;
    this.compressTraces = compressTraces;
    addProcessMetadataEvent();
  }

  private void addProcessMetadataEvent() {
    eventList.add(
        new ChromeTraceEvent(
            "buck",
            "process_name",
            ChromeTraceEvent.Phase.METADATA,
 0,
 0,
 0,
            ImmutableMap.of("name", "buck")));
  }

  @VisibleForTesting
  void deleteOldTraces() {
    if (!projectFilesystem.exists(BuckConstant.BUCK_TRACE_DIR)) {
      return;
    }

    Path traceDirectory = projectFilesystem.getPathForRelativePath(BuckConstant.BUCK_TRACE_DIR);

    try {
      for (Path path : PathListing.listMatchingPathsWithFilters(
               traceDirectory,
               "build.*.trace",
               PathListing.GET_PATH_MODIFIED_TIME,
               PathListing.FilterMode.EXCLUDE,
               Optional.of(tracesToKeep),
               Optional.<Long>absent())) {
        projectFilesystem.deleteFileAtPath(path);
      }
    } catch (IOException e) {
      LOG.error(e, "Couldn't list paths in trace directory %s", traceDirectory);
    }
  }

  @Override
  public void outputTrace(BuildId buildId) {
    try {
      String filenameTime = dateFormat.get().format(new Date(clock.currentTimeMillis()));
      String traceName = String.format("build.%s.%s.trace", filenameTime, buildId);
      if (compressTraces) {
        traceName = traceName + ".gz";
      }
      Path tracePath = BuckConstant.BUCK_TRACE_DIR.resolve(traceName);
      projectFilesystem.createParentDirs(tracePath);
      OutputStream stream = projectFilesystem.newFileOutputStream(tracePath);
      if (compressTraces) {
        stream = new BestCompressionGZIPOutputStream(stream, true);
      }

      LOG.debug("Writing Chrome trace to %s", tracePath);
      mapper.writeValue(stream, eventList);

      String symlinkName = compressTraces ? "build.trace.gz" : "build.trace";
      Path symlinkPath = BuckConstant.BUCK_TRACE_DIR.resolve(symlinkName);
      projectFilesystem.createSymLink(
          projectFilesystem.resolve(symlinkPath),
          projectFilesystem.resolve(tracePath),
          true);

      deleteOldTraces();
    } catch (IOException e) {
      throw new HumanReadableException(e, "Unable to write trace file: " + e);
    }
  }

  @Subscribe
  public void commandStarted(CommandEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCommandName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(started.getArgs())
        ),
        started);
  }

  @Subscribe
  public void commandFinished(CommandEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getCommandName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(finished.getArgs()),
            "daemon", Boolean.toString(finished.isDaemon())),
        finished);
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public synchronized void buildFinished(BuildEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void ruleStarted(BuildRuleEvent.Started started) {
    BuildRule buildRule = started.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", started.getRuleKeySafe()),
        started);
  }

  @Subscribe
  public void ruleFinished(BuildRuleEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getBuildRule().getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "cache_result", finished.getCacheResult().toString().toLowerCase(),
            "success_type",
            finished.getSuccessType().transform(Functions.toStringFunction()).or("failed")
        ),
        finished);
  }

  @Subscribe
  public void ruleResumed(BuildRuleEvent.Resumed resumed) {
    BuildRule buildRule = resumed.getBuildRule();
    writeChromeTraceEvent(
        "buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", resumed.getRuleKeySafe()),
        resumed);
  }

  @Subscribe
  public void ruleSuspended(BuildRuleEvent.Suspended suspended) {
    BuildRule buildRule = suspended.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of("rule_key", suspended.getRuleKeySafe()),
        suspended);
  }

  @Subscribe
  public void stepStarted(StepEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getShortStepName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void stepFinished(StepEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getShortStepName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "description", finished.getDescription(),
            "exit_code", Integer.toString(finished.getExitCode())),
        finished);
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "targets",
            Joiner.on(",").join(finished.getBuildTargets())),
        finished);
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void startActivityStarted(StartActivityEvent.Started started) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void startActivityFinished(StartActivityEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "activity_name", finished.getActivityName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void uninstallStarted(UninstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void uninstallFinished(UninstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "package_name", finished.getPackageName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void artifactFetchStarted(ArtifactCacheEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "rule_key", Joiner.on(", ").join(started.getRuleKeys())),
        started);
  }

  @Subscribe
  public void artifactFetchFinished(ArtifactCacheEvent.Finished finished) {
    ImmutableMap.Builder<String, String> argumentsBuilder = ImmutableMap.<String, String>builder()
        .put("success", Boolean.toString(finished.isSuccess()))
        .put("rule_key", Joiner.on(", ").join(finished.getRuleKeys()));
    Optionals.putIfPresent(finished.getCacheResult().transform(Functions.toStringFunction()),
        "cache_result",
        argumentsBuilder);

    writeChromeTraceEvent("buck",
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        argumentsBuilder.build(),
        finished);
  }

  @Subscribe
  public void artifactConnectStarted(ArtifactCacheConnectEvent.Started started) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void artifactConnectFinished(ArtifactCacheConnectEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void javacPhaseStarted(JavacPhaseEvent.Started started) {
    writeChromeTraceEvent(
        "javac",
        started.getPhase().toString(),
        ChromeTraceEvent.Phase.BEGIN,
        started.getArgs(),
        started);
  }

  @Subscribe
  public void javacPhaseFinished(JavacPhaseEvent.Finished finished) {
    writeChromeTraceEvent(
        "javac",
        finished.getPhase().toString(),
        ChromeTraceEvent.Phase.END,
        finished.getArgs(),
        finished);
  }

  @Subscribe
  public void annotationProcessingStarted(AnnotationProcessingEvent.Started started) {
    writeChromeTraceEvent(
        started.getAnnotationProcessorName(),
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void annotationProcessingFinished(AnnotationProcessingEvent.Finished finished) {
    writeChromeTraceEvent(
        finished.getAnnotationProcessorName(),
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void compilerPluginDurationEventStarted(CompilerPluginDurationEvent.Started started) {
    writeChromeTraceEvent(
        started.getPluginName(),
        started.getDurationName(),
        ChromeTraceEvent.Phase.BEGIN,
        started.getArgs(),
        started);
  }

  @Subscribe
  public void compilerPluginDurationEventFinished(CompilerPluginDurationEvent.Finished finished) {
    writeChromeTraceEvent(
        finished.getPluginName(),
        finished.getDurationName(),
        ChromeTraceEvent.Phase.END,
        finished.getArgs(),
        finished);
  }

  @Subscribe
  public void traceEvent(TraceEvent event) {
    writeChromeTraceEvent("buck",
        event.getEventName(),
        event.getPhase(),
        event.getProperties(),
        event);
  }

  @Subscribe
  public void testStartedEvent(TestSummaryEvent.Started started) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "test_case_name", started.getTestCaseName(),
            "test_name", started.getTestName()),
        started);
  }

  @Subscribe
  public void testFinishedEvent(TestSummaryEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "test_case_name", finished.getTestCaseName(),
            "test_name", finished.getTestName()),
        finished);
  }

  private void writeChromeTraceEvent(String category,
      String name,
      ChromeTraceEvent.Phase phase,
      ImmutableMap<String, String> arguments,
      BuckEvent event) {
    eventList.add(new ChromeTraceEvent(category,
        name,
        phase,
        0,
        event.getThreadId(),
        TimeUnit.NANOSECONDS.toMicros(event.getNanoTime()),
        arguments));
  }
}

<code block>


package com.facebook.buck.parser;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.facebook.buck.event.AbstractBuckEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.graph.AbstractAcyclicDepthFirstPostOrderTraversal;
import com.facebook.buck.graph.MutableDirectedGraph;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.json.DefaultProjectBuildFileParserFactory;
import com.facebook.buck.json.JsonObjectHashing;
import com.facebook.buck.json.ProjectBuildFileParser;
import com.facebook.buck.json.ProjectBuildFileParserFactory;
import com.facebook.buck.json.ProjectBuildFileParserOptions;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuckVersion;
import com.facebook.buck.model.BuildFileTree;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.BuildTargetPattern;
import com.facebook.buck.model.FilesystemBackedBuildFileTree;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.Pair;
import com.facebook.buck.model.UnflavoredBuildTarget;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuckPyFunction;
import com.facebook.buck.rules.BuildRuleFactoryParams;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.ConstructorArgMarshalException;
import com.facebook.buck.rules.ConstructorArgMarshaller;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Repository;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Supplier;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.eventbus.Subscribe;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class Parser {

  private final CachedState state;

  private final ImmutableSet<Pattern> tempFilePatterns;

  private final Repository repository;
  private final String buildFileName;
  private final ProjectBuildFileParserFactory buildFileParserFactory;


  private static final String INCLUDES_META_RULE = "__includes";


  private final ListMultimap<Path, Path> buildFileDependents;

  private final boolean enforceBuckPackageBoundary;



  private Optional<BuckEvent> parseStartEvent = Optional.absent();

  private static final Logger LOG = Logger.get(Parser.class);

  private static final ConstructorArgMarshaller marshaller = new ConstructorArgMarshaller();


  @VisibleForTesting
  static class BuildFileTreeCache implements Supplier<BuildFileTree> {
    private final Supplier<BuildFileTree> supplier;
    @Nullable private BuildFileTree buildFileTree;
    private BuildId currentBuildId = new BuildId();
    private BuildId buildTreeBuildId = new BuildId();


    public BuildFileTreeCache(Supplier<BuildFileTree> buildFileTreeSupplier) {
      this.supplier = buildFileTreeSupplier;
    }


    public synchronized void invalidateIfStale() {
      if (!currentBuildId.equals(buildTreeBuildId)) {
        buildFileTree = null;
      }
    }


    @Override
    public synchronized BuildFileTree get() {
      if (buildFileTree == null) {
        buildTreeBuildId = currentBuildId;
        buildFileTree = supplier.get();
      }
      return buildFileTree;
    }


    public synchronized void onCommandStartedEvent(BuckEvent event) {


      Preconditions.checkArgument(event.getEventName().equals("CommandStarted"),
          "event should be of type CommandEvent.Started, but was: %s.",
          event);
      currentBuildId = event.getBuildId();
    }
  }
  private final BuildFileTreeCache buildFileTreeCache;

  public static Parser createParser(
      final Repository repository,
      String pythonInterpreter,
      boolean allowEmptyGlobs,
      boolean enforceBuckPackageBoundary,
      ImmutableSet<Pattern> tempFilePatterns,
      final String buildFileName,
      Iterable<String> defaultIncludes)
      throws IOException, InterruptedException {
    return new Parser(
        repository,
        enforceBuckPackageBoundary,
        tempFilePatterns,
        buildFileName,


        new Supplier<BuildFileTree>() {
          @Override
          public BuildFileTree get() {
            return new FilesystemBackedBuildFileTree(
                repository.getFilesystem(),
                buildFileName);
          }
        },

        new DefaultProjectBuildFileParserFactory(
            ProjectBuildFileParserOptions.builder()
                .setProjectRoot(repository.getFilesystem().getRootPath())
                .setPythonInterpreter(pythonInterpreter)
                .setAllowEmptyGlobs(allowEmptyGlobs)
                .setBuildFileName(buildFileName)
                .setDefaultIncludes(defaultIncludes)
                .setDescriptions(repository.getAllDescriptions())
                .build()));
  }


  @VisibleForTesting
  Parser(
      Repository repository,
      boolean enforceBuckPackageBoundary,
      ImmutableSet<Pattern> tempFilePatterns,
      String buildFileName,
      Supplier<BuildFileTree> buildFileTreeSupplier,
      ProjectBuildFileParserFactory buildFileParserFactory)
      throws IOException, InterruptedException {
    this.repository = repository;
    this.buildFileName = buildFileName;
    this.buildFileTreeCache = new BuildFileTreeCache(buildFileTreeSupplier);
    this.buildFileParserFactory = buildFileParserFactory;
    this.enforceBuckPackageBoundary = enforceBuckPackageBoundary;
    this.buildFileDependents = ArrayListMultimap.create();
    this.tempFilePatterns = tempFilePatterns;
    this.state = new CachedState(buildFileName);
  }

  public Path getProjectRoot() {
    return repository.getFilesystem().getRootPath();
  }


  private synchronized boolean isCached(
      Path buildFile,
      Iterable<String> includes,
      ImmutableMap<String, String> env) {
    boolean includesChanged = state.invalidateCacheOnIncludeChange(includes);
    boolean environmentChanged = state.invalidateCacheOnEnvironmentChange(env);
    boolean fileParsed = state.isParsed(buildFile);
    return !includesChanged && !environmentChanged && fileParsed;
  }

  private synchronized void invalidateCache() {
    state.invalidateAll();
  }


  public synchronized void cleanCache() {
    state.cleanCache();
  }

  public LoadingCache<BuildTarget, HashCode> getBuildTargetHashCodeCache() {
    return state.getBuildTargetHashCodeCache();
  }


  private ImmutableSet<BuildTarget> resolveTargetSpec(
      TargetNodeSpec spec,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    ImmutableSet.Builder<BuildTarget> targets = ImmutableSet.builder();


    for (Path buildFile : spec.getBuildFileSpec().findBuildFiles(
        repository.getFilesystem(),
        buildFileName)) {


      if (!repository.getFilesystem().isFile(buildFile)) {
        throw new MissingBuildFileException(spec, buildFile);
      }


      List<Map<String, Object>> parsed = parseBuildFile(
          repository.getFilesystem().resolve(buildFile),
          parserConfig,
          buildFileParser,
          environment);
      List<TargetNode<?>> nodes = Lists.newArrayListWithCapacity(parsed.size());
      for (Map<String, Object> map : parsed) {
        BuildTarget target = parseBuildTargetFromRawRule(map);
        TargetNode<?> node = getTargetNode(target);
        nodes.add(node);
      }


      targets.addAll(spec.filter(nodes));
    }

    return targets.build();
  }

  private ImmutableSet<BuildTarget> resolveTargetSpecs(
      Iterable<? extends TargetNodeSpec> specs,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    ImmutableSet.Builder<BuildTarget> targets = ImmutableSet.builder();

    for (TargetNodeSpec spec : specs) {
      targets.addAll(
          resolveTargetSpec(
              spec,
              parserConfig,
              buildFileParser,
              environment));
    }

    return targets.build();
  }


  public synchronized Pair<ImmutableSet<BuildTarget>, TargetGraph>
      buildTargetGraphForTargetNodeSpecs(
          Iterable<? extends TargetNodeSpec> targetNodeSpecs,
          ParserConfig parserConfig,
          BuckEventBus eventBus,
          Console console,
          ImmutableMap<String, String> environment,
          boolean enableProfiling)
          throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    TargetGraph graph = null;


    try (ProjectBuildFileParser buildFileParser = buildFileParserFactory.createParser(
        console,
        environment,
        eventBus)) {
      buildFileParser.setEnableProfiling(enableProfiling);


      ImmutableSet<BuildTarget> buildTargets = resolveTargetSpecs(
          targetNodeSpecs,
          parserConfig,
          buildFileParser,
          environment);

      postParseStartEvent(buildTargets, eventBus);

      try {
        graph = buildTargetGraph(
            buildTargets,
            parserConfig,
            buildFileParser,
            environment);
        return new Pair<>(buildTargets, graph);
      } finally {
        eventBus.post(ParseEvent.finished(buildTargets, Optional.fromNullable(graph)));
      }
    }
  }


  public TargetGraph buildTargetGraphForBuildTargets(
      Iterable<BuildTarget> buildTargets,
      ParserConfig parserConfig,
      BuckEventBus eventBus,
      Console console,
      ImmutableMap<String, String> environment,
      boolean enableProfiling)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
    return buildTargetGraphForTargetNodeSpecs(
        Iterables.transform(
            buildTargets,
            AbstractBuildTargetSpec.TO_BUILD_TARGET_SPEC),
        parserConfig,
        eventBus,
        console,
        environment,
        enableProfiling).getSecond();
  }

  @Nullable
  public synchronized TargetNode<?> getTargetNode(BuildTarget buildTarget)
      throws IOException, InterruptedException {
    return state.get(buildTarget);
  }


  private synchronized TargetGraph buildTargetGraph(
      Iterable<BuildTarget> toExplore,
      final ParserConfig parserConfig,
      final ProjectBuildFileParser buildFileParser,
      final ImmutableMap<String, String> environment) throws IOException, InterruptedException {

    final MutableDirectedGraph<TargetNode<?>> graph = new MutableDirectedGraph<>();

    AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal =
        new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>() {
          @Override
          protected Iterator<BuildTarget> findChildren(BuildTarget buildTarget)
              throws IOException, InterruptedException {
            BuildTargetPatternParser<BuildTargetPattern> buildTargetPatternParser =
                BuildTargetPatternParser.forBaseName(buildTarget.getBaseName());



            TargetNode<?> targetNode = getTargetNode(buildTarget);
            if (targetNode == null) {
              throw new HumanReadableException(
                  NoSuchBuildTargetException.createForMissingBuildRule(
                      buildTarget,
                      buildTargetPatternParser,
                      parserConfig.getBuildFileName()));
            }

            Set<BuildTarget> deps = Sets.newHashSet();
            for (BuildTarget buildTargetForDep : targetNode.getDeps()) {
              try {
                TargetNode<?> depTargetNode = getTargetNode(buildTargetForDep);
                if (depTargetNode == null) {
                  parseBuildFileContainingTarget(
                      buildTargetForDep,
                      parserConfig,
                      buildFileParser,
                      environment);
                  depTargetNode = getTargetNode(buildTargetForDep);
                  if (depTargetNode == null) {
                    throw new HumanReadableException(
                        NoSuchBuildTargetException.createForMissingBuildRule(
                            buildTargetForDep,
                            BuildTargetPatternParser.forBaseName(
                                buildTargetForDep.getBaseName()),
                            parserConfig.getBuildFileName()));
                  }
                }
                depTargetNode.checkVisibility(buildTarget);
                deps.add(buildTargetForDep);
              } catch (HumanReadableException | BuildTargetException | BuildFileParseException e) {
                throw new HumanReadableException(
                    e,
                    "Couldn't get dependency '%s' of target '%s':\n%s",
                    buildTargetForDep,
                    buildTarget,
                    e.getHumanReadableErrorMessage());
              }
            }

            return deps.iterator();
          }

          @Override
          protected void onNodeExplored(BuildTarget buildTarget)
              throws IOException, InterruptedException {
            TargetNode<?> targetNode = getTargetNode(buildTarget);
            Preconditions.checkNotNull(targetNode, "No target node found for %s", buildTarget);
            graph.addNode(targetNode);
            for (BuildTarget target : targetNode.getDeps()) {
              graph.addEdge(targetNode, Preconditions.checkNotNull(getTargetNode(target)));
            }
          }

          @Override
          protected void onTraversalComplete(Iterable<BuildTarget> nodesInExplorationOrder) {
          }
        };

    try {
      traversal.traverse(toExplore);
    } catch (AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
      throw new HumanReadableException(e.getMessage());
    }

    return new TargetGraph(graph);
  }

  private synchronized void parseBuildFileContainingTarget(
      BuildTarget buildTarget,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    if (buildTarget.getRepository().isPresent()) {
      throw new HumanReadableException(
          "Buck does not currently support multiple repositories: %d",
          buildTarget);
    }
    Repository targetRepo = repository;
    Path buildFile = targetRepo.getAbsolutePathToBuildFile(buildTarget);
    if (isCached(buildFile, parserConfig.getDefaultIncludes(), environment)) {
      throw new HumanReadableException(
          "The build file that should contain %s has already been parsed (%s), " +
              "but %s was not found. Please make sure that %s is defined in %s.",
          buildTarget,
          buildFile,
          buildTarget,
          buildTarget,
          buildFile);
    }

    parseBuildFile(buildFile, parserConfig, buildFileParser, environment);
  }

  public synchronized List<Map<String, Object>> parseBuildFile(
      Path buildFile,
      ParserConfig parserConfig,
      ImmutableMap<String, String> environment,
      Console console,
      BuckEventBus buckEventBus)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
    try (ProjectBuildFileParser projectBuildFileParser = buildFileParserFactory.createParser(
        console,
        environment,
        buckEventBus)) {
      return parseBuildFile(buildFile, parserConfig, projectBuildFileParser, environment);
    }
  }


  public synchronized List<Map<String, Object>> parseBuildFile(
      Path buildFile,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    if (!isCached(buildFile, parserConfig.getDefaultIncludes(), environment)) {
      LOG.debug("Parsing %s file: %s", buildFileName, buildFile);
      parseRawRulesInternal(buildFileParser.getAllRulesAndMetaRules(buildFile));
    } else {
      LOG.debug("Not parsing %s file (already in cache)", buildFileName);
    }
    return state.getRawRules(buildFile);
  }


  @VisibleForTesting
  synchronized void parseRawRulesInternal(Iterable<Map<String, Object>> rules)
      throws BuildTargetException, IOException {
    LOG.verbose("Parsing raw rules, state before parse %s", state);
    for (Map<String, Object> map : rules) {

      if (isMetaRule(map)) {
        parseMetaRule(map);
        continue;
      }

      BuildTarget target = parseBuildTargetFromRawRule(map);
      BuildRuleType buildRuleType = parseBuildRuleTypeFromRawRule(map);
      Description<?> description = repository.getDescription(buildRuleType);
      if (description == null) {
        throw new HumanReadableException("Unrecognized rule %s while parsing %s.",
            buildRuleType,
            repository.getAbsolutePathToBuildFile(target));
      }

      state.put(target, map);
    }
    LOG.verbose("Finished parsing raw rules, state after parse %s", state);
  }


  private boolean isMetaRule(Map<String, Object> map) {
    return map.containsKey(INCLUDES_META_RULE);
  }


  @SuppressWarnings("unchecked") 
  private synchronized boolean parseMetaRule(Map<String, Object> map) {
    Preconditions.checkState(isMetaRule(map));



    List<String> fileNames = ((List<String>) map.get(INCLUDES_META_RULE));
    Preconditions.checkNotNull(fileNames);
    Path dependent = normalize(Paths.get(fileNames.get(0)));
    for (String fileName : fileNames) {
      buildFileDependents.put(normalize(Paths.get(fileName)), dependent);
    }
    return true;
  }


  private BuildRuleType parseBuildRuleTypeFromRawRule(Map<String, Object> map) {
    String type = (String) Preconditions.checkNotNull(map.get(BuckPyFunction.TYPE_PROPERTY_NAME));
    return repository.getBuildRuleType(type);
  }


  private BuildTarget parseBuildTargetFromRawRule(Map<String, Object> map) {
    String basePath = (String) Preconditions.checkNotNull(map.get("buck.base_path"));
    String name = (String) Preconditions.checkNotNull(map.get("name"));
    return BuildTarget.builder(UnflavoredBuildTarget.BUILD_TARGET_PREFIX + basePath, name).build();
  }



  @Subscribe
  public synchronized void onCommandStartedEvent(BuckEvent event) {


    Preconditions.checkArgument(
        event.getEventName().equals("CommandStarted"),
        "event should be of type CommandEvent.Started, but was: %s.",
        event);
    buildFileTreeCache.onCommandStartedEvent(event);
  }


  @Subscribe
  public synchronized void onFileSystemChange(WatchEvent<?> event) throws IOException {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(
          "Parser watched event %s %s",
          event.kind(),
          repository.getFilesystem().createContextString(event));
    }

    if (repository.getFilesystem().isPathChangeEvent(event)) {
      Path path = (Path) event.context();

      if (isPathCreateOrDeleteEvent(event)) {

        if (path.endsWith(new ParserConfig(repository.getBuckConfig()).getBuildFileName())) {


          buildFileTreeCache.invalidateIfStale();
        }



        if (!isTempFile(path)) {
          invalidateContainingBuildFile(path);
        }
      }

      LOG.verbose("Invalidating dependents for path %s, cache state %s", path, state);


      state.invalidateDependents(path);

    } else {

      LOG.debug("Parser invalidating entire cache on overflow.");
      buildFileTreeCache.invalidateIfStale();
      invalidateCache();
    }
  }


  private boolean isTempFile(Path path) {
    final String fileName = path.getFileName().toString();
    Predicate<Pattern> patternMatches = new Predicate<Pattern>() {
      @Override
      public boolean apply(Pattern pattern) {
        return pattern.matcher(fileName).matches();
      }
    };
    return Iterators.any(tempFilePatterns.iterator(), patternMatches);
  }


  private synchronized void invalidateContainingBuildFile(Path path) throws IOException {
    List<Path> packageBuildFiles = Lists.newArrayList();



    Optional<Path> packageBuildFile = buildFileTreeCache.get().getBasePathOfAncestorTarget(path);
    packageBuildFiles.addAll(packageBuildFile.asSet());



    if (!enforceBuckPackageBoundary) {
      while (packageBuildFile.isPresent() && packageBuildFile.get().getParent() != null) {
        packageBuildFile =
            buildFileTreeCache.get()
                .getBasePathOfAncestorTarget(packageBuildFile.get().getParent());
        packageBuildFiles.addAll(packageBuildFile.asSet());
      }
    }


    for (Path buildFile : packageBuildFiles) {
      state.invalidateDependents(
          repository.getFilesystem().getPathForRelativePath(
              buildFile.resolve(
                  new ParserConfig(repository.getBuckConfig()).getBuildFileName())));
    }
  }

  private boolean isPathCreateOrDeleteEvent(WatchEvent<?> event) {
    return event.kind() == StandardWatchEventKinds.ENTRY_CREATE ||
        event.kind() == StandardWatchEventKinds.ENTRY_DELETE;
  }


  private Path normalize(Path path) {
    return repository.getFilesystem().resolve(path);
  }


  public void recordParseStartTime(BuckEventBus eventBus) {
    class ParseStartTime extends AbstractBuckEvent {

      @Override
      protected String getValueString() {
        return "Timestamp.";
      }

      @Override
      public String getEventName() {
        return "ParseStartTime";
      }
    }
    parseStartEvent = Optional.<BuckEvent>of(new ParseStartTime());
    eventBus.timestamp(parseStartEvent.get());
  }


  public Optional<BuckEvent> getParseStartTime() {
    return parseStartEvent;
  }


  private void postParseStartEvent(Iterable<BuildTarget> buildTargets, BuckEventBus eventBus) {
    if (parseStartEvent.isPresent()) {
      eventBus.post(ParseEvent.started(buildTargets), parseStartEvent.get());
    } else {
      eventBus.post(ParseEvent.started(buildTargets));
    }
  }

  private class CachedState {


    private final ListMultimap<Path, Map<String, Object>> parsedBuildFiles;


    private final Map<Path, Path> symlinkExistenceCache;


    private final Set<Path> buildInputPathsUnderSymlink;


    private final ListMultimap<Path, BuildTarget> pathsToBuildTargets;


    private final Map<BuildTarget, TargetNode<?>> memoizedTargetNodes;


    @Nullable
    private ImmutableMap<String, String> cacheEnvironment;


    @Nullable
    private List<String> cacheDefaultIncludes;

    private final Map<BuildTarget, Path> targetsToFile;

    private final LoadingCache<BuildTarget, HashCode> buildTargetHashCodeCache;

    private final String buildFile;

    public CachedState(String buildFileName) {
      this.memoizedTargetNodes = Maps.newHashMap();
      this.symlinkExistenceCache = Maps.newHashMap();
      this.buildInputPathsUnderSymlink = Sets.newHashSet();
      this.parsedBuildFiles = ArrayListMultimap.create();
      this.targetsToFile = Maps.newHashMap();
      this.pathsToBuildTargets = ArrayListMultimap.create();
      this.buildTargetHashCodeCache = CacheBuilder.newBuilder().build(
          new CacheLoader<BuildTarget, HashCode>() {
            @Override
            public HashCode load(BuildTarget buildTarget) throws IOException, InterruptedException {
              return loadHashCodeForBuildTarget(buildTarget);
            }
          });
      this.buildFile = buildFileName;
    }

    public void invalidateAll() {
      LOG.debug("Invalidating all cached data.");
      parsedBuildFiles.clear();
      symlinkExistenceCache.clear();
      buildInputPathsUnderSymlink.clear();
      memoizedTargetNodes.clear();
      targetsToFile.clear();
      pathsToBuildTargets.clear();
      buildTargetHashCodeCache.invalidateAll();
    }

    @Override
    public String toString() {
      return String.format(
          "%s memoized=%s symlinks=%s build files under symlink=%s parsed=%s targets-to-files=%s " +
          "paths-to-targets=%s build-target-hash-code-cache=%s",
          super.toString(),
          memoizedTargetNodes,
          symlinkExistenceCache,
          buildInputPathsUnderSymlink,
          parsedBuildFiles,
          targetsToFile,
          pathsToBuildTargets,
          buildTargetHashCodeCache);
    }


    private synchronized boolean invalidateCacheOnEnvironmentChange(
        ImmutableMap<String, String> environment) {
      if (!environment.equals(cacheEnvironment)) {
        if (cacheEnvironment != null) {
          LOG.warn(
              "Environment variables changed (%s). Discarding cache to avoid effects on build. " +
              "This will make builds very slow.",
              Maps.difference(cacheEnvironment, environment));
        }
        invalidateCache();
        this.cacheEnvironment = environment;
        return true;
      }
      return false;
    }


    private synchronized boolean invalidateCacheOnIncludeChange(Iterable<String> includes) {
      List<String> includesList = Lists.newArrayList(includes);
      if (!includesList.equals(this.cacheDefaultIncludes)) {
        LOG.debug("Parser invalidating entire cache on default include change.");
        invalidateCache();
        this.cacheDefaultIncludes = includesList;
        return true;
      }
      return false;
    }


    synchronized void invalidateDependents(Path path) {

      path = normalize(path);


      symlinkExistenceCache.remove(path);

      if (parsedBuildFiles.containsKey(path)) {
        LOG.debug("Parser invalidating %s cache", path);


        List<?> removed = parsedBuildFiles.removeAll(path);
        LOG.verbose("Removed parsed build files %s defined by %s", removed, path);



        buildInputPathsUnderSymlink.remove(path);
      } else {
        LOG.debug("Parsed build files does not contain %s, not invalidating", path);
      }

      List<BuildTarget> targetsToRemove = pathsToBuildTargets.get(path);
      LOG.debug("Removing targets %s for path %s", targetsToRemove, path);
      for (BuildTarget target : targetsToRemove) {
        memoizedTargetNodes.remove(target);
      }
      buildTargetHashCodeCache.invalidateAll(targetsToRemove);
      pathsToBuildTargets.removeAll(path);

      List<Path> dependents = buildFileDependents.get(path);
      LOG.verbose("Invalidating dependents %s of path %s", dependents, path);

      for (Path dependent : dependents) {

        if (!dependent.equals(path)) {
          invalidateDependents(dependent);
        }
      }


      List<?> removedDependents = buildFileDependents.removeAll(path);
      LOG.verbose("Removed build file dependents %s defined by %s", removedDependents, path);
    }

    public boolean isParsed(Path buildFile) {
      return parsedBuildFiles.containsKey(normalize(buildFile));
    }

    public List<Map<String, Object>> getRawRules(Path buildFile) {
      return Preconditions.checkNotNull(parsedBuildFiles.get(normalize(buildFile)));
    }

    public void put(BuildTarget target, Map<String, Object> rawRules) {
      Path normalized = normalize(target.getBasePath().resolve(buildFile));
      LOG.verbose("Adding rules for parsed build file %s", normalized);
      parsedBuildFiles.put(normalized, rawRules);

      targetsToFile.put(
          target,
          normalize(Paths.get((String) rawRules.get("buck.base_path")))
              .resolve(buildFile).toAbsolutePath());
    }

    @Nullable
    @SuppressWarnings({"rawtypes", "unchecked"})
    public TargetNode<?> get(BuildTarget buildTarget) throws IOException, InterruptedException {

      TargetNode<?> toReturn = memoizedTargetNodes.get(buildTarget);
      if (toReturn != null) {
        return toReturn;
      }

      if (buildTarget.getRepository().isPresent()) {
        throw new HumanReadableException(
            "Buck does not currently support multiple repos: %d",
            buildTarget);
      }
      Repository targetRepo = repository;
      Path buildFilePath;
      try {
        buildFilePath = targetRepo.getAbsolutePathToBuildFile(buildTarget);
      } catch (Repository.MissingBuildFileException e) {
        throw new HumanReadableException(e);
      }
      UnflavoredBuildTarget unflavored = buildTarget.getUnflavoredBuildTarget();
      List<Map<String, Object>> rules = state.getRawRules(buildFilePath);
      for (Map<String, Object> map : rules) {

        if (!buildTarget.getShortName().equals(map.get("name"))) {
          continue;
        }

        BuildRuleType buildRuleType = parseBuildRuleTypeFromRawRule(map);
        targetsToFile.put(
            BuildTarget.of(unflavored),
            normalize(Paths.get((String) map.get("buck.base_path")))
                .resolve(buildFile).toAbsolutePath());

        Description<?> description = repository.getDescription(buildRuleType);
        if (description == null) {
          throw new HumanReadableException("Unrecognized rule %s while parsing %s%s.",
              buildRuleType,
              UnflavoredBuildTarget.BUILD_TARGET_PREFIX,
              MorePaths.pathWithUnixSeparators(unflavored.getBasePath().resolve(buildFile)));
        }

        if (buildTarget.isFlavored()) {
          if (description instanceof Flavored) {
            if (!((Flavored) description).hasFlavors(
                    ImmutableSet.copyOf(buildTarget.getFlavors()))) {
              throw new HumanReadableException(
                  "Unrecognized flavor in target %s while parsing %s%s.",
                  buildTarget,
                  UnflavoredBuildTarget.BUILD_TARGET_PREFIX,
                  MorePaths.pathWithUnixSeparators(
                      buildTarget.getBasePath().resolve(buildFile)));
            }
          } else {
            LOG.warn(
                "Target %s (type %s) must implement the Flavored interface " +
                "before we can check if it supports flavors: %s",
                buildTarget.getUnflavoredBuildTarget(),
                buildRuleType,
                buildTarget.getFlavors());
            throw new HumanReadableException(
                "Target %s (type %s) does not currently support flavors (tried %s)",
                buildTarget.getUnflavoredBuildTarget(),
                buildRuleType,
                buildTarget.getFlavors());
          }
        }

        this.pathsToBuildTargets.put(buildFilePath, buildTarget);

        BuildRuleFactoryParams factoryParams = new BuildRuleFactoryParams(
            targetRepo.getFilesystem(),


            buildTarget,
            buildFileTreeCache.get(),
            enforceBuckPackageBoundary);
        Object constructorArg = description.createUnpopulatedConstructorArg();
        TargetNode<?> targetNode;
        try {
          ImmutableSet.Builder<BuildTarget> declaredDeps = ImmutableSet.builder();
          ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns = ImmutableSet.builder();
          marshaller.populate(
              targetRepo.getFilesystem(),
              factoryParams,
              constructorArg,
              declaredDeps,
              visibilityPatterns,
              map);
          targetNode = new TargetNode(
              description,
              constructorArg,
              factoryParams,
              declaredDeps.build(),
              visibilityPatterns.build());
        } catch (NoSuchBuildTargetException | TargetNode.InvalidSourcePathInputException e) {
          throw new HumanReadableException(e);
        } catch (ConstructorArgMarshalException e) {
          throw new HumanReadableException("%s: %s", buildTarget, e.getMessage());
        }

        Map<Path, Path> newSymlinksEncountered = Maps.newHashMap();
        if (inputFilesUnderSymlink(
                targetNode.getInputs(),
                targetRepo.getFilesystem(),
                symlinkExistenceCache,
                newSymlinksEncountered)) {
          LOG.warn(
              "Disabling caching for target %s, because one or more input files are under a " +
              "symbolic link (%s). This will severely impact performance! To resolve this, use " +
              "separate rules and declare dependencies instead of using symbolic links.",
              targetNode.getBuildTarget(),
              newSymlinksEncountered);
          buildInputPathsUnderSymlink.add(buildFilePath);
        }
        TargetNode<?> existingTargetNode = memoizedTargetNodes.put(buildTarget, targetNode);
        if (existingTargetNode != null) {
          throw new HumanReadableException("Duplicate definition for " + unflavored);
        }


      }

      return memoizedTargetNodes.get(buildTarget);
    }

    public synchronized void cleanCache() {
      LOG.debug(
          "Cleaning cache of build files with inputs under symlink %s",
          buildInputPathsUnderSymlink);
      Set<Path> buildInputPathsUnderSymlinkCopy = new HashSet<>(buildInputPathsUnderSymlink);
      buildInputPathsUnderSymlink.clear();
      for (Path buildFilePath : buildInputPathsUnderSymlinkCopy) {
        invalidateDependents(buildFilePath);
      }
    }

    private synchronized HashCode loadHashCodeForBuildTarget(BuildTarget buildTarget)
        throws IOException, InterruptedException{

      get(buildTarget);

      Path buildTargetPath = targetsToFile.get(
          BuildTarget.of(buildTarget.getUnflavoredBuildTarget()));
      if (buildTargetPath == null) {
        throw new HumanReadableException("Couldn't find build target %s", buildTarget);
      }
      List<Map<String, Object>> rules = getRawRules(buildTargetPath);
      Hasher hasher = Hashing.sha1().newHasher();
      hasher.putString(BuckVersion.getVersion(), UTF_8);
      for (Map<String, Object> map : rules) {
        if (!buildTarget.getShortName().equals(map.get("name"))) {
          continue;
        }

        JsonObjectHashing.hashJsonObject(hasher, map);
      }
      return hasher.hash();
    }

    public LoadingCache<BuildTarget, HashCode> getBuildTargetHashCodeCache() {
      return buildTargetHashCodeCache;
    }
  }

  private static boolean inputFilesUnderSymlink(


      Collection<Path> inputs,
      ProjectFilesystem projectFilesystem,
      Map<Path, Path> symlinkExistenceCache,
      Map<Path, Path> newSymlinksEncountered) throws IOException {
    boolean result = false;
    for (Path input : inputs) {
      for (int i = 1; i < input.getNameCount(); i++) {
        Path subpath = input.subpath(0, i);
        Path resolvedSymlink = symlinkExistenceCache.get(subpath);
        if (resolvedSymlink != null) {
          newSymlinksEncountered.put(subpath, resolvedSymlink);
          result = true;
        } else if (projectFilesystem.isSymLink(subpath)) {
          try {
            resolvedSymlink = projectFilesystem.getRootPath().relativize(subpath.toRealPath());
            LOG.debug("Detected symbolic link %s -> %s", subpath, resolvedSymlink);
            newSymlinksEncountered.put(subpath, resolvedSymlink);
            symlinkExistenceCache.put(subpath, resolvedSymlink);
          } catch (NoSuchFileException e) {
            LOG.verbose(e, "No such file detecting symlink at %s", subpath);
          } catch (IOException e) {
            LOG.error(e, "Couldn't detect symbolic link at %s", subpath);
          }
          result = true;
        }
      }
    }
    return result;
  }

}

<code block>


package com.facebook.buck.json;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.BuckPyFunction;
import com.facebook.buck.rules.ConstructorArgMarshaller;
import com.facebook.buck.rules.Description;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.InputStreamConsumer;
import com.facebook.buck.util.MoreThrowables;
import com.facebook.buck.util.NamedTemporaryFile;
import com.facebook.buck.util.Threads;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Resources;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;


public class ProjectBuildFileParser implements AutoCloseable {


  private static final String BUCK_PY_RESOURCE = "com/facebook/buck/json/buck.py";

  private static final Path PATH_TO_PATHLIB_PY = Paths.get(
      System.getProperty(
          "buck.path_to_pathlib_py",
          "third-party/py/pathlib/pathlib.py"));

  private static final Logger LOG = Logger.get(ProjectBuildFileParser.class);

  private final ImmutableMap<String, String> environment;

  private Optional<Path> pathToBuckPy;

  @Nullable private Process buckPyProcess;
  @Nullable BuildFileToJsonParser buckPyStdoutParser;
  @Nullable private BufferedWriter buckPyStdinWriter;

  private final ProjectBuildFileParserOptions options;
  private final Console console;
  private final BuckEventBus buckEventBus;

  private boolean isInitialized;
  private boolean isClosed;

  private boolean enableProfiling;
  @Nullable private NamedTemporaryFile profileOutputFile;
  @Nullable private Thread stderrConsumer;
  @Nullable private ProjectBuildFileParseEvents.Started projectBuildFileParseEventStarted;

  protected ProjectBuildFileParser(
      ProjectBuildFileParserOptions options,
      Console console,
      ImmutableMap<String, String> environment,
      BuckEventBus buckEventBus) {
    this.pathToBuckPy = Optional.absent();
    this.options = options;
    this.console = console;
    this.environment = environment;
    this.buckEventBus = buckEventBus;
  }

  public void setEnableProfiling(boolean enableProfiling) {
    ensureNotClosed();
    ensureNotInitialized();
    this.enableProfiling = enableProfiling;
  }

  private void ensureNotClosed() {
    Preconditions.checkState(!isClosed);
  }

  private void ensureNotInitialized() {
    Preconditions.checkState(!isInitialized);
  }


  @VisibleForTesting
  public void initIfNeeded() throws IOException {
    ensureNotClosed();
    if (!isInitialized) {
      init();
      isInitialized = true;
    }
  }


  private void init() throws IOException {
    projectBuildFileParseEventStarted = new ProjectBuildFileParseEvents.Started();
    buckEventBus.post(projectBuildFileParseEventStarted);

    ProcessBuilder processBuilder = new ProcessBuilder(buildArgs());
    processBuilder.environment().clear();
    processBuilder.environment().putAll(environment);

    LOG.debug(
        "Starting buck.py command: %s environment: %s",
        processBuilder.command(),
        processBuilder.environment());
    buckPyProcess = processBuilder.start();
    LOG.debug("Started process %s successfully", buckPyProcess);

    OutputStream stdin = buckPyProcess.getOutputStream();
    InputStream stderr = buckPyProcess.getErrorStream();

    stderrConsumer = Threads.namedThread(
        ProjectBuildFileParser.class.getSimpleName(),
        new InputStreamConsumer(stderr,
            console.getStdErr(),
            console.getAnsi(),
 true,
            Optional.<InputStreamConsumer.Handler>of(new InputStreamConsumer.Handler() {
              @Override
              public void handleLine(String line) {
                LOG.warn("buck.py warning: %s", line);
              }
            })));
    stderrConsumer.start();

    buckPyStdinWriter = new BufferedWriter(new OutputStreamWriter(stdin));

    Reader reader = new InputStreamReader(buckPyProcess.getInputStream(), Charsets.UTF_8);
    buckPyStdoutParser = new BuildFileToJsonParser(reader);
  }

  private ImmutableList<String> buildArgs() throws IOException {

    ImmutableList.Builder<String> argBuilder = ImmutableList.builder();

    argBuilder.add(options.getPythonInterpreter());



    argBuilder.add("-u");

    if (enableProfiling) {
      profileOutputFile = new NamedTemporaryFile("buck-py-profile", ".pstats");
      argBuilder.add("-m");
      argBuilder.add("cProfile");
      argBuilder.add("-o");
      argBuilder.add(profileOutputFile.get().toString());
    }

    argBuilder.add(getPathToBuckPy(options.getDescriptions()).toString());

    if (options.getAllowEmptyGlobs()) {
      argBuilder.add("--allow_empty_globs");
    }

    argBuilder.add("--project_root", options.getProjectRoot().toAbsolutePath().toString());
    argBuilder.add("--build_file_name", options.getBuildFileName());


    for (String include : options.getDefaultIncludes()) {
      argBuilder.add("--include");
      argBuilder.add(include);
    }

    return argBuilder.build();
  }


  public List<Map<String, Object>> getAll(Path buildFile)
      throws BuildFileParseException, InterruptedException {
    List<Map<String, Object>> result = getAllRulesAndMetaRules(buildFile);


    return Collections.unmodifiableList(result.subList(0, result.size() - 1));
  }


  public List<Map<String, Object>> getAllRulesAndMetaRules(Path buildFile)
      throws BuildFileParseException, InterruptedException {
    try {
      return getAllRulesInternal(buildFile);
    } catch (IOException e) {
      MoreThrowables.propagateIfInterrupt(e);
      throw BuildFileParseException.createForBuildFileParseError(buildFile, e);
    }
  }

  @VisibleForTesting
  protected List<Map<String, Object>> getAllRulesInternal(Path buildFile)
      throws IOException {
    ensureNotClosed();
    initIfNeeded();


    Preconditions.checkNotNull(buckPyStdoutParser);
    Preconditions.checkNotNull(buckPyStdinWriter);
    Preconditions.checkNotNull(buckPyProcess);

    String buildFileString = buildFile.toString();
    LOG.verbose("Writing to buck.py stdin: %s", buildFileString);
    buckPyStdinWriter.write(buildFileString);
    buckPyStdinWriter.newLine();
    buckPyStdinWriter.flush();

    LOG.debug("Parsing output of process %s...", buckPyProcess);
    List<Map<String, Object>> result = buckPyStdoutParser.nextRules();
    LOG.verbose("Got rules: %s", result);
    LOG.debug("Parsed %d rules from process", result.size());
    return result;
  }

  @Override
  @SuppressWarnings("PMD.EmptyCatchBlock")
  public void close() throws BuildFileParseException, InterruptedException {
    if (isClosed) {
      return;
    }

    try {
      if (isInitialized) {


        Preconditions.checkNotNull(buckPyStdoutParser);
        Preconditions.checkNotNull(buckPyStdinWriter);
        Preconditions.checkNotNull(buckPyProcess);

        try {
          buckPyStdoutParser.close();
        } catch (IOException e) {

        }


        try {
          buckPyStdinWriter.close();
        } catch (IOException e) {


        }

        if (stderrConsumer != null) {
          stderrConsumer.join();
          stderrConsumer = null;
        }

        if (enableProfiling && profileOutputFile != null) {
          parseProfileOutput(profileOutputFile.get());
        }

        LOG.debug("Waiting for process %s to exit...", buckPyProcess);
        int exitCode = buckPyProcess.waitFor();
        if (exitCode != 0) {
          LOG.error("Process %s exited with error code %d", buckPyProcess, exitCode);
          throw BuildFileParseException.createForUnknownParseError(
              String.format("Parser did not exit cleanly (exit code: %d)", exitCode));
        }
        LOG.debug("Process %s exited cleanly.", buckPyProcess);

        try {
          synchronized (this) {
            if (pathToBuckPy.isPresent()) {
              Files.delete(pathToBuckPy.get());
            }
          }
        } catch (IOException e) {

        }

      }
    } finally {
      if (isInitialized) {
        buckEventBus.post(
            new ProjectBuildFileParseEvents.Finished(
                Preconditions.checkNotNull(projectBuildFileParseEventStarted)));
      }
      isClosed = true;
    }
  }

  private static void parseProfileOutput(Path profileOutput) throws InterruptedException {
    try {
      LOG.debug("Parsing output of profiler: %s", profileOutput);
      ProcessBuilder processBuilder = new ProcessBuilder(
          "python", "-m", "pstats", profileOutput.toString());
      Process process = processBuilder.start();
      LOG.debug("Started process: %s", processBuilder.command());
      try (OutputStreamWriter stdin =
               new OutputStreamWriter(process.getOutputStream(), Charsets.UTF_8);
           BufferedWriter stdinWriter = new BufferedWriter(stdin);
           InputStreamReader stdout =
               new InputStreamReader(process.getInputStream(), Charsets.UTF_8);
           BufferedReader stdoutReader = new BufferedReader(stdout)) {
        stdinWriter.write("sort cumulative\nstats 25\n");
        stdinWriter.flush();
        stdinWriter.close();
        LOG.debug("Reading process output...");
        String line;
        while ((line = stdoutReader.readLine()) != null) {
          LOG.debug("buck.py profile: %s", line);
        }
        LOG.debug("Done reading process output.");
      }
      process.waitFor();
    } catch (IOException e) {
      LOG.error(e, "Couldn't read profile output file %s", profileOutput);
    }
  }

  private Path getPathToBuckPy(ImmutableSet<Description<?>> descriptions) throws IOException {
    generatePathToBuckPy(descriptions);
    return pathToBuckPy.get();
  }

  private synchronized void generatePathToBuckPy(ImmutableSet<Description<?>> descriptions)
      throws IOException {
    if (pathToBuckPy.isPresent()) {
      return;
    }

    LOG.debug("Creating temporary buck.py instance...");






    Path buckDotPy = Files.createTempFile("buck", ".py");
    Files.createDirectories(buckDotPy.getParent());

    try (Writer out = Files.newBufferedWriter(buckDotPy, UTF_8)) {
      URL resource = Resources.getResource(BUCK_PY_RESOURCE);
      String pathlibDir = PATH_TO_PATHLIB_PY.getParent().toString();
      out.write(
          "from __future__ import with_statement\n" +
          "import sys\n" +
          "sys.path.insert(0, \"" +
              Escaper.escapeAsBashString(MorePaths.pathWithUnixSeparators(pathlibDir)) + "\")\n");
      Resources.asCharSource(resource, UTF_8).copyTo(out);
      out.write("\n\n");

      ConstructorArgMarshaller inspector = new ConstructorArgMarshaller();
      BuckPyFunction function = new BuckPyFunction(inspector);
      for (Description<?> description : descriptions) {
        out.write(function.toPythonFunction(
            description.getBuildRuleType(),
            description.createUnpopulatedConstructorArg()));
        out.write('\n');
      }

      out.write(Joiner.on("\n").join(
          "if __name__ == '__main__':",
          "  try:",
          "    main()",
          "  except KeyboardInterrupt:",
          "    print >> sys.stderr, 'Killed by User'",
          ""));
    }
    Path normalizedBuckDotPyPath = buckDotPy.normalize();
    pathToBuckPy = Optional.of(normalizedBuckDotPyPath);
    LOG.debug("Created temporary buck.py instance at %s.", normalizedBuckDotPyPath);
  }
}

<code block>


package com.facebook.buck.event.listener;

import com.facebook.buck.cli.CommandEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ChromeTraceEvent;
import com.facebook.buck.event.CompilerPluginDurationEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEvent;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.io.PathListing;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.json.ParseBuckFileEvent;
import com.facebook.buck.java.AnnotationProcessingEvent;
import com.facebook.buck.java.tracing.JavacPhaseEvent;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.CreateTargetNodeEvent;
import com.facebook.buck.parser.MarshalConstructorArgsEvent;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.parser.GetTargetDependenciesEvent;
import com.facebook.buck.parser.GetTargetNodeEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.ArtifactCacheConnectEvent;
import com.facebook.buck.rules.ArtifactCacheEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.BestCompressionGZIPOutputStream;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Optionals;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.Subscribe;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;


public class ChromeTraceBuildListener implements BuckEventListener {
  private static final Logger LOG = Logger.get(ChromeTraceBuildListener.class);

  private final ProjectFilesystem projectFilesystem;
  private final Clock clock;
  private final int tracesToKeep;
  private final boolean compressTraces;
  private final ObjectMapper mapper;
  private final ThreadLocal<SimpleDateFormat> dateFormat;
  private ConcurrentLinkedQueue<ChromeTraceEvent> eventList =
      new ConcurrentLinkedQueue<ChromeTraceEvent>();

  public ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      int tracesToKeep,
      boolean compressTraces) {
    this(
        projectFilesystem,
        clock,
        objectMapper,
        Locale.US,
        TimeZone.getDefault(),
        tracesToKeep,
        compressTraces);
  }

  @VisibleForTesting
  ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      final Locale locale,
      final TimeZone timeZone,
      int tracesToKeep,
      boolean compressTraces) {
    this.projectFilesystem = projectFilesystem;
    this.clock = clock;
    this.mapper = objectMapper;
    this.dateFormat = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd.HH-mm-ss", locale);
          dateFormat.setTimeZone(timeZone);
          return dateFormat;
      }
    };
    this.tracesToKeep = tracesToKeep;
    this.compressTraces = compressTraces;
    addProcessMetadataEvent();
  }

  private void addProcessMetadataEvent() {
    eventList.add(
        new ChromeTraceEvent(
            "buck",
            "process_name",
            ChromeTraceEvent.Phase.METADATA,
 0,
 0,
 0,
            ImmutableMap.of("name", "buck")));
  }

  @VisibleForTesting
  void deleteOldTraces() {
    if (!projectFilesystem.exists(BuckConstant.BUCK_TRACE_DIR)) {
      return;
    }

    Path traceDirectory = projectFilesystem.getPathForRelativePath(BuckConstant.BUCK_TRACE_DIR);

    try {
      for (Path path : PathListing.listMatchingPathsWithFilters(
               traceDirectory,
               "build.*.trace",
               PathListing.GET_PATH_MODIFIED_TIME,
               PathListing.FilterMode.EXCLUDE,
               Optional.of(tracesToKeep),
               Optional.<Long>absent())) {
        projectFilesystem.deleteFileAtPath(path);
      }
    } catch (IOException e) {
      LOG.error(e, "Couldn't list paths in trace directory %s", traceDirectory);
    }
  }

  @Override
  public void outputTrace(BuildId buildId) {
    try {
      String filenameTime = dateFormat.get().format(new Date(clock.currentTimeMillis()));
      String traceName = String.format("build.%s.%s.trace", filenameTime, buildId);
      if (compressTraces) {
        traceName = traceName + ".gz";
      }
      Path tracePath = BuckConstant.BUCK_TRACE_DIR.resolve(traceName);
      projectFilesystem.createParentDirs(tracePath);
      OutputStream stream = projectFilesystem.newFileOutputStream(tracePath);
      if (compressTraces) {
        stream = new BestCompressionGZIPOutputStream(stream, true);
      }

      LOG.debug("Writing Chrome trace to %s", tracePath);
      mapper.writeValue(stream, eventList);

      String symlinkName = compressTraces ? "build.trace.gz" : "build.trace";
      Path symlinkPath = BuckConstant.BUCK_TRACE_DIR.resolve(symlinkName);
      projectFilesystem.createSymLink(
          projectFilesystem.resolve(symlinkPath),
          projectFilesystem.resolve(tracePath),
          true);

      deleteOldTraces();
    } catch (IOException e) {
      throw new HumanReadableException(e, "Unable to write trace file: " + e);
    }
  }

  @Subscribe
  public void commandStarted(CommandEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCommandName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(started.getArgs())
        ),
        started);
  }

  @Subscribe
  public void commandFinished(CommandEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getCommandName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(finished.getArgs()),
            "daemon", Boolean.toString(finished.isDaemon())),
        finished);
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public synchronized void buildFinished(BuildEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void ruleStarted(BuildRuleEvent.Started started) {
    BuildRule buildRule = started.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", started.getRuleKeySafe()),
        started);
  }

  @Subscribe
  public void ruleFinished(BuildRuleEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getBuildRule().getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "cache_result", finished.getCacheResult().toString().toLowerCase(),
            "success_type",
            finished.getSuccessType().transform(Functions.toStringFunction()).or("failed")
        ),
        finished);
  }

  @Subscribe
  public void ruleResumed(BuildRuleEvent.Resumed resumed) {
    BuildRule buildRule = resumed.getBuildRule();
    writeChromeTraceEvent(
        "buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", resumed.getRuleKeySafe()),
        resumed);
  }

  @Subscribe
  public void ruleSuspended(BuildRuleEvent.Suspended suspended) {
    BuildRule buildRule = suspended.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of("rule_key", suspended.getRuleKeySafe()),
        suspended);
  }

  @Subscribe
  public void stepStarted(StepEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getShortStepName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void stepFinished(StepEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getShortStepName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "description", finished.getDescription(),
            "exit_code", Integer.toString(finished.getExitCode())),
        finished);
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "targets",
            Joiner.on(",").join(finished.getBuildTargets())),
        finished);
  }

  @Subscribe
  public void getTargetDependenciesStarted(GetTargetDependenciesEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "get_target_deps",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "target",
            started.getBuildTarget().toString()),
        started);
  }

  @Subscribe
  public void getTargetDependenciesFinished(GetTargetDependenciesEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "get_target_deps",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target",
            finished.getBuildTarget().toString()),
        finished);
  }

  @Subscribe
  public void getTargetNodeStarted(GetTargetNodeEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "get_target_node",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "target",
            started.getBuildTarget().toString()),
        started);
  }

  @Subscribe
  public void getTargetNodeFinished(GetTargetNodeEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "get_target_node",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target",
            finished.getBuildTarget().toString()),
        finished);
  }

  @Subscribe
  public void marshalConstructorArgsStarted(MarshalConstructorArgsEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "marshal_constructor_args",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "target",
            started.getBuildTarget().toString()),
        started);
  }

  @Subscribe
  public void marshalConstructorArgsFinished(MarshalConstructorArgsEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "marshal_constructor_args",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target",
            finished.getBuildTarget().toString()),
        finished);
  }

  @Subscribe
  public void createTargetNodeStarted(CreateTargetNodeEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "create_target_node",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "target",
            started.getBuildTarget().toString()),
        started);
  }

  @Subscribe
  public void createTargetNodeFinished(CreateTargetNodeEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "create_target_node",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target",
            finished.getBuildTarget().toString()),
        finished);
  }

  @Subscribe
  public void parseBuckFileStarted(ParseBuckFileEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "parse_file",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "path",
            started.getBuckFilePath().toString()),
        started);
  }

  @Subscribe
  public void parseBuckFileFinished(ParseBuckFileEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "parse_file",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "path",
            finished.getBuckFilePath().toString(),
            "num_rules",
            Integer.toString(finished.getNumRules())),
        finished);
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void startActivityStarted(StartActivityEvent.Started started) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void startActivityFinished(StartActivityEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "activity_name", finished.getActivityName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void uninstallStarted(UninstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void uninstallFinished(UninstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "package_name", finished.getPackageName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void artifactFetchStarted(ArtifactCacheEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "rule_key", Joiner.on(", ").join(started.getRuleKeys())),
        started);
  }

  @Subscribe
  public void artifactFetchFinished(ArtifactCacheEvent.Finished finished) {
    ImmutableMap.Builder<String, String> argumentsBuilder = ImmutableMap.<String, String>builder()
        .put("success", Boolean.toString(finished.isSuccess()))
        .put("rule_key", Joiner.on(", ").join(finished.getRuleKeys()));
    Optionals.putIfPresent(finished.getCacheResult().transform(Functions.toStringFunction()),
        "cache_result",
        argumentsBuilder);

    writeChromeTraceEvent("buck",
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        argumentsBuilder.build(),
        finished);
  }

  @Subscribe
  public void artifactConnectStarted(ArtifactCacheConnectEvent.Started started) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void artifactConnectFinished(ArtifactCacheConnectEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void javacPhaseStarted(JavacPhaseEvent.Started started) {
    writeChromeTraceEvent(
        "javac",
        started.getPhase().toString(),
        ChromeTraceEvent.Phase.BEGIN,
        started.getArgs(),
        started);
  }

  @Subscribe
  public void javacPhaseFinished(JavacPhaseEvent.Finished finished) {
    writeChromeTraceEvent(
        "javac",
        finished.getPhase().toString(),
        ChromeTraceEvent.Phase.END,
        finished.getArgs(),
        finished);
  }

  @Subscribe
  public void annotationProcessingStarted(AnnotationProcessingEvent.Started started) {
    writeChromeTraceEvent(
        started.getAnnotationProcessorName(),
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void annotationProcessingFinished(AnnotationProcessingEvent.Finished finished) {
    writeChromeTraceEvent(
        finished.getAnnotationProcessorName(),
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void compilerPluginDurationEventStarted(CompilerPluginDurationEvent.Started started) {
    writeChromeTraceEvent(
        started.getPluginName(),
        started.getDurationName(),
        ChromeTraceEvent.Phase.BEGIN,
        started.getArgs(),
        started);
  }

  @Subscribe
  public void compilerPluginDurationEventFinished(CompilerPluginDurationEvent.Finished finished) {
    writeChromeTraceEvent(
        finished.getPluginName(),
        finished.getDurationName(),
        ChromeTraceEvent.Phase.END,
        finished.getArgs(),
        finished);
  }

  @Subscribe
  public void traceEvent(TraceEvent event) {
    writeChromeTraceEvent("buck",
        event.getEventName(),
        event.getPhase(),
        event.getProperties(),
        event);
  }

  @Subscribe
  public void testStartedEvent(TestSummaryEvent.Started started) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "test_case_name", started.getTestCaseName(),
            "test_name", started.getTestName()),
        started);
  }

  @Subscribe
  public void testFinishedEvent(TestSummaryEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "test_case_name", finished.getTestCaseName(),
            "test_name", finished.getTestName()),
        finished);
  }

  private void writeChromeTraceEvent(String category,
      String name,
      ChromeTraceEvent.Phase phase,
      ImmutableMap<String, String> arguments,
      BuckEvent event) {
    eventList.add(new ChromeTraceEvent(category,
        name,
        phase,
        0,
        event.getThreadId(),
        TimeUnit.NANOSECONDS.toMicros(event.getNanoTime()),
        arguments));
  }
}

<code block>


package com.facebook.buck.parser;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.facebook.buck.event.AbstractBuckEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.graph.AbstractAcyclicDepthFirstPostOrderTraversal;
import com.facebook.buck.graph.MutableDirectedGraph;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.json.DefaultProjectBuildFileParserFactory;
import com.facebook.buck.json.JsonObjectHashing;
import com.facebook.buck.json.ProjectBuildFileParser;
import com.facebook.buck.json.ProjectBuildFileParserFactory;
import com.facebook.buck.json.ProjectBuildFileParserOptions;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuckVersion;
import com.facebook.buck.model.BuildFileTree;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.BuildTargetPattern;
import com.facebook.buck.model.FilesystemBackedBuildFileTree;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.Pair;
import com.facebook.buck.model.UnflavoredBuildTarget;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuckPyFunction;
import com.facebook.buck.rules.BuildRuleFactoryParams;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.ConstructorArgMarshalException;
import com.facebook.buck.rules.ConstructorArgMarshaller;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Repository;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Supplier;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.eventbus.Subscribe;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class Parser {

  private final CachedState state;

  private final ImmutableSet<Pattern> tempFilePatterns;

  private final Repository repository;
  private final String buildFileName;
  private final ProjectBuildFileParserFactory buildFileParserFactory;


  private static final String INCLUDES_META_RULE = "__includes";


  private final ListMultimap<Path, Path> buildFileDependents;

  private final boolean enforceBuckPackageBoundary;



  private Optional<BuckEvent> parseStartEvent = Optional.absent();

  private static final Logger LOG = Logger.get(Parser.class);

  private static final ConstructorArgMarshaller marshaller = new ConstructorArgMarshaller();


  @VisibleForTesting
  static class BuildFileTreeCache implements Supplier<BuildFileTree> {
    private final Supplier<BuildFileTree> supplier;
    @Nullable private BuildFileTree buildFileTree;
    private BuildId currentBuildId = new BuildId();
    private BuildId buildTreeBuildId = new BuildId();


    public BuildFileTreeCache(Supplier<BuildFileTree> buildFileTreeSupplier) {
      this.supplier = buildFileTreeSupplier;
    }


    public synchronized void invalidateIfStale() {
      if (!currentBuildId.equals(buildTreeBuildId)) {
        buildFileTree = null;
      }
    }


    @Override
    public synchronized BuildFileTree get() {
      if (buildFileTree == null) {
        buildTreeBuildId = currentBuildId;
        buildFileTree = supplier.get();
      }
      return buildFileTree;
    }


    public synchronized void onCommandStartedEvent(BuckEvent event) {


      Preconditions.checkArgument(event.getEventName().equals("CommandStarted"),
          "event should be of type CommandEvent.Started, but was: %s.",
          event);
      currentBuildId = event.getBuildId();
    }
  }
  private final BuildFileTreeCache buildFileTreeCache;

  public static Parser createParser(
      final Repository repository,
      String pythonInterpreter,
      boolean allowEmptyGlobs,
      boolean enforceBuckPackageBoundary,
      ImmutableSet<Pattern> tempFilePatterns,
      final String buildFileName,
      Iterable<String> defaultIncludes)
      throws IOException, InterruptedException {
    return new Parser(
        repository,
        enforceBuckPackageBoundary,
        tempFilePatterns,
        buildFileName,


        new Supplier<BuildFileTree>() {
          @Override
          public BuildFileTree get() {
            return new FilesystemBackedBuildFileTree(
                repository.getFilesystem(),
                buildFileName);
          }
        },

        new DefaultProjectBuildFileParserFactory(
            ProjectBuildFileParserOptions.builder()
                .setProjectRoot(repository.getFilesystem().getRootPath())
                .setPythonInterpreter(pythonInterpreter)
                .setAllowEmptyGlobs(allowEmptyGlobs)
                .setBuildFileName(buildFileName)
                .setDefaultIncludes(defaultIncludes)
                .setDescriptions(repository.getAllDescriptions())
                .build()));
  }


  @VisibleForTesting
  Parser(
      Repository repository,
      boolean enforceBuckPackageBoundary,
      ImmutableSet<Pattern> tempFilePatterns,
      String buildFileName,
      Supplier<BuildFileTree> buildFileTreeSupplier,
      ProjectBuildFileParserFactory buildFileParserFactory)
      throws IOException, InterruptedException {
    this.repository = repository;
    this.buildFileName = buildFileName;
    this.buildFileTreeCache = new BuildFileTreeCache(buildFileTreeSupplier);
    this.buildFileParserFactory = buildFileParserFactory;
    this.enforceBuckPackageBoundary = enforceBuckPackageBoundary;
    this.buildFileDependents = ArrayListMultimap.create();
    this.tempFilePatterns = tempFilePatterns;
    this.state = new CachedState(buildFileName);
  }

  public Path getProjectRoot() {
    return repository.getFilesystem().getRootPath();
  }


  private synchronized boolean isCached(
      Path buildFile,
      Iterable<String> includes,
      ImmutableMap<String, String> env) {
    boolean includesChanged = state.invalidateCacheOnIncludeChange(includes);
    boolean environmentChanged = state.invalidateCacheOnEnvironmentChange(env);
    boolean fileParsed = state.isParsed(buildFile);
    return !includesChanged && !environmentChanged && fileParsed;
  }

  private synchronized void invalidateCache() {
    state.invalidateAll();
  }


  public synchronized void cleanCache() {
    state.cleanCache();
  }

  public LoadingCache<BuildTarget, HashCode> getBuildTargetHashCodeCache() {
    return state.getBuildTargetHashCodeCache();
  }


  private ImmutableSet<BuildTarget> resolveTargetSpec(
      TargetNodeSpec spec,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    ImmutableSet.Builder<BuildTarget> targets = ImmutableSet.builder();


    for (Path buildFile : spec.getBuildFileSpec().findBuildFiles(
        repository.getFilesystem(),
        buildFileName)) {


      if (!repository.getFilesystem().isFile(buildFile)) {
        throw new MissingBuildFileException(spec, buildFile);
      }


      List<Map<String, Object>> parsed = parseBuildFile(
          repository.getFilesystem().resolve(buildFile),
          parserConfig,
          buildFileParser,
          environment);
      List<TargetNode<?>> nodes = Lists.newArrayListWithCapacity(parsed.size());
      for (Map<String, Object> map : parsed) {
        BuildTarget target = parseBuildTargetFromRawRule(map);
        TargetNode<?> node = getTargetNode(target);
        nodes.add(node);
      }


      targets.addAll(spec.filter(nodes));
    }

    return targets.build();
  }

  private ImmutableSet<BuildTarget> resolveTargetSpecs(
      Iterable<? extends TargetNodeSpec> specs,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    ImmutableSet.Builder<BuildTarget> targets = ImmutableSet.builder();

    for (TargetNodeSpec spec : specs) {
      targets.addAll(
          resolveTargetSpec(
              spec,
              parserConfig,
              buildFileParser,
              environment));
    }

    return targets.build();
  }


  public synchronized Pair<ImmutableSet<BuildTarget>, TargetGraph>
      buildTargetGraphForTargetNodeSpecs(
          Iterable<? extends TargetNodeSpec> targetNodeSpecs,
          ParserConfig parserConfig,
          BuckEventBus eventBus,
          Console console,
          ImmutableMap<String, String> environment,
          boolean enableProfiling)
          throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    TargetGraph graph = null;


    try (ProjectBuildFileParser buildFileParser = buildFileParserFactory.createParser(
        console,
        environment,
        eventBus)) {
      buildFileParser.setEnableProfiling(enableProfiling);


      ImmutableSet<BuildTarget> buildTargets = resolveTargetSpecs(
          targetNodeSpecs,
          parserConfig,
          buildFileParser,
          environment);

      postParseStartEvent(buildTargets, eventBus);

      try {
        graph = buildTargetGraph(
            buildTargets,
            parserConfig,
            buildFileParser,
            environment,
            eventBus);
        return new Pair<>(buildTargets, graph);
      } finally {
        eventBus.post(ParseEvent.finished(buildTargets, Optional.fromNullable(graph)));
      }
    }
  }


  public TargetGraph buildTargetGraphForBuildTargets(
      Iterable<BuildTarget> buildTargets,
      ParserConfig parserConfig,
      BuckEventBus eventBus,
      Console console,
      ImmutableMap<String, String> environment,
      boolean enableProfiling)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
    return buildTargetGraphForTargetNodeSpecs(
        Iterables.transform(
            buildTargets,
            AbstractBuildTargetSpec.TO_BUILD_TARGET_SPEC),
        parserConfig,
        eventBus,
        console,
        environment,
        enableProfiling).getSecond();
  }

  @Nullable
  public synchronized TargetNode<?> getTargetNode(BuildTarget buildTarget)
      throws IOException, InterruptedException {
    return state.get(buildTarget);
  }


  private synchronized TargetGraph buildTargetGraph(
      Iterable<BuildTarget> toExplore,
      final ParserConfig parserConfig,
      final ProjectBuildFileParser buildFileParser,
      final ImmutableMap<String, String> environment,
      final BuckEventBus eventBus) throws IOException, InterruptedException {

    final MutableDirectedGraph<TargetNode<?>> graph = new MutableDirectedGraph<>();

    final Optional<BuckEventBus> eventBusOptional = Optional.of(eventBus);

    AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal =
        new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>() {
          @Override
          protected Iterator<BuildTarget> findChildren(BuildTarget buildTarget)
              throws IOException, InterruptedException {
            eventBus.post(GetTargetDependenciesEvent.started(buildTarget));
            try {
              BuildTargetPatternParser<BuildTargetPattern> buildTargetPatternParser =
                  BuildTargetPatternParser.forBaseName(buildTarget.getBaseName());



              eventBus.post(GetTargetNodeEvent.started(buildTarget));
              TargetNode<?> targetNode = state.get(buildTarget, eventBusOptional);
              eventBus.post(GetTargetNodeEvent.finished(buildTarget));
              if (targetNode == null) {
                throw new HumanReadableException(
                    NoSuchBuildTargetException.createForMissingBuildRule(
                        buildTarget,
                        buildTargetPatternParser,
                        parserConfig.getBuildFileName()));
              }

              Set<BuildTarget> deps = Sets.newHashSet();
              for (BuildTarget buildTargetForDep : targetNode.getDeps()) {
                try {
                  eventBus.post(GetTargetNodeEvent.started(buildTargetForDep));
                  TargetNode<?> depTargetNode = state.get(buildTargetForDep, eventBusOptional);
                  eventBus.post(GetTargetNodeEvent.finished(buildTargetForDep));
                  if (depTargetNode == null) {
                    parseBuildFileContainingTarget(
                        buildTargetForDep,
                        parserConfig,
                        buildFileParser,
                        environment);
                    eventBus.post(GetTargetNodeEvent.started(buildTargetForDep));
                    depTargetNode = state.get(buildTargetForDep, eventBusOptional);
                    eventBus.post(GetTargetNodeEvent.finished(buildTargetForDep));
                    if (depTargetNode == null) {
                      throw new HumanReadableException(
                          NoSuchBuildTargetException.createForMissingBuildRule(
                              buildTargetForDep,
                              BuildTargetPatternParser.forBaseName(
                                  buildTargetForDep.getBaseName()),
                              parserConfig.getBuildFileName()));
                    }
                  }
                  depTargetNode.checkVisibility(buildTarget);
                  deps.add(buildTargetForDep);
                } catch (HumanReadableException | BuildTargetException | BuildFileParseException
                             e) {
                  throw new HumanReadableException(
                      e,
                      "Couldn't get dependency '%s' of target '%s':\n%s",
                      buildTargetForDep,
                      buildTarget,
                      e.getHumanReadableErrorMessage());
                }
              }

              return deps.iterator();
            } finally {
              eventBus.post(GetTargetDependenciesEvent.finished(buildTarget));
            }
          }

          @Override
          protected void onNodeExplored(BuildTarget buildTarget)
              throws IOException, InterruptedException {
            TargetNode<?> targetNode = getTargetNode(buildTarget);
            Preconditions.checkNotNull(targetNode, "No target node found for %s", buildTarget);
            graph.addNode(targetNode);
            for (BuildTarget target : targetNode.getDeps()) {
              graph.addEdge(targetNode, Preconditions.checkNotNull(getTargetNode(target)));
            }
          }

          @Override
          protected void onTraversalComplete(Iterable<BuildTarget> nodesInExplorationOrder) {
          }
        };

    try {
      traversal.traverse(toExplore);
    } catch (AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
      throw new HumanReadableException(e.getMessage());
    }

    return new TargetGraph(graph);
  }

  private synchronized void parseBuildFileContainingTarget(
      BuildTarget buildTarget,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    if (buildTarget.getRepository().isPresent()) {
      throw new HumanReadableException(
          "Buck does not currently support multiple repositories: %d",
          buildTarget);
    }
    Repository targetRepo = repository;
    Path buildFile = targetRepo.getAbsolutePathToBuildFile(buildTarget);
    if (isCached(buildFile, parserConfig.getDefaultIncludes(), environment)) {
      throw new HumanReadableException(
          "The build file that should contain %s has already been parsed (%s), " +
              "but %s was not found. Please make sure that %s is defined in %s.",
          buildTarget,
          buildFile,
          buildTarget,
          buildTarget,
          buildFile);
    }

    parseBuildFile(buildFile, parserConfig, buildFileParser, environment);
  }

  public synchronized List<Map<String, Object>> parseBuildFile(
      Path buildFile,
      ParserConfig parserConfig,
      ImmutableMap<String, String> environment,
      Console console,
      BuckEventBus buckEventBus)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {
    try (ProjectBuildFileParser projectBuildFileParser = buildFileParserFactory.createParser(
        console,
        environment,
        buckEventBus)) {
      return parseBuildFile(buildFile, parserConfig, projectBuildFileParser, environment);
    }
  }


  public synchronized List<Map<String, Object>> parseBuildFile(
      Path buildFile,
      ParserConfig parserConfig,
      ProjectBuildFileParser buildFileParser,
      ImmutableMap<String, String> environment)
      throws BuildFileParseException, BuildTargetException, IOException, InterruptedException {

    if (!isCached(buildFile, parserConfig.getDefaultIncludes(), environment)) {
      LOG.debug("Parsing %s file: %s", buildFileName, buildFile);
      parseRawRulesInternal(buildFileParser.getAllRulesAndMetaRules(buildFile));
    } else {
      LOG.debug("Not parsing %s file (already in cache)", buildFileName);
    }
    return state.getRawRules(buildFile);
  }


  @VisibleForTesting
  synchronized void parseRawRulesInternal(Iterable<Map<String, Object>> rules)
      throws BuildTargetException, IOException {
    LOG.verbose("Parsing raw rules, state before parse %s", state);
    for (Map<String, Object> map : rules) {

      if (isMetaRule(map)) {
        parseMetaRule(map);
        continue;
      }

      BuildTarget target = parseBuildTargetFromRawRule(map);
      BuildRuleType buildRuleType = parseBuildRuleTypeFromRawRule(map);
      Description<?> description = repository.getDescription(buildRuleType);
      if (description == null) {
        throw new HumanReadableException("Unrecognized rule %s while parsing %s.",
            buildRuleType,
            repository.getAbsolutePathToBuildFile(target));
      }

      state.put(target, map);
    }
    LOG.verbose("Finished parsing raw rules, state after parse %s", state);
  }


  private boolean isMetaRule(Map<String, Object> map) {
    return map.containsKey(INCLUDES_META_RULE);
  }


  @SuppressWarnings("unchecked") 
  private synchronized boolean parseMetaRule(Map<String, Object> map) {
    Preconditions.checkState(isMetaRule(map));



    List<String> fileNames = ((List<String>) map.get(INCLUDES_META_RULE));
    Preconditions.checkNotNull(fileNames);
    Path dependent = normalize(Paths.get(fileNames.get(0)));
    for (String fileName : fileNames) {
      buildFileDependents.put(normalize(Paths.get(fileName)), dependent);
    }
    return true;
  }


  private BuildRuleType parseBuildRuleTypeFromRawRule(Map<String, Object> map) {
    String type = (String) Preconditions.checkNotNull(map.get(BuckPyFunction.TYPE_PROPERTY_NAME));
    return repository.getBuildRuleType(type);
  }


  private BuildTarget parseBuildTargetFromRawRule(Map<String, Object> map) {
    String basePath = (String) Preconditions.checkNotNull(map.get("buck.base_path"));
    String name = (String) Preconditions.checkNotNull(map.get("name"));
    return BuildTarget.builder(UnflavoredBuildTarget.BUILD_TARGET_PREFIX + basePath, name).build();
  }



  @Subscribe
  public synchronized void onCommandStartedEvent(BuckEvent event) {


    Preconditions.checkArgument(
        event.getEventName().equals("CommandStarted"),
        "event should be of type CommandEvent.Started, but was: %s.",
        event);
    buildFileTreeCache.onCommandStartedEvent(event);
  }


  @Subscribe
  public synchronized void onFileSystemChange(WatchEvent<?> event) throws IOException {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(
          "Parser watched event %s %s",
          event.kind(),
          repository.getFilesystem().createContextString(event));
    }

    if (repository.getFilesystem().isPathChangeEvent(event)) {
      Path path = (Path) event.context();

      if (isPathCreateOrDeleteEvent(event)) {

        if (path.endsWith(new ParserConfig(repository.getBuckConfig()).getBuildFileName())) {


          buildFileTreeCache.invalidateIfStale();
        }



        if (!isTempFile(path)) {
          invalidateContainingBuildFile(path);
        }
      }

      LOG.verbose("Invalidating dependents for path %s, cache state %s", path, state);


      state.invalidateDependents(path);

    } else {

      LOG.debug("Parser invalidating entire cache on overflow.");
      buildFileTreeCache.invalidateIfStale();
      invalidateCache();
    }
  }


  private boolean isTempFile(Path path) {
    final String fileName = path.getFileName().toString();
    Predicate<Pattern> patternMatches = new Predicate<Pattern>() {
      @Override
      public boolean apply(Pattern pattern) {
        return pattern.matcher(fileName).matches();
      }
    };
    return Iterators.any(tempFilePatterns.iterator(), patternMatches);
  }


  private synchronized void invalidateContainingBuildFile(Path path) throws IOException {
    List<Path> packageBuildFiles = Lists.newArrayList();



    Optional<Path> packageBuildFile = buildFileTreeCache.get().getBasePathOfAncestorTarget(path);
    packageBuildFiles.addAll(packageBuildFile.asSet());



    if (!enforceBuckPackageBoundary) {
      while (packageBuildFile.isPresent() && packageBuildFile.get().getParent() != null) {
        packageBuildFile =
            buildFileTreeCache.get()
                .getBasePathOfAncestorTarget(packageBuildFile.get().getParent());
        packageBuildFiles.addAll(packageBuildFile.asSet());
      }
    }


    for (Path buildFile : packageBuildFiles) {
      state.invalidateDependents(
          repository.getFilesystem().getPathForRelativePath(
              buildFile.resolve(
                  new ParserConfig(repository.getBuckConfig()).getBuildFileName())));
    }
  }

  private boolean isPathCreateOrDeleteEvent(WatchEvent<?> event) {
    return event.kind() == StandardWatchEventKinds.ENTRY_CREATE ||
        event.kind() == StandardWatchEventKinds.ENTRY_DELETE;
  }


  private Path normalize(Path path) {
    return repository.getFilesystem().resolve(path);
  }


  public void recordParseStartTime(BuckEventBus eventBus) {
    class ParseStartTime extends AbstractBuckEvent {

      @Override
      protected String getValueString() {
        return "Timestamp.";
      }

      @Override
      public String getEventName() {
        return "ParseStartTime";
      }
    }
    parseStartEvent = Optional.<BuckEvent>of(new ParseStartTime());
    eventBus.timestamp(parseStartEvent.get());
  }


  public Optional<BuckEvent> getParseStartTime() {
    return parseStartEvent;
  }


  private void postParseStartEvent(Iterable<BuildTarget> buildTargets, BuckEventBus eventBus) {
    if (parseStartEvent.isPresent()) {
      eventBus.post(ParseEvent.started(buildTargets), parseStartEvent.get());
    } else {
      eventBus.post(ParseEvent.started(buildTargets));
    }
  }

  private class CachedState {


    private final ListMultimap<Path, Map<String, Object>> parsedBuildFiles;


    private final Map<Path, Path> symlinkExistenceCache;


    private final Set<Path> buildInputPathsUnderSymlink;


    private final ListMultimap<Path, BuildTarget> pathsToBuildTargets;


    private final Map<BuildTarget, TargetNode<?>> memoizedTargetNodes;


    @Nullable
    private ImmutableMap<String, String> cacheEnvironment;


    @Nullable
    private List<String> cacheDefaultIncludes;

    private final Map<BuildTarget, Path> targetsToFile;

    private final LoadingCache<BuildTarget, HashCode> buildTargetHashCodeCache;

    private final String buildFile;

    public CachedState(String buildFileName) {
      this.memoizedTargetNodes = Maps.newHashMap();
      this.symlinkExistenceCache = Maps.newHashMap();
      this.buildInputPathsUnderSymlink = Sets.newHashSet();
      this.parsedBuildFiles = ArrayListMultimap.create();
      this.targetsToFile = Maps.newHashMap();
      this.pathsToBuildTargets = ArrayListMultimap.create();
      this.buildTargetHashCodeCache = CacheBuilder.newBuilder().build(
          new CacheLoader<BuildTarget, HashCode>() {
            @Override
            public HashCode load(BuildTarget buildTarget) throws IOException, InterruptedException {
              return loadHashCodeForBuildTarget(buildTarget);
            }
          });
      this.buildFile = buildFileName;
    }

    public void invalidateAll() {
      LOG.debug("Invalidating all cached data.");
      parsedBuildFiles.clear();
      symlinkExistenceCache.clear();
      buildInputPathsUnderSymlink.clear();
      memoizedTargetNodes.clear();
      targetsToFile.clear();
      pathsToBuildTargets.clear();
      buildTargetHashCodeCache.invalidateAll();
    }

    @Override
    public String toString() {
      return String.format(
          "%s memoized=%s symlinks=%s build files under symlink=%s parsed=%s targets-to-files=%s " +
          "paths-to-targets=%s build-target-hash-code-cache=%s",
          super.toString(),
          memoizedTargetNodes,
          symlinkExistenceCache,
          buildInputPathsUnderSymlink,
          parsedBuildFiles,
          targetsToFile,
          pathsToBuildTargets,
          buildTargetHashCodeCache);
    }


    private synchronized boolean invalidateCacheOnEnvironmentChange(
        ImmutableMap<String, String> environment) {
      if (!environment.equals(cacheEnvironment)) {
        if (cacheEnvironment != null) {
          LOG.warn(
              "Environment variables changed (%s). Discarding cache to avoid effects on build. " +
              "This will make builds very slow.",
              Maps.difference(cacheEnvironment, environment));
        }
        invalidateCache();
        this.cacheEnvironment = environment;
        return true;
      }
      return false;
    }


    private synchronized boolean invalidateCacheOnIncludeChange(Iterable<String> includes) {
      List<String> includesList = Lists.newArrayList(includes);
      if (!includesList.equals(this.cacheDefaultIncludes)) {
        LOG.debug("Parser invalidating entire cache on default include change.");
        invalidateCache();
        this.cacheDefaultIncludes = includesList;
        return true;
      }
      return false;
    }


    synchronized void invalidateDependents(Path path) {

      path = normalize(path);


      symlinkExistenceCache.remove(path);

      if (parsedBuildFiles.containsKey(path)) {
        LOG.debug("Parser invalidating %s cache", path);


        List<?> removed = parsedBuildFiles.removeAll(path);
        LOG.verbose("Removed parsed build files %s defined by %s", removed, path);



        buildInputPathsUnderSymlink.remove(path);
      } else {
        LOG.debug("Parsed build files does not contain %s, not invalidating", path);
      }

      List<BuildTarget> targetsToRemove = pathsToBuildTargets.get(path);
      LOG.debug("Removing targets %s for path %s", targetsToRemove, path);
      for (BuildTarget target : targetsToRemove) {
        memoizedTargetNodes.remove(target);
      }
      buildTargetHashCodeCache.invalidateAll(targetsToRemove);
      pathsToBuildTargets.removeAll(path);

      List<Path> dependents = buildFileDependents.get(path);
      LOG.verbose("Invalidating dependents %s of path %s", dependents, path);

      for (Path dependent : dependents) {

        if (!dependent.equals(path)) {
          invalidateDependents(dependent);
        }
      }


      List<?> removedDependents = buildFileDependents.removeAll(path);
      LOG.verbose("Removed build file dependents %s defined by %s", removedDependents, path);
    }

    public boolean isParsed(Path buildFile) {
      return parsedBuildFiles.containsKey(normalize(buildFile));
    }

    public List<Map<String, Object>> getRawRules(Path buildFile) {
      return Preconditions.checkNotNull(parsedBuildFiles.get(normalize(buildFile)));
    }

    public void put(BuildTarget target, Map<String, Object> rawRules) {
      Path normalized = normalize(target.getBasePath().resolve(buildFile));
      LOG.verbose("Adding rules for parsed build file %s", normalized);
      parsedBuildFiles.put(normalized, rawRules);

      targetsToFile.put(
          target,
          normalize(Paths.get((String) rawRules.get("buck.base_path")))
              .resolve(buildFile).toAbsolutePath());
    }

    @Nullable
    public TargetNode<?> get(BuildTarget buildTarget) throws IOException, InterruptedException {
      return get(buildTarget, Optional.<BuckEventBus>absent());
    }

    @Nullable
    @SuppressWarnings({"rawtypes", "unchecked"})
    public TargetNode<?> get(
        BuildTarget buildTarget,
        Optional<BuckEventBus> eventBus) throws IOException, InterruptedException {

      TargetNode<?> toReturn = memoizedTargetNodes.get(buildTarget);
      if (toReturn != null) {
        return toReturn;
      }

      if (buildTarget.getRepository().isPresent()) {
        throw new HumanReadableException(
            "Buck does not currently support multiple repos: %d",
            buildTarget);
      }
      Repository targetRepo = repository;
      Path buildFilePath;
      try {
        buildFilePath = targetRepo.getAbsolutePathToBuildFile(buildTarget);
      } catch (Repository.MissingBuildFileException e) {
        throw new HumanReadableException(e);
      }
      UnflavoredBuildTarget unflavored = buildTarget.getUnflavoredBuildTarget();
      List<Map<String, Object>> rules = state.getRawRules(buildFilePath);
      for (Map<String, Object> map : rules) {

        if (!buildTarget.getShortName().equals(map.get("name"))) {
          continue;
        }

        BuildRuleType buildRuleType = parseBuildRuleTypeFromRawRule(map);
        targetsToFile.put(
            BuildTarget.of(unflavored),
            normalize(Paths.get((String) map.get("buck.base_path")))
                .resolve(buildFile).toAbsolutePath());

        Description<?> description = repository.getDescription(buildRuleType);
        if (description == null) {
          throw new HumanReadableException("Unrecognized rule %s while parsing %s%s.",
              buildRuleType,
              UnflavoredBuildTarget.BUILD_TARGET_PREFIX,
              MorePaths.pathWithUnixSeparators(unflavored.getBasePath().resolve(buildFile)));
        }

        if (buildTarget.isFlavored()) {
          if (description instanceof Flavored) {
            if (!((Flavored) description).hasFlavors(
                    ImmutableSet.copyOf(buildTarget.getFlavors()))) {
              throw new HumanReadableException(
                  "Unrecognized flavor in target %s while parsing %s%s.",
                  buildTarget,
                  UnflavoredBuildTarget.BUILD_TARGET_PREFIX,
                  MorePaths.pathWithUnixSeparators(
                      buildTarget.getBasePath().resolve(buildFile)));
            }
          } else {
            LOG.warn(
                "Target %s (type %s) must implement the Flavored interface " +
                "before we can check if it supports flavors: %s",
                buildTarget.getUnflavoredBuildTarget(),
                buildRuleType,
                buildTarget.getFlavors());
            throw new HumanReadableException(
                "Target %s (type %s) does not currently support flavors (tried %s)",
                buildTarget.getUnflavoredBuildTarget(),
                buildRuleType,
                buildTarget.getFlavors());
          }
        }

        this.pathsToBuildTargets.put(buildFilePath, buildTarget);

        BuildRuleFactoryParams factoryParams = new BuildRuleFactoryParams(
            targetRepo.getFilesystem(),


            buildTarget,
            buildFileTreeCache.get(),
            enforceBuckPackageBoundary);
        Object constructorArg = description.createUnpopulatedConstructorArg();
        TargetNode<?> targetNode;
        try {
          ImmutableSet.Builder<BuildTarget> declaredDeps = ImmutableSet.builder();
          ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns = ImmutableSet.builder();
          if (eventBus.isPresent()) {
            eventBus.get().post(MarshalConstructorArgsEvent.started(buildTarget));
          }
          marshaller.populate(
              targetRepo.getFilesystem(),
              factoryParams,
              constructorArg,
              declaredDeps,
              visibilityPatterns,
              map);
          if (eventBus.isPresent()) {
            eventBus.get().post(MarshalConstructorArgsEvent.finished(buildTarget));
          }
          if (eventBus.isPresent()) {
            eventBus.get().post(CreateTargetNodeEvent.started(buildTarget));
          }
          targetNode = new TargetNode(
              description,
              constructorArg,
              factoryParams,
              declaredDeps.build(),
              visibilityPatterns.build());
          if (eventBus.isPresent()) {
            eventBus.get().post(CreateTargetNodeEvent.finished(buildTarget));
          }
        } catch (NoSuchBuildTargetException | TargetNode.InvalidSourcePathInputException e) {
          throw new HumanReadableException(e);
        } catch (ConstructorArgMarshalException e) {
          throw new HumanReadableException("%s: %s", buildTarget, e.getMessage());
        }

        Map<Path, Path> newSymlinksEncountered = Maps.newHashMap();
        if (inputFilesUnderSymlink(
                targetNode.getInputs(),
                targetRepo.getFilesystem(),
                symlinkExistenceCache,
                newSymlinksEncountered)) {
          LOG.warn(
              "Disabling caching for target %s, because one or more input files are under a " +
              "symbolic link (%s). This will severely impact performance! To resolve this, use " +
              "separate rules and declare dependencies instead of using symbolic links.",
              targetNode.getBuildTarget(),
              newSymlinksEncountered);
          buildInputPathsUnderSymlink.add(buildFilePath);
        }
        TargetNode<?> existingTargetNode = memoizedTargetNodes.put(buildTarget, targetNode);
        if (existingTargetNode != null) {
          throw new HumanReadableException("Duplicate definition for " + unflavored);
        }


      }

      return memoizedTargetNodes.get(buildTarget);
    }

    public synchronized void cleanCache() {
      LOG.debug(
          "Cleaning cache of build files with inputs under symlink %s",
          buildInputPathsUnderSymlink);
      Set<Path> buildInputPathsUnderSymlinkCopy = new HashSet<>(buildInputPathsUnderSymlink);
      buildInputPathsUnderSymlink.clear();
      for (Path buildFilePath : buildInputPathsUnderSymlinkCopy) {
        invalidateDependents(buildFilePath);
      }
    }

    private synchronized HashCode loadHashCodeForBuildTarget(BuildTarget buildTarget)
        throws IOException, InterruptedException{

      get(buildTarget);

      Path buildTargetPath = targetsToFile.get(
          BuildTarget.of(buildTarget.getUnflavoredBuildTarget()));
      if (buildTargetPath == null) {
        throw new HumanReadableException("Couldn't find build target %s", buildTarget);
      }
      List<Map<String, Object>> rules = getRawRules(buildTargetPath);
      Hasher hasher = Hashing.sha1().newHasher();
      hasher.putString(BuckVersion.getVersion(), UTF_8);
      for (Map<String, Object> map : rules) {
        if (!buildTarget.getShortName().equals(map.get("name"))) {
          continue;
        }

        JsonObjectHashing.hashJsonObject(hasher, map);
      }
      return hasher.hash();
    }

    public LoadingCache<BuildTarget, HashCode> getBuildTargetHashCodeCache() {
      return buildTargetHashCodeCache;
    }
  }

  private static boolean inputFilesUnderSymlink(


      Collection<Path> inputs,
      ProjectFilesystem projectFilesystem,
      Map<Path, Path> symlinkExistenceCache,
      Map<Path, Path> newSymlinksEncountered) throws IOException {
    boolean result = false;
    for (Path input : inputs) {
      for (int i = 1; i < input.getNameCount(); i++) {
        Path subpath = input.subpath(0, i);
        Path resolvedSymlink = symlinkExistenceCache.get(subpath);
        if (resolvedSymlink != null) {
          newSymlinksEncountered.put(subpath, resolvedSymlink);
          result = true;
        } else if (projectFilesystem.isSymLink(subpath)) {
          try {
            resolvedSymlink = projectFilesystem.getRootPath().relativize(subpath.toRealPath());
            LOG.debug("Detected symbolic link %s -> %s", subpath, resolvedSymlink);
            newSymlinksEncountered.put(subpath, resolvedSymlink);
            symlinkExistenceCache.put(subpath, resolvedSymlink);
          } catch (NoSuchFileException e) {
            LOG.verbose(e, "No such file detecting symlink at %s", subpath);
          } catch (IOException e) {
            LOG.error(e, "Couldn't detect symbolic link at %s", subpath);
          }
          result = true;
        }
      }
    }
    return result;
  }

}

<code block>


package com.facebook.buck.json;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.BuckPyFunction;
import com.facebook.buck.rules.ConstructorArgMarshaller;
import com.facebook.buck.rules.Description;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.InputStreamConsumer;
import com.facebook.buck.util.MoreThrowables;
import com.facebook.buck.util.NamedTemporaryFile;
import com.facebook.buck.util.Threads;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Resources;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;


public class ProjectBuildFileParser implements AutoCloseable {


  private static final String BUCK_PY_RESOURCE = "com/facebook/buck/json/buck.py";

  private static final Path PATH_TO_PATHLIB_PY = Paths.get(
      System.getProperty(
          "buck.path_to_pathlib_py",
          "third-party/py/pathlib/pathlib.py"));

  private static final Logger LOG = Logger.get(ProjectBuildFileParser.class);

  private final ImmutableMap<String, String> environment;

  private Optional<Path> pathToBuckPy;

  @Nullable private Process buckPyProcess;
  @Nullable BuildFileToJsonParser buckPyStdoutParser;
  @Nullable private BufferedWriter buckPyStdinWriter;

  private final ProjectBuildFileParserOptions options;
  private final Console console;
  private final BuckEventBus buckEventBus;

  private boolean isInitialized;
  private boolean isClosed;

  private boolean enableProfiling;
  @Nullable private NamedTemporaryFile profileOutputFile;
  @Nullable private Thread stderrConsumer;
  @Nullable private ProjectBuildFileParseEvents.Started projectBuildFileParseEventStarted;

  protected ProjectBuildFileParser(
      ProjectBuildFileParserOptions options,
      Console console,
      ImmutableMap<String, String> environment,
      BuckEventBus buckEventBus) {
    this.pathToBuckPy = Optional.absent();
    this.options = options;
    this.console = console;
    this.environment = environment;
    this.buckEventBus = buckEventBus;
  }

  public void setEnableProfiling(boolean enableProfiling) {
    ensureNotClosed();
    ensureNotInitialized();
    this.enableProfiling = enableProfiling;
  }

  private void ensureNotClosed() {
    Preconditions.checkState(!isClosed);
  }

  private void ensureNotInitialized() {
    Preconditions.checkState(!isInitialized);
  }


  @VisibleForTesting
  public void initIfNeeded() throws IOException {
    ensureNotClosed();
    if (!isInitialized) {
      init();
      isInitialized = true;
    }
  }


  private void init() throws IOException {
    projectBuildFileParseEventStarted = new ProjectBuildFileParseEvents.Started();
    buckEventBus.post(projectBuildFileParseEventStarted);

    ProcessBuilder processBuilder = new ProcessBuilder(buildArgs());
    processBuilder.environment().clear();
    processBuilder.environment().putAll(environment);

    LOG.debug(
        "Starting buck.py command: %s environment: %s",
        processBuilder.command(),
        processBuilder.environment());
    buckPyProcess = processBuilder.start();
    LOG.debug("Started process %s successfully", buckPyProcess);

    OutputStream stdin = buckPyProcess.getOutputStream();
    InputStream stderr = buckPyProcess.getErrorStream();

    stderrConsumer = Threads.namedThread(
        ProjectBuildFileParser.class.getSimpleName(),
        new InputStreamConsumer(stderr,
            console.getStdErr(),
            console.getAnsi(),
 true,
            Optional.<InputStreamConsumer.Handler>of(new InputStreamConsumer.Handler() {
              @Override
              public void handleLine(String line) {
                LOG.warn("buck.py warning: %s", line);
              }
            })));
    stderrConsumer.start();

    buckPyStdinWriter = new BufferedWriter(new OutputStreamWriter(stdin));

    Reader reader = new InputStreamReader(buckPyProcess.getInputStream(), Charsets.UTF_8);
    buckPyStdoutParser = new BuildFileToJsonParser(reader);
  }

  private ImmutableList<String> buildArgs() throws IOException {

    ImmutableList.Builder<String> argBuilder = ImmutableList.builder();

    argBuilder.add(options.getPythonInterpreter());



    argBuilder.add("-u");

    if (enableProfiling) {
      profileOutputFile = new NamedTemporaryFile("buck-py-profile", ".pstats");
      argBuilder.add("-m");
      argBuilder.add("cProfile");
      argBuilder.add("-o");
      argBuilder.add(profileOutputFile.get().toString());
    }

    argBuilder.add(getPathToBuckPy(options.getDescriptions()).toString());

    if (options.getAllowEmptyGlobs()) {
      argBuilder.add("--allow_empty_globs");
    }

    argBuilder.add("--project_root", options.getProjectRoot().toAbsolutePath().toString());
    argBuilder.add("--build_file_name", options.getBuildFileName());


    for (String include : options.getDefaultIncludes()) {
      argBuilder.add("--include");
      argBuilder.add(include);
    }

    return argBuilder.build();
  }


  public List<Map<String, Object>> getAll(Path buildFile)
      throws BuildFileParseException, InterruptedException {
    List<Map<String, Object>> result = getAllRulesAndMetaRules(buildFile);


    return Collections.unmodifiableList(result.subList(0, result.size() - 1));
  }


  public List<Map<String, Object>> getAllRulesAndMetaRules(Path buildFile)
      throws BuildFileParseException, InterruptedException {
    try {
      return getAllRulesInternal(buildFile);
    } catch (IOException e) {
      MoreThrowables.propagateIfInterrupt(e);
      throw BuildFileParseException.createForBuildFileParseError(buildFile, e);
    }
  }

  @VisibleForTesting
  protected List<Map<String, Object>> getAllRulesInternal(Path buildFile)
      throws IOException {
    ensureNotClosed();
    initIfNeeded();


    Preconditions.checkNotNull(buckPyStdoutParser);
    Preconditions.checkNotNull(buckPyStdinWriter);
    Preconditions.checkNotNull(buckPyProcess);

    buckEventBus.post(ParseBuckFileEvent.started(buildFile));
    String buildFileString = buildFile.toString();
    LOG.verbose("Writing to buck.py stdin: %s", buildFileString);
    buckPyStdinWriter.write(buildFileString);
    buckPyStdinWriter.newLine();
    buckPyStdinWriter.flush();

    LOG.debug("Parsing output of process %s...", buckPyProcess);
    List<Map<String, Object>> result = buckPyStdoutParser.nextRules();
    LOG.verbose("Got rules: %s", result);
    int numRules = result.size();
    LOG.debug("Parsed %d rules from process", numRules);
    buckEventBus.post(ParseBuckFileEvent.finished(buildFile, numRules));
    return result;
  }

  @Override
  @SuppressWarnings("PMD.EmptyCatchBlock")
  public void close() throws BuildFileParseException, InterruptedException {
    if (isClosed) {
      return;
    }

    try {
      if (isInitialized) {


        Preconditions.checkNotNull(buckPyStdoutParser);
        Preconditions.checkNotNull(buckPyStdinWriter);
        Preconditions.checkNotNull(buckPyProcess);

        try {
          buckPyStdoutParser.close();
        } catch (IOException e) {

        }


        try {
          buckPyStdinWriter.close();
        } catch (IOException e) {


        }

        if (stderrConsumer != null) {
          stderrConsumer.join();
          stderrConsumer = null;
        }

        if (enableProfiling && profileOutputFile != null) {
          parseProfileOutput(profileOutputFile.get());
        }

        LOG.debug("Waiting for process %s to exit...", buckPyProcess);
        int exitCode = buckPyProcess.waitFor();
        if (exitCode != 0) {
          LOG.error("Process %s exited with error code %d", buckPyProcess, exitCode);
          throw BuildFileParseException.createForUnknownParseError(
              String.format("Parser did not exit cleanly (exit code: %d)", exitCode));
        }
        LOG.debug("Process %s exited cleanly.", buckPyProcess);

        try {
          synchronized (this) {
            if (pathToBuckPy.isPresent()) {
              Files.delete(pathToBuckPy.get());
            }
          }
        } catch (IOException e) {

        }

      }
    } finally {
      if (isInitialized) {
        buckEventBus.post(
            new ProjectBuildFileParseEvents.Finished(
                Preconditions.checkNotNull(projectBuildFileParseEventStarted)));
      }
      isClosed = true;
    }
  }

  private static void parseProfileOutput(Path profileOutput) throws InterruptedException {
    try {
      LOG.debug("Parsing output of profiler: %s", profileOutput);
      ProcessBuilder processBuilder = new ProcessBuilder(
          "python", "-m", "pstats", profileOutput.toString());
      Process process = processBuilder.start();
      LOG.debug("Started process: %s", processBuilder.command());
      try (OutputStreamWriter stdin =
               new OutputStreamWriter(process.getOutputStream(), Charsets.UTF_8);
           BufferedWriter stdinWriter = new BufferedWriter(stdin);
           InputStreamReader stdout =
               new InputStreamReader(process.getInputStream(), Charsets.UTF_8);
           BufferedReader stdoutReader = new BufferedReader(stdout)) {
        stdinWriter.write("sort cumulative\nstats 25\n");
        stdinWriter.flush();
        stdinWriter.close();
        LOG.debug("Reading process output...");
        String line;
        while ((line = stdoutReader.readLine()) != null) {
          LOG.debug("buck.py profile: %s", line);
        }
        LOG.debug("Done reading process output.");
      }
      process.waitFor();
    } catch (IOException e) {
      LOG.error(e, "Couldn't read profile output file %s", profileOutput);
    }
  }

  private Path getPathToBuckPy(ImmutableSet<Description<?>> descriptions) throws IOException {
    generatePathToBuckPy(descriptions);
    return pathToBuckPy.get();
  }

  private synchronized void generatePathToBuckPy(ImmutableSet<Description<?>> descriptions)
      throws IOException {
    if (pathToBuckPy.isPresent()) {
      return;
    }

    LOG.debug("Creating temporary buck.py instance...");






    Path buckDotPy = Files.createTempFile("buck", ".py");
    Files.createDirectories(buckDotPy.getParent());

    try (Writer out = Files.newBufferedWriter(buckDotPy, UTF_8)) {
      URL resource = Resources.getResource(BUCK_PY_RESOURCE);
      String pathlibDir = PATH_TO_PATHLIB_PY.getParent().toString();
      out.write(
          "from __future__ import with_statement\n" +
          "import sys\n" +
          "sys.path.insert(0, \"" +
              Escaper.escapeAsBashString(MorePaths.pathWithUnixSeparators(pathlibDir)) + "\")\n");
      Resources.asCharSource(resource, UTF_8).copyTo(out);
      out.write("\n\n");

      ConstructorArgMarshaller inspector = new ConstructorArgMarshaller();
      BuckPyFunction function = new BuckPyFunction(inspector);
      for (Description<?> description : descriptions) {
        out.write(function.toPythonFunction(
            description.getBuildRuleType(),
            description.createUnpopulatedConstructorArg()));
        out.write('\n');
      }

      out.write(Joiner.on("\n").join(
          "if __name__ == '__main__':",
          "  try:",
          "    main()",
          "  except KeyboardInterrupt:",
          "    print >> sys.stderr, 'Killed by User'",
          ""));
    }
    Path normalizedBuckDotPyPath = buckDotPy.normalize();
    pathToBuckPy = Optional.of(normalizedBuckDotPyPath);
    LOG.debug("Created temporary buck.py instance at %s.", normalizedBuckDotPyPath);
  }
}

<code block>


package com.facebook.buck.android;

import static com.facebook.buck.util.concurrent.MoreExecutors.newMultiThreadExecutor;
import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.AndroidDebugBridge;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.MultiLineReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.TimeoutException;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.InterruptionFailedException;
import com.facebook.buck.util.TriState;
import com.facebook.buck.util.concurrent.MoreExecutors;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class AdbHelper {

  private static final long ADB_CONNECT_TIMEOUT_MS = 5000;
  private static final long ADB_CONNECT_TIME_STEP_MS = ADB_CONNECT_TIMEOUT_MS / 10;


  public static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile("[\\w.-]+");


  static final String SERIAL_NUMBER_ENV = "ANDROID_SERIAL";


  public static final long INSTALL_TIMEOUT = 2 * 60 * 1000; 
  public static final long GETPROP_TIMEOUT = 2 * 1000; 

  public static final String ECHO_COMMAND_SUFFIX = " ; echo -n :$?";

  private final AdbOptions options;
  private final TargetDeviceOptions deviceOptions;
  private final ExecutionContext context;
  private final Console console;
  private final BuckEventBus buckEventBus;
  private final boolean restartAdbOnFailure;

  public AdbHelper(
      AdbOptions adbOptions,
      TargetDeviceOptions deviceOptions,
      ExecutionContext context,
      Console console,
      BuckEventBus buckEventBus,
      boolean restartAdbOnFailure) {
    this.options = adbOptions;
    this.deviceOptions = deviceOptions;
    this.context = context;
    this.console = console;
    this.buckEventBus = buckEventBus;
    this.restartAdbOnFailure = restartAdbOnFailure;
  }

  private BuckEventBus getBuckEventBus() {
    return buckEventBus;
  }


  @Nullable
  @VisibleForTesting
  List<IDevice> filterDevices(IDevice[] allDevices) {
    if (allDevices.length == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    List<IDevice> devices = Lists.newArrayList();
    TriState emulatorsOnly = TriState.UNSPECIFIED;
    if (deviceOptions.isEmulatorsOnlyModeEnabled() && options.isMultiInstallModeEnabled()) {
      emulatorsOnly = TriState.UNSPECIFIED;
    } else if (deviceOptions.isEmulatorsOnlyModeEnabled()) {
      emulatorsOnly = TriState.TRUE;
    } else if (deviceOptions.isRealDevicesOnlyModeEnabled()) {
      emulatorsOnly = TriState.FALSE;
    }

    int onlineDevices = 0;
    for (IDevice device : allDevices) {
      boolean passed = false;
      if (device.isOnline()) {
        onlineDevices++;

        boolean serialMatches = true;
        if (deviceOptions.hasSerialNumber()) {
          serialMatches = device.getSerialNumber().equals(deviceOptions.getSerialNumber());
        } else if (context.getEnvironment().containsKey(SERIAL_NUMBER_ENV)) {
          serialMatches = device.getSerialNumber().equals(
              context.getEnvironment().get(SERIAL_NUMBER_ENV));
        }

        boolean deviceTypeMatches;
        if (emulatorsOnly.isSet()) {


          deviceTypeMatches = (emulatorsOnly.asBoolean() == device.isEmulator());
        } else {

          deviceTypeMatches = true;
        }
        passed = serialMatches && deviceTypeMatches;
      }

      if (passed) {
        devices.add(device);
      }
    }


    if (onlineDevices == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    if (devices.isEmpty()) {
      console.printBuildFailure(String.format(
          "Found %d connected device(s), but none of them matches specified filter.",
          onlineDevices));
      return null;
    }


    if (!options.isMultiInstallModeEnabled() && devices.size() > 1) {
      console.printBuildFailure(
          String.format("%d device(s) matches specified device filter (1 expected).\n" +
                        "Either disconnect other devices or enable multi-install mode (%s).",
                         devices.size(), AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG));
      return null;
    }


    if (devices.size() > 1) {
      console.getStdOut().printf("Found " + devices.size() + " matching devices.\n");
    }
    return devices;
  }

  private boolean isAdbInitialized(AndroidDebugBridge adb) {
    return adb.isConnected() && adb.hasInitialDeviceList();
  }


  @Nullable
  @SuppressWarnings("PMD.EmptyCatchBlock")
  private AndroidDebugBridge createAdb(ExecutionContext context) throws InterruptedException {
    try {
      AndroidDebugBridge.init( false);
    } catch (IllegalStateException ex) {

    }

    AndroidDebugBridge adb =
        AndroidDebugBridge.createBridge(context.getPathToAdbExecutable(), false);
    if (adb == null) {
      console.printBuildFailure("Failed to connect to adb. Make sure adb server is running.");
      return null;
    }

    long start = System.currentTimeMillis();
    while (!isAdbInitialized(adb)) {
      long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();
      if (timeLeft <= 0) {
        break;
      }
      Thread.sleep(ADB_CONNECT_TIME_STEP_MS);
    }
    return isAdbInitialized(adb) ? adb : null;
  }


  @SuppressWarnings("PMD.EmptyCatchBlock")
  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {
    List<IDevice> devices;

    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, "set_up_adb_call")) {


      AndroidDebugBridge adb = createAdb(context);
      if (adb == null) {
        console.printBuildFailure("Failed to create adb connection.");
        return false;
      }


      devices = filterDevices(adb.getDevices());
      if (devices == null) {
        if (restartAdbOnFailure) {
          console.printErrorText("No devices found with adb, restarting adb-server.");
          adb.restart();
          devices = filterDevices(adb.getDevices());
        }

        if (devices == null) {
            return false;
        }
      }
    }

    int adbThreadCount = options.getAdbThreadCount();
    if (adbThreadCount <= 0) {
      adbThreadCount = devices.size();
    }


    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();
    ListeningExecutorService executorService =
        listeningDecorator(
            newMultiThreadExecutor(
                new CommandThreadFactory(getClass().getSimpleName()),
                adbThreadCount));

    for (final IDevice device : devices) {
      futures.add(executorService.submit(adbCallable.forDevice(device)));
    }


    List<Boolean> results = null;
    try {
      results = Futures.allAsList(futures).get();
    } catch (ExecutionException ex) {
      console.printBuildFailure("Failed: " + adbCallable);
      ex.printStackTrace(console.getStdErr());
      return false;
    } catch (InterruptedException e) {
      try {
        Futures.allAsList(futures).cancel(true);
      } catch (CancellationException ignored) {

      }
      Thread.currentThread().interrupt();
      throw e;
    } finally {
      MoreExecutors.shutdownOrThrow(
          executorService,
          10,
          TimeUnit.MINUTES,
          new InterruptionFailedException("Failed to shutdown ExecutorService."));
    }

    int successCount = 0;
    for (Boolean result : results) {
      if (result) {
        successCount++;
      }
    }
    int failureCount = results.size() - successCount;


    if (successCount > 0) {
      console.printSuccess(
          String.format("Successfully ran %s on %d device(s)", adbCallable, successCount));
    }
    if (failureCount > 0) {
      console.printBuildFailure(
          String.format("Failed to %s on %d device(s).", adbCallable, failureCount));
    }

    return failureCount == 0;
  }


  public abstract static class AdbCallable {


    public abstract boolean call(IDevice device) throws Exception;


    public Callable<Boolean> forDevice(final IDevice device) {
      return new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
          return AdbCallable.this.call(device);
        }
        @Override
        public String toString() {
          return AdbCallable.this.toString();
        }
      };
    }
  }


  private abstract static class ErrorParsingReceiver extends MultiLineReceiver {

    @Nullable
    private String errorMessage = null;


    @Nullable
    protected abstract String matchForError(String line);


    protected boolean matchForSuccess(String line) {
      return false;
    }

    @Override
    public void processNewLines(String[] lines) {
        for (String line : lines) {
            if (line.length() > 0) {
                if (matchForSuccess(line)) {
                    errorMessage = null;
                } else {
                    String err = matchForError(line);
                    if (err != null) {
                      errorMessage = err;
                    }
                }
            }
        }
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Nullable
    public String getErrorMessage() {
       return errorMessage;
    }
  }


  @SuppressWarnings("serial")
  public static class CommandFailedException extends IOException {
    public final String command;
    public final int exitCode;
    public final String output;
    public CommandFailedException(String command, int exitCode, String output) {
      super("Command '" + command + "' failed with code " + exitCode + ".  Output:\n" + output);
      this.command = command;
      this.exitCode = exitCode;
      this.output = output;
    }
  }


  public static String executeCommandWithErrorChecking(IDevice device, String command)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(command + ECHO_COMMAND_SUFFIX, receiver);
    String realOutput = checkReceiverOutput(command, receiver);
    return realOutput;
  }


  public static String checkReceiverOutput(
      String command,
      CollectingOutputReceiver receiver) throws CommandFailedException {
    String fullOutput = receiver.getOutput();
    int colon = fullOutput.lastIndexOf(':');
    String realOutput = fullOutput.substring(0, colon);
    String exitCodeStr = fullOutput.substring(colon + 1);
    int exitCode = Integer.parseInt(exitCodeStr);
    if (exitCode != 0) {
      throw new CommandFailedException(command, exitCode, realOutput);
    }
    return realOutput;
  }


  public boolean installApk(
      InstallableApk installableApk,
      final boolean installViaSd) throws InterruptedException {
    getBuckEventBus().post(InstallEvent.started(installableApk.getBuildTarget()));

    final File apk = installableApk.getApkPath().toFile();
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            return installApkOnDevice(device, apk, installViaSd);
          }

          @Override
          public String toString() {
            return "install apk";
          }
        });
    getBuckEventBus().post(InstallEvent.finished(installableApk.getBuildTarget(), success));

    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  public boolean installApkOnDevice(IDevice device, File apk, boolean installViaSd) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    if (!isDeviceTempWritable(device, name)) {
      return false;
    }

    getBuckEventBus().post(ConsoleEvent.info("Installing apk on %s.", name));
    try {
      String reason = null;
      if (installViaSd) {
        reason = deviceInstallPackageViaSd(device, apk.getAbsolutePath());
      } else {
        reason = device.installPackage(apk.getAbsolutePath(), true);
      }
      if (reason != null) {
        console.printBuildFailure(String.format("Failed to install apk on %s: %s.", name, reason));
        return false;
      }
      return true;
    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to install apk on %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }

  @VisibleForTesting
  protected boolean isDeviceTempWritable(IDevice device, String name) {
    StringBuilder loggingInfo = new StringBuilder();
    try {
      String output = null;

      try {
        output = executeCommandWithErrorChecking(device, "ls -l -d /data/local/tmp");
        if (!(

            output.matches("\\Adrwx....-x +shell +shell.* tmp[\\r\\n]*\\z") ||

            output.matches("\\Adrwx....-x +[0-9]+ +shell +shell.* /data/local/tmp[\\r\\n]*\\z"))) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad ls output for /data/local/tmp: '%s'\n",
                  output));
        }

        executeCommandWithErrorChecking(device, "echo exo > /data/local/tmp/buck-experiment");
        output = executeCommandWithErrorChecking(device, "cat /data/local/tmp/buck-experiment");
        if (!output.matches("\\Aexo[\\r\\n]*\\z")) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad echo/cat output for /data/local/tmp: '%s'\n",
                  output));
        }
        executeCommandWithErrorChecking(device, "rm /data/local/tmp/buck-experiment");

      } catch (CommandFailedException e) {
        loggingInfo.append(
            String.format(
                java.util.Locale.ENGLISH,
                "Failed (%d) '%s':\n%s\n",
                e.exitCode,
                e.command,
                e.output));
      }

      if (!loggingInfo.toString().isEmpty()) {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("getprop", receiver);
        for (String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
          if (line.contains("ro.product.model") || line.contains("ro.build.description")) {
            loggingInfo.append(line).append('\n');
          }
        }
      }

    } catch (
        AdbCommandRejectedException |
            ShellCommandUnresponsiveException |
            TimeoutException |
            IOException e) {
      console.printBuildFailure(String.format("Failed to test /data/local/tmp on %s.", name));
      e.printStackTrace(console.getStdErr());
      return false;
    }
    String logMessage = loggingInfo.toString();
    if (!logMessage.isEmpty()) {
      StringBuilder fullMessage = new StringBuilder();
      fullMessage.append("============================================================\n");
      fullMessage.append('\n');
      fullMessage.append("HEY! LISTEN!\n");
      fullMessage.append('\n');
      fullMessage.append("The /data/local/tmp directory on your device isn't fully-functional.\n");
      fullMessage.append("Here's some extra info:\n");
      fullMessage.append(logMessage);
      fullMessage.append("============================================================\n");
      console.getStdErr().println(fullMessage.toString());
    }

    return true;
  }


  private String deviceInstallPackageViaSd(IDevice device, String apk) {
    try {

      String externalStorage = deviceGetExternalStorage(device);
      if (externalStorage == null) {
        return "Cannot get external storage location.";
      }
      String remotePackage = String.format("%s/%s.apk", externalStorage, UUID.randomUUID());

      device.pushFile(apk, remotePackage);

      String reason = device.installRemotePackage(remotePackage, true);

      device.removeRemotePackage(remotePackage);
      return reason;
    } catch (Throwable t) {
      return String.valueOf(t.getMessage());
    }
  }


  @Nullable
  private String deviceGetExternalStorage(IDevice device) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(
        "echo $EXTERNAL_STORAGE",
        receiver,
        AdbHelper.GETPROP_TIMEOUT,
        TimeUnit.MILLISECONDS);
    String value = receiver.getOutput().trim();
    if (value.isEmpty()) {
      return null;
    }
    return value;
  }

  public int startActivity(
      InstallableApk installableApk,
      @Nullable String activity) throws IOException, InterruptedException {


    Path pathToManifest = installableApk.getManifestPath();
    AndroidManifestReader reader = DefaultAndroidManifestReader.forPath(
        pathToManifest, context.getProjectFilesystem());

    if (activity == null) {

      List<String> launcherActivities = reader.getLauncherActivities();


      if (launcherActivities.isEmpty()) {
        console.printBuildFailure("No launchable activities found.");
        return 1;
      } else if (launcherActivities.size() > 1) {
        console.printBuildFailure("Default activity is ambiguous.");
        return 1;
      }


      activity = reader.getPackage() + "/" + launcherActivities.get(0);
    } else if (!activity.contains("/")) {

      activity = reader.getPackage() + "/" + activity;
    }

    final String activityToRun = activity;

    PrintStream stdOut = console.getStdOut();
    stdOut.println(String.format("Starting activity %s...", activityToRun));

    getBuckEventBus().post(StartActivityEvent.started(installableApk.getBuildTarget(),
        activityToRun));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            String err = deviceStartActivity(device, activityToRun);
            if (err != null) {
              console.printBuildFailure(err);
              return false;
            } else {
              return true;
            }
          }

          @Override
          public String toString() {
            return "start activity";
          }
        });
    getBuckEventBus().post(StartActivityEvent.finished(installableApk.getBuildTarget(),
        activityToRun,
        success));

    return success ? 0 : 1;

  }

  @VisibleForTesting
  @Nullable
  String deviceStartActivity(IDevice device, String activityToRun) {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {

          return (Pattern.matches("^([\\w_$.])*(Exception|Error|error).*$", line) ||
              line.contains("am: not found")) ? line : null;
        }
      };
      device.executeShellCommand(
          String.format("am start -n %s", activityToRun),
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (Exception e) {
      return e.toString();
    }
  }


  public boolean uninstallApp(
      final String packageName,
      final boolean shouldKeepUserData) throws InterruptedException {
    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    getBuckEventBus().post(UninstallEvent.started(packageName));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
      @Override
      public boolean call(IDevice device) throws Exception {

        device.executeShellCommand("rm -r /data/local/tmp/exopackage/" + packageName,
            NullOutputReceiver.getReceiver());
        return uninstallApkFromDevice(device, packageName, shouldKeepUserData);
      }

      @Override
      public String toString() {
        return "uninstall apk";
      }
    });
    getBuckEventBus().post(UninstallEvent.finished(packageName, success));
    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  private boolean uninstallApkFromDevice(IDevice device, String packageName, boolean keepData) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    PrintStream stdOut = console.getStdOut();
    stdOut.printf("Removing apk from %s.\n", name);
    try {
      long start = System.currentTimeMillis();
      String reason = deviceUninstallPackage(device, packageName, keepData);
      long end = System.currentTimeMillis();

      if (reason != null) {
        console.printBuildFailure(
            String.format("Failed to uninstall apk from %s: %s.", name, reason));
        return false;
      }

      long delta = end - start;
      stdOut.printf("Uninstalled apk from %s in %d.%03ds.\n", name, delta / 1000, delta % 1000);
      return true;

    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to uninstall apk from %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }


  @Nullable
  private String deviceUninstallPackage(IDevice device,
      String packageName,
      boolean keepData) throws InstallException {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {
          return line.toLowerCase().contains("failure") ? line : null;
        }
      };
      device.executeShellCommand(
          "pm uninstall " + (keepData ? "-k " : "") + packageName,
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (TimeoutException e) {
      throw new InstallException(e);
    } catch (AdbCommandRejectedException e) {
      throw new InstallException(e);
    } catch (ShellCommandUnresponsiveException e) {
      throw new InstallException(e);
    } catch (IOException e) {
      throw new InstallException(e);
    }
  }

  public static String tryToExtractPackageNameFromManifest(
      InstallableApk androidBinaryRule,
      ExecutionContext context) {
    Path pathToManifest = androidBinaryRule.getManifestPath();



    if (!Files.isRegularFile(pathToManifest)) {
      throw new HumanReadableException(
          "Manifest file %s does not exist, so could not extract package name.",
          pathToManifest);
    }

    try {
      return DefaultAndroidManifestReader.forPath(pathToManifest, context.getProjectFilesystem())
          .getPackage();
    } catch (IOException e) {
      throw new HumanReadableException("Could not extract package name from %s", pathToManifest);
    }
  }
}

<code block>


package com.facebook.buck.android;

import static com.facebook.buck.util.concurrent.MoreExecutors.newMultiThreadExecutor;
import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.AndroidDebugBridge;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.MultiLineReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.TimeoutException;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.InterruptionFailedException;
import com.facebook.buck.util.TriState;
import com.facebook.buck.util.concurrent.MoreExecutors;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class AdbHelper {

  private static final long ADB_CONNECT_TIMEOUT_MS = 5000;
  private static final long ADB_CONNECT_TIME_STEP_MS = ADB_CONNECT_TIMEOUT_MS / 10;


  public static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile("[\\w.-]+");


  static final String SERIAL_NUMBER_ENV = "ANDROID_SERIAL";


  public static final long INSTALL_TIMEOUT = 2 * 60 * 1000; 
  public static final long GETPROP_TIMEOUT = 2 * 1000; 

  public static final String ECHO_COMMAND_SUFFIX = " ; echo -n :$?";

  private final AdbOptions options;
  private final TargetDeviceOptions deviceOptions;
  private final ExecutionContext context;
  private final Console console;
  private final BuckEventBus buckEventBus;
  private final boolean restartAdbOnFailure;

  public AdbHelper(
      AdbOptions adbOptions,
      TargetDeviceOptions deviceOptions,
      ExecutionContext context,
      Console console,
      BuckEventBus buckEventBus,
      boolean restartAdbOnFailure) {
    this.options = adbOptions;
    this.deviceOptions = deviceOptions;
    this.context = context;
    this.console = console;
    this.buckEventBus = buckEventBus;
    this.restartAdbOnFailure = restartAdbOnFailure;
  }

  private BuckEventBus getBuckEventBus() {
    return buckEventBus;
  }


  @Nullable
  @VisibleForTesting
  List<IDevice> filterDevices(IDevice[] allDevices) {
    if (allDevices.length == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    List<IDevice> devices = Lists.newArrayList();
    TriState emulatorsOnly = TriState.UNSPECIFIED;
    if (deviceOptions.isEmulatorsOnlyModeEnabled() && options.isMultiInstallModeEnabled()) {
      emulatorsOnly = TriState.UNSPECIFIED;
    } else if (deviceOptions.isEmulatorsOnlyModeEnabled()) {
      emulatorsOnly = TriState.TRUE;
    } else if (deviceOptions.isRealDevicesOnlyModeEnabled()) {
      emulatorsOnly = TriState.FALSE;
    }

    int onlineDevices = 0;
    for (IDevice device : allDevices) {
      boolean passed = false;
      if (device.isOnline()) {
        onlineDevices++;

        boolean serialMatches = true;
        if (deviceOptions.hasSerialNumber()) {
          serialMatches = device.getSerialNumber().equals(deviceOptions.getSerialNumber());
        } else if (context.getEnvironment().containsKey(SERIAL_NUMBER_ENV)) {
          serialMatches = device.getSerialNumber().equals(
              context.getEnvironment().get(SERIAL_NUMBER_ENV));
        }

        boolean deviceTypeMatches;
        if (emulatorsOnly.isSet()) {


          deviceTypeMatches = (emulatorsOnly.asBoolean() == device.isEmulator());
        } else {

          deviceTypeMatches = true;
        }
        passed = serialMatches && deviceTypeMatches;
      }

      if (passed) {
        devices.add(device);
      }
    }


    if (onlineDevices == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    if (devices.isEmpty()) {
      console.printBuildFailure(String.format(
          "Found %d connected device(s), but none of them matches specified filter.",
          onlineDevices));
      return null;
    }


    if (!options.isMultiInstallModeEnabled() && devices.size() > 1) {
      console.printBuildFailure(
          String.format("%d device(s) matches specified device filter (1 expected).\n" +
                        "Either disconnect other devices or enable multi-install mode (%s).",
                         devices.size(), AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG));
      return null;
    }


    if (devices.size() > 1) {
      console.getStdOut().printf("Found " + devices.size() + " matching devices.\n");
    }
    return devices;
  }

  private boolean isAdbInitialized(AndroidDebugBridge adb) {
    return adb.isConnected() && adb.hasInitialDeviceList();
  }


  @Nullable
  @SuppressWarnings("PMD.EmptyCatchBlock")
  private AndroidDebugBridge createAdb(ExecutionContext context) throws InterruptedException {
    try {
      AndroidDebugBridge.init( false);
    } catch (IllegalStateException ex) {

    }

    AndroidDebugBridge adb =
        AndroidDebugBridge.createBridge(context.getPathToAdbExecutable(), false);
    if (adb == null) {
      console.printBuildFailure("Failed to connect to adb. Make sure adb server is running.");
      return null;
    }

    long start = System.currentTimeMillis();
    while (!isAdbInitialized(adb)) {
      long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();
      if (timeLeft <= 0) {
        break;
      }
      Thread.sleep(ADB_CONNECT_TIME_STEP_MS);
    }
    return isAdbInitialized(adb) ? adb : null;
  }

  @Nullable
  public List<IDevice> getDevices() throws InterruptedException {

    AndroidDebugBridge adb = createAdb(context);
    if (adb == null) {
      console.printBuildFailure("Failed to create adb connection.");
      return null;
    }


    List<IDevice> devices = filterDevices(adb.getDevices());
    if (devices == null && restartAdbOnFailure) {
      console.printErrorText("No devices found with adb, restarting adb-server.");
      adb.restart();
      devices = filterDevices(adb.getDevices());
    }
    return devices;
  }


  @SuppressWarnings("PMD.EmptyCatchBlock")
  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {
    List<IDevice> devices;

    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, "set_up_adb_call")) {
      devices = getDevices();
      if (devices == null) {
        return false;
      }
    }

    int adbThreadCount = options.getAdbThreadCount();
    if (adbThreadCount <= 0) {
      adbThreadCount = devices.size();
    }


    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();
    ListeningExecutorService executorService =
        listeningDecorator(
            newMultiThreadExecutor(
                new CommandThreadFactory(getClass().getSimpleName()),
                adbThreadCount));

    for (final IDevice device : devices) {
      futures.add(executorService.submit(adbCallable.forDevice(device)));
    }


    List<Boolean> results = null;
    try {
      results = Futures.allAsList(futures).get();
    } catch (ExecutionException ex) {
      console.printBuildFailure("Failed: " + adbCallable);
      ex.printStackTrace(console.getStdErr());
      return false;
    } catch (InterruptedException e) {
      try {
        Futures.allAsList(futures).cancel(true);
      } catch (CancellationException ignored) {

      }
      Thread.currentThread().interrupt();
      throw e;
    } finally {
      MoreExecutors.shutdownOrThrow(
          executorService,
          10,
          TimeUnit.MINUTES,
          new InterruptionFailedException("Failed to shutdown ExecutorService."));
    }

    int successCount = 0;
    for (Boolean result : results) {
      if (result) {
        successCount++;
      }
    }
    int failureCount = results.size() - successCount;


    if (successCount > 0) {
      console.printSuccess(
          String.format("Successfully ran %s on %d device(s)", adbCallable, successCount));
    }
    if (failureCount > 0) {
      console.printBuildFailure(
          String.format("Failed to %s on %d device(s).", adbCallable, failureCount));
    }

    return failureCount == 0;
  }


  public abstract static class AdbCallable {


    public abstract boolean call(IDevice device) throws Exception;


    public Callable<Boolean> forDevice(final IDevice device) {
      return new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
          return AdbCallable.this.call(device);
        }
        @Override
        public String toString() {
          return AdbCallable.this.toString();
        }
      };
    }
  }


  private abstract static class ErrorParsingReceiver extends MultiLineReceiver {

    @Nullable
    private String errorMessage = null;


    @Nullable
    protected abstract String matchForError(String line);


    protected boolean matchForSuccess(String line) {
      return false;
    }

    @Override
    public void processNewLines(String[] lines) {
        for (String line : lines) {
            if (line.length() > 0) {
                if (matchForSuccess(line)) {
                    errorMessage = null;
                } else {
                    String err = matchForError(line);
                    if (err != null) {
                      errorMessage = err;
                    }
                }
            }
        }
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Nullable
    public String getErrorMessage() {
       return errorMessage;
    }
  }


  @SuppressWarnings("serial")
  public static class CommandFailedException extends IOException {
    public final String command;
    public final int exitCode;
    public final String output;
    public CommandFailedException(String command, int exitCode, String output) {
      super("Command '" + command + "' failed with code " + exitCode + ".  Output:\n" + output);
      this.command = command;
      this.exitCode = exitCode;
      this.output = output;
    }
  }


  public static String executeCommandWithErrorChecking(IDevice device, String command)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(command + ECHO_COMMAND_SUFFIX, receiver);
    String realOutput = checkReceiverOutput(command, receiver);
    return realOutput;
  }


  public static String checkReceiverOutput(
      String command,
      CollectingOutputReceiver receiver) throws CommandFailedException {
    String fullOutput = receiver.getOutput();
    int colon = fullOutput.lastIndexOf(':');
    String realOutput = fullOutput.substring(0, colon);
    String exitCodeStr = fullOutput.substring(colon + 1);
    int exitCode = Integer.parseInt(exitCodeStr);
    if (exitCode != 0) {
      throw new CommandFailedException(command, exitCode, realOutput);
    }
    return realOutput;
  }


  public boolean installApk(
      InstallableApk installableApk,
      final boolean installViaSd) throws InterruptedException {
    getBuckEventBus().post(InstallEvent.started(installableApk.getBuildTarget()));

    final File apk = installableApk.getApkPath().toFile();
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            return installApkOnDevice(device, apk, installViaSd);
          }

          @Override
          public String toString() {
            return "install apk";
          }
        });
    getBuckEventBus().post(InstallEvent.finished(installableApk.getBuildTarget(), success));

    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  public boolean installApkOnDevice(IDevice device, File apk, boolean installViaSd) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    if (!isDeviceTempWritable(device, name)) {
      return false;
    }

    getBuckEventBus().post(ConsoleEvent.info("Installing apk on %s.", name));
    try {
      String reason = null;
      if (installViaSd) {
        reason = deviceInstallPackageViaSd(device, apk.getAbsolutePath());
      } else {
        reason = device.installPackage(apk.getAbsolutePath(), true);
      }
      if (reason != null) {
        console.printBuildFailure(String.format("Failed to install apk on %s: %s.", name, reason));
        return false;
      }
      return true;
    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to install apk on %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }

  @VisibleForTesting
  protected boolean isDeviceTempWritable(IDevice device, String name) {
    StringBuilder loggingInfo = new StringBuilder();
    try {
      String output = null;

      try {
        output = executeCommandWithErrorChecking(device, "ls -l -d /data/local/tmp");
        if (!(

            output.matches("\\Adrwx....-x +shell +shell.* tmp[\\r\\n]*\\z") ||

            output.matches("\\Adrwx....-x +[0-9]+ +shell +shell.* /data/local/tmp[\\r\\n]*\\z"))) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad ls output for /data/local/tmp: '%s'\n",
                  output));
        }

        executeCommandWithErrorChecking(device, "echo exo > /data/local/tmp/buck-experiment");
        output = executeCommandWithErrorChecking(device, "cat /data/local/tmp/buck-experiment");
        if (!output.matches("\\Aexo[\\r\\n]*\\z")) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad echo/cat output for /data/local/tmp: '%s'\n",
                  output));
        }
        executeCommandWithErrorChecking(device, "rm /data/local/tmp/buck-experiment");

      } catch (CommandFailedException e) {
        loggingInfo.append(
            String.format(
                java.util.Locale.ENGLISH,
                "Failed (%d) '%s':\n%s\n",
                e.exitCode,
                e.command,
                e.output));
      }

      if (!loggingInfo.toString().isEmpty()) {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("getprop", receiver);
        for (String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
          if (line.contains("ro.product.model") || line.contains("ro.build.description")) {
            loggingInfo.append(line).append('\n');
          }
        }
      }

    } catch (
        AdbCommandRejectedException |
            ShellCommandUnresponsiveException |
            TimeoutException |
            IOException e) {
      console.printBuildFailure(String.format("Failed to test /data/local/tmp on %s.", name));
      e.printStackTrace(console.getStdErr());
      return false;
    }
    String logMessage = loggingInfo.toString();
    if (!logMessage.isEmpty()) {
      StringBuilder fullMessage = new StringBuilder();
      fullMessage.append("============================================================\n");
      fullMessage.append('\n');
      fullMessage.append("HEY! LISTEN!\n");
      fullMessage.append('\n');
      fullMessage.append("The /data/local/tmp directory on your device isn't fully-functional.\n");
      fullMessage.append("Here's some extra info:\n");
      fullMessage.append(logMessage);
      fullMessage.append("============================================================\n");
      console.getStdErr().println(fullMessage.toString());
    }

    return true;
  }


  private String deviceInstallPackageViaSd(IDevice device, String apk) {
    try {

      String externalStorage = deviceGetExternalStorage(device);
      if (externalStorage == null) {
        return "Cannot get external storage location.";
      }
      String remotePackage = String.format("%s/%s.apk", externalStorage, UUID.randomUUID());

      device.pushFile(apk, remotePackage);

      String reason = device.installRemotePackage(remotePackage, true);

      device.removeRemotePackage(remotePackage);
      return reason;
    } catch (Throwable t) {
      return String.valueOf(t.getMessage());
    }
  }


  @Nullable
  private String deviceGetExternalStorage(IDevice device) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(
        "echo $EXTERNAL_STORAGE",
        receiver,
        AdbHelper.GETPROP_TIMEOUT,
        TimeUnit.MILLISECONDS);
    String value = receiver.getOutput().trim();
    if (value.isEmpty()) {
      return null;
    }
    return value;
  }

  public int startActivity(
      InstallableApk installableApk,
      @Nullable String activity) throws IOException, InterruptedException {


    Path pathToManifest = installableApk.getManifestPath();
    AndroidManifestReader reader = DefaultAndroidManifestReader.forPath(
        pathToManifest, context.getProjectFilesystem());

    if (activity == null) {

      List<String> launcherActivities = reader.getLauncherActivities();


      if (launcherActivities.isEmpty()) {
        console.printBuildFailure("No launchable activities found.");
        return 1;
      } else if (launcherActivities.size() > 1) {
        console.printBuildFailure("Default activity is ambiguous.");
        return 1;
      }


      activity = reader.getPackage() + "/" + launcherActivities.get(0);
    } else if (!activity.contains("/")) {

      activity = reader.getPackage() + "/" + activity;
    }

    final String activityToRun = activity;

    PrintStream stdOut = console.getStdOut();
    stdOut.println(String.format("Starting activity %s...", activityToRun));

    getBuckEventBus().post(StartActivityEvent.started(installableApk.getBuildTarget(),
        activityToRun));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            String err = deviceStartActivity(device, activityToRun);
            if (err != null) {
              console.printBuildFailure(err);
              return false;
            } else {
              return true;
            }
          }

          @Override
          public String toString() {
            return "start activity";
          }
        });
    getBuckEventBus().post(StartActivityEvent.finished(installableApk.getBuildTarget(),
        activityToRun,
        success));

    return success ? 0 : 1;

  }

  @VisibleForTesting
  @Nullable
  String deviceStartActivity(IDevice device, String activityToRun) {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {

          return (Pattern.matches("^([\\w_$.])*(Exception|Error|error).*$", line) ||
              line.contains("am: not found")) ? line : null;
        }
      };
      device.executeShellCommand(
          String.format("am start -n %s", activityToRun),
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (Exception e) {
      return e.toString();
    }
  }


  public boolean uninstallApp(
      final String packageName,
      final boolean shouldKeepUserData) throws InterruptedException {
    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    getBuckEventBus().post(UninstallEvent.started(packageName));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
      @Override
      public boolean call(IDevice device) throws Exception {

        device.executeShellCommand("rm -r /data/local/tmp/exopackage/" + packageName,
            NullOutputReceiver.getReceiver());
        return uninstallApkFromDevice(device, packageName, shouldKeepUserData);
      }

      @Override
      public String toString() {
        return "uninstall apk";
      }
    });
    getBuckEventBus().post(UninstallEvent.finished(packageName, success));
    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  private boolean uninstallApkFromDevice(IDevice device, String packageName, boolean keepData) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    PrintStream stdOut = console.getStdOut();
    stdOut.printf("Removing apk from %s.\n", name);
    try {
      long start = System.currentTimeMillis();
      String reason = deviceUninstallPackage(device, packageName, keepData);
      long end = System.currentTimeMillis();

      if (reason != null) {
        console.printBuildFailure(
            String.format("Failed to uninstall apk from %s: %s.", name, reason));
        return false;
      }

      long delta = end - start;
      stdOut.printf("Uninstalled apk from %s in %d.%03ds.\n", name, delta / 1000, delta % 1000);
      return true;

    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to uninstall apk from %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }


  @Nullable
  private String deviceUninstallPackage(IDevice device,
      String packageName,
      boolean keepData) throws InstallException {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {
          return line.toLowerCase().contains("failure") ? line : null;
        }
      };
      device.executeShellCommand(
          "pm uninstall " + (keepData ? "-k " : "") + packageName,
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (TimeoutException e) {
      throw new InstallException(e);
    } catch (AdbCommandRejectedException e) {
      throw new InstallException(e);
    } catch (ShellCommandUnresponsiveException e) {
      throw new InstallException(e);
    } catch (IOException e) {
      throw new InstallException(e);
    }
  }

  public static String tryToExtractPackageNameFromManifest(
      InstallableApk androidBinaryRule,
      ExecutionContext context) {
    Path pathToManifest = androidBinaryRule.getManifestPath();



    if (!Files.isRegularFile(pathToManifest)) {
      throw new HumanReadableException(
          "Manifest file %s does not exist, so could not extract package name.",
          pathToManifest);
    }

    try {
      return DefaultAndroidManifestReader.forPath(pathToManifest, context.getProjectFilesystem())
          .getPackage();
    } catch (IOException e) {
      throw new HumanReadableException("Could not extract package name from %s", pathToManifest);
    }
  }
}

<code block>


package com.facebook.buck.util;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nullable;


public final class ClassLoaderCache implements AutoCloseable {

  private static final Function<Path, URL> PATH_TO_URL = new Function<Path, URL>() {
      @Override
      public URL apply(Path p) {
        try {
          return p.toUri().toURL();
        } catch (MalformedURLException e) {
          throw new RuntimeException(e);
        }
      }
    };

  private final Map<ClassLoader, Map<ImmutableList<Path>, ClassLoader>> cache = new HashMap<>();

  private int referenceCount = 1;

  private synchronized Map<ImmutableList<Path>, ClassLoader> getCacheForParent(
      @Nullable ClassLoader parentClassLoader) {
    Map<ImmutableList<Path>, ClassLoader> cacheForParent =
        cache.get(parentClassLoader);

    if (cacheForParent == null) {
      cacheForParent = new HashMap<>();
      cache.put(parentClassLoader, cacheForParent);
    }

    return cacheForParent;
  }

  public synchronized ClassLoader getClassLoaderForClassPath(
      @Nullable ClassLoader parentClassLoader,
      ImmutableList<Path> classPath) {

    Map<ImmutableList<Path>, ClassLoader> cacheForParent =
        getCacheForParent(parentClassLoader);

    ClassLoader classLoader = cacheForParent.get(classPath);
    if (classLoader == null) {
      URL[] urls = FluentIterable.from(classPath)
          .transform(PATH_TO_URL)
          .toArray(URL.class);
      classLoader = new URLClassLoader(urls, parentClassLoader);
      cacheForParent.put(classPath, classLoader);
    }

    return classLoader;
  }

  @VisibleForTesting
  public synchronized void injectClassLoader(
      @Nullable ClassLoader parentClassLoader,
      ImmutableList<Path> classPath,
      ClassLoader injectedClassLoader) {
    Map<ImmutableList<Path>, ClassLoader> cacheForParent =
        getCacheForParent(parentClassLoader);

    cacheForParent.put(classPath, injectedClassLoader);
  }

  public synchronized ClassLoaderCache addRef() {
    referenceCount += 1;
    return this;
  }

  @Override
  public synchronized void close() throws IOException {
    if (referenceCount > 1) {
      referenceCount -= 1;
      return;
    }

    Optional<IOException> caughtEx = Optional.absent();

    for (Map<ImmutableList<Path>, ClassLoader> cacheForParent : cache.values()) {
      for (ClassLoader cl : cacheForParent.values()) {
        try {
          if (cl instanceof URLClassLoader) {
            ((URLClassLoader) cl).close();
          }
        } catch (IOException ex) {
          if (caughtEx.isPresent()) {
            caughtEx.get().addSuppressed(ex);
          } else {
            caughtEx = Optional.of(ex);
          }
        }
      }
    }

    if (caughtEx.isPresent()) {
      throw caughtEx.get();
    }
  }
}

<code block>


package com.facebook.buck.java;

import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.ClassLoaderCache;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.Ordering;

import java.nio.file.Path;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import javax.tools.JavaCompiler;

public class JarBackedJavac extends Jsr199Javac {

  private final String compilerClassName;
  private final Iterable<SourcePath> classpath;

  JarBackedJavac(String compilerClassName, Iterable<SourcePath> classpath) {
    this.compilerClassName = compilerClassName;
    this.classpath = classpath;
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder.setReflectively("javac", "jar-backed-jsr199")
        .setReflectively("javac.version", "in-memory")
        .setReflectively("javac.classname", compilerClassName)
        .setReflectively("javac.classpath", classpath);
  }

  @Override
  protected JavaCompiler createCompiler(
      ExecutionContext context,
      final SourcePathResolver resolver) {
    ClassLoaderCache classLoaderCache = context.getClassLoaderCache();
    ClassLoader compilerClassLoader = classLoaderCache.getClassLoaderForClassPath(
        ClassLoader.getSystemClassLoader(),
        FluentIterable.from(classpath)
            .transformAndConcat(
                new Function<SourcePath, Collection<Path>>() {
                  @Override
                  public Collection<Path> apply(SourcePath input) {
                    Set<Path> paths = new HashSet<>();
                    Optional<BuildRule> rule = resolver.getRule(input);
                    if (rule instanceof JavaLibrary) {
                      paths.addAll(((JavaLibrary) rule).getTransitiveClasspathEntries().values());
                    } else {
                      paths.add(resolver.getPath(input));
                    }
                    return paths;
                  }
                })
            .toSortedSet(Ordering.natural())
            .asList());
    try {
      return (JavaCompiler) compilerClassLoader.loadClass(compilerClassName).newInstance();
    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException ex) {
      throw new RuntimeException(ex);
    }
  }

  @VisibleForTesting
  Iterable<SourcePath> getCompilerClassPath() {
    return classpath;
  }
}

<code block>


package com.facebook.buck.util;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertSame;

import com.google.common.base.Function;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;

import org.junit.Test;

import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Path;
import java.nio.file.Paths;

public class ClassLoaderCacheTest {
  private static final String DUMMYDIR = "d7b9d9fd-1a83-4c76-8981-52deb0fa4d17";

  private static final Function<Path, URL> PATH_TO_URL = new Function<Path, URL>() {
      @Override
      public URL apply(Path p) {
        try {
          return p.toUri().toURL();
        } catch (MalformedURLException e) {
          throw new RuntimeException(e);
        }
      }
    };

  @Test
  public void cacheLoaderReturnsSameClassLoader() throws Exception {
    try (ClassLoaderCache clc = new ClassLoaderCache()) {
    ClassLoader dummyParent = ClassLoader.getSystemClassLoader();
    ImmutableList<Path> dummyClassPath = ImmutableList.of(
        Paths.get(DUMMYDIR, "foo"),
        Paths.get(DUMMYDIR, "bar"));
    ClassLoader cl1 = clc.getClassLoaderForClassPath(dummyParent, dummyClassPath);
    ClassLoader cl2 = clc.getClassLoaderForClassPath(dummyParent, dummyClassPath);


    assertSame(cl1, cl2);


    URL[] dummyUrls = FluentIterable.from(dummyClassPath)
        .transform(PATH_TO_URL)
        .toArray(URL.class);

    assertArrayEquals(
        dummyUrls,
        ((URLClassLoader) cl1).getURLs());
    }
  }
}

<code block>


package com.facebook.buck.java;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.util.MockClassLoader;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Locale;
import java.util.Set;

import javax.lang.model.SourceVersion;
import javax.tools.DiagnosticListener;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;

public class Jsr199JavacIntegrationTest {

  private static final SourcePathResolver PATH_RESOLVER =
      new SourcePathResolver(new BuildRuleResolver());
  public static final ImmutableSet<Path> SOURCE_PATHS = ImmutableSet.of(Paths.get("Example.java"));
  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  private Path pathToSrcsList;

  @Before
  public void setUp() {
    pathToSrcsList = Paths.get(tmp.getRoot().getPath(), "srcs_list");
  }

  @Test
  public void testGetDescription() throws IOException {
    Jsr199Javac javac = createJavac( false);
    String pathToOutputDir = new File(tmp.getRoot(), "out").getAbsolutePath();

    assertEquals(
        String.format("javac -source %s -target %s -g " +
            "-d %s " +
            "-classpath '' " +
            "@" + pathToSrcsList.toString(),
            JavaBuckConfig.TARGETED_JAVA_VERSION,
            JavaBuckConfig.TARGETED_JAVA_VERSION,
            pathToOutputDir),
        javac.getDescription(
            ImmutableList.of(
                "-source", JavaBuckConfig.TARGETED_JAVA_VERSION,
                "-target", JavaBuckConfig.TARGETED_JAVA_VERSION,
                "-g",
                "-d", pathToOutputDir,
                "-classpath", "''"),
            SOURCE_PATHS,
            Optional.of(pathToSrcsList)));
  }

  @Test
  public void testGetShortName() throws IOException {
    Jsr199Javac javac = createJavac( false);
    assertEquals("javac", javac.getShortName());
  }

  @Test
  public void testClassesFile() throws IOException, InterruptedException {
    Jsr199Javac javac = createJavac( false);
    ExecutionContext executionContext = createExecutionContext();
    int exitCode = javac.buildWithClasspath(
        executionContext,
        PATH_RESOLVER,
        BuildTargetFactory.newInstance("//some:example"),
        ImmutableList.<String>of(),
        SOURCE_PATHS,
        Optional.of(pathToSrcsList),
        Optional.<Path>absent());
    assertEquals("javac should exit with code 0.", exitCode, 0);

    File srcsListFile = pathToSrcsList.toFile();
    assertTrue(srcsListFile.exists());
    assertTrue(srcsListFile.isFile());
    assertEquals("Example.java", Files.toString(srcsListFile, Charsets.UTF_8).trim());
  }


  @Test
  public void shouldWriteResolvedBuildTargetSourcePathsToClassesFile()
      throws IOException, InterruptedException {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    BuildRule rule = new FakeBuildRule("//:fake", pathResolver);
    resolver.addToIndex(rule);

    Jsr199Javac javac = createJavac(
 false);
    ExecutionContext executionContext = createExecutionContext();
    int exitCode = javac.buildWithClasspath(
        executionContext,
        PATH_RESOLVER,
        BuildTargetFactory.newInstance("//some:example"),
        ImmutableList.<String>of(),
        SOURCE_PATHS,
        Optional.of(pathToSrcsList),
        Optional.<Path>absent());
    assertEquals("javac should exit with code 0.", exitCode, 0);

    File srcsListFile = pathToSrcsList.toFile();
    assertTrue(srcsListFile.exists());
    assertTrue(srcsListFile.isFile());
    assertEquals("Example.java", Files.toString(srcsListFile, Charsets.UTF_8).trim());
  }

  public static final class MockJavac implements JavaCompiler {

    public MockJavac() {
    }

    @Override
    public Set<SourceVersion> getSourceVersions() {
      return ImmutableSet.of(SourceVersion.RELEASE_7);
    }

    @Override
    public int run(
        InputStream in,
        OutputStream out,
        OutputStream err,
        String... arguments) {
      throw new UnsupportedOperationException("abcdef");
    }

    @Override
    public int isSupportedOption(String option) {
      return -1;
    }

    @Override
    public StandardJavaFileManager
    getStandardFileManager(
        DiagnosticListener<? super JavaFileObject> diagnosticListener,
        Locale locale,
        Charset charset) {
      throw new UnsupportedOperationException("abcdef");
    }

    @Override
    public CompilationTask getTask(
        Writer out,
        JavaFileManager fileManager,
        DiagnosticListener<? super JavaFileObject> diagnosticListener,
        Iterable<String> options,
        Iterable<String> classes,
        Iterable<? extends JavaFileObject> compilationUnits) {
      throw new UnsupportedOperationException("abcdef");
    }
  }

  @Test
  public void shouldUseSpecifiedJavacJar() throws Exception {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    BuildRule rule = new FakeBuildRule("//:fake", pathResolver);
    resolver.addToIndex(rule);

    Path fakeJavacJar = Paths.get("ae036e57-77a7-4356-a79c-0f85b1a3290d", "fakeJavac.jar");
    ExecutionContext executionContext = createExecutionContext();
    MockClassLoader mockClassLoader = new MockClassLoader(
        ClassLoader.getSystemClassLoader(),
        ImmutableMap.<String, Class<?>>of(
            "com.sun.tools.javac.api.JavacTool",
            MockJavac.class));
    executionContext.getClassLoaderCache().injectClassLoader(
        ClassLoader.getSystemClassLoader(),
        ImmutableList.of(fakeJavacJar),
        mockClassLoader);

    Jsr199Javac javac = createJavac(
 false,
        Optional.of(fakeJavacJar));

    boolean caught = false;

    try {
      javac.buildWithClasspath(
          executionContext,
          PATH_RESOLVER,
          BuildTargetFactory.newInstance("//some:example"),
          ImmutableList.<String>of(),
          SOURCE_PATHS,
          Optional.of(pathToSrcsList),
          Optional.<Path>absent());
      fail("Did not expect compilation to succeed");
    } catch (UnsupportedOperationException ex) {
      if (ex.toString().contains("abcdef")) {
        caught = true;
      }
    }

    assertTrue("mock Java compiler should throw", caught);
  }

  private Jsr199Javac createJavac(
      boolean withSyntaxError,
      Optional<Path> javacJar) throws IOException {

    File exampleJava = tmp.newFile("Example.java");
    Files.write(Joiner.on('\n').join(
            "package com.example;",
            "",
            "public class Example {" +
            (withSyntaxError ? "" : "}")
        ),
        exampleJava,
        Charsets.UTF_8);

    Path pathToOutputDirectory = Paths.get("out");
    tmp.newFolder(pathToOutputDirectory.toString());

    Optional<SourcePath> jar = javacJar.transform(
        SourcePaths.toSourcePath(new FakeProjectFilesystem()));
    if (jar.isPresent()) {
      return new JarBackedJavac("com.sun.tools.javac.api.JavacTool", ImmutableSet.of(jar.get()));
    }

    return new JdkProvidedInMemoryJavac();
  }

  private Jsr199Javac createJavac(boolean withSyntaxError) throws IOException {
    return createJavac(withSyntaxError, Optional.<Path>absent());
  }

  private ExecutionContext createExecutionContext() {
    return TestExecutionContext.newBuilder()
        .setProjectFilesystem(new ProjectFilesystem(tmp.getRootPath()))
        .build();
  }
}

<code block>


package com.facebook.buck.util;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;

import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nullable;


public final class ClassLoaderCache implements AutoCloseable {

  private final Map<ClassLoader, Map<ImmutableList<URL>, ClassLoader>> cache = new HashMap<>();

  private int referenceCount = 1;

  private synchronized Map<ImmutableList<URL>, ClassLoader> getCacheForParent(
      @Nullable ClassLoader parentClassLoader) {
    Map<ImmutableList<URL>, ClassLoader> cacheForParent =
        cache.get(parentClassLoader);

    if (cacheForParent == null) {
      cacheForParent = new HashMap<>();
      cache.put(parentClassLoader, cacheForParent);
    }

    return cacheForParent;
  }

  public synchronized ClassLoader getClassLoaderForClassPath(
      @Nullable ClassLoader parentClassLoader,
      ImmutableList<URL> classPath) {

    Map<ImmutableList<URL>, ClassLoader> cacheForParent =
        getCacheForParent(parentClassLoader);

    ClassLoader classLoader = cacheForParent.get(classPath);
    if (classLoader == null) {
      URL[] urls = classPath.toArray(new URL[classPath.size()]);
      classLoader = new URLClassLoader(urls, parentClassLoader);
      cacheForParent.put(classPath, classLoader);
    }

    return classLoader;
  }

  @VisibleForTesting
  public synchronized void injectClassLoader(
      @Nullable ClassLoader parentClassLoader,
      ImmutableList<URL> classPath,
      ClassLoader injectedClassLoader) {
    Map<ImmutableList<URL>, ClassLoader> cacheForParent =
        getCacheForParent(parentClassLoader);

    cacheForParent.put(classPath, injectedClassLoader);
  }

  public synchronized ClassLoaderCache addRef() {
    referenceCount += 1;
    return this;
  }

  @Override
  public synchronized void close() throws IOException {
    if (referenceCount > 1) {
      referenceCount -= 1;
      return;
    }

    Optional<IOException> caughtEx = Optional.absent();

    for (Map<ImmutableList<URL>, ClassLoader> cacheForParent : cache.values()) {
      for (ClassLoader cl : cacheForParent.values()) {
        try {
          if (cl instanceof URLClassLoader) {
            ((URLClassLoader) cl).close();
          }
        } catch (IOException ex) {
          if (caughtEx.isPresent()) {
            caughtEx.get().addSuppressed(ex);
          } else {
            caughtEx = Optional.of(ex);
          }
        }
      }
    }

    if (caughtEx.isPresent()) {
      throw caughtEx.get();
    }
  }
}

<code block>


package com.facebook.buck.java;

import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.ClassLoaderCache;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.Ordering;

import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Path;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import javax.tools.JavaCompiler;

public class JarBackedJavac extends Jsr199Javac {

  private static final Function<Path, URL> PATH_TO_URL = new Function<Path, URL>() {
    @Override
    public URL apply(Path p) {
      try {
        return p.toUri().toURL();
      } catch (MalformedURLException e) {
        throw new RuntimeException(e);
      }
    }
  };

  private final String compilerClassName;
  private final Iterable<SourcePath> classpath;

  JarBackedJavac(String compilerClassName, Iterable<SourcePath> classpath) {
    this.compilerClassName = compilerClassName;
    this.classpath = classpath;
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder.setReflectively("javac", "jar-backed-jsr199")
        .setReflectively("javac.version", "in-memory")
        .setReflectively("javac.classname", compilerClassName)
        .setReflectively("javac.classpath", classpath);
  }

  @Override
  protected JavaCompiler createCompiler(
      ExecutionContext context,
      final SourcePathResolver resolver) {
    ClassLoaderCache classLoaderCache = context.getClassLoaderCache();
    ClassLoader compilerClassLoader = classLoaderCache.getClassLoaderForClassPath(
        ClassLoader.getSystemClassLoader(),
        FluentIterable.from(classpath)
            .transformAndConcat(
                new Function<SourcePath, Collection<Path>>() {
                  @Override
                  public Collection<Path> apply(SourcePath input) {
                    Set<Path> paths = new HashSet<>();
                    Optional<BuildRule> rule = resolver.getRule(input);
                    if (rule instanceof JavaLibrary) {
                      paths.addAll(((JavaLibrary) rule).getTransitiveClasspathEntries().values());
                    } else {
                      paths.add(resolver.getPath(input));
                    }
                    return paths;
                  }
                })
            .transform(PATH_TO_URL)

            .toSortedSet(Ordering.usingToString())
            .asList());
    try {
      return (JavaCompiler) compilerClassLoader.loadClass(compilerClassName).newInstance();
    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException ex) {
      throw new RuntimeException(ex);
    }
  }

  @VisibleForTesting
  Iterable<SourcePath> getCompilerClassPath() {
    return classpath;
  }
}

<code block>


package com.facebook.buck.util;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertSame;

import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;

import org.junit.Test;

import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Paths;

public class ClassLoaderCacheTest {
  private static final String DUMMYDIR = "d7b9d9fd-1a83-4c76-8981-52deb0fa4d17";

  @Test
  public void cacheLoaderReturnsSameClassLoader() throws Exception {
    try (ClassLoaderCache clc = new ClassLoaderCache()) {
    ClassLoader dummyParent = ClassLoader.getSystemClassLoader();
    ImmutableList<URL> dummyClassPath = ImmutableList.of(
        Paths.get(DUMMYDIR, "foo").toUri().toURL(),
        Paths.get(DUMMYDIR, "bar").toUri().toURL());
    ClassLoader cl1 = clc.getClassLoaderForClassPath(dummyParent, dummyClassPath);
    ClassLoader cl2 = clc.getClassLoaderForClassPath(dummyParent, dummyClassPath);


    assertSame(cl1, cl2);


    URL[] dummyUrls = FluentIterable.from(dummyClassPath).toArray(URL.class);

    assertArrayEquals(
        dummyUrls,
        ((URLClassLoader) cl1).getURLs());
    }
  }
}

<code block>


package com.facebook.buck.java;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.util.MockClassLoader;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Locale;
import java.util.Set;

import javax.lang.model.SourceVersion;
import javax.tools.DiagnosticListener;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;

public class Jsr199JavacIntegrationTest {

  private static final SourcePathResolver PATH_RESOLVER =
      new SourcePathResolver(new BuildRuleResolver());
  public static final ImmutableSet<Path> SOURCE_PATHS = ImmutableSet.of(Paths.get("Example.java"));
  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  private Path pathToSrcsList;

  @Before
  public void setUp() {
    pathToSrcsList = Paths.get(tmp.getRoot().getPath(), "srcs_list");
  }

  @Test
  public void testGetDescription() throws IOException {
    Jsr199Javac javac = createJavac( false);
    String pathToOutputDir = new File(tmp.getRoot(), "out").getAbsolutePath();

    assertEquals(
        String.format("javac -source %s -target %s -g " +
            "-d %s " +
            "-classpath '' " +
            "@" + pathToSrcsList.toString(),
            JavaBuckConfig.TARGETED_JAVA_VERSION,
            JavaBuckConfig.TARGETED_JAVA_VERSION,
            pathToOutputDir),
        javac.getDescription(
            ImmutableList.of(
                "-source", JavaBuckConfig.TARGETED_JAVA_VERSION,
                "-target", JavaBuckConfig.TARGETED_JAVA_VERSION,
                "-g",
                "-d", pathToOutputDir,
                "-classpath", "''"),
            SOURCE_PATHS,
            Optional.of(pathToSrcsList)));
  }

  @Test
  public void testGetShortName() throws IOException {
    Jsr199Javac javac = createJavac( false);
    assertEquals("javac", javac.getShortName());
  }

  @Test
  public void testClassesFile() throws IOException, InterruptedException {
    Jsr199Javac javac = createJavac( false);
    ExecutionContext executionContext = createExecutionContext();
    int exitCode = javac.buildWithClasspath(
        executionContext,
        PATH_RESOLVER,
        BuildTargetFactory.newInstance("//some:example"),
        ImmutableList.<String>of(),
        SOURCE_PATHS,
        Optional.of(pathToSrcsList),
        Optional.<Path>absent());
    assertEquals("javac should exit with code 0.", exitCode, 0);

    File srcsListFile = pathToSrcsList.toFile();
    assertTrue(srcsListFile.exists());
    assertTrue(srcsListFile.isFile());
    assertEquals("Example.java", Files.toString(srcsListFile, Charsets.UTF_8).trim());
  }


  @Test
  public void shouldWriteResolvedBuildTargetSourcePathsToClassesFile()
      throws IOException, InterruptedException {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    BuildRule rule = new FakeBuildRule("//:fake", pathResolver);
    resolver.addToIndex(rule);

    Jsr199Javac javac = createJavac(
 false);
    ExecutionContext executionContext = createExecutionContext();
    int exitCode = javac.buildWithClasspath(
        executionContext,
        PATH_RESOLVER,
        BuildTargetFactory.newInstance("//some:example"),
        ImmutableList.<String>of(),
        SOURCE_PATHS,
        Optional.of(pathToSrcsList),
        Optional.<Path>absent());
    assertEquals("javac should exit with code 0.", exitCode, 0);

    File srcsListFile = pathToSrcsList.toFile();
    assertTrue(srcsListFile.exists());
    assertTrue(srcsListFile.isFile());
    assertEquals("Example.java", Files.toString(srcsListFile, Charsets.UTF_8).trim());
  }

  public static final class MockJavac implements JavaCompiler {

    public MockJavac() {
    }

    @Override
    public Set<SourceVersion> getSourceVersions() {
      return ImmutableSet.of(SourceVersion.RELEASE_7);
    }

    @Override
    public int run(
        InputStream in,
        OutputStream out,
        OutputStream err,
        String... arguments) {
      throw new UnsupportedOperationException("abcdef");
    }

    @Override
    public int isSupportedOption(String option) {
      return -1;
    }

    @Override
    public StandardJavaFileManager
    getStandardFileManager(
        DiagnosticListener<? super JavaFileObject> diagnosticListener,
        Locale locale,
        Charset charset) {
      throw new UnsupportedOperationException("abcdef");
    }

    @Override
    public CompilationTask getTask(
        Writer out,
        JavaFileManager fileManager,
        DiagnosticListener<? super JavaFileObject> diagnosticListener,
        Iterable<String> options,
        Iterable<String> classes,
        Iterable<? extends JavaFileObject> compilationUnits) {
      throw new UnsupportedOperationException("abcdef");
    }
  }

  @Test
  public void shouldUseSpecifiedJavacJar() throws Exception {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    BuildRule rule = new FakeBuildRule("//:fake", pathResolver);
    resolver.addToIndex(rule);

    Path fakeJavacJar = Paths.get("ae036e57-77a7-4356-a79c-0f85b1a3290d", "fakeJavac.jar");
    ExecutionContext executionContext = createExecutionContext();
    MockClassLoader mockClassLoader = new MockClassLoader(
        ClassLoader.getSystemClassLoader(),
        ImmutableMap.<String, Class<?>>of(
            "com.sun.tools.javac.api.JavacTool",
            MockJavac.class));
    executionContext.getClassLoaderCache().injectClassLoader(
        ClassLoader.getSystemClassLoader(),
        ImmutableList.of(fakeJavacJar.toUri().toURL()),
        mockClassLoader);

    Jsr199Javac javac = createJavac(
 false,
        Optional.of(fakeJavacJar));

    boolean caught = false;

    try {
      javac.buildWithClasspath(
          executionContext,
          PATH_RESOLVER,
          BuildTargetFactory.newInstance("//some:example"),
          ImmutableList.<String>of(),
          SOURCE_PATHS,
          Optional.of(pathToSrcsList),
          Optional.<Path>absent());
      fail("Did not expect compilation to succeed");
    } catch (UnsupportedOperationException ex) {
      if (ex.toString().contains("abcdef")) {
        caught = true;
      }
    }

    assertTrue("mock Java compiler should throw", caught);
  }

  private Jsr199Javac createJavac(
      boolean withSyntaxError,
      Optional<Path> javacJar) throws IOException {

    File exampleJava = tmp.newFile("Example.java");
    Files.write(Joiner.on('\n').join(
            "package com.example;",
            "",
            "public class Example {" +
            (withSyntaxError ? "" : "}")
        ),
        exampleJava,
        Charsets.UTF_8);

    Path pathToOutputDirectory = Paths.get("out");
    tmp.newFolder(pathToOutputDirectory.toString());

    Optional<SourcePath> jar = javacJar.transform(
        SourcePaths.toSourcePath(new FakeProjectFilesystem()));
    if (jar.isPresent()) {
      return new JarBackedJavac("com.sun.tools.javac.api.JavacTool", ImmutableSet.of(jar.get()));
    }

    return new JdkProvidedInMemoryJavac();
  }

  private Jsr199Javac createJavac(boolean withSyntaxError) throws IOException {
    return createJavac(withSyntaxError, Optional.<Path>absent());
  }

  private ExecutionContext createExecutionContext() {
    return TestExecutionContext.newBuilder()
        .setProjectFilesystem(new ProjectFilesystem(tmp.getRootPath()))
        .build();
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.graph.AbstractBottomUpTraversal;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.parser.BuildTargetParser;
import com.facebook.buck.parser.BuildTargetPatternParser;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphAndTargets;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TargetNodes;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Sets;
import com.google.common.collect.TreeMultimap;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.Collection;
import java.util.List;

public class AuditDependenciesCommand extends AbstractCommand {

  private static final Logger LOG = Logger.get(AuditDependenciesCommand.class);

  @Option(name = "--json",
      usage = "Output in JSON format")
  private boolean generateJsonOutput;

  public boolean shouldGenerateJsonOutput() {
    return generateJsonOutput;
  }

  @Option(
      name = "--include-tests",
      usage = "Includes a target's tests with its dependencies. With the transitive flag, this " +
          "prints the dependencies of the tests as well")
  private boolean includeTests = false;

  @Option(name = "--transitive",
      aliases = { "-t" },
      usage = "Whether to include transitive dependencies in the output")
  private boolean transitive = false;

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public boolean shouldShowTransitiveDependencies() {
    return transitive;
  }

  public boolean shouldIncludeTests() {
    return includeTests;
  }

  public List<String> getArgumentsFormattedAsBuildTargets(BuckConfig buckConfig) {
    return getCommandLineBuildTargetNormalizer(buckConfig).normalizeAll(getArguments());
  }

  @Override
  public int runWithoutHelp(final CommandRunnerParams params)
      throws IOException, InterruptedException {
    final ImmutableSet<String> fullyQualifiedBuildTargets = ImmutableSet.copyOf(
        getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));

    if (fullyQualifiedBuildTargets.isEmpty()) {
      params.getConsole().printBuildFailure("Must specify at least one build target.");
      return 1;
    }

    ImmutableSet<BuildTarget> targets = FluentIterable
        .from(getArgumentsFormattedAsBuildTargets(params.getBuckConfig()))
        .transform(
            new Function<String, BuildTarget>() {
              @Override
              public BuildTarget apply(String input) {
                return BuildTargetParser.INSTANCE.parse(
                    input,
                    BuildTargetPatternParser.fullyQualified());
              }
            })
        .toSet();

    TargetGraph graph;
    try {
      graph = params.getParser().buildTargetGraphForBuildTargets(
          targets,
          new ParserConfig(params.getBuckConfig()),
          params.getBuckEventBus(),
          params.getConsole(),
          params.getEnvironment(),
          getEnableProfiling());
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    TreeMultimap<BuildTarget, BuildTarget> targetsAndDependencies = TreeMultimap.create();
    for (BuildTarget target : targets) {
      targetsAndDependencies.putAll(target, getDependenciesWithOptions(params, target, graph));
    }

    if (shouldGenerateJsonOutput()) {
      printJSON(params, targetsAndDependencies);
    } else {
      printToConsole(params, targetsAndDependencies);
    }

    return 0;
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  ImmutableSet<BuildTarget> getDependenciesWithOptions(
      CommandRunnerParams params,
      BuildTarget target,
      TargetGraph graph) throws IOException, InterruptedException {
    ImmutableSet<BuildTarget> targetsToPrint = shouldShowTransitiveDependencies() ?
        getTransitiveDependencies(ImmutableSet.of(target), graph) :
        getImmediateDependencies(target, graph);

    if (shouldIncludeTests()) {
      ImmutableSet.Builder<BuildTarget> builder = ImmutableSet.builder();
      targetsToPrint = builder
          .addAll(targetsToPrint)
          .addAll(getTestTargetDependencies(params, target, graph))
          .build();
    }
    return targetsToPrint;
  }

  @VisibleForTesting
  ImmutableSet<BuildTarget> getTransitiveDependencies(
      final ImmutableSet<BuildTarget> targets,
      TargetGraph graph) {
    final ImmutableSet.Builder<BuildTarget> builder = ImmutableSet.builder();

    TargetGraph subgraph = graph.getSubgraph(graph.getAll(targets));
    new AbstractBottomUpTraversal<TargetNode<?>, Void>(subgraph) {

      @Override
      public void visit(TargetNode<?> node) {
        LOG.debug("Visiting dependency " + node.getBuildTarget().getFullyQualifiedName());

        if (!targets.contains(node.getBuildTarget())) {
          builder.add(node.getBuildTarget());
        }
      }

      @Override
      public Void getResult() {
        return null;
      }

    }.traverse();

    return builder.build();
  }

  @VisibleForTesting
  ImmutableSet<BuildTarget> getImmediateDependencies(BuildTarget target, TargetGraph graph) {
    return Preconditions.checkNotNull(graph.get(target)).getDeps();
  }

  @VisibleForTesting
  Collection<BuildTarget> getTestTargetDependencies(
      CommandRunnerParams params,
      BuildTarget target,
      TargetGraph graph) throws IOException, InterruptedException {
    if (!shouldShowTransitiveDependencies()) {
      return TargetNodes.getTestTargetsForNode(Preconditions.checkNotNull(graph.get(target)));
    }

    ProjectGraphParser projectGraphParser = ProjectGraphParsers.createProjectGraphParser(
        params.getParser(),
        new ParserConfig(params.getBuckConfig()),
        params.getBuckEventBus(),
        params.getConsole(),
        params.getEnvironment(),
        getEnableProfiling());

    TargetGraph graphWithTests = TargetGraphTestParsing.expandedTargetGraphToIncludeTestsForTargets(
        projectGraphParser,
        graph,
        ImmutableSet.of(target));

    ImmutableSet<BuildTarget> tests = TargetGraphAndTargets.getExplicitTestTargets(
        ImmutableSet.of(target),
        graphWithTests);



    Sets.SetView<BuildTarget> testsWithDependencies = Sets.union(
        tests,
        getTransitiveDependencies(tests, graphWithTests));


    return Sets.difference(testsWithDependencies, ImmutableSet.of(target));
  }

  private void printJSON(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndDependencies) throws IOException {
    Multimap<BuildTarget, String> targetsAndDependenciesNames =
        Multimaps.transformValues(
            targetsAndDependencies, new Function<BuildTarget, String>() {
              @Override
              public String apply(BuildTarget input) {
                return Preconditions.checkNotNull(input.getFullyQualifiedName());
              }
            });
    params.getObjectMapper().writeValue(
        params.getConsole().getStdOut(),
        targetsAndDependenciesNames.asMap());
  }

  private void printToConsole(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndDependencies) {
    for (BuildTarget target : ImmutableSortedSet.copyOf(targetsAndDependencies.values())) {
      params.getConsole().getStdOut().println(target.getFullyQualifiedName());
    }
  }

  @Override
  public String getShortDescription() {
    return "provides facilities to audit build targets' dependencies";
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNodes;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.TreeMultimap;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.List;

public class AuditTestsCommand extends AbstractCommand {

  private static final Logger LOG = Logger.get(AuditTestsCommand.class);

  @Option(name = "--json",
      usage = "Output in JSON format")
  private boolean generateJsonOutput;

  public boolean shouldGenerateJsonOutput() {
    return generateJsonOutput;
  }

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public List<String> getArgumentsFormattedAsBuildTargets(BuckConfig buckConfig) {
    return getCommandLineBuildTargetNormalizer(buckConfig).normalizeAll(getArguments());
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
    final ImmutableSet<String> fullyQualifiedBuildTargets = ImmutableSet.copyOf(
        getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));

    if (fullyQualifiedBuildTargets.isEmpty()) {
      params.getConsole().printBuildFailure("Must specify at least one build target.");
      return 1;
    }

    ImmutableSet<BuildTarget> targets = getBuildTargets(
        ImmutableSet.copyOf(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())));

    TargetGraph graph;
    try {
      graph = params.getParser().buildTargetGraphForBuildTargets(
          targets,
          new ParserConfig(params.getBuckConfig()),
          params.getBuckEventBus(),
          params.getConsole(),
          params.getEnvironment(),
          getEnableProfiling());
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    TreeMultimap<BuildTarget, BuildTarget> targetsToPrint =
        getTestsForTargets(targets, graph);
    LOG.debug("Printing out the following targets: " + targetsToPrint);

    if (shouldGenerateJsonOutput()) {
      printJSON(params, targetsToPrint);
    } else {
      printToConsole(params, targetsToPrint);
    }

    return 0;
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  TreeMultimap<BuildTarget, BuildTarget> getTestsForTargets(
      final ImmutableSet<BuildTarget> targets,
      final TargetGraph graph) {
    TreeMultimap<BuildTarget, BuildTarget> multimap = TreeMultimap.create();
    for (BuildTarget target : targets) {
      multimap.putAll(
          target,
          TargetNodes.getTestTargetsForNode(Preconditions.checkNotNull(graph.get(target))));
    }
    return multimap;
  }

  private void printJSON(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndTests)
      throws IOException {
    Multimap<BuildTarget, String> targetsAndTestNames =
        Multimaps.transformValues(
            targetsAndTests, new Function<BuildTarget, String>() {
              @Override
              public String apply(BuildTarget input) {
                return Preconditions.checkNotNull(input.getFullyQualifiedName());
              }
            });
    params.getObjectMapper().writeValue(
        params.getConsole().getStdOut(),
        targetsAndTestNames.asMap());
  }

  private void printToConsole(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndTests) {
    for (BuildTarget target : ImmutableSortedSet.copyOf(targetsAndTests.values())) {
      params.getConsole().getStdOut().println(target.getFullyQualifiedName());
    }
  }

  @Override
  public String getShortDescription() {
    return "provides facilities to audit build targets' tests";
  }

}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;

import com.facebook.buck.java.JavaLibraryBuilder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.google.common.collect.ImmutableSet;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Paths;

public class AuditDependenciesCommandTest {

  private AuditDependenciesCommand auditDependenciesCommand;

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws IOException, InterruptedException{
    FakeProjectFilesystem projectFilesystem = new FakeProjectFilesystem();
    projectFilesystem.touch(Paths.get("src/com/facebook/TestAndroidLibrary.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibrary.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibraryThree.java"));

    auditDependenciesCommand = new AuditDependenciesCommand();
  }

  @Test
  public void testGetTransitiveDependenciesWalksTheGraph() throws IOException {
    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.of(javaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        auditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    assertEquals(ImmutableSet.of(secondLibraryTarget, javaTarget), transitiveDependencies);
  }

  @Test
  public void testGetImmediateDependenciesDoesntReturnTransitiveDependencies() throws IOException {
    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.of(javaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> immediateDependencies =
        auditDependenciesCommand.getImmediateDependencies(libraryTarget, targetGraph);
    assertEquals(ImmutableSet.of(secondLibraryTarget), immediateDependencies);
  }

  @Test
  public void testGetTransitiveDependenciesWithMultipleInputsReturnsAllDependencies()
      throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .addDep(thirdJavaTarget)
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addDep(secondJavaTarget)
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget, javaTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        auditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondLibraryTarget, secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

  @Test
  public void testGetImmediateDependenciesIncludesExtraDependencies() throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addExportedDep(thirdJavaTarget)
        .addDep(secondJavaTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> transitiveDependencies =
        auditDependenciesCommand.getImmediateDependencies(javaTarget, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

  @Test
  public void testGetTransitiveDependenciesIncludesExtraDependencies() throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addExportedDep(thirdJavaTarget)
        .addDep(secondJavaTarget)
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addExportedDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        auditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondLibraryTarget, javaTarget, secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.graph.AbstractBottomUpTraversal;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.parser.BuildTargetParser;
import com.facebook.buck.parser.BuildTargetPatternParser;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphAndTargets;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TargetNodes;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.Sets;
import com.google.common.collect.TreeMultimap;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.Collection;
import java.util.List;

public class AuditDependenciesCommand extends AbstractCommand {

  private static final Logger LOG = Logger.get(AuditDependenciesCommand.class);

  @Option(name = "--json",
      usage = "Output in JSON format")
  private boolean generateJsonOutput;

  public boolean shouldGenerateJsonOutput() {
    return generateJsonOutput;
  }

  @Option(
      name = "--include-tests",
      usage = "Includes a target's tests with its dependencies. With the transitive flag, this " +
          "prints the dependencies of the tests as well")
  private boolean includeTests = false;

  @Option(name = "--transitive",
      aliases = { "-t" },
      usage = "Whether to include transitive dependencies in the output")
  private boolean transitive = false;

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public boolean shouldShowTransitiveDependencies() {
    return transitive;
  }

  public boolean shouldIncludeTests() {
    return includeTests;
  }

  public List<String> getArgumentsFormattedAsBuildTargets(BuckConfig buckConfig) {
    return getCommandLineBuildTargetNormalizer(buckConfig).normalizeAll(getArguments());
  }

  @Override
  public int runWithoutHelp(final CommandRunnerParams params)
      throws IOException, InterruptedException {
    final ImmutableSet<String> fullyQualifiedBuildTargets = ImmutableSet.copyOf(
        getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));

    if (fullyQualifiedBuildTargets.isEmpty()) {
      params.getConsole().printBuildFailure("Must specify at least one build target.");
      return 1;
    }

    try {
      Multimap<BuildTarget, BuildTarget> targetsAndDependencies = getTargetsAndDependencies(
          params,
          getArgumentsFormattedAsBuildTargets(params.getBuckConfig()),
          shouldShowTransitiveDependencies(),
          shouldIncludeTests(),
          getEnableProfiling());

      if (shouldGenerateJsonOutput()) {
        printJSON(params, targetsAndDependencies);
      } else {
        printToConsole(params, targetsAndDependencies);
      }
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    return 0;
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  public static Multimap<BuildTarget, BuildTarget> getTargetsAndDependencies(
      final CommandRunnerParams params,
      final List<String> argumentsFormattedAsBuildTargets,
      boolean showTransitive,
      boolean showTests,
      boolean enableProfiling)
      throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
    ImmutableSet<BuildTarget> targets = FluentIterable
        .from(argumentsFormattedAsBuildTargets)
        .transform(
            new Function<String, BuildTarget>() {
              @Override
              public BuildTarget apply(String input) {
                return BuildTargetParser.INSTANCE.parse(
                    input,
                    BuildTargetPatternParser.fullyQualified());
              }
            })
        .toSet();

    TargetGraph graph = params.getParser().buildTargetGraphForBuildTargets(
        targets,
        new ParserConfig(params.getBuckConfig()),
        params.getBuckEventBus(),
        params.getConsole(),
        params.getEnvironment(),
        enableProfiling);

    TreeMultimap<BuildTarget, BuildTarget> targetsAndDependencies = TreeMultimap.create();
    for (BuildTarget target : targets) {
      targetsAndDependencies.putAll(
          target,
          getDependenciesWithOptions(
              params,
              target,
              graph,
              showTransitive,
              showTests,
              enableProfiling));
    }
    return targetsAndDependencies;
  }

  static ImmutableSet<BuildTarget> getDependenciesWithOptions(
      CommandRunnerParams params,
      BuildTarget target,
      TargetGraph graph,
      boolean showTransitive,
      boolean showTests,
      boolean enableProfiling) throws IOException, InterruptedException {
    ImmutableSet<BuildTarget> targetsToPrint = showTransitive ?
        getTransitiveDependencies(ImmutableSet.of(target), graph) :
        getImmediateDependencies(target, graph);

    if (showTests) {
      ImmutableSet.Builder<BuildTarget> builder = ImmutableSet.builder();
      targetsToPrint = builder
          .addAll(targetsToPrint)
          .addAll(getTestTargetDependencies(params, target, graph, showTransitive, enableProfiling))
          .build();
    }
    return targetsToPrint;
  }

  @VisibleForTesting
  static ImmutableSet<BuildTarget> getTransitiveDependencies(
      final ImmutableSet<BuildTarget> targets,
      TargetGraph graph) {
    final ImmutableSet.Builder<BuildTarget> builder = ImmutableSet.builder();

    TargetGraph subgraph = graph.getSubgraph(graph.getAll(targets));
    new AbstractBottomUpTraversal<TargetNode<?>, Void>(subgraph) {

      @Override
      public void visit(TargetNode<?> node) {
        LOG.debug("Visiting dependency " + node.getBuildTarget().getFullyQualifiedName());

        if (!targets.contains(node.getBuildTarget())) {
          builder.add(node.getBuildTarget());
        }
      }

      @Override
      public Void getResult() {
        return null;
      }

    }.traverse();

    return builder.build();
  }

  @VisibleForTesting
  static ImmutableSet<BuildTarget> getImmediateDependencies(BuildTarget target, TargetGraph graph) {
    return Preconditions.checkNotNull(graph.get(target)).getDeps();
  }

  @VisibleForTesting
  static Collection<BuildTarget> getTestTargetDependencies(
      CommandRunnerParams params,
      BuildTarget target,
      TargetGraph graph,
      boolean showTransitive,
      boolean enableProfiling) throws IOException, InterruptedException {
    if (!showTransitive) {
      return TargetNodes.getTestTargetsForNode(Preconditions.checkNotNull(graph.get(target)));
    }

    ProjectGraphParser projectGraphParser = ProjectGraphParsers.createProjectGraphParser(
        params.getParser(),
        new ParserConfig(params.getBuckConfig()),
        params.getBuckEventBus(),
        params.getConsole(),
        params.getEnvironment(),
        enableProfiling);

    TargetGraph graphWithTests = TargetGraphTestParsing.expandedTargetGraphToIncludeTestsForTargets(
        projectGraphParser,
        graph,
        ImmutableSet.of(target));

    ImmutableSet<BuildTarget> tests = TargetGraphAndTargets.getExplicitTestTargets(
        ImmutableSet.of(target),
        graphWithTests);



    Sets.SetView<BuildTarget> testsWithDependencies = Sets.union(
        tests,
        getTransitiveDependencies(tests, graphWithTests));


    return Sets.difference(testsWithDependencies, ImmutableSet.of(target));
  }

  private void printJSON(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndDependencies) throws IOException {
    Multimap<BuildTarget, String> targetsAndDependenciesNames =
        Multimaps.transformValues(
            targetsAndDependencies, new Function<BuildTarget, String>() {
              @Override
              public String apply(BuildTarget input) {
                return Preconditions.checkNotNull(input.getFullyQualifiedName());
              }
            });
    params.getObjectMapper().writeValue(
        params.getConsole().getStdOut(),
        targetsAndDependenciesNames.asMap());
  }

  private void printToConsole(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndDependencies) {
    for (BuildTarget target : ImmutableSortedSet.copyOf(targetsAndDependencies.values())) {
      params.getConsole().getStdOut().println(target.getFullyQualifiedName());
    }
  }

  @Override
  public String getShortDescription() {
    return "provides facilities to audit build targets' dependencies";
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNodes;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.TreeMultimap;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.List;

public class AuditTestsCommand extends AbstractCommand {

  private static final Logger LOG = Logger.get(AuditTestsCommand.class);

  @Option(name = "--json",
      usage = "Output in JSON format")
  private boolean generateJsonOutput;

  public boolean shouldGenerateJsonOutput() {
    return generateJsonOutput;
  }

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public List<String> getArgumentsFormattedAsBuildTargets(BuckConfig buckConfig) {
    return getCommandLineBuildTargetNormalizer(buckConfig).normalizeAll(getArguments());
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
    final ImmutableSet<String> fullyQualifiedBuildTargets = ImmutableSet.copyOf(
        getArgumentsFormattedAsBuildTargets(params.getBuckConfig()));

    if (fullyQualifiedBuildTargets.isEmpty()) {
      params.getConsole().printBuildFailure("Must specify at least one build target.");
      return 1;
    }

    ImmutableSet<BuildTarget> targets = getBuildTargets(
        ImmutableSet.copyOf(getArgumentsFormattedAsBuildTargets(params.getBuckConfig())));

    try {
      TreeMultimap<BuildTarget, BuildTarget> targetsToPrint =
          getTestsForTargets(params, targets, getEnableProfiling());
      LOG.debug("Printing out the following targets: " + targetsToPrint);

      if (shouldGenerateJsonOutput()) {
        printJSON(params, targetsToPrint);
      } else {
        printToConsole(params, targetsToPrint);
      }
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    return 0;
  }

  @Override
  public boolean isReadOnly() {
    return true;
  }

  public static TreeMultimap<BuildTarget, BuildTarget> getTestsForTargets(
      final CommandRunnerParams params,
      final ImmutableSet<BuildTarget> targets,
      boolean enableProfiling)
      throws IOException, InterruptedException, BuildFileParseException, BuildTargetException {
    TargetGraph graph = params.getParser().buildTargetGraphForBuildTargets(
        targets,
        new ParserConfig(params.getBuckConfig()),
        params.getBuckEventBus(),
        params.getConsole(),
        params.getEnvironment(),
        enableProfiling);

    TreeMultimap<BuildTarget, BuildTarget> multimap = TreeMultimap.create();
    for (BuildTarget target : targets) {
      multimap.putAll(
          target,
          TargetNodes.getTestTargetsForNode(Preconditions.checkNotNull(graph.get(target))));
    }
    return multimap;
  }

  private void printJSON(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndTests)
      throws IOException {
    Multimap<BuildTarget, String> targetsAndTestNames =
        Multimaps.transformValues(
            targetsAndTests, new Function<BuildTarget, String>() {
              @Override
              public String apply(BuildTarget input) {
                return Preconditions.checkNotNull(input.getFullyQualifiedName());
              }
            });
    params.getObjectMapper().writeValue(
        params.getConsole().getStdOut(),
        targetsAndTestNames.asMap());
  }

  private void printToConsole(
      CommandRunnerParams params,
      Multimap<BuildTarget, BuildTarget> targetsAndTests) {
    for (BuildTarget target : ImmutableSortedSet.copyOf(targetsAndTests.values())) {
      params.getConsole().getStdOut().println(target.getFullyQualifiedName());
    }
  }

  @Override
  public String getShortDescription() {
    return "provides facilities to audit build targets' tests";
  }

}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;

import com.facebook.buck.java.JavaLibraryBuilder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.google.common.collect.ImmutableSet;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Paths;

public class AuditDependenciesCommandTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws IOException, InterruptedException{
    FakeProjectFilesystem projectFilesystem = new FakeProjectFilesystem();
    projectFilesystem.touch(Paths.get("src/com/facebook/TestAndroidLibrary.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibrary.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"));
    projectFilesystem.touch(Paths.get("src/com/facebook/TestJavaLibraryThree.java"));
  }

  @Test
  public void testGetTransitiveDependenciesWalksTheGraph() throws IOException {
    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.of(javaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        AuditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    assertEquals(ImmutableSet.of(secondLibraryTarget, javaTarget), transitiveDependencies);
  }

  @Test
  public void testGetImmediateDependenciesDoesntReturnTransitiveDependencies() throws IOException {
    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.of(javaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> immediateDependencies =
        AuditDependenciesCommand.getImmediateDependencies(libraryTarget, targetGraph);
    assertEquals(ImmutableSet.of(secondLibraryTarget), immediateDependencies);
  }

  @Test
  public void testGetTransitiveDependenciesWithMultipleInputsReturnsAllDependencies()
      throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .addDep(thirdJavaTarget)
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addDep(secondJavaTarget)
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget, javaTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        AuditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondLibraryTarget, secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

  @Test
  public void testGetImmediateDependenciesIncludesExtraDependencies() throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addExportedDep(thirdJavaTarget)
        .addDep(secondJavaTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> transitiveDependencies =
        AuditDependenciesCommand.getImmediateDependencies(javaTarget, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

  @Test
  public void testGetTransitiveDependenciesIncludesExtraDependencies() throws IOException {
    BuildTarget thirdJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-three");
    TargetNode<?> thirdJavaNode = JavaLibraryBuilder
        .createBuilder(thirdJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryThree.java"))
        .build();

    BuildTarget secondJavaTarget = BuildTargetFactory.newInstance("//:test-java-library-two");
    TargetNode<?> secondJavaNode = JavaLibraryBuilder
        .createBuilder(secondJavaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibraryTwo.java"))
        .build();

    BuildTarget javaTarget = BuildTargetFactory.newInstance("//:test-java-library");
    TargetNode<?> javaNode = JavaLibraryBuilder
        .createBuilder(javaTarget)
        .addSrc(Paths.get("src/com/facebook/TestJavaLibrary.java"))
        .addExportedDep(thirdJavaTarget)
        .addDep(secondJavaTarget)
        .build();

    BuildTarget secondLibraryTarget = BuildTargetFactory.newInstance("//:test-android-library-two");
    TargetNode<?> secondLibraryNode = JavaLibraryBuilder
        .createBuilder(secondLibraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibraryTwo.java"))
        .addExportedDep(javaTarget)
        .build();

    BuildTarget libraryTarget = BuildTargetFactory.newInstance("//:test-android-library");
    TargetNode<?> libraryNode = JavaLibraryBuilder
        .createBuilder(libraryTarget)
        .addSrc(Paths.get("src/com/facebook/TestAndroidLibrary.java"))
        .addDep(secondLibraryTarget)
        .build();

    ImmutableSet<TargetNode<?>> nodes =
        ImmutableSet.of(javaNode, secondJavaNode, thirdJavaNode, libraryNode, secondLibraryNode);
    TargetGraph targetGraph = TargetGraphFactory.newInstance(nodes);

    ImmutableSet<BuildTarget> testInput = ImmutableSet.of(libraryTarget);
    ImmutableSet<BuildTarget> transitiveDependencies =
        AuditDependenciesCommand.getTransitiveDependencies(testInput, targetGraph);
    ImmutableSet<BuildTarget> expectedOutput =
        ImmutableSet.of(secondLibraryTarget, javaTarget, secondJavaTarget, thirdJavaTarget);
    assertEquals(expectedOutput, transitiveDependencies);
  }

}

<code block>


package com.facebook.buck.event.listener;

import com.facebook.buck.cli.CommandEvent;
import com.facebook.buck.cli.InstallEvent;
import com.facebook.buck.cli.StartActivityEvent;
import com.facebook.buck.cli.UninstallEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ChromeTraceEvent;
import com.facebook.buck.event.TraceEvent;
import com.facebook.buck.io.PathListing;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.ArtifactCacheConnectEvent;
import com.facebook.buck.rules.ArtifactCacheEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.BestCompressionGZIPOutputStream;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Optionals;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.Subscribe;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;


public class ChromeTraceBuildListener implements BuckEventListener {
  private static final Logger LOG = Logger.get(ChromeTraceBuildListener.class);

  private final ProjectFilesystem projectFilesystem;
  private final Clock clock;
  private final int tracesToKeep;
  private final boolean compressTraces;
  private final ObjectMapper mapper;
  private final ThreadLocal<SimpleDateFormat> dateFormat;
  private ConcurrentLinkedQueue<ChromeTraceEvent> eventList =
      new ConcurrentLinkedQueue<ChromeTraceEvent>();

  public ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      int tracesToKeep,
      boolean compressTraces) {
    this(
        projectFilesystem,
        clock,
        objectMapper,
        Locale.US,
        TimeZone.getDefault(),
        tracesToKeep,
        compressTraces);
  }

  @VisibleForTesting
  ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      final Locale locale,
      final TimeZone timeZone,
      int tracesToKeep,
      boolean compressTraces) {
    this.projectFilesystem = projectFilesystem;
    this.clock = clock;
    this.mapper = objectMapper;
    this.dateFormat = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd.HH-mm-ss", locale);
          dateFormat.setTimeZone(timeZone);
          return dateFormat;
      }
    };
    this.tracesToKeep = tracesToKeep;
    this.compressTraces = compressTraces;
    addProcessMetadataEvent();
  }

  private void addProcessMetadataEvent() {
    eventList.add(
        new ChromeTraceEvent(
            "buck",
            "process_name",
            ChromeTraceEvent.Phase.METADATA,
 0,
 0,
 0,
            ImmutableMap.of("name", "buck")));
  }

  @VisibleForTesting
  void deleteOldTraces() {
    if (!projectFilesystem.exists(BuckConstant.BUCK_TRACE_DIR)) {
      return;
    }

    Path traceDirectory = projectFilesystem.getPathForRelativePath(BuckConstant.BUCK_TRACE_DIR);

    try {
      for (Path path : PathListing.listMatchingPathsWithFilters(
               traceDirectory,
               "build.*.trace",
               PathListing.GET_PATH_MODIFIED_TIME,
               PathListing.FilterMode.EXCLUDE,
               Optional.of(tracesToKeep),
               Optional.<Long>absent())) {
        projectFilesystem.deleteFileAtPath(path);
      }
    } catch (IOException e) {
      LOG.error(e, "Couldn't list paths in trace directory %s", traceDirectory);
    }
  }

  @Override
  public void outputTrace(BuildId buildId) {
    try {
      String filenameTime = dateFormat.get().format(new Date(clock.currentTimeMillis()));
      String traceName = String.format("build.%s.%s.trace", filenameTime, buildId);
      if (compressTraces) {
        traceName = traceName + ".gz";
      }
      Path tracePath = BuckConstant.BUCK_TRACE_DIR.resolve(traceName);
      projectFilesystem.createParentDirs(tracePath);
      OutputStream stream = projectFilesystem.newFileOutputStream(tracePath);
      if (compressTraces) {
        stream = new BestCompressionGZIPOutputStream(stream, true);
      }

      LOG.debug("Writing Chrome trace to %s", tracePath);
      mapper.writeValue(stream, eventList);

      String symlinkName = compressTraces ? "build.trace.gz" : "build.trace";
      Path symlinkPath = BuckConstant.BUCK_TRACE_DIR.resolve(symlinkName);
      projectFilesystem.createSymLink(
          projectFilesystem.resolve(symlinkPath),
          projectFilesystem.resolve(tracePath),
          true);

      deleteOldTraces();
    } catch (IOException e) {
      throw new HumanReadableException(e, "Unable to write trace file: " + e);
    }
  }

  @Subscribe
  public void commandStarted(CommandEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCommandName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(started.getArgs())
        ),
        started);
  }

  @Subscribe
  public void commandFinished(CommandEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getCommandName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(finished.getArgs()),
            "daemon", Boolean.toString(finished.isDaemon())),
        finished);
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public synchronized void buildFinished(BuildEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void ruleStarted(BuildRuleEvent.Started started) {
    BuildRule buildRule = started.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", started.getRuleKeySafe()),
        started);
  }

  @Subscribe
  public void ruleFinished(BuildRuleEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getBuildRule().getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "cache_result", finished.getCacheResult().toString().toLowerCase(),
            "success_type",
            finished.getSuccessType().transform(Functions.toStringFunction()).or("failed")
        ),
        finished);
  }

  @Subscribe
  public void ruleResumed(BuildRuleEvent.Resumed resumed) {
    BuildRule buildRule = resumed.getBuildRule();
    writeChromeTraceEvent(
        "buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", resumed.getRuleKeySafe()),
        resumed);
  }

  @Subscribe
  public void ruleSuspended(BuildRuleEvent.Suspended suspended) {
    BuildRule buildRule = suspended.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of("rule_key", suspended.getRuleKeySafe()),
        suspended);
  }

  @Subscribe
  public void stepStarted(StepEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getShortStepName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void stepFinished(StepEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getShortStepName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "description", finished.getDescription(),
            "exit_code", Integer.toString(finished.getExitCode())),
        finished);
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "targets",
            Joiner.on(",").join(finished.getBuildTargets())),
        finished);
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void startActivityStarted(StartActivityEvent.Started started) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void startActivityFinished(StartActivityEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "activity_name", finished.getActivityName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void uninstallStarted(UninstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void uninstallFinished(UninstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "package_name", finished.getPackageName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void artifactFetchStarted(ArtifactCacheEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "rule_key", Joiner.on(", ").join(started.getRuleKeys())),
        started);
  }

  @Subscribe
  public void artifactFetchFinished(ArtifactCacheEvent.Finished finished) {
    ImmutableMap.Builder<String, String> argumentsBuilder = ImmutableMap.<String, String>builder()
        .put("success", Boolean.toString(finished.isSuccess()))
        .put("rule_key", Joiner.on(", ").join(finished.getRuleKeys()));
    Optionals.putIfPresent(finished.getCacheResult().transform(Functions.toStringFunction()),
        "cache_result",
        argumentsBuilder);

    writeChromeTraceEvent("buck",
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        argumentsBuilder.build(),
        finished);
  }

  @Subscribe
  public void artifactConnectStarted(ArtifactCacheConnectEvent.Started started) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void artifactConnectFinished(ArtifactCacheConnectEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void traceEvent(TraceEvent event) {
    writeChromeTraceEvent("buck",
        event.getEventName(),
        event.getPhase(),
        event.getProperties(),
        event);
  }

  @Subscribe
  public void testStartedEvent(TestSummaryEvent.Started started) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "test_case_name", started.getTestCaseName(),
            "test_name", started.getTestName()),
        started);
  }

  @Subscribe
  public void testFinishedEvent(TestSummaryEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "test_case_name", finished.getTestCaseName(),
            "test_name", finished.getTestName()),
        finished);
  }

  private void writeChromeTraceEvent(String category,
      String name,
      ChromeTraceEvent.Phase phase,
      ImmutableMap<String, String> arguments,
      BuckEvent event) {
    eventList.add(new ChromeTraceEvent(category,
        name,
        phase,
        0,
        event.getThreadId(),
        TimeUnit.NANOSECONDS.toMicros(event.getNanoTime()),
        arguments));
  }
}

<code block>

package com.facebook.buck.event.listener;

import com.facebook.buck.cli.InstallEvent;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.IndividualTestEvent;
import com.facebook.buck.rules.TestRunEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.Console;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.eventbus.Subscribe;

import java.util.concurrent.atomic.AtomicLong;


public class SimpleConsoleEventBusListener extends AbstractConsoleEventBusListener {
  private final AtomicLong parseTime;
  private final TestResultFormatter testFormatter;

  public SimpleConsoleEventBusListener(Console console, Clock clock) {
    super(console, clock);

    this.parseTime = new AtomicLong(0);
    this.testFormatter = new TestResultFormatter(console.getAnsi(), console.getVerbosity());
  }

  @Override
  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    super.parseFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    this.parseTime.set(logEventPair("PARSING BUCK FILES",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        0L,
        parseStarted,
        parseFinished,
        lines));
    printLines(lines);
  }

  @Override
  @Subscribe
  public void buildFinished(BuildEvent.Finished finished) {
    super.buildFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    logEventPair("BUILDING",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        parseTime.get(),
        buildStarted,
        buildFinished,
        lines);
    printLines(lines);
  }

  @Override
  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    super.installFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    logEventPair("INSTALLING",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        0L,
        installStarted,
        installFinished,
        lines);
    printLines(lines);
  }

  @Subscribe
  public void logEvent(ConsoleEvent event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    formatConsoleEvent(event, lines);
    printLines(lines);
  }

  @Subscribe
  public void testRunStarted(TestRunEvent.Started event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.runStarted(lines,
        event.isRunAllTests(),
        event.getTestSelectorList(),
        event.shouldExplainTestSelectorList(),
        event.getTargetNames(),
        TestResultFormatter.FormatMode.BEFORE_TEST_RUN);
    printLines(lines);
  }

  @Subscribe
  public void testRunCompleted(TestRunEvent.Finished event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.runComplete(lines, event.getResults());
    printLines(lines);
  }

  @Subscribe
  public void testResultsAvailable(IndividualTestEvent.Finished event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.reportResult(lines, event.getResults());
    printLines(lines);
  }

  @Subscribe
  public void buildRuleFinished(BuildRuleEvent.Finished finished) {
    String line = String.format("BUILT %s", finished.getBuildRule().getFullyQualifiedName());
    if (ruleCount.isPresent()) {
      line += String.format(
          " (%d/%d JOBS)",
          numRulesCompleted.get(),
          ruleCount.get());
    }
    console.getStdErr().println(line);
  }

  private void printLines(ImmutableList.Builder<String> lines) {



    ImmutableList<String> stringList = lines.build();
    if (stringList.size() == 0) {
      return;
    }
    console.getStdErr().println(Joiner.on("\n").join(stringList));
  }
}

<code block>

package com.facebook.buck.event.listener;

import com.facebook.buck.cli.InstallEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.json.ProjectBuildFileParseEvents;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.Ansi;
import com.facebook.buck.util.Console;
import com.google.common.base.Optional;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.eventbus.Subscribe;

import java.io.Closeable;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;

import javax.annotation.Nullable;


public abstract class AbstractConsoleEventBusListener implements BuckEventListener, Closeable {
  protected static final DecimalFormat TIME_FORMATTER = new DecimalFormat("0.0s");
  protected static final long UNFINISHED_EVENT_PAIR = -1;
  protected final Console console;
  protected final Clock clock;
  protected final Ansi ansi;

  @Nullable
  protected volatile ProjectBuildFileParseEvents.Started projectBuildFileParseStarted;
  @Nullable
  protected volatile ProjectBuildFileParseEvents.Finished projectBuildFileParseFinished;

  @Nullable
  protected volatile ParseEvent.Started parseStarted;
  @Nullable
  protected volatile ParseEvent.Finished parseFinished;

  @Nullable
  protected volatile ActionGraphEvent.Started actionGraphStarted;
  @Nullable
  protected volatile ActionGraphEvent.Finished actionGraphFinished;

  @Nullable
  protected volatile BuildEvent.Started buildStarted;
  @Nullable
  protected volatile BuildEvent.Finished buildFinished;

  @Nullable
  protected volatile InstallEvent.Started installStarted;
  @Nullable
  protected volatile InstallEvent.Finished installFinished;

  protected volatile Optional<Integer> ruleCount = Optional.absent();

  protected final AtomicInteger numRulesCompleted = new AtomicInteger();

  public AbstractConsoleEventBusListener(Console console, Clock clock) {
    this.console = console;
    this.clock = clock;
    this.ansi = console.getAnsi();

    this.projectBuildFileParseStarted = null;
    this.projectBuildFileParseFinished = null;

    this.parseStarted = null;
    this.parseFinished = null;

    this.actionGraphStarted = null;
    this.actionGraphFinished = null;

    this.buildStarted = null;
    this.buildFinished = null;

    this.installStarted = null;
    this.installFinished = null;
  }

  protected String formatElapsedTime(long elapsedTimeMs) {
    return TIME_FORMATTER.format(elapsedTimeMs / 1000.0);
  }



  protected long logEventPair(String prefix,
      Optional<String> suffix,
      long currentMillis,
      long offsetMs,
      @Nullable BuckEvent startEvent,
      @Nullable BuckEvent finishedEvent,
      ImmutableList.Builder<String> lines) {
    long result = UNFINISHED_EVENT_PAIR;
    if (startEvent == null) {
      return result;
    }
    String parseLine = (finishedEvent != null ? "[-] " : "[+] ") + prefix + "...";
    long elapsedTimeMs;
    if (finishedEvent != null) {
      elapsedTimeMs = finishedEvent.getTimestamp() - startEvent.getTimestamp();
      parseLine += "FINISHED ";
      result = elapsedTimeMs;
    } else {
      elapsedTimeMs = currentMillis - startEvent.getTimestamp();
    }
    parseLine += formatElapsedTime(elapsedTimeMs - offsetMs);
    if (suffix.isPresent()) {
      parseLine += " " + suffix.get();
    }
    lines.add(parseLine);

    return result;
  }


  protected void formatConsoleEvent(ConsoleEvent logEvent, ImmutableList.Builder<String> lines) {
    String formattedLine = "";
    if (logEvent.getLevel().equals(Level.INFO)) {
      formattedLine = logEvent.getMessage();
    } else if (logEvent.getLevel().equals(Level.WARNING)) {
      formattedLine = ansi.asWarningText(logEvent.getMessage());
    } else if (logEvent.getLevel().equals(Level.SEVERE)) {
      formattedLine = ansi.asErrorText(logEvent.getMessage());
    }
    if (!formattedLine.isEmpty()) {


      lines.addAll(Splitter.on("\n").split(formattedLine));
    }
  }

  @Subscribe
  public void projectBuildFileParseStarted(ProjectBuildFileParseEvents.Started started) {
    projectBuildFileParseStarted = started;
  }

  @Subscribe
  public void projectBuildFileParseFinished(ProjectBuildFileParseEvents.Finished finished) {
    projectBuildFileParseFinished = finished;
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    parseStarted = started;
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    parseFinished = finished;
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    actionGraphStarted = started;
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    actionGraphFinished = finished;
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    buildStarted = started;
  }

  @Subscribe
  public void ruleCountCalculated(BuildEvent.RuleCountCalculated calculated) {
    ruleCount = Optional.of(calculated.getNumRules());
  }

  @Subscribe
  public void incrementNumRulesCompleted(
      @SuppressWarnings("unused") BuildRuleEvent.Finished finished) {
    numRulesCompleted.getAndIncrement();
  }

  @Subscribe
  public void buildFinished(BuildEvent.Finished finished) {
    buildFinished = finished;
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    installStarted = started;
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    installFinished = finished;
  }

  @Override
  public void outputTrace(BuildId buildId) {}

  @Override
  public void close() throws IOException {
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.event.AbstractBuckEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.LeafEvent;
import com.facebook.buck.model.BuildTarget;
import com.google.common.base.Objects;

@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class InstallEvent extends AbstractBuckEvent implements LeafEvent {
  private final BuildTarget buildTarget;

  protected InstallEvent(BuildTarget buildTarget) {
    this.buildTarget = buildTarget;
  }

  public BuildTarget getBuildTarget() {
    return buildTarget;
  }

  @Override
  public String getCategory() {
    return "install_apk";
  }

  @Override
  protected String getValueString() {
    return buildTarget.getFullyQualifiedName();
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof InstallEvent)) {
      return false;
    }

    InstallEvent that = (InstallEvent) event;

    return Objects.equal(getBuildTarget(), that.getBuildTarget());
  }

  @Override
  public int hashCode() {
    return getBuildTarget().hashCode();
  }

  public static Started started(BuildTarget buildTarget) {
    return new Started(buildTarget);
  }

  public static Finished finished(BuildTarget buildTarget, boolean success) {
    return new Finished(buildTarget, success);
  }

  public static class Started extends InstallEvent {
    protected Started(BuildTarget buildTarget) {
      super(buildTarget);
    }

    @Override
    public String getEventName() {
      return "InstallStarted";
    }
  }

  public static class Finished extends InstallEvent {
    private final boolean success;

    protected Finished(BuildTarget buildTarget, boolean success) {
      super(buildTarget);
      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "InstallFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getBuildTarget(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.command.Build;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.Pair;
import com.facebook.buck.parser.BuildFileSpec;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.parser.TargetNodePredicateSpec;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.CachingBuildEngine;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphToActionGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TargetNodes;
import com.facebook.buck.rules.TestRule;
import com.facebook.buck.step.DefaultStepRunner;
import com.facebook.buck.step.TargetDevice;
import com.facebook.buck.test.CoverageReportFormat;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.concurrent.ConcurrencyLimit;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.annotation.Nullable;

public class TestCommand extends BuildCommand {

  public static final String USE_RESULTS_CACHE = "use_results_cache";

  private static final Logger LOG = Logger.get(TestCommand.class);

  @Option(name = "--all",
          usage =
              "Whether all of the tests should be run. " +
              "If no targets are given, --all is implied")
  private boolean all = false;

  @Option(name = "--code-coverage", usage = "Whether code coverage information will be generated.")
  private boolean isCodeCoverageEnabled = false;

  @Option(name = "--code-coverage-format", usage = "Format to be used for coverage")
  private CoverageReportFormat coverageReportFormat = CoverageReportFormat.HTML;

  @Option(name = "--debug",
          usage = "Whether the test will start suspended with a JDWP debug port of 5005")
  private boolean isDebugEnabled = false;

  @Option(name = "--xml", usage = "Where to write test output as XML.")
  @Nullable
  private String pathToXmlTestOutput = null;

  @Option(name = "--no-results-cache", usage = "Whether to use cached test results.")
  @Nullable
  private Boolean isResultsCacheDisabled = null;

  @Option(name = "--build-filtered", usage = "Whether to build filtered out tests.")
  @Nullable
  private Boolean isBuildFiltered = null;

  @Option(
      name = "--ignore-when-dependencies-fail",
      aliases = {"-i"},
      usage =
          "Ignore test failures for libraries if they depend on other libraries " +
          "that aren't passing their tests.  " +
          "For example, if java_library A depends on B, " +
          "and they are tested respectively by T1 and T2 and both of those tests fail, " +
          "only print the error for T2.")
  private boolean isIgnoreFailingDependencies = false;

  @Option(
      name = "--dry-run",
      usage = "Print tests that match the given command line options, but don't run them.")
  private boolean isDryRun;

  @Option(
      name = "--one-time-output",
      usage =
          "Put test-results in a unique, one-time output directory.  " +
          "This allows multiple tests to be run in parallel without interfering with each other, " +
          "but at the expense of being unable to use cached results.  " +
          "WARNING: this is experimental, and only works for Java tests!")
  private boolean isUsingOneTimeOutput;

  @Option(
      name = "--shuffle",
      usage =
          "Randomize the order in which test classes are executed." +
          "WARNING: only works for Java tests!")
  private boolean isShufflingTests;

  @Option(
      name = "--exclude-transitive-tests",
      usage =
          "Only run the tests targets that were specified on the command line (without adding " +
          "more tests by following dependencies).")
  private boolean shouldExcludeTransitiveTests;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceOptions targetDeviceOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TestSelectorOptions testSelectorOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TestLabelOptions testLabelOptions;

  public boolean isRunAllTests() {
    return all || getArguments().isEmpty();
  }

  @Override
  public boolean isCodeCoverageEnabled() {
    return isCodeCoverageEnabled;
  }

  public boolean isResultsCacheEnabled(BuckConfig buckConfig) {

    if (isResultsCacheDisabled == null) {
      boolean isUseResultsCache = buckConfig.getBooleanValue("test", USE_RESULTS_CACHE, true);
      isResultsCacheDisabled = !isUseResultsCache;
    }
    return !isResultsCacheDisabled;
  }

  @Override
  public boolean isDebugEnabled() {
    return isDebugEnabled;
  }

  public Optional<TargetDevice> getTargetDeviceOptional() {
    return targetDeviceOptions.getTargetDeviceOptional();
  }

  public boolean isDryRun() {
    return isDryRun;
  }

  public boolean isMatchedByLabelOptions(BuckConfig buckConfig, Set<Label> labels) {
    return testLabelOptions.isMatchedByLabelOptions(buckConfig, labels);
  }

  public boolean shouldExcludeTransitiveTests() {
    return shouldExcludeTransitiveTests;
  }

  public boolean shouldExcludeWin() {
    return testLabelOptions.shouldExcludeWin();
  }

  public boolean isBuildFiltered(BuckConfig buckConfig) {
    return isBuildFiltered != null ?
        isBuildFiltered :
        buckConfig.getBooleanValue("test", "build_filtered_tests", false);
  }

  public int getNumTestThreads(BuckConfig buckConfig) {
    if (isDebugEnabled()) {
      return 1;
    }
    return getNumThreads(buckConfig);
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
    LOG.debug("Running with arguments %s", getArguments());


    if (params.getParser().getParseStartTime().isPresent()) {
      params.getBuckEventBus().post(
          BuildEvent.started(getArguments()),
          params.getParser().getParseStartTime().get());
    } else {
      params.getBuckEventBus().post(BuildEvent.started(getArguments()));
    }



    ParserConfig parserConfig = new ParserConfig(params.getBuckConfig());
    TargetGraph targetGraph;
    ImmutableSet<BuildTarget> explicitBuildTargets;

    try {



      if (isRunAllTests()) {
        targetGraph = params.getParser().buildTargetGraphForTargetNodeSpecs(
            ImmutableList.of(
                TargetNodePredicateSpec.of(
                    new Predicate<TargetNode<?>>() {
                      @Override
                      public boolean apply(TargetNode<?> input) {
                        return input.getType().isTestRule();
                      }
                    },
                    BuildFileSpec.fromRecursivePath(
                        Paths.get(""),
                        params.getRepository().getFilesystem().getIgnorePaths()))),
            parserConfig,
            params.getBuckEventBus(),
            params.getConsole(),
            params.getEnvironment(),
            getEnableProfiling()).getSecond();
        explicitBuildTargets = ImmutableSet.of();



      } else {
        LOG.debug("Parsing graph for arguments %s", getArguments());
        Pair<ImmutableSet<BuildTarget>, TargetGraph> result = params.getParser()
            .buildTargetGraphForTargetNodeSpecs(
                parseArgumentsAsTargetNodeSpecs(
                    params.getBuckConfig(),
                    params.getRepository().getFilesystem().getIgnorePaths(),
                    getArguments()),
                parserConfig,
                params.getBuckEventBus(),
                params.getConsole(),
                params.getEnvironment(),
                getEnableProfiling());
        targetGraph = result.getSecond();
        explicitBuildTargets = result.getFirst();

        LOG.debug("Got explicit build targets %s", explicitBuildTargets);
        ImmutableSet.Builder<BuildTarget> testTargetsBuilder = ImmutableSet.builder();
        for (TargetNode<?> node : targetGraph.getAll(explicitBuildTargets)) {
          ImmutableSortedSet<BuildTarget> nodeTests = TargetNodes.getTestTargetsForNode(node);
          if (!nodeTests.isEmpty()) {
            LOG.debug("Got tests for target %s: %s", node.getBuildTarget(), nodeTests);
            testTargetsBuilder.addAll(nodeTests);
          }
        }
        ImmutableSet<BuildTarget> testTargets = testTargetsBuilder.build();
        if (!testTargets.isEmpty()) {
          LOG.debug("Got related test targets %s, building new target graph...", testTargets);
          targetGraph = params.getParser().buildTargetGraphForBuildTargets(
              Iterables.concat(
                  explicitBuildTargets,
                  testTargets),
              parserConfig,
              params.getBuckEventBus(),
              params.getConsole(),
              params.getEnvironment(),
              getEnableProfiling());
          LOG.debug("Finished building new target graph with tests.");
        }
      }

    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    ActionGraph graph = new TargetGraphToActionGraph(
        params.getBuckEventBus(),
        new BuildTargetNodeToBuildRuleTransformer(),
        params.getFileHashCache()).apply(targetGraph);


    Iterable<TestRule> testRules = Iterables.filter(graph.getNodes(), TestRule.class);



    if (!isBuildFiltered(params.getBuckConfig())) {
      testRules = filterTestRules(params.getBuckConfig(), explicitBuildTargets, testRules);
    }

    if (isDryRun()) {
      printMatchingTestRules(params.getConsole(), testRules);
    }

    try (CommandThreadManager pool =
             new CommandThreadManager("Test", getConcurrencyLimit(params.getBuckConfig()))) {
      CachingBuildEngine cachingBuildEngine =
          new CachingBuildEngine(
              pool.getExecutor(),
              getBuildEngineMode().or(params.getBuckConfig().getBuildEngineMode()));
      try (Build build = createBuild(
          params.getBuckConfig(),
          graph,
          params.getRepository().getFilesystem(),
          params.getAndroidPlatformTargetSupplier(),
          cachingBuildEngine,
          getArtifactCache(params),
          params.getConsole(),
          params.getBuckEventBus(),
          getTargetDeviceOptional(),
          params.getPlatform(),
          params.getEnvironment(),
          params.getObjectMapper(),
          params.getClock())) {


        int exitCode = build.executeAndPrintFailuresToConsole(
            testRules,
            isKeepGoing(),
            params.getConsole(),
            getPathToBuildReport(params.getBuckConfig()));
        params.getBuckEventBus().post(BuildEvent.finished(getArguments(), exitCode));
        if (exitCode != 0) {
          return exitCode;
        }



        if (isBuildFiltered(params.getBuckConfig())) {
          testRules =
              filterTestRules(params.getBuckConfig(), explicitBuildTargets, testRules);
        }


        ConcurrencyLimit concurrencyLimit = new ConcurrencyLimit(
            getNumTestThreads(params.getBuckConfig()),
            getLoadLimit(params.getBuckConfig()));
        try (CommandThreadManager testPool =
                 new CommandThreadManager("Test-Run", concurrencyLimit)) {
          TestRunningOptions options = TestRunningOptions.builder()
              .setUsingOneTimeOutputDirectories(isUsingOneTimeOutput)
              .setCodeCoverageEnabled(isCodeCoverageEnabled)
              .setRunAllTests(isRunAllTests())
              .setTestSelectorList(testSelectorOptions.getTestSelectorList())
              .setShouldExplainTestSelectorList(testSelectorOptions.shouldExplain())
              .setIgnoreFailingDependencies(isIgnoreFailingDependencies)
              .setResultsCacheEnabled(isResultsCacheEnabled(params.getBuckConfig()))
              .setDryRun(isDryRun)
              .setShufflingTests(isShufflingTests)
              .setPathToXmlTestOutput(Optional.fromNullable(pathToXmlTestOutput))
              .setCoverageReportFormat(coverageReportFormat)
              .build();
          return TestRunning.runTests(
              params,
              testRules,
              Preconditions.checkNotNull(build.getBuildContext()),
              build.getExecutionContext(),
              options,
              testPool.getExecutor(),
              cachingBuildEngine,
              new DefaultStepRunner(build.getExecutionContext()));
        } catch (ExecutionException e) {
          params.getConsole().printBuildFailureWithoutStacktrace(e);
          return 1;
        }
      }
    }
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

  private void printMatchingTestRules(Console console, Iterable<TestRule> testRules) {
    PrintStream out = console.getStdOut();
    ImmutableList<TestRule> list = ImmutableList.copyOf(testRules);
    out.println(String.format("MATCHING TEST RULES (%d):", list.size()));
    out.println("");
    if (list.isEmpty()) {
      out.println("  (none)");
    } else {
      for (TestRule testRule : testRules) {
        out.println("  " + testRule.getBuildTarget());
      }
    }
    out.println("");
  }

  @VisibleForTesting
  Iterable<TestRule> filterTestRules(
      BuckConfig buckConfig,
      ImmutableSet<BuildTarget> explicitBuildTargets,
      Iterable<TestRule> testRules) {

    ImmutableSortedSet.Builder<TestRule> builder =
        ImmutableSortedSet.orderedBy(
            new Comparator<TestRule>() {
              @Override
              public int compare(TestRule o1, TestRule o2) {
                return o1.getBuildTarget().getFullyQualifiedName().compareTo(
                    o2.getBuildTarget().getFullyQualifiedName());
              }
            });

    for (TestRule rule : testRules) {
      boolean explicitArgument = explicitBuildTargets.contains(rule.getBuildTarget());
      boolean matchesLabel = isMatchedByLabelOptions(buckConfig, rule.getLabels());



      if (shouldExcludeWin() && !matchesLabel) {
        continue;
      }



      if (shouldExcludeTransitiveTests() && !explicitArgument) {
        continue;
      }



      if (explicitArgument || matchesLabel) {
        builder.add(rule);
      }
    }

    return builder.build();
  }

  @Override
  public String getShortDescription() {
    return "builds and runs the tests for the specified target";
  }

}

<code block>


package com.facebook.buck.cli;

import static com.facebook.buck.util.concurrent.MoreExecutors.newMultiThreadExecutor;
import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.AndroidDebugBridge;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.MultiLineReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.TimeoutException;
import com.facebook.buck.android.AndroidManifestReader;
import com.facebook.buck.android.DefaultAndroidManifestReader;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.InterruptionFailedException;
import com.facebook.buck.util.TriState;
import com.facebook.buck.util.concurrent.MoreExecutors;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class AdbHelper {

  private static final long ADB_CONNECT_TIMEOUT_MS = 5000;
  private static final long ADB_CONNECT_TIME_STEP_MS = ADB_CONNECT_TIMEOUT_MS / 10;


  static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile("[\\w.-]+");


  static final String SERIAL_NUMBER_ENV = "ANDROID_SERIAL";


  public static final long INSTALL_TIMEOUT = 2 * 60 * 1000; 
  public static final long GETPROP_TIMEOUT = 2 * 1000; 

  public static final String ECHO_COMMAND_SUFFIX = " ; echo -n :$?";

  private final AdbOptions options;
  private final TargetDeviceOptions deviceOptions;
  private final ExecutionContext context;
  private final Console console;
  private final BuckEventBus buckEventBus;
  private final BuckConfig buckConfig;

  public AdbHelper(
      AdbOptions adbOptions,
      TargetDeviceOptions deviceOptions,
      ExecutionContext context,
      Console console,
      BuckEventBus buckEventBus,
      BuckConfig buckConfig) {
    this.options = adbOptions;
    this.deviceOptions = deviceOptions;
    this.context = context;
    this.console = console;
    this.buckEventBus = buckEventBus;
    this.buckConfig = buckConfig;
  }

  private BuckEventBus getBuckEventBus() {
    return buckEventBus;
  }


  @Nullable
  @VisibleForTesting
  List<IDevice> filterDevices(IDevice[] allDevices) {
    if (allDevices.length == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    List<IDevice> devices = Lists.newArrayList();
    TriState emulatorsOnly = TriState.UNSPECIFIED;
    if (deviceOptions.isEmulatorsOnlyModeEnabled() && options.isMultiInstallModeEnabled()) {
      emulatorsOnly = TriState.UNSPECIFIED;
    } else if (deviceOptions.isEmulatorsOnlyModeEnabled()) {
      emulatorsOnly = TriState.TRUE;
    } else if (deviceOptions.isRealDevicesOnlyModeEnabled()) {
      emulatorsOnly = TriState.FALSE;
    }

    int onlineDevices = 0;
    for (IDevice device : allDevices) {
      boolean passed = false;
      if (device.isOnline()) {
        onlineDevices++;

        boolean serialMatches = true;
        if (deviceOptions.hasSerialNumber()) {
          serialMatches = device.getSerialNumber().equals(deviceOptions.getSerialNumber());
        } else if (context.getEnvironment().containsKey(SERIAL_NUMBER_ENV)) {
          serialMatches = device.getSerialNumber().equals(
              context.getEnvironment().get(SERIAL_NUMBER_ENV));
        }

        boolean deviceTypeMatches;
        if (emulatorsOnly.isSet()) {


          deviceTypeMatches = (emulatorsOnly.asBoolean() == device.isEmulator());
        } else {

          deviceTypeMatches = true;
        }
        passed = serialMatches && deviceTypeMatches;
      }

      if (passed) {
        devices.add(device);
      }
    }


    if (onlineDevices == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    if (devices.isEmpty()) {
      console.printBuildFailure(String.format(
          "Found %d connected device(s), but none of them matches specified filter.",
          onlineDevices));
      return null;
    }


    if (!options.isMultiInstallModeEnabled() && devices.size() > 1) {
      console.printBuildFailure(
          String.format("%d device(s) matches specified device filter (1 expected).\n" +
                        "Either disconnect other devices or enable multi-install mode (%s).",
                         devices.size(), AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG));
      return null;
    }


    if (devices.size() > 1) {
      console.getStdOut().printf("Found " + devices.size() + " matching devices.\n");
    }
    return devices;
  }

  private boolean isAdbInitialized(AndroidDebugBridge adb) {
    return adb.isConnected() && adb.hasInitialDeviceList();
  }


  @Nullable
  @SuppressWarnings("PMD.EmptyCatchBlock")
  private AndroidDebugBridge createAdb(ExecutionContext context) throws InterruptedException {
    try {
      AndroidDebugBridge.init( false);
    } catch (IllegalStateException ex) {

    }

    AndroidDebugBridge adb =
        AndroidDebugBridge.createBridge(context.getPathToAdbExecutable(), false);
    if (adb == null) {
      console.printBuildFailure("Failed to connect to adb. Make sure adb server is running.");
      return null;
    }

    long start = System.currentTimeMillis();
    while (!isAdbInitialized(adb)) {
      long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();
      if (timeLeft <= 0) {
        break;
      }
      Thread.sleep(ADB_CONNECT_TIME_STEP_MS);
    }
    return isAdbInitialized(adb) ? adb : null;
  }


  @SuppressWarnings("PMD.EmptyCatchBlock")
  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {
    List<IDevice> devices;

    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, "set_up_adb_call")) {


      AndroidDebugBridge adb = createAdb(context);
      if (adb == null) {
        console.printBuildFailure("Failed to create adb connection.");
        return false;
      }


      devices = filterDevices(adb.getDevices());
      if (devices == null) {
        if (buckConfig.getRestartAdbOnFailure()) {
          console.printErrorText("No devices found with adb, restarting adb-server.");
          adb.restart();
          devices = filterDevices(adb.getDevices());
        }

        if (devices == null) {
            return false;
        }
      }
    }

    int adbThreadCount = options.getAdbThreadCount();
    if (adbThreadCount <= 0) {
      adbThreadCount = devices.size();
    }


    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();
    ListeningExecutorService executorService =
        listeningDecorator(
            newMultiThreadExecutor(
                new CommandThreadFactory(getClass().getSimpleName()),
                adbThreadCount));

    for (final IDevice device : devices) {
      futures.add(executorService.submit(adbCallable.forDevice(device)));
    }


    List<Boolean> results = null;
    try {
      results = Futures.allAsList(futures).get();
    } catch (ExecutionException ex) {
      console.printBuildFailure("Failed: " + adbCallable);
      ex.printStackTrace(console.getStdErr());
      return false;
    } catch (InterruptedException e) {
      try {
        Futures.allAsList(futures).cancel(true);
      } catch (CancellationException ignored) {

      }
      Thread.currentThread().interrupt();
      throw e;
    } finally {
      MoreExecutors.shutdownOrThrow(
          executorService,
          10,
          TimeUnit.MINUTES,
          new InterruptionFailedException("Failed to shutdown ExecutorService."));
    }

    int successCount = 0;
    for (Boolean result : results) {
      if (result) {
        successCount++;
      }
    }
    int failureCount = results.size() - successCount;


    if (successCount > 0) {
      console.printSuccess(
          String.format("Successfully ran %s on %d device(s)", adbCallable, successCount));
    }
    if (failureCount > 0) {
      console.printBuildFailure(
          String.format("Failed to %s on %d device(s).", adbCallable, failureCount));
    }

    return failureCount == 0;
  }


  public abstract static class AdbCallable {


    public abstract boolean call(IDevice device) throws Exception;


    public Callable<Boolean> forDevice(final IDevice device) {
      return new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
          return AdbCallable.this.call(device);
        }
        @Override
        public String toString() {
          return AdbCallable.this.toString();
        }
      };
    }
  }


  private abstract static class ErrorParsingReceiver extends MultiLineReceiver {

    @Nullable
    private String errorMessage = null;


    @Nullable
    protected abstract String matchForError(String line);


    protected boolean matchForSuccess(String line) {
      return false;
    }

    @Override
    public void processNewLines(String[] lines) {
        for (String line : lines) {
            if (line.length() > 0) {
                if (matchForSuccess(line)) {
                    errorMessage = null;
                } else {
                    String err = matchForError(line);
                    if (err != null) {
                      errorMessage = err;
                    }
                }
            }
        }
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Nullable
    public String getErrorMessage() {
       return errorMessage;
    }
  }


  @SuppressWarnings("serial")
  public static class CommandFailedException extends IOException {
    public final String command;
    public final int exitCode;
    public final String output;
    public CommandFailedException(String command, int exitCode, String output) {
      super("Command '" + command + "' failed with code " + exitCode + ".  Output:\n" + output);
      this.command = command;
      this.exitCode = exitCode;
      this.output = output;
    }
  }


  public static String executeCommandWithErrorChecking(IDevice device, String command)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(command + ECHO_COMMAND_SUFFIX, receiver);
    String realOutput = checkReceiverOutput(command, receiver);
    return realOutput;
  }


  public static String checkReceiverOutput(
      String command,
      CollectingOutputReceiver receiver) throws CommandFailedException {
    String fullOutput = receiver.getOutput();
    int colon = fullOutput.lastIndexOf(':');
    String realOutput = fullOutput.substring(0, colon);
    String exitCodeStr = fullOutput.substring(colon + 1);
    int exitCode = Integer.parseInt(exitCodeStr);
    if (exitCode != 0) {
      throw new CommandFailedException(command, exitCode, realOutput);
    }
    return realOutput;
  }


  public boolean installApk(
      InstallableApk installableApk,
      InstallCommand command) throws InterruptedException {
    getBuckEventBus().post(InstallEvent.started(installableApk.getBuildTarget()));

    final File apk = installableApk.getApkPath().toFile();
    final boolean installViaSd = command.shouldInstallViaSd();
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            return installApkOnDevice(device, apk, installViaSd);
          }

          @Override
          public String toString() {
            return "install apk";
          }
        });
    getBuckEventBus().post(InstallEvent.finished(installableApk.getBuildTarget(), success));

    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  public boolean installApkOnDevice(IDevice device, File apk, boolean installViaSd) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    if (!isDeviceTempWritable(device, name)) {
      return false;
    }

    getBuckEventBus().post(ConsoleEvent.info("Installing apk on %s.", name));
    try {
      String reason = null;
      if (installViaSd) {
        reason = deviceInstallPackageViaSd(device, apk.getAbsolutePath());
      } else {
        reason = device.installPackage(apk.getAbsolutePath(), true);
      }
      if (reason != null) {
        console.printBuildFailure(String.format("Failed to install apk on %s: %s.", name, reason));
        return false;
      }
      return true;
    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to install apk on %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }

  @VisibleForTesting
  protected boolean isDeviceTempWritable(IDevice device, String name) {
    StringBuilder loggingInfo = new StringBuilder();
    try {
      String output = null;

      try {
        output = executeCommandWithErrorChecking(device, "ls -l -d /data/local/tmp");
        if (!(

            output.matches("\\Adrwx....-x +shell +shell.* tmp[\\r\\n]*\\z") ||

            output.matches("\\Adrwx....-x +[0-9]+ +shell +shell.* /data/local/tmp[\\r\\n]*\\z"))) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad ls output for /data/local/tmp: '%s'\n",
                  output));
        }

        executeCommandWithErrorChecking(device, "echo exo > /data/local/tmp/buck-experiment");
        output = executeCommandWithErrorChecking(device, "cat /data/local/tmp/buck-experiment");
        if (!output.matches("\\Aexo[\\r\\n]*\\z")) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad echo/cat output for /data/local/tmp: '%s'\n",
                  output));
        }
        executeCommandWithErrorChecking(device, "rm /data/local/tmp/buck-experiment");

      } catch (CommandFailedException e) {
        loggingInfo.append(
            String.format(
                java.util.Locale.ENGLISH,
                "Failed (%d) '%s':\n%s\n",
                e.exitCode,
                e.command,
                e.output));
      }

      if (!loggingInfo.toString().isEmpty()) {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("getprop", receiver);
        for (String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
          if (line.contains("ro.product.model") || line.contains("ro.build.description")) {
            loggingInfo.append(line).append('\n');
          }
        }
      }

    } catch (
        AdbCommandRejectedException |
            ShellCommandUnresponsiveException |
            TimeoutException |
            IOException e) {
      console.printBuildFailure(String.format("Failed to test /data/local/tmp on %s.", name));
      e.printStackTrace(console.getStdErr());
      return false;
    }
    String logMessage = loggingInfo.toString();
    if (!logMessage.isEmpty()) {
      StringBuilder fullMessage = new StringBuilder();
      fullMessage.append("============================================================\n");
      fullMessage.append('\n');
      fullMessage.append("HEY! LISTEN!\n");
      fullMessage.append('\n');
      fullMessage.append("The /data/local/tmp directory on your device isn't fully-functional.\n");
      fullMessage.append("Here's some extra info:\n");
      fullMessage.append(logMessage);
      fullMessage.append("============================================================\n");
      console.getStdErr().println(fullMessage.toString());
    }

    return true;
  }


  private String deviceInstallPackageViaSd(IDevice device, String apk) {
    try {

      String externalStorage = deviceGetExternalStorage(device);
      if (externalStorage == null) {
        return "Cannot get external storage location.";
      }
      String remotePackage = String.format("%s/%s.apk", externalStorage, UUID.randomUUID());

      device.pushFile(apk, remotePackage);

      String reason = device.installRemotePackage(remotePackage, true);

      device.removeRemotePackage(remotePackage);
      return reason;
    } catch (Throwable t) {
      return String.valueOf(t.getMessage());
    }
  }


  @Nullable
  private String deviceGetExternalStorage(IDevice device) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(
        "echo $EXTERNAL_STORAGE",
        receiver,
        AdbHelper.GETPROP_TIMEOUT,
        TimeUnit.MILLISECONDS);
    String value = receiver.getOutput().trim();
    if (value.isEmpty()) {
      return null;
    }
    return value;
  }

  public int startActivity(
      InstallableApk installableApk,
      @Nullable String activity) throws IOException, InterruptedException {


    Path pathToManifest = installableApk.getManifestPath();
    AndroidManifestReader reader = DefaultAndroidManifestReader.forPath(
        pathToManifest, context.getProjectFilesystem());

    if (activity == null) {

      List<String> launcherActivities = reader.getLauncherActivities();


      if (launcherActivities.isEmpty()) {
        console.printBuildFailure("No launchable activities found.");
        return 1;
      } else if (launcherActivities.size() > 1) {
        console.printBuildFailure("Default activity is ambiguous.");
        return 1;
      }


      activity = reader.getPackage() + "/" + launcherActivities.get(0);
    } else if (!activity.contains("/")) {

      activity = reader.getPackage() + "/" + activity;
    }

    final String activityToRun = activity;

    PrintStream stdOut = console.getStdOut();
    stdOut.println(String.format("Starting activity %s...", activityToRun));

    getBuckEventBus().post(StartActivityEvent.started(installableApk.getBuildTarget(),
        activityToRun));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            String err = deviceStartActivity(device, activityToRun);
            if (err != null) {
              console.printBuildFailure(err);
              return false;
            } else {
              return true;
            }
          }

          @Override
          public String toString() {
            return "start activity";
          }
        });
    getBuckEventBus().post(StartActivityEvent.finished(installableApk.getBuildTarget(),
        activityToRun,
        success));

    return success ? 0 : 1;

  }

  @VisibleForTesting
  @Nullable
  String deviceStartActivity(IDevice device, String activityToRun) {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {

          return (Pattern.matches("^([\\w_$.])*(Exception|Error|error).*$", line) ||
              line.contains("am: not found")) ? line : null;
        }
      };
      device.executeShellCommand(
          String.format("am start -n %s", activityToRun),
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (Exception e) {
      return e.toString();
    }
  }


  public boolean uninstallApp(
      final String packageName,
      final UninstallCommand.UninstallOptions uninstallOptions) throws InterruptedException {
    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    getBuckEventBus().post(UninstallEvent.started(packageName));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
      @Override
      public boolean call(IDevice device) throws Exception {

        device.executeShellCommand("rm -r /data/local/tmp/exopackage/" + packageName,
            NullOutputReceiver.getReceiver());
        return uninstallApkFromDevice(device, packageName, uninstallOptions.shouldKeepUserData());
      }

      @Override
      public String toString() {
        return "uninstall apk";
      }
    });
    getBuckEventBus().post(UninstallEvent.finished(packageName, success));
    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  private boolean uninstallApkFromDevice(IDevice device, String packageName, boolean keepData) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    PrintStream stdOut = console.getStdOut();
    stdOut.printf("Removing apk from %s.\n", name);
    try {
      long start = System.currentTimeMillis();
      String reason = deviceUninstallPackage(device, packageName, keepData);
      long end = System.currentTimeMillis();

      if (reason != null) {
        console.printBuildFailure(
            String.format("Failed to uninstall apk from %s: %s.", name, reason));
        return false;
      }

      long delta = end - start;
      stdOut.printf("Uninstalled apk from %s in %d.%03ds.\n", name, delta / 1000, delta % 1000);
      return true;

    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to uninstall apk from %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }


  @Nullable
  private String deviceUninstallPackage(IDevice device,
      String packageName,
      boolean keepData) throws InstallException {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {
          return line.toLowerCase().contains("failure") ? line : null;
        }
      };
      device.executeShellCommand(
          "pm uninstall " + (keepData ? "-k " : "") + packageName,
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (TimeoutException e) {
      throw new InstallException(e);
    } catch (AdbCommandRejectedException e) {
      throw new InstallException(e);
    } catch (ShellCommandUnresponsiveException e) {
      throw new InstallException(e);
    } catch (IOException e) {
      throw new InstallException(e);
    }
  }

  public static String tryToExtractPackageNameFromManifest(
      InstallableApk androidBinaryRule,
      ExecutionContext context) {
    Path pathToManifest = androidBinaryRule.getManifestPath();



    if (!Files.isRegularFile(pathToManifest)) {
      throw new HumanReadableException(
          "Manifest file %s does not exist, so could not extract package name.",
          pathToManifest);
    }

    try {
      return DefaultAndroidManifestReader.forPath(pathToManifest, context.getProjectFilesystem())
          .getPackage();
    } catch (IOException e) {
      throw new HumanReadableException("Could not extract package name from %s", pathToManifest);
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.step.TargetDevice;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;

import org.kohsuke.args4j.Option;

import javax.annotation.Nullable;

public class TargetDeviceOptions {

  @VisibleForTesting public static final String EMULATOR_MODE_SHORT_ARG = "-e";
  @VisibleForTesting static final String EMULATOR_MODE_LONG_ARG = "--emulator";
  @Option(
      name = EMULATOR_MODE_LONG_ARG,
      aliases = {EMULATOR_MODE_SHORT_ARG},
      usage = "Use this option to use emulators only.")
  private boolean useEmulatorsOnlyMode;

  @VisibleForTesting static final String DEVICE_MODE_SHORT_ARG = "-d";
  @VisibleForTesting static final String DEVICE_MODE_LONG_ARG = "--device";
  @Option(
      name = DEVICE_MODE_LONG_ARG,
      aliases = {DEVICE_MODE_SHORT_ARG},
      usage = "Use this option to use real devices only."
  )
  private boolean useRealDevicesOnlyMode;

  @VisibleForTesting static final String SERIAL_NUMBER_SHORT_ARG = "-s";
  @VisibleForTesting static final String SERIAL_NUMBER_LONG_ARG = "--serial";
  @Option(
      name = SERIAL_NUMBER_LONG_ARG,
      aliases = {SERIAL_NUMBER_SHORT_ARG},
      metaVar = "<serial-number>",
      usage = "Use device or emulator with specific serial number."
  )
  @Nullable
  private String serialNumber;

  public TargetDeviceOptions() {
  }

  @VisibleForTesting
  TargetDeviceOptions(String serial) {
    this.serialNumber = serial;
  }

  public boolean isEmulatorsOnlyModeEnabled() {
    return useEmulatorsOnlyMode;
  }

  public boolean isRealDevicesOnlyModeEnabled() {
    return useRealDevicesOnlyMode;
  }

  @Nullable
  public String getSerialNumber() {
    return serialNumber;
  }

  public boolean hasSerialNumber() {
    return serialNumber != null;
  }

  public Optional<TargetDevice> getTargetDeviceOptional() {
    if (!hasSerialNumber() && !isEmulatorsOnlyModeEnabled() && !isRealDevicesOnlyModeEnabled()) {
      return Optional.absent();
    }

    TargetDevice device = new TargetDevice(
        isEmulatorsOnlyModeEnabled() ? TargetDevice.Type.EMULATOR : TargetDevice.Type.REAL_DEVICE,
        getSerialNumber());
    return Optional.of(device);
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.apple.AppleBundle;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleInfoPlistParsing;
import com.facebook.buck.apple.simulator.AppleCoreSimulatorServiceController;
import com.facebook.buck.apple.simulator.AppleSimulator;
import com.facebook.buck.apple.simulator.AppleSimulatorController;
import com.facebook.buck.apple.simulator.AppleSimulatorDiscovery;
import com.facebook.buck.cli.UninstallCommand.UninstallOptions;
import com.facebook.buck.command.Build;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.ExopackageInfo;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.UnixUserIdFetcher;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.InputStream;

import java.nio.file.Path;

import javax.annotation.Nullable;


public class InstallCommand extends BuildCommand {

  private static final Logger LOG = Logger.get(InstallCommand.class);
  private static final long APPLE_SIMULATOR_WAIT_MILLIS = 20000;

  @VisibleForTesting static final String RUN_LONG_ARG = "--run";
  @VisibleForTesting static final String RUN_SHORT_ARG = "-r";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_LONG_ARG = "--wait-for-debugger";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_SHORT_ARG = "-w";
  @VisibleForTesting static final String INSTALL_VIA_SD_LONG_ARG = "--via-sd";
  @VisibleForTesting static final String INSTALL_VIA_SD_SHORT_ARG = "-S";
  @VisibleForTesting static final String ACTIVITY_LONG_ARG = "--activity";
  @VisibleForTesting static final String ACTIVITY_SHORT_ARG = "-a";
  @VisibleForTesting static final String UNINSTALL_LONG_ARG = "--uninstall";
  @VisibleForTesting static final String UNINSTALL_SHORT_ARG = "-u";

  @Option(
      name = UNINSTALL_LONG_ARG,
      aliases = { UNINSTALL_SHORT_ARG },
      usage = "Uninstall the existing version before installing.")
  private boolean uninstallFirst = false;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceOptions deviceOptions;

  @Option(
      name = RUN_LONG_ARG,
      aliases = { RUN_SHORT_ARG },
      usage = "Run an activity (the default activity for package unless -a is specified).")
  private boolean run = false;

  @Option(
      name = WAIT_FOR_DEBUGGER_LONG_ARG,
      aliases = { WAIT_FOR_DEBUGGER_SHORT_ARG },
      usage = "Have the launched process wait for the debugger")
  private boolean waitForDebugger = false;

  @Option(
      name = INSTALL_VIA_SD_LONG_ARG,
      aliases = { INSTALL_VIA_SD_SHORT_ARG },
      usage = "Copy package to external storage (SD) instead of /data/local/tmp before installing.")
  private boolean installViaSd = false;

  @Option(
      name = ACTIVITY_LONG_ARG,
      aliases = { ACTIVITY_SHORT_ARG },
      metaVar = "<pkg/activity>",
      usage = "Activity to launch e.g. com.facebook.katana/.LoginActivity. Implies -r.")
  @Nullable
  private String activity = null;

  public AdbOptions adbOptions() {
    return adbOptions;
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions;
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public boolean shouldUninstallFirst() {
    return uninstallFirst;
  }

  public boolean shouldStartActivity() {
    return (activity != null) || run;
  }

  public boolean shouldInstallViaSd() {
    return installViaSd;
  }

  @Nullable
  public String getActivityToStart() {
    return activity;
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {

    if (getArguments().size() != 1) {
      params.getConsole().getStdErr().println(
          "Must specify exactly one rule.");
      return 1;
    }


    int exitCode = super.runWithoutHelp(params);
    if (exitCode != 0) {
      return exitCode;
    }

    Build build = super.getBuild();
    ActionGraph graph = build.getActionGraph();
    BuildRule buildRule = Preconditions.checkNotNull(
        graph.findBuildRuleByTarget(getBuildTargets().get(0)));

    if (buildRule instanceof InstallableApk) {
      return installApk(
          params,
          (InstallableApk) buildRule,
          build.getExecutionContext());
    } else if (buildRule instanceof AppleBundle) {
      AppleBundle appleBundle = (AppleBundle) buildRule;
      params.getBuckEventBus().post(InstallEvent.started(appleBundle.getBuildTarget()));
      exitCode = installAppleBundle(
          params,
          appleBundle,
          build.getExecutionContext().getProjectFilesystem(),
          build.getExecutionContext().getProcessExecutor());
      params.getBuckEventBus().post(
          InstallEvent.finished(appleBundle.getBuildTarget(), exitCode == 0));
      return exitCode;
    } else {
      params.getConsole().printBuildFailure(String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() or " +
              "apple_bundle() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
  }

  private int installApk(
      CommandRunnerParams params,
      InstallableApk installableApk,
      ExecutionContext executionContext) throws IOException, InterruptedException {
    final AdbHelper adbHelper = new AdbHelper(
        adbOptions(),
        targetDeviceOptions(),
        executionContext,
        params.getConsole(),
        params.getBuckEventBus(),
        params.getBuckConfig());


    if (shouldUninstallFirst()) {
      String packageName = AdbHelper.tryToExtractPackageNameFromManifest(
          installableApk,
          executionContext);
      adbHelper.uninstallApp(packageName, uninstallOptions());

    }

    boolean installSuccess;
    Optional<ExopackageInfo> exopackageInfo = installableApk.getExopackageInfo();
    if (exopackageInfo.isPresent()) {
      installSuccess = new ExopackageInstaller(
          executionContext,
          adbHelper,
          installableApk)
          .install();
    } else {
      installSuccess = adbHelper.installApk(installableApk, this);
    }
    if (!installSuccess) {
      return 1;
    }



    if (shouldStartActivity()) {
      int exitCode = adbHelper.startActivity(installableApk, getActivityToStart());
      if (exitCode != 0) {
        return exitCode;
      }
    }

    return 0;
  }

  private int installAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor) throws IOException, InterruptedException {


    AppleConfig appleConfig = new AppleConfig(params.getBuckConfig());
    Optional<Path> xcodeDeveloperPath = appleConfig.getAppleDeveloperDirectorySupplier(
        processExecutor).get();
    if (!xcodeDeveloperPath.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (Xcode not found)", appleBundle.getFullyQualifiedName()));
      return 1;
    }

    UnixUserIdFetcher userIdFetcher = new UnixUserIdFetcher();
    AppleCoreSimulatorServiceController appleCoreSimulatorServiceController =
        new AppleCoreSimulatorServiceController(processExecutor);

    Optional<Path> coreSimulatorServicePath =
        appleCoreSimulatorServiceController.getCoreSimulatorServicePath(userIdFetcher);

    boolean shouldWaitForSimulatorsToShutdown = false;

    if (!coreSimulatorServicePath.isPresent() ||
        !coreSimulatorServicePath.get().toRealPath().startsWith(
            xcodeDeveloperPath.get().toRealPath())) {
      LOG.warn(
          "Core simulator service path %s does not match developer directory %s, " +
          "killing all simulators.",
          coreSimulatorServicePath,
          xcodeDeveloperPath.get());
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return 1;
      }

      shouldWaitForSimulatorsToShutdown = true;
    }

    Path simctlPath = xcodeDeveloperPath.get().resolve("usr/bin/simctl");
    Optional<AppleSimulator> appleSimulator = getAppleSimulatorForBundle(
        appleBundle,
        processExecutor,
        simctlPath);

    if (!appleSimulator.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (no appropriate simulator found)",
              appleBundle.getFullyQualifiedName()));
      return 1;
    }

    Path iosSimulatorPath = xcodeDeveloperPath.get().resolve("Applications/iOS Simulator.app");
    AppleSimulatorController appleSimulatorController = new AppleSimulatorController(
        processExecutor,
        simctlPath,
        iosSimulatorPath);

    if (!appleSimulatorController.canStartSimulator(appleSimulator.get().getUdid())) {
      LOG.warn("Cannot start simulator %s, killing simulators and trying again.");
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return 1;
      }

      shouldWaitForSimulatorsToShutdown = true;


      appleSimulator = getAppleSimulatorForBundle(appleBundle, processExecutor, simctlPath);
      if (!appleSimulator.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (no appropriate simulator found)",
                appleBundle.getFullyQualifiedName()));
        return 1;
      }
    }

    long remainingMillis = APPLE_SIMULATOR_WAIT_MILLIS;
    if (shouldWaitForSimulatorsToShutdown) {
      Optional<Long> shutdownMillis = appleSimulatorController.waitForSimulatorsToShutdown(
          remainingMillis);
      if (!shutdownMillis.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (simulators did not shut down within %d ms).",
                appleBundle.getFullyQualifiedName(),
                APPLE_SIMULATOR_WAIT_MILLIS));
        return 1;
      }

      LOG.debug("Simulators shut down in %d millis.", shutdownMillis.get());
      remainingMillis -= shutdownMillis.get();
    }

    LOG.debug("Starting up simulator %s", appleSimulator.get());

    Optional<Long> startMillis = appleSimulatorController.startSimulator(
        appleSimulator.get().getUdid(),
        remainingMillis);

    if (!startMillis.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not start simulator %s within %d ms)",
              appleBundle.getFullyQualifiedName(),
              appleSimulator.get().getName(),
              APPLE_SIMULATOR_WAIT_MILLIS));
      return 1;
    }

    LOG.debug(
        "Simulator started in %d ms. Installing Apple bundle %s in simulator %s",
        startMillis.get(),
        appleBundle,
        appleSimulator.get());

    if (!appleSimulatorController.installBundleInSimulator(
            appleSimulator.get().getUdid(),
            projectFilesystem.resolve(appleBundle.getPathToOutput()))) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not install bundle %s in simulator %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getPathToOutput(),
              appleSimulator.get().getName()));
      return 1;
    }

    if (run) {
      return launchAppleBundle(
          params,
          appleBundle,
          appleSimulatorController,
          projectFilesystem,
          appleSimulator.get());
    } else {
      params.getConsole().printSuccess(
          String.format(
              "Successfully installed %s. (Use `buck install -r %s` to run.)",
              getArguments().get(0),
              getArguments().get(0)));
      return 0;
    }
  }

  private int launchAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      AppleSimulatorController appleSimulatorController,
      ProjectFilesystem projectFilesystem,
      AppleSimulator appleSimulator) throws IOException, InterruptedException {

    LOG.debug("Launching Apple bundle %s in simulator %s", appleBundle, appleSimulator);

    Optional<String> appleBundleId;
    try (InputStream bundlePlistStream =
             projectFilesystem.getInputStreamForRelativePath(appleBundle.getInfoPlistPath())){
        appleBundleId = AppleInfoPlistParsing.getBundleIdFromPlistStream(bundlePlistStream);
    }
    if (!appleBundleId.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not get bundle ID from %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getInfoPlistPath()));
      return 1;
    }

    Optional<Long> launchedPid = appleSimulatorController.launchInstalledBundleInSimulator(
        appleSimulator.getUdid(),
        appleBundleId.get(),
        waitForDebugger ? AppleSimulatorController.LaunchBehavior.WAIT_FOR_DEBUGGER :
            AppleSimulatorController.LaunchBehavior.DO_NOT_WAIT_FOR_DEBUGGER);
    if (!launchedPid.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot launch %s (failed to launch bundle ID %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundleId.get()));
      return 1;
    }

    params.getConsole().printSuccess(
        String.format(
            "Successfully launched %s%s. To debug, run: lldb -p %d",
            getArguments().get(0),
            waitForDebugger ? " (waiting for debugger)" : "",
            launchedPid.get()));

    return 0;
  }

  private Optional<AppleSimulator> getAppleSimulatorForBundle(
      AppleBundle appleBundle,
      ProcessExecutor processExecutor,
      Path simctlPath) throws IOException, InterruptedException {
    LOG.debug("Choosing simulator for %s", appleBundle);

    for (AppleSimulator simulator : AppleSimulatorDiscovery.discoverAppleSimulators(
             processExecutor,
             simctlPath)) {


      if (simulator.getName().equals("iPhone 5s")) {
        return Optional.of(simulator);
      }
    }

    return Optional.<AppleSimulator>absent();
  }

  @Override
  public String getShortDescription() {
    return "builds and installs an application";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.event.AbstractBuckEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.LeafEvent;
import com.google.common.base.Objects;

@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class UninstallEvent extends AbstractBuckEvent implements LeafEvent {
  private final String packageName;

  public UninstallEvent(String packageName) {
    this.packageName = packageName;
  }

  public String getPackageName() {
    return packageName;
  }

  @Override
  public String getCategory() {
    return "uninstall_apk";
  }

  @Override
  protected String getValueString() {
    return packageName;
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof UninstallEvent)) {
      return false;
    }

    UninstallEvent that = (UninstallEvent) event;

    return Objects.equal(getPackageName(), that.getPackageName());
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(getPackageName());
  }

  public static Started started(String packageName) {
    return new Started(packageName);
  }

  public static Finished finished(String packageName, boolean success) {
    return new Finished(packageName, success);
  }

  public static class Started extends UninstallEvent {
    protected Started(String packageName) {
      super(packageName);
    }

    @Override
    public String getEventName() {
      return "UninstallStarted";
    }
  }

  public static class Finished extends UninstallEvent {
    private final boolean success;

    protected Finished(String packageName, boolean success) {
      super(packageName);

      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "UninstallFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getPackageName(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.event.AbstractBuckEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.LeafEvent;
import com.facebook.buck.model.BuildTarget;
import com.google.common.base.Objects;


@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class StartActivityEvent extends AbstractBuckEvent implements LeafEvent {
  private final BuildTarget buildTarget;
  private final String activityName;

  protected StartActivityEvent(BuildTarget buildTarget, String activityName) {
    this.buildTarget = buildTarget;
    this.activityName = activityName;
  }

  public BuildTarget getBuildTarget() {
    return buildTarget;
  }

  public String getActivityName() {
    return activityName;
  }

  @Override
  public String getCategory() {
    return "start_activity";
  }

  @Override
  protected String getValueString() {
    return String.format("%s %s", getBuildTarget().getFullyQualifiedName(), getActivityName());
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof StartActivityEvent)) {
      return false;
    }

    StartActivityEvent that = (StartActivityEvent) event;

    return Objects.equal(getBuildTarget(), that.getBuildTarget()) &&
        Objects.equal(getActivityName(), that.getActivityName());
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(getActivityName(), getBuildTarget());
  }

  public static Started started(BuildTarget buildTarget, String activityName) {
    return new Started(buildTarget, activityName);
  }

  public static Finished finished(BuildTarget buildTarget, String activityName, boolean success) {
    return new Finished(buildTarget, activityName, success);
  }

  public static class Started extends StartActivityEvent {
    protected Started(BuildTarget buildTarget, String activityName) {
      super(buildTarget, activityName);
    }

    @Override
    public String getEventName() {
      return "StartActivityStarted";
    }
  }

  public static class Finished extends StartActivityEvent {
    private final boolean success;

    protected Finished(BuildTarget buildTarget, String activityName, boolean success) {
      super(buildTarget, activityName);
      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "StartActivityFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getActivityName(), getBuildTarget(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.google.common.annotations.VisibleForTesting;

import org.kohsuke.args4j.Option;

public class AdbOptions {

  @VisibleForTesting static final String ADB_THREADS_LONG_ARG = "--adb-threads";
  @VisibleForTesting static final String ADB_THREADS_SHORT_ARG = "-T";

  @Option(
      name = ADB_THREADS_LONG_ARG,
      aliases = { ADB_THREADS_SHORT_ARG },
      usage = "Number of threads to use for adb operations. " +
              "Defaults to number of connected devices.")
  private int adbThreadCount = 0;

  @VisibleForTesting static final String MULTI_INSTALL_MODE_SHORT_ARG = "-x";
  @VisibleForTesting static final String MULTI_INSTALL_MODE_LONG_ARG = "-all";
  @Option(
      name = MULTI_INSTALL_MODE_LONG_ARG,
      aliases =  {MULTI_INSTALL_MODE_SHORT_ARG},
      usage = "Install .apk on all connected devices and/or emulators (multi-install mode)"
  )
  private boolean multiInstallMode;

  public int getAdbThreadCount() {
    return adbThreadCount;
  }

  public boolean isMultiInstallModeEnabled() {
    return multiInstallMode;
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.Pair;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphToActionGraph;
import com.facebook.buck.rules.TargetGraphTransformer;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.List;

public class UninstallCommand extends AbstractCommand {

  public static class UninstallOptions {
    @VisibleForTesting static final String KEEP_LONG_ARG = "--keep";
    @VisibleForTesting static final String KEEP_SHORT_ARG = "-k";
    @Option(
        name = KEEP_LONG_ARG,
        aliases = { KEEP_SHORT_ARG },
        usage = "Keep user data when uninstalling.")
    private boolean keepData = false;

    public boolean shouldKeepUserData() {
      return keepData;
    }
  }

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceOptions deviceOptions;

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public AdbOptions adbOptions() {
    return adbOptions;
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions;
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {


    ActionGraph actionGraph;
    ImmutableSet<BuildTarget> buildTargets;
    try {
      Pair<ImmutableSet<BuildTarget>, TargetGraph> result = params.getParser()
          .buildTargetGraphForTargetNodeSpecs(
              parseArgumentsAsTargetNodeSpecs(
                  params.getBuckConfig(),
                  params.getRepository().getFilesystem().getIgnorePaths(),
                  getArguments()),
              new ParserConfig(params.getBuckConfig()),
              params.getBuckEventBus(),
              params.getConsole(),
              params.getEnvironment(),
              getEnableProfiling());
      buildTargets = result.getFirst();
      TargetGraphTransformer<ActionGraph> targetGraphTransformer = new TargetGraphToActionGraph(
          params.getBuckEventBus(),
          new BuildTargetNodeToBuildRuleTransformer(),
          params.getFileHashCache());
      actionGraph = targetGraphTransformer.apply(result.getSecond());
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }


    if (buildTargets.size() != 1) {
      params.getConsole().getStdErr().println("Must specify exactly one android_binary() rule.");
      return 1;
    }
    BuildTarget buildTarget = Iterables.get(buildTargets, 0);


    BuildRule buildRule = Preconditions.checkNotNull(
        actionGraph.findBuildRuleByTarget(buildTarget));
    if (!(buildRule instanceof InstallableApk)) {
      params.getConsole().printBuildFailure(
          String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
    InstallableApk installableApk = (InstallableApk) buildRule;


    try (ExecutionContext context = createExecutionContext(params)) {
      final AdbHelper adbHelper = new AdbHelper(
          adbOptions(),
          targetDeviceOptions(),
          context,
          params.getConsole(),
          params.getBuckEventBus(),
          params.getBuckConfig());


      String appId = AdbHelper.tryToExtractPackageNameFromManifest(installableApk, context);
      return adbHelper.uninstallApp(
          appId,
          uninstallOptions()
      ) ? 0 : 1;
    }
  }

  @Override
  public String getShortDescription() {
    return "uninstalls an APK";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.cli;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.facebook.buck.android.agent.util.AgentUtil;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.ExopackageInfo;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.NamedTemporaryFile;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Splitter;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class ExopackageInstaller {

  private static final Logger LOG = Logger.get(ExopackageInstaller.class);


  private static final String AGENT_DEVICE_PATH = "/data/app/" + AgentUtil.AGENT_PACKAGE_NAME;


  private static final String JAVA_AGENT_COMMAND =
      "dalvikvm -classpath " +
      AGENT_DEVICE_PATH + "-1.apk:" + AGENT_DEVICE_PATH + "-2.apk:" +
      AGENT_DEVICE_PATH + "-1/base.apk:" + AGENT_DEVICE_PATH + "-2/base.apk " +
      "com.facebook.buck.android.agent.AgentMain ";


  private static final int MAX_ADB_COMMAND_SIZE = 1019;

  private static final Path SECONDARY_DEX_DIR = Paths.get("secondary-dex");

  private static final Path NATIVE_LIBS_DIR = Paths.get("native-libs");

  @VisibleForTesting
  static final Pattern DEX_FILE_PATTERN = Pattern.compile("secondary-([0-9a-f]+)\\.[\\w.-]*");

  @VisibleForTesting
  static final Pattern NATIVE_LIB_PATTERN = Pattern.compile("native-([0-9a-f]+)\\.so");

  private final ProjectFilesystem projectFilesystem;
  private final BuckEventBus eventBus;
  private final AdbHelper adbHelper;
  private final InstallableApk apkRule;
  private final String packageName;
  private final Path dataRoot;

  private final ExopackageInfo exopackageInfo;


  private final AtomicInteger nextAgentPort = new AtomicInteger(2828);

  @VisibleForTesting
  static class PackageInfo {
    final String apkPath;
    final String nativeLibPath;
    final String versionCode;
    private PackageInfo(String apkPath, String nativeLibPath, String versionCode) {
      this.nativeLibPath = nativeLibPath;
      this.apkPath = apkPath;
      this.versionCode = versionCode;
    }
  }

  public ExopackageInstaller(
      ExecutionContext context,
      AdbHelper adbHelper,
      InstallableApk apkRule) {
    this.adbHelper = adbHelper;
    this.projectFilesystem = context.getProjectFilesystem();
    this.eventBus = context.getBuckEventBus();
    this.apkRule = apkRule;
    this.packageName = AdbHelper.tryToExtractPackageNameFromManifest(apkRule, context);
    this.dataRoot = Paths.get("/data/local/tmp/exopackage/").resolve(packageName);

    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    Optional<ExopackageInfo> exopackageInfo = apkRule.getExopackageInfo();
    Preconditions.checkArgument(exopackageInfo.isPresent());
    this.exopackageInfo = exopackageInfo.get();
  }


  public synchronized boolean install() throws InterruptedException {
    eventBus.post(InstallEvent.started(apkRule.getBuildTarget()));

    boolean success = adbHelper.adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            try {
              return new SingleDeviceInstaller(device, nextAgentPort.getAndIncrement()).doInstall();
            } catch (Exception e) {
              throw new RuntimeException("Failed to install exopackage on " + device, e);
            }
          }

          @Override
          public String toString() {
            return "install exopackage";
          }
        });

    eventBus.post(InstallEvent.finished(apkRule.getBuildTarget(), success));
    return success;
  }


  private class SingleDeviceInstaller {


    private final IDevice device;


    private final int agentPort;


    private boolean useNativeAgent = true;


    @Nullable
    private String nativeAgentPath;

    private SingleDeviceInstaller(IDevice device, int agentPort) {
      this.device = device;
      this.agentPort = agentPort;
    }

    boolean doInstall() throws Exception {
      Optional<PackageInfo> agentInfo = installAgentIfNecessary();
      if (!agentInfo.isPresent()) {
        return false;
      }

      nativeAgentPath = agentInfo.get().nativeLibPath;
      determineBestAgent();

      final File apk = apkRule.getApkPath().toFile();

      final boolean installViaSd = false;

      if (shouldAppBeInstalled()) {
        try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "install_exo_apk")) {
          boolean success = adbHelper.installApkOnDevice(device, apk, installViaSd);
          if (!success) {
            return false;
          }
        }
      }

      if (exopackageInfo.getDexInfo().isPresent()) {
        installSecondaryDexFiles();
      }

      if (exopackageInfo.getNativeLibsInfo().isPresent()) {
        installNativeLibraryFiles();
      }


      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "kill_app")) {
        AdbHelper.executeCommandWithErrorChecking(device, "am force-stop " + packageName);
      }

      return true;
    }

    private void installSecondaryDexFiles() throws Exception {
      final ImmutableMap<String, Path> hashToSources = getRequiredDexFiles();
      final ImmutableSet<String> requiredHashes = hashToSources.keySet();
      final ImmutableSet<String> presentHashes = prepareSecondaryDexDir(requiredHashes);
      final Set<String> hashesToInstall = Sets.difference(requiredHashes, presentHashes);

      Map<String, Path> filesToInstallByHash =
          Maps.filterKeys(hashToSources, Predicates.in(hashesToInstall));









      String metadataContents = com.google.common.io.Files.toString(
          exopackageInfo.getDexInfo().get().getMetadata().toFile(),
          Charsets.UTF_8)
          .replaceAll(
              "secondary-(\\d+)\\.dex\\.jar (\\p{XDigit}{40}) ",
              "secondary-$2.dex.jar $2 ");

      installFiles(
          "secondary_dex",
          ImmutableMap.copyOf(filesToInstallByHash),
          metadataContents,
          "secondary-%s.dex.jar",
          SECONDARY_DEX_DIR);
    }

    private ImmutableList<String> getDeviceAbis() throws Exception {
      ImmutableList.Builder<String> abis = ImmutableList.builder();

      String abiListProperty = getProperty("ro.product.cpu.abilist");
      if (!abiListProperty.isEmpty()) {
        abis.addAll(Splitter.on(',').splitToList(abiListProperty));
      } else {
        String abi1 = getProperty("ro.product.cpu.abi");
        if (abi1.isEmpty()) {
          throw new RuntimeException("adb returned empty result for ro.product.cpu.abi property.");
        }

        abis.add(abi1);
        String abi2 = getProperty("ro.product.cpu.abi2");
        if (!abi2.isEmpty()) {
          abis.add(abi2);
        }
      }

      return abis.build();
    }

    private void installNativeLibraryFiles() throws Exception {
      ImmutableMultimap<String, Path> allLibraries = getAllLibraries();
      ImmutableSet.Builder<String> providedLibraries = ImmutableSet.builder();
      for (String abi : getDeviceAbis()) {
        ImmutableMap<String, Path> libraries =
            getRequiredLibrariesForAbi(allLibraries, abi, providedLibraries.build());

        installNativeLibrariesForAbi(abi, libraries);
        providedLibraries.addAll(libraries.keySet());
      }
    }

    private void installNativeLibrariesForAbi(String abi, ImmutableMap<String, Path> libraries)
        throws Exception {
      if (libraries.isEmpty()) {
        return;
      }

      ImmutableSet<String> requiredHashes = libraries.keySet();
      ImmutableSet<String> presentHashes = prepareNativeLibsDir(abi, requiredHashes);

      Map<String, Path> filesToInstallByHash =
          Maps.filterKeys(libraries, Predicates.not(Predicates.in(presentHashes)));

      String metadataContents = Joiner.on('\n').join(
          FluentIterable.from(libraries.entrySet()).transform(
              new Function<Map.Entry<String, Path>, String>() {
                @Override
                public String apply(Map.Entry<String, Path> input) {
                  String hash = input.getKey();
                  String filename = input.getValue().getFileName().toString();
                  int index = filename.indexOf('.');
                  String libname = index == -1 ? filename : filename.substring(0, index);
                  return String.format("%s native-%s.so", libname, hash);
                }
              }));

      installFiles(
          "native_library",
          ImmutableMap.copyOf(filesToInstallByHash),
          metadataContents,
          "native-%s.so",
          NATIVE_LIBS_DIR.resolve(abi));
    }


    private void determineBestAgent() throws Exception {
      String value = getProperty("ro.build.version.sdk");
      try {
        if (Integer.valueOf(value.trim()) > 19) {
          useNativeAgent = false;
        }
      } catch (NumberFormatException exn) {
        useNativeAgent = false;
      }
    }

    private String getAgentCommand() {
      if (useNativeAgent) {
        return nativeAgentPath + "/libagent.so ";
      } else {
        return JAVA_AGENT_COMMAND;
      }
    }

    private Optional<PackageInfo> getPackageInfo(final String packageName) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(
          eventBus,
          "get_package_info",
          ImmutableMap.of("package", packageName))) {


        String lines = AdbHelper.executeCommandWithErrorChecking(
            device, "dumpsys package " + packageName);

        return parsePackageInfo(packageName, lines);
      }
    }


    private Optional<PackageInfo> installAgentIfNecessary() throws Exception {
      Optional<PackageInfo> agentInfo = getPackageInfo(AgentUtil.AGENT_PACKAGE_NAME);
      if (!agentInfo.isPresent()) {
        LOG.debug("Agent not installed.  Installing.");
        return installAgentApk();
      }
      LOG.debug("Agent version: %s", agentInfo.get().versionCode);
      if (!agentInfo.get().versionCode.equals(AgentUtil.AGENT_VERSION_CODE)) {


        uninstallAgent();
        return installAgentApk();
      }
      return agentInfo;
    }

    private void uninstallAgent() throws InstallException {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "uninstall_old_agent")) {
        device.uninstallPackage(AgentUtil.AGENT_PACKAGE_NAME);
      }
    }

    private Optional<PackageInfo> installAgentApk() throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "install_agent_apk")) {
        String apkFileName = System.getProperty("buck.android_agent_path");
        if (apkFileName == null) {
          throw new RuntimeException("Android agent apk path not specified in properties");
        }
        File apkPath = new File(apkFileName);
        boolean success = adbHelper.installApkOnDevice(device, apkPath,  false);
        if (!success) {
          return Optional.absent();
        }
        return getPackageInfo(AgentUtil.AGENT_PACKAGE_NAME);
      }
    }

    private boolean shouldAppBeInstalled() throws Exception {
      Optional<PackageInfo> appPackageInfo = getPackageInfo(packageName);
      if (!appPackageInfo.isPresent()) {
        eventBus.post(ConsoleEvent.info("App not installed.  Installing now."));
        return true;
      }

      LOG.debug("App path: %s", appPackageInfo.get().apkPath);
      String installedAppSignature = getInstalledAppSignature(appPackageInfo.get().apkPath);
      String localAppSignature = AgentUtil.getJarSignature(apkRule.getApkPath().toString());
      LOG.debug("Local app signature: %s", localAppSignature);
      LOG.debug("Remote app signature: %s", installedAppSignature);

      if (!installedAppSignature.equals(localAppSignature)) {
        LOG.debug("App signatures do not match.  Must re-install.");
        return true;
      }

      LOG.debug("App signatures match.  No need to install.");
      return false;
    }

    private String getInstalledAppSignature(final String packagePath) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "get_app_signature")) {
        String command = getAgentCommand() + "get-signature " + packagePath;
        LOG.debug("Executing %s", command);
        String output = AdbHelper.executeCommandWithErrorChecking(device, command);

        String result = output.trim();
        if (result.contains("\n") || result.contains("\r")) {
          throw new IllegalStateException("Unexpected return from get-signature:\n" + output);
        }

        return result;
      }
    }

    private ImmutableMap<String, Path> getRequiredDexFiles() throws IOException {
      ExopackageInfo.DexInfo dexInfo = exopackageInfo.getDexInfo().get();
      ImmutableMultimap<String, Path> multimap = parseExopackageInfoMetadata(
          dexInfo.getMetadata(),
          dexInfo.getDirectory(),
          projectFilesystem);

      ImmutableMap.Builder<String, Path> builder = ImmutableMap.builder();
      for (Map.Entry<String, Path> entry : multimap.entries()) {
        builder.put(entry);
      }
      return builder.build();
    }

    private ImmutableSet<String> prepareSecondaryDexDir(ImmutableSet<String> requiredHashes)
        throws Exception {
      return prepareDirectory("secondary-dex", DEX_FILE_PATTERN, requiredHashes);
    }

    private ImmutableSet<String> prepareNativeLibsDir(
        String abi,
        ImmutableSet<String> requiredHashes) throws Exception {
      return prepareDirectory("native-libs/" + abi, NATIVE_LIB_PATTERN, requiredHashes);
    }

    private ImmutableSet<String> prepareDirectory(
        String dirname,
        Pattern filePattern,
        ImmutableSet<String> requiredHashes) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "prepare_" + dirname)) {
        String dirPath = dataRoot.resolve(dirname).toString();
        mkDirP(dirPath);

        String output = AdbHelper.executeCommandWithErrorChecking(device, "ls " + dirPath);

        ImmutableSet.Builder<String> foundHashes = ImmutableSet.builder();
        ImmutableSet.Builder<String> filesToDelete = ImmutableSet.builder();

        processLsOutput(output, filePattern, requiredHashes, foundHashes, filesToDelete);

        String commandPrefix = "cd " + dirPath + " && rm ";

        final int overhead = commandPrefix.length() + 100;
        for (List<String> rmArgs :
            chunkArgs(filesToDelete.build(), MAX_ADB_COMMAND_SIZE - overhead)) {
          String command = commandPrefix + Joiner.on(' ').join(rmArgs);
          LOG.debug("Executing %s", command);
          AdbHelper.executeCommandWithErrorChecking(device, command);
        }

        return foundHashes.build();
      }
    }

    private void installFiles(
        String filesType,
        ImmutableMap<String, Path> filesToInstallByHash,
        String metadataFileContents,
        String filenameFormat,
        Path destinationDirRelativeToDataRoot) throws Exception {
      try (TraceEventLogger ignored1 =
               TraceEventLogger.start(eventBus, "multi_install_" + filesType)) {
        device.createForward(agentPort, agentPort);
        try {
          for (Map.Entry<String, Path> entry : filesToInstallByHash.entrySet()) {
            Path destination = destinationDirRelativeToDataRoot.resolve(
                String.format(filenameFormat, entry.getKey()));
            Path source = entry.getValue();

            try (TraceEventLogger ignored2 =
                     TraceEventLogger.start(eventBus, "install_" + filesType)) {
              installFile(device, agentPort, destination, source);
            }
          }
          try (TraceEventLogger ignored3 =
                   TraceEventLogger.start(eventBus, "install_" + filesType + "_metadata")) {
            try (NamedTemporaryFile temp = new NamedTemporaryFile("metadata", "tmp")) {
              com.google.common.io.Files.write(
                  metadataFileContents.getBytes(Charsets.UTF_8),
                  temp.get().toFile());
              installFile(
                  device,
                  agentPort,
                  destinationDirRelativeToDataRoot.resolve("metadata.txt"),
                  temp.get());
            }
          }
        } finally {
          try {
            device.removeForward(agentPort, agentPort);
          } catch (AdbCommandRejectedException e) {
            LOG.warn(e, "Failed to remove adb forward on port %d for device %s", agentPort, device);
            eventBus.post(
                ConsoleEvent.warning(
                    "Failed to remove adb forward %d. This is not necessarily a problem\n" +
                        "because it will be recreated during the next exopackage installation.\n" +
                        "See the log for the full exception.",
                    agentPort));
          }
        }
      }
    }

    private void installFile(
        IDevice device,
        final int port,
        Path pathRelativeToDataRoot,
        final Path source) throws Exception {
      CollectingOutputReceiver receiver = new CollectingOutputReceiver() {

        private boolean sentPayload = false;

        @Override
        public void addOutput(byte[] data, int offset, int length) {
          super.addOutput(data, offset, length);
          if (!sentPayload && getOutput().length() >= AgentUtil.TEXT_SECRET_KEY_SIZE) {
            LOG.verbose("Got key: %s", getOutput().trim());

            sentPayload = true;
            try (Socket clientSocket = new Socket("localhost", port)) {
              LOG.verbose("Connected");
              OutputStream outToDevice = clientSocket.getOutputStream();
              outToDevice.write(
                  getOutput().substring(
                      0,
                      AgentUtil.TEXT_SECRET_KEY_SIZE).getBytes());
              LOG.verbose("Wrote key");
              com.google.common.io.Files.asByteSource(source.toFile()).copyTo(outToDevice);
              LOG.verbose("Wrote file");
            } catch (IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
      };

      String targetFileName = dataRoot.resolve(pathRelativeToDataRoot).toString();
      String command =
          "umask 022 && " +
              getAgentCommand() +
              "receive-file " + port + " " + Files.size(source) + " " +
              targetFileName +
              " ; echo -n :$?";
      LOG.debug("Executing %s", command);



      Exception shellException = null;
      try {
        device.executeShellCommand(command, receiver);
      } catch (Exception e) {
        shellException = e;
      }

      try {
        AdbHelper.checkReceiverOutput(command, receiver);
      } catch (Exception e) {
        if (shellException != null) {
          e.addSuppressed(shellException);
        }
        throw e;
      }

      if (shellException != null) {
        throw shellException;
      }






      AdbHelper.executeCommandWithErrorChecking(device, "chmod 644 " + targetFileName);
    }

    private String getProperty(String property) throws Exception {
      return AdbHelper.executeCommandWithErrorChecking(device, "getprop " + property).trim();
    }

    private void mkDirP(String dirpath) throws Exception {



      String mkdirP = useNativeAgent ? getAgentCommand() + "mkdir-p" : "mkdir -p";

      AdbHelper.executeCommandWithErrorChecking(device, "umask 022 && " + mkdirP + " " + dirpath);
    }
  }

  private ImmutableMultimap<String, Path> getAllLibraries() throws IOException {
    ExopackageInfo.NativeLibsInfo nativeLibsInfo = exopackageInfo.getNativeLibsInfo().get();
    return parseExopackageInfoMetadata(
        nativeLibsInfo.getMetadata(),
        nativeLibsInfo.getDirectory(),
        projectFilesystem);
  }

  private ImmutableMap<String, Path> getRequiredLibrariesForAbi(
      ImmutableMultimap<String, Path> allLibraries,
      String abi,
      ImmutableSet<String> ignoreLibraries) throws IOException {
    return filterLibrariesForAbi(
        exopackageInfo.getNativeLibsInfo().get().getDirectory(),
        allLibraries,
        abi,
        ignoreLibraries);
  }

  @VisibleForTesting
  static ImmutableMap<String, Path> filterLibrariesForAbi(
      Path nativeLibsDir,
      ImmutableMultimap<String, Path> allLibraries,
      String abi,
      ImmutableSet<String> ignoreLibraries) {
    ImmutableMap.Builder<String, Path> filteredLibraries = ImmutableMap.builder();
    for (Map.Entry<String, Path> entry : allLibraries.entries()) {
      Path relativePath = nativeLibsDir.relativize(entry.getValue());
      Preconditions.checkState(relativePath.getNameCount() == 2);
      String libAbi = relativePath.getParent().toString();
      String libName = relativePath.getFileName().toString();
      if (libAbi.equals(abi) && !ignoreLibraries.contains(libName)) {
        filteredLibraries.put(entry);
      }
    }
    return filteredLibraries.build();
  }


  @VisibleForTesting
  static ImmutableMultimap<String, Path> parseExopackageInfoMetadata(
      Path metadataTxt,
      Path resolvePathAgainst,
      ProjectFilesystem filesystem) throws IOException {
    ImmutableMultimap.Builder<String, Path> builder = ImmutableMultimap.builder();
    for (String line : filesystem.readLines(metadataTxt)) {
      List<String> parts = Splitter.on(' ').splitToList(line);
      if (parts.size() < 2) {
        throw new RuntimeException("Illegal line in metadata file: " + line);
      }
      builder.put(parts.get(1), resolvePathAgainst.resolve(parts.get(0)));
    }
    return builder.build();
  }

  @VisibleForTesting
  static Optional<PackageInfo> parsePackageInfo(String packageName, String lines) {
    final String packagePrefix = "  Package [" + packageName + "] (";
    final String otherPrefix = "  Package [";
    boolean sawPackageLine = false;
    final Splitter splitter = Splitter.on('=').limit(2);

    String codePath = null;
    String resourcePath = null;
    String nativeLibPath = null;
    String versionCode = null;

    for (String line : Splitter.on("\r\n").split(lines)) {

      if (line.startsWith(packagePrefix)) {
        sawPackageLine = true;
        continue;
      }

      if (line.startsWith(otherPrefix)) {
        break;
      }

      if (!sawPackageLine) {
        continue;
      }

      List<String> parts = splitter.splitToList(line.trim());
      if (parts.size() != 2) {
        continue;
      }
      switch (parts.get(0)) {
        case "codePath":
          codePath = parts.get(1);
          break;
        case "resourcePath":
          resourcePath = parts.get(1);
          break;
        case "nativeLibraryPath":
          nativeLibPath = parts.get(1);
          break;



        case "legacyNativeLibraryDir":
          nativeLibPath = parts.get(1);
          break;
        case "versionCode":

          versionCode = parts.get(1).split(" ", 2)[0];
          break;
        default:
          break;
      }
    }

    if (!sawPackageLine) {
      return Optional.absent();
    }

    Preconditions.checkNotNull(codePath, "Could not find codePath");
    Preconditions.checkNotNull(resourcePath, "Could not find resourcePath");
    Preconditions.checkNotNull(nativeLibPath, "Could not find nativeLibraryPath");
    Preconditions.checkNotNull(versionCode, "Could not find versionCode");
    if (!codePath.equals(resourcePath)) {
      throw new IllegalStateException("Code and resource path do not match");
    }


    if (!codePath.endsWith(".apk")) {
      codePath += "/base.apk";
    }

    return Optional.of(new PackageInfo(codePath, nativeLibPath, versionCode));
  }


  @VisibleForTesting
  static void processLsOutput(
      String output,
      Pattern filePattern,
      ImmutableSet<String> requiredHashes,
      ImmutableSet.Builder<String> foundHashes,
      ImmutableSet.Builder<String> toDelete) {
    for (String line : Splitter.on("\r\n").omitEmptyStrings().split(output)) {
      if (line.equals("lock")) {
        continue;
      }

      Matcher m = filePattern.matcher(line);
      if (m.matches()) {
        if (requiredHashes.contains(m.group(1))) {
          foundHashes.add(m.group(1));
        } else {
          toDelete.add(line);
        }
      } else {
        toDelete.add(line);
      }
    }
  }


  @VisibleForTesting
  static ImmutableList<ImmutableList<String>> chunkArgs(Iterable<String> args, int sizeLimit) {
    ImmutableList.Builder<ImmutableList<String>> topLevelBuilder = ImmutableList.builder();
    ImmutableList.Builder<String> chunkBuilder = ImmutableList.builder();
    int chunkSize = 0;
    for (String arg : args) {
      if (chunkSize + arg.length() > sizeLimit) {
        topLevelBuilder.add(chunkBuilder.build());
        chunkBuilder = ImmutableList.builder();
        chunkSize = 0;
      }


      chunkBuilder.add(arg);
      chunkSize += arg.length();
    }
    ImmutableList<String> tail = chunkBuilder.build();
    if (!tail.isEmpty()) {
      topLevelBuilder.add(tail);
    }
    return topLevelBuilder.build();
  }
}

<code block>

package com.facebook.buck.event.listener;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEventAtTime;
import static org.junit.Assert.assertEquals;

import com.facebook.buck.cli.InstallEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleStatus;
import com.facebook.buck.rules.BuildRuleSuccessType;
import com.facebook.buck.rules.CacheResult;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.timing.IncrementingFakeClock;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.eventbus.EventBus;
import com.google.common.hash.HashCode;

import org.junit.Test;

import java.util.concurrent.TimeUnit;

public class SimpleConsoleEventBusListenerTest {
  @Test
  public void testSimpleBuild() {
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        new SourcePathResolver(new BuildRuleResolver()),
        ImmutableSortedSet.<BuildRule>of());

    SimpleConsoleEventBusListener listener = new SimpleConsoleEventBusListener(console, fakeClock);
    eventBus.register(listener);

    final long threadId = 0;

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            0L,
            TimeUnit.MILLISECONDS,
            threadId));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(buildTargets), 0L, TimeUnit.MILLISECONDS, threadId));

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals("", console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.finished(buildTargets,
            Optional.<TargetGraph>absent()),
            400L,
            TimeUnit.MILLISECONDS,
            threadId));

    final String parsingLine = "[-] PARSING BUCK FILES...FINISHED 0.4s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(fakeRule), 600L, TimeUnit.MILLISECONDS, threadId));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.finished(
                fakeRule,
                BuildRuleStatus.SUCCESS,
                CacheResult.miss(),
                Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
                Optional.<HashCode>absent(),
                Optional.<Long>absent()),
            1000L,
            TimeUnit.MILLISECONDS,
            threadId));
    rawEventBus.post(configureTestEventAtTime(
        BuildEvent.finished(buildArgs, 0), 1234L, TimeUnit.MILLISECONDS, threadId));

    final String buildingLine = "BUILT //banana:stand\n[-] BUILDING...FINISHED 0.8s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        ConsoleEvent.severe("I've made a huge mistake."), 1500L, TimeUnit.MILLISECONDS, threadId));

    final String logLine = "I've made a huge mistake.\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.started(fakeTarget), 2500L, TimeUnit.MILLISECONDS, threadId));

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.finished(fakeTarget, true), 4000L, TimeUnit.MILLISECONDS, threadId));

    final String installLine = "[-] INSTALLING...FINISHED 1.5s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine + installLine,
        console.getTextWrittenToStdErr());
  }

}

<code block>

package com.facebook.buck.event.listener;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEventAtTime;
import static org.junit.Assert.assertEquals;

import com.facebook.buck.cli.InstallEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.httpserver.WebServer;
import com.facebook.buck.json.ProjectBuildFileParseEvents;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleStatus;
import com.facebook.buck.rules.BuildRuleSuccessType;
import com.facebook.buck.rules.CacheResult;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TestRunEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.test.TestCaseSummary;
import com.facebook.buck.test.TestResultSummary;
import com.facebook.buck.test.TestResults;
import com.facebook.buck.test.TestRuleEvent;
import com.facebook.buck.test.result.type.ResultType;
import com.facebook.buck.test.selectors.TestSelectorList;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.timing.IncrementingFakeClock;
import com.facebook.buck.util.FakeProcessExecutor;
import com.facebook.buck.util.environment.DefaultExecutionEnvironment;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.eventbus.EventBus;
import com.google.common.hash.HashCode;

import org.junit.Test;

import java.text.DecimalFormat;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

public class SuperConsoleEventBusListenerTest {
  private static final DecimalFormat timeFormatter = new DecimalFormat("0.0s");


  private static String formatConsoleTimes(String template, Double... time) {
    return String.format(template, (Object[]) FluentIterable.from(ImmutableList.copyOf(time))
        .transform(new Function<Double, String>() {
            @Override
            public String apply(Double input) {
              return timeFormatter.format(input);
            }
          }).toArray(String.class));
  }

  @Test
  public void testSimpleBuild() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    BuildTarget cachedTarget = BuildTargetFactory.newInstance("//chicken:dance");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget, cachedTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());
    FakeBuildRule cachedRule = new FakeBuildRule(
        cachedTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(buildTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(buildTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(fakeRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //banana:stand...  %s (checking local cache)", 0.2)));

    String stepShortName = "doing_something";
    String stepDescription = "working hard";
    UUID stepUuid = UUID.randomUUID();
    rawEventBus.post(configureTestEventAtTime(
        StepEvent.started(stepShortName, stepDescription, stepUuid),
          800L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 900L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.5),
        formatConsoleTimes(" |=> //banana:stand...  %s (running doing_something[%s])", 0.3, 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        StepEvent.finished(stepShortName, stepDescription, stepUuid, 0),
        900L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            fakeRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 1000L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.6),
        " |=> IDLE"));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(cachedRule),
        1010L, TimeUnit.MILLISECONDS,  2L));

    validateConsole(console, listener, 1100L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.7),
        " |=> IDLE",
        formatConsoleTimes(" |=> //chicken:dance...  %s (checking local cache)", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            cachedRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1120L, TimeUnit.MILLISECONDS,  2L));

    rawEventBus.post(configureTestEventAtTime(
        BuildEvent.finished(buildArgs, 0),
        1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(configureTestEventAtTime(
        ConsoleEvent.severe("I've made a huge mistake."),
        1500L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 1600L, ImmutableList.of(parsingLine,
        buildingLine,
        "Log:",
        "I've made a huge mistake."));

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.started(fakeTarget),
        2500L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 3000L, ImmutableList.of(parsingLine,
        buildingLine,
        formatConsoleTimes("[+] INSTALLING...%s", 0.5),
        "Log:",
        "I've made a huge mistake."));

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.finished(fakeTarget, true),
        4000L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 5000L, ImmutableList.of(parsingLine,
        buildingLine,
        formatConsoleTimes("[-] INSTALLING...FINISHED %s", 1.5),
        "Log:",
        "I've made a huge mistake."));

    listener.render();
    String beforeStderrWrite = console.getTextWrittenToStdErr();
    console.getStdErr().print("ROFLCOPTER");
    listener.render();
    assertEquals("After stderr is written to by someone other than SuperConsole, rendering " +
        "should be a noop.",
        beforeStderrWrite + "ROFLCOPTER", console.getTextWrittenToStdErr());
  }

  @Test
  public void testSimpleTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.SUCCESS,
            0L, 
            null, 
            null, 
            null, 
            null); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (1 PASS/0 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes("[-] TESTING...FINISHED %s (1 PASS/0 FAIL)", 1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "RESULTS FOR ALL TESTS",
            "PASS    <100ms  1 Passed   0 Skipped   0 Failed   TestClass",
            "TESTS PASSED"));
  }

  @Test
  public void testSkippedTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.ASSUMPTION_VIOLATION,
            0L, 
            null, 
            null, 
            null, 
            null); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/1 SKIP/0 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes(
        "[-] TESTING...FINISHED %s (0 PASS/1 SKIP/0 FAIL)",
        1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "RESULTS FOR ALL TESTS",
            "ASSUME  <100ms  0 Passed   1 Skipped   0 Failed   TestClass",
            "TESTS PASSED (with some assumption violations)"));
  }

  @Test
  public void testFailingTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.FAILURE,
            0L, 
            "Foo.java:47: Assertion failure: 'foo' != 'bar'", 
            null, 
            "Message on stdout", 
            "Message on stderr"); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/1 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9),
            "Log:",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'"));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes("[-] TESTING...FINISHED %s (0 PASS/1 FAIL)", 1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'",
            "RESULTS FOR ALL TESTS",
            "FAIL    <100ms  0 Passed   0 Skipped   1 Failed   TestClass",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'",
            "====STANDARD OUT====",
            "Message on stdout",
            "====STANDARD ERR====",
            "Message on stderr",
            "TESTS FAILED: 1 FAILURE",
            "Failed target: //:test",
            "FAIL TestClass"));
  }

  @Test
  public void testBuildRuleSuspendResumeEvents() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());
    String stepShortName = "doing_something";
    String stepDescription = "working hard";
    UUID stepUuid = UUID.randomUUID();

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
            Optional.<WebServer>absent());
    eventBus.register(listener);


    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED 0.0s");
    rawEventBus.post(
        configureTestEventAtTime(
            ParseEvent.started(buildTargets),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ParseEvent.finished(buildTargets, Optional.<TargetGraph>absent()),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.started(fakeRule),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(stepShortName, stepDescription, stepUuid),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(stepShortName, stepDescription, stepUuid,  0),
            100L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.suspended(fakeRule),
            100L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        200L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.2),
            " |=> IDLE"));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.resumed(fakeRule),
            300L,
            TimeUnit.MILLISECONDS,
 0L));



    validateConsole(
        console,
        listener,
        300L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.3),
            formatConsoleTimes(" |=> //banana:stand...  %s (checking local cache)", 0.1)));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(stepShortName, stepDescription, stepUuid),
            400L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        500L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.5),
            formatConsoleTimes(
                " |=> //banana:stand...  %s (running doing_something[%s])",
                0.3,
                0.1)));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(stepShortName, stepDescription, stepUuid,  0),
            600L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.finished(
                fakeRule,
                BuildRuleStatus.SUCCESS,
                CacheResult.miss(),
                Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
                Optional.<HashCode>absent(),
                Optional.<Long>absent()),
            600L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        700L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.7),
            " |=> IDLE"));
  }

  private void validateConsole(TestConsole console,
      SuperConsoleEventBusListener listener,
      long timeMs,
      ImmutableList<String> lines) {
    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals("", console.getTextWrittenToStdErr());
    assertEquals(lines, listener.createRenderLinesAtTime(timeMs));
  }
}

<code block>


package com.facebook.buck.cli;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTargetFactory;

import org.junit.Test;

public class StartActivityEventTest {
  @Test
  public void testEquals() throws Exception {
    StartActivityEvent started =
        configureTestEvent(StartActivityEvent.started(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar"));
    StartActivityEvent startedTwo =
        configureTestEvent(StartActivityEvent.started(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar"));
    StartActivityEvent finished =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            false));
    StartActivityEvent finishedTwo =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            false));
    StartActivityEvent finishedSucceed =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            true));

    assertEquals(started, started);
    assertNotEquals(started, finished);
    assertEquals(started, startedTwo);
    assertEquals(finished, finishedTwo);
    assertNotEquals(finished, finishedSucceed);
  }
}

<code block>


package com.facebook.buck.cli;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTargetFactory;

import org.junit.Test;

public class InstallEventTest {
  @Test
  public void testEquals() throws Exception {
    InstallEvent started = configureTestEvent(
        InstallEvent.started(BuildTargetFactory.newInstance("//foo:bar")));
    InstallEvent startedTwo = configureTestEvent(
        InstallEvent.started(BuildTargetFactory.newInstance("//foo:bar")));
    InstallEvent finished = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:bar"), true));
    InstallEvent finishedDifferentEvent = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:raz"), true));
    InstallEvent finishedFail = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:bar"), false));

    assertEquals(started, startedTwo);
    assertNotEquals(finished, finishedDifferentEvent);
    assertNotEquals(started, finished);
    assertNotEquals(finished, finishedFail);

  }
}

<code block>


package com.facebook.buck.cli;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.Client;
import com.android.ddmlib.FileListingService;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.RawImage;
import com.android.ddmlib.ScreenRecorderOptions;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.SyncException;
import com.android.ddmlib.SyncService;
import com.android.ddmlib.TimeoutException;
import com.android.ddmlib.log.LogReceiver;
import com.google.common.collect.Maps;

import java.io.IOException;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.TimeUnit;


public class TestDevice implements IDevice {

  private boolean isEmulator;
  private String name;
  private String serialNumber;
  private DeviceState state;
  private Map<String, String> properties;

  public static TestDevice createEmulator(String serial) {
    TestDevice device = new TestDevice();
    device.setIsEmulator(true);
    device.setSerialNumber(serial);
    device.setName("emulator-" + serial);
    device.setState(DeviceState.ONLINE);
    return device;
  }

  public static TestDevice createRealDevice(String serial) {
    TestDevice device = new TestDevice();
    device.setIsEmulator(false);
    device.setSerialNumber(serial);
    device.setName("device-" + serial);
    device.setState(DeviceState.ONLINE);
    return device;
  }

  public TestDevice() {
    properties = Maps.newHashMap();
  }

  public void setSerialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
  }

  @Override
  public String getSerialNumber() {
    return serialNumber;
  }

  @Override
  public String getAvdName() {
    if (isEmulator()) {
      return name;
    } else {
      return null;
    }
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public String getName() {
    return name;
  }

  public void setIsEmulator(boolean isEmulator) {
    this.isEmulator = isEmulator;
  }

  @Override
  public boolean isEmulator() {
    return isEmulator;
  }

  public void setState(DeviceState state) {
    this.state = state;
  }

  @Override
  public DeviceState getState() {
    return state;
  }

  @Override
  public boolean isOnline() {
    return state == DeviceState.ONLINE;
  }

  @Override
  public boolean isOffline() {
    return state == DeviceState.OFFLINE;
  }

  @Override
  public boolean isBootLoader() {
    return state == DeviceState.BOOTLOADER;
  }

  @Override
  public Map<String, String> getProperties() {
    return Collections.unmodifiableMap(properties);
  }

  @Override
  public int getPropertyCount() {
    return properties.size();
  }

  @Override
  public String getProperty(String s) {
    return properties.get(s);
  }

  @Override
  public boolean arePropertiesSet() {
    return true;
  }

  @Override
  public String getPropertySync(String s) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getPropertyCacheOrSync(String s) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean supportsFeature(Feature feature) {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getMountPoint(String s) {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean hasClients() {
    throw new UnsupportedOperationException();
  }

  @Override
  public Client[] getClients() {
    throw new UnsupportedOperationException();
  }

  @Override
  public Client getClient(String s) {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getClientName(int i) {
    throw new UnsupportedOperationException();
  }

  @Override
  public SyncService getSyncService() throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public FileListingService getFileListingService() {
    throw new UnsupportedOperationException();
  }

  @Override
  public RawImage getScreenshot() throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void startScreenRecorder(
      String remoteFilePath,
      ScreenRecorderOptions options,
      IShellOutputReceiver receiver)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      IOException,
      ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void executeShellCommand(String s, IShellOutputReceiver iShellOutputReceiver)
      throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Deprecated
  @Override
  public void executeShellCommand(String s, IShellOutputReceiver iShellOutputReceiver, int i)
      throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void executeShellCommand(
      String command,
      IShellOutputReceiver receiver,
      long maxTimeToOutputResponse,
      TimeUnit maxTimeUnits)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void runEventLogService(LogReceiver logReceiver) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void runLogService(String s, LogReceiver logReceiver) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void createForward(int i, int i1) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void createForward(int i, String s, DeviceUnixSocketNamespace deviceUnixSocketNamespace)
      throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeForward(int i, int i1) throws TimeoutException, AdbCommandRejectedException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeForward(int i, String s, DeviceUnixSocketNamespace deviceUnixSocketNamespace)
      throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }


  @Override
  public void pushFile(String s, String s1) throws IOException,
      AdbCommandRejectedException, TimeoutException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void pullFile(String s, String s1) throws IOException,
      AdbCommandRejectedException, TimeoutException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String installPackage(String s, boolean b, String... strings) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String syncPackageToDevice(String s) throws TimeoutException, AdbCommandRejectedException,
      IOException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String installRemotePackage(String s, boolean b, String... strings)
      throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeRemotePackage(String s) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String uninstallPackage(String s) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void reboot(String s) throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public Integer getBatteryLevel() throws TimeoutException, AdbCommandRejectedException,
      IOException, ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }

  @Override
  public Integer getBatteryLevel(long l) throws TimeoutException, AdbCommandRejectedException,
      IOException, ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }
}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;

public class InstallCommandOptionsTest {

  private InstallCommand getCommand(String... args) throws CmdLineException {
    InstallCommand command = new InstallCommand();
    new AdditionalOptionsCmdLineParser(command).parseArgument(args);
    return command;
  }

  private AdbOptions getAdbOptions(String...args) throws CmdLineException {
    return getCommand(args).adbOptions();
  }

  private TargetDeviceOptions getTargetDeviceOptions(String... args) throws CmdLineException {
    return getCommand(args).targetDeviceOptions();
  }

  @Test
  public void testInstallCommandOptionsRun() throws CmdLineException {
    InstallCommand command = getCommand(
        InstallCommand.RUN_SHORT_ARG, "katana",
        VerbosityParser.VERBOSE_SHORT_ARG, "10");
    assertTrue(command.shouldStartActivity());
    assertNull(command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsRunAndActivity() throws CmdLineException {
    InstallCommand command = getCommand(
        InstallCommand.RUN_SHORT_ARG,
        VerbosityParser.VERBOSE_SHORT_ARG, "10",
        "wakizashi",
        InstallCommand.ACTIVITY_SHORT_ARG, "com.facebook.katana.LoginActivity");
    assertTrue(command.shouldStartActivity());
    assertEquals("com.facebook.katana.LoginActivity", command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsActivity() throws CmdLineException {
    InstallCommand command = getCommand(
        "katana",
        InstallCommand.ACTIVITY_SHORT_ARG, ".LoginActivity");
    assertTrue(command.shouldStartActivity());
    assertEquals(".LoginActivity", command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsNone() throws CmdLineException {
    InstallCommand command = getCommand(
        VerbosityParser.VERBOSE_SHORT_ARG, "10",
        "katana");
    assertFalse(command.shouldStartActivity());
    assertNull(command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsEmulatorMode() throws CmdLineException {

    TargetDeviceOptions options =
        getTargetDeviceOptions(TargetDeviceOptions.EMULATOR_MODE_SHORT_ARG);
    assertTrue(options.isEmulatorsOnlyModeEnabled());


    options = getTargetDeviceOptions(TargetDeviceOptions.EMULATOR_MODE_LONG_ARG);
    assertTrue(options.isEmulatorsOnlyModeEnabled());


    options = getTargetDeviceOptions();
    assertFalse(options.isEmulatorsOnlyModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsDeviceMode() throws CmdLineException {

    TargetDeviceOptions options = getTargetDeviceOptions(TargetDeviceOptions.DEVICE_MODE_SHORT_ARG);
    assertTrue(options.isRealDevicesOnlyModeEnabled());


    options = getTargetDeviceOptions(TargetDeviceOptions.DEVICE_MODE_LONG_ARG);
    assertTrue(options.isRealDevicesOnlyModeEnabled());


    options = getTargetDeviceOptions();
    assertFalse(options.isRealDevicesOnlyModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsSerial() throws CmdLineException {
    String serial = "some-random-serial-number";

    TargetDeviceOptions options = getTargetDeviceOptions(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, serial);
    assertTrue(options.hasSerialNumber());
    assertEquals(serial, options.getSerialNumber());


    options = getTargetDeviceOptions(TargetDeviceOptions.SERIAL_NUMBER_LONG_ARG, serial);
    assertTrue(options.hasSerialNumber());
    assertEquals(serial, options.getSerialNumber());


    options = getTargetDeviceOptions();
    assertFalse(options.hasSerialNumber());
    assertEquals(null, options.getSerialNumber());
  }

  @Test
  public void testInstallCommandOptionsMultiInstallMode() throws CmdLineException {

    AdbOptions options = getAdbOptions(AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG);
    assertTrue(options.isMultiInstallModeEnabled());


    options = getAdbOptions(AdbOptions.MULTI_INSTALL_MODE_LONG_ARG);
    assertTrue(options.isMultiInstallModeEnabled());


    options = getAdbOptions();
    assertFalse(options.isMultiInstallModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsAdbThreads() throws CmdLineException {

    AdbOptions options = getAdbOptions(AdbOptions.ADB_THREADS_SHORT_ARG, "4");
    assertEquals(4, options.getAdbThreadCount());


    options = getAdbOptions(AdbOptions.ADB_THREADS_LONG_ARG, "4");
    assertEquals(4, options.getAdbThreadCount());


    options = getAdbOptions();
    assertEquals(0, options.getAdbThreadCount());
  }
}

<code block>


package com.facebook.buck.cli;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import org.junit.Test;

public class UninstallEventTest {
  @Test
  public void testEquals() throws Exception {
    UninstallEvent started = configureTestEvent(UninstallEvent.started("com.foo.bar"));
    UninstallEvent startedTwo = configureTestEvent(UninstallEvent.started("com.foo.bar"));
    UninstallEvent finished = configureTestEvent(UninstallEvent.finished("com.foo.bar", true));
    UninstallEvent finishedFail = configureTestEvent(UninstallEvent.finished("com.foo.bar", false));

    assertEquals(started, startedTwo);
    assertNotEquals(started, finished);
    assertNotEquals(finished, finishedFail);
  }
}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import com.android.ddmlib.IDevice;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.InstallException;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.util.Console;
import com.google.common.collect.ImmutableMap;

import org.junit.Before;
import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;

import java.io.File;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class AdbHelperTest {

  private BuckConfig buckConfig;
  private AdbHelper basicAdbHelper;

  @Before
  public void setUp() throws CmdLineException {
    buckConfig = new FakeBuckConfig();
    basicAdbHelper = createAdbHelper();
  }

  private InstallCommand getCommand(String... args) throws CmdLineException {
    InstallCommand command = new InstallCommand();
    new AdditionalOptionsCmdLineParser(command).parseArgument(args);
    return command;
  }

  private TestDevice createRealDevice(String serial, IDevice.DeviceState state) {
    TestDevice device = TestDevice.createRealDevice(serial);
    device.setState(state);
    return device;
  }

  private TestDevice createEmulator(String serial, IDevice.DeviceState state) {
    TestDevice device = TestDevice.createEmulator(serial);
    device.setState(state);
    return device;
  }

  private TestDevice createDeviceForShellCommandTest(final String output) {
    return new TestDevice() {
      @Override
      public void executeShellCommand(
          String cmd,
          IShellOutputReceiver receiver,
          long timeout,
          TimeUnit timeoutUnit) {
        byte[] outputBytes = output.getBytes();
        receiver.addOutput(outputBytes, 0, outputBytes.length);
        receiver.flush();
      }
    };
  }

  private AdbHelper createAdbHelper(String... args) throws CmdLineException {
    return createAdbHelper(TestExecutionContext.newInstance(), args);
  }

  private AdbHelper createAdbHelper(ExecutionContext executionContext, String... args)
      throws CmdLineException {
    Console console = new TestConsole();
    BuckEventBus eventBus = BuckEventBusFactory.newInstance();
    InstallCommand command = getCommand(args);
    return new AdbHelper(
        command.adbOptions(),
        command.targetDeviceOptions(),
        executionContext,
        console,
        eventBus,
        buckConfig) {
      @Override
      protected boolean isDeviceTempWritable(IDevice device, String name) {
        return true;
      }
    };
  }


  @Test
  public void testDeviceFilterNoDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] { };

    assertNull(basicAdbHelper.filterDevices(devices));
  }


  @Test
  public void testDeviceFilterOnlineOnly() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.OFFLINE),
        createEmulator("2", IDevice.DeviceState.BOOTLOADER),
        createEmulator("3", IDevice.DeviceState.RECOVERY),
        createRealDevice("4", IDevice.DeviceState.OFFLINE),
        createRealDevice("5", IDevice.DeviceState.BOOTLOADER),
        createRealDevice("6", IDevice.DeviceState.RECOVERY),
    };

    assertNull(basicAdbHelper.filterDevices(devices));
  }


  @Test
  public void testDeviceFilterMultipleDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("4", IDevice.DeviceState.ONLINE),
        createRealDevice("5", IDevice.DeviceState.ONLINE)
    };

    assertNull(basicAdbHelper.filterDevices(devices));

    AdbHelper myAdbHelper = createAdbHelper(AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG);
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(devices.length, filteredDevices.size());
  }


  @Test
  public void testDeviceFilterEmulator() throws CmdLineException {
    AdbHelper myAdbHelper = createAdbHelper(TargetDeviceOptions.EMULATOR_MODE_SHORT_ARG);

    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.ONLINE),
        createRealDevice("2", IDevice.DeviceState.ONLINE),
    };

    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(devices[0], filteredDevices.get(0));
  }


  @Test
  public void testDeviceFilterRealDevices() throws CmdLineException {
    AdbHelper myAdbHelper = createAdbHelper(TargetDeviceOptions.DEVICE_MODE_LONG_ARG);

    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE)
    };

    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(devices[0], filteredDevices.get(0));
  }


  @Test
  public void testDeviceFilterBySerial() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    for (int i = 0; i < devices.length; i++) {
      AdbHelper myAdbHelper = createAdbHelper(
          TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, devices[i].getSerialNumber());
      List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
      assertNotNull(filteredDevices);
      assertEquals(1, filteredDevices.size());
      assertSame(devices[i], filteredDevices.get(0));
    }
  }


  @Test
  public void whenSerialNumberSetInEnvironmentThenCorrectDeviceFound()
      throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    for (int i = 0; i < devices.length; i++) {
      AdbHelper myAdbHelper = createAdbHelper(
          TestExecutionContext.newBuilder()
              .setEnvironment(ImmutableMap.of(
                      AdbHelper.SERIAL_NUMBER_ENV,
                      devices[i].getSerialNumber()))
              .build());
      List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
      assertNotNull(filteredDevices);
      assertEquals(1, filteredDevices.size());
      assertSame(devices[i], filteredDevices.get(0));
    }
  }


  @Test
  public void testDeviceFilterNoMatchingDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    AdbHelper myAdbHelper = createAdbHelper(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, "invalid-serial");
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNull(filteredDevices);
  }


  @Test
  public void testDeviceFilterCombos() throws CmdLineException {
    TestDevice realDevice1 = createRealDevice("1", IDevice.DeviceState.ONLINE);
    TestDevice realDevice2 = createRealDevice("2", IDevice.DeviceState.ONLINE);
    TestDevice emulator1 = createEmulator("3", IDevice.DeviceState.ONLINE);
    TestDevice emulator2 = createEmulator("4", IDevice.DeviceState.ONLINE);
    IDevice[] devices = new IDevice[] {
        realDevice1,
        emulator1,
        realDevice2,
        emulator2
    };

    AdbHelper myAdbHelper;

    myAdbHelper = createAdbHelper(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, realDevice1.getSerialNumber(),
        TargetDeviceOptions.DEVICE_MODE_LONG_ARG);
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(realDevice1, filteredDevices.get(0));


    myAdbHelper = createAdbHelper(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, emulator1.getSerialNumber(),
        TargetDeviceOptions.DEVICE_MODE_LONG_ARG);
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNull(filteredDevices);


    myAdbHelper = createAdbHelper(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, realDevice1.getSerialNumber(),
        TargetDeviceOptions.EMULATOR_MODE_SHORT_ARG);
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNull(filteredDevices);


    myAdbHelper = createAdbHelper(
        TargetDeviceOptions.SERIAL_NUMBER_SHORT_ARG, emulator1.getSerialNumber(),
        TargetDeviceOptions.EMULATOR_MODE_SHORT_ARG);
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(emulator1, filteredDevices.get(0));


    myAdbHelper = createAdbHelper(
        TargetDeviceOptions.DEVICE_MODE_LONG_ARG,
        TargetDeviceOptions.EMULATOR_MODE_SHORT_ARG,
        AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG);
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(devices.length, filteredDevices.size());
    for (IDevice device : devices) {
      assertTrue(filteredDevices.contains(device));
    }
  }


  @Test
  public void testSuccessfulDeviceInstall() {
    File apk = new File("/some/file.apk");
    final AtomicReference<String> apkPath = new AtomicReference<>();

    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        apkPath.set(s);
        return null;
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");

    assertTrue(basicAdbHelper.installApkOnDevice(device, apk, false));
    assertEquals(apk.getAbsolutePath(), apkPath.get());
  }


  @Test
  public void testDeviceStartActivitySuccess() {
    TestDevice device = createDeviceForShellCommandTest(
        "Starting: Intent { cmp=com.example.ExceptionErrorActivity }\r\n");
    assertNull(basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity"));
  }

  @Test
  public void testDeviceStartActivityAmDoesntExist() {
    TestDevice device = createDeviceForShellCommandTest("sh: am: not found\r\n");
    assertNotNull(basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity"));
  }

  @Test
  public void testDeviceStartActivityActivityDoesntExist() {
    String errorLine = "Error: Activity class {com.foo/.Activiqy} does not exist.\r\n";
    TestDevice device = createDeviceForShellCommandTest(
         "Starting: Intent { cmp=com.foo/.Activiqy }\r\n" +
         "Error type 3\r\n" +
         errorLine);
    assertEquals(
        errorLine.trim(),
        basicAdbHelper.deviceStartActivity(device, "com.foo/.Activiy").trim());
  }

  @Test
  public void testDeviceStartActivityException() {
    String errorLine = "java.lang.SecurityException: Permission Denial: " +
        "starting Intent { flg=0x10000000 cmp=com.foo/.Activity } from null " +
        "(pid=27581, uid=2000) not exported from uid 10002\r\n";
    TestDevice device = createDeviceForShellCommandTest(
        "Starting: Intent { cmp=com.foo/.Activity }\r\n" +
        errorLine +
         "  at android.os.Parcel.readException(Parcel.java:1425)\r\n" +
         "  at android.os.Parcel.readException(Parcel.java:1379)\r\n" +

        "  at dalvik.system.NativeStart.main(Native Method)\r\n");
    assertEquals(
        errorLine.trim(),
        basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity").trim());
  }


  @Test
  public void testFailedDeviceInstallWithReason() {
    File apk = new File("/some/file.apk");
    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        return "[SOME_REASON]";
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");
    assertFalse(basicAdbHelper.installApkOnDevice(device, apk, false));
  }


  @Test
  public void testFailedDeviceInstallWithException() {
    File apk = new File("/some/file.apk");

    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        throw new InstallException("Failed to install on test device.", null);
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");
    assertFalse(basicAdbHelper.installApkOnDevice(device, apk, false));
  }

}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.step.TargetDevice;

import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;

public class TargetDeviceOptionsTest {
  @Test
  public void shouldReturnAnAbsentOptionalIfNoTargetDeviceOptionsSet() {
    TargetDeviceOptions options = buildOptions();

    assertFalse(options.getTargetDeviceOptional().isPresent());
  }

  @Test
  public void shouldReturnAnEmulatorIfOnlyEmulatorFlagSet() {
    TargetDeviceOptions options = buildOptions("-e");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertTrue(device.isEmulator());
    assertNull(device.getIdentifier());
  }

  @Test
  public void shouldReturnADeviceIfOnlyDeviceFlagSet() {
    TargetDeviceOptions options = buildOptions("-d");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertFalse(device.isEmulator());
    assertNull(device.getIdentifier());
  }

  @Test
  public void onlySettingTheSerialFlagAssumesTheTargetIsARealDevice() {
    TargetDeviceOptions options = buildOptions("-s", "1234");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertFalse(device.isEmulator());
    assertEquals("1234", device.getIdentifier());
  }

  @Test
  public void serialFlagOverridesEnvironment() {
    TargetDeviceOptions options = new TargetDeviceOptions("1234");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertEquals("1234", device.getIdentifier());

    try {
      new CmdLineParser(options).parseArgument("-s", "5678");
    } catch (CmdLineException e) {
      fail("Unable to parse arguments");
    }

    device = options.getTargetDeviceOptional().get();

    assertEquals("5678", device.getIdentifier());
  }

  private TargetDeviceOptions buildOptions(String... args) {
    TargetDeviceOptions options = new TargetDeviceOptions();

    try {
      new CmdLineParser(options).parseArgument(args);
    } catch (CmdLineException e) {
      fail("Unable to parse arguments");
    }

    return options;
  }
}

<code block>


package com.facebook.buck.android;

import static com.facebook.buck.util.concurrent.MoreExecutors.newMultiThreadExecutor;
import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.AndroidDebugBridge;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.MultiLineReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.TimeoutException;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.InterruptionFailedException;
import com.facebook.buck.util.TriState;
import com.facebook.buck.util.concurrent.MoreExecutors;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class AdbHelper {

  private static final long ADB_CONNECT_TIMEOUT_MS = 5000;
  private static final long ADB_CONNECT_TIME_STEP_MS = ADB_CONNECT_TIMEOUT_MS / 10;


  public static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile("[\\w.-]+");


  static final String SERIAL_NUMBER_ENV = "ANDROID_SERIAL";


  public static final long INSTALL_TIMEOUT = 2 * 60 * 1000; 
  public static final long GETPROP_TIMEOUT = 2 * 1000; 

  public static final String ECHO_COMMAND_SUFFIX = " ; echo -n :$?";

  private final AdbOptions options;
  private final TargetDeviceOptions deviceOptions;
  private final ExecutionContext context;
  private final Console console;
  private final BuckEventBus buckEventBus;
  private final boolean restartAdbOnFailure;

  public AdbHelper(
      AdbOptions adbOptions,
      TargetDeviceOptions deviceOptions,
      ExecutionContext context,
      Console console,
      BuckEventBus buckEventBus,
      boolean restartAdbOnFailure) {
    this.options = adbOptions;
    this.deviceOptions = deviceOptions;
    this.context = context;
    this.console = console;
    this.buckEventBus = buckEventBus;
    this.restartAdbOnFailure = restartAdbOnFailure;
  }

  private BuckEventBus getBuckEventBus() {
    return buckEventBus;
  }


  @Nullable
  @VisibleForTesting
  List<IDevice> filterDevices(IDevice[] allDevices) {
    if (allDevices.length == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    List<IDevice> devices = Lists.newArrayList();
    TriState emulatorsOnly = TriState.UNSPECIFIED;
    if (deviceOptions.isEmulatorsOnlyModeEnabled() && options.isMultiInstallModeEnabled()) {
      emulatorsOnly = TriState.UNSPECIFIED;
    } else if (deviceOptions.isEmulatorsOnlyModeEnabled()) {
      emulatorsOnly = TriState.TRUE;
    } else if (deviceOptions.isRealDevicesOnlyModeEnabled()) {
      emulatorsOnly = TriState.FALSE;
    }

    int onlineDevices = 0;
    for (IDevice device : allDevices) {
      boolean passed = false;
      if (device.isOnline()) {
        onlineDevices++;

        boolean serialMatches = true;
        if (deviceOptions.hasSerialNumber()) {
          serialMatches = device.getSerialNumber().equals(deviceOptions.getSerialNumber());
        } else if (context.getEnvironment().containsKey(SERIAL_NUMBER_ENV)) {
          serialMatches = device.getSerialNumber().equals(
              context.getEnvironment().get(SERIAL_NUMBER_ENV));
        }

        boolean deviceTypeMatches;
        if (emulatorsOnly.isSet()) {


          deviceTypeMatches = (emulatorsOnly.asBoolean() == device.isEmulator());
        } else {

          deviceTypeMatches = true;
        }
        passed = serialMatches && deviceTypeMatches;
      }

      if (passed) {
        devices.add(device);
      }
    }


    if (onlineDevices == 0) {
      console.printBuildFailure("No devices are found.");
      return null;
    }

    if (devices.isEmpty()) {
      console.printBuildFailure(String.format(
          "Found %d connected device(s), but none of them matches specified filter.",
          onlineDevices));
      return null;
    }


    if (!options.isMultiInstallModeEnabled() && devices.size() > 1) {
      console.printBuildFailure(
          String.format("%d device(s) matches specified device filter (1 expected).\n" +
                        "Either disconnect other devices or enable multi-install mode (%s).",
                         devices.size(), AdbOptions.MULTI_INSTALL_MODE_SHORT_ARG));
      return null;
    }


    if (devices.size() > 1) {
      console.getStdOut().printf("Found " + devices.size() + " matching devices.\n");
    }
    return devices;
  }

  private boolean isAdbInitialized(AndroidDebugBridge adb) {
    return adb.isConnected() && adb.hasInitialDeviceList();
  }


  @Nullable
  @SuppressWarnings("PMD.EmptyCatchBlock")
  private AndroidDebugBridge createAdb(ExecutionContext context) throws InterruptedException {
    try {
      AndroidDebugBridge.init( false);
    } catch (IllegalStateException ex) {

    }

    AndroidDebugBridge adb =
        AndroidDebugBridge.createBridge(context.getPathToAdbExecutable(), false);
    if (adb == null) {
      console.printBuildFailure("Failed to connect to adb. Make sure adb server is running.");
      return null;
    }

    long start = System.currentTimeMillis();
    while (!isAdbInitialized(adb)) {
      long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();
      if (timeLeft <= 0) {
        break;
      }
      Thread.sleep(ADB_CONNECT_TIME_STEP_MS);
    }
    return isAdbInitialized(adb) ? adb : null;
  }


  @SuppressWarnings("PMD.EmptyCatchBlock")
  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {
    List<IDevice> devices;

    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, "set_up_adb_call")) {


      AndroidDebugBridge adb = createAdb(context);
      if (adb == null) {
        console.printBuildFailure("Failed to create adb connection.");
        return false;
      }


      devices = filterDevices(adb.getDevices());
      if (devices == null) {
        if (restartAdbOnFailure) {
          console.printErrorText("No devices found with adb, restarting adb-server.");
          adb.restart();
          devices = filterDevices(adb.getDevices());
        }

        if (devices == null) {
            return false;
        }
      }
    }

    int adbThreadCount = options.getAdbThreadCount();
    if (adbThreadCount <= 0) {
      adbThreadCount = devices.size();
    }


    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();
    ListeningExecutorService executorService =
        listeningDecorator(
            newMultiThreadExecutor(
                new CommandThreadFactory(getClass().getSimpleName()),
                adbThreadCount));

    for (final IDevice device : devices) {
      futures.add(executorService.submit(adbCallable.forDevice(device)));
    }


    List<Boolean> results = null;
    try {
      results = Futures.allAsList(futures).get();
    } catch (ExecutionException ex) {
      console.printBuildFailure("Failed: " + adbCallable);
      ex.printStackTrace(console.getStdErr());
      return false;
    } catch (InterruptedException e) {
      try {
        Futures.allAsList(futures).cancel(true);
      } catch (CancellationException ignored) {

      }
      Thread.currentThread().interrupt();
      throw e;
    } finally {
      MoreExecutors.shutdownOrThrow(
          executorService,
          10,
          TimeUnit.MINUTES,
          new InterruptionFailedException("Failed to shutdown ExecutorService."));
    }

    int successCount = 0;
    for (Boolean result : results) {
      if (result) {
        successCount++;
      }
    }
    int failureCount = results.size() - successCount;


    if (successCount > 0) {
      console.printSuccess(
          String.format("Successfully ran %s on %d device(s)", adbCallable, successCount));
    }
    if (failureCount > 0) {
      console.printBuildFailure(
          String.format("Failed to %s on %d device(s).", adbCallable, failureCount));
    }

    return failureCount == 0;
  }


  public abstract static class AdbCallable {


    public abstract boolean call(IDevice device) throws Exception;


    public Callable<Boolean> forDevice(final IDevice device) {
      return new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
          return AdbCallable.this.call(device);
        }
        @Override
        public String toString() {
          return AdbCallable.this.toString();
        }
      };
    }
  }


  private abstract static class ErrorParsingReceiver extends MultiLineReceiver {

    @Nullable
    private String errorMessage = null;


    @Nullable
    protected abstract String matchForError(String line);


    protected boolean matchForSuccess(String line) {
      return false;
    }

    @Override
    public void processNewLines(String[] lines) {
        for (String line : lines) {
            if (line.length() > 0) {
                if (matchForSuccess(line)) {
                    errorMessage = null;
                } else {
                    String err = matchForError(line);
                    if (err != null) {
                      errorMessage = err;
                    }
                }
            }
        }
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Nullable
    public String getErrorMessage() {
       return errorMessage;
    }
  }


  @SuppressWarnings("serial")
  public static class CommandFailedException extends IOException {
    public final String command;
    public final int exitCode;
    public final String output;
    public CommandFailedException(String command, int exitCode, String output) {
      super("Command '" + command + "' failed with code " + exitCode + ".  Output:\n" + output);
      this.command = command;
      this.exitCode = exitCode;
      this.output = output;
    }
  }


  public static String executeCommandWithErrorChecking(IDevice device, String command)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(command + ECHO_COMMAND_SUFFIX, receiver);
    String realOutput = checkReceiverOutput(command, receiver);
    return realOutput;
  }


  public static String checkReceiverOutput(
      String command,
      CollectingOutputReceiver receiver) throws CommandFailedException {
    String fullOutput = receiver.getOutput();
    int colon = fullOutput.lastIndexOf(':');
    String realOutput = fullOutput.substring(0, colon);
    String exitCodeStr = fullOutput.substring(colon + 1);
    int exitCode = Integer.parseInt(exitCodeStr);
    if (exitCode != 0) {
      throw new CommandFailedException(command, exitCode, realOutput);
    }
    return realOutput;
  }


  public boolean installApk(
      InstallableApk installableApk,
      final boolean installViaSd) throws InterruptedException {
    getBuckEventBus().post(InstallEvent.started(installableApk.getBuildTarget()));

    final File apk = installableApk.getApkPath().toFile();
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            return installApkOnDevice(device, apk, installViaSd);
          }

          @Override
          public String toString() {
            return "install apk";
          }
        });
    getBuckEventBus().post(InstallEvent.finished(installableApk.getBuildTarget(), success));

    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  public boolean installApkOnDevice(IDevice device, File apk, boolean installViaSd) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    if (!isDeviceTempWritable(device, name)) {
      return false;
    }

    getBuckEventBus().post(ConsoleEvent.info("Installing apk on %s.", name));
    try {
      String reason = null;
      if (installViaSd) {
        reason = deviceInstallPackageViaSd(device, apk.getAbsolutePath());
      } else {
        reason = device.installPackage(apk.getAbsolutePath(), true);
      }
      if (reason != null) {
        console.printBuildFailure(String.format("Failed to install apk on %s: %s.", name, reason));
        return false;
      }
      return true;
    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to install apk on %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }

  @VisibleForTesting
  protected boolean isDeviceTempWritable(IDevice device, String name) {
    StringBuilder loggingInfo = new StringBuilder();
    try {
      String output = null;

      try {
        output = executeCommandWithErrorChecking(device, "ls -l -d /data/local/tmp");
        if (!(

            output.matches("\\Adrwx....-x +shell +shell.* tmp[\\r\\n]*\\z") ||

            output.matches("\\Adrwx....-x +[0-9]+ +shell +shell.* /data/local/tmp[\\r\\n]*\\z"))) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad ls output for /data/local/tmp: '%s'\n",
                  output));
        }

        executeCommandWithErrorChecking(device, "echo exo > /data/local/tmp/buck-experiment");
        output = executeCommandWithErrorChecking(device, "cat /data/local/tmp/buck-experiment");
        if (!output.matches("\\Aexo[\\r\\n]*\\z")) {
          loggingInfo.append(
              String.format(
                  java.util.Locale.ENGLISH,
                  "Bad echo/cat output for /data/local/tmp: '%s'\n",
                  output));
        }
        executeCommandWithErrorChecking(device, "rm /data/local/tmp/buck-experiment");

      } catch (CommandFailedException e) {
        loggingInfo.append(
            String.format(
                java.util.Locale.ENGLISH,
                "Failed (%d) '%s':\n%s\n",
                e.exitCode,
                e.command,
                e.output));
      }

      if (!loggingInfo.toString().isEmpty()) {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        device.executeShellCommand("getprop", receiver);
        for (String line : com.google.common.base.Splitter.on('\n').split(receiver.getOutput())) {
          if (line.contains("ro.product.model") || line.contains("ro.build.description")) {
            loggingInfo.append(line).append('\n');
          }
        }
      }

    } catch (
        AdbCommandRejectedException |
            ShellCommandUnresponsiveException |
            TimeoutException |
            IOException e) {
      console.printBuildFailure(String.format("Failed to test /data/local/tmp on %s.", name));
      e.printStackTrace(console.getStdErr());
      return false;
    }
    String logMessage = loggingInfo.toString();
    if (!logMessage.isEmpty()) {
      StringBuilder fullMessage = new StringBuilder();
      fullMessage.append("============================================================\n");
      fullMessage.append('\n');
      fullMessage.append("HEY! LISTEN!\n");
      fullMessage.append('\n');
      fullMessage.append("The /data/local/tmp directory on your device isn't fully-functional.\n");
      fullMessage.append("Here's some extra info:\n");
      fullMessage.append(logMessage);
      fullMessage.append("============================================================\n");
      console.getStdErr().println(fullMessage.toString());
    }

    return true;
  }


  private String deviceInstallPackageViaSd(IDevice device, String apk) {
    try {

      String externalStorage = deviceGetExternalStorage(device);
      if (externalStorage == null) {
        return "Cannot get external storage location.";
      }
      String remotePackage = String.format("%s/%s.apk", externalStorage, UUID.randomUUID());

      device.pushFile(apk, remotePackage);

      String reason = device.installRemotePackage(remotePackage, true);

      device.removeRemotePackage(remotePackage);
      return reason;
    } catch (Throwable t) {
      return String.valueOf(t.getMessage());
    }
  }


  @Nullable
  private String deviceGetExternalStorage(IDevice device) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    CollectingOutputReceiver receiver = new CollectingOutputReceiver();
    device.executeShellCommand(
        "echo $EXTERNAL_STORAGE",
        receiver,
        AdbHelper.GETPROP_TIMEOUT,
        TimeUnit.MILLISECONDS);
    String value = receiver.getOutput().trim();
    if (value.isEmpty()) {
      return null;
    }
    return value;
  }

  public int startActivity(
      InstallableApk installableApk,
      @Nullable String activity) throws IOException, InterruptedException {


    Path pathToManifest = installableApk.getManifestPath();
    AndroidManifestReader reader = DefaultAndroidManifestReader.forPath(
        pathToManifest, context.getProjectFilesystem());

    if (activity == null) {

      List<String> launcherActivities = reader.getLauncherActivities();


      if (launcherActivities.isEmpty()) {
        console.printBuildFailure("No launchable activities found.");
        return 1;
      } else if (launcherActivities.size() > 1) {
        console.printBuildFailure("Default activity is ambiguous.");
        return 1;
      }


      activity = reader.getPackage() + "/" + launcherActivities.get(0);
    } else if (!activity.contains("/")) {

      activity = reader.getPackage() + "/" + activity;
    }

    final String activityToRun = activity;

    PrintStream stdOut = console.getStdOut();
    stdOut.println(String.format("Starting activity %s...", activityToRun));

    getBuckEventBus().post(StartActivityEvent.started(installableApk.getBuildTarget(),
        activityToRun));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            String err = deviceStartActivity(device, activityToRun);
            if (err != null) {
              console.printBuildFailure(err);
              return false;
            } else {
              return true;
            }
          }

          @Override
          public String toString() {
            return "start activity";
          }
        });
    getBuckEventBus().post(StartActivityEvent.finished(installableApk.getBuildTarget(),
        activityToRun,
        success));

    return success ? 0 : 1;

  }

  @VisibleForTesting
  @Nullable
  String deviceStartActivity(IDevice device, String activityToRun) {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {

          return (Pattern.matches("^([\\w_$.])*(Exception|Error|error).*$", line) ||
              line.contains("am: not found")) ? line : null;
        }
      };
      device.executeShellCommand(
          String.format("am start -n %s", activityToRun),
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (Exception e) {
      return e.toString();
    }
  }


  public boolean uninstallApp(
      final String packageName,
      final boolean shouldKeepUserData) throws InterruptedException {
    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    getBuckEventBus().post(UninstallEvent.started(packageName));
    boolean success = adbCall(
        new AdbHelper.AdbCallable() {
      @Override
      public boolean call(IDevice device) throws Exception {

        device.executeShellCommand("rm -r /data/local/tmp/exopackage/" + packageName,
            NullOutputReceiver.getReceiver());
        return uninstallApkFromDevice(device, packageName, shouldKeepUserData);
      }

      @Override
      public String toString() {
        return "uninstall apk";
      }
    });
    getBuckEventBus().post(UninstallEvent.finished(packageName, success));
    return success;
  }


  @SuppressWarnings("PMD.PrematureDeclaration")
  private boolean uninstallApkFromDevice(IDevice device, String packageName, boolean keepData) {
    String name;
    if (device.isEmulator()) {
      name = device.getSerialNumber() + " (" + device.getAvdName() + ")";
    } else {
      name = device.getSerialNumber();
      String model = device.getProperty("ro.product.model");
      if (model != null) {
        name += " (" + model + ")";
      }
    }

    PrintStream stdOut = console.getStdOut();
    stdOut.printf("Removing apk from %s.\n", name);
    try {
      long start = System.currentTimeMillis();
      String reason = deviceUninstallPackage(device, packageName, keepData);
      long end = System.currentTimeMillis();

      if (reason != null) {
        console.printBuildFailure(
            String.format("Failed to uninstall apk from %s: %s.", name, reason));
        return false;
      }

      long delta = end - start;
      stdOut.printf("Uninstalled apk from %s in %d.%03ds.\n", name, delta / 1000, delta % 1000);
      return true;

    } catch (InstallException ex) {
      console.printBuildFailure(String.format("Failed to uninstall apk from %s.", name));
      ex.printStackTrace(console.getStdErr());
      return false;
    }
  }


  @Nullable
  private String deviceUninstallPackage(IDevice device,
      String packageName,
      boolean keepData) throws InstallException {
    try {
      AdbHelper.ErrorParsingReceiver receiver = new AdbHelper.ErrorParsingReceiver() {
        @Override
        @Nullable
        protected String matchForError(String line) {
          return line.toLowerCase().contains("failure") ? line : null;
        }
      };
      device.executeShellCommand(
          "pm uninstall " + (keepData ? "-k " : "") + packageName,
          receiver,
          AdbHelper.INSTALL_TIMEOUT,
          TimeUnit.MILLISECONDS);
      return receiver.getErrorMessage();
    } catch (TimeoutException e) {
      throw new InstallException(e);
    } catch (AdbCommandRejectedException e) {
      throw new InstallException(e);
    } catch (ShellCommandUnresponsiveException e) {
      throw new InstallException(e);
    } catch (IOException e) {
      throw new InstallException(e);
    }
  }

  public static String tryToExtractPackageNameFromManifest(
      InstallableApk androidBinaryRule,
      ExecutionContext context) {
    Path pathToManifest = androidBinaryRule.getManifestPath();



    if (!Files.isRegularFile(pathToManifest)) {
      throw new HumanReadableException(
          "Manifest file %s does not exist, so could not extract package name.",
          pathToManifest);
    }

    try {
      return DefaultAndroidManifestReader.forPath(pathToManifest, context.getProjectFilesystem())
          .getPackage();
    } catch (IOException e) {
      throw new HumanReadableException("Could not extract package name from %s", pathToManifest);
    }
  }
}

<code block>


package com.facebook.buck.android;

import com.facebook.buck.step.TargetDevice;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;

import javax.annotation.Nullable;

public class TargetDeviceOptions {

  private boolean useEmulatorsOnlyMode;

  private boolean useRealDevicesOnlyMode;

  @Nullable
  private String serialNumber;

  public TargetDeviceOptions() {
    this(false, false, null);
  }

  public TargetDeviceOptions(
      boolean useEmulatorsOnlyMode,
      boolean useRealDevicesOnlyMode,
      @Nullable String serialNumber) {
    this.useEmulatorsOnlyMode = useEmulatorsOnlyMode;
    this.useRealDevicesOnlyMode = useRealDevicesOnlyMode;
    this.serialNumber = serialNumber;
  }

  @VisibleForTesting
  TargetDeviceOptions(String serial) {
    this.serialNumber = serial;
  }

  public boolean isEmulatorsOnlyModeEnabled() {
    return useEmulatorsOnlyMode;
  }

  public boolean isRealDevicesOnlyModeEnabled() {
    return useRealDevicesOnlyMode;
  }

  @Nullable
  public String getSerialNumber() {
    return serialNumber;
  }

  public boolean hasSerialNumber() {
    return serialNumber != null;
  }

  public Optional<TargetDevice> getTargetDeviceOptional() {
    if (!hasSerialNumber() && !isEmulatorsOnlyModeEnabled() && !isRealDevicesOnlyModeEnabled()) {
      return Optional.absent();
    }

    TargetDevice device = new TargetDevice(
        isEmulatorsOnlyModeEnabled() ? TargetDevice.Type.EMULATOR : TargetDevice.Type.REAL_DEVICE,
        getSerialNumber());
    return Optional.of(device);
  }
}

<code block>


package com.facebook.buck.android;

public class AdbOptions {

  static final String MULTI_INSTALL_MODE_SHORT_ARG = "-x";

  private int adbThreadCount;
  private boolean multiInstallMode;

  public AdbOptions() {
    this(0, false);
  }

  public AdbOptions(
      int adbThreadCount,
      boolean multiInstallMode) {
    this.adbThreadCount = adbThreadCount;
    this.multiInstallMode = multiInstallMode;
  }

  public int getAdbThreadCount() {
    return adbThreadCount;
  }

  public boolean isMultiInstallModeEnabled() {
    return multiInstallMode;
  }

}

<code block>


package com.facebook.buck.event;

import com.facebook.buck.model.BuildTarget;
import com.google.common.base.Objects;

@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class InstallEvent extends AbstractBuckEvent implements LeafEvent {
  private final BuildTarget buildTarget;

  protected InstallEvent(BuildTarget buildTarget) {
    this.buildTarget = buildTarget;
  }

  public BuildTarget getBuildTarget() {
    return buildTarget;
  }

  @Override
  public String getCategory() {
    return "install_apk";
  }

  @Override
  protected String getValueString() {
    return buildTarget.getFullyQualifiedName();
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof InstallEvent)) {
      return false;
    }

    InstallEvent that = (InstallEvent) event;

    return Objects.equal(getBuildTarget(), that.getBuildTarget());
  }

  @Override
  public int hashCode() {
    return getBuildTarget().hashCode();
  }

  public static Started started(BuildTarget buildTarget) {
    return new Started(buildTarget);
  }

  public static Finished finished(BuildTarget buildTarget, boolean success) {
    return new Finished(buildTarget, success);
  }

  public static class Started extends InstallEvent {
    protected Started(BuildTarget buildTarget) {
      super(buildTarget);
    }

    @Override
    public String getEventName() {
      return "InstallStarted";
    }
  }

  public static class Finished extends InstallEvent {
    private final boolean success;

    protected Finished(BuildTarget buildTarget, boolean success) {
      super(buildTarget);
      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "InstallFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getBuildTarget(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.event;

import com.google.common.base.Objects;

@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class UninstallEvent extends AbstractBuckEvent implements LeafEvent {
  private final String packageName;

  public UninstallEvent(String packageName) {
    this.packageName = packageName;
  }

  public String getPackageName() {
    return packageName;
  }

  @Override
  public String getCategory() {
    return "uninstall_apk";
  }

  @Override
  protected String getValueString() {
    return packageName;
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof UninstallEvent)) {
      return false;
    }

    UninstallEvent that = (UninstallEvent) event;

    return Objects.equal(getPackageName(), that.getPackageName());
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(getPackageName());
  }

  public static Started started(String packageName) {
    return new Started(packageName);
  }

  public static Finished finished(String packageName, boolean success) {
    return new Finished(packageName, success);
  }

  public static class Started extends UninstallEvent {
    protected Started(String packageName) {
      super(packageName);
    }

    @Override
    public String getEventName() {
      return "UninstallStarted";
    }
  }

  public static class Finished extends UninstallEvent {
    private final boolean success;

    protected Finished(String packageName, boolean success) {
      super(packageName);

      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "UninstallFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getPackageName(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.event;

import com.facebook.buck.model.BuildTarget;
import com.google.common.base.Objects;


@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")
public abstract class StartActivityEvent extends AbstractBuckEvent implements LeafEvent {
  private final BuildTarget buildTarget;
  private final String activityName;

  protected StartActivityEvent(BuildTarget buildTarget, String activityName) {
    this.buildTarget = buildTarget;
    this.activityName = activityName;
  }

  public BuildTarget getBuildTarget() {
    return buildTarget;
  }

  public String getActivityName() {
    return activityName;
  }

  @Override
  public String getCategory() {
    return "start_activity";
  }

  @Override
  protected String getValueString() {
    return String.format("%s %s", getBuildTarget().getFullyQualifiedName(), getActivityName());
  }

  @Override
  public boolean isRelatedTo(BuckEvent event) {
    if (!(event instanceof StartActivityEvent)) {
      return false;
    }

    StartActivityEvent that = (StartActivityEvent) event;

    return Objects.equal(getBuildTarget(), that.getBuildTarget()) &&
        Objects.equal(getActivityName(), that.getActivityName());
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(getActivityName(), getBuildTarget());
  }

  public static Started started(BuildTarget buildTarget, String activityName) {
    return new Started(buildTarget, activityName);
  }

  public static Finished finished(BuildTarget buildTarget, String activityName, boolean success) {
    return new Finished(buildTarget, activityName, success);
  }

  public static class Started extends StartActivityEvent {
    protected Started(BuildTarget buildTarget, String activityName) {
      super(buildTarget, activityName);
    }

    @Override
    public String getEventName() {
      return "StartActivityStarted";
    }
  }

  public static class Finished extends StartActivityEvent {
    private final boolean success;

    protected Finished(BuildTarget buildTarget, String activityName, boolean success) {
      super(buildTarget, activityName);
      this.success = success;
    }

    public boolean isSuccess() {
      return success;
    }

    @Override
    public String getEventName() {
      return "StartActivityFinished";
    }

    @Override
    public boolean equals(Object o) {
      if (!super.equals(o)) {
        return false;
      }

      Finished that = (Finished) o;
      return isSuccess() == that.isSuccess();
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(getActivityName(), getBuildTarget(), isSuccess());
    }
  }
}

<code block>


package com.facebook.buck.event.listener;

import com.facebook.buck.cli.CommandEvent;
import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ChromeTraceEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.StartActivityEvent;
import com.facebook.buck.event.TraceEvent;
import com.facebook.buck.event.UninstallEvent;
import com.facebook.buck.io.PathListing;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.ArtifactCacheConnectEvent;
import com.facebook.buck.rules.ArtifactCacheEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.BestCompressionGZIPOutputStream;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Optionals;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.Subscribe;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;


public class ChromeTraceBuildListener implements BuckEventListener {
  private static final Logger LOG = Logger.get(ChromeTraceBuildListener.class);

  private final ProjectFilesystem projectFilesystem;
  private final Clock clock;
  private final int tracesToKeep;
  private final boolean compressTraces;
  private final ObjectMapper mapper;
  private final ThreadLocal<SimpleDateFormat> dateFormat;
  private ConcurrentLinkedQueue<ChromeTraceEvent> eventList =
      new ConcurrentLinkedQueue<ChromeTraceEvent>();

  public ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      int tracesToKeep,
      boolean compressTraces) {
    this(
        projectFilesystem,
        clock,
        objectMapper,
        Locale.US,
        TimeZone.getDefault(),
        tracesToKeep,
        compressTraces);
  }

  @VisibleForTesting
  ChromeTraceBuildListener(
      ProjectFilesystem projectFilesystem,
      Clock clock,
      ObjectMapper objectMapper,
      final Locale locale,
      final TimeZone timeZone,
      int tracesToKeep,
      boolean compressTraces) {
    this.projectFilesystem = projectFilesystem;
    this.clock = clock;
    this.mapper = objectMapper;
    this.dateFormat = new ThreadLocal<SimpleDateFormat>() {
      @Override
      protected SimpleDateFormat initialValue() {
          SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd.HH-mm-ss", locale);
          dateFormat.setTimeZone(timeZone);
          return dateFormat;
      }
    };
    this.tracesToKeep = tracesToKeep;
    this.compressTraces = compressTraces;
    addProcessMetadataEvent();
  }

  private void addProcessMetadataEvent() {
    eventList.add(
        new ChromeTraceEvent(
            "buck",
            "process_name",
            ChromeTraceEvent.Phase.METADATA,
 0,
 0,
 0,
            ImmutableMap.of("name", "buck")));
  }

  @VisibleForTesting
  void deleteOldTraces() {
    if (!projectFilesystem.exists(BuckConstant.BUCK_TRACE_DIR)) {
      return;
    }

    Path traceDirectory = projectFilesystem.getPathForRelativePath(BuckConstant.BUCK_TRACE_DIR);

    try {
      for (Path path : PathListing.listMatchingPathsWithFilters(
               traceDirectory,
               "build.*.trace",
               PathListing.GET_PATH_MODIFIED_TIME,
               PathListing.FilterMode.EXCLUDE,
               Optional.of(tracesToKeep),
               Optional.<Long>absent())) {
        projectFilesystem.deleteFileAtPath(path);
      }
    } catch (IOException e) {
      LOG.error(e, "Couldn't list paths in trace directory %s", traceDirectory);
    }
  }

  @Override
  public void outputTrace(BuildId buildId) {
    try {
      String filenameTime = dateFormat.get().format(new Date(clock.currentTimeMillis()));
      String traceName = String.format("build.%s.%s.trace", filenameTime, buildId);
      if (compressTraces) {
        traceName = traceName + ".gz";
      }
      Path tracePath = BuckConstant.BUCK_TRACE_DIR.resolve(traceName);
      projectFilesystem.createParentDirs(tracePath);
      OutputStream stream = projectFilesystem.newFileOutputStream(tracePath);
      if (compressTraces) {
        stream = new BestCompressionGZIPOutputStream(stream, true);
      }

      LOG.debug("Writing Chrome trace to %s", tracePath);
      mapper.writeValue(stream, eventList);

      String symlinkName = compressTraces ? "build.trace.gz" : "build.trace";
      Path symlinkPath = BuckConstant.BUCK_TRACE_DIR.resolve(symlinkName);
      projectFilesystem.createSymLink(
          projectFilesystem.resolve(symlinkPath),
          projectFilesystem.resolve(tracePath),
          true);

      deleteOldTraces();
    } catch (IOException e) {
      throw new HumanReadableException(e, "Unable to write trace file: " + e);
    }
  }

  @Subscribe
  public void commandStarted(CommandEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCommandName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(started.getArgs())
        ),
        started);
  }

  @Subscribe
  public void commandFinished(CommandEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getCommandName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "command_args", Joiner.on(' ').join(finished.getArgs()),
            "daemon", Boolean.toString(finished.isDaemon())),
        finished);
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public synchronized void buildFinished(BuildEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "build",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void ruleStarted(BuildRuleEvent.Started started) {
    BuildRule buildRule = started.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", started.getRuleKeySafe()),
        started);
  }

  @Subscribe
  public void ruleFinished(BuildRuleEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getBuildRule().getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "cache_result", finished.getCacheResult().toString().toLowerCase(),
            "success_type",
            finished.getSuccessType().transform(Functions.toStringFunction()).or("failed")
        ),
        finished);
  }

  @Subscribe
  public void ruleResumed(BuildRuleEvent.Resumed resumed) {
    BuildRule buildRule = resumed.getBuildRule();
    writeChromeTraceEvent(
        "buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of("rule_key", resumed.getRuleKeySafe()),
        resumed);
  }

  @Subscribe
  public void ruleSuspended(BuildRuleEvent.Suspended suspended) {
    BuildRule buildRule = suspended.getBuildRule();
    writeChromeTraceEvent("buck",
        buildRule.getFullyQualifiedName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of("rule_key", suspended.getRuleKeySafe()),
        suspended);
  }

  @Subscribe
  public void stepStarted(StepEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getShortStepName(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void stepFinished(StepEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        finished.getShortStepName(),
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "description", finished.getDescription(),
            "exit_code", Integer.toString(finished.getExitCode())),
        finished);
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "parse",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "targets",
            Joiner.on(",").join(finished.getBuildTargets())),
        finished);
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    writeChromeTraceEvent(
        "buck",
        "action_graph",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "install",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void startActivityStarted(StartActivityEvent.Started started) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void startActivityFinished(StartActivityEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "start_activity",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "target", finished.getBuildTarget().getFullyQualifiedName(),
            "activity_name", finished.getActivityName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void uninstallStarted(UninstallEvent.Started started) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void uninstallFinished(UninstallEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "uninstall",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "package_name", finished.getPackageName(),
            "success", Boolean.toString(finished.isSuccess())),
        finished);
  }

  @Subscribe
  public void artifactFetchStarted(ArtifactCacheEvent.Started started) {
    writeChromeTraceEvent("buck",
        started.getCategory(),
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "rule_key", Joiner.on(", ").join(started.getRuleKeys())),
        started);
  }

  @Subscribe
  public void artifactFetchFinished(ArtifactCacheEvent.Finished finished) {
    ImmutableMap.Builder<String, String> argumentsBuilder = ImmutableMap.<String, String>builder()
        .put("success", Boolean.toString(finished.isSuccess()))
        .put("rule_key", Joiner.on(", ").join(finished.getRuleKeys()));
    Optionals.putIfPresent(finished.getCacheResult().transform(Functions.toStringFunction()),
        "cache_result",
        argumentsBuilder);

    writeChromeTraceEvent("buck",
        finished.getCategory(),
        ChromeTraceEvent.Phase.END,
        argumentsBuilder.build(),
        finished);
  }

  @Subscribe
  public void artifactConnectStarted(ArtifactCacheConnectEvent.Started started) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.<String, String>of(),
        started);
  }

  @Subscribe
  public void artifactConnectFinished(ArtifactCacheConnectEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "artifact_connect",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.<String, String>of(),
        finished);
  }

  @Subscribe
  public void traceEvent(TraceEvent event) {
    writeChromeTraceEvent("buck",
        event.getEventName(),
        event.getPhase(),
        event.getProperties(),
        event);
  }

  @Subscribe
  public void testStartedEvent(TestSummaryEvent.Started started) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.BEGIN,
        ImmutableMap.of(
            "test_case_name", started.getTestCaseName(),
            "test_name", started.getTestName()),
        started);
  }

  @Subscribe
  public void testFinishedEvent(TestSummaryEvent.Finished finished) {
    writeChromeTraceEvent("buck",
        "test",
        ChromeTraceEvent.Phase.END,
        ImmutableMap.of(
            "test_case_name", finished.getTestCaseName(),
            "test_name", finished.getTestName()),
        finished);
  }

  private void writeChromeTraceEvent(String category,
      String name,
      ChromeTraceEvent.Phase phase,
      ImmutableMap<String, String> arguments,
      BuckEvent event) {
    eventList.add(new ChromeTraceEvent(category,
        name,
        phase,
        0,
        event.getThreadId(),
        TimeUnit.NANOSECONDS.toMicros(event.getNanoTime()),
        arguments));
  }
}

<code block>

package com.facebook.buck.event.listener;

import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.IndividualTestEvent;
import com.facebook.buck.rules.TestRunEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.Console;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.eventbus.Subscribe;

import java.util.concurrent.atomic.AtomicLong;


public class SimpleConsoleEventBusListener extends AbstractConsoleEventBusListener {
  private final AtomicLong parseTime;
  private final TestResultFormatter testFormatter;

  public SimpleConsoleEventBusListener(Console console, Clock clock) {
    super(console, clock);

    this.parseTime = new AtomicLong(0);
    this.testFormatter = new TestResultFormatter(console.getAnsi(), console.getVerbosity());
  }

  @Override
  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    super.parseFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    this.parseTime.set(logEventPair("PARSING BUCK FILES",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        0L,
        parseStarted,
        parseFinished,
        lines));
    printLines(lines);
  }

  @Override
  @Subscribe
  public void buildFinished(BuildEvent.Finished finished) {
    super.buildFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    logEventPair("BUILDING",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        parseTime.get(),
        buildStarted,
        buildFinished,
        lines);
    printLines(lines);
  }

  @Override
  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    super.installFinished(finished);
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    logEventPair("INSTALLING",
 Optional.<String>absent(),
        clock.currentTimeMillis(),
        0L,
        installStarted,
        installFinished,
        lines);
    printLines(lines);
  }

  @Subscribe
  public void logEvent(ConsoleEvent event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    formatConsoleEvent(event, lines);
    printLines(lines);
  }

  @Subscribe
  public void testRunStarted(TestRunEvent.Started event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.runStarted(lines,
        event.isRunAllTests(),
        event.getTestSelectorList(),
        event.shouldExplainTestSelectorList(),
        event.getTargetNames(),
        TestResultFormatter.FormatMode.BEFORE_TEST_RUN);
    printLines(lines);
  }

  @Subscribe
  public void testRunCompleted(TestRunEvent.Finished event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.runComplete(lines, event.getResults());
    printLines(lines);
  }

  @Subscribe
  public void testResultsAvailable(IndividualTestEvent.Finished event) {
    ImmutableList.Builder<String> lines = ImmutableList.builder();
    testFormatter.reportResult(lines, event.getResults());
    printLines(lines);
  }

  @Subscribe
  public void buildRuleFinished(BuildRuleEvent.Finished finished) {
    String line = String.format("BUILT %s", finished.getBuildRule().getFullyQualifiedName());
    if (ruleCount.isPresent()) {
      line += String.format(
          " (%d/%d JOBS)",
          numRulesCompleted.get(),
          ruleCount.get());
    }
    console.getStdErr().println(line);
  }

  private void printLines(ImmutableList.Builder<String> lines) {



    ImmutableList<String> stringList = lines.build();
    if (stringList.size() == 0) {
      return;
    }
    console.getStdErr().println(Joiner.on("\n").join(stringList));
  }
}

<code block>

package com.facebook.buck.event.listener;

import com.facebook.buck.event.BuckEvent;
import com.facebook.buck.event.BuckEventListener;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.json.ProjectBuildFileParseEvents;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.util.Ansi;
import com.facebook.buck.util.Console;
import com.google.common.base.Optional;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.eventbus.Subscribe;

import java.io.Closeable;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;

import javax.annotation.Nullable;


public abstract class AbstractConsoleEventBusListener implements BuckEventListener, Closeable {
  protected static final DecimalFormat TIME_FORMATTER = new DecimalFormat("0.0s");
  protected static final long UNFINISHED_EVENT_PAIR = -1;
  protected final Console console;
  protected final Clock clock;
  protected final Ansi ansi;

  @Nullable
  protected volatile ProjectBuildFileParseEvents.Started projectBuildFileParseStarted;
  @Nullable
  protected volatile ProjectBuildFileParseEvents.Finished projectBuildFileParseFinished;

  @Nullable
  protected volatile ParseEvent.Started parseStarted;
  @Nullable
  protected volatile ParseEvent.Finished parseFinished;

  @Nullable
  protected volatile ActionGraphEvent.Started actionGraphStarted;
  @Nullable
  protected volatile ActionGraphEvent.Finished actionGraphFinished;

  @Nullable
  protected volatile BuildEvent.Started buildStarted;
  @Nullable
  protected volatile BuildEvent.Finished buildFinished;

  @Nullable
  protected volatile InstallEvent.Started installStarted;
  @Nullable
  protected volatile InstallEvent.Finished installFinished;

  protected volatile Optional<Integer> ruleCount = Optional.absent();

  protected final AtomicInteger numRulesCompleted = new AtomicInteger();

  public AbstractConsoleEventBusListener(Console console, Clock clock) {
    this.console = console;
    this.clock = clock;
    this.ansi = console.getAnsi();

    this.projectBuildFileParseStarted = null;
    this.projectBuildFileParseFinished = null;

    this.parseStarted = null;
    this.parseFinished = null;

    this.actionGraphStarted = null;
    this.actionGraphFinished = null;

    this.buildStarted = null;
    this.buildFinished = null;

    this.installStarted = null;
    this.installFinished = null;
  }

  protected String formatElapsedTime(long elapsedTimeMs) {
    return TIME_FORMATTER.format(elapsedTimeMs / 1000.0);
  }



  protected long logEventPair(String prefix,
      Optional<String> suffix,
      long currentMillis,
      long offsetMs,
      @Nullable BuckEvent startEvent,
      @Nullable BuckEvent finishedEvent,
      ImmutableList.Builder<String> lines) {
    long result = UNFINISHED_EVENT_PAIR;
    if (startEvent == null) {
      return result;
    }
    String parseLine = (finishedEvent != null ? "[-] " : "[+] ") + prefix + "...";
    long elapsedTimeMs;
    if (finishedEvent != null) {
      elapsedTimeMs = finishedEvent.getTimestamp() - startEvent.getTimestamp();
      parseLine += "FINISHED ";
      result = elapsedTimeMs;
    } else {
      elapsedTimeMs = currentMillis - startEvent.getTimestamp();
    }
    parseLine += formatElapsedTime(elapsedTimeMs - offsetMs);
    if (suffix.isPresent()) {
      parseLine += " " + suffix.get();
    }
    lines.add(parseLine);

    return result;
  }


  protected void formatConsoleEvent(ConsoleEvent logEvent, ImmutableList.Builder<String> lines) {
    String formattedLine = "";
    if (logEvent.getLevel().equals(Level.INFO)) {
      formattedLine = logEvent.getMessage();
    } else if (logEvent.getLevel().equals(Level.WARNING)) {
      formattedLine = ansi.asWarningText(logEvent.getMessage());
    } else if (logEvent.getLevel().equals(Level.SEVERE)) {
      formattedLine = ansi.asErrorText(logEvent.getMessage());
    }
    if (!formattedLine.isEmpty()) {


      lines.addAll(Splitter.on("\n").split(formattedLine));
    }
  }

  @Subscribe
  public void projectBuildFileParseStarted(ProjectBuildFileParseEvents.Started started) {
    projectBuildFileParseStarted = started;
  }

  @Subscribe
  public void projectBuildFileParseFinished(ProjectBuildFileParseEvents.Finished finished) {
    projectBuildFileParseFinished = finished;
  }

  @Subscribe
  public void parseStarted(ParseEvent.Started started) {
    parseStarted = started;
  }

  @Subscribe
  public void parseFinished(ParseEvent.Finished finished) {
    parseFinished = finished;
  }

  @Subscribe
  public void actionGraphStarted(ActionGraphEvent.Started started) {
    actionGraphStarted = started;
  }

  @Subscribe
  public void actionGraphFinished(ActionGraphEvent.Finished finished) {
    actionGraphFinished = finished;
  }

  @Subscribe
  public void buildStarted(BuildEvent.Started started) {
    buildStarted = started;
  }

  @Subscribe
  public void ruleCountCalculated(BuildEvent.RuleCountCalculated calculated) {
    ruleCount = Optional.of(calculated.getNumRules());
  }

  @Subscribe
  public void incrementNumRulesCompleted(
      @SuppressWarnings("unused") BuildRuleEvent.Finished finished) {
    numRulesCompleted.getAndIncrement();
  }

  @Subscribe
  public void buildFinished(BuildEvent.Finished finished) {
    buildFinished = finished;
  }

  @Subscribe
  public void installStarted(InstallEvent.Started started) {
    installStarted = started;
  }

  @Subscribe
  public void installFinished(InstallEvent.Finished finished) {
    installFinished = finished;
  }

  @Override
  public void outputTrace(BuildId buildId) {}

  @Override
  public void close() throws IOException {
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.TargetDeviceOptions;
import com.facebook.buck.step.TargetDevice;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;

import org.kohsuke.args4j.Option;

import javax.annotation.Nullable;

public class TargetDeviceCommandLineOptions {

  @VisibleForTesting public static final String EMULATOR_MODE_SHORT_ARG = "-e";
  @VisibleForTesting static final String EMULATOR_MODE_LONG_ARG = "--emulator";
  @Option(
      name = EMULATOR_MODE_LONG_ARG,
      aliases = {EMULATOR_MODE_SHORT_ARG},
      usage = "Use this option to use emulators only.")
  private boolean useEmulatorsOnlyMode;

  @VisibleForTesting static final String DEVICE_MODE_SHORT_ARG = "-d";
  @VisibleForTesting static final String DEVICE_MODE_LONG_ARG = "--device";
  @Option(
      name = DEVICE_MODE_LONG_ARG,
      aliases = {DEVICE_MODE_SHORT_ARG},
      usage = "Use this option to use real devices only."
  )
  private boolean useRealDevicesOnlyMode;

  @VisibleForTesting static final String SERIAL_NUMBER_SHORT_ARG = "-s";
  @VisibleForTesting static final String SERIAL_NUMBER_LONG_ARG = "--serial";
  @Option(
      name = SERIAL_NUMBER_LONG_ARG,
      aliases = {SERIAL_NUMBER_SHORT_ARG},
      metaVar = "<serial-number>",
      usage = "Use device or emulator with specific serial number."
  )
  @Nullable
  private String serialNumber;

  public TargetDeviceCommandLineOptions() {
  }

  @VisibleForTesting
  TargetDeviceCommandLineOptions(String serial) {
    this.serialNumber = serial;
  }

  public boolean isEmulatorsOnlyModeEnabled() {
    return useEmulatorsOnlyMode;
  }

  public boolean isRealDevicesOnlyModeEnabled() {
    return useRealDevicesOnlyMode;
  }

  @Nullable
  public String getSerialNumber() {
    return serialNumber;
  }

  public boolean hasSerialNumber() {
    return serialNumber != null;
  }

  public Optional<TargetDevice> getTargetDeviceOptional() {
    if (!hasSerialNumber() && !isEmulatorsOnlyModeEnabled() && !isRealDevicesOnlyModeEnabled()) {
      return Optional.absent();
    }

    TargetDevice device = new TargetDevice(
        isEmulatorsOnlyModeEnabled() ? TargetDevice.Type.EMULATOR : TargetDevice.Type.REAL_DEVICE,
        getSerialNumber());
    return Optional.of(device);
  }

  public TargetDeviceOptions getTargetDeviceOptions() {
    return new TargetDeviceOptions(
        useEmulatorsOnlyMode,
        useRealDevicesOnlyMode,
        serialNumber);
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.command.Build;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.Pair;
import com.facebook.buck.parser.BuildFileSpec;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.parser.TargetNodePredicateSpec;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.CachingBuildEngine;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphToActionGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TargetNodes;
import com.facebook.buck.rules.TestRule;
import com.facebook.buck.step.DefaultStepRunner;
import com.facebook.buck.step.TargetDevice;
import com.facebook.buck.test.CoverageReportFormat;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.concurrent.ConcurrencyLimit;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.annotation.Nullable;

public class TestCommand extends BuildCommand {

  public static final String USE_RESULTS_CACHE = "use_results_cache";

  private static final Logger LOG = Logger.get(TestCommand.class);

  @Option(name = "--all",
          usage =
              "Whether all of the tests should be run. " +
              "If no targets are given, --all is implied")
  private boolean all = false;

  @Option(name = "--code-coverage", usage = "Whether code coverage information will be generated.")
  private boolean isCodeCoverageEnabled = false;

  @Option(name = "--code-coverage-format", usage = "Format to be used for coverage")
  private CoverageReportFormat coverageReportFormat = CoverageReportFormat.HTML;

  @Option(name = "--debug",
          usage = "Whether the test will start suspended with a JDWP debug port of 5005")
  private boolean isDebugEnabled = false;

  @Option(name = "--xml", usage = "Where to write test output as XML.")
  @Nullable
  private String pathToXmlTestOutput = null;

  @Option(name = "--no-results-cache", usage = "Whether to use cached test results.")
  @Nullable
  private Boolean isResultsCacheDisabled = null;

  @Option(name = "--build-filtered", usage = "Whether to build filtered out tests.")
  @Nullable
  private Boolean isBuildFiltered = null;

  @Option(
      name = "--ignore-when-dependencies-fail",
      aliases = {"-i"},
      usage =
          "Ignore test failures for libraries if they depend on other libraries " +
          "that aren't passing their tests.  " +
          "For example, if java_library A depends on B, " +
          "and they are tested respectively by T1 and T2 and both of those tests fail, " +
          "only print the error for T2.")
  private boolean isIgnoreFailingDependencies = false;

  @Option(
      name = "--dry-run",
      usage = "Print tests that match the given command line options, but don't run them.")
  private boolean isDryRun;

  @Option(
      name = "--one-time-output",
      usage =
          "Put test-results in a unique, one-time output directory.  " +
          "This allows multiple tests to be run in parallel without interfering with each other, " +
          "but at the expense of being unable to use cached results.  " +
          "WARNING: this is experimental, and only works for Java tests!")
  private boolean isUsingOneTimeOutput;

  @Option(
      name = "--shuffle",
      usage =
          "Randomize the order in which test classes are executed." +
          "WARNING: only works for Java tests!")
  private boolean isShufflingTests;

  @Option(
      name = "--exclude-transitive-tests",
      usage =
          "Only run the tests targets that were specified on the command line (without adding " +
          "more tests by following dependencies).")
  private boolean shouldExcludeTransitiveTests;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceCommandLineOptions targetDeviceOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TestSelectorOptions testSelectorOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TestLabelOptions testLabelOptions;

  public boolean isRunAllTests() {
    return all || getArguments().isEmpty();
  }

  @Override
  public boolean isCodeCoverageEnabled() {
    return isCodeCoverageEnabled;
  }

  public boolean isResultsCacheEnabled(BuckConfig buckConfig) {

    if (isResultsCacheDisabled == null) {
      boolean isUseResultsCache = buckConfig.getBooleanValue("test", USE_RESULTS_CACHE, true);
      isResultsCacheDisabled = !isUseResultsCache;
    }
    return !isResultsCacheDisabled;
  }

  @Override
  public boolean isDebugEnabled() {
    return isDebugEnabled;
  }

  public Optional<TargetDevice> getTargetDeviceOptional() {
    return targetDeviceOptions.getTargetDeviceOptional();
  }

  public boolean isDryRun() {
    return isDryRun;
  }

  public boolean isMatchedByLabelOptions(BuckConfig buckConfig, Set<Label> labels) {
    return testLabelOptions.isMatchedByLabelOptions(buckConfig, labels);
  }

  public boolean shouldExcludeTransitiveTests() {
    return shouldExcludeTransitiveTests;
  }

  public boolean shouldExcludeWin() {
    return testLabelOptions.shouldExcludeWin();
  }

  public boolean isBuildFiltered(BuckConfig buckConfig) {
    return isBuildFiltered != null ?
        isBuildFiltered :
        buckConfig.getBooleanValue("test", "build_filtered_tests", false);
  }

  public int getNumTestThreads(BuckConfig buckConfig) {
    if (isDebugEnabled()) {
      return 1;
    }
    return getNumThreads(buckConfig);
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
    LOG.debug("Running with arguments %s", getArguments());


    if (params.getParser().getParseStartTime().isPresent()) {
      params.getBuckEventBus().post(
          BuildEvent.started(getArguments()),
          params.getParser().getParseStartTime().get());
    } else {
      params.getBuckEventBus().post(BuildEvent.started(getArguments()));
    }



    ParserConfig parserConfig = new ParserConfig(params.getBuckConfig());
    TargetGraph targetGraph;
    ImmutableSet<BuildTarget> explicitBuildTargets;

    try {



      if (isRunAllTests()) {
        targetGraph = params.getParser().buildTargetGraphForTargetNodeSpecs(
            ImmutableList.of(
                TargetNodePredicateSpec.of(
                    new Predicate<TargetNode<?>>() {
                      @Override
                      public boolean apply(TargetNode<?> input) {
                        return input.getType().isTestRule();
                      }
                    },
                    BuildFileSpec.fromRecursivePath(
                        Paths.get(""),
                        params.getRepository().getFilesystem().getIgnorePaths()))),
            parserConfig,
            params.getBuckEventBus(),
            params.getConsole(),
            params.getEnvironment(),
            getEnableProfiling()).getSecond();
        explicitBuildTargets = ImmutableSet.of();



      } else {
        LOG.debug("Parsing graph for arguments %s", getArguments());
        Pair<ImmutableSet<BuildTarget>, TargetGraph> result = params.getParser()
            .buildTargetGraphForTargetNodeSpecs(
                parseArgumentsAsTargetNodeSpecs(
                    params.getBuckConfig(),
                    params.getRepository().getFilesystem().getIgnorePaths(),
                    getArguments()),
                parserConfig,
                params.getBuckEventBus(),
                params.getConsole(),
                params.getEnvironment(),
                getEnableProfiling());
        targetGraph = result.getSecond();
        explicitBuildTargets = result.getFirst();

        LOG.debug("Got explicit build targets %s", explicitBuildTargets);
        ImmutableSet.Builder<BuildTarget> testTargetsBuilder = ImmutableSet.builder();
        for (TargetNode<?> node : targetGraph.getAll(explicitBuildTargets)) {
          ImmutableSortedSet<BuildTarget> nodeTests = TargetNodes.getTestTargetsForNode(node);
          if (!nodeTests.isEmpty()) {
            LOG.debug("Got tests for target %s: %s", node.getBuildTarget(), nodeTests);
            testTargetsBuilder.addAll(nodeTests);
          }
        }
        ImmutableSet<BuildTarget> testTargets = testTargetsBuilder.build();
        if (!testTargets.isEmpty()) {
          LOG.debug("Got related test targets %s, building new target graph...", testTargets);
          targetGraph = params.getParser().buildTargetGraphForBuildTargets(
              Iterables.concat(
                  explicitBuildTargets,
                  testTargets),
              parserConfig,
              params.getBuckEventBus(),
              params.getConsole(),
              params.getEnvironment(),
              getEnableProfiling());
          LOG.debug("Finished building new target graph with tests.");
        }
      }

    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }

    ActionGraph graph = new TargetGraphToActionGraph(
        params.getBuckEventBus(),
        new BuildTargetNodeToBuildRuleTransformer(),
        params.getFileHashCache()).apply(targetGraph);


    Iterable<TestRule> testRules = Iterables.filter(graph.getNodes(), TestRule.class);



    if (!isBuildFiltered(params.getBuckConfig())) {
      testRules = filterTestRules(params.getBuckConfig(), explicitBuildTargets, testRules);
    }

    if (isDryRun()) {
      printMatchingTestRules(params.getConsole(), testRules);
    }

    try (CommandThreadManager pool =
             new CommandThreadManager("Test", getConcurrencyLimit(params.getBuckConfig()))) {
      CachingBuildEngine cachingBuildEngine =
          new CachingBuildEngine(
              pool.getExecutor(),
              getBuildEngineMode().or(params.getBuckConfig().getBuildEngineMode()));
      try (Build build = createBuild(
          params.getBuckConfig(),
          graph,
          params.getRepository().getFilesystem(),
          params.getAndroidPlatformTargetSupplier(),
          cachingBuildEngine,
          getArtifactCache(params),
          params.getConsole(),
          params.getBuckEventBus(),
          getTargetDeviceOptional(),
          params.getPlatform(),
          params.getEnvironment(),
          params.getObjectMapper(),
          params.getClock())) {


        int exitCode = build.executeAndPrintFailuresToConsole(
            testRules,
            isKeepGoing(),
            params.getConsole(),
            getPathToBuildReport(params.getBuckConfig()));
        params.getBuckEventBus().post(BuildEvent.finished(getArguments(), exitCode));
        if (exitCode != 0) {
          return exitCode;
        }



        if (isBuildFiltered(params.getBuckConfig())) {
          testRules =
              filterTestRules(params.getBuckConfig(), explicitBuildTargets, testRules);
        }


        ConcurrencyLimit concurrencyLimit = new ConcurrencyLimit(
            getNumTestThreads(params.getBuckConfig()),
            getLoadLimit(params.getBuckConfig()));
        try (CommandThreadManager testPool =
                 new CommandThreadManager("Test-Run", concurrencyLimit)) {
          TestRunningOptions options = TestRunningOptions.builder()
              .setUsingOneTimeOutputDirectories(isUsingOneTimeOutput)
              .setCodeCoverageEnabled(isCodeCoverageEnabled)
              .setRunAllTests(isRunAllTests())
              .setTestSelectorList(testSelectorOptions.getTestSelectorList())
              .setShouldExplainTestSelectorList(testSelectorOptions.shouldExplain())
              .setIgnoreFailingDependencies(isIgnoreFailingDependencies)
              .setResultsCacheEnabled(isResultsCacheEnabled(params.getBuckConfig()))
              .setDryRun(isDryRun)
              .setShufflingTests(isShufflingTests)
              .setPathToXmlTestOutput(Optional.fromNullable(pathToXmlTestOutput))
              .setCoverageReportFormat(coverageReportFormat)
              .build();
          return TestRunning.runTests(
              params,
              testRules,
              Preconditions.checkNotNull(build.getBuildContext()),
              build.getExecutionContext(),
              options,
              testPool.getExecutor(),
              cachingBuildEngine,
              new DefaultStepRunner(build.getExecutionContext()));
        } catch (ExecutionException e) {
          params.getConsole().printBuildFailureWithoutStacktrace(e);
          return 1;
        }
      }
    }
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

  private void printMatchingTestRules(Console console, Iterable<TestRule> testRules) {
    PrintStream out = console.getStdOut();
    ImmutableList<TestRule> list = ImmutableList.copyOf(testRules);
    out.println(String.format("MATCHING TEST RULES (%d):", list.size()));
    out.println("");
    if (list.isEmpty()) {
      out.println("  (none)");
    } else {
      for (TestRule testRule : testRules) {
        out.println("  " + testRule.getBuildTarget());
      }
    }
    out.println("");
  }

  @VisibleForTesting
  Iterable<TestRule> filterTestRules(
      BuckConfig buckConfig,
      ImmutableSet<BuildTarget> explicitBuildTargets,
      Iterable<TestRule> testRules) {

    ImmutableSortedSet.Builder<TestRule> builder =
        ImmutableSortedSet.orderedBy(
            new Comparator<TestRule>() {
              @Override
              public int compare(TestRule o1, TestRule o2) {
                return o1.getBuildTarget().getFullyQualifiedName().compareTo(
                    o2.getBuildTarget().getFullyQualifiedName());
              }
            });

    for (TestRule rule : testRules) {
      boolean explicitArgument = explicitBuildTargets.contains(rule.getBuildTarget());
      boolean matchesLabel = isMatchedByLabelOptions(buckConfig, rule.getLabels());



      if (shouldExcludeWin() && !matchesLabel) {
        continue;
      }



      if (shouldExcludeTransitiveTests() && !explicitArgument) {
        continue;
      }



      if (explicitArgument || matchesLabel) {
        builder.add(rule);
      }
    }

    return builder.build();
  }

  @Override
  public String getShortDescription() {
    return "builds and runs the tests for the specified target";
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.AdbOptions;
import com.google.common.annotations.VisibleForTesting;

import org.kohsuke.args4j.Option;

public class AdbCommandLineOptions {

  @VisibleForTesting static final String ADB_THREADS_LONG_ARG = "--adb-threads";
  @VisibleForTesting static final String ADB_THREADS_SHORT_ARG = "-T";

  @Option(
      name = ADB_THREADS_LONG_ARG,
      aliases = { ADB_THREADS_SHORT_ARG },
      usage = "Number of threads to use for adb operations. " +
              "Defaults to number of connected devices.")
  private int adbThreadCount = 0;

  @VisibleForTesting static final String MULTI_INSTALL_MODE_SHORT_ARG = "-x";
  @VisibleForTesting static final String MULTI_INSTALL_MODE_LONG_ARG = "-all";
  @Option(
      name = MULTI_INSTALL_MODE_LONG_ARG,
      aliases =  {MULTI_INSTALL_MODE_SHORT_ARG},
      usage = "Install .apk on all connected devices and/or emulators (multi-install mode)"
  )
  private boolean multiInstallMode;

  public AdbOptions getAdbOptions() {
    return new AdbOptions(
        adbThreadCount,
        multiInstallMode);
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.apple.AppleBundle;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleInfoPlistParsing;
import com.facebook.buck.apple.simulator.AppleCoreSimulatorServiceController;
import com.facebook.buck.apple.simulator.AppleSimulator;
import com.facebook.buck.apple.simulator.AppleSimulatorController;
import com.facebook.buck.apple.simulator.AppleSimulatorDiscovery;
import com.facebook.buck.android.AdbHelper;
import com.facebook.buck.android.AdbOptions;
import com.facebook.buck.android.TargetDeviceOptions;
import com.facebook.buck.cli.UninstallCommand.UninstallOptions;
import com.facebook.buck.command.Build;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.ExopackageInfo;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.UnixUserIdFetcher;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.InputStream;

import java.nio.file.Path;

import javax.annotation.Nullable;


public class InstallCommand extends BuildCommand {

  private static final Logger LOG = Logger.get(InstallCommand.class);
  private static final long APPLE_SIMULATOR_WAIT_MILLIS = 20000;

  @VisibleForTesting static final String RUN_LONG_ARG = "--run";
  @VisibleForTesting static final String RUN_SHORT_ARG = "-r";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_LONG_ARG = "--wait-for-debugger";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_SHORT_ARG = "-w";
  @VisibleForTesting static final String INSTALL_VIA_SD_LONG_ARG = "--via-sd";
  @VisibleForTesting static final String INSTALL_VIA_SD_SHORT_ARG = "-S";
  @VisibleForTesting static final String ACTIVITY_LONG_ARG = "--activity";
  @VisibleForTesting static final String ACTIVITY_SHORT_ARG = "-a";
  @VisibleForTesting static final String UNINSTALL_LONG_ARG = "--uninstall";
  @VisibleForTesting static final String UNINSTALL_SHORT_ARG = "-u";

  @Option(
      name = UNINSTALL_LONG_ARG,
      aliases = { UNINSTALL_SHORT_ARG },
      usage = "Uninstall the existing version before installing.")
  private boolean uninstallFirst = false;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbCommandLineOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceCommandLineOptions deviceOptions;

  @Option(
      name = RUN_LONG_ARG,
      aliases = { RUN_SHORT_ARG },
      usage = "Run an activity (the default activity for package unless -a is specified).")
  private boolean run = false;

  @Option(
      name = WAIT_FOR_DEBUGGER_LONG_ARG,
      aliases = { WAIT_FOR_DEBUGGER_SHORT_ARG },
      usage = "Have the launched process wait for the debugger")
  private boolean waitForDebugger = false;

  @Option(
      name = INSTALL_VIA_SD_LONG_ARG,
      aliases = { INSTALL_VIA_SD_SHORT_ARG },
      usage = "Copy package to external storage (SD) instead of /data/local/tmp before installing.")
  private boolean installViaSd = false;

  @Option(
      name = ACTIVITY_LONG_ARG,
      aliases = { ACTIVITY_SHORT_ARG },
      metaVar = "<pkg/activity>",
      usage = "Activity to launch e.g. com.facebook.katana/.LoginActivity. Implies -r.")
  @Nullable
  private String activity = null;

  public AdbOptions adbOptions() {
    return adbOptions.getAdbOptions();
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions.getTargetDeviceOptions();
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public boolean shouldUninstallFirst() {
    return uninstallFirst;
  }

  public boolean shouldStartActivity() {
    return (activity != null) || run;
  }

  public boolean shouldInstallViaSd() {
    return installViaSd;
  }

  @Nullable
  public String getActivityToStart() {
    return activity;
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {

    if (getArguments().size() != 1) {
      params.getConsole().getStdErr().println(
          "Must specify exactly one rule.");
      return 1;
    }


    int exitCode = super.runWithoutHelp(params);
    if (exitCode != 0) {
      return exitCode;
    }

    Build build = super.getBuild();
    ActionGraph graph = build.getActionGraph();
    BuildRule buildRule = Preconditions.checkNotNull(
        graph.findBuildRuleByTarget(getBuildTargets().get(0)));

    if (buildRule instanceof InstallableApk) {
      return installApk(
          params,
          (InstallableApk) buildRule,
          build.getExecutionContext());
    } else if (buildRule instanceof AppleBundle) {
      AppleBundle appleBundle = (AppleBundle) buildRule;
      params.getBuckEventBus().post(InstallEvent.started(appleBundle.getBuildTarget()));
      exitCode = installAppleBundle(
          params,
          appleBundle,
          build.getExecutionContext().getProjectFilesystem(),
          build.getExecutionContext().getProcessExecutor());
      params.getBuckEventBus().post(
          InstallEvent.finished(appleBundle.getBuildTarget(), exitCode == 0));
      return exitCode;
    } else {
      params.getConsole().printBuildFailure(String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() or " +
              "apple_bundle() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
  }

  private int installApk(
      CommandRunnerParams params,
      InstallableApk installableApk,
      ExecutionContext executionContext) throws IOException, InterruptedException {
    final AdbHelper adbHelper = new AdbHelper(
        adbOptions(),
        targetDeviceOptions(),
        executionContext,
        params.getConsole(),
        params.getBuckEventBus(),
        params.getBuckConfig().getRestartAdbOnFailure());


    if (shouldUninstallFirst()) {
      String packageName = AdbHelper.tryToExtractPackageNameFromManifest(
          installableApk,
          executionContext);
      adbHelper.uninstallApp(packageName, uninstallOptions().shouldKeepUserData());

    }

    boolean installSuccess;
    Optional<ExopackageInfo> exopackageInfo = installableApk.getExopackageInfo();
    if (exopackageInfo.isPresent()) {
      installSuccess = new ExopackageInstaller(
          executionContext,
          adbHelper,
          installableApk)
          .install();
    } else {
      installSuccess = adbHelper.installApk(installableApk, shouldInstallViaSd());
    }
    if (!installSuccess) {
      return 1;
    }



    if (shouldStartActivity()) {
      int exitCode = adbHelper.startActivity(installableApk, getActivityToStart());
      if (exitCode != 0) {
        return exitCode;
      }
    }

    return 0;
  }

  private int installAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor) throws IOException, InterruptedException {


    AppleConfig appleConfig = new AppleConfig(params.getBuckConfig());
    Optional<Path> xcodeDeveloperPath = appleConfig.getAppleDeveloperDirectorySupplier(
        processExecutor).get();
    if (!xcodeDeveloperPath.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (Xcode not found)", appleBundle.getFullyQualifiedName()));
      return 1;
    }

    UnixUserIdFetcher userIdFetcher = new UnixUserIdFetcher();
    AppleCoreSimulatorServiceController appleCoreSimulatorServiceController =
        new AppleCoreSimulatorServiceController(processExecutor);

    Optional<Path> coreSimulatorServicePath =
        appleCoreSimulatorServiceController.getCoreSimulatorServicePath(userIdFetcher);

    boolean shouldWaitForSimulatorsToShutdown = false;

    if (!coreSimulatorServicePath.isPresent() ||
        !coreSimulatorServicePath.get().toRealPath().startsWith(
            xcodeDeveloperPath.get().toRealPath())) {
      LOG.warn(
          "Core simulator service path %s does not match developer directory %s, " +
          "killing all simulators.",
          coreSimulatorServicePath,
          xcodeDeveloperPath.get());
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return 1;
      }

      shouldWaitForSimulatorsToShutdown = true;
    }

    Path simctlPath = xcodeDeveloperPath.get().resolve("usr/bin/simctl");
    Optional<AppleSimulator> appleSimulator = getAppleSimulatorForBundle(
        appleBundle,
        processExecutor,
        simctlPath);

    if (!appleSimulator.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (no appropriate simulator found)",
              appleBundle.getFullyQualifiedName()));
      return 1;
    }

    Path iosSimulatorPath = xcodeDeveloperPath.get().resolve("Applications/iOS Simulator.app");
    AppleSimulatorController appleSimulatorController = new AppleSimulatorController(
        processExecutor,
        simctlPath,
        iosSimulatorPath);

    if (!appleSimulatorController.canStartSimulator(appleSimulator.get().getUdid())) {
      LOG.warn("Cannot start simulator %s, killing simulators and trying again.");
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return 1;
      }

      shouldWaitForSimulatorsToShutdown = true;


      appleSimulator = getAppleSimulatorForBundle(appleBundle, processExecutor, simctlPath);
      if (!appleSimulator.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (no appropriate simulator found)",
                appleBundle.getFullyQualifiedName()));
        return 1;
      }
    }

    long remainingMillis = APPLE_SIMULATOR_WAIT_MILLIS;
    if (shouldWaitForSimulatorsToShutdown) {
      Optional<Long> shutdownMillis = appleSimulatorController.waitForSimulatorsToShutdown(
          remainingMillis);
      if (!shutdownMillis.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (simulators did not shut down within %d ms).",
                appleBundle.getFullyQualifiedName(),
                APPLE_SIMULATOR_WAIT_MILLIS));
        return 1;
      }

      LOG.debug("Simulators shut down in %d millis.", shutdownMillis.get());
      remainingMillis -= shutdownMillis.get();
    }

    LOG.debug("Starting up simulator %s", appleSimulator.get());

    Optional<Long> startMillis = appleSimulatorController.startSimulator(
        appleSimulator.get().getUdid(),
        remainingMillis);

    if (!startMillis.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not start simulator %s within %d ms)",
              appleBundle.getFullyQualifiedName(),
              appleSimulator.get().getName(),
              APPLE_SIMULATOR_WAIT_MILLIS));
      return 1;
    }

    LOG.debug(
        "Simulator started in %d ms. Installing Apple bundle %s in simulator %s",
        startMillis.get(),
        appleBundle,
        appleSimulator.get());

    if (!appleSimulatorController.installBundleInSimulator(
            appleSimulator.get().getUdid(),
            projectFilesystem.resolve(appleBundle.getPathToOutput()))) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not install bundle %s in simulator %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getPathToOutput(),
              appleSimulator.get().getName()));
      return 1;
    }

    if (run) {
      return launchAppleBundle(
          params,
          appleBundle,
          appleSimulatorController,
          projectFilesystem,
          appleSimulator.get());
    } else {
      params.getConsole().printSuccess(
          String.format(
              "Successfully installed %s. (Use `buck install -r %s` to run.)",
              getArguments().get(0),
              getArguments().get(0)));
      return 0;
    }
  }

  private int launchAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      AppleSimulatorController appleSimulatorController,
      ProjectFilesystem projectFilesystem,
      AppleSimulator appleSimulator) throws IOException, InterruptedException {

    LOG.debug("Launching Apple bundle %s in simulator %s", appleBundle, appleSimulator);

    Optional<String> appleBundleId;
    try (InputStream bundlePlistStream =
             projectFilesystem.getInputStreamForRelativePath(appleBundle.getInfoPlistPath())){
        appleBundleId = AppleInfoPlistParsing.getBundleIdFromPlistStream(bundlePlistStream);
    }
    if (!appleBundleId.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not get bundle ID from %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getInfoPlistPath()));
      return 1;
    }

    Optional<Long> launchedPid = appleSimulatorController.launchInstalledBundleInSimulator(
        appleSimulator.getUdid(),
        appleBundleId.get(),
        waitForDebugger ? AppleSimulatorController.LaunchBehavior.WAIT_FOR_DEBUGGER :
            AppleSimulatorController.LaunchBehavior.DO_NOT_WAIT_FOR_DEBUGGER);
    if (!launchedPid.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot launch %s (failed to launch bundle ID %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundleId.get()));
      return 1;
    }

    params.getConsole().printSuccess(
        String.format(
            "Successfully launched %s%s. To debug, run: lldb -p %d",
            getArguments().get(0),
            waitForDebugger ? " (waiting for debugger)" : "",
            launchedPid.get()));

    return 0;
  }

  private Optional<AppleSimulator> getAppleSimulatorForBundle(
      AppleBundle appleBundle,
      ProcessExecutor processExecutor,
      Path simctlPath) throws IOException, InterruptedException {
    LOG.debug("Choosing simulator for %s", appleBundle);

    for (AppleSimulator simulator : AppleSimulatorDiscovery.discoverAppleSimulators(
             processExecutor,
             simctlPath)) {


      if (simulator.getName().equals("iPhone 5s")) {
        return Optional.of(simulator);
      }
    }

    return Optional.<AppleSimulator>absent();
  }

  @Override
  public String getShortDescription() {
    return "builds and installs an application";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.AdbHelper;
import com.facebook.buck.android.AdbOptions;
import com.facebook.buck.android.TargetDeviceOptions;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetException;
import com.facebook.buck.model.Pair;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetGraphToActionGraph;
import com.facebook.buck.rules.TargetGraphTransformer;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.util.List;

public class UninstallCommand extends AbstractCommand {

  public static class UninstallOptions {
    @VisibleForTesting static final String KEEP_LONG_ARG = "--keep";
    @VisibleForTesting static final String KEEP_SHORT_ARG = "-k";
    @Option(
        name = KEEP_LONG_ARG,
        aliases = { KEEP_SHORT_ARG },
        usage = "Keep user data when uninstalling.")
    private boolean keepData = false;

    public boolean shouldKeepUserData() {
      return keepData;
    }
  }

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbCommandLineOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceCommandLineOptions deviceOptions;

  @Argument
  private List<String> arguments = Lists.newArrayList();

  public List<String> getArguments() {
    return arguments;
  }

  @VisibleForTesting
  void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public AdbOptions adbOptions() {
    return adbOptions.getAdbOptions();
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions.getTargetDeviceOptions();
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {


    ActionGraph actionGraph;
    ImmutableSet<BuildTarget> buildTargets;
    try {
      Pair<ImmutableSet<BuildTarget>, TargetGraph> result = params.getParser()
          .buildTargetGraphForTargetNodeSpecs(
              parseArgumentsAsTargetNodeSpecs(
                  params.getBuckConfig(),
                  params.getRepository().getFilesystem().getIgnorePaths(),
                  getArguments()),
              new ParserConfig(params.getBuckConfig()),
              params.getBuckEventBus(),
              params.getConsole(),
              params.getEnvironment(),
              getEnableProfiling());
      buildTargets = result.getFirst();
      TargetGraphTransformer<ActionGraph> targetGraphTransformer = new TargetGraphToActionGraph(
          params.getBuckEventBus(),
          new BuildTargetNodeToBuildRuleTransformer(),
          params.getFileHashCache());
      actionGraph = targetGraphTransformer.apply(result.getSecond());
    } catch (BuildTargetException | BuildFileParseException e) {
      params.getConsole().printBuildFailureWithoutStacktrace(e);
      return 1;
    }


    if (buildTargets.size() != 1) {
      params.getConsole().getStdErr().println("Must specify exactly one android_binary() rule.");
      return 1;
    }
    BuildTarget buildTarget = Iterables.get(buildTargets, 0);


    BuildRule buildRule = Preconditions.checkNotNull(
        actionGraph.findBuildRuleByTarget(buildTarget));
    if (!(buildRule instanceof InstallableApk)) {
      params.getConsole().printBuildFailure(
          String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
    InstallableApk installableApk = (InstallableApk) buildRule;


    try (ExecutionContext context = createExecutionContext(params)) {
      final AdbHelper adbHelper = new AdbHelper(
          adbOptions(),
          targetDeviceOptions(),
          context,
          params.getConsole(),
          params.getBuckEventBus(),
          params.getBuckConfig().getRestartAdbOnFailure());


      String appId = AdbHelper.tryToExtractPackageNameFromManifest(installableApk, context);
      return adbHelper.uninstallApp(
          appId,
          uninstallOptions().shouldKeepUserData()
      ) ? 0 : 1;
    }
  }

  @Override
  public String getShortDescription() {
    return "uninstalls an APK";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.cli;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.InstallException;
import com.facebook.buck.android.AdbHelper;
import com.facebook.buck.android.agent.util.AgentUtil;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.TraceEventLogger;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.ExopackageInfo;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.util.NamedTemporaryFile;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Splitter;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class ExopackageInstaller {

  private static final Logger LOG = Logger.get(ExopackageInstaller.class);


  private static final String AGENT_DEVICE_PATH = "/data/app/" + AgentUtil.AGENT_PACKAGE_NAME;


  private static final String JAVA_AGENT_COMMAND =
      "dalvikvm -classpath " +
      AGENT_DEVICE_PATH + "-1.apk:" + AGENT_DEVICE_PATH + "-2.apk:" +
      AGENT_DEVICE_PATH + "-1/base.apk:" + AGENT_DEVICE_PATH + "-2/base.apk " +
      "com.facebook.buck.android.agent.AgentMain ";


  private static final int MAX_ADB_COMMAND_SIZE = 1019;

  private static final Path SECONDARY_DEX_DIR = Paths.get("secondary-dex");

  private static final Path NATIVE_LIBS_DIR = Paths.get("native-libs");

  @VisibleForTesting
  static final Pattern DEX_FILE_PATTERN = Pattern.compile("secondary-([0-9a-f]+)\\.[\\w.-]*");

  @VisibleForTesting
  static final Pattern NATIVE_LIB_PATTERN = Pattern.compile("native-([0-9a-f]+)\\.so");

  private final ProjectFilesystem projectFilesystem;
  private final BuckEventBus eventBus;
  private final AdbHelper adbHelper;
  private final InstallableApk apkRule;
  private final String packageName;
  private final Path dataRoot;

  private final ExopackageInfo exopackageInfo;


  private final AtomicInteger nextAgentPort = new AtomicInteger(2828);

  @VisibleForTesting
  static class PackageInfo {
    final String apkPath;
    final String nativeLibPath;
    final String versionCode;
    private PackageInfo(String apkPath, String nativeLibPath, String versionCode) {
      this.nativeLibPath = nativeLibPath;
      this.apkPath = apkPath;
      this.versionCode = versionCode;
    }
  }

  public ExopackageInstaller(
      ExecutionContext context,
      AdbHelper adbHelper,
      InstallableApk apkRule) {
    this.adbHelper = adbHelper;
    this.projectFilesystem = context.getProjectFilesystem();
    this.eventBus = context.getBuckEventBus();
    this.apkRule = apkRule;
    this.packageName = AdbHelper.tryToExtractPackageNameFromManifest(apkRule, context);
    this.dataRoot = Paths.get("/data/local/tmp/exopackage/").resolve(packageName);

    Preconditions.checkArgument(AdbHelper.PACKAGE_NAME_PATTERN.matcher(packageName).matches());

    Optional<ExopackageInfo> exopackageInfo = apkRule.getExopackageInfo();
    Preconditions.checkArgument(exopackageInfo.isPresent());
    this.exopackageInfo = exopackageInfo.get();
  }


  public synchronized boolean install() throws InterruptedException {
    eventBus.post(InstallEvent.started(apkRule.getBuildTarget()));

    boolean success = adbHelper.adbCall(
        new AdbHelper.AdbCallable() {
          @Override
          public boolean call(IDevice device) throws Exception {
            try {
              return new SingleDeviceInstaller(device, nextAgentPort.getAndIncrement()).doInstall();
            } catch (Exception e) {
              throw new RuntimeException("Failed to install exopackage on " + device, e);
            }
          }

          @Override
          public String toString() {
            return "install exopackage";
          }
        });

    eventBus.post(InstallEvent.finished(apkRule.getBuildTarget(), success));
    return success;
  }


  private class SingleDeviceInstaller {


    private final IDevice device;


    private final int agentPort;


    private boolean useNativeAgent = true;


    @Nullable
    private String nativeAgentPath;

    private SingleDeviceInstaller(IDevice device, int agentPort) {
      this.device = device;
      this.agentPort = agentPort;
    }

    boolean doInstall() throws Exception {
      Optional<PackageInfo> agentInfo = installAgentIfNecessary();
      if (!agentInfo.isPresent()) {
        return false;
      }

      nativeAgentPath = agentInfo.get().nativeLibPath;
      determineBestAgent();

      final File apk = apkRule.getApkPath().toFile();

      final boolean installViaSd = false;

      if (shouldAppBeInstalled()) {
        try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "install_exo_apk")) {
          boolean success = adbHelper.installApkOnDevice(device, apk, installViaSd);
          if (!success) {
            return false;
          }
        }
      }

      if (exopackageInfo.getDexInfo().isPresent()) {
        installSecondaryDexFiles();
      }

      if (exopackageInfo.getNativeLibsInfo().isPresent()) {
        installNativeLibraryFiles();
      }


      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "kill_app")) {
        AdbHelper.executeCommandWithErrorChecking(device, "am force-stop " + packageName);
      }

      return true;
    }

    private void installSecondaryDexFiles() throws Exception {
      final ImmutableMap<String, Path> hashToSources = getRequiredDexFiles();
      final ImmutableSet<String> requiredHashes = hashToSources.keySet();
      final ImmutableSet<String> presentHashes = prepareSecondaryDexDir(requiredHashes);
      final Set<String> hashesToInstall = Sets.difference(requiredHashes, presentHashes);

      Map<String, Path> filesToInstallByHash =
          Maps.filterKeys(hashToSources, Predicates.in(hashesToInstall));









      String metadataContents = com.google.common.io.Files.toString(
          exopackageInfo.getDexInfo().get().getMetadata().toFile(),
          Charsets.UTF_8)
          .replaceAll(
              "secondary-(\\d+)\\.dex\\.jar (\\p{XDigit}{40}) ",
              "secondary-$2.dex.jar $2 ");

      installFiles(
          "secondary_dex",
          ImmutableMap.copyOf(filesToInstallByHash),
          metadataContents,
          "secondary-%s.dex.jar",
          SECONDARY_DEX_DIR);
    }

    private ImmutableList<String> getDeviceAbis() throws Exception {
      ImmutableList.Builder<String> abis = ImmutableList.builder();

      String abiListProperty = getProperty("ro.product.cpu.abilist");
      if (!abiListProperty.isEmpty()) {
        abis.addAll(Splitter.on(',').splitToList(abiListProperty));
      } else {
        String abi1 = getProperty("ro.product.cpu.abi");
        if (abi1.isEmpty()) {
          throw new RuntimeException("adb returned empty result for ro.product.cpu.abi property.");
        }

        abis.add(abi1);
        String abi2 = getProperty("ro.product.cpu.abi2");
        if (!abi2.isEmpty()) {
          abis.add(abi2);
        }
      }

      return abis.build();
    }

    private void installNativeLibraryFiles() throws Exception {
      ImmutableMultimap<String, Path> allLibraries = getAllLibraries();
      ImmutableSet.Builder<String> providedLibraries = ImmutableSet.builder();
      for (String abi : getDeviceAbis()) {
        ImmutableMap<String, Path> libraries =
            getRequiredLibrariesForAbi(allLibraries, abi, providedLibraries.build());

        installNativeLibrariesForAbi(abi, libraries);
        providedLibraries.addAll(libraries.keySet());
      }
    }

    private void installNativeLibrariesForAbi(String abi, ImmutableMap<String, Path> libraries)
        throws Exception {
      if (libraries.isEmpty()) {
        return;
      }

      ImmutableSet<String> requiredHashes = libraries.keySet();
      ImmutableSet<String> presentHashes = prepareNativeLibsDir(abi, requiredHashes);

      Map<String, Path> filesToInstallByHash =
          Maps.filterKeys(libraries, Predicates.not(Predicates.in(presentHashes)));

      String metadataContents = Joiner.on('\n').join(
          FluentIterable.from(libraries.entrySet()).transform(
              new Function<Map.Entry<String, Path>, String>() {
                @Override
                public String apply(Map.Entry<String, Path> input) {
                  String hash = input.getKey();
                  String filename = input.getValue().getFileName().toString();
                  int index = filename.indexOf('.');
                  String libname = index == -1 ? filename : filename.substring(0, index);
                  return String.format("%s native-%s.so", libname, hash);
                }
              }));

      installFiles(
          "native_library",
          ImmutableMap.copyOf(filesToInstallByHash),
          metadataContents,
          "native-%s.so",
          NATIVE_LIBS_DIR.resolve(abi));
    }


    private void determineBestAgent() throws Exception {
      String value = getProperty("ro.build.version.sdk");
      try {
        if (Integer.valueOf(value.trim()) > 19) {
          useNativeAgent = false;
        }
      } catch (NumberFormatException exn) {
        useNativeAgent = false;
      }
    }

    private String getAgentCommand() {
      if (useNativeAgent) {
        return nativeAgentPath + "/libagent.so ";
      } else {
        return JAVA_AGENT_COMMAND;
      }
    }

    private Optional<PackageInfo> getPackageInfo(final String packageName) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(
          eventBus,
          "get_package_info",
          ImmutableMap.of("package", packageName))) {


        String lines = AdbHelper.executeCommandWithErrorChecking(
            device, "dumpsys package " + packageName);

        return parsePackageInfo(packageName, lines);
      }
    }


    private Optional<PackageInfo> installAgentIfNecessary() throws Exception {
      Optional<PackageInfo> agentInfo = getPackageInfo(AgentUtil.AGENT_PACKAGE_NAME);
      if (!agentInfo.isPresent()) {
        LOG.debug("Agent not installed.  Installing.");
        return installAgentApk();
      }
      LOG.debug("Agent version: %s", agentInfo.get().versionCode);
      if (!agentInfo.get().versionCode.equals(AgentUtil.AGENT_VERSION_CODE)) {


        uninstallAgent();
        return installAgentApk();
      }
      return agentInfo;
    }

    private void uninstallAgent() throws InstallException {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "uninstall_old_agent")) {
        device.uninstallPackage(AgentUtil.AGENT_PACKAGE_NAME);
      }
    }

    private Optional<PackageInfo> installAgentApk() throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "install_agent_apk")) {
        String apkFileName = System.getProperty("buck.android_agent_path");
        if (apkFileName == null) {
          throw new RuntimeException("Android agent apk path not specified in properties");
        }
        File apkPath = new File(apkFileName);
        boolean success = adbHelper.installApkOnDevice(device, apkPath,  false);
        if (!success) {
          return Optional.absent();
        }
        return getPackageInfo(AgentUtil.AGENT_PACKAGE_NAME);
      }
    }

    private boolean shouldAppBeInstalled() throws Exception {
      Optional<PackageInfo> appPackageInfo = getPackageInfo(packageName);
      if (!appPackageInfo.isPresent()) {
        eventBus.post(ConsoleEvent.info("App not installed.  Installing now."));
        return true;
      }

      LOG.debug("App path: %s", appPackageInfo.get().apkPath);
      String installedAppSignature = getInstalledAppSignature(appPackageInfo.get().apkPath);
      String localAppSignature = AgentUtil.getJarSignature(apkRule.getApkPath().toString());
      LOG.debug("Local app signature: %s", localAppSignature);
      LOG.debug("Remote app signature: %s", installedAppSignature);

      if (!installedAppSignature.equals(localAppSignature)) {
        LOG.debug("App signatures do not match.  Must re-install.");
        return true;
      }

      LOG.debug("App signatures match.  No need to install.");
      return false;
    }

    private String getInstalledAppSignature(final String packagePath) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "get_app_signature")) {
        String command = getAgentCommand() + "get-signature " + packagePath;
        LOG.debug("Executing %s", command);
        String output = AdbHelper.executeCommandWithErrorChecking(device, command);

        String result = output.trim();
        if (result.contains("\n") || result.contains("\r")) {
          throw new IllegalStateException("Unexpected return from get-signature:\n" + output);
        }

        return result;
      }
    }

    private ImmutableMap<String, Path> getRequiredDexFiles() throws IOException {
      ExopackageInfo.DexInfo dexInfo = exopackageInfo.getDexInfo().get();
      ImmutableMultimap<String, Path> multimap = parseExopackageInfoMetadata(
          dexInfo.getMetadata(),
          dexInfo.getDirectory(),
          projectFilesystem);

      ImmutableMap.Builder<String, Path> builder = ImmutableMap.builder();
      for (Map.Entry<String, Path> entry : multimap.entries()) {
        builder.put(entry);
      }
      return builder.build();
    }

    private ImmutableSet<String> prepareSecondaryDexDir(ImmutableSet<String> requiredHashes)
        throws Exception {
      return prepareDirectory("secondary-dex", DEX_FILE_PATTERN, requiredHashes);
    }

    private ImmutableSet<String> prepareNativeLibsDir(
        String abi,
        ImmutableSet<String> requiredHashes) throws Exception {
      return prepareDirectory("native-libs/" + abi, NATIVE_LIB_PATTERN, requiredHashes);
    }

    private ImmutableSet<String> prepareDirectory(
        String dirname,
        Pattern filePattern,
        ImmutableSet<String> requiredHashes) throws Exception {
      try (TraceEventLogger ignored = TraceEventLogger.start(eventBus, "prepare_" + dirname)) {
        String dirPath = dataRoot.resolve(dirname).toString();
        mkDirP(dirPath);

        String output = AdbHelper.executeCommandWithErrorChecking(device, "ls " + dirPath);

        ImmutableSet.Builder<String> foundHashes = ImmutableSet.builder();
        ImmutableSet.Builder<String> filesToDelete = ImmutableSet.builder();

        processLsOutput(output, filePattern, requiredHashes, foundHashes, filesToDelete);

        String commandPrefix = "cd " + dirPath + " && rm ";

        final int overhead = commandPrefix.length() + 100;
        for (List<String> rmArgs :
            chunkArgs(filesToDelete.build(), MAX_ADB_COMMAND_SIZE - overhead)) {
          String command = commandPrefix + Joiner.on(' ').join(rmArgs);
          LOG.debug("Executing %s", command);
          AdbHelper.executeCommandWithErrorChecking(device, command);
        }

        return foundHashes.build();
      }
    }

    private void installFiles(
        String filesType,
        ImmutableMap<String, Path> filesToInstallByHash,
        String metadataFileContents,
        String filenameFormat,
        Path destinationDirRelativeToDataRoot) throws Exception {
      try (TraceEventLogger ignored1 =
               TraceEventLogger.start(eventBus, "multi_install_" + filesType)) {
        device.createForward(agentPort, agentPort);
        try {
          for (Map.Entry<String, Path> entry : filesToInstallByHash.entrySet()) {
            Path destination = destinationDirRelativeToDataRoot.resolve(
                String.format(filenameFormat, entry.getKey()));
            Path source = entry.getValue();

            try (TraceEventLogger ignored2 =
                     TraceEventLogger.start(eventBus, "install_" + filesType)) {
              installFile(device, agentPort, destination, source);
            }
          }
          try (TraceEventLogger ignored3 =
                   TraceEventLogger.start(eventBus, "install_" + filesType + "_metadata")) {
            try (NamedTemporaryFile temp = new NamedTemporaryFile("metadata", "tmp")) {
              com.google.common.io.Files.write(
                  metadataFileContents.getBytes(Charsets.UTF_8),
                  temp.get().toFile());
              installFile(
                  device,
                  agentPort,
                  destinationDirRelativeToDataRoot.resolve("metadata.txt"),
                  temp.get());
            }
          }
        } finally {
          try {
            device.removeForward(agentPort, agentPort);
          } catch (AdbCommandRejectedException e) {
            LOG.warn(e, "Failed to remove adb forward on port %d for device %s", agentPort, device);
            eventBus.post(
                ConsoleEvent.warning(
                    "Failed to remove adb forward %d. This is not necessarily a problem\n" +
                        "because it will be recreated during the next exopackage installation.\n" +
                        "See the log for the full exception.",
                    agentPort));
          }
        }
      }
    }

    private void installFile(
        IDevice device,
        final int port,
        Path pathRelativeToDataRoot,
        final Path source) throws Exception {
      CollectingOutputReceiver receiver = new CollectingOutputReceiver() {

        private boolean sentPayload = false;

        @Override
        public void addOutput(byte[] data, int offset, int length) {
          super.addOutput(data, offset, length);
          if (!sentPayload && getOutput().length() >= AgentUtil.TEXT_SECRET_KEY_SIZE) {
            LOG.verbose("Got key: %s", getOutput().trim());

            sentPayload = true;
            try (Socket clientSocket = new Socket("localhost", port)) {
              LOG.verbose("Connected");
              OutputStream outToDevice = clientSocket.getOutputStream();
              outToDevice.write(
                  getOutput().substring(
                      0,
                      AgentUtil.TEXT_SECRET_KEY_SIZE).getBytes());
              LOG.verbose("Wrote key");
              com.google.common.io.Files.asByteSource(source.toFile()).copyTo(outToDevice);
              LOG.verbose("Wrote file");
            } catch (IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
      };

      String targetFileName = dataRoot.resolve(pathRelativeToDataRoot).toString();
      String command =
          "umask 022 && " +
              getAgentCommand() +
              "receive-file " + port + " " + Files.size(source) + " " +
              targetFileName +
              " ; echo -n :$?";
      LOG.debug("Executing %s", command);



      Exception shellException = null;
      try {
        device.executeShellCommand(command, receiver);
      } catch (Exception e) {
        shellException = e;
      }

      try {
        AdbHelper.checkReceiverOutput(command, receiver);
      } catch (Exception e) {
        if (shellException != null) {
          e.addSuppressed(shellException);
        }
        throw e;
      }

      if (shellException != null) {
        throw shellException;
      }






      AdbHelper.executeCommandWithErrorChecking(device, "chmod 644 " + targetFileName);
    }

    private String getProperty(String property) throws Exception {
      return AdbHelper.executeCommandWithErrorChecking(device, "getprop " + property).trim();
    }

    private void mkDirP(String dirpath) throws Exception {



      String mkdirP = useNativeAgent ? getAgentCommand() + "mkdir-p" : "mkdir -p";

      AdbHelper.executeCommandWithErrorChecking(device, "umask 022 && " + mkdirP + " " + dirpath);
    }
  }

  private ImmutableMultimap<String, Path> getAllLibraries() throws IOException {
    ExopackageInfo.NativeLibsInfo nativeLibsInfo = exopackageInfo.getNativeLibsInfo().get();
    return parseExopackageInfoMetadata(
        nativeLibsInfo.getMetadata(),
        nativeLibsInfo.getDirectory(),
        projectFilesystem);
  }

  private ImmutableMap<String, Path> getRequiredLibrariesForAbi(
      ImmutableMultimap<String, Path> allLibraries,
      String abi,
      ImmutableSet<String> ignoreLibraries) throws IOException {
    return filterLibrariesForAbi(
        exopackageInfo.getNativeLibsInfo().get().getDirectory(),
        allLibraries,
        abi,
        ignoreLibraries);
  }

  @VisibleForTesting
  static ImmutableMap<String, Path> filterLibrariesForAbi(
      Path nativeLibsDir,
      ImmutableMultimap<String, Path> allLibraries,
      String abi,
      ImmutableSet<String> ignoreLibraries) {
    ImmutableMap.Builder<String, Path> filteredLibraries = ImmutableMap.builder();
    for (Map.Entry<String, Path> entry : allLibraries.entries()) {
      Path relativePath = nativeLibsDir.relativize(entry.getValue());
      Preconditions.checkState(relativePath.getNameCount() == 2);
      String libAbi = relativePath.getParent().toString();
      String libName = relativePath.getFileName().toString();
      if (libAbi.equals(abi) && !ignoreLibraries.contains(libName)) {
        filteredLibraries.put(entry);
      }
    }
    return filteredLibraries.build();
  }


  @VisibleForTesting
  static ImmutableMultimap<String, Path> parseExopackageInfoMetadata(
      Path metadataTxt,
      Path resolvePathAgainst,
      ProjectFilesystem filesystem) throws IOException {
    ImmutableMultimap.Builder<String, Path> builder = ImmutableMultimap.builder();
    for (String line : filesystem.readLines(metadataTxt)) {
      List<String> parts = Splitter.on(' ').splitToList(line);
      if (parts.size() < 2) {
        throw new RuntimeException("Illegal line in metadata file: " + line);
      }
      builder.put(parts.get(1), resolvePathAgainst.resolve(parts.get(0)));
    }
    return builder.build();
  }

  @VisibleForTesting
  static Optional<PackageInfo> parsePackageInfo(String packageName, String lines) {
    final String packagePrefix = "  Package [" + packageName + "] (";
    final String otherPrefix = "  Package [";
    boolean sawPackageLine = false;
    final Splitter splitter = Splitter.on('=').limit(2);

    String codePath = null;
    String resourcePath = null;
    String nativeLibPath = null;
    String versionCode = null;

    for (String line : Splitter.on("\r\n").split(lines)) {

      if (line.startsWith(packagePrefix)) {
        sawPackageLine = true;
        continue;
      }

      if (line.startsWith(otherPrefix)) {
        break;
      }

      if (!sawPackageLine) {
        continue;
      }

      List<String> parts = splitter.splitToList(line.trim());
      if (parts.size() != 2) {
        continue;
      }
      switch (parts.get(0)) {
        case "codePath":
          codePath = parts.get(1);
          break;
        case "resourcePath":
          resourcePath = parts.get(1);
          break;
        case "nativeLibraryPath":
          nativeLibPath = parts.get(1);
          break;



        case "legacyNativeLibraryDir":
          nativeLibPath = parts.get(1);
          break;
        case "versionCode":

          versionCode = parts.get(1).split(" ", 2)[0];
          break;
        default:
          break;
      }
    }

    if (!sawPackageLine) {
      return Optional.absent();
    }

    Preconditions.checkNotNull(codePath, "Could not find codePath");
    Preconditions.checkNotNull(resourcePath, "Could not find resourcePath");
    Preconditions.checkNotNull(nativeLibPath, "Could not find nativeLibraryPath");
    Preconditions.checkNotNull(versionCode, "Could not find versionCode");
    if (!codePath.equals(resourcePath)) {
      throw new IllegalStateException("Code and resource path do not match");
    }


    if (!codePath.endsWith(".apk")) {
      codePath += "/base.apk";
    }

    return Optional.of(new PackageInfo(codePath, nativeLibPath, versionCode));
  }


  @VisibleForTesting
  static void processLsOutput(
      String output,
      Pattern filePattern,
      ImmutableSet<String> requiredHashes,
      ImmutableSet.Builder<String> foundHashes,
      ImmutableSet.Builder<String> toDelete) {
    for (String line : Splitter.on("\r\n").omitEmptyStrings().split(output)) {
      if (line.equals("lock")) {
        continue;
      }

      Matcher m = filePattern.matcher(line);
      if (m.matches()) {
        if (requiredHashes.contains(m.group(1))) {
          foundHashes.add(m.group(1));
        } else {
          toDelete.add(line);
        }
      } else {
        toDelete.add(line);
      }
    }
  }


  @VisibleForTesting
  static ImmutableList<ImmutableList<String>> chunkArgs(Iterable<String> args, int sizeLimit) {
    ImmutableList.Builder<ImmutableList<String>> topLevelBuilder = ImmutableList.builder();
    ImmutableList.Builder<String> chunkBuilder = ImmutableList.builder();
    int chunkSize = 0;
    for (String arg : args) {
      if (chunkSize + arg.length() > sizeLimit) {
        topLevelBuilder.add(chunkBuilder.build());
        chunkBuilder = ImmutableList.builder();
        chunkSize = 0;
      }


      chunkBuilder.add(arg);
      chunkSize += arg.length();
    }
    ImmutableList<String> tail = chunkBuilder.build();
    if (!tail.isEmpty()) {
      topLevelBuilder.add(tail);
    }
    return topLevelBuilder.build();
  }
}

<code block>


package com.facebook.buck.android;

import com.android.ddmlib.AdbCommandRejectedException;
import com.android.ddmlib.Client;
import com.android.ddmlib.FileListingService;
import com.android.ddmlib.IDevice;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.InstallException;
import com.android.ddmlib.RawImage;
import com.android.ddmlib.ScreenRecorderOptions;
import com.android.ddmlib.ShellCommandUnresponsiveException;
import com.android.ddmlib.SyncException;
import com.android.ddmlib.SyncService;
import com.android.ddmlib.TimeoutException;
import com.android.ddmlib.log.LogReceiver;
import com.google.common.collect.Maps;

import java.io.IOException;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.TimeUnit;


public class TestDevice implements IDevice {

  private boolean isEmulator;
  private String name;
  private String serialNumber;
  private DeviceState state;
  private Map<String, String> properties;

  public static TestDevice createEmulator(String serial) {
    TestDevice device = new TestDevice();
    device.setIsEmulator(true);
    device.setSerialNumber(serial);
    device.setName("emulator-" + serial);
    device.setState(DeviceState.ONLINE);
    return device;
  }

  public static TestDevice createRealDevice(String serial) {
    TestDevice device = new TestDevice();
    device.setIsEmulator(false);
    device.setSerialNumber(serial);
    device.setName("device-" + serial);
    device.setState(DeviceState.ONLINE);
    return device;
  }

  public TestDevice() {
    properties = Maps.newHashMap();
  }

  public void setSerialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
  }

  @Override
  public String getSerialNumber() {
    return serialNumber;
  }

  @Override
  public String getAvdName() {
    if (isEmulator()) {
      return name;
    } else {
      return null;
    }
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public String getName() {
    return name;
  }

  public void setIsEmulator(boolean isEmulator) {
    this.isEmulator = isEmulator;
  }

  @Override
  public boolean isEmulator() {
    return isEmulator;
  }

  public void setState(DeviceState state) {
    this.state = state;
  }

  @Override
  public DeviceState getState() {
    return state;
  }

  @Override
  public boolean isOnline() {
    return state == DeviceState.ONLINE;
  }

  @Override
  public boolean isOffline() {
    return state == DeviceState.OFFLINE;
  }

  @Override
  public boolean isBootLoader() {
    return state == DeviceState.BOOTLOADER;
  }

  @Override
  public Map<String, String> getProperties() {
    return Collections.unmodifiableMap(properties);
  }

  @Override
  public int getPropertyCount() {
    return properties.size();
  }

  @Override
  public String getProperty(String s) {
    return properties.get(s);
  }

  @Override
  public boolean arePropertiesSet() {
    return true;
  }

  @Override
  public String getPropertySync(String s) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getPropertyCacheOrSync(String s) throws TimeoutException,
      AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean supportsFeature(Feature feature) {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getMountPoint(String s) {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean hasClients() {
    throw new UnsupportedOperationException();
  }

  @Override
  public Client[] getClients() {
    throw new UnsupportedOperationException();
  }

  @Override
  public Client getClient(String s) {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getClientName(int i) {
    throw new UnsupportedOperationException();
  }

  @Override
  public SyncService getSyncService() throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public FileListingService getFileListingService() {
    throw new UnsupportedOperationException();
  }

  @Override
  public RawImage getScreenshot() throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void startScreenRecorder(
      String remoteFilePath,
      ScreenRecorderOptions options,
      IShellOutputReceiver receiver)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      IOException,
      ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void executeShellCommand(String s, IShellOutputReceiver iShellOutputReceiver)
      throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Deprecated
  @Override
  public void executeShellCommand(String s, IShellOutputReceiver iShellOutputReceiver, int i)
      throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void executeShellCommand(
      String command,
      IShellOutputReceiver receiver,
      long maxTimeToOutputResponse,
      TimeUnit maxTimeUnits)
      throws
      TimeoutException,
      AdbCommandRejectedException,
      ShellCommandUnresponsiveException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void runEventLogService(LogReceiver logReceiver) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void runLogService(String s, LogReceiver logReceiver) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void createForward(int i, int i1) throws TimeoutException,
      AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void createForward(int i, String s, DeviceUnixSocketNamespace deviceUnixSocketNamespace)
      throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeForward(int i, int i1) throws TimeoutException, AdbCommandRejectedException,
      IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeForward(int i, String s, DeviceUnixSocketNamespace deviceUnixSocketNamespace)
      throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }


  @Override
  public void pushFile(String s, String s1) throws IOException,
      AdbCommandRejectedException, TimeoutException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void pullFile(String s, String s1) throws IOException,
      AdbCommandRejectedException, TimeoutException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String installPackage(String s, boolean b, String... strings) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String syncPackageToDevice(String s) throws TimeoutException, AdbCommandRejectedException,
      IOException, SyncException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String installRemotePackage(String s, boolean b, String... strings)
      throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeRemotePackage(String s) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String uninstallPackage(String s) throws InstallException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void reboot(String s) throws TimeoutException, AdbCommandRejectedException, IOException {
    throw new UnsupportedOperationException();
  }

  @Override
  public Integer getBatteryLevel() throws TimeoutException, AdbCommandRejectedException,
      IOException, ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }

  @Override
  public Integer getBatteryLevel(long l) throws TimeoutException, AdbCommandRejectedException,
      IOException, ShellCommandUnresponsiveException {
    throw new UnsupportedOperationException();
  }
}

<code block>


package com.facebook.buck.android;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import com.android.ddmlib.IDevice;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.InstallException;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.util.Console;
import com.google.common.collect.ImmutableMap;

import org.junit.Before;
import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;

import java.io.File;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class AdbHelperTest {

  private AdbHelper basicAdbHelper;

  @Before
  public void setUp() throws CmdLineException {
    basicAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions());
  }

  private TestDevice createRealDevice(String serial, IDevice.DeviceState state) {
    TestDevice device = TestDevice.createRealDevice(serial);
    device.setState(state);
    return device;
  }

  private TestDevice createEmulator(String serial, IDevice.DeviceState state) {
    TestDevice device = TestDevice.createEmulator(serial);
    device.setState(state);
    return device;
  }

  private TestDevice createDeviceForShellCommandTest(final String output) {
    return new TestDevice() {
      @Override
      public void executeShellCommand(
          String cmd,
          IShellOutputReceiver receiver,
          long timeout,
          TimeUnit timeoutUnit) {
        byte[] outputBytes = output.getBytes();
        receiver.addOutput(outputBytes, 0, outputBytes.length);
        receiver.flush();
      }
    };
  }

  private AdbHelper createAdbHelper(
      AdbOptions adbOptions,
      TargetDeviceOptions targetDeviceOptions)
      throws CmdLineException {
    return createAdbHelper(
        TestExecutionContext.newInstance(),
        adbOptions,
        targetDeviceOptions);
  }

  private AdbHelper createAdbHelper(
      ExecutionContext executionContext,
      AdbOptions adbOptions,
      TargetDeviceOptions targetDeviceOptions)
      throws CmdLineException {
    Console console = new TestConsole();
    BuckEventBus eventBus = BuckEventBusFactory.newInstance();
    return new AdbHelper(
        adbOptions,
        targetDeviceOptions,
        executionContext,
        console,
        eventBus,
        true) {
      @Override
      protected boolean isDeviceTempWritable(IDevice device, String name) {
        return true;
      }
    };
  }


  @Test
  public void testDeviceFilterNoDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] { };

    assertNull(basicAdbHelper.filterDevices(devices));
  }


  @Test
  public void testDeviceFilterOnlineOnly() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.OFFLINE),
        createEmulator("2", IDevice.DeviceState.BOOTLOADER),
        createEmulator("3", IDevice.DeviceState.RECOVERY),
        createRealDevice("4", IDevice.DeviceState.OFFLINE),
        createRealDevice("5", IDevice.DeviceState.BOOTLOADER),
        createRealDevice("6", IDevice.DeviceState.RECOVERY),
    };

    assertNull(basicAdbHelper.filterDevices(devices));
  }


  @Test
  public void testDeviceFilterMultipleDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("4", IDevice.DeviceState.ONLINE),
        createRealDevice("5", IDevice.DeviceState.ONLINE)
    };

    assertNull(basicAdbHelper.filterDevices(devices));

    AdbHelper myAdbHelper = createAdbHelper(
        new AdbOptions(0, true),
        new TargetDeviceOptions());
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(devices.length, filteredDevices.size());
  }


  @Test
  public void testDeviceFilterEmulator() throws CmdLineException {
    AdbHelper myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(true, false, null));

    IDevice[] devices = new IDevice[] {
        createEmulator("1", IDevice.DeviceState.ONLINE),
        createRealDevice("2", IDevice.DeviceState.ONLINE),
    };

    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(devices[0], filteredDevices.get(0));
  }


  @Test
  public void testDeviceFilterRealDevices() throws CmdLineException {
    AdbHelper myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(false, true, null));

    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE)
    };

    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(devices[0], filteredDevices.get(0));
  }


  @Test
  public void testDeviceFilterBySerial() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    for (int i = 0; i < devices.length; i++) {
      AdbHelper myAdbHelper = createAdbHelper(
          new AdbOptions(),
          new TargetDeviceOptions(false, false, devices[i].getSerialNumber()));
      List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
      assertNotNull(filteredDevices);
      assertEquals(1, filteredDevices.size());
      assertSame(devices[i], filteredDevices.get(0));
    }
  }


  @Test
  public void whenSerialNumberSetInEnvironmentThenCorrectDeviceFound()
      throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    for (int i = 0; i < devices.length; i++) {
      AdbHelper myAdbHelper = createAdbHelper(
          TestExecutionContext.newBuilder()
              .setEnvironment(ImmutableMap.of(
                      AdbHelper.SERIAL_NUMBER_ENV,
                      devices[i].getSerialNumber()))
              .build(),
          new AdbOptions(),
          new TargetDeviceOptions());
      List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
      assertNotNull(filteredDevices);
      assertEquals(1, filteredDevices.size());
      assertSame(devices[i], filteredDevices.get(0));
    }
  }


  @Test
  public void testDeviceFilterNoMatchingDevices() throws CmdLineException {
    IDevice[] devices = new IDevice[] {
        createRealDevice("1", IDevice.DeviceState.ONLINE),
        createEmulator("2", IDevice.DeviceState.ONLINE),
        createRealDevice("3", IDevice.DeviceState.ONLINE),
        createEmulator("4", IDevice.DeviceState.ONLINE)
    };

    AdbHelper myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(false, false, "invalid-serial"));
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);
    assertNull(filteredDevices);
  }


  @Test
  public void testDeviceFilterCombos() throws CmdLineException {
    TestDevice realDevice1 = createRealDevice("1", IDevice.DeviceState.ONLINE);
    TestDevice realDevice2 = createRealDevice("2", IDevice.DeviceState.ONLINE);
    TestDevice emulator1 = createEmulator("3", IDevice.DeviceState.ONLINE);
    TestDevice emulator2 = createEmulator("4", IDevice.DeviceState.ONLINE);
    IDevice[] devices = new IDevice[] {
        realDevice1,
        emulator1,
        realDevice2,
        emulator2
    };

    AdbHelper myAdbHelper;

    myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(false, true, realDevice1.getSerialNumber()));
    List<IDevice> filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(realDevice1, filteredDevices.get(0));


    myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(false, true, emulator1.getSerialNumber()));
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNull(filteredDevices);


    myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(true, false, realDevice1.getSerialNumber()));
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNull(filteredDevices);


    myAdbHelper = createAdbHelper(
        new AdbOptions(),
        new TargetDeviceOptions(true, false, emulator1.getSerialNumber()));
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(1, filteredDevices.size());
    assertSame(emulator1, filteredDevices.get(0));


    myAdbHelper = createAdbHelper(
        new AdbOptions(0, true),
        new TargetDeviceOptions(true, true, null));
    filteredDevices = myAdbHelper.filterDevices(
        devices);
    assertNotNull(filteredDevices);
    assertEquals(devices.length, filteredDevices.size());
    for (IDevice device : devices) {
      assertTrue(filteredDevices.contains(device));
    }
  }


  @Test
  public void testSuccessfulDeviceInstall() {
    File apk = new File("/some/file.apk");
    final AtomicReference<String> apkPath = new AtomicReference<>();

    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        apkPath.set(s);
        return null;
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");

    assertTrue(basicAdbHelper.installApkOnDevice(device, apk, false));
    assertEquals(apk.getAbsolutePath(), apkPath.get());
  }


  @Test
  public void testDeviceStartActivitySuccess() {
    TestDevice device = createDeviceForShellCommandTest(
        "Starting: Intent { cmp=com.example.ExceptionErrorActivity }\r\n");
    assertNull(basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity"));
  }

  @Test
  public void testDeviceStartActivityAmDoesntExist() {
    TestDevice device = createDeviceForShellCommandTest("sh: am: not found\r\n");
    assertNotNull(basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity"));
  }

  @Test
  public void testDeviceStartActivityActivityDoesntExist() {
    String errorLine = "Error: Activity class {com.foo/.Activiqy} does not exist.\r\n";
    TestDevice device = createDeviceForShellCommandTest(
         "Starting: Intent { cmp=com.foo/.Activiqy }\r\n" +
         "Error type 3\r\n" +
         errorLine);
    assertEquals(
        errorLine.trim(),
        basicAdbHelper.deviceStartActivity(device, "com.foo/.Activiy").trim());
  }

  @Test
  public void testDeviceStartActivityException() {
    String errorLine = "java.lang.SecurityException: Permission Denial: " +
        "starting Intent { flg=0x10000000 cmp=com.foo/.Activity } from null " +
        "(pid=27581, uid=2000) not exported from uid 10002\r\n";
    TestDevice device = createDeviceForShellCommandTest(
        "Starting: Intent { cmp=com.foo/.Activity }\r\n" +
        errorLine +
         "  at android.os.Parcel.readException(Parcel.java:1425)\r\n" +
         "  at android.os.Parcel.readException(Parcel.java:1379)\r\n" +

        "  at dalvik.system.NativeStart.main(Native Method)\r\n");
    assertEquals(
        errorLine.trim(),
        basicAdbHelper.deviceStartActivity(device, "com.foo/.Activity").trim());
  }


  @Test
  public void testFailedDeviceInstallWithReason() {
    File apk = new File("/some/file.apk");
    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        return "[SOME_REASON]";
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");
    assertFalse(basicAdbHelper.installApkOnDevice(device, apk, false));
  }


  @Test
  public void testFailedDeviceInstallWithException() {
    File apk = new File("/some/file.apk");

    TestDevice device = new TestDevice() {
      @Override
      public String installPackage(String s, boolean b, String... strings) throws InstallException {
        throw new InstallException("Failed to install on test device.", null);
      }
    };
    device.setSerialNumber("serial#1");
    device.setName("testDevice");
    assertFalse(basicAdbHelper.installApkOnDevice(device, apk, false));
  }

}

<code block>


package com.facebook.buck.event;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTargetFactory;

import org.junit.Test;

public class StartActivityEventTest {
  @Test
  public void testEquals() throws Exception {
    StartActivityEvent started =
        configureTestEvent(StartActivityEvent.started(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar"));
    StartActivityEvent startedTwo =
        configureTestEvent(StartActivityEvent.started(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar"));
    StartActivityEvent finished =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            false));
    StartActivityEvent finishedTwo =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            false));
    StartActivityEvent finishedSucceed =
        configureTestEvent(StartActivityEvent.finished(BuildTargetFactory.newInstance("//foo:bar"),
            "com.foo.bar",
            true));

    assertEquals(started, started);
    assertNotEquals(started, finished);
    assertEquals(started, startedTwo);
    assertEquals(finished, finishedTwo);
    assertNotEquals(finished, finishedSucceed);
  }
}

<code block>


package com.facebook.buck.event;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTargetFactory;

import org.junit.Test;

public class InstallEventTest {
  @Test
  public void testEquals() throws Exception {
    InstallEvent started = configureTestEvent(
        InstallEvent.started(BuildTargetFactory.newInstance("//foo:bar")));
    InstallEvent startedTwo = configureTestEvent(
        InstallEvent.started(BuildTargetFactory.newInstance("//foo:bar")));
    InstallEvent finished = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:bar"), true));
    InstallEvent finishedDifferentEvent = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:raz"), true));
    InstallEvent finishedFail = configureTestEvent(
        InstallEvent.finished(BuildTargetFactory.newInstance("//foo:bar"), false));

    assertEquals(started, startedTwo);
    assertNotEquals(finished, finishedDifferentEvent);
    assertNotEquals(started, finished);
    assertNotEquals(finished, finishedFail);

  }
}

<code block>


package com.facebook.buck.event;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEvent;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import org.junit.Test;

public class UninstallEventTest {
  @Test
  public void testEquals() throws Exception {
    UninstallEvent started = configureTestEvent(UninstallEvent.started("com.foo.bar"));
    UninstallEvent startedTwo = configureTestEvent(UninstallEvent.started("com.foo.bar"));
    UninstallEvent finished = configureTestEvent(UninstallEvent.finished("com.foo.bar", true));
    UninstallEvent finishedFail = configureTestEvent(UninstallEvent.finished("com.foo.bar", false));

    assertEquals(started, startedTwo);
    assertNotEquals(started, finished);
    assertNotEquals(finished, finishedFail);
  }
}

<code block>

package com.facebook.buck.event.listener;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEventAtTime;
import static org.junit.Assert.assertEquals;

import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleStatus;
import com.facebook.buck.rules.BuildRuleSuccessType;
import com.facebook.buck.rules.CacheResult;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.timing.IncrementingFakeClock;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.eventbus.EventBus;
import com.google.common.hash.HashCode;

import org.junit.Test;

import java.util.concurrent.TimeUnit;

public class SimpleConsoleEventBusListenerTest {
  @Test
  public void testSimpleBuild() {
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        new SourcePathResolver(new BuildRuleResolver()),
        ImmutableSortedSet.<BuildRule>of());

    SimpleConsoleEventBusListener listener = new SimpleConsoleEventBusListener(console, fakeClock);
    eventBus.register(listener);

    final long threadId = 0;

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            0L,
            TimeUnit.MILLISECONDS,
            threadId));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(buildTargets), 0L, TimeUnit.MILLISECONDS, threadId));

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals("", console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.finished(buildTargets,
            Optional.<TargetGraph>absent()),
            400L,
            TimeUnit.MILLISECONDS,
            threadId));

    final String parsingLine = "[-] PARSING BUCK FILES...FINISHED 0.4s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(fakeRule), 600L, TimeUnit.MILLISECONDS, threadId));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.finished(
                fakeRule,
                BuildRuleStatus.SUCCESS,
                CacheResult.miss(),
                Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
                Optional.<HashCode>absent(),
                Optional.<Long>absent()),
            1000L,
            TimeUnit.MILLISECONDS,
            threadId));
    rawEventBus.post(configureTestEventAtTime(
        BuildEvent.finished(buildArgs, 0), 1234L, TimeUnit.MILLISECONDS, threadId));

    final String buildingLine = "BUILT //banana:stand\n[-] BUILDING...FINISHED 0.8s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        ConsoleEvent.severe("I've made a huge mistake."), 1500L, TimeUnit.MILLISECONDS, threadId));

    final String logLine = "I've made a huge mistake.\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.started(fakeTarget), 2500L, TimeUnit.MILLISECONDS, threadId));

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine,
        console.getTextWrittenToStdErr());

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.finished(fakeTarget, true), 4000L, TimeUnit.MILLISECONDS, threadId));

    final String installLine = "[-] INSTALLING...FINISHED 1.5s\n";

    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals(parsingLine + buildingLine + logLine + installLine,
        console.getTextWrittenToStdErr());
  }

}

<code block>

package com.facebook.buck.event.listener;

import static com.facebook.buck.event.TestEventConfigerator.configureTestEventAtTime;
import static org.junit.Assert.assertEquals;

import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.httpserver.WebServer;
import com.facebook.buck.json.ProjectBuildFileParseEvents;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.parser.ParseEvent;
import com.facebook.buck.rules.ActionGraphEvent;
import com.facebook.buck.rules.BuildEvent;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleEvent;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleStatus;
import com.facebook.buck.rules.BuildRuleSuccessType;
import com.facebook.buck.rules.CacheResult;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TestRunEvent;
import com.facebook.buck.rules.TestSummaryEvent;
import com.facebook.buck.step.StepEvent;
import com.facebook.buck.test.TestCaseSummary;
import com.facebook.buck.test.TestResultSummary;
import com.facebook.buck.test.TestResults;
import com.facebook.buck.test.TestRuleEvent;
import com.facebook.buck.test.result.type.ResultType;
import com.facebook.buck.test.selectors.TestSelectorList;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.timing.Clock;
import com.facebook.buck.timing.IncrementingFakeClock;
import com.facebook.buck.util.FakeProcessExecutor;
import com.facebook.buck.util.environment.DefaultExecutionEnvironment;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.eventbus.EventBus;
import com.google.common.hash.HashCode;

import org.junit.Test;

import java.text.DecimalFormat;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

public class SuperConsoleEventBusListenerTest {
  private static final DecimalFormat timeFormatter = new DecimalFormat("0.0s");


  private static String formatConsoleTimes(String template, Double... time) {
    return String.format(template, (Object[]) FluentIterable.from(ImmutableList.copyOf(time))
        .transform(new Function<Double, String>() {
            @Override
            public String apply(Double input) {
              return timeFormatter.format(input);
            }
          }).toArray(String.class));
  }

  @Test
  public void testSimpleBuild() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    BuildTarget cachedTarget = BuildTargetFactory.newInstance("//chicken:dance");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget, cachedTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());
    FakeBuildRule cachedRule = new FakeBuildRule(
        cachedTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(buildTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(buildTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(fakeRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //banana:stand...  %s (checking local cache)", 0.2)));

    String stepShortName = "doing_something";
    String stepDescription = "working hard";
    UUID stepUuid = UUID.randomUUID();
    rawEventBus.post(configureTestEventAtTime(
        StepEvent.started(stepShortName, stepDescription, stepUuid),
          800L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 900L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.5),
        formatConsoleTimes(" |=> //banana:stand...  %s (running doing_something[%s])", 0.3, 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        StepEvent.finished(stepShortName, stepDescription, stepUuid, 0),
        900L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            fakeRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 1000L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.6),
        " |=> IDLE"));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(cachedRule),
        1010L, TimeUnit.MILLISECONDS,  2L));

    validateConsole(console, listener, 1100L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.7),
        " |=> IDLE",
        formatConsoleTimes(" |=> //chicken:dance...  %s (checking local cache)", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            cachedRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1120L, TimeUnit.MILLISECONDS,  2L));

    rawEventBus.post(configureTestEventAtTime(
        BuildEvent.finished(buildArgs, 0),
        1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(configureTestEventAtTime(
        ConsoleEvent.severe("I've made a huge mistake."),
        1500L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 1600L, ImmutableList.of(parsingLine,
        buildingLine,
        "Log:",
        "I've made a huge mistake."));

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.started(fakeTarget),
        2500L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 3000L, ImmutableList.of(parsingLine,
        buildingLine,
        formatConsoleTimes("[+] INSTALLING...%s", 0.5),
        "Log:",
        "I've made a huge mistake."));

    rawEventBus.post(configureTestEventAtTime(
        InstallEvent.finished(fakeTarget, true),
        4000L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 5000L, ImmutableList.of(parsingLine,
        buildingLine,
        formatConsoleTimes("[-] INSTALLING...FINISHED %s", 1.5),
        "Log:",
        "I've made a huge mistake."));

    listener.render();
    String beforeStderrWrite = console.getTextWrittenToStdErr();
    console.getStdErr().print("ROFLCOPTER");
    listener.render();
    assertEquals("After stderr is written to by someone other than SuperConsole, rendering " +
        "should be a noop.",
        beforeStderrWrite + "ROFLCOPTER", console.getTextWrittenToStdErr());
  }

  @Test
  public void testSimpleTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.SUCCESS,
            0L, 
            null, 
            null, 
            null, 
            null); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (1 PASS/0 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes("[-] TESTING...FINISHED %s (1 PASS/0 FAIL)", 1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "RESULTS FOR ALL TESTS",
            "PASS    <100ms  1 Passed   0 Skipped   0 Failed   TestClass",
            "TESTS PASSED"));
  }

  @Test
  public void testSkippedTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.ASSUMPTION_VIOLATION,
            0L, 
            null, 
            null, 
            null, 
            null); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/1 SKIP/0 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes(
        "[-] TESTING...FINISHED %s (0 PASS/1 SKIP/0 FAIL)",
        1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "RESULTS FOR ALL TESTS",
            "ASSUME  <100ms  0 Passed   1 Skipped   0 Failed   TestClass",
            "TESTS PASSED (with some assumption violations)"));
  }

  @Test
  public void testFailingTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");
    ImmutableSet<BuildTarget> testTargets = ImmutableSet.of(testTarget);
    Iterable<String> testArgs = Iterables.transform(testTargets, Functions.toStringFunction());
    FakeBuildRule testBuildRule = new FakeBuildRule(
        testTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
        Optional.<WebServer>absent());
    eventBus.register(listener);

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Started(),
            0L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(console, listener, 0L, ImmutableList.of(
        formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.0)));

    validateConsole(
        console, listener, 100L, ImmutableList.of(
            formatConsoleTimes("[+] PARSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            new ProjectBuildFileParseEvents.Finished(),
            200L, TimeUnit.MILLISECONDS,  0L));
    validateConsole(
        console, listener, 200L, ImmutableList.of(
            formatConsoleTimes("[-] PARSING BUCK FILES...FINISHED %s", 0.2)));

    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(testArgs),
            200L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(configureTestEventAtTime(
        ParseEvent.started(testTargets),
        200L, TimeUnit.MILLISECONDS,  0L));

    validateConsole(console, listener, 300L, ImmutableList.of(
        formatConsoleTimes("[+] PROCESSING BUCK FILES...%s", 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(ParseEvent.finished(testTargets,
                                                     Optional.<TargetGraph>absent()),
        300L, TimeUnit.MILLISECONDS,  0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            400L,
            TimeUnit.MILLISECONDS,
 0L));

    final String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED %s", 0.2);

    validateConsole(console, listener, 540L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.1)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.started(testBuildRule),
        600L, TimeUnit.MILLISECONDS,  0L));


    validateConsole(console, listener, 800L, ImmutableList.of(parsingLine,
        formatConsoleTimes("[+] BUILDING...%s", 0.4),
        formatConsoleTimes(" |=> //:test...  %s (checking local cache)", 0.2)));

    rawEventBus.post(configureTestEventAtTime(
        BuildRuleEvent.finished(
            testBuildRule,
            BuildRuleStatus.SUCCESS,
            CacheResult.miss(),
            Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
            Optional.<HashCode>absent(),
            Optional.<Long>absent()),
        1000L, TimeUnit.MILLISECONDS,  0L));

    rawEventBus.post(configureTestEventAtTime(
                         BuildEvent.finished(testArgs, 0),
                         1234L, TimeUnit.MILLISECONDS,  0L));

    final String buildingLine = formatConsoleTimes("[-] BUILDING...FINISHED %s", 0.8);

    validateConsole(console, listener, 1300L, ImmutableList.of(parsingLine, buildingLine));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.started(
                true, 
                TestSelectorList.empty(),
                false, 
                ImmutableSet.copyOf(testArgs)),
            2500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.5)));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRuleEvent.started(testTarget),
            3100L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.7),
            formatConsoleTimes(" |=> //:test...  %s", 0.1)));

    UUID stepUuid = new UUID(0, 1);
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(
                "step_name",
                "step_desc",
                stepUuid),
            3300L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3400L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 0.9),
            formatConsoleTimes(" |=> //:test...  %s (running step_name[%s])", 0.3, 0.1)));

    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(
                "step_name",
                "step_desc",
                stepUuid,
                0),
            3500L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3600L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.1),
            formatConsoleTimes(" |=> //:test...  %s", 0.5)));

    UUID testUUID = new UUID(2, 3);

    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.started(testUUID, "TestClass", "TestClass.Foo"),
            3700L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        3800L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/0 FAIL)", 1.3),
            formatConsoleTimes(" |=> //:test...  %s (running TestClass.Foo[%s])", 0.7, 0.1)));

    TestResultSummary testResultSummary =
        new TestResultSummary(
            "TestClass",
            "TestClass.Foo",
            ResultType.FAILURE,
            0L, 
            "Foo.java:47: Assertion failure: 'foo' != 'bar'", 
            null, 
            "Message on stdout", 
            "Message on stderr"); 
    rawEventBus.post(
        configureTestEventAtTime(
            TestSummaryEvent.finished(
                testUUID,
                testResultSummary),
            3900L,
            TimeUnit.MILLISECONDS,
 0L));

    validateConsole(
        console,
        listener,
        4000L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            formatConsoleTimes("[+] TESTING...%s (0 PASS/1 FAIL)", 1.5),
            formatConsoleTimes(" |=> //:test...  %s", 0.9),
            "Log:",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'"));

    rawEventBus.post(
        configureTestEventAtTime(
            TestRunEvent.finished(
                ImmutableSet.copyOf(testArgs),
                ImmutableList.of(
                    new TestResults(
                        testTarget,
                        ImmutableList.of(
                            new TestCaseSummary(
                                "TestClass",
                                ImmutableList.of(
                                    testResultSummary))),
                        ImmutableSet.<String>of(), 
                        ImmutableSet.<String>of()))), 
            4100L,
            TimeUnit.MILLISECONDS,
 0L));

    final String testingLine = formatConsoleTimes("[-] TESTING...FINISHED %s (0 PASS/1 FAIL)", 1.6);

    validateConsole(
        console,
        listener,
        4200L,
        ImmutableList.of(
            parsingLine,
            buildingLine,
            testingLine,
            "Log:",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'",
            "RESULTS FOR ALL TESTS",
            "FAIL    <100ms  0 Passed   0 Skipped   1 Failed   TestClass",
            "FAILURE TestClass.Foo: Foo.java:47: Assertion failure: 'foo' != 'bar'",
            "====STANDARD OUT====",
            "Message on stdout",
            "====STANDARD ERR====",
            "Message on stderr",
            "TESTS FAILED: 1 FAILURE",
            "Failed target: //:test",
            "FAIL TestClass"));
  }

  @Test
  public void testBuildRuleSuspendResumeEvents() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    Clock fakeClock = new IncrementingFakeClock(TimeUnit.SECONDS.toNanos(1));
    BuckEventBus eventBus = BuckEventBusFactory.newInstance(fakeClock);
    EventBus rawEventBus = BuckEventBusFactory.getEventBusFor(eventBus);
    TestConsole console = new TestConsole();

    BuildTarget fakeTarget = BuildTargetFactory.newInstance("//banana:stand");
    ImmutableSet<BuildTarget> buildTargets = ImmutableSet.of(fakeTarget);
    Iterable<String> buildArgs = Iterables.transform(buildTargets, Functions.toStringFunction());
    FakeBuildRule fakeRule = new FakeBuildRule(
        fakeTarget,
        pathResolver,
        ImmutableSortedSet.<BuildRule>of());
    String stepShortName = "doing_something";
    String stepDescription = "working hard";
    UUID stepUuid = UUID.randomUUID();

    SuperConsoleEventBusListener listener =
        new SuperConsoleEventBusListener(
            console,
            fakeClock,
            new DefaultExecutionEnvironment(
                new FakeProcessExecutor(),
                ImmutableMap.copyOf(System.getenv()),
                System.getProperties()),
            Optional.<WebServer>absent());
    eventBus.register(listener);


    rawEventBus.post(
        configureTestEventAtTime(
            BuildEvent.started(buildArgs),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    String parsingLine = formatConsoleTimes("[-] PROCESSING BUCK FILES...FINISHED 0.0s");
    rawEventBus.post(
        configureTestEventAtTime(
            ParseEvent.started(buildTargets),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ParseEvent.finished(buildTargets, Optional.<TargetGraph>absent()),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            ActionGraphEvent.finished(),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.started(fakeRule),
            0L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(stepShortName, stepDescription, stepUuid),
            0L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(stepShortName, stepDescription, stepUuid,  0),
            100L,
            TimeUnit.MILLISECONDS,
 0L));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.suspended(fakeRule),
            100L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        200L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.2),
            " |=> IDLE"));


    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.resumed(fakeRule),
            300L,
            TimeUnit.MILLISECONDS,
 0L));



    validateConsole(
        console,
        listener,
        300L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.3),
            formatConsoleTimes(" |=> //banana:stand...  %s (checking local cache)", 0.1)));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.started(stepShortName, stepDescription, stepUuid),
            400L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        500L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.5),
            formatConsoleTimes(
                " |=> //banana:stand...  %s (running doing_something[%s])",
                0.3,
                0.1)));


    rawEventBus.post(
        configureTestEventAtTime(
            StepEvent.finished(stepShortName, stepDescription, stepUuid,  0),
            600L,
            TimeUnit.MILLISECONDS,
 0L));
    rawEventBus.post(
        configureTestEventAtTime(
            BuildRuleEvent.finished(
                fakeRule,
                BuildRuleStatus.SUCCESS,
                CacheResult.miss(),
                Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),
                Optional.<HashCode>absent(),
                Optional.<Long>absent()),
            600L,
            TimeUnit.MILLISECONDS,
 0L));


    validateConsole(
        console,
        listener,
        700L,
        ImmutableList.of(
            parsingLine,
            formatConsoleTimes("[+] BUILDING...%s", 0.7),
            " |=> IDLE"));
  }

  private void validateConsole(TestConsole console,
      SuperConsoleEventBusListener listener,
      long timeMs,
      ImmutableList<String> lines) {
    assertEquals("", console.getTextWrittenToStdOut());
    assertEquals("", console.getTextWrittenToStdErr());
    assertEquals(lines, listener.createRenderLinesAtTime(timeMs));
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.AdbOptions;
import com.facebook.buck.android.TargetDeviceOptions;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;

public class InstallCommandOptionsTest {

  private InstallCommand getCommand(String... args) throws CmdLineException {
    InstallCommand command = new InstallCommand();
    new AdditionalOptionsCmdLineParser(command).parseArgument(args);
    return command;
  }

  private AdbOptions getAdbOptions(String...args) throws CmdLineException {
    return getCommand(args).adbOptions();
  }

  private TargetDeviceOptions getTargetDeviceOptions(String... args) throws CmdLineException {
    return getCommand(args).targetDeviceOptions();
  }

  @Test
  public void testInstallCommandOptionsRun() throws CmdLineException {
    InstallCommand command = getCommand(
        InstallCommand.RUN_SHORT_ARG, "katana",
        VerbosityParser.VERBOSE_SHORT_ARG, "10");
    assertTrue(command.shouldStartActivity());
    assertNull(command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsRunAndActivity() throws CmdLineException {
    InstallCommand command = getCommand(
        InstallCommand.RUN_SHORT_ARG,
        VerbosityParser.VERBOSE_SHORT_ARG, "10",
        "wakizashi",
        InstallCommand.ACTIVITY_SHORT_ARG, "com.facebook.katana.LoginActivity");
    assertTrue(command.shouldStartActivity());
    assertEquals("com.facebook.katana.LoginActivity", command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsActivity() throws CmdLineException {
    InstallCommand command = getCommand(
        "katana",
        InstallCommand.ACTIVITY_SHORT_ARG, ".LoginActivity");
    assertTrue(command.shouldStartActivity());
    assertEquals(".LoginActivity", command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsNone() throws CmdLineException {
    InstallCommand command = getCommand(
        VerbosityParser.VERBOSE_SHORT_ARG, "10",
        "katana");
    assertFalse(command.shouldStartActivity());
    assertNull(command.getActivityToStart());
  }

  @Test
  public void testInstallCommandOptionsEmulatorMode() throws CmdLineException {

    TargetDeviceOptions options =
        getTargetDeviceOptions(TargetDeviceCommandLineOptions.EMULATOR_MODE_SHORT_ARG);
    assertTrue(options.isEmulatorsOnlyModeEnabled());


    options = getTargetDeviceOptions(TargetDeviceCommandLineOptions.EMULATOR_MODE_LONG_ARG);
    assertTrue(options.isEmulatorsOnlyModeEnabled());


    options = getTargetDeviceOptions();
    assertFalse(options.isEmulatorsOnlyModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsDeviceMode() throws CmdLineException {

    TargetDeviceOptions options = getTargetDeviceOptions(
        TargetDeviceCommandLineOptions.DEVICE_MODE_SHORT_ARG);
    assertTrue(options.isRealDevicesOnlyModeEnabled());


    options = getTargetDeviceOptions(TargetDeviceCommandLineOptions.DEVICE_MODE_LONG_ARG);
    assertTrue(options.isRealDevicesOnlyModeEnabled());


    options = getTargetDeviceOptions();
    assertFalse(options.isRealDevicesOnlyModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsSerial() throws CmdLineException {
    String serial = "some-random-serial-number";

    TargetDeviceOptions options = getTargetDeviceOptions(
        TargetDeviceCommandLineOptions.SERIAL_NUMBER_SHORT_ARG, serial);
    assertTrue(options.hasSerialNumber());
    assertEquals(serial, options.getSerialNumber());


    options = getTargetDeviceOptions(TargetDeviceCommandLineOptions.SERIAL_NUMBER_LONG_ARG, serial);
    assertTrue(options.hasSerialNumber());
    assertEquals(serial, options.getSerialNumber());


    options = getTargetDeviceOptions();
    assertFalse(options.hasSerialNumber());
    assertEquals(null, options.getSerialNumber());
  }

  @Test
  public void testInstallCommandOptionsMultiInstallMode() throws CmdLineException {

    AdbOptions options = getAdbOptions(AdbCommandLineOptions.MULTI_INSTALL_MODE_SHORT_ARG);
    assertTrue(options.isMultiInstallModeEnabled());


    options = getAdbOptions(AdbCommandLineOptions.MULTI_INSTALL_MODE_LONG_ARG);
    assertTrue(options.isMultiInstallModeEnabled());


    options = getAdbOptions();
    assertFalse(options.isMultiInstallModeEnabled());
  }

  @Test
  public void testInstallCommandOptionsAdbThreads() throws CmdLineException {

    AdbOptions options = getAdbOptions(AdbCommandLineOptions.ADB_THREADS_SHORT_ARG, "4");
    assertEquals(4, options.getAdbThreadCount());


    options = getAdbOptions(AdbCommandLineOptions.ADB_THREADS_LONG_ARG, "4");
    assertEquals(4, options.getAdbThreadCount());


    options = getAdbOptions();
    assertEquals(0, options.getAdbThreadCount());
  }
}

<code block>


package com.facebook.buck.cli;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.step.TargetDevice;

import org.junit.Test;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;

public class TargetDeviceCommandLineOptionsTest {
  @Test
  public void shouldReturnAnAbsentOptionalIfNoTargetDeviceCommandLineOptionsSet() {
    TargetDeviceCommandLineOptions options = buildOptions();

    assertFalse(options.getTargetDeviceOptional().isPresent());
  }

  @Test
  public void shouldReturnAnEmulatorIfOnlyEmulatorFlagSet() {
    TargetDeviceCommandLineOptions options = buildOptions("-e");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertTrue(device.isEmulator());
    assertNull(device.getIdentifier());
  }

  @Test
  public void shouldReturnADeviceIfOnlyDeviceFlagSet() {
    TargetDeviceCommandLineOptions options = buildOptions("-d");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertFalse(device.isEmulator());
    assertNull(device.getIdentifier());
  }

  @Test
  public void onlySettingTheSerialFlagAssumesTheTargetIsARealDevice() {
    TargetDeviceCommandLineOptions options = buildOptions("-s", "1234");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertFalse(device.isEmulator());
    assertEquals("1234", device.getIdentifier());
  }

  @Test
  public void serialFlagOverridesEnvironment() {
    TargetDeviceCommandLineOptions options = new TargetDeviceCommandLineOptions("1234");

    TargetDevice device = options.getTargetDeviceOptional().get();

    assertEquals("1234", device.getIdentifier());

    try {
      new CmdLineParser(options).parseArgument("-s", "5678");
    } catch (CmdLineException e) {
      fail("Unable to parse arguments");
    }

    device = options.getTargetDeviceOptional().get();

    assertEquals("5678", device.getIdentifier());
  }

  private TargetDeviceCommandLineOptions buildOptions(String... args) {
    TargetDeviceCommandLineOptions options = new TargetDeviceCommandLineOptions();

    try {
      new CmdLineParser(options).parseArgument(args);
    } catch (CmdLineException e) {
      fail("Unable to parse arguments");
    }

    return options;
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nonnull;

public class CxxSourceRuleFactory {

  private static final Logger LOG = Logger.get(CxxSourceRuleFactory.class);
  private static final String COMPILE_FLAVOR_PREFIX = "compile-";
  private static final String PREPROCESS_FLAVOR_PREFIX = "preprocess-";

  private final BuildRuleParams params;
  private final BuildRuleResolver resolver;
  private final SourcePathResolver pathResolver;
  private final CxxPlatform cxxPlatform;
  private final ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput;
  private final ImmutableList<String> compilerFlags;

  private final Supplier<ImmutableList<BuildRule>> preprocessDeps = Suppliers.memoize(
      new Supplier<ImmutableList<BuildRule>>() {
        @Override
        public ImmutableList<BuildRule> get() {
          ImmutableList.Builder<BuildRule> builder = ImmutableList.builder();

          for (CxxPreprocessorInput input : cxxPreprocessorInput) {


            builder.addAll(
                pathResolver.filterBuildRuleInputs(
                    ImmutableList.<SourcePath>builder()
                        .addAll(input.getIncludes().getPrefixHeaders())
                        .addAll(input.getIncludes().getNameToPathMap().values())
                        .build()));



            builder.addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    input.getRules()));
          }

          return builder.build();
        }
      });

  private final Supplier<ImmutableSet<Path>> includeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_INCLUDE_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableSet<Path>> systemIncludeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_SYSTEM_INCLUDE_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableSet<Path>> frameworkRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_FRAMEWORK_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableList<CxxHeaders>> includes =
      Suppliers.memoize(
          new Supplier<ImmutableList<CxxHeaders>>() {
            @Override
            public ImmutableList<CxxHeaders> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transform(CxxPreprocessorInput.GET_INCLUDES)
                  .toList();
            }
          });

  private final LoadingCache<CxxSource.Type, ImmutableList<String>> preprocessorFlags =
      CacheBuilder.newBuilder()
          .build(
              new CacheLoader<CxxSource.Type, ImmutableList<String>>() {
                @Override
                public ImmutableList<String> load(@Nonnull CxxSource.Type type) {
                  ImmutableList.Builder<String> builder = ImmutableList.builder();
                  for (CxxPreprocessorInput input : cxxPreprocessorInput) {
                    builder.addAll(input.getPreprocessorFlags().get(type));
                  }
                  return builder.build();
                }
              });

  @VisibleForTesting
  public CxxSourceRuleFactory(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags) {
    this.params = params;
    this.resolver = resolver;
    this.pathResolver = pathResolver;
    this.cxxPlatform = cxxPlatform;
    this.cxxPreprocessorInput = cxxPreprocessorInput;
    this.compilerFlags = compilerFlags;
  }


  private String getPreprocessOutputName(CxxSource.Type type, String name) {
    CxxSource.Type outputType = CxxSourceTypes.getPreprocessorOutputType(type);
    return name + "." + Iterables.get(outputType.getExtensions(), 0);
  }


  @VisibleForTesting
  public BuildTarget createPreprocessBuildTarget(
      String name,
      CxxSource.Type type,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getPreprocessOutputName(type, name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    PREPROCESS_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isPreprocessFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(PREPROCESS_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }


  @VisibleForTesting
  Path getPreprocessOutputPath(BuildTarget target, CxxSource.Type type, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getPreprocessOutputName(type, name));
  }

  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Preprocessor tool = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());


    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getInputs(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> platformFlags =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, source.getType()))

            .addAll(getPlatformCompileFlags(
              CxxSourceTypes.getPreprocessorOutputType(source.getType())))
            .build();

    ImmutableList<String> ruleFlags =
        ImmutableList.<String>builder()

            .addAll(preprocessorFlags.getUnchecked(source.getType()))

            .addAll(getRuleCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocess(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        platformFlags,
        ruleFlags,
        getPreprocessOutputPath(target, source.getType(), name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessBuildRule(resolver, name, source, pic);
  }


  private String getCompileOutputName(String name) {
    return name + ".o";
  }


  @VisibleForTesting
  Path getCompileOutputPath(BuildTarget target, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getCompileOutputName(name));
  }


  @VisibleForTesting
  public BuildTarget createCompileBuildTarget(
      String name,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getCompileOutputName(name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    COMPILE_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isCompileFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(COMPILE_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }



  private Compiler getCompiler(CxxSource.Type type) {
    return CxxSourceTypes.needsCxxCompiler(type) ?
        cxxPlatform.getCxx() :
        cxxPlatform.getCc();
  }

  private ImmutableList<String> getPlatformCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCflags());
    }



    if (type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCxxflags());
    }


    args.addAll(cxxPlatform.getAsflags());

    return args.build();
  }

  private ImmutableList<String> getRuleCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT ||
        type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(compilerFlags);
    }

    return args.build();
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isCompilableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Compiler compiler = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(compiler.getInputs(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))
            .build();


    ImmutableList<String> platformFlags =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(getPlatformCompileFlags(source.getType()))
            .build();

    ImmutableList<String> ruleFlags =
        ImmutableList.<String>builder()

            .addAll(getRuleCompileFlags(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.compile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        compiler,
        platformFlags,
        ruleFlags,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requireCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createCompileBuildRule(resolver, name, source, pic);
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Preprocessor preprocessor = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());
    Compiler compiler = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(compiler.getInputs(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> platformCompilerFlags = ImmutableList.<String>builder()

        .addAll(pic.getFlags())

        .addAll(getPlatformCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))
        .build();

    ImmutableList<String> ruleCompilerFlags = ImmutableList.<String>builder()

        .addAll(getRuleCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

        .addAll(source.getFlags())
        .build();

    LOG.verbose("Creating preprocess and compile %s for %s", target, source);


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocessAndCompile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        preprocessor,
        CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, source.getType()),
        preprocessorFlags.getUnchecked(source.getType()),
        compiler,
        platformCompilerFlags,
        ruleCompilerFlags,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer(),
        strategy);
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
  }

  private ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleResolver resolver,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {

    ImmutableList.Builder<CxxPreprocessAndCompile> objects = ImmutableList.builder();

    for (Map.Entry<String, CxxSource> entry : sources.entrySet()) {
      String name = entry.getKey();
      CxxSource source = entry.getValue();

      Preconditions.checkState(
          CxxSourceTypes.isPreprocessableType(source.getType()) ||
              CxxSourceTypes.isCompilableType(source.getType()));

      switch (strategy) {

        case PIPED:
        case COMBINED: {
          CxxPreprocessAndCompile rule;



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            rule = requirePreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
          } else {
            rule = requireCompileBuildRule(resolver, name, source, pic);
          }

          objects.add(rule);
          break;
        }

        case SEPARATE: {



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            CxxPreprocessAndCompile rule = requirePreprocessBuildRule(resolver, name, source, pic);
            source = CxxSource.copyOf(source)
                .withType(CxxSourceTypes.getPreprocessorOutputType(source.getType()))
                .withPath(
                    new BuildTargetSourcePath(rule.getBuildTarget()));
          }


          CxxPreprocessAndCompile rule = requireCompileBuildRule(resolver, name, source, pic);
          objects.add(rule);

          break;
        }


        default:
          throw new IllegalStateException();
      }
    }

    return FluentIterable
        .from(objects.build())
        .toMap(new Function<CxxPreprocessAndCompile, SourcePath>() {
          @Override
          public SourcePath apply(CxxPreprocessAndCompile input) {
            return new BuildTargetSourcePath(input.getBuildTarget());
          }
        });
  }

  public static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {
    CxxSourceRuleFactory factory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            compilerFlags);
    return factory.requirePreprocessAndCompileRules(resolver, strategy, sources, pic);
  }

  public enum PicType {


    PIC("-fPIC"),


    PDC;

    private final ImmutableList<String> flags;

    PicType(String... flags) {
      this.flags = ImmutableList.copyOf(flags);
    }

    public ImmutableList<String> getFlags() {
      return flags;
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.Tool;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nonnull;

public class CxxSourceRuleFactory {

  private static final Logger LOG = Logger.get(CxxSourceRuleFactory.class);
  private static final String COMPILE_FLAVOR_PREFIX = "compile-";
  private static final String PREPROCESS_FLAVOR_PREFIX = "preprocess-";

  private final BuildRuleParams params;
  private final BuildRuleResolver resolver;
  private final SourcePathResolver pathResolver;
  private final CxxPlatform cxxPlatform;
  private final ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput;
  private final ImmutableList<String> compilerFlags;

  private final Supplier<ImmutableList<BuildRule>> preprocessDeps = Suppliers.memoize(
      new Supplier<ImmutableList<BuildRule>>() {
        @Override
        public ImmutableList<BuildRule> get() {
          ImmutableList.Builder<BuildRule> builder = ImmutableList.builder();

          for (CxxPreprocessorInput input : cxxPreprocessorInput) {


            builder.addAll(
                pathResolver.filterBuildRuleInputs(
                    ImmutableList.<SourcePath>builder()
                        .addAll(input.getIncludes().getPrefixHeaders())
                        .addAll(input.getIncludes().getNameToPathMap().values())
                        .build()));



            builder.addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    input.getRules()));
          }

          return builder.build();
        }
      });

  private final Supplier<ImmutableSet<Path>> includeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_INCLUDE_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableSet<Path>> systemIncludeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_SYSTEM_INCLUDE_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableSet<Path>> frameworkRoots =
      Suppliers.memoize(
          new Supplier<ImmutableSet<Path>>() {
            @Override
            public ImmutableSet<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_FRAMEWORK_ROOTS)
                  .toSet();
            }
          });

  private final Supplier<ImmutableList<CxxHeaders>> includes =
      Suppliers.memoize(
          new Supplier<ImmutableList<CxxHeaders>>() {
            @Override
            public ImmutableList<CxxHeaders> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transform(CxxPreprocessorInput.GET_INCLUDES)
                  .toList();
            }
          });

  private final LoadingCache<CxxSource.Type, ImmutableList<String>> preprocessorFlags =
      CacheBuilder.newBuilder()
          .build(
              new CacheLoader<CxxSource.Type, ImmutableList<String>>() {
                @Override
                public ImmutableList<String> load(@Nonnull CxxSource.Type type) {
                  ImmutableList.Builder<String> builder = ImmutableList.builder();
                  for (CxxPreprocessorInput input : cxxPreprocessorInput) {
                    builder.addAll(input.getPreprocessorFlags().get(type));
                  }
                  return builder.build();
                }
              });

  @VisibleForTesting
  public CxxSourceRuleFactory(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags) {
    this.params = params;
    this.resolver = resolver;
    this.pathResolver = pathResolver;
    this.cxxPlatform = cxxPlatform;
    this.cxxPreprocessorInput = cxxPreprocessorInput;
    this.compilerFlags = compilerFlags;
  }


  private String getPreprocessOutputName(CxxSource.Type type, String name) {
    CxxSource.Type outputType = CxxSourceTypes.getPreprocessorOutputType(type);
    return name + "." + Iterables.get(outputType.getExtensions(), 0);
  }


  @VisibleForTesting
  public BuildTarget createPreprocessBuildTarget(
      String name,
      CxxSource.Type type,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getPreprocessOutputName(type, name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    PREPROCESS_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isPreprocessFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(PREPROCESS_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }


  @VisibleForTesting
  Path getPreprocessOutputPath(BuildTarget target, CxxSource.Type type, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getPreprocessOutputName(type, name));
  }

  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Preprocessor tool = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());


    ImmutableSortedSet<BuildRule> dependencies =
        computeSourcePreprocessorAndToolDeps(Optional.of((Tool) tool), source);


    ImmutableList<String> platformFlags = computePlatformFlags(pic, source);

    ImmutableList<String> ruleFlags = computeRuleFlags(source);


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocess(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        platformFlags,
        ruleFlags,
        getPreprocessOutputPath(target, source.getType(), name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessBuildRule(resolver, name, source, pic);
  }


  private String getCompileOutputName(String name) {
    return name + ".o";
  }


  @VisibleForTesting
  Path getCompileOutputPath(BuildTarget target, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getCompileOutputName(name));
  }


  @VisibleForTesting
  public BuildTarget createCompileBuildTarget(
      String name,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getCompileOutputName(name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    COMPILE_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isCompileFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(COMPILE_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }



  private Compiler getCompiler(CxxSource.Type type) {
    return CxxSourceTypes.needsCxxCompiler(type) ?
        cxxPlatform.getCxx() :
        cxxPlatform.getCc();
  }

  private ImmutableList<String> getPlatformCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCflags());
    }



    if (type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCxxflags());
    }


    args.addAll(cxxPlatform.getAsflags());

    return args.build();
  }

  private ImmutableList<String> getRuleCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT ||
        type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(compilerFlags);
    }

    return args.build();
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isCompilableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Compiler compiler = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(compiler.getInputs(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))
            .build();


    ImmutableList<String> platformFlags =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(getPlatformCompileFlags(source.getType()))
            .build();

    ImmutableList<String> ruleFlags =
        ImmutableList.<String>builder()

            .addAll(getRuleCompileFlags(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.compile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        compiler,
        platformFlags,
        ruleFlags,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requireCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createCompileBuildRule(resolver, name, source, pic);
  }

  private ImmutableSortedSet<BuildRule> computeSourcePreprocessorAndToolDeps(
      Optional<Tool> toolOptional,
      CxxSource source) {

    ImmutableCollection<BuildRule> toolInputs =
        toolOptional.isPresent()
            ? toolOptional.get().getInputs(pathResolver)
            : ImmutableSet.<BuildRule>of();

    return ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(toolInputs)

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();
  }

  private ImmutableList<String> computePlatformFlags(
      PicType pic,
      CxxSource source) {
    return ImmutableList.<String>builder()

        .addAll(pic.getFlags())

        .addAll(CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, source.getType()))

        .addAll(
            getPlatformCompileFlags(
                CxxSourceTypes.getPreprocessorOutputType(source.getType())))
        .build();
  }


  private ImmutableList<String> computePlatformCompilerFlags(
      PicType pic,
      CxxSource source) {

    return ImmutableList.<String>builder()

        .addAll(pic.getFlags())

        .addAll(getPlatformCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))
        .build();
  }

  private ImmutableList<String> computeRuleFlags(CxxSource source) {
    return ImmutableList.<String>builder()

        .addAll(preprocessorFlags.getUnchecked(source.getType()))

        .addAll(getRuleCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

        .addAll(source.getFlags())
        .build();
  }

  private ImmutableList<String> computeRuleCompilerFlags(CxxSource source) {
    return ImmutableList.<String>builder()

        .addAll(getRuleCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

        .addAll(source.getFlags())
        .build();
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Preprocessor preprocessor = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());
    Compiler compiler = getCompiler(source.getType());

    LOG.verbose("Creating preprocess and compile %s for %s", target, source);


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocessAndCompile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(
                computeSourcePreprocessorAndToolDeps(Optional.of((Tool) compiler), source)),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        preprocessor,
        CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, source.getType()),
        preprocessorFlags.getUnchecked(source.getType()),
        compiler,
        computePlatformCompilerFlags(pic, source),
        computeRuleCompilerFlags(source),
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer(),
        strategy);
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
  }

  private ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleResolver resolver,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {

    ImmutableList.Builder<CxxPreprocessAndCompile> objects = ImmutableList.builder();

    for (Map.Entry<String, CxxSource> entry : sources.entrySet()) {
      String name = entry.getKey();
      CxxSource source = entry.getValue();

      Preconditions.checkState(
          CxxSourceTypes.isPreprocessableType(source.getType()) ||
              CxxSourceTypes.isCompilableType(source.getType()));

      switch (strategy) {

        case PIPED:
        case COMBINED: {
          CxxPreprocessAndCompile rule;



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            rule = requirePreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
          } else {
            rule = requireCompileBuildRule(resolver, name, source, pic);
          }

          objects.add(rule);
          break;
        }

        case SEPARATE: {



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            CxxPreprocessAndCompile rule = requirePreprocessBuildRule(resolver, name, source, pic);
            source = CxxSource.copyOf(source)
                .withType(CxxSourceTypes.getPreprocessorOutputType(source.getType()))
                .withPath(
                    new BuildTargetSourcePath(rule.getBuildTarget()));
          }


          CxxPreprocessAndCompile rule = requireCompileBuildRule(resolver, name, source, pic);
          objects.add(rule);

          break;
        }


        default:
          throw new IllegalStateException();
      }
    }

    return FluentIterable
        .from(objects.build())
        .toMap(new Function<CxxPreprocessAndCompile, SourcePath>() {
          @Override
          public SourcePath apply(CxxPreprocessAndCompile input) {
            return new BuildTargetSourcePath(input.getBuildTarget());
          }
        });
  }

  public static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {
    CxxSourceRuleFactory factory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            compilerFlags);
    return factory.requirePreprocessAndCompileRules(resolver, strategy, sources, pic);
  }

  public enum PicType {


    PIC("-fPIC"),


    PDC;

    private final ImmutableList<String> flags;

    PicType(String... flags) {
      this.flags = ImmutableList.copyOf(flags);
    }

    public ImmutableList<String> getFlags() {
      return flags;
    }

  }

}

<code block>

package com.facebook.buck.java;

import org.jacoco.core.analysis.Analyzer;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.tools.ExecFileLoader;
import org.jacoco.report.DirectorySourceFileLocator;
import org.jacoco.report.FileMultiReportOutput;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.ISourceFileLocator;
import org.jacoco.report.MultiSourceFileLocator;
import org.jacoco.report.csv.CSVFormatter;
import org.jacoco.report.html.HTMLFormatter;
import org.jacoco.report.xml.XMLFormatter;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;


public class ReportGenerator {

        private static final int TAB_WIDTH = 4;

        private final String title;

        private final File executionDataFile;
        private final ExecFileLoader execFileLoader;
        private final String classesPath;
        private final String sourcesPath;
        private final File reportDirectory;
        private final String reportFormat;


        public ReportGenerator() {
                String jacocoOutputDir = System.getProperty("jacoco.output.dir");
                this.title = "Code-Coverage Analysis";
                this.executionDataFile = new File(
                    jacocoOutputDir, System.getProperty("jacoco.exec.data.file"));
                this.execFileLoader = new ExecFileLoader();
                this.classesPath = System.getProperty("classes.dir");
                this.sourcesPath = System.getProperty("src.dir");
                this.reportDirectory = new File(jacocoOutputDir, "code-coverage");
                this.reportFormat = System.getProperty("jacoco.format", "html");
        }


        public void create() throws IOException {



                loadExecutionData();







                final IBundleCoverage bundleCoverage = analyzeStructure();

                createReport(bundleCoverage);

        }

        private void createReport(final IBundleCoverage bundleCoverage)
                        throws IOException {



                IReportVisitor visitor;
                switch (reportFormat) {
                    case "csv":
                        reportDirectory.mkdirs();
                        CSVFormatter csvFormatter = new CSVFormatter();
                        visitor = csvFormatter.createVisitor(
                            new FileOutputStream(new File(reportDirectory, "coverage.csv")));
                        break;

                    case "html":
                        HTMLFormatter htmlFormatter = new HTMLFormatter();
                        visitor = htmlFormatter.createVisitor(
                            new FileMultiReportOutput(reportDirectory));
                        break;

                    case "xml":
                        reportDirectory.mkdirs();
                        XMLFormatter xmlFormatter = new XMLFormatter();
                        visitor = xmlFormatter.createVisitor(
                            new FileOutputStream(new File(reportDirectory, "coverage.xml")));
                        break;

                    default:
                        throw new RuntimeException("Unable to parse format: " + reportFormat);
                }




                visitor.visitInfo(execFileLoader.getSessionInfoStore().getInfos(),
                                execFileLoader.getExecutionDataStore().getContents());



                visitor.visitBundle(bundleCoverage, createSourceFileLocator());



                visitor.visitEnd();

        }

        private void loadExecutionData() throws IOException {
                executionDataFile.createNewFile();
                execFileLoader.load(executionDataFile);
        }

        private IBundleCoverage analyzeStructure() throws IOException {
                final CoverageBuilder coverageBuilder = new CoverageBuilder();
                final Analyzer analyzer = new Analyzer(
                    execFileLoader.getExecutionDataStore(), coverageBuilder);

                String[] jarsPath = classesPath.split(":");
                for (String jarPath : jarsPath) {
                        analyzer.analyzeAll(new File(jarPath));
                }

                return coverageBuilder.getBundle(title);
        }

        private ISourceFileLocator createSourceFileLocator() {
          final MultiSourceFileLocator result = new MultiSourceFileLocator(TAB_WIDTH);

          String[] sourceDirectoryPaths = sourcesPath.split(":");
          for (String sourceDirectoryPath : sourceDirectoryPaths) {
            File sourceDirectory = new File(sourceDirectoryPath);
            result.add(new DirectorySourceFileLocator(sourceDirectory, "utf-8", TAB_WIDTH));
          }

          return result;
        }


        public static void main(final String[] args) throws IOException {
                final ReportGenerator generator = new ReportGenerator();
                generator.create();
        }

}

<code block>

package com.facebook.buck.util;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.io.DirectoryTraversal;
import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;
import java.util.regex.Pattern;

public class LicenseCheckTest {



  private static final Set<String> NON_APACHE_LICENSE_WHITELIST = ImmutableSet.of(

      "com/facebook/buck/java/ReportGenerator.java",
      "com/facebook/buck/util/WindowsCreateProcessEscape.java",
      "com/facebook/buck/util/WindowsCreateProcessEscapeTest.java");

  @Test
  public void ensureAllSrcFilesHaveTheApacheLicense() throws IOException {
    new JavaCopyrightTraversal(new File("src"), false).traverse();
    new JavaCopyrightTraversal(new File("test"), true).traverse();
  }

  private static class JavaCopyrightTraversal extends DirectoryTraversal {
    private static final Pattern LICENSE_FRAGMENT = Pattern.compile(



        "^/\\\\*.*?" +
        "\\\\* Copyright 20\\d\\d-present Facebook, Inc\\..*?" +
        "\\\\* Licensed under the Apache License, Version 2.0 \\(the \"License\"\\); you may.*",
        Pattern.MULTILINE | Pattern.DOTALL);

    private static final Path TEST_DATA = Paths.get("testdata");

    private final boolean ignoreTestData;

    public JavaCopyrightTraversal(File root, boolean ignoreTestData) {
      super(root);
      this.ignoreTestData = ignoreTestData;
    }

    @Override
    public void visit(File file, String relativePath) {
      if (!"java".equals(Files.getFileExtension(relativePath)) ||

          !file.exists() ||
          NON_APACHE_LICENSE_WHITELIST.contains(relativePath) ||
          relativePath.startsWith("com/facebook/buck/cli/quickstart/android/")) {
        return;
      }

      if (ignoreTestData) {
        for (Path path : file.toPath()) {
           if (TEST_DATA.equals(path)) {
             return;
           }
        }
      }

      try {
        String asString = Files.toString(file, Charsets.UTF_8);

        assertTrue("Check license of: " + relativePath,
            LICENSE_FRAGMENT.matcher(asString).matches());
      } catch (IOException e) {
        fail("Unable to read: " + relativePath);
      }
    }
  }
}

<code block>

package com.facebook.buck.java.coverage;

import org.jacoco.core.analysis.Analyzer;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.tools.ExecFileLoader;
import org.jacoco.report.DirectorySourceFileLocator;
import org.jacoco.report.FileMultiReportOutput;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.ISourceFileLocator;
import org.jacoco.report.MultiSourceFileLocator;
import org.jacoco.report.csv.CSVFormatter;
import org.jacoco.report.html.HTMLFormatter;
import org.jacoco.report.xml.XMLFormatter;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;


public class ReportGenerator {

        private static final int TAB_WIDTH = 4;

        private final String title;

        private final File executionDataFile;
        private final ExecFileLoader execFileLoader;
        private final String classesPath;
        private final String sourcesPath;
        private final File reportDirectory;
        private final String reportFormat;


        public ReportGenerator() {
                String jacocoOutputDir = System.getProperty("jacoco.output.dir");
                this.title = "Code-Coverage Analysis";
                this.executionDataFile = new File(
                    jacocoOutputDir, System.getProperty("jacoco.exec.data.file"));
                this.execFileLoader = new ExecFileLoader();
                this.classesPath = System.getProperty("classes.dir");
                this.sourcesPath = System.getProperty("src.dir");
                this.reportDirectory = new File(jacocoOutputDir, "code-coverage");
                this.reportFormat = System.getProperty("jacoco.format", "html");
        }


        public void create() throws IOException {



                loadExecutionData();







                final IBundleCoverage bundleCoverage = analyzeStructure();

                createReport(bundleCoverage);

        }

        private void createReport(final IBundleCoverage bundleCoverage)
                        throws IOException {



                IReportVisitor visitor;
                switch (reportFormat) {
                    case "csv":
                        reportDirectory.mkdirs();
                        CSVFormatter csvFormatter = new CSVFormatter();
                        visitor = csvFormatter.createVisitor(
                            new FileOutputStream(new File(reportDirectory, "coverage.csv")));
                        break;

                    case "html":
                        HTMLFormatter htmlFormatter = new HTMLFormatter();
                        visitor = htmlFormatter.createVisitor(
                            new FileMultiReportOutput(reportDirectory));
                        break;

                    case "xml":
                        reportDirectory.mkdirs();
                        XMLFormatter xmlFormatter = new XMLFormatter();
                        visitor = xmlFormatter.createVisitor(
                            new FileOutputStream(new File(reportDirectory, "coverage.xml")));
                        break;

                    default:
                        throw new RuntimeException("Unable to parse format: " + reportFormat);
                }




                visitor.visitInfo(execFileLoader.getSessionInfoStore().getInfos(),
                                execFileLoader.getExecutionDataStore().getContents());



                visitor.visitBundle(bundleCoverage, createSourceFileLocator());



                visitor.visitEnd();

        }

        private void loadExecutionData() throws IOException {
                executionDataFile.createNewFile();
                execFileLoader.load(executionDataFile);
        }

        private IBundleCoverage analyzeStructure() throws IOException {
                final CoverageBuilder coverageBuilder = new CoverageBuilder();
                final Analyzer analyzer = new Analyzer(
                    execFileLoader.getExecutionDataStore(), coverageBuilder);

                String[] jarsPath = classesPath.split(":");
                for (String jarPath : jarsPath) {
                        analyzer.analyzeAll(new File(jarPath));
                }

                return coverageBuilder.getBundle(title);
        }

        private ISourceFileLocator createSourceFileLocator() {
          final MultiSourceFileLocator result = new MultiSourceFileLocator(TAB_WIDTH);

          String[] sourceDirectoryPaths = sourcesPath.split(":");
          for (String sourceDirectoryPath : sourceDirectoryPaths) {
            File sourceDirectory = new File(sourceDirectoryPath);
            result.add(new DirectorySourceFileLocator(sourceDirectory, "utf-8", TAB_WIDTH));
          }

          return result;
        }


        public static void main(final String[] args) throws IOException {
                final ReportGenerator generator = new ReportGenerator();
                generator.create();
        }

}

<code block>

package com.facebook.buck.util;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import com.facebook.buck.io.DirectoryTraversal;
import com.google.common.base.Charsets;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;
import java.util.regex.Pattern;

public class LicenseCheckTest {



  private static final Set<String> NON_APACHE_LICENSE_WHITELIST = ImmutableSet.of(

      "com/facebook/buck/java/coverage/ReportGenerator.java",
      "com/facebook/buck/util/WindowsCreateProcessEscape.java",
      "com/facebook/buck/util/WindowsCreateProcessEscapeTest.java");

  @Test
  public void ensureAllSrcFilesHaveTheApacheLicense() throws IOException {
    new JavaCopyrightTraversal(new File("src"), false).traverse();
    new JavaCopyrightTraversal(new File("test"), true).traverse();
  }

  private static class JavaCopyrightTraversal extends DirectoryTraversal {
    private static final Pattern LICENSE_FRAGMENT = Pattern.compile(



        "^/\\\\*.*?" +
        "\\\\* Copyright 20\\d\\d-present Facebook, Inc\\..*?" +
        "\\\\* Licensed under the Apache License, Version 2.0 \\(the \"License\"\\); you may.*",
        Pattern.MULTILINE | Pattern.DOTALL);

    private static final Path TEST_DATA = Paths.get("testdata");

    private final boolean ignoreTestData;

    public JavaCopyrightTraversal(File root, boolean ignoreTestData) {
      super(root);
      this.ignoreTestData = ignoreTestData;
    }

    @Override
    public void visit(File file, String relativePath) {
      if (!"java".equals(Files.getFileExtension(relativePath)) ||

          !file.exists() ||
          NON_APACHE_LICENSE_WHITELIST.contains(relativePath) ||
          relativePath.startsWith("com/facebook/buck/cli/quickstart/android/")) {
        return;
      }

      if (ignoreTestData) {
        for (Path path : file.toPath()) {
           if (TEST_DATA.equals(path)) {
             return;
           }
        }
      }

      try {
        String asString = Files.toString(file, Charsets.UTF_8);

        assertTrue("Check license of: " + relativePath,
            LICENSE_FRAGMENT.matcher(asString).matches());
      } catch (IOException e) {
        fail("Unable to read: " + relativePath);
      }
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.ProcessExecutorParams;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.EnumSet;
import java.util.Set;

public class AppleConfig {

  private static final Logger LOG = Logger.get(AppleConfig.class);

  private final BuckConfig delegate;

  public AppleConfig(BuckConfig delegate) {
    this.delegate = delegate;
  }


  public Supplier<Optional<Path>> getAppleDeveloperDirectorySupplier(
      ProcessExecutor processExecutor) {
    Optional<String> xcodeDeveloperDirectory = delegate.getValue("apple", "xcode_developer_dir");
    if (xcodeDeveloperDirectory.isPresent()) {
      Path developerDirectory = delegate.resolvePathThatMayBeOutsideTheProjectFilesystem(
          Paths.get(xcodeDeveloperDirectory.get()));
      return Suppliers.ofInstance(Optional.of(developerDirectory));
    } else {
      return createAppleDeveloperDirectorySupplier(processExecutor);
    }
  }

  public ImmutableList<Path> getExtraToolchainPaths() {
    ImmutableList<String> extraPathsStrings = delegate.getListWithoutComments(
        "apple",
        "extra_toolchain_paths");
    return ImmutableList.copyOf(Lists.transform(
        extraPathsStrings,
        new Function<String, Path>() {
            @Override
            public Path apply(String string) {
                return Paths.get(string);
            }
        }));
  }

  public ImmutableList<Path> getExtraPlatformPaths() {
    ImmutableList<String> extraPathsStrings = delegate.getListWithoutComments(
        "apple",
        "extra_platform_paths");
    return ImmutableList.copyOf(Lists.transform(
        extraPathsStrings,
        new Function<String, Path>() {
            @Override
            public Path apply(String string) {
                return Paths.get(string);
            }
        }));
  }

  public ImmutableMap<AppleSdk, AppleSdkPaths> getAppleSdkPaths(ProcessExecutor processExecutor) {
    Optional<Path> appleDeveloperDirectory =
        getAppleDeveloperDirectorySupplier(processExecutor).get();
    try {
      ImmutableMap<String, AppleToolchain> toolchains =
          AppleToolchainDiscovery.discoverAppleToolchains(
              appleDeveloperDirectory,
              getExtraToolchainPaths());
      return AppleSdkDiscovery.discoverAppleSdkPaths(
          appleDeveloperDirectory,
          getExtraPlatformPaths(),
          toolchains);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }


  private static Supplier<Optional<Path>> createAppleDeveloperDirectorySupplier(
      final ProcessExecutor processExecutor) {
    return Suppliers.memoize(new Supplier<Optional<Path>>() {
      @Override
      public Optional<Path> get() {
        ProcessExecutorParams processExecutorParams =
            ProcessExecutorParams.builder()
                .setCommand(ImmutableList.of("xcode-select", "--print-path"))
                .build();

        Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
        ProcessExecutor.Result result;
        try {
          result = processExecutor.launchAndExecute(
              processExecutorParams,
              options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
        } catch (InterruptedException | IOException e) {
          LOG.warn("Could not execute xcode-select, continuing without developer dir.");
          return Optional.absent();
        }

        if (result.getExitCode() != 0) {
          throw new RuntimeException("xcode-select --print-path failed: " + result.getStderr());
        }

        return Optional.of(Paths.get(result.getStdout().get().trim()));
      }
    });
  }

  public Optional<String> getTargetSdkVersion(ApplePlatform platform) {
    return delegate.getValue("apple", platform.getName() + "_target_sdk_version");
  }

  public ImmutableList<String> getXctestPlatformNames() {
    return delegate.getListWithoutComments(
        "apple",
        "xctest_platforms");
  }

  public Optional<Path> getXctoolPath() {
    Optional<String> xctoolPath = delegate.getValue("apple", "xctool_path");
    if (xctoolPath.isPresent()) {
      return Optional.of(Paths.get(xctoolPath.get()));
    } else {
      return Optional.absent();
    }
  }

  public Optional<BuildTarget> getXctoolZipTarget() {
    return delegate.getBuildTarget("apple", "xctool_zip_target");
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSNumber;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.cxx.NativeTestable;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.shell.DefaultShellStep;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.CopyStep;
import com.facebook.buck.step.fs.FindAndReplaceStep;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.step.fs.WriteFileStep;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import java.nio.file.Path;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;


public class AppleBundle extends AbstractBuildRule implements NativeTestable {
  private static final Logger LOG = Logger.get(AppleBundle.class);

  @AddToRuleKey
  private final String extension;

  @AddToRuleKey
  private final Optional<SourcePath> infoPlist;

  @AddToRuleKey
  private final ImmutableMap<String, String> infoPlistSubstitutions;

  @AddToRuleKey
  private final Optional<BuildRule> binary;

  @AddToRuleKey
  private final AppleBundleDestinations destinations;

  @AddToRuleKey
  private final Set<SourcePath> resourceDirs;

  @AddToRuleKey
  private final Set<SourcePath> resourceFiles;

  @AddToRuleKey
  private final Set<SourcePath> dirsContainingResourceDirs;

  @AddToRuleKey
  private final Optional<ImmutableSet<SourcePath>> resourceVariantFiles;

  @AddToRuleKey
  private final Tool ibtool;

  @AddToRuleKey
  private final Tool dsymutil;

  @AddToRuleKey
  private final Tool strip;

  @AddToRuleKey
  private final ImmutableSortedSet<BuildTarget> tests;

  @AddToRuleKey
  private final String platformName;

  @AddToRuleKey
  private final String sdkName;

  private final ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs;

  private final Optional<AppleAssetCatalog> mergedAssetCatalog;

  private final String binaryName;
  private final Path bundleRoot;
  private final Path binaryPath;

  AppleBundle(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Either<AppleBundleExtension, String> extension,
      Optional<SourcePath> infoPlist,
      Map<String, String> infoPlistSubstitutions,
      Optional<BuildRule> binary,
      AppleBundleDestinations destinations,
      Set<SourcePath> resourceDirs,
      Set<SourcePath> resourceFiles,
      Set<SourcePath> dirsContainingResourceDirs,
      Optional<ImmutableSet<SourcePath>> resourceVariantFiles,
      Tool ibtool,
      Tool dsymutil,
      Tool strip,
      Set<AppleAssetCatalog> bundledAssetCatalogs,
      Optional<AppleAssetCatalog> mergedAssetCatalog,
      Set<BuildTarget> tests,
      String platformName,
      String sdkName) {
    super(params, resolver);
    this.extension = extension.isLeft() ?
        extension.getLeft().toFileExtension() :
        extension.getRight();
    this.infoPlist = infoPlist;
    this.infoPlistSubstitutions = ImmutableMap.copyOf(infoPlistSubstitutions);
    this.binary = binary;
    this.destinations = destinations;
    this.resourceDirs = resourceDirs;
    this.resourceFiles = resourceFiles;
    this.dirsContainingResourceDirs = dirsContainingResourceDirs;
    this.resourceVariantFiles = resourceVariantFiles;
    this.ibtool = ibtool;
    this.dsymutil = dsymutil;
    this.strip = strip;
    this.bundledAssetCatalogs = ImmutableSet.copyOf(bundledAssetCatalogs);
    this.mergedAssetCatalog = mergedAssetCatalog;
    this.binaryName = getBinaryName(getBuildTarget());
    this.bundleRoot = getBundleRoot(getBuildTarget(), this.extension);
    this.binaryPath = this.destinations.getExecutablesPath()
        .resolve(this.binaryName);
    this.tests = ImmutableSortedSet.copyOf(tests);
    this.platformName = platformName;
    this.sdkName = sdkName;
  }

  public static String getBinaryName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  public static Path getBundleRoot(BuildTarget buildTarget, String extension) {
    return BuildTargets
        .getGenPath(buildTarget, "%s")
        .resolve(getBinaryName(buildTarget) + "." + extension);
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return bundleRoot;
  }

  public Path getInfoPlistPath() {
    return getMetadataPath().resolve("Info.plist");
  }

  public Path getUnzippedOutputFilePathToBinary() {
    return this.binaryPath;
  }

  private Path getMetadataPath() {
    return bundleRoot.resolve(destinations.getMetadataPath());
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> stepsBuilder = ImmutableList.builder();

    Path metadataPath = getMetadataPath();

    Path infoPlistInputPath = getResolver().getPath(infoPlist.get());
    Path infoPlistSubstitutionTempPath =
        BuildTargets.getScratchPath(getBuildTarget(), "%s.plist");
    Path infoPlistOutputPath = metadataPath.resolve("Info.plist");

    stepsBuilder.add(
        new MakeCleanDirectoryStep(bundleRoot),
        new MkdirStep(metadataPath),

        new WriteFileStep("APPLWRUN", metadataPath.resolve("PkgInfo")),
        new FindAndReplaceStep(
            infoPlistInputPath,
            infoPlistSubstitutionTempPath,
            InfoPlistSubstitution.createVariableExpansionFunction(
                withDefaults(
                    infoPlistSubstitutions,
                    ImmutableMap.of(
                        "EXECUTABLE_NAME", binaryName,
                        "PRODUCT_NAME", binaryName
                    ))
            )),
        new PlistProcessStep(
            infoPlistSubstitutionTempPath,
            infoPlistOutputPath,
            getInfoPlistAdditionalKeys(platformName, sdkName),
            getInfoPlistOverrideKeys(platformName),
            PlistProcessStep.OutputFormat.BINARY));





    if (binary.isPresent() && binary.get().getPathToOutput() != null) {
      stepsBuilder.add(
          new MkdirStep(bundleRoot.resolve(this.destinations.getExecutablesPath())));
      Path bundleBinaryPath = bundleRoot.resolve(binaryPath);
      stepsBuilder.add(
          CopyStep.forFile(
              binary.get().getPathToOutput(),
              bundleBinaryPath));
      stepsBuilder.add(
          new DsymStep(
              dsymutil.getCommandPrefix(getResolver()),
              bundleBinaryPath,
              bundleBinaryPath.resolveSibling(
                  bundleBinaryPath.getFileName().toString() + ".dSYM")));
      stepsBuilder.add(
          new DefaultShellStep(
              ImmutableList.<String>builder()
                  .addAll(strip.getCommandPrefix(getResolver()))
                  .add("-S")
                  .add(getProjectFilesystem().resolve(bundleBinaryPath).toString())
                  .build()));
    }

    Path bundleDestinationPath = bundleRoot.resolve(this.destinations.getResourcesPath());
    for (SourcePath dir : resourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }
    for (SourcePath dir : dirsContainingResourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }
    for (SourcePath file : resourceFiles) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      Path resolvedFilePath = getResolver().getPath(file);
      Path destinationPath = bundleDestinationPath.resolve(resolvedFilePath.getFileName());
      addResourceProcessingSteps(resolvedFilePath, destinationPath, stepsBuilder);
    }

    if (resourceVariantFiles.isPresent()) {
      for (SourcePath variantSourcePath : resourceVariantFiles.get()) {
        Path variantFilePath = getResolver().getPath(variantSourcePath);

        Path variantDirectory = variantFilePath.getParent();
        if (variantDirectory == null || !variantDirectory.toString().endsWith(".lproj")) {
          throw new HumanReadableException(
              "Variant files have to be in a directory with name ending in '.lproj', " +
                  "but '%s' is not.",
              variantFilePath);
        }

        Path bundleVariantDestinationPath =
            bundleDestinationPath.resolve(variantDirectory.getFileName());
        stepsBuilder.add(new MkdirStep(bundleVariantDestinationPath));

        Path destinationPath = bundleVariantDestinationPath.resolve(variantFilePath.getFileName());
        addResourceProcessingSteps(variantFilePath, destinationPath, stepsBuilder);
      }
    }

    for (AppleAssetCatalog bundledAssetCatalog : bundledAssetCatalogs) {
      Path bundleDir = bundledAssetCatalog.getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }

    if (mergedAssetCatalog.isPresent()) {
      Path bundleDir = mergedAssetCatalog.get().getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }


    buildableContext.recordArtifact(bundleRoot);

    return stepsBuilder.build();
  }

  static ImmutableMap<String, String> withDefaults(
      ImmutableMap<String, String> map,
      ImmutableMap<String, String> defaults) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.<String, String>builder()
        .putAll(map);
    for (ImmutableMap.Entry<String, String> entry : defaults.entrySet()) {
      if (!map.containsKey(entry.getKey())) {
        builder = builder.put(entry.getKey(), entry.getValue());
      }
    }
    return builder.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistOverrideKeys(
      String platformName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("LSRequiresIPhoneOS", new NSNumber(false));
    } else {
      keys.put("LSRequiresIPhoneOS", new NSNumber(true));
    }

    return keys.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistAdditionalKeys(
      String platformName,
      String sdkName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("NSHighResolutionCapable", new NSNumber(true));
      keys.put("NSSupportsAutomaticGraphicsSwitching", new NSNumber(true));
    }

    keys.put("DTPlatformName", new NSString(platformName));
    keys.put("DTSDKName", new NSString(sdkName));

    return keys.build();
  }

  private void addResourceProcessingSteps(
      Path sourcePath,
      Path destinationPath,
      ImmutableList.Builder<Step> stepsBuilder) {
    String sourcePathExtension = Files.getFileExtension(sourcePath.toString())
        .toLowerCase(Locale.US);
    switch (sourcePathExtension) {
      case "plist":
      case "stringsdict":
        LOG.debug("Converting plist %s to binary plist %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new PlistProcessStep(
                sourcePath,
                destinationPath,
                ImmutableMap.<String, NSObject>of(),
                ImmutableMap.<String, NSObject>of(),
                PlistProcessStep.OutputFormat.BINARY));
        break;
      case "xib":
        String compiledNibFilename = Files.getNameWithoutExtension(destinationPath.toString()) +
            ".nib";
        Path compiledNibPath = destinationPath.getParent().resolve(compiledNibFilename);
        LOG.debug("Compiling XIB %s to NIB %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new IbtoolStep(
                ibtool.getCommandPrefix(getResolver()),
                sourcePath,
                compiledNibPath));
        break;
      default:
        stepsBuilder.add(CopyStep.forFile(sourcePath, destinationPath));
        break;
    }
  }

  @Override
  public boolean isTestedBy(BuildTarget testRule) {
    if (tests.contains(testRule)) {
      return true;
    }

    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).isTestedBy(testRule);
      }
    }

    return false;
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      TargetGraph targetGraph,
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).getCxxPreprocessorInput(
            targetGraph,
            cxxPlatform,
            headerVisibility);
      }
    }
    return CxxPreprocessorInput.EMPTY;
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.google.common.collect.ImmutableMap;

import com.dd.plist.BinaryPropertyListWriter;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.nio.file.Path;

public class PlistProcessStep implements Step {


  public static enum OutputFormat {

    XML,


    BINARY,
    ;
  }

  private final Path input;
  private final Path output;


  private final ImmutableMap<String, NSObject> additionalKeys;


  private final ImmutableMap<String, NSObject> overrideKeys;
  private final OutputFormat outputFormat;

  public PlistProcessStep(
      Path input,
      Path output,
      ImmutableMap<String, NSObject> additionalKeys,
      ImmutableMap<String, NSObject> overrideKeys,
      OutputFormat outputFormat) {
    this.input = input;
    this.output = output;
    this.additionalKeys = additionalKeys;
    this.overrideKeys = overrideKeys;
    this.outputFormat = outputFormat;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {
    ProjectFilesystem filesystem = context.getProjectFilesystem();
    try (InputStream stream = filesystem.newFileInputStream(input);
         BufferedInputStream bufferedStream = new BufferedInputStream(stream)) {
      NSObject infoPlist;
      try {
        infoPlist = PropertyListParser.parse(bufferedStream);
      } catch (Exception e) {
        throw new IOException(e);
      }

      if (infoPlist instanceof NSDictionary) {
        NSDictionary dictionary = (NSDictionary) infoPlist;
        for (ImmutableMap.Entry<String, NSObject> entry : additionalKeys.entrySet()) {
          if (!dictionary.containsKey(entry.getKey())) {
            dictionary.put(entry.getKey(), entry.getValue());
          }
        }

        dictionary.putAll(overrideKeys);
      }

      switch (this.outputFormat) {
        case XML:
          String serializedInfoPlist = infoPlist.toXMLPropertyList();
          filesystem.writeContentsToPath(
              serializedInfoPlist,
              output);
          break;
        case BINARY:
          byte[] binaryInfoPlist = BinaryPropertyListWriter.writeToArray(infoPlist);
          filesystem.writeBytesToPath(
              binaryInfoPlist,
              output);
          break;
      }
    } catch (IOException e) {
      context.logError(e, "error parsing plist %s", input);
      return 1;
    }

    return 0;
  }

  @Override
  public String getShortName() {
    return "process-plist";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return String.format("process-plist %s %s", input, output);
  }

}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class InfoPlistSubstitution {


  private InfoPlistSubstitution() { }

  private static final String VARIABLE_GROUP_NAME = "variable";
  private static final String OPEN_PAREN_GROUP_NAME = "openparen";
  private static final String CLOSE_PAREN_GROUP_NAME = "closeparen";
  private static final String MODIFIER_GROUP_NAME = "modifier";

  private static final Pattern PLIST_VARIABLE_PATTERN =
      Pattern.compile(
          "\\$(?<" + OPEN_PAREN_GROUP_NAME + ">[\\{\\(])" +
          "(?<" + VARIABLE_GROUP_NAME + ">[^\\}\\):]+)" +
          "(?::(?<" + MODIFIER_GROUP_NAME + ">[^\\}\\)]+))?" +
          "(?<" + CLOSE_PAREN_GROUP_NAME + ">[\\}\\)])");

  private static final ImmutableMap<String, String> MATCHING_PARENS = ImmutableMap.of(
      "{", "}",
      "(", ")"
  );

  public static String replaceVariablesInString(
      String input,
      Map<String, String> variablesToExpand) {
    return replaceVariablesInString(input, variablesToExpand, ImmutableList.<String>of());
  }

  private static String replaceVariablesInString(
      String input,
      Map<String, String> variablesToExpand,
      List<String> maskedVariables) {
    Matcher variableMatcher = PLIST_VARIABLE_PATTERN.matcher(input);

    StringBuffer result = new StringBuffer();
    while (variableMatcher.find()) {
      String openParen = variableMatcher.group(OPEN_PAREN_GROUP_NAME);
      String closeParen = variableMatcher.group(CLOSE_PAREN_GROUP_NAME);

      String expectedCloseParen = Preconditions.checkNotNull(MATCHING_PARENS.get(openParen));
      if (!expectedCloseParen.equals(closeParen)) {

        variableMatcher.appendReplacement(
            result,
            Matcher.quoteReplacement(variableMatcher.group(0)));
        continue;
      }

      String variableName = variableMatcher.group(VARIABLE_GROUP_NAME);
      if (maskedVariables.contains(variableName)) {
        throw new HumanReadableException(
            "Recursive plist variable: %s -> %s",
            Joiner.on(" -> ").join(maskedVariables),
            variableName);
      }

      String expansion = variablesToExpand.get(variableName);
      if (expansion == null) {
        throw new HumanReadableException(
            "Unrecognized plist variable: %s",
            variableMatcher.group(0));
      }



      expansion = replaceVariablesInString(
          expansion,
          variablesToExpand,
          new ImmutableList.Builder<String>().addAll(maskedVariables).add(variableName).build());




      variableMatcher.appendReplacement(
          result,
          Matcher.quoteReplacement(expansion));
    }
    variableMatcher.appendTail(result);
    return result.toString();
  }

  public static Function<String, String> createVariableExpansionFunction(
      Map<String, String> variablesToExpand) {
    final ImmutableMap<String, String> variablesToExpandCopy = ImmutableMap.copyOf(
        variablesToExpand);
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return replaceVariablesInString(input, variablesToExpandCopy);
      }
    };
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxCompilationDatabase;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

import java.util.Map;
import java.util.Set;

public class AppleTestDescription implements
    Description<AppleTestDescription.Arg>,
    Flavored,
    ImplicitDepsInferringDescription<AppleTestDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("apple_test");


  private static final Flavor LIBRARY_FLAVOR = ImmutableFlavor.of("apple-test-library");
  private static final Flavor BUNDLE_FLAVOR = ImmutableFlavor.of("apple-test-bundle");

  private static final Set<Flavor> SUPPORTED_FLAVORS = ImmutableSet.of(
      LIBRARY_FLAVOR, BUNDLE_FLAVOR);

  private static final Predicate<Flavor> IS_SUPPORTED_FLAVOR = Predicates.in(SUPPORTED_FLAVORS);

  private static final Set<Flavor> NON_LIBRARY_FLAVORS = ImmutableSet.of(
      CxxCompilationDatabase.COMPILATION_DATABASE,
      CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR,
      CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR);

  private final AppleConfig appleConfig;
  private final AppleBundleDescription appleBundleDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleTestDescription(
      AppleConfig appleConfig,
      AppleBundleDescription appleBundleDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleConfig = appleConfig;
    this.appleBundleDescription = appleBundleDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return FluentIterable.from(flavors).allMatch(IS_SUPPORTED_FLAVOR) ||
        appleLibraryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    String extension = args.extension.isLeft() ?
        args.extension.getLeft().toFileExtension() :
        args.extension.getRight();
    if (!AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS.contains(extension)) {
      throw new HumanReadableException(
          "Invalid bundle extension for apple_test rule: %s (must be one of %s)",
          extension,
          AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS);
    }
    boolean createBundle = Sets.intersection(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS).isEmpty();
    Sets.SetView<Flavor> nonLibraryFlavors = Sets.difference(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS);
    boolean addDefaultPlatform = nonLibraryFlavors.isEmpty();
    ImmutableSet.Builder<Flavor> extraFlavorsBuilder = ImmutableSet.builder();
    if (createBundle) {
      extraFlavorsBuilder.add(
          LIBRARY_FLAVOR,
          CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR);
    }
    if (addDefaultPlatform) {
      extraFlavorsBuilder.add(defaultCxxPlatform.getFlavor());
    }

    Optional<AppleBundle> testHostApp;
    Optional<SourcePath> testHostAppBinarySourcePath;
    if (args.testHostApp.isPresent()) {
      TargetNode<?> testHostAppNode = targetGraph.get(args.testHostApp.get());
      Preconditions.checkNotNull(testHostAppNode);

      if (testHostAppNode.getType() != AppleBundleDescription.TYPE) {
        throw new HumanReadableException(
            "Apple test rule %s has unrecognized test_host_app %s type %s (should be %s)",
            params.getBuildTarget(),
            args.testHostApp.get(),
            testHostAppNode.getType(),
            AppleBundleDescription.TYPE);
      }

      AppleBundleDescription.Arg testHostAppDescription = (AppleBundleDescription.Arg)
          testHostAppNode.getConstructorArg();

      testHostApp = Optional.of(
          appleBundleDescription
              .createBuildRule(
                  targetGraph,
                  params.copyWithChanges(
                      BuildTarget.builder(args.testHostApp.get())
                          .addAllFlavors(nonLibraryFlavors)
                          .build(),
                      Suppliers.ofInstance(
                          BuildRules.toBuildRulesFor(
                              args.testHostApp.get(),
                              resolver,
                              testHostAppNode.getDeclaredDeps())),
                      Suppliers.ofInstance(
                          BuildRules.toBuildRulesFor(
                              args.testHostApp.get(),
                              resolver,
                              testHostAppNode.getExtraDeps()))),
                  resolver,
                  testHostAppDescription));
      testHostAppBinarySourcePath = Optional.<SourcePath>of(
          new BuildTargetSourcePath(testHostAppDescription.binary));
    } else {
      testHostApp = Optional.absent();
      testHostAppBinarySourcePath = Optional.absent();
    }

    BuildRule library = appleLibraryDescription.createBuildRule(
        targetGraph,
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget())
                .addAllFlavors(extraFlavorsBuilder.build())
                .build(),
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        resolver,
        args,


        Optional.of(Linker.LinkableDepType.STATIC),
        testHostAppBinarySourcePath);
    if (!createBundle) {
      return library;
    }

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple test requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);
    ImmutableSet.Builder<SourcePath> resourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> resourceFilesBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> resourceVariantFilesBuilder = ImmutableSet.builder();

    AppleResources.collectResourceDirsAndFiles(
        targetGraph,
        Preconditions.checkNotNull(targetGraph.get(params.getBuildTarget())),
        resourceDirsBuilder,
        dirsContainingResourceDirsBuilder,
        resourceFilesBuilder,
        resourceVariantFilesBuilder);

    ImmutableSet<SourcePath> resourceDirs = resourceDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> resourceFiles = resourceFilesBuilder.build();
    ImmutableSet<SourcePath> resourceVariantFiles = resourceVariantFilesBuilder.build();

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            targetGraph,
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();

    String sdkName = appleCxxPlatform.getAppleSdk().getName();
    String platformName = appleCxxPlatform.getAppleSdk().getApplePlatform().getName();

    AppleBundle bundle = new AppleBundle(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget()).addFlavors(BUNDLE_FLAVOR).build(),


            Suppliers.ofInstance(
                ImmutableSortedSet.<BuildRule>naturalOrder()
                    .add(library)
                    .addAll(mergedAssetCatalog.asSet())
                    .addAll(bundledAssetCatalogs)
                    .addAll(params.getDeclaredDeps())
                    .addAll(
                        BuildRules.toBuildRulesFor(
                            params.getBuildTarget(),
                            resolver,
                            SourcePaths.filterBuildTargetSourcePaths(
                                Iterables.concat(
                                    resourceFiles,
                                    resourceDirs,
                                    dirsContainingResourceDirs,
                                    resourceVariantFiles))))
                    .build()),
            Suppliers.ofInstance(params.getExtraDeps())),
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(library),
        destinations,
        resourceDirs,
        resourceFiles,
        dirsContainingResourceDirsBuilder.build(),
        Optional.of(resourceVariantFiles),
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        appleCxxPlatform.getCxxPlatform().getStrip(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        ImmutableSortedSet.<BuildTarget>of(),
        platformName,
        sdkName);


    Optional<BuildRule> xctoolZipBuildRule;
    if (appleConfig.getXctoolZipTarget().isPresent()) {
      xctoolZipBuildRule = Optional.of(
          resolver.getRule(appleConfig.getXctoolZipTarget().get()));
    } else {
      xctoolZipBuildRule = Optional.absent();
    }

    return new AppleTest(
        appleConfig.getXctoolPath(),
        xctoolZipBuildRule,
        appleCxxPlatform.getXctest(),
        appleCxxPlatform.getOtest(),
        appleConfig.getXctestPlatformNames().contains(platformName),
        platformName,
        Optional.<String>absent(),
        params.copyWithDeps(
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(bundle)),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        sourcePathResolver,
        bundle,
        testHostApp,
        extension,
        args.contacts.get(),
        args.labels.get());
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      AppleTestDescription.Arg constructorArg) {



    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();
    Optional<BuildTarget> xctoolZipTarget = appleConfig.getXctoolZipTarget();
    if (xctoolZipTarget.isPresent()) {
      deps.add(xctoolZipTarget.get());
    }
    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends AppleNativeTargetDescriptionArg implements HasAppleBundleFields {
    public Optional<ImmutableSortedSet<String>> contacts;
    public Optional<ImmutableSortedSet<Label>> labels;
    public Optional<Boolean> canGroup;
    public Optional<BuildTarget> testHostApp;


    public Either<AppleBundleExtension, String> extension;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<String> xcodeProductType;
    public Optional<String> resourcePrefixDir;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }

    public boolean canGroup() {
      return canGroup.or(false);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractApplePlatform implements Comparable<AbstractApplePlatform> {
  class Name {
    public static final String IPHONEOS = "iphoneos";
    public static final String IPHONESIMULATOR = "iphonesimulator";
    public static final String WATCHOS = "watchos";
    public static final String WATCHSIMULATOR = "watchsimulator";
    public static final String MACOSX = "macosx";

    private Name() { }
  }


  public abstract String getName();

  @Override
  public int compareTo(AbstractApplePlatform other) {
    return getName().compareTo(other.getName());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Hint;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

import java.util.Map;
import java.util.Set;

public class AppleBundleDescription implements Description<AppleBundleDescription.Arg>, Flavored {
  public static final BuildRuleType TYPE = BuildRuleType.of("apple_bundle");

  private final AppleBinaryDescription appleBinaryDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleBundleDescription(
      AppleBinaryDescription appleBinaryDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleBinaryDescription = appleBinaryDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    if (appleLibraryDescription.hasFlavors(flavors)) {
      return true;
    }
    ImmutableSet.Builder<Flavor> flavorBuilder = ImmutableSet.builder();
    for (Flavor flavor : flavors) {
      if (flavor.equals(ReactNativeFlavors.DO_NOT_BUNDLE)) {
        continue;
      }
      flavorBuilder.add(flavor);
    }
    return appleBinaryDescription.hasFlavors(flavorBuilder.build());
  }

  @Override
  public <A extends Arg> AppleBundle createBuildRule(
      TargetGraph targetGraph,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple bundle requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    ImmutableSet.Builder<SourcePath> bundleDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleFilesBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleVariantFilesBuilder = ImmutableSet.builder();
    AppleResources.collectResourceDirsAndFiles(
        targetGraph,
        Preconditions.checkNotNull(targetGraph.get(params.getBuildTarget())),
        bundleDirsBuilder,
        dirsContainingResourceDirsBuilder,
        bundleFilesBuilder,
        bundleVariantFilesBuilder);
    ImmutableSet<SourcePath> bundleDirs = bundleDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> bundleFiles = bundleFilesBuilder.build();
    ImmutableSet<SourcePath> bundleVariantFiles = bundleVariantFilesBuilder.build();

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            targetGraph,
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();



    BuildRule flavoredBinaryRule = getFlavoredBinaryRule(targetGraph, params, resolver, args);
    BuildRuleParams bundleParamsWithFlavoredBinaryDep = getBundleParamsWithUpdatedDeps(
        params,
        args.binary,
        ImmutableSet.<BuildRule>builder()
            .add(flavoredBinaryRule)
            .addAll(mergedAssetCatalog.asSet())
            .addAll(bundledAssetCatalogs)
            .addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    SourcePaths.filterBuildTargetSourcePaths(
                        Iterables.concat(
                            bundleFiles,
                            bundleDirs,
                            dirsContainingResourceDirs,
                            bundleVariantFiles))))
            .build());

    return new AppleBundle(
        bundleParamsWithFlavoredBinaryDep,
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(flavoredBinaryRule),
        destinations,
        bundleDirs,
        bundleFiles,
        dirsContainingResourceDirs,
        Optional.of(bundleVariantFiles),
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        appleCxxPlatform.getCxxPlatform().getStrip(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        args.getTests(),
        appleCxxPlatform.getAppleSdk().getApplePlatform().getName(),
        appleCxxPlatform.getAppleSdk().getName());
  }

  private static <A extends Arg> BuildRule getFlavoredBinaryRule(
      TargetGraph targetGraph,
      final BuildRuleParams params,
      final BuildRuleResolver resolver,
      A args) {
    final TargetNode<?> binaryTargetNode = Preconditions.checkNotNull(targetGraph.get(args.binary));
    BuildRuleParams binaryRuleParams = new BuildRuleParams(
        args.binary,
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getDeclaredDeps())),
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getExtraDeps())),
        params.getProjectFilesystem(),
        params.getRuleKeyBuilderFactory());
    return CxxDescriptionEnhancer.requireBuildRule(
        targetGraph,
        binaryRuleParams,
        resolver,
        params
            .getBuildTarget()
            .withoutFlavors(ImmutableSet.of(ReactNativeFlavors.DO_NOT_BUNDLE))
            .getFlavors()
            .toArray(new Flavor[0]));
  }

  private static BuildRuleParams getBundleParamsWithUpdatedDeps(
      final BuildRuleParams params,
      final BuildTarget originalBinaryTarget,
      final Set<BuildRule> newDeps) {

    final Predicate<BuildRule> notOriginalBinaryRule = Predicates.not(
        BuildRules.isBuildRuleWithTarget(originalBinaryTarget));
    return params.copyWithDeps(
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getDeclaredDeps())
                .filter(notOriginalBinaryRule)
                .append(newDeps)
                .toSortedSet(Ordering.natural())),
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getExtraDeps())
                .filter(notOriginalBinaryRule)
                .toSortedSet(Ordering.natural())));
  }

  @SuppressFieldNotInitialized
  public static class Arg implements HasAppleBundleFields, HasTests {
    public Either<AppleBundleExtension, String> extension;
    public BuildTarget binary;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<ImmutableMap<String, SourcePath>> headers;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
    @Hint(isDep = false) public Optional<ImmutableSortedSet<BuildTarget>> tests;
    public Optional<String> xcodeProductType;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public ImmutableSortedSet<BuildTarget> getTests() {
      return tests.get();
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }
  }
}

<code block>


package com.facebook.buck.rules;

import com.facebook.buck.android.AndroidAarDescription;
import com.facebook.buck.android.AndroidBinaryDescription;
import com.facebook.buck.android.AndroidBuckConfig;
import com.facebook.buck.android.AndroidBuildConfigDescription;
import com.facebook.buck.android.AndroidDirectoryResolver;
import com.facebook.buck.android.AndroidInstrumentationApkDescription;
import com.facebook.buck.android.AndroidInstrumentationTestDescription;
import com.facebook.buck.android.AndroidLibraryDescription;
import com.facebook.buck.android.AndroidManifestDescription;
import com.facebook.buck.android.AndroidPrebuiltAarDescription;
import com.facebook.buck.android.AndroidResourceDescription;
import com.facebook.buck.android.ApkGenruleDescription;
import com.facebook.buck.android.GenAidlDescription;
import com.facebook.buck.android.ImmutableNdkCxxPlatforms;
import com.facebook.buck.android.NdkCxxPlatform;
import com.facebook.buck.android.NdkCxxPlatforms;
import com.facebook.buck.android.NdkLibraryDescription;
import com.facebook.buck.android.PrebuiltNativeLibraryDescription;
import com.facebook.buck.android.ProGuardConfig;
import com.facebook.buck.android.RobolectricTestDescription;
import com.facebook.buck.android.SmartDexingStep;
import com.facebook.buck.apple.AppleAssetCatalogDescription;
import com.facebook.buck.apple.AppleBinaryDescription;
import com.facebook.buck.apple.AppleBundleDescription;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleCxxPlatform;
import com.facebook.buck.apple.AppleCxxPlatforms;
import com.facebook.buck.apple.AppleLibraryDescription;
import com.facebook.buck.apple.AppleResourceDescription;
import com.facebook.buck.apple.AppleSdk;
import com.facebook.buck.apple.AppleSdkDiscovery;
import com.facebook.buck.apple.AppleSdkPaths;
import com.facebook.buck.apple.AppleTestDescription;
import com.facebook.buck.apple.AppleToolchain;
import com.facebook.buck.apple.AppleToolchainDiscovery;
import com.facebook.buck.apple.CoreDataModelDescription;
import com.facebook.buck.apple.XcodePostbuildScriptDescription;
import com.facebook.buck.apple.XcodePrebuildScriptDescription;
import com.facebook.buck.apple.XcodeWorkspaceConfigDescription;
import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.CxxBinaryDescription;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxLibraryDescription;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.CxxPythonExtensionDescription;
import com.facebook.buck.cxx.CxxTestDescription;
import com.facebook.buck.cxx.DefaultCxxPlatforms;
import com.facebook.buck.cxx.PrebuiltCxxLibraryDescription;
import com.facebook.buck.d.DBinaryDescription;
import com.facebook.buck.d.DBuckConfig;
import com.facebook.buck.d.DLibraryDescription;
import com.facebook.buck.d.DTestDescription;
import com.facebook.buck.file.Downloader;
import com.facebook.buck.file.ExplodingDownloader;
import com.facebook.buck.file.HttpDownloader;
import com.facebook.buck.file.RemoteFileDescription;
import com.facebook.buck.gwt.GwtBinaryDescription;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.java.JavaBinaryDescription;
import com.facebook.buck.java.JavaBuckConfig;
import com.facebook.buck.java.JavaLibraryDescription;
import com.facebook.buck.java.JavaTestDescription;
import com.facebook.buck.java.JavacOptions;
import com.facebook.buck.java.KeystoreDescription;
import com.facebook.buck.java.PrebuiltJarDescription;
import com.facebook.buck.js.AndroidReactNativeLibraryDescription;
import com.facebook.buck.js.IosReactNativeLibraryDescription;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.ocaml.OCamlBinaryDescription;
import com.facebook.buck.ocaml.OCamlBuckConfig;
import com.facebook.buck.ocaml.OCamlLibraryDescription;
import com.facebook.buck.ocaml.PrebuiltOCamlLibraryDescription;
import com.facebook.buck.python.PrebuiltPythonLibraryDescription;
import com.facebook.buck.python.PythonBinaryDescription;
import com.facebook.buck.python.PythonBuckConfig;
import com.facebook.buck.python.PythonEnvironment;
import com.facebook.buck.python.PythonLibraryDescription;
import com.facebook.buck.python.PythonTestDescription;
import com.facebook.buck.rust.RustBinaryDescription;
import com.facebook.buck.rust.RustBuckConfig;
import com.facebook.buck.rust.RustLibraryDescription;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleDescription;
import com.facebook.buck.shell.ShBinaryDescription;
import com.facebook.buck.shell.ShTestDescription;
import com.facebook.buck.thrift.ThriftBuckConfig;
import com.facebook.buck.thrift.ThriftCxxEnhancer;
import com.facebook.buck.thrift.ThriftJavaEnhancer;
import com.facebook.buck.thrift.ThriftLibraryDescription;
import com.facebook.buck.thrift.ThriftPythonEnhancer;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.environment.Platform;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;

import java.io.IOException;
import java.net.Proxy;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.Executors;

import javax.annotation.Nullable;


public class KnownBuildRuleTypes {

  private static final Logger LOG = Logger.get(KnownBuildRuleTypes.class);
  private final ImmutableMap<BuildRuleType, Description<?>> descriptions;
  private final ImmutableMap<String, BuildRuleType> types;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;
  private final CxxPlatform defaultCxxPlatforms;

  private KnownBuildRuleTypes(
      Map<BuildRuleType, Description<?>> descriptions,
      Map<String, BuildRuleType> types,
      FlavorDomain<CxxPlatform> cxxPlatforms,
      CxxPlatform defaultCxxPlatforms) {
    this.descriptions = ImmutableMap.copyOf(descriptions);
    this.types = ImmutableMap.copyOf(types);
    this.cxxPlatforms = cxxPlatforms;
    this.defaultCxxPlatforms = defaultCxxPlatforms;
  }

  public BuildRuleType getBuildRuleType(String named) {
    BuildRuleType type = types.get(named);
    if (type == null) {
      throw new HumanReadableException("Unable to find build rule type: " + named);
    }
    return type;
  }

  public Description<?> getDescription(BuildRuleType buildRuleType) {
    Description<?> description = descriptions.get(buildRuleType);
    if (description == null) {
      throw new HumanReadableException(
          "Unable to find description for build rule type: " + buildRuleType);
    }
    return description;
  }

  public ImmutableSet<Description<?>> getAllDescriptions() {
    return ImmutableSet.copyOf(descriptions.values());
  }

  public FlavorDomain<CxxPlatform> getCxxPlatforms() {
    return cxxPlatforms;
  }

  public CxxPlatform getDefaultCxxPlatforms() {
    return defaultCxxPlatforms;
  }

  public static Builder builder() {
    return new Builder();
  }

  public static KnownBuildRuleTypes createInstance(
      BuckConfig config,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor,
      AndroidDirectoryResolver androidDirectoryResolver,
      PythonEnvironment pythonEnv) throws InterruptedException, IOException {
    return createBuilder(
        config,
        projectFilesystem,
        processExecutor,
        androidDirectoryResolver,
        pythonEnv).build();
  }

  private static void buildAppleCxxPlatforms(
      Supplier<Optional<Path>> appleDeveloperDirectorySupplier,
      ImmutableList<Path> extraToolchainPaths,
      ImmutableList<Path> extraPlatformPaths,
      BuckConfig buckConfig,
      AppleConfig appleConfig,
      ImmutableMap.Builder<Flavor, AppleCxxPlatform> platformFlavorsToAppleSdkPathsBuilder)
      throws IOException {
    Optional<Path> appleDeveloperDirectory = appleDeveloperDirectorySupplier.get();
    if (appleDeveloperDirectory.isPresent() &&
        !Files.isDirectory(appleDeveloperDirectory.get())) {
      LOG.error(
        "Developer directory is set to %s, but is not a directory",
        appleDeveloperDirectory.get());
      return;
    }

    ImmutableMap<String, AppleToolchain> toolchains =
        AppleToolchainDiscovery.discoverAppleToolchains(
            appleDeveloperDirectory,
            extraToolchainPaths);

    ImmutableMap<AppleSdk, AppleSdkPaths> sdkPaths = AppleSdkDiscovery.discoverAppleSdkPaths(
        appleDeveloperDirectory,
        extraPlatformPaths,
        toolchains);

    for (Map.Entry<AppleSdk, AppleSdkPaths> entry : sdkPaths.entrySet()) {
      AppleSdk sdk = entry.getKey();
      AppleSdkPaths appleSdkPaths = entry.getValue();
      String targetSdkVersion = appleConfig.getTargetSdkVersion(
          sdk.getApplePlatform()).or(sdk.getVersion());
      LOG.debug("SDK %s using default version %s", sdk, targetSdkVersion);
      for (String architecture : sdk.getArchitectures()) {
        AppleCxxPlatform appleCxxPlatform = AppleCxxPlatforms.build(
            sdk,
            targetSdkVersion,
            architecture,
            appleSdkPaths,
            buckConfig);
        platformFlavorsToAppleSdkPathsBuilder.put(
            appleCxxPlatform.getCxxPlatform().getFlavor(),
            appleCxxPlatform);
      }
    }
  }

  @VisibleForTesting
  static Builder createBuilder(
      BuckConfig config,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor,
      AndroidDirectoryResolver androidDirectoryResolver,
      PythonEnvironment pythonEnv) throws InterruptedException, IOException {

    Platform platform = Platform.detect();

    AndroidBuckConfig androidConfig = new AndroidBuckConfig(config, platform);
    Optional<String> ndkVersion = androidConfig.getNdkVersion();


    if (!ndkVersion.isPresent()) {
      ndkVersion = androidDirectoryResolver.getNdkVersion();
    }

    AppleConfig appleConfig = new AppleConfig(config);
    ImmutableMap.Builder<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatformsBuilder =
        ImmutableMap.builder();
    buildAppleCxxPlatforms(
        appleConfig.getAppleDeveloperDirectorySupplier(processExecutor),
        appleConfig.getExtraToolchainPaths(),
        appleConfig.getExtraPlatformPaths(),
        config,
        appleConfig,
        platformFlavorsToAppleCxxPlatformsBuilder);
    ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms =
        platformFlavorsToAppleCxxPlatformsBuilder.build();


    Optional<Path> ndkRoot = androidDirectoryResolver.findAndroidNdkDir();
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> ndkCxxPlatformsBuilder =
        ImmutableMap.builder();
    if (ndkRoot.isPresent()) {
      NdkCxxPlatforms.Compiler.Type compilerType =
          androidConfig.getNdkCompiler().or(NdkCxxPlatforms.DEFAULT_COMPILER_TYPE);
      String gccVersion = androidConfig.getNdkGccVersion().or(NdkCxxPlatforms.DEFAULT_GCC_VERSION);
      NdkCxxPlatforms.Compiler compiler =
          ImmutableNdkCxxPlatforms.Compiler.builder()
              .setType(compilerType)
              .setVersion(
                  compilerType == NdkCxxPlatforms.Compiler.Type.GCC ?
                      gccVersion :
                      androidConfig.getNdkClangVersion().or(NdkCxxPlatforms.DEFAULT_CLANG_VERSION))
              .setGccVersion(gccVersion)
              .build();
      ndkCxxPlatformsBuilder.putAll(
          NdkCxxPlatforms.getPlatforms(
              new ProjectFilesystem(ndkRoot.get()),
              compiler,
              androidConfig.getNdkCxxRuntime().or(NdkCxxPlatforms.DEFAULT_CXX_RUNTIME),
              androidConfig.getNdkAppPlatform().or(NdkCxxPlatforms.DEFAULT_TARGET_APP_PLATFORM),
              platform));
    }
    ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> ndkCxxPlatforms =
        ndkCxxPlatformsBuilder.build();


    CxxBuckConfig cxxBuckConfig = new CxxBuckConfig(config);
    ImmutableMap.Builder<Flavor, CxxPlatform> cxxPlatformsBuilder = ImmutableMap.builder();



    for (NdkCxxPlatform ndkCxxPlatform : ndkCxxPlatforms.values()) {
      cxxPlatformsBuilder.put(
          ndkCxxPlatform.getCxxPlatform().getFlavor(),
          ndkCxxPlatform.getCxxPlatform());
    }

    for (Map.Entry<Flavor, AppleCxxPlatform> entry :
        platformFlavorsToAppleCxxPlatforms.entrySet()) {
      cxxPlatformsBuilder.put(entry.getKey(), entry.getValue().getCxxPlatform());
    }


    CxxPlatform systemDefaultCxxPlatform = DefaultCxxPlatforms.build(platform, cxxBuckConfig);
    cxxPlatformsBuilder.put(systemDefaultCxxPlatform.getFlavor(), systemDefaultCxxPlatform);
    ImmutableMap<Flavor, CxxPlatform> cxxPlatformsMap = cxxPlatformsBuilder.build();


    CxxPlatform defaultCxxPlatform = CxxPlatforms.getConfigDefaultCxxPlatform(
        cxxBuckConfig,
        cxxPlatformsMap,
        systemDefaultCxxPlatform);



    ImmutableSet<Flavor> cxxFlavors = CxxBuckConfig.getCxxFlavors(config);
    for (Flavor flavor: cxxFlavors) {
      CxxBuckConfig flavoredCxxBuckConfig =  new CxxBuckConfig(config, flavor);
      CxxPlatform defaultPlatformForFlavor = CxxPlatforms.getConfigDefaultCxxPlatform(
          flavoredCxxBuckConfig,
          cxxPlatformsMap,
          systemDefaultCxxPlatform);
      cxxPlatformsBuilder.put(flavor, CxxPlatforms.copyPlatformWithFlavorAndConfig(
          defaultPlatformForFlavor,
          flavoredCxxBuckConfig,
          flavor));
    }

    cxxPlatformsMap = cxxPlatformsBuilder.build();



    FlavorDomain<CxxPlatform> cxxPlatforms = new FlavorDomain<>(
        "C/C++ platform",
        cxxPlatformsMap);

    DBuckConfig dBuckConfig = new DBuckConfig(config);

    ReactNativeBuckConfig reactNativeBuckConfig = new ReactNativeBuckConfig(config);

    RustBuckConfig rustBuckConfig = new RustBuckConfig(config);

    ProGuardConfig proGuardConfig = new ProGuardConfig(config);

    PythonBuckConfig pyConfig = new PythonBuckConfig(config, new ExecutableFinder());


    Path pythonPathToPythonTestMain = pyConfig.getPathToTestMain();


    Optional<Long> testRuleTimeoutMs = config.getLong("test", "rule_timeout");


    Optional<String> defaultMavenRepo = config.getValue("download", "maven_repo");
    boolean downloadAtRuntimeOk = config.getBooleanValue("download", "in_build", false);
    Downloader downloader;
    if (downloadAtRuntimeOk) {
      downloader = new HttpDownloader(Optional.<Proxy>absent(), defaultMavenRepo);
    } else {
      downloader = new ExplodingDownloader();
    }

    Builder builder = builder();

    JavaBuckConfig javaConfig = new JavaBuckConfig(config);
    JavacOptions defaultJavacOptions = javaConfig.getDefaultJavacOptions();
    JavacOptions androidBinaryOptions = JavacOptions.builder(defaultJavacOptions)
        .build();

    CxxBinaryDescription cxxBinaryDescription =
        new CxxBinaryDescription(
            cxxBuckConfig,
            defaultCxxPlatform,
            cxxPlatforms,
            cxxBuckConfig.getPreprocessMode());

    CxxLibraryDescription cxxLibraryDescription = new CxxLibraryDescription(
        cxxBuckConfig,
        cxxPlatforms,
        cxxBuckConfig.getPreprocessMode());

    AppleLibraryDescription appleLibraryDescription =
        new AppleLibraryDescription(
            cxxLibraryDescription,
            cxxPlatforms);
    builder.register(appleLibraryDescription);

    AppleBinaryDescription appleBinaryDescription =
        new AppleBinaryDescription(cxxBinaryDescription);
    builder.register(appleBinaryDescription);


    ListeningExecutorService dxExecutorService =
        MoreExecutors.listeningDecorator(
            Executors.newFixedThreadPool(
                SmartDexingStep.determineOptimalThreadCount(),
                new CommandThreadFactory("SmartDexing")));

    builder.register(new AndroidAarDescription(new AndroidManifestDescription(), ndkCxxPlatforms));
    builder.register(
        new AndroidBinaryDescription(
            androidBinaryOptions,
            proGuardConfig,
            ndkCxxPlatforms,
            dxExecutorService));
    builder.register(new AndroidBuildConfigDescription(androidBinaryOptions));
    builder.register(new AndroidInstrumentationApkDescription(
            proGuardConfig,
            androidBinaryOptions,
            ndkCxxPlatforms,
            dxExecutorService));
    builder.register(new AndroidInstrumentationTestDescription(testRuleTimeoutMs));
    builder.register(new AndroidLibraryDescription(androidBinaryOptions));
    builder.register(new AndroidManifestDescription());
    builder.register(new AndroidPrebuiltAarDescription(androidBinaryOptions));
    builder.register(new AndroidReactNativeLibraryDescription(reactNativeBuckConfig));
    builder.register(new AndroidResourceDescription());
    builder.register(new ApkGenruleDescription());
    builder.register(new AppleAssetCatalogDescription());
    AppleBundleDescription appleBundleDescription =
        new AppleBundleDescription(
            appleBinaryDescription,
            appleLibraryDescription,
            cxxPlatforms,
            platformFlavorsToAppleCxxPlatforms,
            defaultCxxPlatform);
    builder.register(appleBundleDescription);
    builder.register(new AppleResourceDescription());
    builder.register(
        new AppleTestDescription(
            appleConfig,
            appleBundleDescription,
            appleLibraryDescription,
            cxxPlatforms,
            platformFlavorsToAppleCxxPlatforms,
            defaultCxxPlatform));
    builder.register(new CoreDataModelDescription());
    builder.register(cxxBinaryDescription);
    builder.register(cxxLibraryDescription);
    builder.register(new CxxPythonExtensionDescription(cxxBuckConfig, cxxPlatforms));
    builder.register(new CxxTestDescription(cxxBuckConfig, defaultCxxPlatform, cxxPlatforms));
    builder.register(new DBinaryDescription(dBuckConfig));
    builder.register(new DLibraryDescription(dBuckConfig));
    builder.register(new DTestDescription(dBuckConfig));
    builder.register(new ExportFileDescription());
    builder.register(new GenruleDescription());
    builder.register(new GenAidlDescription());
    builder.register(new GwtBinaryDescription());
    builder.register(new IosReactNativeLibraryDescription(reactNativeBuckConfig));
    builder.register(new JavaBinaryDescription(defaultJavacOptions, defaultCxxPlatform));
    builder.register(new JavaLibraryDescription(defaultJavacOptions));
    builder.register(
        new JavaTestDescription(
            defaultJavacOptions,
            testRuleTimeoutMs,
            defaultCxxPlatform));
    builder.register(new KeystoreDescription());
    builder.register(new NdkLibraryDescription(ndkVersion, ndkCxxPlatforms));
    OCamlBuckConfig ocamlBuckConfig = new OCamlBuckConfig(platform, config);
    builder.register(new OCamlBinaryDescription(ocamlBuckConfig));
    builder.register(new OCamlLibraryDescription(ocamlBuckConfig));
    builder.register(new PrebuiltCxxLibraryDescription(cxxPlatforms));
    builder.register(new PrebuiltJarDescription());
    builder.register(new PrebuiltNativeLibraryDescription());
    builder.register(new PrebuiltOCamlLibraryDescription());
    builder.register(new PrebuiltPythonLibraryDescription());
    builder.register(new ProjectConfigDescription());
    builder.register(
        new PythonBinaryDescription(
            pyConfig.getPathToPex(),
            pyConfig.getPathToPexExecuter(),
            pyConfig.getPexExtension(),
            pythonEnv,
            defaultCxxPlatform,
            cxxPlatforms));
    builder.register(new PythonLibraryDescription());
    builder.register(
        new PythonTestDescription(
            projectFilesystem,
            pyConfig.getPathToPex(),
            pyConfig.getPathToPexExecuter(),
            pyConfig.getPexExtension(),
            pythonPathToPythonTestMain,
            pythonEnv,
            defaultCxxPlatform,
            cxxPlatforms));
    builder.register(new RemoteFileDescription(downloader));
    builder.register(new RobolectricTestDescription(
            androidBinaryOptions,
            testRuleTimeoutMs,
            defaultCxxPlatform));
    builder.register(new RustBinaryDescription(rustBuckConfig));
    builder.register(new RustLibraryDescription(rustBuckConfig));
    builder.register(new ShBinaryDescription());
    builder.register(new ShTestDescription());
    ThriftBuckConfig thriftBuckConfig = new ThriftBuckConfig(config);
    builder.register(
        new ThriftLibraryDescription(
            thriftBuckConfig,
            ImmutableList.of(
                new ThriftJavaEnhancer(thriftBuckConfig, defaultJavacOptions),
                new ThriftCxxEnhancer(
                    thriftBuckConfig,
                    cxxLibraryDescription,
 false),
                new ThriftCxxEnhancer(
                    thriftBuckConfig,
                    cxxLibraryDescription,
 true),
                new ThriftPythonEnhancer(thriftBuckConfig, ThriftPythonEnhancer.Type.NORMAL),
                new ThriftPythonEnhancer(thriftBuckConfig, ThriftPythonEnhancer.Type.TWISTED))));
    builder.register(new XcodePostbuildScriptDescription());
    builder.register(new XcodePrebuildScriptDescription());
    builder.register(new XcodeWorkspaceConfigDescription());

    builder.setCxxPlatforms(cxxPlatforms);
    builder.setDefaultCxxPlatform(defaultCxxPlatform);

    return builder;
  }

  public static class Builder {
    private final Map<BuildRuleType, Description<?>> descriptions;
    private final Map<String, BuildRuleType> types;

    @Nullable
    private FlavorDomain<CxxPlatform> cxxPlatforms;
    @Nullable
    private CxxPlatform defaultCxxPlatform;

    protected Builder() {
      this.descriptions = Maps.newConcurrentMap();
      this.types = Maps.newConcurrentMap();
    }

    public Builder register(Description<?> description) {
      BuildRuleType type = description.getBuildRuleType();
      types.put(type.getName(), type);
      descriptions.put(type, description);
      return this;
    }

    public Builder setCxxPlatforms(FlavorDomain<CxxPlatform> cxxPlatforms) {
      this.cxxPlatforms = cxxPlatforms;
      return this;
    }

    public Builder setDefaultCxxPlatform(CxxPlatform defaultCxxPlatform) {
      this.defaultCxxPlatform = defaultCxxPlatform;
      return this;
    }

    public KnownBuildRuleTypes build() {
      return new KnownBuildRuleTypes(
          descriptions,
          types,
          Preconditions.checkNotNull(cxxPlatforms),
          Preconditions.checkNotNull(defaultCxxPlatform));
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.AdbHelper;
import com.facebook.buck.apple.AppleBundle;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleInfoPlistParsing;
import com.facebook.buck.apple.simulator.AppleCoreSimulatorServiceController;
import com.facebook.buck.apple.simulator.AppleSimulator;
import com.facebook.buck.apple.simulator.AppleSimulatorController;
import com.facebook.buck.apple.simulator.AppleSimulatorDiscovery;
import com.facebook.buck.cli.UninstallCommand.UninstallOptions;
import com.facebook.buck.command.Build;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.AdbOptions;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TargetDeviceOptions;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.ProcessExecutorParams;
import com.facebook.buck.util.UnixUserIdFetcher;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.Nullable;


public class InstallCommand extends BuildCommand {

  private static final Logger LOG = Logger.get(InstallCommand.class);
  private static final long APPLE_SIMULATOR_WAIT_MILLIS = 20000;
  private static final ImmutableList<String> APPLE_SIMULATOR_APPS = ImmutableList.of(
      "Simulator.app",
      "iOS Simulator.app");
  private static final String DEFAULT_APPLE_SIMULATOR_NAME = "iPhone 5s";
  private static final InstallResult FAILURE = InstallResult.builder().setExitCode(1).build();

  @VisibleForTesting static final String RUN_LONG_ARG = "--run";
  @VisibleForTesting static final String RUN_SHORT_ARG = "-r";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_LONG_ARG = "--wait-for-debugger";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_SHORT_ARG = "-w";
  @VisibleForTesting static final String INSTALL_VIA_SD_LONG_ARG = "--via-sd";
  @VisibleForTesting static final String INSTALL_VIA_SD_SHORT_ARG = "-S";
  @VisibleForTesting static final String ACTIVITY_LONG_ARG = "--activity";
  @VisibleForTesting static final String ACTIVITY_SHORT_ARG = "-a";
  @VisibleForTesting static final String UNINSTALL_LONG_ARG = "--uninstall";
  @VisibleForTesting static final String UNINSTALL_SHORT_ARG = "-u";

  @Option(
      name = UNINSTALL_LONG_ARG,
      aliases = { UNINSTALL_SHORT_ARG },
      usage = "Uninstall the existing version before installing.")
  private boolean uninstallFirst = false;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbCommandLineOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceCommandLineOptions deviceOptions;

  @Option(
      name = "--",
      usage = "Arguments passed when running with -r. Only valid for Apple targets.",
      handler = ConsumeAllOptionsHandler.class,
      depends = "-r")
  private List<String> runArgs = Lists.newArrayList();

  @Option(
      name = RUN_LONG_ARG,
      aliases = { RUN_SHORT_ARG },
      usage = "Run an activity (the default activity for package unless -a is specified).")
  private boolean run = false;

  @Option(
      name = WAIT_FOR_DEBUGGER_LONG_ARG,
      aliases = { WAIT_FOR_DEBUGGER_SHORT_ARG },
      usage = "Have the launched process wait for the debugger")
  private boolean waitForDebugger = false;

  @Option(
      name = INSTALL_VIA_SD_LONG_ARG,
      aliases = { INSTALL_VIA_SD_SHORT_ARG },
      usage = "Copy package to external storage (SD) instead of /data/local/tmp before installing.")
  private boolean installViaSd = false;

  @Option(
      name = ACTIVITY_LONG_ARG,
      aliases = { ACTIVITY_SHORT_ARG },
      metaVar = "<pkg/activity>",
      usage = "Activity to launch e.g. com.facebook.katana/.LoginActivity. Implies -r.")
  @Nullable
  private String activity = null;

  public AdbOptions adbOptions() {
    return adbOptions.getAdbOptions();
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions.getTargetDeviceOptions();
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public boolean shouldUninstallFirst() {
    return uninstallFirst;
  }

  public boolean shouldStartActivity() {
    return (activity != null) || run;
  }

  public boolean shouldInstallViaSd() {
    return installViaSd;
  }

  @Nullable
  public String getActivityToStart() {
    return activity;
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {

    if (getArguments().size() != 1) {
      params.getConsole().getStdErr().println(
          "Must specify exactly one rule.");
      return 1;
    }


    int exitCode = super.runWithoutHelp(params);
    if (exitCode != 0) {
      return exitCode;
    }

    Build build = super.getBuild();
    ActionGraph graph = build.getActionGraph();
    BuildRule buildRule = Preconditions.checkNotNull(
        graph.findBuildRuleByTarget(getBuildTargets().get(0)));

    if (buildRule instanceof InstallableApk) {
      ExecutionContext.Builder builder = ExecutionContext.builder()
          .setExecutionContext(build.getExecutionContext())
          .setAdbOptions(Optional.<AdbOptions>of(adbOptions()))
          .setTargetDeviceOptions(Optional.<TargetDeviceOptions>of(targetDeviceOptions()));
      return installApk(
          params,
          (InstallableApk) buildRule,
          builder.build());
    } else if (buildRule instanceof AppleBundle) {
      AppleBundle appleBundle = (AppleBundle) buildRule;
      InstallEvent.Started started = InstallEvent.started(appleBundle.getBuildTarget());
      params.getBuckEventBus().post(started);
      InstallResult installResult = installAppleBundle(
          params,
          appleBundle,
          build.getExecutionContext().getProjectFilesystem(),
          build.getExecutionContext().getProcessExecutor());
      params.getBuckEventBus().post(InstallEvent.finished(
          started,
          installResult.getExitCode() == 0,
          installResult.getLaunchedPid()));
      return installResult.getExitCode();
    } else {
      params.getConsole().printBuildFailure(
          String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() or " +
                  "apple_bundle() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
  }

  private int installApk(
      CommandRunnerParams params,
      InstallableApk installableApk,
      ExecutionContext executionContext) throws IOException, InterruptedException {
    final AdbHelper adbHelper = AdbHelper.get(
        executionContext,
        params.getBuckConfig().getRestartAdbOnFailure());


    if (shouldUninstallFirst()) {
      String packageName = AdbHelper.tryToExtractPackageNameFromManifest(
          installableApk,
          executionContext);
      adbHelper.uninstallApp(packageName, uninstallOptions().shouldKeepUserData());

    }

    if (!adbHelper.installApk(installableApk, shouldInstallViaSd(), false)) {
      return 1;
    }



    if (shouldStartActivity()) {
      int exitCode = adbHelper.startActivity(installableApk, getActivityToStart());
      if (exitCode != 0) {
        return exitCode;
      }
    }

    return 0;
  }

  private InstallResult installAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor) throws IOException, InterruptedException {


    AppleConfig appleConfig = new AppleConfig(params.getBuckConfig());
    Optional<Path> xcodeDeveloperPath = appleConfig.getAppleDeveloperDirectorySupplier(
        processExecutor).get();
    if (!xcodeDeveloperPath.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (Xcode not found)", appleBundle.getFullyQualifiedName()));
      return FAILURE;
    }

    UnixUserIdFetcher userIdFetcher = new UnixUserIdFetcher();
    AppleCoreSimulatorServiceController appleCoreSimulatorServiceController =
        new AppleCoreSimulatorServiceController(processExecutor);

    Optional<Path> coreSimulatorServicePath =
        appleCoreSimulatorServiceController.getCoreSimulatorServicePath(userIdFetcher);

    boolean shouldWaitForSimulatorsToShutdown = false;

    if (!coreSimulatorServicePath.isPresent() ||
        !coreSimulatorServicePath.get().toRealPath().startsWith(
            xcodeDeveloperPath.get().toRealPath())) {
      LOG.warn(
          "Core simulator service path %s does not match developer directory %s, " +
          "killing all simulators.",
          coreSimulatorServicePath,
          xcodeDeveloperPath.get());
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return FAILURE;
      }

      shouldWaitForSimulatorsToShutdown = true;
    }

    Path simctlPath = xcodeDeveloperPath.get().resolve("usr/bin/simctl");
    Optional<AppleSimulator> appleSimulator = getAppleSimulatorForBundle(
        appleBundle,
        processExecutor,
        simctlPath);

    if (!appleSimulator.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (no appropriate simulator found)",
              appleBundle.getFullyQualifiedName()));
      return FAILURE;
    }

    Path iosSimulatorPath = null;
    Path xcodeApplicationsPath = xcodeDeveloperPath.get().resolve("Applications");
    for (String simulatorApp : APPLE_SIMULATOR_APPS) {
      Path resolvedSimulatorPath = xcodeApplicationsPath.resolve(simulatorApp);
      if (projectFilesystem.isDirectory(resolvedSimulatorPath)) {
        iosSimulatorPath = resolvedSimulatorPath;
        break;
      }
    }

    if (iosSimulatorPath == null) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not find simulator under %s, checked %s)",
              appleBundle.getFullyQualifiedName(),
              xcodeApplicationsPath,
              APPLE_SIMULATOR_APPS));
      return FAILURE;
    }

    AppleSimulatorController appleSimulatorController = new AppleSimulatorController(
        processExecutor,
        simctlPath,
        iosSimulatorPath);

    if (!appleSimulatorController.canStartSimulator(appleSimulator.get().getUdid())) {
      LOG.warn("Cannot start simulator %s, killing simulators and trying again.");
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return FAILURE;
      }

      shouldWaitForSimulatorsToShutdown = true;


      appleSimulator = getAppleSimulatorForBundle(appleBundle, processExecutor, simctlPath);
      if (!appleSimulator.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (no appropriate simulator found)",
                appleBundle.getFullyQualifiedName()));
        return FAILURE;
      }
    }

    long remainingMillis = APPLE_SIMULATOR_WAIT_MILLIS;
    if (shouldWaitForSimulatorsToShutdown) {
      Optional<Long> shutdownMillis = appleSimulatorController.waitForSimulatorsToShutdown(
          remainingMillis);
      if (!shutdownMillis.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (simulators did not shut down within %d ms).",
                appleBundle.getFullyQualifiedName(),
                APPLE_SIMULATOR_WAIT_MILLIS));
        return FAILURE;
      }

      LOG.debug("Simulators shut down in %d millis.", shutdownMillis.get());
      remainingMillis -= shutdownMillis.get();
    }

    LOG.debug("Starting up simulator %s", appleSimulator.get());

    Optional<Long> startMillis = appleSimulatorController.startSimulator(
        appleSimulator.get().getUdid(),
        remainingMillis);

    if (!startMillis.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not start simulator %s within %d ms)",
              appleBundle.getFullyQualifiedName(),
              appleSimulator.get().getName(),
              APPLE_SIMULATOR_WAIT_MILLIS));
      return FAILURE;
    }

    LOG.debug(
        "Simulator started in %d ms. Installing Apple bundle %s in simulator %s",
        startMillis.get(),
        appleBundle,
        appleSimulator.get());

    if (!appleSimulatorController.installBundleInSimulator(
            appleSimulator.get().getUdid(),
            projectFilesystem.resolve(Preconditions.checkNotNull(appleBundle.getPathToOutput())))) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not install bundle %s in simulator %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getPathToOutput(),
              appleSimulator.get().getName()));
      return FAILURE;
    }

    if (ReactNativeFlavors.skipBundling(appleBundle.getBuildTarget())) {
      ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(params.getBuckConfig());
      if (buckConfig.getServer().isPresent()) {
        int exitCode = launchReactNativeServer(
            processExecutor,
            projectFilesystem.resolve(buckConfig.getServer().get()),
            params.getBuckEventBus());
        if (exitCode != 0) {
          return InstallResult.builder().setExitCode(exitCode).build();
        }
      }
    }

    if (run) {
      return launchAppleBundle(
          params,
          appleBundle,
          appleSimulatorController,
          projectFilesystem,
          appleSimulator.get());
    } else {
      params.getBuckEventBus().post(
          ConsoleEvent.info(
              params.getConsole().getAnsi().asHighlightedSuccessText(
                  "Successfully installed %s. (Use `buck install -r %s` to run.)"),
              getArguments().get(0),
              getArguments().get(0)));
      return InstallResult.builder().setExitCode(0).build();
    }
  }

  private InstallResult launchAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      AppleSimulatorController appleSimulatorController,
      ProjectFilesystem projectFilesystem,
      AppleSimulator appleSimulator) throws IOException, InterruptedException {

    LOG.debug("Launching Apple bundle %s in simulator %s", appleBundle, appleSimulator);

    Optional<String> appleBundleId;
    try (InputStream bundlePlistStream =
             projectFilesystem.getInputStreamForRelativePath(appleBundle.getInfoPlistPath())){
        appleBundleId = AppleInfoPlistParsing.getBundleIdFromPlistStream(bundlePlistStream);
    }
    if (!appleBundleId.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not get bundle ID from %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getInfoPlistPath()));
      return FAILURE;
    }

    Optional<Long> launchedPid = appleSimulatorController.launchInstalledBundleInSimulator(
        appleSimulator.getUdid(),
        appleBundleId.get(),
        waitForDebugger ? AppleSimulatorController.LaunchBehavior.WAIT_FOR_DEBUGGER :
            AppleSimulatorController.LaunchBehavior.DO_NOT_WAIT_FOR_DEBUGGER,
        runArgs);
    if (!launchedPid.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot launch %s (failed to launch bundle ID %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundleId.get()));
      return FAILURE;
    }

    params.getBuckEventBus().post(
        ConsoleEvent.info(
            params.getConsole().getAnsi().asHighlightedSuccessText(
                "Successfully launched %s%s. To debug, run: lldb -p %d"),
            getArguments().get(0),
            waitForDebugger ? " (waiting for debugger)" : "",
            launchedPid.get()));

    return InstallResult.builder().setExitCode(0).setLaunchedPid(launchedPid.get()).build();
  }

  private Optional<AppleSimulator> getAppleSimulatorForBundle(
      AppleBundle appleBundle,
      ProcessExecutor processExecutor,
      Path simctlPath) throws IOException, InterruptedException {
    LOG.debug("Choosing simulator for %s", appleBundle);

    Optional<AppleSimulator> simulatorByUdid = Optional.absent();
    Optional<AppleSimulator> simulatorByName = Optional.absent();
    Optional<AppleSimulator> defaultSimulator = Optional.absent();

    boolean wantUdid = deviceOptions.hasSerialNumber();
    boolean wantName = deviceOptions.getSimulatorName().isPresent();

    for (AppleSimulator simulator : AppleSimulatorDiscovery.discoverAppleSimulators(
             processExecutor,
             simctlPath)) {
      if (wantUdid &&
          deviceOptions.getSerialNumber().toLowerCase(Locale.US).equals(
              simulator.getUdid().toLowerCase(Locale.US))) {
        LOG.debug("Got UDID match (%s): %s", deviceOptions.getSerialNumber(), simulator);
        simulatorByUdid = Optional.of(simulator);

        break;
      } else if (wantName &&
                 deviceOptions.getSimulatorName().get().toLowerCase(Locale.US).equals(
                     simulator.getName().toLowerCase(Locale.US))) {
        LOG.debug("Got name match (%s): %s", simulator.getName(), simulator);
        simulatorByName = Optional.of(simulator);


      } else if (simulator.getName().equals(DEFAULT_APPLE_SIMULATOR_NAME)) {
        LOG.debug("Got default match (%s): %s", DEFAULT_APPLE_SIMULATOR_NAME, simulator);
        defaultSimulator = Optional.of(simulator);
      }
    }

    if (wantUdid) {
      if (simulatorByUdid.isPresent()) {
        return simulatorByUdid;
      } else {
        LOG.warn(
            "Asked to find simulator with UDID %s, but couldn't find one.",
            deviceOptions.getSerialNumber());
        return Optional.<AppleSimulator>absent();
      }
    } else if (wantName) {
      if (simulatorByName.isPresent()) {
        return simulatorByName;
      } else {
        LOG.warn(
            "Asked to find simulator with name %s, but couldn't find one.",
            deviceOptions.getSimulatorName().get());
        return Optional.<AppleSimulator>absent();
      }
    } else {
      return defaultSimulator;
    }
  }

  private int launchReactNativeServer(
      ProcessExecutor processExecutor,
      Path reactNativeServerInitScript,
      BuckEventBus eventBus) throws IOException, InterruptedException {
    ProcessExecutorParams processExecutorParams =
        ProcessExecutorParams.builder()
            .setCommand(ImmutableList.of(reactNativeServerInitScript.toString()))
            .build();
    Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
    ProcessExecutor.Result result = processExecutor.launchAndExecute(
        processExecutorParams,
        options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
    LOG.debug("React Native server: %s", result.getStdout());
    if (result.getExitCode() != 0) {
      eventBus.post(ConsoleEvent.severe(
              "Error starting the RN server: %s", result.getStderr().or("")));
    }
    return result.getExitCode();
  }

  @Override
  public String getShortDescription() {
    return "builds and installs an application";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.emptyString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import com.facebook.buck.util.HumanReadableException;
import com.google.common.collect.ImmutableMap;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;


public class InfoPlistSubstitutionTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void emptyStringReplacementIsEmpty() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "",
            ImmutableMap.<String, String>of()),
        is(emptyString()));
  }

  @Test
  public void emptyMapLeavesStringAsIs() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello world"));
  }

  @Test
  public void curlyBracesAreSubstituted() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO} world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void parensAreSubstituted() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO) world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void unknownModifiersAreIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO:bar) world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void multipleMatchesAreReplaced() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO) $(BAR) world",
            ImmutableMap.of(
                "FOO", "cruel",
                "BAR", "mean")),
        equalTo("Hello cruel mean world"));
  }

  @Test
  public void unrecognizedVariableThrows() {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage("Unrecognized plist variable: ${XYZZY:blurgh}");
    InfoPlistSubstitution.replaceVariablesInString(
        "Hello ${XYZZY:blurgh} world",
        ImmutableMap.<String, String>of());
  }

  @Test
  public void recursiveVariableThrows() {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage("Recursive plist variable: FOO -> BAR -> BAZ -> FOO");
    InfoPlistSubstitution.replaceVariablesInString(
        "Hello ${FOO}",
        ImmutableMap.<String, String>of(
            "FOO", "${BAR}",
            "BAR", "${BAZ}",
            "BAZ", "${FOO}"));
  }

  @Test
  public void mismatchedParenIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO} world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello $(FOO} world"));
  }

  @Test
  public void mismatchedBraceIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO) world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello ${FOO) world"));
  }

  @Test
  public void replacementWithMatcherAppendReplacementSpecialChars() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO} world",
            ImmutableMap.of(
                "FOO", "${BAZ}",
                "BAZ", "$BAR")),
        equalTo("Hello $BAR world"));
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxBinaryDescription;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxLibraryDescription;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.DefaultCxxPlatforms;
import com.facebook.buck.io.FakeExecutableFinder;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.util.environment.Platform;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Paths;


public class FakeAppleRuleDescriptions {

  private FakeAppleRuleDescriptions() { }

  private static final AppleSdkPaths DEFAULT_IPHONEOS_SDK_PATHS =
      AppleSdkPaths.builder()
          .setDeveloperPath(Paths.get("."))
          .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
          .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
          .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
          .build();

  private static final AppleSdk DEFAULT_IPHONEOS_SDK =
      AppleSdk.builder()
          .setApplePlatform(
              ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
          .setName("iphoneos")
          .setVersion("8.0")
          .setToolchains(ImmutableList.<AppleToolchain>of())
          .build();

  private static final AppleCxxPlatform DEFAULT_IPHONEOS_PLATFORM =
      AppleCxxPlatforms.buildWithExecutableChecker(
          DEFAULT_IPHONEOS_SDK,
          "8.0",
          "i386",
          DEFAULT_IPHONEOS_SDK_PATHS,
          new FakeBuckConfig(),
          new FakeExecutableFinder(
              ImmutableSet.of(
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"),
                  Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"),
                  Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"),
                  Paths.get("usr/bin/actool"),
                  Paths.get("usr/bin/ibtool"),
                  Paths.get("Tools/otest"),
                  Paths.get("usr/bin/xctest"))));

  private static final BuckConfig DEFAULT_BUCK_CONFIG = new FakeBuckConfig();

  private static final CxxPlatform DEFAULT_PLATFORM = DefaultCxxPlatforms.build(
      Platform.MACOS,
      new CxxBuckConfig(DEFAULT_BUCK_CONFIG));

  private static final FlavorDomain<CxxPlatform> DEFAULT_IPHONEOS_FLAVOR_DOMAIN =
      new FlavorDomain<>(
          "Fake iPhone C/C++ Platform",
          ImmutableMap.of(
              DEFAULT_PLATFORM.getFlavor(),
              DEFAULT_PLATFORM,
              DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform().getFlavor(),
              DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform()));

  private static final ImmutableMap<Flavor, AppleCxxPlatform>
    DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS =
      ImmutableMap.of(
          DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform().getFlavor(),
          DEFAULT_IPHONEOS_PLATFORM);


  public static final AppleLibraryDescription LIBRARY_DESCRIPTION =
    new AppleLibraryDescription(
        new CxxLibraryDescription(
            new CxxBuckConfig(DEFAULT_BUCK_CONFIG),
            DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
            CxxPreprocessMode.COMBINED),
        DEFAULT_IPHONEOS_FLAVOR_DOMAIN);


  public static final AppleBinaryDescription BINARY_DESCRIPTION =
    new AppleBinaryDescription(
        new CxxBinaryDescription(
            new CxxBuckConfig(DEFAULT_BUCK_CONFIG),
            DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform(),
            DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
            CxxPreprocessMode.COMBINED));


  public static final AppleBundleDescription BUNDLE_DESCRIPTION =
      new AppleBundleDescription(
          BINARY_DESCRIPTION,
          LIBRARY_DESCRIPTION,
          DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
          DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS,
          DEFAULT_PLATFORM);


  public static final AppleTestDescription TEST_DESCRIPTION =
      new AppleTestDescription(
          new FakeAppleConfig(),
          BUNDLE_DESCRIPTION,
          LIBRARY_DESCRIPTION,
          DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
          DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS,
          DEFAULT_PLATFORM);
}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.environment.Platform;
import com.facebook.buck.util.HumanReadableException;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class AppleBundleIntegrationTest {

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void simpleApplicationBundle() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));
  }

  @Test
  public void bundleHasOutputPath() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace
        .runBuckCommand("targets", "--show-output", "//:DemoApp");
    result.assertSuccess();
    assertEquals("//:DemoApp buck-out/gen/DemoApp/DemoApp.app", result.getStdout().trim());
  }

  @Test
  public void bundleBinaryHasDsymBundle() throws IOException, InterruptedException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    Path bundlePath = tmp.getRootPath()
        .resolve(BuckConstant.GEN_DIR)
        .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app");
    Path dwarfPath = bundlePath.resolve("DemoApp.dSYM/Contents/Resources/DWARF/DemoApp");
    Path binaryPath = bundlePath.resolve("DemoApp");
    assertTrue(Files.exists(dwarfPath));
    String dwarfdumpMainStdout =
        workspace.runCommand("dwarfdump", "-n", "main", dwarfPath.toString()).getStdout().or("");
    assertTrue(dwarfdumpMainStdout.contains("AT_name"));
    assertTrue(dwarfdumpMainStdout.contains("AT_decl_file"));
    assertTrue(dwarfdumpMainStdout.contains("AT_decl_line"));

    ProcessExecutor.Result result = workspace.runCommand(
        "dsymutil",
        "-o",
        binaryPath.toString() + ".test.dSYM",
        binaryPath.toString());
    assertThat(result.getStdout().isPresent(), is(true));
    assertThat(result.getStdout().get(), containsString("warning: no debug symbols in executable"));
  }

  @Test
  public void appBundleWithResources() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_resources",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();
  }

  @Test
  public void appBundleVariantDirectoryMustEndInLproj() throws IOException {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "Variant files have to be in a directory with name ending in '.lproj', " +
            "but 'cc/Localizable.strings' is not.");

    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_invalid_variant",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertFailure();
  }

  @Test
  public void defaultPlatformInBuckConfig() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "default_platform_in_buckconfig_app_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/DemoApp")));
  }

  @Test
  public void defaultPlatformInBuckConfigWithFlavorSpecified() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "default_platform_in_buckconfig_flavored_app_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));
  }

  @Test
  public void appleAssetCatalogsAreIncludedInBundle() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "apple_asset_catalogs_are_included_in_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp").assertSuccess();

    System.err.println(tmp.getRootPath());
    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets.car")));
    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets1.bundle/Image1.png")));
    assertFalse(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets2.bundle/Image2.png")));
    assertFalse(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets3.bundle/Image3.png")));

    workspace.verify();
  }

  @Test
  public void infoPlistSubstitutionsAreApplied() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "application_bundle_with_substitutions",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));
  }

  @Test
  public void infoPlistWithUnrecognizedVariableFails() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "application_bundle_with_invalid_substitutions",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertFailure();
  }

  @Test
  public void xibIsCompiledToNib() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_xib",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/AppViewController.nib")));
  }

}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSDate;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;

import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.base.Charsets;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.Files;

import org.immutables.value.Value;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;



@Value.Immutable
@BuckStyleImmutable
abstract class AbstractProvisioningProfileMetadata implements RuleKeyAppendable {
  private static final Pattern BUNDLE_ID_PATTERN = Pattern.compile("^([A-Z0-9]{10,10})\\.(.+)$");
  private static final Pattern PLIST_XML_PATTERN = Pattern.compile("((?s)<\\?xml.*</plist>)");


  public abstract Pair<String, String> getAppID();

  public abstract Date getExpirationDate();

  public abstract String getUUID();

  public abstract Optional<Path> getProfilePath();


  public abstract ImmutableMap<String, NSObject> getEntitlements();


  public static Pair<String, String> splitAppID(String appID) throws Exception {
    Matcher matcher = BUNDLE_ID_PATTERN.matcher(appID);
    if (matcher.find()) {
      String prefix = matcher.group(1);
      String bundleID = matcher.group(2);

      return new Pair<>(prefix, bundleID);
    } else {
      throw new IllegalArgumentException("Malformed app ID: " + appID);
    }
  }

  public static ProvisioningProfileMetadata fromProvisioningProfilePath(Path profilePath)
      throws IOException {
    String fileAsString = Files.toString(profilePath.toFile(), Charsets.UTF_8);
    Matcher matcher = PLIST_XML_PATTERN.matcher(fileAsString);
    if (matcher.find()) {
      fileAsString = matcher.group();
    } else {
      throw new IllegalArgumentException(
          "Malformed .mobileprovision file (could not find embedded plist)");
    }

    try {
      NSDictionary plist = (NSDictionary) PropertyListParser.parse(fileAsString.getBytes());
      Date expirationDate = ((NSDate) plist.get("ExpirationDate")).getDate();
      String uuid = ((NSString) plist.get("UUID")).getContent();
      ImmutableMap.Builder<String, NSObject> builder =
          ImmutableMap.<String, NSObject>builder();
      NSDictionary entitlements = ((NSDictionary) plist.get("Entitlements"));
      for (String key : entitlements.keySet()) {
        builder = builder.put(key, entitlements.objectForKey(key));
      }
      String appID = entitlements.get("application-identifier").toString();

      return ProvisioningProfileMetadata.builder()
          .setAppID(ProvisioningProfileMetadata.splitAppID(appID))
          .setExpirationDate(expirationDate)
          .setUUID(uuid)
          .setProfilePath(Optional.<Path>of(profilePath))
          .setEntitlements(builder.build())
          .build();
    } catch (Exception e) {
      throw new IllegalArgumentException("Malformed embedded plist: " + e);
    }
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder.setReflectively("provisioning-profile-uuid", getUUID());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.ProcessExecutorParams;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.EnumSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;

public class AppleConfig {
  private static final Pattern CODE_SIGN_IDENTITY_PATTERN =
      Pattern.compile("([A-F0-9]{40}) \"(iPhone.*)\"");
  private static final Logger LOG = Logger.get(AppleConfig.class);

  private final BuckConfig delegate;

  public AppleConfig(BuckConfig delegate) {
    this.delegate = delegate;
  }


  public Supplier<Optional<Path>> getAppleDeveloperDirectorySupplier(
      ProcessExecutor processExecutor) {
    Optional<String> xcodeDeveloperDirectory = delegate.getValue("apple", "xcode_developer_dir");
    if (xcodeDeveloperDirectory.isPresent()) {
      Path developerDirectory = delegate.resolvePathThatMayBeOutsideTheProjectFilesystem(
          Paths.get(xcodeDeveloperDirectory.get()));
      return Suppliers.ofInstance(Optional.of(developerDirectory));
    } else {
      return createAppleDeveloperDirectorySupplier(processExecutor);
    }
  }

  public ImmutableList<Path> getExtraToolchainPaths() {
    ImmutableList<String> extraPathsStrings = delegate.getListWithoutComments(
        "apple",
        "extra_toolchain_paths");
    return ImmutableList.copyOf(Lists.transform(
        extraPathsStrings,
        new Function<String, Path>() {
            @Override
            public Path apply(String string) {
                return Paths.get(string);
            }
        }));
  }

  public ImmutableList<Path> getExtraPlatformPaths() {
    ImmutableList<String> extraPathsStrings = delegate.getListWithoutComments(
        "apple",
        "extra_platform_paths");
    return ImmutableList.copyOf(Lists.transform(
        extraPathsStrings,
        new Function<String, Path>() {
            @Override
            public Path apply(String string) {
                return Paths.get(string);
            }
        }));
  }

  public ImmutableMap<AppleSdk, AppleSdkPaths> getAppleSdkPaths(ProcessExecutor processExecutor) {
    Optional<Path> appleDeveloperDirectory =
        getAppleDeveloperDirectorySupplier(processExecutor).get();
    try {
      ImmutableMap<String, AppleToolchain> toolchains =
          AppleToolchainDiscovery.discoverAppleToolchains(
              appleDeveloperDirectory,
              getExtraToolchainPaths());
      return AppleSdkDiscovery.discoverAppleSdkPaths(
          appleDeveloperDirectory,
          getExtraPlatformPaths(),
          toolchains);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }


  public static Supplier<ImmutableSet<CodeSignIdentity>> createCodeSignIdentitiesSupplier(
      final ProcessExecutor processExecutor) {
    return Suppliers.memoize(new Supplier<ImmutableSet<CodeSignIdentity>>() {
      @Override
      public ImmutableSet<CodeSignIdentity> get() {
        ProcessExecutorParams processExecutorParams =
            ProcessExecutorParams.builder()
                .setCommand(
                    ImmutableList.of(
                        "security", "find-identity",
                        "-v", "-p", "codesigning"))
                .build();

        Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
        ProcessExecutor.Result result;
        try {
          result = processExecutor.launchAndExecute(
              processExecutorParams,
              options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
        } catch (InterruptedException | IOException e) {
          LOG.warn("Could not execute security, continuing without codesign identity.");
          return ImmutableSet.of();
        }

        if (result.getExitCode() != 0) {
          throw new RuntimeException("security -v -p codesigning failed: " + result.getStderr());
        }

        Matcher matcher = CODE_SIGN_IDENTITY_PATTERN.matcher(result.getStdout().get());
        ImmutableSet.Builder<CodeSignIdentity> builder = ImmutableSet.builder();
        while (matcher.find()) {
          String hash = matcher.group(1);
          String fullName = matcher.group(2);
          CodeSignIdentity identity = CodeSignIdentity.builder()
              .setHash(hash).setFullName(fullName).build();
          builder.add(identity);
          LOG.debug("Found code signing identity: " + identity.toString());
        }
        ImmutableSet<CodeSignIdentity> allValidIdentities = builder.build();
        if (allValidIdentities.isEmpty()) {
          LOG.warn("No valid code signing identities found.  Device build/install won't work.");
        } else if (allValidIdentities.size() > 1) {
          LOG.warn("More than 1 valid identity found.  This could potentially " +
              "cause the wrong one to be used unless explicitly specified via CODE_SIGN_IDENTITY.");
        }
        return allValidIdentities;
      }
    });
  }


  private static Supplier<Optional<Path>> createAppleDeveloperDirectorySupplier(
      final ProcessExecutor processExecutor) {
    return Suppliers.memoize(new Supplier<Optional<Path>>() {
      @Override
      public Optional<Path> get() {
        ProcessExecutorParams processExecutorParams =
            ProcessExecutorParams.builder()
                .setCommand(ImmutableList.of("xcode-select", "--print-path"))
                .build();

        Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
        ProcessExecutor.Result result;
        try {
          result = processExecutor.launchAndExecute(
              processExecutorParams,
              options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
        } catch (InterruptedException | IOException e) {
          LOG.warn("Could not execute xcode-select, continuing without developer dir.");
          return Optional.absent();
        }

        if (result.getExitCode() != 0) {
          throw new RuntimeException("xcode-select --print-path failed: " + result.getStderr());
        }

        return Optional.of(Paths.get(result.getStdout().get().trim()));
      }
    });
  }

  public Optional<String> getTargetSdkVersion(ApplePlatform platform) {
    return delegate.getValue("apple", platform.getName() + "_target_sdk_version");
  }

  public ImmutableList<String> getXctestPlatformNames() {
    return delegate.getListWithoutComments(
        "apple",
        "xctest_platforms");
  }

  public Optional<Path> getXctoolPath() {
    Optional<String> xctoolPath = delegate.getValue("apple", "xctool_path");
    if (xctoolPath.isPresent()) {
      return Optional.of(Paths.get(xctoolPath.get()));
    } else {
      return Optional.absent();
    }
  }

  public Optional<BuildTarget> getXctoolZipTarget() {
    return delegate.getBuildTarget("apple", "xctool_zip_target");
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSNumber;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.cxx.NativeTestable;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.shell.DefaultShellStep;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.CopyStep;
import com.facebook.buck.step.fs.FindAndReplaceStep;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.step.fs.WriteFileStep;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;


public class AppleBundle extends AbstractBuildRule implements NativeTestable {
  private static final Logger LOG = Logger.get(AppleBundle.class);
  private static final String CODE_SIGN_ENTITLEMENTS = "CODE_SIGN_ENTITLEMENTS";
  private static final String CODE_SIGN_IDENTITY = "CODE_SIGN_IDENTITY";

  @AddToRuleKey
  private final String extension;

  @AddToRuleKey
  private final Optional<SourcePath> infoPlist;

  @AddToRuleKey
  private final ImmutableMap<String, String> infoPlistSubstitutions;

  @AddToRuleKey
  private final Optional<BuildRule> binary;

  @AddToRuleKey
  private final AppleBundleDestinations destinations;

  @AddToRuleKey
  private final Set<SourcePath> resourceDirs;

  @AddToRuleKey
  private final Set<SourcePath> resourceFiles;

  @AddToRuleKey
  private final Set<SourcePath> dirsContainingResourceDirs;

  @AddToRuleKey
  private final Optional<ImmutableSet<SourcePath>> resourceVariantFiles;

  @AddToRuleKey
  private final Tool ibtool;

  @AddToRuleKey
  private final Tool dsymutil;

  @AddToRuleKey
  private final Tool strip;

  @AddToRuleKey
  private final ImmutableSortedSet<BuildTarget> tests;

  @AddToRuleKey
  private final String platformName;

  @AddToRuleKey
  private final String sdkName;

  @AddToRuleKey
  private final Optional<ImmutableSet<ProvisioningProfileMetadata>> provisioningProfiles;

  @AddToRuleKey
  private final Optional<CodeSignIdentity> codeSignIdentity;

  private final ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs;

  private final Optional<AppleAssetCatalog> mergedAssetCatalog;

  private final String binaryName;
  private final Path bundleRoot;
  private final Path binaryPath;

  AppleBundle(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Either<AppleBundleExtension, String> extension,
      Optional<SourcePath> infoPlist,
      Map<String, String> infoPlistSubstitutions,
      Optional<BuildRule> binary,
      AppleBundleDestinations destinations,
      Set<SourcePath> resourceDirs,
      Set<SourcePath> resourceFiles,
      Set<SourcePath> dirsContainingResourceDirs,
      Optional<ImmutableSet<SourcePath>> resourceVariantFiles,
      Tool ibtool,
      Tool dsymutil,
      Tool strip,
      Set<AppleAssetCatalog> bundledAssetCatalogs,
      Optional<AppleAssetCatalog> mergedAssetCatalog,
      Set<BuildTarget> tests,
      AppleSdk sdk,
      ImmutableSet<CodeSignIdentity> allValidCodeSignIdentities,
      Optional<SourcePath> provisioningProfileSearchPath) {
    super(params, resolver);
    this.extension = extension.isLeft() ?
        extension.getLeft().toFileExtension() :
        extension.getRight();
    this.infoPlist = infoPlist;
    this.infoPlistSubstitutions = ImmutableMap.copyOf(infoPlistSubstitutions);
    this.binary = binary;
    this.destinations = destinations;
    this.resourceDirs = resourceDirs;
    this.resourceFiles = resourceFiles;
    this.dirsContainingResourceDirs = dirsContainingResourceDirs;
    this.resourceVariantFiles = resourceVariantFiles;
    this.ibtool = ibtool;
    this.dsymutil = dsymutil;
    this.strip = strip;
    this.bundledAssetCatalogs = ImmutableSet.copyOf(bundledAssetCatalogs);
    this.mergedAssetCatalog = mergedAssetCatalog;
    this.binaryName = getBinaryName(getBuildTarget());
    this.bundleRoot = getBundleRoot(getBuildTarget(), this.extension);
    this.binaryPath = this.destinations.getExecutablesPath()
        .resolve(this.binaryName);
    this.tests = ImmutableSortedSet.copyOf(tests);
    this.platformName = sdk.getApplePlatform().getName();
    this.sdkName = sdk.getName();



    if (binary.isPresent() && ApplePlatform.needsCodeSign(this.platformName)) {
      final Path searchPath;
      if (provisioningProfileSearchPath.isPresent()) {
        searchPath = resolver.getResolvedPath(provisioningProfileSearchPath.get());
      } else {
        searchPath = Paths.get(System.getProperty("user.home") +
                "/Library/MobileDevice/Provisioning Profiles");
      }

      this.provisioningProfiles = Optional.of(
          ProvisioningProfileCopyStep.findProfilesInPath(searchPath));

      Optional<CodeSignIdentity> foundIdentity = Optional.absent();
      Optional<String> customIdentity = InfoPlistSubstitution.getVariableExpansionForPlatform(
          CODE_SIGN_IDENTITY,
          this.platformName,
          this.infoPlistSubstitutions);
      if (customIdentity.isPresent()) {
        LOG.debug("Bundle specifies custom code signing identity: " + customIdentity.get());
        if (CodeSignIdentity.isHash(customIdentity.get())) {
          for (CodeSignIdentity identity : allValidCodeSignIdentities) {
            if (identity.getHash().equals(customIdentity.get())) {
              foundIdentity = Optional.of(identity);
              break;
            }
          }
        } else {
          for (CodeSignIdentity identity : allValidCodeSignIdentities) {
            if (identity.getFullName().startsWith(customIdentity.get())) {
              foundIdentity = Optional.of(identity);
              break;
            }
          }
        }
      } else if (!allValidCodeSignIdentities.isEmpty()) {
        LOG.debug("Using default code signing identity");
        Iterator<CodeSignIdentity> it = allValidCodeSignIdentities.iterator();
        foundIdentity = Optional.of(it.next());
      }
      if (!foundIdentity.isPresent()) {
        throw new HumanReadableException("The platform " + platformName + " for this target " +
            "requires code signing but couldn't find a compatible code signing identity to use.");
      }
      LOG.debug("Code signing identity is " + foundIdentity.toString());
      this.codeSignIdentity = foundIdentity;
    } else {
      this.provisioningProfiles = Optional.absent();
      this.codeSignIdentity = Optional.absent();
    }
  }

  public static String getBinaryName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  public static Path getBundleRoot(BuildTarget buildTarget, String extension) {
    return BuildTargets
        .getGenPath(buildTarget, "%s")
        .resolve(getBinaryName(buildTarget) + "." + extension);
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return bundleRoot;
  }

  public Path getInfoPlistPath() {
    return getMetadataPath().resolve("Info.plist");
  }

  public Path getUnzippedOutputFilePathToBinary() {
    return this.binaryPath;
  }

  private Path getMetadataPath() {
    return bundleRoot.resolve(destinations.getMetadataPath());
  }

  public String getPlatformName() { return platformName; }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> stepsBuilder = ImmutableList.builder();

    Path metadataPath = getMetadataPath();

    Path infoPlistInputPath = getResolver().getPath(infoPlist.get());
    Path infoPlistSubstitutionTempPath =
        BuildTargets.getScratchPath(getBuildTarget(), "%s.plist");
    Path infoPlistOutputPath = metadataPath.resolve("Info.plist");

    stepsBuilder.add(
        new MakeCleanDirectoryStep(bundleRoot),
        new MkdirStep(metadataPath),

        new WriteFileStep("APPLWRUN", metadataPath.resolve("PkgInfo")),
        new FindAndReplaceStep(
          infoPlistInputPath,
          infoPlistSubstitutionTempPath,
          InfoPlistSubstitution.createVariableExpansionFunction(
              withDefaults(
                  infoPlistSubstitutions,
                  ImmutableMap.of(
                      "EXECUTABLE_NAME", binaryName,
                      "PRODUCT_NAME", binaryName
                  ))
          )),
        new PlistProcessStep(
            infoPlistSubstitutionTempPath,
            infoPlistOutputPath,
            getInfoPlistAdditionalKeys(platformName, sdkName),
            getInfoPlistOverrideKeys(platformName),
            PlistProcessStep.OutputFormat.BINARY));





    if (binary.isPresent() && binary.get().getPathToOutput() != null) {
      stepsBuilder.add(
          new MkdirStep(bundleRoot.resolve(this.destinations.getExecutablesPath())));
      Path bundleBinaryPath = bundleRoot.resolve(binaryPath);
      stepsBuilder.add(
          CopyStep.forFile(
              binary.get().getPathToOutput(),
              bundleBinaryPath));
      stepsBuilder.add(
          new DsymStep(
              dsymutil.getCommandPrefix(getResolver()),
              bundleBinaryPath,
              bundleBinaryPath.resolveSibling(
                  bundleBinaryPath.getFileName().toString() + ".dSYM")));
      stepsBuilder.add(
          new DefaultShellStep(
              ImmutableList.<String>builder()
                  .addAll(strip.getCommandPrefix(getResolver()))
                  .add("-S")
                  .add(getProjectFilesystem().resolve(bundleBinaryPath).toString())
                  .build()));
    }

    Path bundleDestinationPath = bundleRoot.resolve(this.destinations.getResourcesPath());
    for (SourcePath dir : resourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }
    for (SourcePath dir : dirsContainingResourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }
    for (SourcePath file : resourceFiles) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      Path resolvedFilePath = getResolver().getPath(file);
      Path destinationPath = bundleDestinationPath.resolve(resolvedFilePath.getFileName());
      addResourceProcessingSteps(resolvedFilePath, destinationPath, stepsBuilder);
    }

    if (resourceVariantFiles.isPresent()) {
      for (SourcePath variantSourcePath : resourceVariantFiles.get()) {
        Path variantFilePath = getResolver().getPath(variantSourcePath);

        Path variantDirectory = variantFilePath.getParent();
        if (variantDirectory == null || !variantDirectory.toString().endsWith(".lproj")) {
          throw new HumanReadableException(
              "Variant files have to be in a directory with name ending in '.lproj', " +
                  "but '%s' is not.",
              variantFilePath);
        }

        Path bundleVariantDestinationPath =
            bundleDestinationPath.resolve(variantDirectory.getFileName());
        stepsBuilder.add(new MkdirStep(bundleVariantDestinationPath));

        Path destinationPath = bundleVariantDestinationPath.resolve(variantFilePath.getFileName());
        addResourceProcessingSteps(variantFilePath, destinationPath, stepsBuilder);
      }
    }

    for (AppleAssetCatalog bundledAssetCatalog : bundledAssetCatalogs) {
      Path bundleDir = bundledAssetCatalog.getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }

    if (mergedAssetCatalog.isPresent()) {
      Path bundleDir = mergedAssetCatalog.get().getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }


    if (provisioningProfiles.isPresent()) {
      Optional<Path> entitlementsPlist = Optional.absent();
      final String srcRoot = context.getProjectRoot().resolve(
          getBuildTarget().getBasePath()).toString();
      Optional<String> entitlementsPlistString =
          InfoPlistSubstitution.getVariableExpansionForPlatform(
              CODE_SIGN_ENTITLEMENTS,
              platformName,
              withDefaults(
                  infoPlistSubstitutions,
                  ImmutableMap.of(
                      "SOURCE_ROOT", srcRoot,
                      "SRCROOT", srcRoot
                  )));
      if (entitlementsPlistString.isPresent()) {
        entitlementsPlist = Optional.of(Paths.get(entitlementsPlistString.get()));
      }

      final Path signingEntitlementsTempPath =
          BuildTargets.getScratchPath(getBuildTarget(), "%s.xcent");

      stepsBuilder.add(
          new ProvisioningProfileCopyStep(
              infoPlistOutputPath,
              Optional.<String>absent(),  
              entitlementsPlist,
              provisioningProfiles.get(),
              bundleDestinationPath.resolve("embedded.mobileprovision"),
              signingEntitlementsTempPath)
      );

      stepsBuilder.add(
          new CodeSignStep(
              bundleDestinationPath,
              signingEntitlementsTempPath,
              codeSignIdentity.get().getHash()
          )
      );
    }


    buildableContext.recordArtifact(bundleRoot);

    return stepsBuilder.build();
  }

  static ImmutableMap<String, String> withDefaults(
      ImmutableMap<String, String> map,
      ImmutableMap<String, String> defaults) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.<String, String>builder()
        .putAll(map);
    for (ImmutableMap.Entry<String, String> entry : defaults.entrySet()) {
      if (!map.containsKey(entry.getKey())) {
        builder = builder.put(entry.getKey(), entry.getValue());
      }
    }
    return builder.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistOverrideKeys(
      String platformName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("LSRequiresIPhoneOS", new NSNumber(false));
    } else {
      keys.put("LSRequiresIPhoneOS", new NSNumber(true));
    }

    return keys.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistAdditionalKeys(
      String platformName,
      String sdkName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("NSHighResolutionCapable", new NSNumber(true));
      keys.put("NSSupportsAutomaticGraphicsSwitching", new NSNumber(true));
    }

    keys.put("DTPlatformName", new NSString(platformName));
    keys.put("DTSDKName", new NSString(sdkName));

    return keys.build();
  }

  private void addResourceProcessingSteps(
      Path sourcePath,
      Path destinationPath,
      ImmutableList.Builder<Step> stepsBuilder) {
    String sourcePathExtension = Files.getFileExtension(sourcePath.toString())
        .toLowerCase(Locale.US);
    switch (sourcePathExtension) {
      case "plist":
      case "stringsdict":
        LOG.debug("Converting plist %s to binary plist %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new PlistProcessStep(
                sourcePath,
                destinationPath,
                ImmutableMap.<String, NSObject>of(),
                ImmutableMap.<String, NSObject>of(),
                PlistProcessStep.OutputFormat.BINARY));
        break;
      case "xib":
        String compiledNibFilename = Files.getNameWithoutExtension(destinationPath.toString()) +
            ".nib";
        Path compiledNibPath = destinationPath.getParent().resolve(compiledNibFilename);
        LOG.debug("Compiling XIB %s to NIB %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new IbtoolStep(
                ibtool.getCommandPrefix(getResolver()),
                sourcePath,
                compiledNibPath));
        break;
      default:
        stepsBuilder.add(CopyStep.forFile(sourcePath, destinationPath));
        break;
    }
  }

  @Override
  public boolean isTestedBy(BuildTarget testRule) {
    if (tests.contains(testRule)) {
      return true;
    }

    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).isTestedBy(testRule);
      }
    }

    return false;
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      TargetGraph targetGraph,
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).getCxxPreprocessorInput(
            targetGraph,
            cxxPlatform,
            headerVisibility);
      }
    }
    return CxxPreprocessorInput.EMPTY;
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.google.common.collect.ImmutableMap;

import com.dd.plist.BinaryPropertyListWriter;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.nio.file.Path;

public class PlistProcessStep implements Step {


  public static enum OutputFormat {

    XML,


    BINARY,
    ;
  }

  private final Path input;
  private final Path output;


  private final ImmutableMap<String, NSObject> additionalKeys;


  private final ImmutableMap<String, NSObject> overrideKeys;
  private final OutputFormat outputFormat;

  public PlistProcessStep(
      Path input,
      Path output,
      ImmutableMap<String, NSObject> additionalKeys,
      ImmutableMap<String, NSObject> overrideKeys,
      OutputFormat outputFormat) {
    this.input = input;
    this.output = output;
    this.additionalKeys = additionalKeys;
    this.overrideKeys = overrideKeys;
    this.outputFormat = outputFormat;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {
    ProjectFilesystem filesystem = context.getProjectFilesystem();
    try (InputStream stream = filesystem.newFileInputStream(input);
         BufferedInputStream bufferedStream = new BufferedInputStream(stream)) {
      NSObject infoPlist;
      try {
        infoPlist = PropertyListParser.parse(bufferedStream);
      } catch (Exception e) {
        throw new IOException(input.toString() + ": " + e);
      }

      if (infoPlist instanceof NSDictionary) {
        NSDictionary dictionary = (NSDictionary) infoPlist;
        for (ImmutableMap.Entry<String, NSObject> entry : additionalKeys.entrySet()) {
          if (!dictionary.containsKey(entry.getKey())) {
            dictionary.put(entry.getKey(), entry.getValue());
          }
        }

        dictionary.putAll(overrideKeys);
      }

      switch (this.outputFormat) {
        case XML:
          String serializedInfoPlist = infoPlist.toXMLPropertyList();
          filesystem.writeContentsToPath(
              serializedInfoPlist,
              output);
          break;
        case BINARY:
          byte[] binaryInfoPlist = BinaryPropertyListWriter.writeToArray(infoPlist);
          filesystem.writeBytesToPath(
              binaryInfoPlist,
              output);
          break;
      }
    } catch (IOException e) {
      context.logError(e, "error parsing plist %s", input);
      return 1;
    }

    return 0;
  }

  @Override
  public String getShortName() {
    return "process-plist";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return String.format("process-plist %s %s", input, output);
  }

}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class InfoPlistSubstitution {


  private InfoPlistSubstitution() { }

  private static final String VARIABLE_GROUP_NAME = "variable";
  private static final String OPEN_PAREN_GROUP_NAME = "openparen";
  private static final String CLOSE_PAREN_GROUP_NAME = "closeparen";
  private static final String MODIFIER_GROUP_NAME = "modifier";

  private static final Pattern PLIST_VARIABLE_PATTERN =
      Pattern.compile(
          "\\$(?<" + OPEN_PAREN_GROUP_NAME + ">[\\{\\(])" +
              "(?<" + VARIABLE_GROUP_NAME + ">[^\\}\\):]+)" +
              "(?::(?<" + MODIFIER_GROUP_NAME + ">[^\\}\\)]+))?" +
              "(?<" + CLOSE_PAREN_GROUP_NAME + ">[\\}\\)])");

  private static final ImmutableMap<String, String> MATCHING_PARENS = ImmutableMap.of(
      "{", "}",
      "(", ")"
  );


  public static Optional<String> getVariableExpansionForPlatform(
      String keyName,
      String platformName,
      Map<String, String> variablesToExpand) {
    final String[] keysToTry;
    if (platformName.equals("iphoneos") || platformName.equals("iphonesimulator")) {
      keysToTry = new String[] {
          keyName + "[sdk=" + platformName + "]",
          keyName + "[sdk=" + platformName + "*]",
          keyName + "[sdk=iphone*]",
          keyName
      };
    } else {
      keysToTry = new String[] {
          keyName + "[sdk=" + platformName + "]",
          keyName + "[sdk=" + platformName + "*]",
          keyName
      };
    }

    for (String keyToTry : keysToTry) {
      if (variablesToExpand.containsKey(keyToTry)) {
        return Optional.of(
            InfoPlistSubstitution.replaceVariablesInString(
                variablesToExpand.get(keyToTry),
                variablesToExpand));
      }
    }

    return Optional.absent();
  }

  public static String replaceVariablesInString(
      String input,
      Map<String, String> variablesToExpand) {
    return replaceVariablesInString(input, variablesToExpand, ImmutableList.<String>of());
  }

  private static String replaceVariablesInString(
      String input,
      Map<String, String> variablesToExpand,
      List<String> maskedVariables) {
    Matcher variableMatcher = PLIST_VARIABLE_PATTERN.matcher(input);

    StringBuffer result = new StringBuffer();
    while (variableMatcher.find()) {
      String openParen = variableMatcher.group(OPEN_PAREN_GROUP_NAME);
      String closeParen = variableMatcher.group(CLOSE_PAREN_GROUP_NAME);

      String expectedCloseParen = Preconditions.checkNotNull(MATCHING_PARENS.get(openParen));
      if (!expectedCloseParen.equals(closeParen)) {

        variableMatcher.appendReplacement(
            result,
            Matcher.quoteReplacement(variableMatcher.group(0)));
        continue;
      }

      String variableName = variableMatcher.group(VARIABLE_GROUP_NAME);
      if (maskedVariables.contains(variableName)) {
        throw new HumanReadableException(
            "Recursive plist variable: %s -> %s",
            Joiner.on(" -> ").join(maskedVariables),
            variableName);
      }

      String expansion = variablesToExpand.get(variableName);
      if (expansion == null) {
        throw new HumanReadableException(
            "Unrecognized plist variable: %s",
            variableMatcher.group(0));
      }



      expansion = replaceVariablesInString(
          expansion,
          variablesToExpand,
          new ImmutableList.Builder<String>().addAll(maskedVariables).add(variableName).build());




      variableMatcher.appendReplacement(
          result,
          Matcher.quoteReplacement(expansion));
    }
    variableMatcher.appendTail(result);
    return result.toString();
  }

  public static Function<String, String> createVariableExpansionFunction(
      Map<String, String> variablesToExpand) {
    final ImmutableMap<String, String> variablesToExpandCopy = ImmutableMap.copyOf(
        variablesToExpand);
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return replaceVariablesInString(input, variablesToExpandCopy);
      }
    };
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxCompilationDatabase;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

import java.util.Map;
import java.util.Set;

public class AppleTestDescription implements
    Description<AppleTestDescription.Arg>,
    Flavored,
    ImplicitDepsInferringDescription<AppleTestDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("apple_test");


  private static final Flavor LIBRARY_FLAVOR = ImmutableFlavor.of("apple-test-library");
  private static final Flavor BUNDLE_FLAVOR = ImmutableFlavor.of("apple-test-bundle");

  private static final Set<Flavor> SUPPORTED_FLAVORS = ImmutableSet.of(
      LIBRARY_FLAVOR, BUNDLE_FLAVOR);

  private static final Predicate<Flavor> IS_SUPPORTED_FLAVOR = Predicates.in(SUPPORTED_FLAVORS);

  private static final Set<Flavor> NON_LIBRARY_FLAVORS = ImmutableSet.of(
      CxxCompilationDatabase.COMPILATION_DATABASE,
      CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR,
      CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR);

  private final AppleConfig appleConfig;
  private final AppleBundleDescription appleBundleDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;
  private final ImmutableSet<CodeSignIdentity> allValidCodeSignIdentities;

  public AppleTestDescription(
      AppleConfig appleConfig,
      AppleBundleDescription appleBundleDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform,
      ImmutableSet<CodeSignIdentity> allValidCodeSignIdentities) {
    this.appleConfig = appleConfig;
    this.appleBundleDescription = appleBundleDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
    this.allValidCodeSignIdentities = allValidCodeSignIdentities;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return FluentIterable.from(flavors).allMatch(IS_SUPPORTED_FLAVOR) ||
        appleLibraryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      TargetGraph targetGraph,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    String extension = args.extension.isLeft() ?
        args.extension.getLeft().toFileExtension() :
        args.extension.getRight();
    if (!AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS.contains(extension)) {
      throw new HumanReadableException(
          "Invalid bundle extension for apple_test rule: %s (must be one of %s)",
          extension,
          AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS);
    }
    boolean createBundle = Sets.intersection(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS).isEmpty();
    Sets.SetView<Flavor> nonLibraryFlavors = Sets.difference(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS);
    boolean addDefaultPlatform = nonLibraryFlavors.isEmpty();
    ImmutableSet.Builder<Flavor> extraFlavorsBuilder = ImmutableSet.builder();
    if (createBundle) {
      extraFlavorsBuilder.add(
          LIBRARY_FLAVOR,
          CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR);
    }
    if (addDefaultPlatform) {
      extraFlavorsBuilder.add(defaultCxxPlatform.getFlavor());
    }

    Optional<AppleBundle> testHostApp;
    Optional<SourcePath> testHostAppBinarySourcePath;
    if (args.testHostApp.isPresent()) {
      TargetNode<?> testHostAppNode = targetGraph.get(args.testHostApp.get());
      Preconditions.checkNotNull(testHostAppNode);

      if (testHostAppNode.getType() != AppleBundleDescription.TYPE) {
        throw new HumanReadableException(
            "Apple test rule %s has unrecognized test_host_app %s type %s (should be %s)",
            params.getBuildTarget(),
            args.testHostApp.get(),
            testHostAppNode.getType(),
            AppleBundleDescription.TYPE);
      }

      AppleBundleDescription.Arg testHostAppDescription = (AppleBundleDescription.Arg)
          testHostAppNode.getConstructorArg();

      testHostApp = Optional.of(
          appleBundleDescription
              .createBuildRule(
                  targetGraph,
                  params.copyWithChanges(
                      BuildTarget.builder(args.testHostApp.get())
                          .addAllFlavors(nonLibraryFlavors)
                          .build(),
                      Suppliers.ofInstance(
                          BuildRules.toBuildRulesFor(
                              args.testHostApp.get(),
                              resolver,
                              testHostAppNode.getDeclaredDeps())),
                      Suppliers.ofInstance(
                          BuildRules.toBuildRulesFor(
                              args.testHostApp.get(),
                              resolver,
                              testHostAppNode.getExtraDeps()))),
                  resolver,
                  testHostAppDescription));
      testHostAppBinarySourcePath = Optional.<SourcePath>of(
          new BuildTargetSourcePath(testHostAppDescription.binary));
    } else {
      testHostApp = Optional.absent();
      testHostAppBinarySourcePath = Optional.absent();
    }

    BuildRule library = appleLibraryDescription.createBuildRule(
        targetGraph,
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget())
                .addAllFlavors(extraFlavorsBuilder.build())
                .build(),
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        resolver,
        args,


        Optional.of(Linker.LinkableDepType.STATIC),
        testHostAppBinarySourcePath);
    if (!createBundle) {
      return library;
    }

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple test requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);
    ImmutableSet.Builder<SourcePath> resourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> resourceFilesBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> resourceVariantFilesBuilder = ImmutableSet.builder();

    AppleResources.collectResourceDirsAndFiles(
        targetGraph,
        Preconditions.checkNotNull(targetGraph.get(params.getBuildTarget())),
        resourceDirsBuilder,
        dirsContainingResourceDirsBuilder,
        resourceFilesBuilder,
        resourceVariantFilesBuilder);

    ImmutableSet<SourcePath> resourceDirs = resourceDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> resourceFiles = resourceFilesBuilder.build();
    ImmutableSet<SourcePath> resourceVariantFiles = resourceVariantFilesBuilder.build();

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            targetGraph,
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();

    String platformName = appleCxxPlatform.getAppleSdk().getApplePlatform().getName();

    AppleBundle bundle = new AppleBundle(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget()).addFlavors(BUNDLE_FLAVOR).build(),


            Suppliers.ofInstance(
                ImmutableSortedSet.<BuildRule>naturalOrder()
                    .add(library)
                    .addAll(mergedAssetCatalog.asSet())
                    .addAll(bundledAssetCatalogs)
                    .addAll(params.getDeclaredDeps())
                    .addAll(
                        BuildRules.toBuildRulesFor(
                            params.getBuildTarget(),
                            resolver,
                            SourcePaths.filterBuildTargetSourcePaths(
                                Iterables.concat(
                                    resourceFiles,
                                    resourceDirs,
                                    dirsContainingResourceDirs,
                                    resourceVariantFiles))))
                    .build()),
            Suppliers.ofInstance(params.getExtraDeps())),
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(library),
        destinations,
        resourceDirs,
        resourceFiles,
        dirsContainingResourceDirsBuilder.build(),
        Optional.of(resourceVariantFiles),
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        appleCxxPlatform.getCxxPlatform().getStrip(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        ImmutableSortedSet.<BuildTarget>of(),
        appleCxxPlatform.getAppleSdk(),
        allValidCodeSignIdentities,
        args.provisioningProfileSearchPath);


    Optional<BuildRule> xctoolZipBuildRule;
    if (appleConfig.getXctoolZipTarget().isPresent()) {
      xctoolZipBuildRule = Optional.of(
          resolver.getRule(appleConfig.getXctoolZipTarget().get()));
    } else {
      xctoolZipBuildRule = Optional.absent();
    }

    return new AppleTest(
        appleConfig.getXctoolPath(),
        xctoolZipBuildRule,
        appleCxxPlatform.getXctest(),
        appleCxxPlatform.getOtest(),
        appleConfig.getXctestPlatformNames().contains(platformName),
        platformName,
        Optional.<String>absent(),
        params.copyWithDeps(
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(bundle)),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        sourcePathResolver,
        bundle,
        testHostApp,
        extension,
        args.contacts.get(),
        args.labels.get());
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      AppleTestDescription.Arg constructorArg) {



    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();
    Optional<BuildTarget> xctoolZipTarget = appleConfig.getXctoolZipTarget();
    if (xctoolZipTarget.isPresent()) {
      deps.add(xctoolZipTarget.get());
    }
    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends AppleNativeTargetDescriptionArg implements HasAppleBundleFields {
    public Optional<ImmutableSortedSet<String>> contacts;
    public Optional<ImmutableSortedSet<Label>> labels;
    public Optional<Boolean> canGroup;
    public Optional<BuildTarget> testHostApp;


    public Either<AppleBundleExtension, String> extension;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<String> xcodeProductType;
    public Optional<String> resourcePrefixDir;
    public Optional<SourcePath> provisioningProfileSearchPath;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }

    public boolean canGroup() {
      return canGroup.or(false);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.base.Preconditions;

import org.immutables.value.Value;

import java.util.regex.Matcher;
import java.util.regex.Pattern;



@Value.Immutable
@BuckStyleImmutable
abstract class AbstractCodeSignIdentity implements RuleKeyAppendable {
  private static final Pattern STRICT_HASH_PATTERN = Pattern.compile("(^[A-F0-9]{40}$)");


  public static final CodeSignIdentity AD_HOC = CodeSignIdentity.builder()
      .setHash("-").setFullName("Ad Hoc").build();


  public abstract String getHash();


  public abstract String getFullName();


  public static boolean isHash(String identifier) {
    Matcher matcher = STRICT_HASH_PATTERN.matcher(identifier);
    return matcher.find() || identifier.equals("-");
  }

  @Value.Check
  protected void check() {
    Preconditions.checkArgument(isHash(getHash()));
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder.setReflectively("code-sign-identity", getHash());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractApplePlatform implements Comparable<AbstractApplePlatform> {
  public class Name {
    public static final String IPHONEOS = "iphoneos";
    public static final String IPHONESIMULATOR = "iphonesimulator";
    public static final String WATCHOS = "watchos";
    public static final String WATCHSIMULATOR = "watchsimulator";
    public static final String MACOSX = "macosx";

    private Name() { }
  }


  public abstract String getName();

  public static boolean needsCodeSign(String name) {
    return name.equals(Name.IPHONEOS) || name.equals(Name.WATCHOS);
  }

  @Override
  public int compareTo(AbstractApplePlatform other) {
    return getName().compareTo(other.getName());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Hint;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

import java.util.Map;
import java.util.Set;

public class AppleBundleDescription implements Description<AppleBundleDescription.Arg>, Flavored {
  public static final BuildRuleType TYPE = BuildRuleType.of("apple_bundle");

  private final AppleBinaryDescription appleBinaryDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;
  private final ImmutableSet<CodeSignIdentity> allValidCodeSignIdentities;

  public AppleBundleDescription(
      AppleBinaryDescription appleBinaryDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform,
      ImmutableSet<CodeSignIdentity> allValidCodeSignIdentities) {
    this.appleBinaryDescription = appleBinaryDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
    this.allValidCodeSignIdentities = allValidCodeSignIdentities;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    if (appleLibraryDescription.hasFlavors(flavors)) {
      return true;
    }
    ImmutableSet.Builder<Flavor> flavorBuilder = ImmutableSet.builder();
    for (Flavor flavor : flavors) {
      if (flavor.equals(ReactNativeFlavors.DO_NOT_BUNDLE)) {
        continue;
      }
      flavorBuilder.add(flavor);
    }
    return appleBinaryDescription.hasFlavors(flavorBuilder.build());
  }

  @Override
  public <A extends Arg> AppleBundle createBuildRule(
      TargetGraph targetGraph,
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple bundle requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    ImmutableSet.Builder<SourcePath> bundleDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleFilesBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleVariantFilesBuilder = ImmutableSet.builder();
    AppleResources.collectResourceDirsAndFiles(
        targetGraph,
        Preconditions.checkNotNull(targetGraph.get(params.getBuildTarget())),
        bundleDirsBuilder,
        dirsContainingResourceDirsBuilder,
        bundleFilesBuilder,
        bundleVariantFilesBuilder);
    ImmutableSet<SourcePath> bundleDirs = bundleDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> bundleFiles = bundleFilesBuilder.build();
    ImmutableSet<SourcePath> bundleVariantFiles = bundleVariantFilesBuilder.build();

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            targetGraph,
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();



    BuildRule flavoredBinaryRule = getFlavoredBinaryRule(targetGraph, params, resolver, args);
    BuildRuleParams bundleParamsWithFlavoredBinaryDep = getBundleParamsWithUpdatedDeps(
        params,
        args.binary,
        ImmutableSet.<BuildRule>builder()
            .add(flavoredBinaryRule)
            .addAll(mergedAssetCatalog.asSet())
            .addAll(bundledAssetCatalogs)
            .addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    SourcePaths.filterBuildTargetSourcePaths(
                        Iterables.concat(
                            bundleFiles,
                            bundleDirs,
                            dirsContainingResourceDirs,
                            bundleVariantFiles))))
            .build());

    return new AppleBundle(
        bundleParamsWithFlavoredBinaryDep,
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(flavoredBinaryRule),
        destinations,
        bundleDirs,
        bundleFiles,
        dirsContainingResourceDirs,
        Optional.of(bundleVariantFiles),
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        appleCxxPlatform.getCxxPlatform().getStrip(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        args.getTests(),
        appleCxxPlatform.getAppleSdk(),
        allValidCodeSignIdentities,
        args.provisioningProfileSearchPath);
  }

  private static <A extends Arg> BuildRule getFlavoredBinaryRule(
      TargetGraph targetGraph,
      final BuildRuleParams params,
      final BuildRuleResolver resolver,
      A args) {
    final TargetNode<?> binaryTargetNode = Preconditions.checkNotNull(targetGraph.get(args.binary));
    BuildRuleParams binaryRuleParams = new BuildRuleParams(
        args.binary,
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getDeclaredDeps())),
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getExtraDeps())),
        params.getProjectFilesystem(),
        params.getRuleKeyBuilderFactory());
    return CxxDescriptionEnhancer.requireBuildRule(
        targetGraph,
        binaryRuleParams,
        resolver,
        params
            .getBuildTarget()
            .withoutFlavors(ImmutableSet.of(ReactNativeFlavors.DO_NOT_BUNDLE))
            .getFlavors()
            .toArray(new Flavor[0]));
  }

  private static BuildRuleParams getBundleParamsWithUpdatedDeps(
      final BuildRuleParams params,
      final BuildTarget originalBinaryTarget,
      final Set<BuildRule> newDeps) {

    final Predicate<BuildRule> notOriginalBinaryRule = Predicates.not(
        BuildRules.isBuildRuleWithTarget(originalBinaryTarget));
    return params.copyWithDeps(
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getDeclaredDeps())
                .filter(notOriginalBinaryRule)
                .append(newDeps)
                .toSortedSet(Ordering.natural())),
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getExtraDeps())
                .filter(notOriginalBinaryRule)
                .toSortedSet(Ordering.natural())));
  }

  @SuppressFieldNotInitialized
  public static class Arg implements HasAppleBundleFields, HasTests {
    public Either<AppleBundleExtension, String> extension;
    public BuildTarget binary;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<ImmutableMap<String, SourcePath>> headers;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
    public Optional<SourcePath> provisioningProfileSearchPath;
    @Hint(isDep = false) public Optional<ImmutableSortedSet<BuildTarget>> tests;
    public Optional<String> xcodeProductType;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public ImmutableSortedSet<BuildTarget> getTests() {
      return tests.get();
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;

import com.facebook.buck.io.ProjectFilesystem.CopySourceMode;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.Pair;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.WriteFileStep;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Date;


public class ProvisioningProfileCopyStep implements Step {
  private static final String KEYCHAIN_ACCESS_GROUPS = "keychain-access-groups";
  private static final String APPLICATION_IDENTIFIER = "application-identifier";
  private static final Logger LOG = Logger.get(ProvisioningProfileCopyStep.class);

  private final Optional<Path> entitlementsPlist;
  private final Optional<String> provisioningProfileUUID;
  private final Path provisioningProfileDestination;
  private final Path signingEntitlementsTempPath;
  private final ImmutableSet<ProvisioningProfileMetadata> profiles;
  private final Path infoPlist;


  public ProvisioningProfileCopyStep(
      Path infoPlist,
      Optional<String> provisioningProfileUUID,
      Optional<Path> entitlementsPlist,
      ImmutableSet<ProvisioningProfileMetadata> profiles,
      Path provisioningProfileDestination,
      Path signingEntitlementsTempPath
  ) {
    this.provisioningProfileDestination = provisioningProfileDestination;
    this.infoPlist = infoPlist;
    this.provisioningProfileUUID = provisioningProfileUUID;
    this.entitlementsPlist = entitlementsPlist;
    this.profiles = profiles;
    this.signingEntitlementsTempPath = signingEntitlementsTempPath;
  }

  public static ImmutableSet<ProvisioningProfileMetadata> findProfilesInPath(Path searchPath) {
    final ImmutableSet.Builder<ProvisioningProfileMetadata> profilesBuilder =
        ImmutableSet.builder();

    try {
      Files.walkFileTree(
          searchPath.toAbsolutePath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
              if (file.toString().endsWith(".mobileprovision")) {
                try {
                  ProvisioningProfileMetadata profile =
                      ProvisioningProfileMetadata.fromProvisioningProfilePath(file);
                  profilesBuilder.add(profile);
                } catch (IOException | IllegalArgumentException e) {
                  LOG.error(e, "Ignoring invalid or malformed .mobileprovision file");
                }
              }

              return FileVisitResult.CONTINUE;
            }
          });
    } catch (IOException e) {
      LOG.error(e, "Error while searching for mobileprovision files");
    }

    return profilesBuilder.build();
  }





  @VisibleForTesting
  static Optional<ProvisioningProfileMetadata> getBestProvisioningProfile(
      ImmutableSet<ProvisioningProfileMetadata> profiles,
      String bundleID,
      Optional<String> provisioningProfileUUID,
      Optional<String> prefix) {
    int bestMatchLength = -1;
    Optional<ProvisioningProfileMetadata> bestMatch =
        Optional.<ProvisioningProfileMetadata>absent();

    for (ProvisioningProfileMetadata profile : profiles) {
      if (provisioningProfileUUID.isPresent() &&
          profile.getUUID().equals(provisioningProfileUUID.get())) {
        return Optional.<ProvisioningProfileMetadata>of(profile);
      }

      if (profile.getExpirationDate().after(new Date())) {
        Pair<String, String> appID = profile.getAppID();

        LOG.debug("Looking at provisioning profile " + profile.getUUID() + "," + appID.toString());

        if (!prefix.isPresent() || prefix.get().equals(appID.getFirst())) {
          String profileBundleID = appID.getSecond();
          boolean match;
          if (profileBundleID.endsWith("*")) {

            profileBundleID =
                profileBundleID.substring(0, profileBundleID.length() - 1);
            match = bundleID.startsWith(profileBundleID);
          } else {
            match = (bundleID.equals(profileBundleID));
          }

          if (match && profileBundleID.length() > bestMatchLength) {
            bestMatchLength = profileBundleID.length();
            bestMatch = Optional.<ProvisioningProfileMetadata>of(profile);
          }
        }
      }
    }

    LOG.debug("Found provisioning profile " + bestMatch.toString());
    return bestMatch;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {

    final String bundleID;
    try {
      bundleID = AppleInfoPlistParsing.getBundleIdFromPlistStream(
          context.getProjectFilesystem().getInputStreamForRelativePath(infoPlist)
      ).get();
    } catch (IOException e) {
      throw new HumanReadableException("Unable to get bundle ID from info.plist: " + infoPlist);
    }


    final Optional<String> prefix;          
    if (entitlementsPlist.isPresent()) {
      NSDictionary entitlementsPlistDict;
      try {
        entitlementsPlistDict =
            (NSDictionary) PropertyListParser.parse(entitlementsPlist.get().toFile());

      } catch (Exception e) {
        throw new HumanReadableException("Malformed entitlement .plist: " +
            entitlementsPlist.get());
      }

      try {
        String appID = ((NSArray) entitlementsPlistDict.get("keychain-access-groups"))
            .objectAtIndex(0).toString();
        prefix = Optional.<String>of(ProvisioningProfileMetadata.splitAppID(appID).getFirst());
      } catch (Exception e) {
        throw new HumanReadableException(
            "Malformed entitlement .plist (missing keychain-access-groups): " +
                entitlementsPlist.get());
      }
    } else {
      prefix = Optional.<String>absent();
    }

    Optional<ProvisioningProfileMetadata> bestProfile = getBestProvisioningProfile(profiles,
        bundleID, provisioningProfileUUID, prefix);

    if (!bestProfile.isPresent()) {
      throw new HumanReadableException("No valid non-expired provisioning profiles match for " +
        prefix + "." + bundleID);
    }

    Path provisioningProfileSource = bestProfile.get().getProfilePath().get();


    try {
      context.getProjectFilesystem().copy(
          provisioningProfileSource,
          provisioningProfileDestination,
          CopySourceMode.FILE);
    } catch (IOException e) {
      context.logError(e, "Failed when trying to copy: %s", getDescription(context));
      return 1;
    }


    if (entitlementsPlist.isPresent()) {
      return (new PlistProcessStep(
          entitlementsPlist.get(),
          signingEntitlementsTempPath,
          bestProfile.get().getEntitlements(),
          ImmutableMap.<String, NSObject>of(),
          PlistProcessStep.OutputFormat.XML)).execute(context);
    } else {

      String appID = bestProfile.get().getAppID().getFirst() + "." + bundleID;
      NSDictionary entitlements = new NSDictionary();
      entitlements.putAll(bestProfile.get().getEntitlements());
      entitlements.put(APPLICATION_IDENTIFIER, appID);
      entitlements.put(KEYCHAIN_ACCESS_GROUPS, new String[]{appID});
      return (new WriteFileStep(
          entitlements.toXMLPropertyList(),
          signingEntitlementsTempPath)).execute(context);
    }
  }

  @Override
  public String getShortName() {
    return "provisioning-profile-copy";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return String.format("provisioning-profile-copy %s",
        provisioningProfileDestination);
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.ProcessExecutorParams;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;

import java.io.IOException;
import java.nio.file.Path;
import java.util.EnumSet;
import java.util.Set;

public class CodeSignStep implements Step {
  private final Path pathToSign;
  private final Path pathToSigningEntitlements;
  private final String codeSignIdentity;

  public CodeSignStep(
      Path pathToSign,
      Path pathToSigningEntitlements,
      String codeSignIdentity
  ) {
    this.pathToSign = pathToSign;
    this.pathToSigningEntitlements = pathToSigningEntitlements;
    this.codeSignIdentity = codeSignIdentity;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {
    ProcessExecutorParams processExecutorParams =
        ProcessExecutorParams.builder()
            .setCommand(
                ImmutableList.of(
                    "codesign",
                    "--force",
                    "--sign", codeSignIdentity,
                    "--entitlements", pathToSigningEntitlements.toString(),
                    pathToSign.toString()))
            .setDirectory(context.getProjectDirectoryRoot().toFile())
            .build();

    Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
    ProcessExecutor.Result result;
    try {
      ProcessExecutor processExecutor = context.getProcessExecutor();
      result = processExecutor.launchAndExecute(
          processExecutorParams,
          options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
    } catch (InterruptedException | IOException e) {
      context.logError(e, "Could not execute codesign.");
      return 1;
    }

    if (result.getExitCode() != 0) {
      return 1;
    }
    return 0;
  }

  @Override
  public String getShortName() {
    return "code-sign";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return String.format("code-sign %s",
        pathToSign);
  }
}

<code block>


package com.facebook.buck.rules;

import com.facebook.buck.android.AndroidAarDescription;
import com.facebook.buck.android.AndroidBinaryDescription;
import com.facebook.buck.android.AndroidBuckConfig;
import com.facebook.buck.android.AndroidBuildConfigDescription;
import com.facebook.buck.android.AndroidDirectoryResolver;
import com.facebook.buck.android.AndroidInstrumentationApkDescription;
import com.facebook.buck.android.AndroidInstrumentationTestDescription;
import com.facebook.buck.android.AndroidLibraryDescription;
import com.facebook.buck.android.AndroidManifestDescription;
import com.facebook.buck.android.AndroidPrebuiltAarDescription;
import com.facebook.buck.android.AndroidResourceDescription;
import com.facebook.buck.android.ApkGenruleDescription;
import com.facebook.buck.android.GenAidlDescription;
import com.facebook.buck.android.ImmutableNdkCxxPlatforms;
import com.facebook.buck.android.NdkCxxPlatform;
import com.facebook.buck.android.NdkCxxPlatforms;
import com.facebook.buck.android.NdkLibraryDescription;
import com.facebook.buck.android.PrebuiltNativeLibraryDescription;
import com.facebook.buck.android.ProGuardConfig;
import com.facebook.buck.android.RobolectricTestDescription;
import com.facebook.buck.android.SmartDexingStep;
import com.facebook.buck.apple.AppleAssetCatalogDescription;
import com.facebook.buck.apple.AppleBinaryDescription;
import com.facebook.buck.apple.AppleBundleDescription;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleCxxPlatform;
import com.facebook.buck.apple.AppleCxxPlatforms;
import com.facebook.buck.apple.AppleLibraryDescription;
import com.facebook.buck.apple.AppleResourceDescription;
import com.facebook.buck.apple.AppleSdk;
import com.facebook.buck.apple.AppleSdkDiscovery;
import com.facebook.buck.apple.AppleSdkPaths;
import com.facebook.buck.apple.AppleTestDescription;
import com.facebook.buck.apple.AppleToolchain;
import com.facebook.buck.apple.AppleToolchainDiscovery;
import com.facebook.buck.apple.CodeSignIdentity;
import com.facebook.buck.apple.CoreDataModelDescription;
import com.facebook.buck.apple.XcodePostbuildScriptDescription;
import com.facebook.buck.apple.XcodePrebuildScriptDescription;
import com.facebook.buck.apple.XcodeWorkspaceConfigDescription;
import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.CxxBinaryDescription;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxLibraryDescription;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.CxxPythonExtensionDescription;
import com.facebook.buck.cxx.CxxTestDescription;
import com.facebook.buck.cxx.DefaultCxxPlatforms;
import com.facebook.buck.cxx.PrebuiltCxxLibraryDescription;
import com.facebook.buck.d.DBinaryDescription;
import com.facebook.buck.d.DBuckConfig;
import com.facebook.buck.d.DLibraryDescription;
import com.facebook.buck.d.DTestDescription;
import com.facebook.buck.file.Downloader;
import com.facebook.buck.file.ExplodingDownloader;
import com.facebook.buck.file.HttpDownloader;
import com.facebook.buck.file.RemoteFileDescription;
import com.facebook.buck.gwt.GwtBinaryDescription;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.java.JavaBinaryDescription;
import com.facebook.buck.java.JavaBuckConfig;
import com.facebook.buck.java.JavaLibraryDescription;
import com.facebook.buck.java.JavaTestDescription;
import com.facebook.buck.java.JavacOptions;
import com.facebook.buck.java.KeystoreDescription;
import com.facebook.buck.java.PrebuiltJarDescription;
import com.facebook.buck.js.AndroidReactNativeLibraryDescription;
import com.facebook.buck.js.IosReactNativeLibraryDescription;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.log.CommandThreadFactory;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.ocaml.OCamlBinaryDescription;
import com.facebook.buck.ocaml.OCamlBuckConfig;
import com.facebook.buck.ocaml.OCamlLibraryDescription;
import com.facebook.buck.ocaml.PrebuiltOCamlLibraryDescription;
import com.facebook.buck.python.PrebuiltPythonLibraryDescription;
import com.facebook.buck.python.PythonBinaryDescription;
import com.facebook.buck.python.PythonBuckConfig;
import com.facebook.buck.python.PythonEnvironment;
import com.facebook.buck.python.PythonLibraryDescription;
import com.facebook.buck.python.PythonTestDescription;
import com.facebook.buck.rust.RustBinaryDescription;
import com.facebook.buck.rust.RustBuckConfig;
import com.facebook.buck.rust.RustLibraryDescription;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleDescription;
import com.facebook.buck.shell.ShBinaryDescription;
import com.facebook.buck.shell.ShTestDescription;
import com.facebook.buck.thrift.ThriftBuckConfig;
import com.facebook.buck.thrift.ThriftCxxEnhancer;
import com.facebook.buck.thrift.ThriftJavaEnhancer;
import com.facebook.buck.thrift.ThriftLibraryDescription;
import com.facebook.buck.thrift.ThriftPythonEnhancer;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.environment.Platform;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;

import java.io.IOException;
import java.net.Proxy;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.Executors;

import javax.annotation.Nullable;


public class KnownBuildRuleTypes {

  private static final Logger LOG = Logger.get(KnownBuildRuleTypes.class);
  private final ImmutableMap<BuildRuleType, Description<?>> descriptions;
  private final ImmutableMap<String, BuildRuleType> types;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;
  private final CxxPlatform defaultCxxPlatforms;

  private KnownBuildRuleTypes(
      Map<BuildRuleType, Description<?>> descriptions,
      Map<String, BuildRuleType> types,
      FlavorDomain<CxxPlatform> cxxPlatforms,
      CxxPlatform defaultCxxPlatforms) {
    this.descriptions = ImmutableMap.copyOf(descriptions);
    this.types = ImmutableMap.copyOf(types);
    this.cxxPlatforms = cxxPlatforms;
    this.defaultCxxPlatforms = defaultCxxPlatforms;
  }

  public BuildRuleType getBuildRuleType(String named) {
    BuildRuleType type = types.get(named);
    if (type == null) {
      throw new HumanReadableException("Unable to find build rule type: " + named);
    }
    return type;
  }

  public Description<?> getDescription(BuildRuleType buildRuleType) {
    Description<?> description = descriptions.get(buildRuleType);
    if (description == null) {
      throw new HumanReadableException(
          "Unable to find description for build rule type: " + buildRuleType);
    }
    return description;
  }

  public ImmutableSet<Description<?>> getAllDescriptions() {
    return ImmutableSet.copyOf(descriptions.values());
  }

  public FlavorDomain<CxxPlatform> getCxxPlatforms() {
    return cxxPlatforms;
  }

  public CxxPlatform getDefaultCxxPlatforms() {
    return defaultCxxPlatforms;
  }

  public static Builder builder() {
    return new Builder();
  }

  public static KnownBuildRuleTypes createInstance(
      BuckConfig config,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor,
      AndroidDirectoryResolver androidDirectoryResolver,
      PythonEnvironment pythonEnv) throws InterruptedException, IOException {
    return createBuilder(
        config,
        projectFilesystem,
        processExecutor,
        androidDirectoryResolver,
        pythonEnv).build();
  }

  private static void buildAppleCxxPlatforms(
      Supplier<Optional<Path>> appleDeveloperDirectorySupplier,
      ImmutableList<Path> extraToolchainPaths,
      ImmutableList<Path> extraPlatformPaths,
      BuckConfig buckConfig,
      AppleConfig appleConfig,
      ImmutableMap.Builder<Flavor, AppleCxxPlatform> platformFlavorsToAppleSdkPathsBuilder)
      throws IOException {
    Optional<Path> appleDeveloperDirectory = appleDeveloperDirectorySupplier.get();
    if (appleDeveloperDirectory.isPresent() &&
        !Files.isDirectory(appleDeveloperDirectory.get())) {
      LOG.error(
        "Developer directory is set to %s, but is not a directory",
        appleDeveloperDirectory.get());
      return;
    }

    ImmutableMap<String, AppleToolchain> toolchains =
        AppleToolchainDiscovery.discoverAppleToolchains(
            appleDeveloperDirectory,
            extraToolchainPaths);

    ImmutableMap<AppleSdk, AppleSdkPaths> sdkPaths = AppleSdkDiscovery.discoverAppleSdkPaths(
        appleDeveloperDirectory,
        extraPlatformPaths,
        toolchains);

    for (Map.Entry<AppleSdk, AppleSdkPaths> entry : sdkPaths.entrySet()) {
      AppleSdk sdk = entry.getKey();
      AppleSdkPaths appleSdkPaths = entry.getValue();
      String targetSdkVersion = appleConfig.getTargetSdkVersion(
          sdk.getApplePlatform()).or(sdk.getVersion());
      LOG.debug("SDK %s using default version %s", sdk, targetSdkVersion);
      for (String architecture : sdk.getArchitectures()) {
        AppleCxxPlatform appleCxxPlatform = AppleCxxPlatforms.build(
            sdk,
            targetSdkVersion,
            architecture,
            appleSdkPaths,
            buckConfig);
        platformFlavorsToAppleSdkPathsBuilder.put(
            appleCxxPlatform.getCxxPlatform().getFlavor(),
            appleCxxPlatform);
      }
    }
  }

  @VisibleForTesting
  static Builder createBuilder(
      BuckConfig config,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor,
      AndroidDirectoryResolver androidDirectoryResolver,
      PythonEnvironment pythonEnv) throws InterruptedException, IOException {

    Platform platform = Platform.detect();

    AndroidBuckConfig androidConfig = new AndroidBuckConfig(config, platform);
    Optional<String> ndkVersion = androidConfig.getNdkVersion();


    if (!ndkVersion.isPresent()) {
      ndkVersion = androidDirectoryResolver.getNdkVersion();
    }

    AppleConfig appleConfig = new AppleConfig(config);
    ImmutableMap.Builder<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatformsBuilder =
        ImmutableMap.builder();
    buildAppleCxxPlatforms(
        appleConfig.getAppleDeveloperDirectorySupplier(processExecutor),
        appleConfig.getExtraToolchainPaths(),
        appleConfig.getExtraPlatformPaths(),
        config,
        appleConfig,
        platformFlavorsToAppleCxxPlatformsBuilder);
    ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms =
        platformFlavorsToAppleCxxPlatformsBuilder.build();


    Optional<Path> ndkRoot = androidDirectoryResolver.findAndroidNdkDir();
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> ndkCxxPlatformsBuilder =
        ImmutableMap.builder();
    if (ndkRoot.isPresent()) {
      NdkCxxPlatforms.Compiler.Type compilerType =
          androidConfig.getNdkCompiler().or(NdkCxxPlatforms.DEFAULT_COMPILER_TYPE);
      String gccVersion = androidConfig.getNdkGccVersion().or(NdkCxxPlatforms.DEFAULT_GCC_VERSION);
      NdkCxxPlatforms.Compiler compiler =
          ImmutableNdkCxxPlatforms.Compiler.builder()
              .setType(compilerType)
              .setVersion(
                  compilerType == NdkCxxPlatforms.Compiler.Type.GCC ?
                      gccVersion :
                      androidConfig.getNdkClangVersion().or(NdkCxxPlatforms.DEFAULT_CLANG_VERSION))
              .setGccVersion(gccVersion)
              .build();
      ndkCxxPlatformsBuilder.putAll(
          NdkCxxPlatforms.getPlatforms(
              new ProjectFilesystem(ndkRoot.get()),
              compiler,
              androidConfig.getNdkCxxRuntime().or(NdkCxxPlatforms.DEFAULT_CXX_RUNTIME),
              androidConfig.getNdkAppPlatform().or(NdkCxxPlatforms.DEFAULT_TARGET_APP_PLATFORM),
              platform));
    }
    ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> ndkCxxPlatforms =
        ndkCxxPlatformsBuilder.build();


    CxxBuckConfig cxxBuckConfig = new CxxBuckConfig(config);
    ImmutableMap.Builder<Flavor, CxxPlatform> cxxPlatformsBuilder = ImmutableMap.builder();



    for (NdkCxxPlatform ndkCxxPlatform : ndkCxxPlatforms.values()) {
      cxxPlatformsBuilder.put(
          ndkCxxPlatform.getCxxPlatform().getFlavor(),
          ndkCxxPlatform.getCxxPlatform());
    }

    for (Map.Entry<Flavor, AppleCxxPlatform> entry :
        platformFlavorsToAppleCxxPlatforms.entrySet()) {
      cxxPlatformsBuilder.put(entry.getKey(), entry.getValue().getCxxPlatform());
    }


    CxxPlatform systemDefaultCxxPlatform = DefaultCxxPlatforms.build(platform, cxxBuckConfig);
    cxxPlatformsBuilder.put(systemDefaultCxxPlatform.getFlavor(), systemDefaultCxxPlatform);
    ImmutableMap<Flavor, CxxPlatform> cxxPlatformsMap = cxxPlatformsBuilder.build();


    CxxPlatform defaultCxxPlatform = CxxPlatforms.getConfigDefaultCxxPlatform(
        cxxBuckConfig,
        cxxPlatformsMap,
        systemDefaultCxxPlatform);



    ImmutableSet<Flavor> cxxFlavors = CxxBuckConfig.getCxxFlavors(config);
    for (Flavor flavor: cxxFlavors) {
      CxxBuckConfig flavoredCxxBuckConfig =  new CxxBuckConfig(config, flavor);
      CxxPlatform defaultPlatformForFlavor = CxxPlatforms.getConfigDefaultCxxPlatform(
          flavoredCxxBuckConfig,
          cxxPlatformsMap,
          systemDefaultCxxPlatform);
      cxxPlatformsBuilder.put(flavor, CxxPlatforms.copyPlatformWithFlavorAndConfig(
          defaultPlatformForFlavor,
          flavoredCxxBuckConfig,
          flavor));
    }

    cxxPlatformsMap = cxxPlatformsBuilder.build();



    FlavorDomain<CxxPlatform> cxxPlatforms = new FlavorDomain<>(
        "C/C++ platform",
        cxxPlatformsMap);

    DBuckConfig dBuckConfig = new DBuckConfig(config);

    ReactNativeBuckConfig reactNativeBuckConfig = new ReactNativeBuckConfig(config);

    RustBuckConfig rustBuckConfig = new RustBuckConfig(config);

    ProGuardConfig proGuardConfig = new ProGuardConfig(config);

    PythonBuckConfig pyConfig = new PythonBuckConfig(config, new ExecutableFinder());


    Path pythonPathToPythonTestMain = pyConfig.getPathToTestMain();


    Optional<Long> testRuleTimeoutMs = config.getLong("test", "rule_timeout");


    Optional<String> defaultMavenRepo = config.getValue("download", "maven_repo");
    boolean downloadAtRuntimeOk = config.getBooleanValue("download", "in_build", false);
    Downloader downloader;
    if (downloadAtRuntimeOk) {
      downloader = new HttpDownloader(Optional.<Proxy>absent(), defaultMavenRepo);
    } else {
      downloader = new ExplodingDownloader();
    }

    Builder builder = builder();

    JavaBuckConfig javaConfig = new JavaBuckConfig(config);
    JavacOptions defaultJavacOptions = javaConfig.getDefaultJavacOptions();
    JavacOptions androidBinaryOptions = JavacOptions.builder(defaultJavacOptions)
        .build();

    CxxBinaryDescription cxxBinaryDescription =
        new CxxBinaryDescription(
            cxxBuckConfig,
            defaultCxxPlatform,
            cxxPlatforms,
            cxxBuckConfig.getPreprocessMode());

    CxxLibraryDescription cxxLibraryDescription = new CxxLibraryDescription(
        cxxBuckConfig,
        cxxPlatforms,
        cxxBuckConfig.getPreprocessMode());

    AppleLibraryDescription appleLibraryDescription =
        new AppleLibraryDescription(
            cxxLibraryDescription,
            cxxPlatforms);
    builder.register(appleLibraryDescription);

    AppleBinaryDescription appleBinaryDescription =
        new AppleBinaryDescription(cxxBinaryDescription);
    builder.register(appleBinaryDescription);


    ListeningExecutorService dxExecutorService =
        MoreExecutors.listeningDecorator(
            Executors.newFixedThreadPool(
                SmartDexingStep.determineOptimalThreadCount(),
                new CommandThreadFactory("SmartDexing")));

    Supplier<ImmutableSet<CodeSignIdentity>> codeSignIdentitiesSupplier =
        AppleConfig.createCodeSignIdentitiesSupplier(processExecutor);

    builder.register(new AndroidAarDescription(new AndroidManifestDescription(), ndkCxxPlatforms));
    builder.register(
        new AndroidBinaryDescription(
            androidBinaryOptions,
            proGuardConfig,
            ndkCxxPlatforms,
            dxExecutorService));
    builder.register(new AndroidBuildConfigDescription(androidBinaryOptions));
    builder.register(new AndroidInstrumentationApkDescription(
            proGuardConfig,
            androidBinaryOptions,
            ndkCxxPlatforms,
            dxExecutorService));
    builder.register(new AndroidInstrumentationTestDescription(testRuleTimeoutMs));
    builder.register(new AndroidLibraryDescription(androidBinaryOptions));
    builder.register(new AndroidManifestDescription());
    builder.register(new AndroidPrebuiltAarDescription(androidBinaryOptions));
    builder.register(new AndroidReactNativeLibraryDescription(reactNativeBuckConfig));
    builder.register(new AndroidResourceDescription());
    builder.register(new ApkGenruleDescription());
    builder.register(new AppleAssetCatalogDescription());
    AppleBundleDescription appleBundleDescription =
        new AppleBundleDescription(
            appleBinaryDescription,
            appleLibraryDescription,
            cxxPlatforms,
            platformFlavorsToAppleCxxPlatforms,
            defaultCxxPlatform,
            codeSignIdentitiesSupplier.get());
    builder.register(appleBundleDescription);
    builder.register(new AppleResourceDescription());
    builder.register(
        new AppleTestDescription(
            appleConfig,
            appleBundleDescription,
            appleLibraryDescription,
            cxxPlatforms,
            platformFlavorsToAppleCxxPlatforms,
            defaultCxxPlatform,
            codeSignIdentitiesSupplier.get()));
    builder.register(new CoreDataModelDescription());
    builder.register(cxxBinaryDescription);
    builder.register(cxxLibraryDescription);
    builder.register(new CxxPythonExtensionDescription(cxxBuckConfig, cxxPlatforms));
    builder.register(new CxxTestDescription(cxxBuckConfig, defaultCxxPlatform, cxxPlatforms));
    builder.register(new DBinaryDescription(dBuckConfig));
    builder.register(new DLibraryDescription(dBuckConfig));
    builder.register(new DTestDescription(dBuckConfig));
    builder.register(new ExportFileDescription());
    builder.register(new GenruleDescription());
    builder.register(new GenAidlDescription());
    builder.register(new GwtBinaryDescription());
    builder.register(new IosReactNativeLibraryDescription(reactNativeBuckConfig));
    builder.register(new JavaBinaryDescription(defaultJavacOptions, defaultCxxPlatform));
    builder.register(new JavaLibraryDescription(defaultJavacOptions));
    builder.register(
        new JavaTestDescription(
            defaultJavacOptions,
            testRuleTimeoutMs,
            defaultCxxPlatform));
    builder.register(new KeystoreDescription());
    builder.register(new NdkLibraryDescription(ndkVersion, ndkCxxPlatforms));
    OCamlBuckConfig ocamlBuckConfig = new OCamlBuckConfig(platform, config);
    builder.register(new OCamlBinaryDescription(ocamlBuckConfig));
    builder.register(new OCamlLibraryDescription(ocamlBuckConfig));
    builder.register(new PrebuiltCxxLibraryDescription(cxxPlatforms));
    builder.register(new PrebuiltJarDescription());
    builder.register(new PrebuiltNativeLibraryDescription());
    builder.register(new PrebuiltOCamlLibraryDescription());
    builder.register(new PrebuiltPythonLibraryDescription());
    builder.register(new ProjectConfigDescription());
    builder.register(
        new PythonBinaryDescription(
            pyConfig.getPathToPex(),
            pyConfig.getPathToPexExecuter(),
            pyConfig.getPexExtension(),
            pythonEnv,
            defaultCxxPlatform,
            cxxPlatforms));
    builder.register(new PythonLibraryDescription());
    builder.register(
        new PythonTestDescription(
            projectFilesystem,
            pyConfig.getPathToPex(),
            pyConfig.getPathToPexExecuter(),
            pyConfig.getPexExtension(),
            pythonPathToPythonTestMain,
            pythonEnv,
            defaultCxxPlatform,
            cxxPlatforms));
    builder.register(new RemoteFileDescription(downloader));
    builder.register(new RobolectricTestDescription(
            androidBinaryOptions,
            testRuleTimeoutMs,
            defaultCxxPlatform));
    builder.register(new RustBinaryDescription(rustBuckConfig));
    builder.register(new RustLibraryDescription(rustBuckConfig));
    builder.register(new ShBinaryDescription());
    builder.register(new ShTestDescription());
    ThriftBuckConfig thriftBuckConfig = new ThriftBuckConfig(config);
    builder.register(
        new ThriftLibraryDescription(
            thriftBuckConfig,
            ImmutableList.of(
                new ThriftJavaEnhancer(thriftBuckConfig, defaultJavacOptions),
                new ThriftCxxEnhancer(
                    thriftBuckConfig,
                    cxxLibraryDescription,
 false),
                new ThriftCxxEnhancer(
                    thriftBuckConfig,
                    cxxLibraryDescription,
 true),
                new ThriftPythonEnhancer(thriftBuckConfig, ThriftPythonEnhancer.Type.NORMAL),
                new ThriftPythonEnhancer(thriftBuckConfig, ThriftPythonEnhancer.Type.TWISTED))));
    builder.register(new XcodePostbuildScriptDescription());
    builder.register(new XcodePrebuildScriptDescription());
    builder.register(new XcodeWorkspaceConfigDescription());

    builder.setCxxPlatforms(cxxPlatforms);
    builder.setDefaultCxxPlatform(defaultCxxPlatform);

    return builder;
  }

  public static class Builder {
    private final Map<BuildRuleType, Description<?>> descriptions;
    private final Map<String, BuildRuleType> types;

    @Nullable
    private FlavorDomain<CxxPlatform> cxxPlatforms;
    @Nullable
    private CxxPlatform defaultCxxPlatform;

    protected Builder() {
      this.descriptions = Maps.newConcurrentMap();
      this.types = Maps.newConcurrentMap();
    }

    public Builder register(Description<?> description) {
      BuildRuleType type = description.getBuildRuleType();
      types.put(type.getName(), type);
      descriptions.put(type, description);
      return this;
    }

    public Builder setCxxPlatforms(FlavorDomain<CxxPlatform> cxxPlatforms) {
      this.cxxPlatforms = cxxPlatforms;
      return this;
    }

    public Builder setDefaultCxxPlatform(CxxPlatform defaultCxxPlatform) {
      this.defaultCxxPlatform = defaultCxxPlatform;
      return this;
    }

    public KnownBuildRuleTypes build() {
      return new KnownBuildRuleTypes(
          descriptions,
          types,
          Preconditions.checkNotNull(cxxPlatforms),
          Preconditions.checkNotNull(defaultCxxPlatform));
    }
  }
}

<code block>


package com.facebook.buck.cli;

import com.facebook.buck.android.AdbHelper;
import com.facebook.buck.apple.AppleBundle;
import com.facebook.buck.apple.AppleConfig;
import com.facebook.buck.apple.AppleInfoPlistParsing;
import com.facebook.buck.apple.ApplePlatform;
import com.facebook.buck.apple.simulator.AppleCoreSimulatorServiceController;
import com.facebook.buck.apple.simulator.AppleSimulator;
import com.facebook.buck.apple.simulator.AppleSimulatorController;
import com.facebook.buck.apple.simulator.AppleSimulatorDiscovery;
import com.facebook.buck.cli.UninstallCommand.UninstallOptions;
import com.facebook.buck.command.Build;
import com.facebook.buck.event.BuckEventBus;
import com.facebook.buck.event.ConsoleEvent;
import com.facebook.buck.event.InstallEvent;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.ActionGraph;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.InstallableApk;
import com.facebook.buck.step.AdbOptions;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TargetDeviceOptions;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.ProcessExecutorParams;
import com.facebook.buck.util.UnixUserIdFetcher;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;

import org.kohsuke.args4j.Option;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.Nullable;


public class InstallCommand extends BuildCommand {

  private static final Logger LOG = Logger.get(InstallCommand.class);
  private static final long APPLE_SIMULATOR_WAIT_MILLIS = 20000;
  private static final ImmutableList<String> APPLE_SIMULATOR_APPS = ImmutableList.of(
      "Simulator.app",
      "iOS Simulator.app");
  private static final String DEFAULT_APPLE_SIMULATOR_NAME = "iPhone 5s";
  private static final InstallResult FAILURE = InstallResult.builder().setExitCode(1).build();

  @VisibleForTesting static final String RUN_LONG_ARG = "--run";
  @VisibleForTesting static final String RUN_SHORT_ARG = "-r";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_LONG_ARG = "--wait-for-debugger";
  @VisibleForTesting static final String WAIT_FOR_DEBUGGER_SHORT_ARG = "-w";
  @VisibleForTesting static final String INSTALL_VIA_SD_LONG_ARG = "--via-sd";
  @VisibleForTesting static final String INSTALL_VIA_SD_SHORT_ARG = "-S";
  @VisibleForTesting static final String ACTIVITY_LONG_ARG = "--activity";
  @VisibleForTesting static final String ACTIVITY_SHORT_ARG = "-a";
  @VisibleForTesting static final String UNINSTALL_LONG_ARG = "--uninstall";
  @VisibleForTesting static final String UNINSTALL_SHORT_ARG = "-u";

  @Option(
      name = UNINSTALL_LONG_ARG,
      aliases = { UNINSTALL_SHORT_ARG },
      usage = "Uninstall the existing version before installing.")
  private boolean uninstallFirst = false;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private UninstallOptions uninstallOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private AdbCommandLineOptions adbOptions;

  @AdditionalOptions
  @SuppressFieldNotInitialized
  private TargetDeviceCommandLineOptions deviceOptions;

  @Option(
      name = "--",
      usage = "Arguments passed when running with -r. Only valid for Apple targets.",
      handler = ConsumeAllOptionsHandler.class,
      depends = "-r")
  private List<String> runArgs = Lists.newArrayList();

  @Option(
      name = RUN_LONG_ARG,
      aliases = { RUN_SHORT_ARG },
      usage = "Run an activity (the default activity for package unless -a is specified).")
  private boolean run = false;

  @Option(
      name = WAIT_FOR_DEBUGGER_LONG_ARG,
      aliases = { WAIT_FOR_DEBUGGER_SHORT_ARG },
      usage = "Have the launched process wait for the debugger")
  private boolean waitForDebugger = false;

  @Option(
      name = INSTALL_VIA_SD_LONG_ARG,
      aliases = { INSTALL_VIA_SD_SHORT_ARG },
      usage = "Copy package to external storage (SD) instead of /data/local/tmp before installing.")
  private boolean installViaSd = false;

  @Option(
      name = ACTIVITY_LONG_ARG,
      aliases = { ACTIVITY_SHORT_ARG },
      metaVar = "<pkg/activity>",
      usage = "Activity to launch e.g. com.facebook.katana/.LoginActivity. Implies -r.")
  @Nullable
  private String activity = null;

  public AdbOptions adbOptions() {
    return adbOptions.getAdbOptions();
  }

  public TargetDeviceOptions targetDeviceOptions() {
    return deviceOptions.getTargetDeviceOptions();
  }

  public UninstallOptions uninstallOptions() {
    return uninstallOptions;
  }

  public boolean shouldUninstallFirst() {
    return uninstallFirst;
  }

  public boolean shouldStartActivity() {
    return (activity != null) || run;
  }

  public boolean shouldInstallViaSd() {
    return installViaSd;
  }

  @Nullable
  public String getActivityToStart() {
    return activity;
  }

  @Override
  public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {

    if (getArguments().size() != 1) {
      params.getConsole().getStdErr().println(
          "Must specify exactly one rule.");
      return 1;
    }


    int exitCode = super.runWithoutHelp(params);
    if (exitCode != 0) {
      return exitCode;
    }

    Build build = super.getBuild();
    ActionGraph graph = build.getActionGraph();
    BuildRule buildRule = Preconditions.checkNotNull(
        graph.findBuildRuleByTarget(getBuildTargets().get(0)));

    if (buildRule instanceof InstallableApk) {
      ExecutionContext.Builder builder = ExecutionContext.builder()
          .setExecutionContext(build.getExecutionContext())
          .setAdbOptions(Optional.<AdbOptions>of(adbOptions()))
          .setTargetDeviceOptions(Optional.<TargetDeviceOptions>of(targetDeviceOptions()));
      return installApk(
          params,
          (InstallableApk) buildRule,
          builder.build());
    } else if (buildRule instanceof AppleBundle) {
      AppleBundle appleBundle = (AppleBundle) buildRule;
      InstallEvent.Started started = InstallEvent.started(appleBundle.getBuildTarget());
      params.getBuckEventBus().post(started);
      InstallResult installResult = installAppleBundle(
          params,
          appleBundle,
          build.getExecutionContext().getProjectFilesystem(),
          build.getExecutionContext().getProcessExecutor());
      params.getBuckEventBus().post(InstallEvent.finished(
          started,
          installResult.getExitCode() == 0,
          installResult.getLaunchedPid()));
      return installResult.getExitCode();
    } else {
      params.getConsole().printBuildFailure(
          String.format(
              "Specified rule %s must be of type android_binary() or apk_genrule() or " +
                  "apple_bundle() but was %s().\n",
              buildRule.getFullyQualifiedName(),
              buildRule.getType()));
      return 1;
    }
  }

  private int installApk(
      CommandRunnerParams params,
      InstallableApk installableApk,
      ExecutionContext executionContext) throws IOException, InterruptedException {
    final AdbHelper adbHelper = AdbHelper.get(
        executionContext,
        params.getBuckConfig().getRestartAdbOnFailure());


    if (shouldUninstallFirst()) {
      String packageName = AdbHelper.tryToExtractPackageNameFromManifest(
          installableApk,
          executionContext);
      adbHelper.uninstallApp(packageName, uninstallOptions().shouldKeepUserData());

    }

    if (!adbHelper.installApk(installableApk, shouldInstallViaSd(), false)) {
      return 1;
    }



    if (shouldStartActivity()) {
      int exitCode = adbHelper.startActivity(installableApk, getActivityToStart());
      if (exitCode != 0) {
        return exitCode;
      }
    }

    return 0;
  }

  private InstallResult installAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor) throws IOException, InterruptedException {
    switch (appleBundle.getPlatformName()) {
      case ApplePlatform.Name.IPHONESIMULATOR:
        return installAppleBundleForSimulator(params, appleBundle, projectFilesystem,
            processExecutor);

      default:
        params.getConsole().printBuildFailure("Install not yet supported for platform " +
            appleBundle.getPlatformName() + ".");
        return FAILURE;
    }
  }

  private InstallResult installAppleBundleForSimulator(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      ProjectFilesystem projectFilesystem,
      ProcessExecutor processExecutor) throws IOException, InterruptedException {


    AppleConfig appleConfig = new AppleConfig(params.getBuckConfig());
    Optional<Path> xcodeDeveloperPath = appleConfig.getAppleDeveloperDirectorySupplier(
        processExecutor).get();
    if (!xcodeDeveloperPath.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (Xcode not found)", appleBundle.getFullyQualifiedName()));
      return FAILURE;
    }

    UnixUserIdFetcher userIdFetcher = new UnixUserIdFetcher();
    AppleCoreSimulatorServiceController appleCoreSimulatorServiceController =
        new AppleCoreSimulatorServiceController(processExecutor);

    Optional<Path> coreSimulatorServicePath =
        appleCoreSimulatorServiceController.getCoreSimulatorServicePath(userIdFetcher);

    boolean shouldWaitForSimulatorsToShutdown = false;

    if (!coreSimulatorServicePath.isPresent() ||
        !coreSimulatorServicePath.get().toRealPath().startsWith(
            xcodeDeveloperPath.get().toRealPath())) {
      LOG.warn(
          "Core simulator service path %s does not match developer directory %s, " +
          "killing all simulators.",
          coreSimulatorServicePath,
          xcodeDeveloperPath.get());
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return FAILURE;
      }

      shouldWaitForSimulatorsToShutdown = true;
    }

    Path simctlPath = xcodeDeveloperPath.get().resolve("usr/bin/simctl");
    Optional<AppleSimulator> appleSimulator = getAppleSimulatorForBundle(
        appleBundle,
        processExecutor,
        simctlPath);

    if (!appleSimulator.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (no appropriate simulator found)",
              appleBundle.getFullyQualifiedName()));
      return FAILURE;
    }

    Path iosSimulatorPath = null;
    Path xcodeApplicationsPath = xcodeDeveloperPath.get().resolve("Applications");
    for (String simulatorApp : APPLE_SIMULATOR_APPS) {
      Path resolvedSimulatorPath = xcodeApplicationsPath.resolve(simulatorApp);
      if (projectFilesystem.isDirectory(resolvedSimulatorPath)) {
        iosSimulatorPath = resolvedSimulatorPath;
        break;
      }
    }

    if (iosSimulatorPath == null) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not find simulator under %s, checked %s)",
              appleBundle.getFullyQualifiedName(),
              xcodeApplicationsPath,
              APPLE_SIMULATOR_APPS));
      return FAILURE;
    }

    AppleSimulatorController appleSimulatorController = new AppleSimulatorController(
        processExecutor,
        simctlPath,
        iosSimulatorPath);

    if (!appleSimulatorController.canStartSimulator(appleSimulator.get().getUdid())) {
      LOG.warn("Cannot start simulator %s, killing simulators and trying again.");
      if (!appleCoreSimulatorServiceController.killSimulatorProcesses()) {
        params.getConsole().printBuildFailure("Could not kill running simulator processes.");
        return FAILURE;
      }

      shouldWaitForSimulatorsToShutdown = true;


      appleSimulator = getAppleSimulatorForBundle(appleBundle, processExecutor, simctlPath);
      if (!appleSimulator.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (no appropriate simulator found)",
                appleBundle.getFullyQualifiedName()));
        return FAILURE;
      }
    }

    long remainingMillis = APPLE_SIMULATOR_WAIT_MILLIS;
    if (shouldWaitForSimulatorsToShutdown) {
      Optional<Long> shutdownMillis = appleSimulatorController.waitForSimulatorsToShutdown(
          remainingMillis);
      if (!shutdownMillis.isPresent()) {
        params.getConsole().printBuildFailure(
            String.format(
                "Cannot install %s (simulators did not shut down within %d ms).",
                appleBundle.getFullyQualifiedName(),
                APPLE_SIMULATOR_WAIT_MILLIS));
        return FAILURE;
      }

      LOG.debug("Simulators shut down in %d millis.", shutdownMillis.get());
      remainingMillis -= shutdownMillis.get();
    }

    LOG.debug("Starting up simulator %s", appleSimulator.get());

    Optional<Long> startMillis = appleSimulatorController.startSimulator(
        appleSimulator.get().getUdid(),
        remainingMillis);

    if (!startMillis.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not start simulator %s within %d ms)",
              appleBundle.getFullyQualifiedName(),
              appleSimulator.get().getName(),
              APPLE_SIMULATOR_WAIT_MILLIS));
      return FAILURE;
    }

    LOG.debug(
        "Simulator started in %d ms. Installing Apple bundle %s in simulator %s",
        startMillis.get(),
        appleBundle,
        appleSimulator.get());

    if (!appleSimulatorController.installBundleInSimulator(
            appleSimulator.get().getUdid(),
            projectFilesystem.resolve(Preconditions.checkNotNull(appleBundle.getPathToOutput())))) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not install bundle %s in simulator %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getPathToOutput(),
              appleSimulator.get().getName()));
      return FAILURE;
    }

    if (ReactNativeFlavors.skipBundling(appleBundle.getBuildTarget())) {
      ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(params.getBuckConfig());
      if (buckConfig.getServer().isPresent()) {
        int exitCode = launchReactNativeServer(
            processExecutor,
            projectFilesystem.resolve(buckConfig.getServer().get()),
            params.getBuckEventBus());
        if (exitCode != 0) {
          return InstallResult.builder().setExitCode(exitCode).build();
        }
      }
    }

    if (run) {
      return launchAppleBundle(
          params,
          appleBundle,
          appleSimulatorController,
          projectFilesystem,
          appleSimulator.get());
    } else {
      params.getBuckEventBus().post(
          ConsoleEvent.info(
              params.getConsole().getAnsi().asHighlightedSuccessText(
                  "Successfully installed %s. (Use `buck install -r %s` to run.)"),
              getArguments().get(0),
              getArguments().get(0)));
      return InstallResult.builder().setExitCode(0).build();
    }
  }

  private InstallResult launchAppleBundle(
      CommandRunnerParams params,
      AppleBundle appleBundle,
      AppleSimulatorController appleSimulatorController,
      ProjectFilesystem projectFilesystem,
      AppleSimulator appleSimulator) throws IOException, InterruptedException {

    LOG.debug("Launching Apple bundle %s in simulator %s", appleBundle, appleSimulator);

    Optional<String> appleBundleId;
    try (InputStream bundlePlistStream =
             projectFilesystem.getInputStreamForRelativePath(appleBundle.getInfoPlistPath())){
        appleBundleId = AppleInfoPlistParsing.getBundleIdFromPlistStream(bundlePlistStream);
    }
    if (!appleBundleId.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot install %s (could not get bundle ID from %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundle.getInfoPlistPath()));
      return FAILURE;
    }

    Optional<Long> launchedPid = appleSimulatorController.launchInstalledBundleInSimulator(
        appleSimulator.getUdid(),
        appleBundleId.get(),
        waitForDebugger ? AppleSimulatorController.LaunchBehavior.WAIT_FOR_DEBUGGER :
            AppleSimulatorController.LaunchBehavior.DO_NOT_WAIT_FOR_DEBUGGER,
        runArgs);
    if (!launchedPid.isPresent()) {
      params.getConsole().printBuildFailure(
          String.format(
              "Cannot launch %s (failed to launch bundle ID %s)",
              appleBundle.getFullyQualifiedName(),
              appleBundleId.get()));
      return FAILURE;
    }

    params.getBuckEventBus().post(
        ConsoleEvent.info(
            params.getConsole().getAnsi().asHighlightedSuccessText(
                "Successfully launched %s%s. To debug, run: lldb -p %d"),
            getArguments().get(0),
            waitForDebugger ? " (waiting for debugger)" : "",
            launchedPid.get()));

    return InstallResult.builder().setExitCode(0).setLaunchedPid(launchedPid.get()).build();
  }

  private Optional<AppleSimulator> getAppleSimulatorForBundle(
      AppleBundle appleBundle,
      ProcessExecutor processExecutor,
      Path simctlPath) throws IOException, InterruptedException {
    LOG.debug("Choosing simulator for %s", appleBundle);

    Optional<AppleSimulator> simulatorByUdid = Optional.absent();
    Optional<AppleSimulator> simulatorByName = Optional.absent();
    Optional<AppleSimulator> defaultSimulator = Optional.absent();

    boolean wantUdid = deviceOptions.hasSerialNumber();
    boolean wantName = deviceOptions.getSimulatorName().isPresent();

    for (AppleSimulator simulator : AppleSimulatorDiscovery.discoverAppleSimulators(
             processExecutor,
             simctlPath)) {
      if (wantUdid &&
          deviceOptions.getSerialNumber().toLowerCase(Locale.US).equals(
              simulator.getUdid().toLowerCase(Locale.US))) {
        LOG.debug("Got UDID match (%s): %s", deviceOptions.getSerialNumber(), simulator);
        simulatorByUdid = Optional.of(simulator);

        break;
      } else if (wantName &&
                 deviceOptions.getSimulatorName().get().toLowerCase(Locale.US).equals(
                     simulator.getName().toLowerCase(Locale.US))) {
        LOG.debug("Got name match (%s): %s", simulator.getName(), simulator);
        simulatorByName = Optional.of(simulator);


      } else if (simulator.getName().equals(DEFAULT_APPLE_SIMULATOR_NAME)) {
        LOG.debug("Got default match (%s): %s", DEFAULT_APPLE_SIMULATOR_NAME, simulator);
        defaultSimulator = Optional.of(simulator);
      }
    }

    if (wantUdid) {
      if (simulatorByUdid.isPresent()) {
        return simulatorByUdid;
      } else {
        LOG.warn(
            "Asked to find simulator with UDID %s, but couldn't find one.",
            deviceOptions.getSerialNumber());
        return Optional.<AppleSimulator>absent();
      }
    } else if (wantName) {
      if (simulatorByName.isPresent()) {
        return simulatorByName;
      } else {
        LOG.warn(
            "Asked to find simulator with name %s, but couldn't find one.",
            deviceOptions.getSimulatorName().get());
        return Optional.<AppleSimulator>absent();
      }
    } else {
      return defaultSimulator;
    }
  }

  private int launchReactNativeServer(
      ProcessExecutor processExecutor,
      Path reactNativeServerInitScript,
      BuckEventBus eventBus) throws IOException, InterruptedException {
    ProcessExecutorParams processExecutorParams =
        ProcessExecutorParams.builder()
            .setCommand(ImmutableList.of(reactNativeServerInitScript.toString()))
            .build();
    Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
    ProcessExecutor.Result result = processExecutor.launchAndExecute(
        processExecutorParams,
        options,
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
    LOG.debug("React Native server: %s", result.getStdout());
    if (result.getExitCode() != 0) {
      eventBus.post(ConsoleEvent.severe(
              "Error starting the RN server: %s", result.getStderr().or("")));
    }
    return result.getExitCode();
  }

  @Override
  public String getShortDescription() {
    return "builds and installs an application";
  }

  @Override
  public boolean isReadOnly() {
    return false;
  }

}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.emptyString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableMap;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;


public class InfoPlistSubstitutionTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void emptyStringReplacementIsEmpty() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "",
            ImmutableMap.<String, String>of()),
        is(emptyString()));
  }

  @Test
  public void emptyMapLeavesStringAsIs() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello world"));
  }

  @Test
  public void curlyBracesAreSubstituted() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO} world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void parensAreSubstituted() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO) world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void unknownModifiersAreIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO:bar) world",
            ImmutableMap.of("FOO", "cruel")),
        equalTo("Hello cruel world"));
  }

  @Test
  public void multipleMatchesAreReplaced() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO) $(BAR) world",
            ImmutableMap.of(
                "FOO", "cruel",
                "BAR", "mean")),
        equalTo("Hello cruel mean world"));
  }

  @Test
  public void unrecognizedVariableThrows() {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage("Unrecognized plist variable: ${XYZZY:blurgh}");
    InfoPlistSubstitution.replaceVariablesInString(
        "Hello ${XYZZY:blurgh} world",
        ImmutableMap.<String, String>of());
  }

  @Test
  public void recursiveVariableThrows() {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage("Recursive plist variable: FOO -> BAR -> BAZ -> FOO");
    InfoPlistSubstitution.replaceVariablesInString(
        "Hello ${FOO}",
        ImmutableMap.<String, String>of(
            "FOO", "${BAR}",
            "BAR", "${BAZ}",
            "BAZ", "${FOO}"));
  }

  @Test
  public void mismatchedParenIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello $(FOO} world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello $(FOO} world"));
  }

  @Test
  public void mismatchedBraceIgnored() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO) world",
            ImmutableMap.<String, String>of()),
        equalTo("Hello ${FOO) world"));
  }

  @Test
  public void replacementWithMatcherAppendReplacementSpecialChars() {
    assertThat(
        InfoPlistSubstitution.replaceVariablesInString(
            "Hello ${FOO} world",
            ImmutableMap.of(
                "FOO", "${BAZ}",
                "BAZ", "$BAR")),
        equalTo("Hello $BAR world"));
  }

  @Test
  public void testVariableExpansionForPlatform() {
    assertThat(
        InfoPlistSubstitution.getVariableExpansionForPlatform("FOO",
            "iphoneos",
            ImmutableMap.of(
                "FOO", "BAR",
                "FOO[sdk=iphoneos]", "BARiphoneos",
                "FOO[sdk=iphonesimulator]", "BARiphonesimulator")),
        equalTo(Optional.of("BARiphoneos")));
  }

  @Test
  public void testVariableExpansionForPlatformWithUnknownKey() {
    assertThat(
        InfoPlistSubstitution.getVariableExpansionForPlatform("BAZ",
            "iphoneos",
            ImmutableMap.of(
                "FOO", "BAR",
                "FOO[sdk=iphoneos]", "BARiphoneos",
                "FOO[sdk=iphonesimulator]", "BARiphonesimulator")),
        equalTo(Optional.<String>absent()));
  }

  @Test
  public void testVariableExpansionForPlatformWithUnknownPlatform() {
    assertThat(
        InfoPlistSubstitution.getVariableExpansionForPlatform("FOO",
            "baz",
            ImmutableMap.of(
                "FOO", "BAR",
                "FOO[sdk=iphoneos]", "BARiphoneos",
                "FOO[sdk=iphonesimulator]", "BARiphonesimulator")),
        equalTo(Optional.of("BAR")));
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxBinaryDescription;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxLibraryDescription;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.DefaultCxxPlatforms;
import com.facebook.buck.io.FakeExecutableFinder;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.util.environment.Platform;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Paths;


public class FakeAppleRuleDescriptions {

  private FakeAppleRuleDescriptions() { }

  private static final AppleSdkPaths DEFAULT_IPHONEOS_SDK_PATHS =
      AppleSdkPaths.builder()
          .setDeveloperPath(Paths.get("."))
          .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
          .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
          .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
          .build();

  private static final AppleSdk DEFAULT_IPHONEOS_SDK =
      AppleSdk.builder()
          .setApplePlatform(
              ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
          .setName("iphoneos")
          .setVersion("8.0")
          .setToolchains(ImmutableList.<AppleToolchain>of())
          .build();

  private static final AppleCxxPlatform DEFAULT_IPHONEOS_PLATFORM =
      AppleCxxPlatforms.buildWithExecutableChecker(
          DEFAULT_IPHONEOS_SDK,
          "8.0",
          "i386",
          DEFAULT_IPHONEOS_SDK_PATHS,
          new FakeBuckConfig(),
          new FakeExecutableFinder(
              ImmutableSet.of(
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"),
                  Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"),
                  Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"),
                  Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"),
                  Paths.get("usr/bin/actool"),
                  Paths.get("usr/bin/ibtool"),
                  Paths.get("Tools/otest"),
                  Paths.get("usr/bin/xctest"))));

  private static final BuckConfig DEFAULT_BUCK_CONFIG = new FakeBuckConfig();

  private static final CxxPlatform DEFAULT_PLATFORM = DefaultCxxPlatforms.build(
      Platform.MACOS,
      new CxxBuckConfig(DEFAULT_BUCK_CONFIG));

  private static final FlavorDomain<CxxPlatform> DEFAULT_IPHONEOS_FLAVOR_DOMAIN =
      new FlavorDomain<>(
          "Fake iPhone C/C++ Platform",
          ImmutableMap.of(
              DEFAULT_PLATFORM.getFlavor(),
              DEFAULT_PLATFORM,
              DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform().getFlavor(),
              DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform()));

  private static final ImmutableMap<Flavor, AppleCxxPlatform>
    DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS =
      ImmutableMap.of(
          DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform().getFlavor(),
          DEFAULT_IPHONEOS_PLATFORM);


  public static final AppleLibraryDescription LIBRARY_DESCRIPTION =
    new AppleLibraryDescription(
        new CxxLibraryDescription(
            new CxxBuckConfig(DEFAULT_BUCK_CONFIG),
            DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
            CxxPreprocessMode.COMBINED),
        DEFAULT_IPHONEOS_FLAVOR_DOMAIN);


  public static final AppleBinaryDescription BINARY_DESCRIPTION =
    new AppleBinaryDescription(
        new CxxBinaryDescription(
            new CxxBuckConfig(DEFAULT_BUCK_CONFIG),
            DEFAULT_IPHONEOS_PLATFORM.getCxxPlatform(),
            DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
            CxxPreprocessMode.COMBINED));


  public static final AppleBundleDescription BUNDLE_DESCRIPTION =
      new AppleBundleDescription(
          BINARY_DESCRIPTION,
          LIBRARY_DESCRIPTION,
          DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
          DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS,
          DEFAULT_PLATFORM,
          ImmutableSet.<CodeSignIdentity>of(CodeSignIdentity.AD_HOC));


  public static final AppleTestDescription TEST_DESCRIPTION =
      new AppleTestDescription(
          new FakeAppleConfig(),
          BUNDLE_DESCRIPTION,
          LIBRARY_DESCRIPTION,
          DEFAULT_IPHONEOS_FLAVOR_DOMAIN,
          DEFAULT_PLATFORM_FLAVORS_TO_APPLE_CXX_PLATFORMS,
          DEFAULT_PLATFORM,
          ImmutableSet.<CodeSignIdentity>of(CodeSignIdentity.AD_HOC));
}

<code block>


package com.facebook.buck.apple;

import static org.junit.Assert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;

import com.dd.plist.NSDate;
import com.facebook.buck.model.Pair;
import com.facebook.buck.testutil.integration.TestDataHelper;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.nio.file.Path;


public class ProvisioningProfileMetadataTest {
  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void testParseProvisioningProfileFile() throws Exception {
    Path testdataDir = TestDataHelper.getTestDataDirectory(this).resolve("provisioning_profiles");
    Path testFile = testdataDir.resolve("sample.mobileprovision");

    ProvisioningProfileMetadata data = ProvisioningProfileMetadata.fromProvisioningProfilePath(
        testFile);

    assertThat(data.getExpirationDate(), is(equalTo(new NSDate("9999-03-05T01:33:40Z").getDate())));
    assertThat(data.getAppID(), is(equalTo(new Pair<>("ABCDE12345", "com.example.TestApp"))));
    assertThat(data.getUUID(), is(equalTo("00000000-0000-0000-0000-000000000000")));
    assertThat(data.getProfilePath().get(), is(equalTo(testFile)));

    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Malformed .mobileprovision file (could not find embedded plist)");
    ProvisioningProfileMetadata.fromProvisioningProfilePath(
        testdataDir.resolve("invalid.mobileprovision"));
  }

  @Test
  public void testSplitAppID() throws Exception {
    Pair<String, String> result;

    result = ProvisioningProfileMetadata.splitAppID("ABCDE12345.com.example.TestApp");
    assertThat(result, is(equalTo(new Pair<>("ABCDE12345", "com.example.TestApp"))));

    result = ProvisioningProfileMetadata.splitAppID("ABCDE12345.*");
    assertThat(result, is(equalTo(new Pair<>("ABCDE12345", "*"))));

    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Malformed app ID: invalid.");
    ProvisioningProfileMetadata.splitAppID("invalid.");
  }
}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.util.HumanReadableException;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Date;

public class ProvisioningProfileCopyStepTest {
private Path testdataDir;
private Path tempOutputDir;
private Path outputFile;
private Path xcentFile;
private ProjectFilesystem projectFilesystem;
private ExecutionContext executionContext;

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws IOException {
    testdataDir = TestDataHelper.getTestDataDirectory(this).resolve("provisioning_profiles");
    projectFilesystem = new FakeProjectFilesystem(testdataDir.toFile());
    DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();
    tmp.create();
    tempOutputDir = tmp.getRootPath();
    outputFile = tempOutputDir.resolve("embedded.mobileprovision");
    xcentFile = tempOutputDir.resolve("test.xcent");
    executionContext = TestExecutionContext
        .newBuilder()
        .setProjectFilesystem(projectFilesystem)
        .build();
  }

  private static ProvisioningProfileMetadata makeTestMetadata(
    String appID, Date expirationDate, String uuid) throws Exception {
    return ProvisioningProfileMetadata.builder()
        .setAppID(ProvisioningProfileMetadata.splitAppID(appID))
        .setExpirationDate(expirationDate)
        .setUUID(uuid)
        .build();
  };

  @Test
  public void testExpiredProfilesAreIgnored() throws Exception {
    ImmutableSet<ProvisioningProfileMetadata> profiles =
        ImmutableSet.<ProvisioningProfileMetadata>of(
            makeTestMetadata("AAAAAAAAAA.*", new Date(0), "00000000-0000-0000-0000-000000000000")
        );

    Optional<ProvisioningProfileMetadata> actual =
        ProvisioningProfileCopyStep.getBestProvisioningProfile(
            profiles, "com.facebook.test", Optional.<String>absent(), Optional.<String>absent());

    assertThat(actual, is(equalTo(Optional.<ProvisioningProfileMetadata>absent())));
  }

  @Test
  public void testPrefixOverride() throws Exception {
    ProvisioningProfileMetadata expected =
        makeTestMetadata("AAAAAAAAAA.*", new Date(Long.MAX_VALUE),
            "00000000-0000-0000-0000-000000000000");

    ImmutableSet<ProvisioningProfileMetadata> profiles =
        ImmutableSet.<ProvisioningProfileMetadata>of(
            expected,
            makeTestMetadata("BBBBBBBBBB.com.facebook.test", new Date(Long.MAX_VALUE),
                "00000000-0000-0000-0000-000000000000")
        );

    Optional<ProvisioningProfileMetadata> actual =
        ProvisioningProfileCopyStep.getBestProvisioningProfile(
            profiles, "com.facebook.test", Optional.<String>absent(),
            Optional.<String>of("AAAAAAAAAA"));

    assertThat(actual.get(), is(equalTo(expected)));
  }

  @Test
  public void testUUIDOverride() throws Exception {
    ProvisioningProfileMetadata expected =
        makeTestMetadata("BBBBBBBBBB.*", new Date(Long.MAX_VALUE),
            "11111111-1111-1111-1111-111111111111");

    ImmutableSet<ProvisioningProfileMetadata> profiles =
        ImmutableSet.<ProvisioningProfileMetadata>of(
            expected,
            makeTestMetadata("BBBBBBBBBB.com.facebook.test", new Date(Long.MAX_VALUE),
                "00000000-0000-0000-0000-000000000000")
        );

    Optional<ProvisioningProfileMetadata> actual =
        ProvisioningProfileCopyStep.getBestProvisioningProfile(
            profiles, "com.facebook.test",
            Optional.<String>of("11111111-1111-1111-1111-111111111111"),
            Optional.<String>absent());

    assertThat(actual.get(), is(equalTo(expected)));
  }

  @Test
  public void testMatchesSpecificApp() throws Exception {
    ProvisioningProfileMetadata expected =
        makeTestMetadata("BBBBBBBBBB.com.facebook.test", new Date(Long.MAX_VALUE),
            "00000000-0000-0000-0000-000000000000");

    ImmutableSet<ProvisioningProfileMetadata> profiles =
        ImmutableSet.<ProvisioningProfileMetadata>of(
            expected,
            makeTestMetadata("BBBBBBBBBB.com.facebook.*", new Date(Long.MAX_VALUE),
                "11111111-1111-1111-1111-111111111111")
        );

    Optional<ProvisioningProfileMetadata> actual =
        ProvisioningProfileCopyStep.getBestProvisioningProfile(
            profiles, "com.facebook.test",
            Optional.<String>absent(),
            Optional.<String>absent());

    assertThat(actual.get(), is(equalTo(expected)));
  }

  @Test
  public void testMatchesWildcard() throws Exception {
    ProvisioningProfileMetadata expected =
        makeTestMetadata("BBBBBBBBBB.*", new Date(Long.MAX_VALUE),
            "00000000-0000-0000-0000-000000000000");

    ImmutableSet<ProvisioningProfileMetadata> profiles =
        ImmutableSet.<ProvisioningProfileMetadata>of(
            expected
        );

    Optional<ProvisioningProfileMetadata> actual =
        ProvisioningProfileCopyStep.getBestProvisioningProfile(
            profiles, "com.facebook.test",
            Optional.<String>absent(),
            Optional.<String>absent());

    assertThat(actual.get(), is(equalTo(expected)));
  }

  @Test
  public void testFailsWithInvalidEntitlementsPlist() throws Exception {
    thrown.expect(HumanReadableException.class);

    ProvisioningProfileCopyStep step = new ProvisioningProfileCopyStep(
        testdataDir.resolve("Info.plist"),
        Optional.<String>absent(),
        Optional.<Path>of(testdataDir.resolve("Invalid.plist")),
        ProvisioningProfileCopyStep.findProfilesInPath(testdataDir),
        outputFile,
        xcentFile
    );

    step.execute(executionContext);
  }

  @Test
  public void testFailsWithInvalidInfoPlist() throws Exception {
    thrown.expect(HumanReadableException.class);

    ProvisioningProfileCopyStep step = new ProvisioningProfileCopyStep(
        testdataDir.resolve("Invalid.plist"),
        Optional.<String>absent(),
        Optional.<Path>absent(),
        ProvisioningProfileCopyStep.findProfilesInPath(testdataDir),
        outputFile,
        xcentFile
    );

    step.execute(executionContext);
  }
}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.environment.Platform;
import com.facebook.buck.util.HumanReadableException;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class AppleBundleIntegrationTest {

  private static final int numCodeSigningIdentities =
      AppleConfig.createCodeSignIdentitiesSupplier(
        new ProcessExecutor(new TestConsole())).get().size();

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  private boolean checkCodeSigning(ProjectWorkspace workspace, String relativeBundlePath)
      throws IOException, InterruptedException {
    String absoluteBundlePath = tmp.getRootPath()
        .resolve(BuckConstant.GEN_DIR)
        .resolve(Paths.get(relativeBundlePath))
        .toString();

    ProcessExecutor.Result result = workspace.runCommand("codesign", "-vvvv", absoluteBundlePath);
    if (result.getExitCode() != 0) {
      return false;
    }

    if (result.getStderr().isPresent()) {
      return result.getStderr().get().contains(": satisfies its Designated Requirement");
    } else {
      return false;
    }
  }

  @Test
  public void simpleApplicationBundle() throws IOException, InterruptedException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));

    assertFalse(checkCodeSigning(workspace, "DemoApp#iphonesimulator-x86_64/DemoApp.app"));
  }

  @Test
  public void simpleApplicationBundleWithCodeSigning() throws IOException, InterruptedException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    assumeTrue(numCodeSigningIdentities > 0);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle_with_codesigning",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphoneos-arm64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphoneos-arm64/DemoApp.app/DemoApp")));

    assertTrue(checkCodeSigning(workspace, "DemoApp#iphoneos-arm64/DemoApp.app"));
  }

  @Test
  public void simpleApplicationBundleWithCodeSigningAndEntitlements()
      throws IOException, InterruptedException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    assumeTrue(numCodeSigningIdentities > 0);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle_with_codesigning_and_entitlements",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphoneos-arm64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphoneos-arm64/DemoApp.app/DemoApp")));

    assertTrue(checkCodeSigning(workspace, "DemoApp#iphoneos-arm64/DemoApp.app"));
  }

  @Test
  public void bundleHasOutputPath() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace
        .runBuckCommand("targets", "--show-output", "//:DemoApp");
    result.assertSuccess();
    assertEquals("//:DemoApp buck-out/gen/DemoApp/DemoApp.app", result.getStdout().trim());
  }

  @Test
  public void bundleBinaryHasDsymBundle() throws IOException, InterruptedException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "simple_application_bundle",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    Path bundlePath = tmp.getRootPath()
        .resolve(BuckConstant.GEN_DIR)
        .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app");
    Path dwarfPath = bundlePath.resolve("DemoApp.dSYM/Contents/Resources/DWARF/DemoApp");
    Path binaryPath = bundlePath.resolve("DemoApp");
    assertTrue(Files.exists(dwarfPath));
    String dwarfdumpMainStdout =
        workspace.runCommand("dwarfdump", "-n", "main", dwarfPath.toString()).getStdout().or("");
    assertTrue(dwarfdumpMainStdout.contains("AT_name"));
    assertTrue(dwarfdumpMainStdout.contains("AT_decl_file"));
    assertTrue(dwarfdumpMainStdout.contains("AT_decl_line"));

    ProcessExecutor.Result result = workspace.runCommand(
        "dsymutil",
        "-o",
        binaryPath.toString() + ".test.dSYM",
        binaryPath.toString());
    assertThat(result.getStdout().isPresent(), is(true));
    assertThat(result.getStdout().get(), containsString("warning: no debug symbols in executable"));
  }

  @Test
  public void appBundleWithResources() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_resources",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();
  }

  @Test
  public void appBundleVariantDirectoryMustEndInLproj() throws IOException {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "Variant files have to be in a directory with name ending in '.lproj', " +
            "but 'cc/Localizable.strings' is not.");

    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_invalid_variant",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertFailure();
  }

  @Test
  public void defaultPlatformInBuckConfig() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "default_platform_in_buckconfig_app_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/DemoApp")));
  }

  @Test
  public void defaultPlatformInBuckConfigWithFlavorSpecified() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "default_platform_in_buckconfig_flavored_app_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));
  }

  @Test
  public void appleAssetCatalogsAreIncludedInBundle() throws IOException{
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "apple_asset_catalogs_are_included_in_bundle",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp").assertSuccess();

    System.err.println(tmp.getRootPath());
    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets.car")));
    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets1.bundle/Image1.png")));
    assertFalse(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets2.bundle/Image2.png")));
    assertFalse(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp/DemoApp.app/Assets3.bundle/Image3.png")));

    workspace.verify();
  }

  @Test
  public void infoPlistSubstitutionsAreApplied() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "application_bundle_with_substitutions",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/DemoApp")));
  }

  @Test
  public void infoPlistWithUnrecognizedVariableFails() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "application_bundle_with_invalid_substitutions",
        tmp);
    workspace.setUp();

    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertFailure();
  }

  @Test
  public void xibIsCompiledToNib() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "app_bundle_with_xib",
        tmp);
    workspace.setUp();
    workspace.runBuckCommand("build", "//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    assertTrue(
        Files.exists(
            tmp.getRootPath()
                .resolve(BuckConstant.GEN_DIR)
                .resolve("DemoApp#iphonesimulator-x86_64/DemoApp.app/AppViewController.nib")));
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.log.Logger;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.FunctionLineProcessorThread;
import com.facebook.buck.util.MoreThrowables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class CxxPreprocessAndCompileStep implements Step {

  private static final Logger LOG = Logger.get(CxxPreprocessAndCompileStep.class);

  private final Operation operation;
  private final Path output;
  private final Path input;
  private final CxxSource.Type inputType;
  private final Optional<ImmutableList<String>> preprocessorCommand;
  private final Optional<ImmutableList<String>> compilerCommand;
  private final ImmutableMap<Path, Path> replacementPaths;
  private final DebugPathSanitizer sanitizer;
  private final Optional<Function<String, Iterable<String>>> extraLineProcessor;



  private static final ImmutableSet<String> SPECIAL_INCLUDE_PATHS = ImmutableSet.of(
      "<built-in>",
      "<command-line>"
  );

  public CxxPreprocessAndCompileStep(
      Operation operation,
      Path output,
      Path input,
      CxxSource.Type inputType,
      Optional<ImmutableList<String>> preprocessorCommand,
      Optional<ImmutableList<String>> compilerCommand,
      ImmutableMap<Path, Path> replacementPaths,
      DebugPathSanitizer sanitizer,
      Optional<Function<String, Iterable<String>>> extraLineProcessor) {
    Preconditions.checkState(operation.isPreprocess() == preprocessorCommand.isPresent());
    Preconditions.checkState(operation.isCompile() == compilerCommand.isPresent());
    this.operation = operation;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.preprocessorCommand = preprocessorCommand;
    this.compilerCommand = compilerCommand;
    this.replacementPaths = replacementPaths;
    this.sanitizer = sanitizer;
    this.extraLineProcessor = extraLineProcessor;
  }

  @Override
  public String getShortName() {
    Optional<CxxSource.Type> type = CxxSource.Type.fromExtension(
        Files.getFileExtension(input.getFileName().toString()));
    String fileType;
    if (type.isPresent()) {
      fileType = type.get().getLanguage();
    } else {
      fileType = "unknown";
    }
    return fileType + " " + operation.toString().toLowerCase();
  }

  @VisibleForTesting
  Function<String, Iterable<String>> createPreprocessOutputLineProcessor(final Path workingDir) {
    return new Function<String, Iterable<String>>() {

      private final Pattern lineMarkers =
          Pattern.compile("^# (?<num>\\d+) \"(?<path>[^\"]+)\"(?<rest>.*)?$");

      @Override
      public Iterable<String> apply(String line) {
        if (line.startsWith("# ")) {
          Matcher m = lineMarkers.matcher(line);

          if (m.find() && !SPECIAL_INCLUDE_PATHS.contains(m.group("path"))) {
            String originalPath = m.group("path");
            String replacementPath = originalPath;

            replacementPath = Optional
                .fromNullable(replacementPaths.get(Paths.get(replacementPath)))
                .transform(Escaper.PATH_FOR_C_INCLUDE_STRING_ESCAPER)
                .or(replacementPath);

            replacementPath =
                sanitizer.sanitize(
                    Optional.of(workingDir),
                    replacementPath,
 false);

            if (!originalPath.equals(replacementPath)) {
              String num = m.group("num");
              String rest = m.group("rest");
              return ImmutableList.of("# " + num + " \"" + replacementPath + "\"" + rest);
            }
          }

          return ImmutableList.of(line);
        }

        if (extraLineProcessor.isPresent()) {
          return extraLineProcessor.get().apply(line);
        }

        return ImmutableList.of(line);
      }
    };
  }

  @VisibleForTesting
  Function<String, Iterable<String>> createErrorLineProcessor(final Path workingDir) {
    return CxxDescriptionEnhancer.createErrorMessagePathProcessor(
        new Function<String, String>() {
          @Override
          public String apply(String original) {
            Path path = Paths.get(original);



            if (operation == Operation.COMPILE) {
              path = Paths.get(sanitizer.restore(Optional.of(workingDir), original));
            }


            return Optional
                .fromNullable(replacementPaths.get(path))
                .transform(Escaper.PATH_FOR_C_INCLUDE_STRING_ESCAPER)
                .or(Escaper.escapePathForCIncludeString(path));
          }
        });
  }


  private ProcessBuilder makeSubprocessBuilder(ExecutionContext context) {
    ProcessBuilder builder = new ProcessBuilder();
    builder.directory(context.getProjectDirectoryRoot().toAbsolutePath().toFile());
    builder.redirectError(ProcessBuilder.Redirect.PIPE);













    builder.environment().put(
        "PWD",



        operation == Operation.COMPILE_MUNGE_DEBUGINFO ?
            sanitizer.getExpandedPath(context.getProjectDirectoryRoot().toAbsolutePath()) :
            context.getProjectDirectoryRoot().toAbsolutePath().toString());

    return builder;
  }

  private ImmutableList<String> makePreprocessCommand() {
    return ImmutableList.<String>builder()
        .addAll(preprocessorCommand.get())
        .add("-x", inputType.getLanguage())
        .add("-E")
        .add(input.toString())
        .build();
  }

  private ImmutableList<String> makeCompileCommand(
      String inputFileName,
      String inputLanguage) {
    return ImmutableList.<String>builder()
        .addAll(compilerCommand.get())
        .add("-x", inputLanguage)
        .add("-c")
        .add(inputFileName)
        .add("-o")
        .add(output.toString())
        .build();
  }

  private void safeCloseProcessor(@Nullable FunctionLineProcessorThread processor) {
    if (processor != null) {
      try {
        processor.waitFor();
        processor.close();
      } catch (Exception ex) {
        LOG.warn(ex, "error closing processor");
      }
    }
  }

  private int executePiped(ExecutionContext context)
      throws IOException, InterruptedException {
    ByteArrayOutputStream preprocessError = new ByteArrayOutputStream();
    ProcessBuilder preprocessBuilder = makeSubprocessBuilder(context);
    preprocessBuilder.command(makePreprocessCommand());
    preprocessBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);

    ByteArrayOutputStream compileError = new ByteArrayOutputStream();
    ProcessBuilder compileBuilder = makeSubprocessBuilder(context);
    compileBuilder.command(
        makeCompileCommand(
            "-",
            inputType.getPreprocessedLanguage()));
    compileBuilder.redirectInput(ProcessBuilder.Redirect.PIPE);

    Process preprocess = null;
    Process compile = null;
    FunctionLineProcessorThread errorProcessorPreprocess = null;
    FunctionLineProcessorThread errorProcessorCompile = null;
    FunctionLineProcessorThread lineDirectiveMunger = null;

    try {
      LOG.debug(
          "Running command (pwd=%s): %s",
          preprocessBuilder.directory(),
          getDescription(context));

      preprocess = preprocessBuilder.start();
      compile = compileBuilder.start();

      errorProcessorPreprocess =
          new FunctionLineProcessorThread(
              preprocess.getErrorStream(),
              preprocessError,
              createErrorLineProcessor(context.getProjectDirectoryRoot()));
      errorProcessorPreprocess.start();

      errorProcessorCompile =
          new FunctionLineProcessorThread(
              compile.getErrorStream(),
              compileError,
              createErrorLineProcessor(context.getProjectDirectoryRoot()));
      errorProcessorCompile.start();

      lineDirectiveMunger =
          new FunctionLineProcessorThread(
              preprocess.getInputStream(),
              compile.getOutputStream(),
              createPreprocessOutputLineProcessor(context.getProjectDirectoryRoot()));
      lineDirectiveMunger.start();

      int compileStatus = compile.waitFor();
      int preprocessStatus = preprocess.waitFor();

      safeCloseProcessor(errorProcessorPreprocess);
      safeCloseProcessor(errorProcessorCompile);

      String preprocessErr = new String(preprocessError.toByteArray());
      if (!preprocessErr.isEmpty()) {
        context.getConsole().printErrorText(preprocessErr);
      }

      String compileErr = new String(compileError.toByteArray());
      if (!compileErr.isEmpty()) {
        context.getConsole().printErrorText(compileErr);
      }

      if (preprocessStatus != 0) {
        LOG.warn("error %d %s(preprocess) %s: %s", preprocessStatus,
            operation.toString().toLowerCase(), input, preprocessErr);
      }

      if (compileStatus != 0) {
        LOG.warn("error %d %s(compile) %s: %s", compileStatus,
            operation.toString().toLowerCase(), input, compileErr);
      }

      if (preprocessStatus != 0) {
        return preprocessStatus;
      }

      if (compileStatus != 0) {
        return compileStatus;
      }

      return 0;
    } finally {
      if (preprocess != null) {
        preprocess.destroy();
        preprocess.waitFor();
      }

      if (compile != null) {
        compile.destroy();
        compile.waitFor();
      }

      safeCloseProcessor(errorProcessorPreprocess);
      safeCloseProcessor(errorProcessorCompile);
      safeCloseProcessor(lineDirectiveMunger);
    }
  }

  private int executeOther(ExecutionContext context) throws Exception {
    ProcessBuilder builder = makeSubprocessBuilder(context);


    if (operation == Operation.PREPROCESS) {
      builder.command(makePreprocessCommand());
      builder.redirectOutput(ProcessBuilder.Redirect.PIPE);
    } else {
      builder.command(
          makeCompileCommand(
              input.toString(),
              inputType.getLanguage()));
    }

    LOG.debug(
        "Running command (pwd=%s): %s",
        builder.directory(),
        getDescription(context));


    Process process = builder.start();


    ByteArrayOutputStream error = new ByteArrayOutputStream();



    int exitCode;
    try {
      try (FunctionLineProcessorThread errorProcessor =
               new FunctionLineProcessorThread(
                   process.getErrorStream(),
                   error,
                   createErrorLineProcessor(context.getProjectDirectoryRoot()))) {
        errorProcessor.start();



        if (operation == Operation.PREPROCESS) {
          try (OutputStream output =
                   context.getProjectFilesystem().newFileOutputStream(this.output);
               FunctionLineProcessorThread outputProcessor =
                   new FunctionLineProcessorThread(
                       process.getInputStream(),
                       output,
                       createPreprocessOutputLineProcessor(context.getProjectDirectoryRoot()))) {
            outputProcessor.start();
            outputProcessor.waitFor();
          } catch (Throwable thrown) {
            process.destroy();
            throw thrown;
          }
        }
        errorProcessor.waitFor();
      } catch (Throwable thrown) {
        process.destroy();
        throw thrown;
      }
      exitCode = process.waitFor();
    } finally {
      process.destroy();
      process.waitFor();
    }


    String err = new String(error.toByteArray());
    if (!err.isEmpty()) {
      context.getConsole().printErrorText(err);
    }

    return exitCode;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {
    try {
      LOG.debug("%s %s -> %s", operation.toString().toLowerCase(), input, output);


      int exitCode;
      if (operation == Operation.PIPED_PREPROCESS_AND_COMPILE) {
        exitCode = executePiped(context);
      } else {
        exitCode = executeOther(context);
      }





      if (exitCode == 0 && operation == Operation.COMPILE_MUNGE_DEBUGINFO) {
        try {
          sanitizer.restoreCompilationDirectory(
              context.getProjectDirectoryRoot().toAbsolutePath().resolve(output),
              context.getProjectDirectoryRoot().toAbsolutePath());
        } catch (IOException e) {
          context.logError(e, "error updating compilation directory");
          return 1;
        }
      }

      if (exitCode != 0) {
        LOG.warn("error %d %s %s", exitCode, operation.toString().toLowerCase(), input);
      }

      return exitCode;

    } catch (Exception e) {
      MoreThrowables.propagateIfInterrupt(e);
      context.getConsole().printBuildFailureWithStacktrace(e);
      return 1;
    }
  }

  public ImmutableList<String> getCommand() {
    switch (operation) {
      case COMPILE:
      case COMPILE_MUNGE_DEBUGINFO:
        return makeCompileCommand(
            input.toString(),
            inputType.getLanguage());
      case PREPROCESS:
        return makePreprocessCommand();

      default:
        throw new RuntimeException("invalid operation type");
    }
  }

  public String getDescriptionNoContext() {
    switch (operation) {
      case PIPED_PREPROCESS_AND_COMPILE: {
        return Joiner.on(' ').join(
            FluentIterable.from(makePreprocessCommand())
            .transform(Escaper.SHELL_ESCAPER)) +
            " | " +
            Joiner.on(' ').join(
                FluentIterable.from(
                    makeCompileCommand(
                        "-",
                        inputType.getPreprocessedLanguage()))
                .transform(Escaper.SHELL_ESCAPER));

      }

      default: {
        return Joiner.on(' ').join(
            FluentIterable.from(getCommand())
            .transform(Escaper.SHELL_ESCAPER));
      }
    }
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return getDescriptionNoContext();
  }

  public enum Operation {
    COMPILE,
    COMPILE_MUNGE_DEBUGINFO,
    PREPROCESS,
    PIPED_PREPROCESS_AND_COMPILE,
    ;

    public boolean isPreprocess() {
      return this == COMPILE_MUNGE_DEBUGINFO ||
          this == PREPROCESS ||
          this == PIPED_PREPROCESS_AND_COMPILE;
    }

    public boolean isCompile() {
      return this == COMPILE ||
          this == COMPILE_MUNGE_DEBUGINFO ||
          this == PIPED_PREPROCESS_AND_COMPILE;
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import static com.facebook.buck.cxx.DebugSectionProperty.COMPRESSED;
import static com.facebook.buck.cxx.DebugSectionProperty.STRINGS;
import static java.nio.channels.FileChannel.MapMode.READ_WRITE;
import static java.nio.file.StandardOpenOption.READ;
import static java.nio.file.StandardOpenOption.WRITE;

import com.facebook.buck.log.Logger;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.ExecutionException;


public class DebugPathSanitizer {

  private static final DebugSectionFinder DEBUG_SECTION_FINDER = new DebugSectionFinder();

  private final int pathSize;
  private final char separator;
  private final Path compilationDirectory;
  private final ImmutableBiMap<Path, Path> other;

  private final LoadingCache<Path, ImmutableBiMap<Path, Path>> pathCache =
      CacheBuilder
          .newBuilder()
          .softValues()
          .build(new CacheLoader<Path, ImmutableBiMap<Path, Path>>() {
            @Override
            public ImmutableBiMap<Path, Path> load(Path key) {
              return getAllPathsWork(key);
            }
          });


  public DebugPathSanitizer(
      int pathSize,
      char separator,
      Path compilationDirectory,
      ImmutableBiMap<Path, Path> other) {
    this.pathSize = pathSize;
    this.separator = separator;
    this.compilationDirectory = compilationDirectory;
    this.other = other;
  }


  public String getExpandedPath(Path path) {
    Preconditions.checkArgument(path.toString().length() <= pathSize);
    return Strings.padEnd(path.toString(), pathSize, separator);
  }

  private ImmutableBiMap<Path, Path> getAllPaths(Optional<Path> workingDir) {
    if (!workingDir.isPresent()) {
      return other;
    }

    try {
      return pathCache.get(workingDir.get());
    } catch (ExecutionException e) {
      Logger.get(DebugPathSanitizer.class).error(
          "Problem loading paths into cache",
          e);
      return getAllPathsWork(workingDir.get());
    }
  }

  private ImmutableBiMap<Path, Path> getAllPathsWork(Path workingDir) {
    ImmutableBiMap.Builder<Path, Path> builder = ImmutableBiMap.builder();
    builder.put(workingDir, compilationDirectory);
    builder.putAll(other);
    return builder.build();
  }

  public String getCompilationDirectory() {
    return getExpandedPath(compilationDirectory);
  }

  public Function<String, String> sanitize(
      final Optional<Path> workingDir,
      final boolean expandPaths) {
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return DebugPathSanitizer.this.sanitize(workingDir, input, expandPaths);
      }
    };
  }


  public String sanitize(Optional<Path> workingDir, String contents, boolean expandPaths) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      String replacement;
      if (expandPaths) {
        replacement = getExpandedPath(entry.getValue());
      } else {
        replacement = entry.getValue().toString();
      }
      String pathToReplace = entry.getKey().toString();
      if (contents.contains(pathToReplace)) {



        contents = contents.replace(pathToReplace, replacement);
      }
    }
    return contents;
  }

  public String sanitize(Optional<Path> workingDir, String contents) {
    return sanitize(workingDir, contents,  true);
  }

  public String restore(Optional<Path> workingDir, String contents) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      contents = contents.replace(getExpandedPath(entry.getValue()), entry.getKey().toString());
    }
    return contents;
  }


  private void restore(ByteBuffer buffer, ByteBufferReplacer replacer) {


    Optional<ImmutableMap<String, DebugSection>> results = DEBUG_SECTION_FINDER.find(buffer);



    if (results.isPresent()) {
      for (DebugSection section : results.get().values()) {

        Preconditions.checkState(!section.properties.contains(COMPRESSED));
        if (section.properties.contains(STRINGS)) {
          replacer.replace(section.body);
        }
      }
    } else {
      replacer.replace(buffer);
    }
  }

  private void restore(Path path, ByteBufferReplacer replacer) throws IOException {
    try (FileChannel channel = FileChannel.open(path, READ, WRITE)) {
      MappedByteBuffer buffer = channel.map(READ_WRITE, 0, channel.size());
      restore(buffer, replacer);
    }
  }


  private ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir) {
    return new ByteBufferReplacer(
        ImmutableMap.of(
            getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),
            getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
  }



  public void restoreCompilationDirectory(Path path, Path workingDir) throws IOException {
    restore(path, getCompilationDirectoryReplacer(workingDir));
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.keys.SupportsInputBasedRuleKey;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.facebook.buck.util.Optionals;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;


public class CxxPreprocessAndCompile
    extends AbstractBuildRule
    implements RuleKeyAppendable, SupportsInputBasedRuleKey {

  @AddToRuleKey
  private final CxxPreprocessAndCompileStep.Operation operation;
  @AddToRuleKey
  private final Optional<Preprocessor> preprocessor;
  private final Optional<ImmutableList<String>> platformPreprocessorFlags;
  private final Optional<ImmutableList<String>> rulePreprocessorFlags;
  @AddToRuleKey
  private final Optional<Compiler> compiler;
  private final Optional<ImmutableList<String>> platformCompilerFlags;
  private final Optional<ImmutableList<String>> ruleCompilerFlags;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @AddToRuleKey
  private final SourcePath input;
  private final CxxSource.Type inputType;
  private final ImmutableSet<Path> includeRoots;
  private final ImmutableSet<Path> systemIncludeRoots;
  private final ImmutableSet<Path> frameworkRoots;
  @AddToRuleKey
  private final ImmutableList<CxxHeaders> includes;
  private final DebugPathSanitizer sanitizer;

  @VisibleForTesting
  CxxPreprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      CxxPreprocessAndCompileStep.Operation operation,
      Optional<Preprocessor> preprocessor,
      Optional<ImmutableList<String>> platformPreprocessorFlags,
      Optional<ImmutableList<String>> rulePreprocessorFlags,
      Optional<Compiler> compiler,
      Optional<ImmutableList<String>> platformCompilerFlags,
      Optional<ImmutableList<String>> ruleCompilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    Preconditions.checkState(operation.isPreprocess() == preprocessor.isPresent());
    Preconditions.checkState(operation.isPreprocess() == platformPreprocessorFlags.isPresent());
    Preconditions.checkState(operation.isPreprocess() == rulePreprocessorFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == compiler.isPresent());
    Preconditions.checkState(operation.isCompile() == platformCompilerFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == ruleCompilerFlags.isPresent());
    this.operation = operation;
    this.preprocessor = preprocessor;
    this.platformPreprocessorFlags = platformPreprocessorFlags;
    this.rulePreprocessorFlags = rulePreprocessorFlags;
    this.compiler = compiler;
    this.platformCompilerFlags = platformCompilerFlags;
    this.ruleCompilerFlags = ruleCompilerFlags;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.includeRoots = includeRoots;
    this.systemIncludeRoots = systemIncludeRoots;
    this.frameworkRoots = frameworkRoots;
    this.includes = includes;
    this.sanitizer = sanitizer;
  }


  public static CxxPreprocessAndCompile compile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Compiler compiler,
      ImmutableList<String> platformFlags,
      ImmutableList<String> ruleFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Preprocessor>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(compiler),
        Optional.of(platformFlags),
        Optional.of(ruleFlags),
        output,
        input,
        inputType,
        ImmutableSet.<Path>of(),
        ImmutableSet.<Path>of(),
        ImmutableSet.<Path>of(),
        ImmutableList.<CxxHeaders>of(),
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocess(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Preprocessor preprocessor,
      ImmutableList<String> platformFlags,
      ImmutableList<String> ruleFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(preprocessor),
        Optional.of(platformFlags),
        Optional.of(ruleFlags),
        Optional.<Compiler>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Preprocessor preprocessor,
      ImmutableList<String> platformPreprocessorFlags,
      ImmutableList<String> rulePreprocessorFlags,
      Compiler compiler,
      ImmutableList<String> platformCompilerFlags,
      ImmutableList<String> ruleCompilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer,
      CxxPreprocessMode strategy) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        (strategy == CxxPreprocessMode.PIPED
            ? CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE
            : CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO),
        Optional.of(preprocessor),
        Optional.of(platformPreprocessorFlags),
        Optional.of(rulePreprocessorFlags),
        Optional.of(compiler),
        Optional.of(platformCompilerFlags),
        Optional.of(ruleCompilerFlags),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {


    builder.setReflectively("platformPreprocessorFlags", sanitizeFlags(platformPreprocessorFlags));
    builder.setReflectively("rulePreprocessorFlags", sanitizeFlags(rulePreprocessorFlags));
    builder.setReflectively("platformCompilerFlags", sanitizeFlags(platformCompilerFlags));
    builder.setReflectively("ruleCompilerFlags", sanitizeFlags(ruleCompilerFlags));
    ImmutableList<String> frameworkRoots = FluentIterable.from(this.frameworkRoots)
        .transform(Functions.toStringFunction())
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
    builder.setReflectively("frameworkRoots", frameworkRoots);



    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      builder.setReflectively("compilationDirectory", sanitizer.getCompilationDirectory());
    }

    return builder;
  }

  private ImmutableList<String> sanitizeFlags(Optional<ImmutableList<String>> flags) {
    return FluentIterable.from(flags.or(ImmutableList.<String>of()))
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
  }

  @VisibleForTesting
  CxxPreprocessAndCompileStep makeMainStep() {



    ImmutableMap.Builder<Path, Path> replacementPathsBuilder = ImmutableMap.builder();
    try {
      for (Map.Entry<Path, SourcePath> entry :
           CxxHeaders.concat(includes).getFullNameToPathMap().entrySet()) {
        replacementPathsBuilder.put(entry.getKey(), getResolver().getPath(entry.getValue()));
      }
    } catch (CxxHeaders.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
    }
    ImmutableMap<Path, Path> replacementPaths = replacementPathsBuilder.build();

    Optional<ImmutableList<String>> preprocessorCommand;
    if (preprocessor.isPresent()) {
      preprocessorCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(preprocessor.get().getCommandPrefix(getResolver()))
              .addAll(getPreprocessorPlatformPrefix())
              .addAll(getPreprocessorSuffix())
              .addAll(preprocessor.get().getExtraFlags().or(ImmutableList.<String>of()))
              .build());
    } else {
      preprocessorCommand = Optional.absent();
    }

    Optional<ImmutableList<String>> compilerCommand;
    if (compiler.isPresent()) {
      compilerCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(compiler.get().getCommandPrefix(getResolver()))
              .addAll(getCompilerPlatformPrefix())
              .addAll(getCompilerSuffix())
              .build());
    } else {
      compilerCommand = Optional.absent();
    }

    return new CxxPreprocessAndCompileStep(
        operation,
        output,
        getResolver().getPath(input),
        inputType,
        preprocessorCommand,
        compilerCommand,
        replacementPaths,
        sanitizer,
        Optionals.bind(
            preprocessor,
            new Function<Preprocessor, Optional<Function<String, Iterable<String>>>>() {
              @Override
              public Optional<Function<String, Iterable<String>>> apply(Preprocessor input) {
                return input.getExtraLineProcessor();
              }
            }));
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        makeMainStep());
  }

  private ImmutableList<String> getPreprocessorPlatformPrefix() {
    Preconditions.checkState(operation.isPreprocess());
    return platformPreprocessorFlags.get();
  }

  private ImmutableList<String> getCompilerPlatformPrefix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> flags = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      flags.addAll(getPreprocessorPlatformPrefix());
    }
    flags.addAll(platformCompilerFlags.get());
    return flags.build();
  }

  private ImmutableList<String> getPreprocessorSuffix() {
    Preconditions.checkState(operation.isPreprocess());
    ImmutableSet.Builder<SourcePath> prefixHeaders = ImmutableSet.builder();
    for (CxxHeaders cxxHeaders : includes) {
      prefixHeaders.addAll(cxxHeaders.getPrefixHeaders());
    }
    return ImmutableList.<String>builder()
        .addAll(rulePreprocessorFlags.get())
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-include"),
                FluentIterable.from(prefixHeaders.build())
                    .transform(getResolver().getPathFunction())
                    .transform(Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-I"),
                Iterables.transform(includeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-isystem"),
                Iterables.transform(systemIncludeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-F"),
                Iterables.transform(frameworkRoots, Functions.toStringFunction())))
        .build();
  }

  private ImmutableList<String> getCompilerSuffix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> suffix = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      suffix.addAll(getPreprocessorSuffix());
    }
    suffix.addAll(ruleCompilerFlags.get());
    suffix.addAll(
        compiler.get()
            .debugCompilationDirFlags(sanitizer.getCompilationDirectory())
            .or(ImmutableList.<String>of()));
    return suffix.build();
  }

  public ImmutableList<String> getCompileCommandCombinedWithPreprocessBuildRule(
      CxxPreprocessAndCompile preprocessBuildRule) {
    if (!operation.isCompile() ||
        !preprocessBuildRule.operation.isPreprocess()) {
      throw new HumanReadableException(
          "%s is not preprocess rule or %s is not compile rule.",
          preprocessBuildRule,
          this);
    }
    ImmutableList.Builder<String> cmd = ImmutableList.builder();
    cmd.addAll(compiler.get().getCommandPrefix(getResolver()));
    cmd.addAll(preprocessBuildRule.getPreprocessorPlatformPrefix());
    cmd.addAll(getCompilerPlatformPrefix());
    cmd.addAll(preprocessBuildRule.getPreprocessorSuffix());
    cmd.addAll(getCompilerSuffix());
    cmd.add("-x", preprocessBuildRule.inputType.getLanguage());
    cmd.add("-c");
    cmd.add("-o", output.toString());
    cmd.add(getResolver().getPath(preprocessBuildRule.input).toString());
    return cmd.build();
  }

  public ImmutableList<String> getCommand() {
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      return makeMainStep().getCommand();
    }
    return getCompileCommandCombinedWithPreprocessBuildRule(this);
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getRulePreprocessorFlags() {
    return rulePreprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPlatformPreprocessorFlags() {
    return platformPreprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getRuleCompilerFlags() {
    return ruleCompilerFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPlatformCompilerFlags() {
    return platformCompilerFlags;
  }

  public Path getOutput() {
    return output;
  }

  public SourcePath getInput() {
    return input;
  }

  public ImmutableList<CxxHeaders> getIncludes() {
    return includes;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.rules.keys.SupportsInputBasedRuleKey;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.FileScrubberStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Path;

public class CxxLink
    extends AbstractBuildRule
    implements RuleKeyAppendable, SupportsInputBasedRuleKey {

  @AddToRuleKey
  private final Linker linker;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @SuppressWarnings("PMD.UnusedPrivateField")
  @AddToRuleKey
  private final ImmutableList<SourcePath> inputs;


  private final ImmutableList<String> args;
  private final ImmutableSet<Path> frameworkRoots;
  private final DebugPathSanitizer sanitizer;

  public CxxLink(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Linker linker,
      Path output,
      ImmutableList<SourcePath> inputs,
      ImmutableList<String> args,
      ImmutableSet<Path> frameworkRoots,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    this.linker = linker;
    this.output = output;
    this.inputs = inputs;
    this.args = args;
    this.frameworkRoots = frameworkRoots;
    this.sanitizer = sanitizer;
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder
        .setReflectively(
            "args",
            FluentIterable.from(args)
                .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
                .toList())
        .setReflectively(
            "frameworkRoots",
            FluentIterable.from(frameworkRoots)
                .transform(Functions.toStringFunction())
                .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
                .toList());
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        new CxxLinkStep(
            linker.getCommandPrefix(getResolver()),
            output,
            args,
            frameworkRoots),
        new FileScrubberStep(output, linker.getScrubbers()));
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  public Tool getLinker() {
    return linker;
  }

  public Path getOutput() {
    return output;
  }

  public ImmutableList<String> getArgs() {
    return args;
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertThat;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableBiMap;

import org.junit.Before;
import org.junit.Test;

import java.nio.file.Paths;

public class DebugPathSanitizerTest {

  DebugPathSanitizer debugPathSanitizer;

  @Before
  public void setUp() {
    debugPathSanitizer = new DebugPathSanitizer(
        40,
        '/',
        Paths.get("."),
        ImmutableBiMap.of(
            Paths.get("/some/absolute/path"),
            Paths.get("SYMBOLIC_NAME"),
            Paths.get("/another/path/with/subdirectories"),
            Paths.get("OTHER_NAME_WITH_SUFFIX"),
            Paths.get("/another/path"),
            Paths.get("OTHER_NAME")));
  }

  @Test
  public void sanitizeWithoutAnyMatchesWithExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "an arbitrary string with no match",
 true),
        equalTo("an arbitrary string with no match"));
  }

  @Test
  public void sanitizeWithoutAnyMatchesWithoutExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "an arbitrary string with no match",
 false),
        equalTo("an arbitrary string with no match"));
  }

  @Test
  public void sanitizeProjectRootWithExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "a string that mentions the /project/root somewhere",
 true),
        equalTo("a string that mentions the ./////////////////////////////////////// somewhere"));
  }

  @Test
  public void sanitizeProjectRootWithoutExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "a string that mentions the /project/root somewhere",
 false),
        equalTo("a string that mentions the . somewhere"));
  }

  @Test
  public void sanitizeOtherDirectoriesWithExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/some/absolute/path/dir -I/another/path",
 true),
        equalTo(
            "-ISYMBOLIC_NAME////////////////////////////dir " +
                "-IOTHER_NAME//////////////////////////////"));
  }

  @Test
  public void sanitizeOtherDirectoriesWithoutExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/some/absolute/path/dir -I/another/path",
 false),
        equalTo("-ISYMBOLIC_NAME/dir -IOTHER_NAME"));
  }

  @Test
  public void sanitizeDirectoriesThatArePrefixOfOtherDirectoriesWithExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/another/path/with/subdirectories/something",
 true),
        equalTo("-IOTHER_NAME_WITH_SUFFIX///////////////////something"));
  }

  @Test
  public void sanitizeDirectoriesThatArePrefixOfOtherDirectoriesWithoutExpandPaths() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/another/path/with/subdirectories/something",
 false),
        equalTo("-IOTHER_NAME_WITH_SUFFIX/something"));
  }

  @Test
  public void restoreWithoutAnyMatches() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "an arbitrary string with no match"),
        equalTo("an arbitrary string with no match"));
  }

  @Test
  public void restoreProjectRoot() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "a string that mentions the ./////////////////////////////////////// somewhere"),
        equalTo("a string that mentions the /project/root somewhere"));
  }

  @Test
  public void restoreOtherDirectories() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "-ISYMBOLIC_NAME////////////////////////////dir " +
                "-IOTHER_NAME//////////////////////////////"),
        equalTo("-I/some/absolute/path/dir -I/another/path"));
  }

  @Test
  public void restoreDirectoriesThatArePrefixOfOtherDirectories() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "-IOTHER_NAME_WITH_SUFFIX///////////////////something"),
        equalTo("-I/another/path/with/subdirectories/something"));
  }

  @Test
  public void restoreDoesNotTouchUnexpandedPaths() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            ". -ISYMBOLIC_NAME/ OTHER_NAME"),
        equalTo(". -ISYMBOLIC_NAME/ OTHER_NAME"));
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.log.Logger;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.FunctionLineProcessorThread;
import com.facebook.buck.util.MoreThrowables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class CxxPreprocessAndCompileStep implements Step {

  private static final Logger LOG = Logger.get(CxxPreprocessAndCompileStep.class);

  private final Operation operation;
  private final Path output;
  private final Path input;
  private final CxxSource.Type inputType;
  private final Optional<ImmutableList<String>> preprocessorCommand;
  private final Optional<ImmutableList<String>> compilerCommand;
  private final ImmutableMap<Path, Path> replacementPaths;
  private final DebugPathSanitizer sanitizer;
  private final Optional<Function<String, Iterable<String>>> extraLineProcessor;



  private static final ImmutableSet<String> SPECIAL_INCLUDE_PATHS = ImmutableSet.of(
      "<built-in>",
      "<command-line>"
  );

  public CxxPreprocessAndCompileStep(
      Operation operation,
      Path output,
      Path input,
      CxxSource.Type inputType,
      Optional<ImmutableList<String>> preprocessorCommand,
      Optional<ImmutableList<String>> compilerCommand,
      ImmutableMap<Path, Path> replacementPaths,
      DebugPathSanitizer sanitizer,
      Optional<Function<String, Iterable<String>>> extraLineProcessor) {
    Preconditions.checkState(operation.isPreprocess() == preprocessorCommand.isPresent());
    Preconditions.checkState(operation.isCompile() == compilerCommand.isPresent());
    this.operation = operation;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.preprocessorCommand = preprocessorCommand;
    this.compilerCommand = compilerCommand;
    this.replacementPaths = replacementPaths;
    this.sanitizer = sanitizer;
    this.extraLineProcessor = extraLineProcessor;
  }

  @Override
  public String getShortName() {
    Optional<CxxSource.Type> type = CxxSource.Type.fromExtension(
        Files.getFileExtension(input.getFileName().toString()));
    String fileType;
    if (type.isPresent()) {
      fileType = type.get().getLanguage();
    } else {
      fileType = "unknown";
    }
    return fileType + " " + operation.toString().toLowerCase();
  }

  @VisibleForTesting
  Function<String, Iterable<String>> createPreprocessOutputLineProcessor(final Path workingDir) {
    return new Function<String, Iterable<String>>() {

      private final Pattern lineMarkers =
          Pattern.compile("^# (?<num>\\d+) \"(?<path>[^\"]+)\"(?<rest>.*)?$");

      @Override
      public Iterable<String> apply(String line) {
        if (line.startsWith("# ")) {
          Matcher m = lineMarkers.matcher(line);

          if (m.find() && !SPECIAL_INCLUDE_PATHS.contains(m.group("path"))) {
            String originalPath = m.group("path");
            String replacementPath = originalPath;

            replacementPath = Optional
                .fromNullable(replacementPaths.get(Paths.get(replacementPath)))
                .transform(Escaper.PATH_FOR_C_INCLUDE_STRING_ESCAPER)
                .or(replacementPath);

            replacementPath = sanitizer.sanitize(Optional.of(workingDir), replacementPath);

            if (!originalPath.equals(replacementPath)) {
              String num = m.group("num");
              String rest = m.group("rest");
              return ImmutableList.of("# " + num + " \"" + replacementPath + "\"" + rest);
            }
          }

          return ImmutableList.of(line);
        }

        if (extraLineProcessor.isPresent()) {
          return extraLineProcessor.get().apply(line);
        }

        return ImmutableList.of(line);
      }
    };
  }

  @VisibleForTesting
  Function<String, Iterable<String>> createErrorLineProcessor(final Path workingDir) {
    return CxxDescriptionEnhancer.createErrorMessagePathProcessor(
        new Function<String, String>() {
          @Override
          public String apply(String original) {
            Path path = Paths.get(original);



            if (operation == Operation.COMPILE) {
              path = Paths.get(sanitizer.restore(Optional.of(workingDir), original));
            }


            return Optional
                .fromNullable(replacementPaths.get(path))
                .transform(Escaper.PATH_FOR_C_INCLUDE_STRING_ESCAPER)
                .or(Escaper.escapePathForCIncludeString(path));
          }
        });
  }


  private ProcessBuilder makeSubprocessBuilder(ExecutionContext context) {
    ProcessBuilder builder = new ProcessBuilder();
    builder.directory(context.getProjectDirectoryRoot().toAbsolutePath().toFile());
    builder.redirectError(ProcessBuilder.Redirect.PIPE);













    builder.environment().put(
        "PWD",


        operation == Operation.COMPILE_MUNGE_DEBUGINFO ?
            sanitizer.getExpandedPath(context.getProjectDirectoryRoot().toAbsolutePath()) :
            context.getProjectDirectoryRoot().toAbsolutePath().toString());

    return builder;
  }

  private ImmutableList<String> makePreprocessCommand() {
    return ImmutableList.<String>builder()
        .addAll(preprocessorCommand.get())
        .add("-x", inputType.getLanguage())
        .add("-E")
        .add(input.toString())
        .build();
  }

  private ImmutableList<String> makeCompileCommand(
      String inputFileName,
      String inputLanguage) {
    return ImmutableList.<String>builder()
        .addAll(compilerCommand.get())
        .add("-x", inputLanguage)
        .add("-c")
        .add(inputFileName)
        .add("-o")
        .add(output.toString())
        .build();
  }

  private void safeCloseProcessor(@Nullable FunctionLineProcessorThread processor) {
    if (processor != null) {
      try {
        processor.waitFor();
        processor.close();
      } catch (Exception ex) {
        LOG.warn(ex, "error closing processor");
      }
    }
  }

  private int executePiped(ExecutionContext context)
      throws IOException, InterruptedException {
    ByteArrayOutputStream preprocessError = new ByteArrayOutputStream();
    ProcessBuilder preprocessBuilder = makeSubprocessBuilder(context);
    preprocessBuilder.command(makePreprocessCommand());
    preprocessBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);

    ByteArrayOutputStream compileError = new ByteArrayOutputStream();
    ProcessBuilder compileBuilder = makeSubprocessBuilder(context);
    compileBuilder.command(
        makeCompileCommand(
            "-",
            inputType.getPreprocessedLanguage()));
    compileBuilder.redirectInput(ProcessBuilder.Redirect.PIPE);

    Process preprocess = null;
    Process compile = null;
    FunctionLineProcessorThread errorProcessorPreprocess = null;
    FunctionLineProcessorThread errorProcessorCompile = null;
    FunctionLineProcessorThread lineDirectiveMunger = null;

    try {
      LOG.debug(
          "Running command (pwd=%s): %s",
          preprocessBuilder.directory(),
          getDescription(context));

      preprocess = preprocessBuilder.start();
      compile = compileBuilder.start();

      errorProcessorPreprocess =
          new FunctionLineProcessorThread(
              preprocess.getErrorStream(),
              preprocessError,
              createErrorLineProcessor(context.getProjectDirectoryRoot()));
      errorProcessorPreprocess.start();

      errorProcessorCompile =
          new FunctionLineProcessorThread(
              compile.getErrorStream(),
              compileError,
              createErrorLineProcessor(context.getProjectDirectoryRoot()));
      errorProcessorCompile.start();

      lineDirectiveMunger =
          new FunctionLineProcessorThread(
              preprocess.getInputStream(),
              compile.getOutputStream(),
              createPreprocessOutputLineProcessor(context.getProjectDirectoryRoot()));
      lineDirectiveMunger.start();

      int compileStatus = compile.waitFor();
      int preprocessStatus = preprocess.waitFor();

      safeCloseProcessor(errorProcessorPreprocess);
      safeCloseProcessor(errorProcessorCompile);

      String preprocessErr = new String(preprocessError.toByteArray());
      if (!preprocessErr.isEmpty()) {
        context.getConsole().printErrorText(preprocessErr);
      }

      String compileErr = new String(compileError.toByteArray());
      if (!compileErr.isEmpty()) {
        context.getConsole().printErrorText(compileErr);
      }

      if (preprocessStatus != 0) {
        LOG.warn("error %d %s(preprocess) %s: %s", preprocessStatus,
            operation.toString().toLowerCase(), input, preprocessErr);
      }

      if (compileStatus != 0) {
        LOG.warn("error %d %s(compile) %s: %s", compileStatus,
            operation.toString().toLowerCase(), input, compileErr);
      }

      if (preprocessStatus != 0) {
        return preprocessStatus;
      }

      if (compileStatus != 0) {
        return compileStatus;
      }

      return 0;
    } finally {
      if (preprocess != null) {
        preprocess.destroy();
        preprocess.waitFor();
      }

      if (compile != null) {
        compile.destroy();
        compile.waitFor();
      }

      safeCloseProcessor(errorProcessorPreprocess);
      safeCloseProcessor(errorProcessorCompile);
      safeCloseProcessor(lineDirectiveMunger);
    }
  }

  private int executeOther(ExecutionContext context) throws Exception {
    ProcessBuilder builder = makeSubprocessBuilder(context);


    if (operation == Operation.PREPROCESS) {
      builder.command(makePreprocessCommand());
      builder.redirectOutput(ProcessBuilder.Redirect.PIPE);
    } else {
      builder.command(
          makeCompileCommand(
              input.toString(),
              inputType.getLanguage()));
    }

    LOG.debug(
        "Running command (pwd=%s): %s",
        builder.directory(),
        getDescription(context));


    Process process = builder.start();


    ByteArrayOutputStream error = new ByteArrayOutputStream();



    int exitCode;
    try {
      try (FunctionLineProcessorThread errorProcessor =
               new FunctionLineProcessorThread(
                   process.getErrorStream(),
                   error,
                   createErrorLineProcessor(context.getProjectDirectoryRoot()))) {
        errorProcessor.start();



        if (operation == Operation.PREPROCESS) {
          try (OutputStream output =
                   context.getProjectFilesystem().newFileOutputStream(this.output);
               FunctionLineProcessorThread outputProcessor =
                   new FunctionLineProcessorThread(
                       process.getInputStream(),
                       output,
                       createPreprocessOutputLineProcessor(context.getProjectDirectoryRoot()))) {
            outputProcessor.start();
            outputProcessor.waitFor();
          } catch (Throwable thrown) {
            process.destroy();
            throw thrown;
          }
        }
        errorProcessor.waitFor();
      } catch (Throwable thrown) {
        process.destroy();
        throw thrown;
      }
      exitCode = process.waitFor();
    } finally {
      process.destroy();
      process.waitFor();
    }


    String err = new String(error.toByteArray());
    if (!err.isEmpty()) {
      context.getConsole().printErrorText(err);
    }

    return exitCode;
  }

  @Override
  public int execute(ExecutionContext context) throws InterruptedException {
    try {
      LOG.debug("%s %s -> %s", operation.toString().toLowerCase(), input, output);


      int exitCode;
      if (operation == Operation.PIPED_PREPROCESS_AND_COMPILE) {
        exitCode = executePiped(context);
      } else {
        exitCode = executeOther(context);
      }





      if (exitCode == 0 && operation == Operation.COMPILE_MUNGE_DEBUGINFO) {
        try {
          sanitizer.restoreCompilationDirectory(
              context.getProjectDirectoryRoot().toAbsolutePath().resolve(output),
              context.getProjectDirectoryRoot().toAbsolutePath());
        } catch (IOException e) {
          context.logError(e, "error updating compilation directory");
          return 1;
        }
      }

      if (exitCode != 0) {
        LOG.warn("error %d %s %s", exitCode, operation.toString().toLowerCase(), input);
      }

      return exitCode;

    } catch (Exception e) {
      MoreThrowables.propagateIfInterrupt(e);
      context.getConsole().printBuildFailureWithStacktrace(e);
      return 1;
    }
  }

  public ImmutableList<String> getCommand() {
    switch (operation) {
      case COMPILE:
      case COMPILE_MUNGE_DEBUGINFO:
        return makeCompileCommand(
            input.toString(),
            inputType.getLanguage());
      case PREPROCESS:
        return makePreprocessCommand();

      default:
        throw new RuntimeException("invalid operation type");
    }
  }

  public String getDescriptionNoContext() {
    switch (operation) {
      case PIPED_PREPROCESS_AND_COMPILE: {
        return Joiner.on(' ').join(
            FluentIterable.from(makePreprocessCommand())
            .transform(Escaper.SHELL_ESCAPER)) +
            " | " +
            Joiner.on(' ').join(
                FluentIterable.from(
                    makeCompileCommand(
                        "-",
                        inputType.getPreprocessedLanguage()))
                .transform(Escaper.SHELL_ESCAPER));

      }

      default: {
        return Joiner.on(' ').join(
            FluentIterable.from(getCommand())
            .transform(Escaper.SHELL_ESCAPER));
      }
    }
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return getDescriptionNoContext();
  }

  public enum Operation {
    COMPILE,
    COMPILE_MUNGE_DEBUGINFO,
    PREPROCESS,
    PIPED_PREPROCESS_AND_COMPILE,
    ;

    public boolean isPreprocess() {
      return this == COMPILE_MUNGE_DEBUGINFO ||
          this == PREPROCESS ||
          this == PIPED_PREPROCESS_AND_COMPILE;
    }

    public boolean isCompile() {
      return this == COMPILE ||
          this == COMPILE_MUNGE_DEBUGINFO ||
          this == PIPED_PREPROCESS_AND_COMPILE;
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import static com.facebook.buck.cxx.DebugSectionProperty.COMPRESSED;
import static com.facebook.buck.cxx.DebugSectionProperty.STRINGS;
import static java.nio.channels.FileChannel.MapMode.READ_WRITE;
import static java.nio.file.StandardOpenOption.READ;
import static java.nio.file.StandardOpenOption.WRITE;

import com.facebook.buck.log.Logger;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.ExecutionException;


public class DebugPathSanitizer {

  private static final DebugSectionFinder DEBUG_SECTION_FINDER = new DebugSectionFinder();

  private final int pathSize;
  private final char separator;
  private final Path compilationDirectory;
  private final ImmutableBiMap<Path, Path> other;

  private final LoadingCache<Path, ImmutableBiMap<Path, Path>> pathCache =
      CacheBuilder
          .newBuilder()
          .softValues()
          .build(new CacheLoader<Path, ImmutableBiMap<Path, Path>>() {
            @Override
            public ImmutableBiMap<Path, Path> load(Path key) {
              return getAllPathsWork(key);
            }
          });


  public DebugPathSanitizer(
      int pathSize,
      char separator,
      Path compilationDirectory,
      ImmutableBiMap<Path, Path> other) {
    this.pathSize = pathSize;
    this.separator = separator;
    this.compilationDirectory = compilationDirectory;
    this.other = other;
  }


  public String getExpandedPath(Path path) {
    Preconditions.checkArgument(path.toString().length() <= pathSize);
    return Strings.padEnd(path.toString(), pathSize, separator);
  }

  private ImmutableBiMap<Path, Path> getAllPaths(Optional<Path> workingDir) {
    if (!workingDir.isPresent()) {
      return other;
    }

    try {
      return pathCache.get(workingDir.get());
    } catch (ExecutionException e) {
      Logger.get(DebugPathSanitizer.class).error(
          "Problem loading paths into cache",
          e);
      return getAllPathsWork(workingDir.get());
    }
  }

  private ImmutableBiMap<Path, Path> getAllPathsWork(Path workingDir) {
    ImmutableBiMap.Builder<Path, Path> builder = ImmutableBiMap.builder();
    builder.put(workingDir, compilationDirectory);
    builder.putAll(other);
    return builder.build();
  }

  public String getCompilationDirectory() {
    return getExpandedPath(compilationDirectory);
  }

  public Function<String, String> sanitize(final Optional<Path> workingDir) {
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return DebugPathSanitizer.this.sanitize(workingDir, input);
      }
    };
  }


  public String sanitize(Optional<Path> workingDir, String contents) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      String replacement = entry.getValue().toString();
      String pathToReplace = entry.getKey().toString();
      if (contents.contains(pathToReplace)) {



        contents = contents.replace(pathToReplace, replacement);
      }
    }
    return contents;
  }

  public String restore(Optional<Path> workingDir, String contents) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      contents = contents.replace(getExpandedPath(entry.getValue()), entry.getKey().toString());
    }
    return contents;
  }


  private void restore(ByteBuffer buffer, ByteBufferReplacer replacer) {


    Optional<ImmutableMap<String, DebugSection>> results = DEBUG_SECTION_FINDER.find(buffer);



    if (results.isPresent()) {
      for (DebugSection section : results.get().values()) {

        Preconditions.checkState(!section.properties.contains(COMPRESSED));
        if (section.properties.contains(STRINGS)) {
          replacer.replace(section.body);
        }
      }
    } else {
      replacer.replace(buffer);
    }
  }

  private void restore(Path path, ByteBufferReplacer replacer) throws IOException {
    try (FileChannel channel = FileChannel.open(path, READ, WRITE)) {
      MappedByteBuffer buffer = channel.map(READ_WRITE, 0, channel.size());
      restore(buffer, replacer);
    }
  }


  private ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir) {
    return new ByteBufferReplacer(
        ImmutableMap.of(
            getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),
            getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
  }



  public void restoreCompilationDirectory(Path path, Path workingDir) throws IOException {
    restore(path, getCompilationDirectoryReplacer(workingDir));
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.keys.SupportsInputBasedRuleKey;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.facebook.buck.util.Optionals;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;


public class CxxPreprocessAndCompile
    extends AbstractBuildRule
    implements RuleKeyAppendable, SupportsInputBasedRuleKey {

  @AddToRuleKey
  private final CxxPreprocessAndCompileStep.Operation operation;
  @AddToRuleKey
  private final Optional<Preprocessor> preprocessor;
  private final Optional<ImmutableList<String>> platformPreprocessorFlags;
  private final Optional<ImmutableList<String>> rulePreprocessorFlags;
  @AddToRuleKey
  private final Optional<Compiler> compiler;
  private final Optional<ImmutableList<String>> platformCompilerFlags;
  private final Optional<ImmutableList<String>> ruleCompilerFlags;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @AddToRuleKey
  private final SourcePath input;
  private final CxxSource.Type inputType;
  private final ImmutableSet<Path> includeRoots;
  private final ImmutableSet<Path> systemIncludeRoots;
  private final ImmutableSet<Path> frameworkRoots;
  @AddToRuleKey
  private final ImmutableList<CxxHeaders> includes;
  private final DebugPathSanitizer sanitizer;

  @VisibleForTesting
  CxxPreprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      CxxPreprocessAndCompileStep.Operation operation,
      Optional<Preprocessor> preprocessor,
      Optional<ImmutableList<String>> platformPreprocessorFlags,
      Optional<ImmutableList<String>> rulePreprocessorFlags,
      Optional<Compiler> compiler,
      Optional<ImmutableList<String>> platformCompilerFlags,
      Optional<ImmutableList<String>> ruleCompilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    Preconditions.checkState(operation.isPreprocess() == preprocessor.isPresent());
    Preconditions.checkState(operation.isPreprocess() == platformPreprocessorFlags.isPresent());
    Preconditions.checkState(operation.isPreprocess() == rulePreprocessorFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == compiler.isPresent());
    Preconditions.checkState(operation.isCompile() == platformCompilerFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == ruleCompilerFlags.isPresent());
    this.operation = operation;
    this.preprocessor = preprocessor;
    this.platformPreprocessorFlags = platformPreprocessorFlags;
    this.rulePreprocessorFlags = rulePreprocessorFlags;
    this.compiler = compiler;
    this.platformCompilerFlags = platformCompilerFlags;
    this.ruleCompilerFlags = ruleCompilerFlags;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.includeRoots = includeRoots;
    this.systemIncludeRoots = systemIncludeRoots;
    this.frameworkRoots = frameworkRoots;
    this.includes = includes;
    this.sanitizer = sanitizer;
  }


  public static CxxPreprocessAndCompile compile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Compiler compiler,
      ImmutableList<String> platformFlags,
      ImmutableList<String> ruleFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Preprocessor>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(compiler),
        Optional.of(platformFlags),
        Optional.of(ruleFlags),
        output,
        input,
        inputType,
        ImmutableSet.<Path>of(),
        ImmutableSet.<Path>of(),
        ImmutableSet.<Path>of(),
        ImmutableList.<CxxHeaders>of(),
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocess(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Preprocessor preprocessor,
      ImmutableList<String> platformFlags,
      ImmutableList<String> ruleFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(preprocessor),
        Optional.of(platformFlags),
        Optional.of(ruleFlags),
        Optional.<Compiler>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Preprocessor preprocessor,
      ImmutableList<String> platformPreprocessorFlags,
      ImmutableList<String> rulePreprocessorFlags,
      Compiler compiler,
      ImmutableList<String> platformCompilerFlags,
      ImmutableList<String> ruleCompilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableSet<Path> includeRoots,
      ImmutableSet<Path> systemIncludeRoots,
      ImmutableSet<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer,
      CxxPreprocessMode strategy) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        (strategy == CxxPreprocessMode.PIPED
            ? CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE
            : CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO),
        Optional.of(preprocessor),
        Optional.of(platformPreprocessorFlags),
        Optional.of(rulePreprocessorFlags),
        Optional.of(compiler),
        Optional.of(platformCompilerFlags),
        Optional.of(ruleCompilerFlags),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {


    builder.setReflectively("platformPreprocessorFlags", sanitizeFlags(platformPreprocessorFlags));
    builder.setReflectively("rulePreprocessorFlags", sanitizeFlags(rulePreprocessorFlags));
    builder.setReflectively("platformCompilerFlags", sanitizeFlags(platformCompilerFlags));
    builder.setReflectively("ruleCompilerFlags", sanitizeFlags(ruleCompilerFlags));
    ImmutableList<String> frameworkRoots = FluentIterable.from(this.frameworkRoots)
        .transform(Functions.toStringFunction())
        .transform(sanitizer.sanitize(Optional.<Path>absent()))
        .toList();
    builder.setReflectively("frameworkRoots", frameworkRoots);



    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      builder.setReflectively("compilationDirectory", sanitizer.getCompilationDirectory());
    }

    return builder;
  }

  private ImmutableList<String> sanitizeFlags(Optional<ImmutableList<String>> flags) {
    return FluentIterable.from(flags.or(ImmutableList.<String>of()))
        .transform(sanitizer.sanitize(Optional.<Path>absent()))
        .toList();
  }

  @VisibleForTesting
  CxxPreprocessAndCompileStep makeMainStep() {



    ImmutableMap.Builder<Path, Path> replacementPathsBuilder = ImmutableMap.builder();
    try {
      for (Map.Entry<Path, SourcePath> entry :
           CxxHeaders.concat(includes).getFullNameToPathMap().entrySet()) {
        replacementPathsBuilder.put(entry.getKey(), getResolver().getPath(entry.getValue()));
      }
    } catch (CxxHeaders.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
    }
    ImmutableMap<Path, Path> replacementPaths = replacementPathsBuilder.build();

    Optional<ImmutableList<String>> preprocessorCommand;
    if (preprocessor.isPresent()) {
      preprocessorCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(preprocessor.get().getCommandPrefix(getResolver()))
              .addAll(getPreprocessorPlatformPrefix())
              .addAll(getPreprocessorSuffix())
              .addAll(preprocessor.get().getExtraFlags().or(ImmutableList.<String>of()))
              .build());
    } else {
      preprocessorCommand = Optional.absent();
    }

    Optional<ImmutableList<String>> compilerCommand;
    if (compiler.isPresent()) {
      compilerCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(compiler.get().getCommandPrefix(getResolver()))
              .addAll(getCompilerPlatformPrefix())
              .addAll(getCompilerSuffix())
              .build());
    } else {
      compilerCommand = Optional.absent();
    }

    return new CxxPreprocessAndCompileStep(
        operation,
        output,
        getResolver().getPath(input),
        inputType,
        preprocessorCommand,
        compilerCommand,
        replacementPaths,
        sanitizer,
        Optionals.bind(
            preprocessor,
            new Function<Preprocessor, Optional<Function<String, Iterable<String>>>>() {
              @Override
              public Optional<Function<String, Iterable<String>>> apply(Preprocessor input) {
                return input.getExtraLineProcessor();
              }
            }));
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        makeMainStep());
  }

  private ImmutableList<String> getPreprocessorPlatformPrefix() {
    Preconditions.checkState(operation.isPreprocess());
    return platformPreprocessorFlags.get();
  }

  private ImmutableList<String> getCompilerPlatformPrefix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> flags = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      flags.addAll(getPreprocessorPlatformPrefix());
    }
    flags.addAll(platformCompilerFlags.get());
    return flags.build();
  }

  private ImmutableList<String> getPreprocessorSuffix() {
    Preconditions.checkState(operation.isPreprocess());
    ImmutableSet.Builder<SourcePath> prefixHeaders = ImmutableSet.builder();
    for (CxxHeaders cxxHeaders : includes) {
      prefixHeaders.addAll(cxxHeaders.getPrefixHeaders());
    }
    return ImmutableList.<String>builder()
        .addAll(rulePreprocessorFlags.get())
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-include"),
                FluentIterable.from(prefixHeaders.build())
                    .transform(getResolver().getPathFunction())
                    .transform(Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-I"),
                Iterables.transform(includeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-isystem"),
                Iterables.transform(systemIncludeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-F"),
                Iterables.transform(frameworkRoots, Functions.toStringFunction())))
        .build();
  }

  private ImmutableList<String> getCompilerSuffix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> suffix = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      suffix.addAll(getPreprocessorSuffix());
    }
    suffix.addAll(ruleCompilerFlags.get());
    suffix.addAll(
        compiler.get()
            .debugCompilationDirFlags(sanitizer.getCompilationDirectory())
            .or(ImmutableList.<String>of()));
    return suffix.build();
  }

  public ImmutableList<String> getCompileCommandCombinedWithPreprocessBuildRule(
      CxxPreprocessAndCompile preprocessBuildRule) {
    if (!operation.isCompile() ||
        !preprocessBuildRule.operation.isPreprocess()) {
      throw new HumanReadableException(
          "%s is not preprocess rule or %s is not compile rule.",
          preprocessBuildRule,
          this);
    }
    ImmutableList.Builder<String> cmd = ImmutableList.builder();
    cmd.addAll(compiler.get().getCommandPrefix(getResolver()));
    cmd.addAll(preprocessBuildRule.getPreprocessorPlatformPrefix());
    cmd.addAll(getCompilerPlatformPrefix());
    cmd.addAll(preprocessBuildRule.getPreprocessorSuffix());
    cmd.addAll(getCompilerSuffix());
    cmd.add("-x", preprocessBuildRule.inputType.getLanguage());
    cmd.add("-c");
    cmd.add("-o", output.toString());
    cmd.add(getResolver().getPath(preprocessBuildRule.input).toString());
    return cmd.build();
  }

  public ImmutableList<String> getCommand() {
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      return makeMainStep().getCommand();
    }
    return getCompileCommandCombinedWithPreprocessBuildRule(this);
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getRulePreprocessorFlags() {
    return rulePreprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPlatformPreprocessorFlags() {
    return platformPreprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getRuleCompilerFlags() {
    return ruleCompilerFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPlatformCompilerFlags() {
    return platformCompilerFlags;
  }

  public Path getOutput() {
    return output;
  }

  public SourcePath getInput() {
    return input;
  }

  public ImmutableList<CxxHeaders> getIncludes() {
    return includes;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.rules.keys.SupportsInputBasedRuleKey;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.FileScrubberStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Path;

public class CxxLink
    extends AbstractBuildRule
    implements RuleKeyAppendable, SupportsInputBasedRuleKey {

  @AddToRuleKey
  private final Linker linker;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @SuppressWarnings("PMD.UnusedPrivateField")
  @AddToRuleKey
  private final ImmutableList<SourcePath> inputs;


  private final ImmutableList<String> args;
  private final ImmutableSet<Path> frameworkRoots;
  private final DebugPathSanitizer sanitizer;

  public CxxLink(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Linker linker,
      Path output,
      ImmutableList<SourcePath> inputs,
      ImmutableList<String> args,
      ImmutableSet<Path> frameworkRoots,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    this.linker = linker;
    this.output = output;
    this.inputs = inputs;
    this.args = args;
    this.frameworkRoots = frameworkRoots;
    this.sanitizer = sanitizer;
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    return builder
        .setReflectively(
            "args",
            FluentIterable.from(args)
                .transform(sanitizer.sanitize(Optional.<Path>absent()))
                .toList())
        .setReflectively(
            "frameworkRoots",
            FluentIterable.from(frameworkRoots)
                .transform(Functions.toStringFunction())
                .transform(sanitizer.sanitize(Optional.<Path>absent()))
                .toList());
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        new CxxLinkStep(
            linker.getCommandPrefix(getResolver()),
            output,
            args,
            frameworkRoots),
        new FileScrubberStep(output, linker.getScrubbers()));
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  public Tool getLinker() {
    return linker;
  }

  public Path getOutput() {
    return output;
  }

  public ImmutableList<String> getArgs() {
    return args;
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertThat;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableBiMap;

import org.junit.Before;
import org.junit.Test;

import java.nio.file.Paths;

public class DebugPathSanitizerTest {

  DebugPathSanitizer debugPathSanitizer;

  @Before
  public void setUp() {
    debugPathSanitizer = new DebugPathSanitizer(
        40,
        '/',
        Paths.get("."),
        ImmutableBiMap.of(
            Paths.get("/some/absolute/path"),
            Paths.get("SYMBOLIC_NAME"),
            Paths.get("/another/path/with/subdirectories"),
            Paths.get("OTHER_NAME_WITH_SUFFIX"),
            Paths.get("/another/path"),
            Paths.get("OTHER_NAME")));
  }

  @Test
  public void sanitizeWithoutAnyMatches() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "an arbitrary string with no match"),
        equalTo("an arbitrary string with no match"));
  }

  @Test
  public void sanitizeProjectRoot() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "a string that mentions the /project/root somewhere"),
        equalTo("a string that mentions the . somewhere"));
  }

  @Test
  public void sanitizeOtherDirectories() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/some/absolute/path/dir -I/another/path"),
        equalTo("-ISYMBOLIC_NAME/dir -IOTHER_NAME"));
  }

  @Test
  public void sanitizeDirectoriesThatArePrefixOfOtherDirectories() {
    assertThat(
        debugPathSanitizer.sanitize(
            Optional.of(Paths.get("/project/root")),
            "-I/another/path/with/subdirectories/something"),
        equalTo("-IOTHER_NAME_WITH_SUFFIX/something"));
  }

  @Test
  public void restoreWithoutAnyMatches() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "an arbitrary string with no match"),
        equalTo("an arbitrary string with no match"));
  }

  @Test
  public void restoreProjectRoot() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "a string that mentions the ./////////////////////////////////////// somewhere"),
        equalTo("a string that mentions the /project/root somewhere"));
  }

  @Test
  public void restoreOtherDirectories() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "-ISYMBOLIC_NAME////////////////////////////dir " +
                "-IOTHER_NAME//////////////////////////////"),
        equalTo("-I/some/absolute/path/dir -I/another/path"));
  }

  @Test
  public void restoreDirectoriesThatArePrefixOfOtherDirectories() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            "-IOTHER_NAME_WITH_SUFFIX///////////////////something"),
        equalTo("-I/another/path/with/subdirectories/something"));
  }

  @Test
  public void restoreDoesNotTouchUnexpandedPaths() {
    assertThat(
        debugPathSanitizer.restore(
            Optional.of(Paths.get("/project/root")),
            ". -ISYMBOLIC_NAME/ OTHER_NAME"),
        equalTo(". -ISYMBOLIC_NAME/ OTHER_NAME"));
  }

}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.google.common.collect.ImmutableSet;

public class IosReactNativeLibraryDescription
    implements Description<ReactNativeLibraryArgs>, Flavored {

  private static final BuildRuleType TYPE = BuildRuleType.of("ios_react_native_library");

  private final ReactNativeLibraryGraphEnhancer enhancer;

  public IosReactNativeLibraryDescription(ReactNativeBuckConfig buckConfig) {
    this.enhancer = new ReactNativeLibraryGraphEnhancer(buckConfig);
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public ReactNativeLibraryArgs createUnpopulatedConstructorArg() {
    return new ReactNativeLibraryArgs();
  }

  @Override
  public <A extends ReactNativeLibraryArgs> ReactNativeBundle createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    return enhancer.enhanceForIos(params, resolver, args);
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return ReactNativeFlavors.validateFlavors(flavors);
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.android.AndroidResource;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.Sha1HashCode;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;

import java.nio.file.Path;

public class ReactNativeLibraryGraphEnhancer {

  private static final Flavor REACT_NATIVE_DEPS_FLAVOR = ImmutableFlavor.of("rn_deps");
  private static final Flavor REACT_NATIVE_BUNDLE_FLAVOR = ImmutableFlavor.of("bundle");
  private static final Flavor REACT_NATIVE_ANDROID_RES_FLAVOR = ImmutableFlavor.of("android_res");

  private final ReactNativeBuckConfig buckConfig;

  public ReactNativeLibraryGraphEnhancer(ReactNativeBuckConfig buckConfig) {
    this.buckConfig = buckConfig;
  }

  private ReactNativeDeps createReactNativeDeps(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      ReactNativeLibraryArgs args,
      ReactNativePlatform platform) {
    BuildTarget originalBuildTarget = params.getBuildTarget();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);


    BuildTarget depsFinderTarget = BuildTarget.builder(originalBuildTarget)
        .addFlavors(REACT_NATIVE_DEPS_FLAVOR)
        .build();
    BuildRuleParams paramsForDepsFinder = params.copyWithBuildTarget(depsFinderTarget);
    ReactNativeDeps depsFinder = new ReactNativeDeps(
        paramsForDepsFinder,
        sourcePathResolver,
        getPackager(),
        args.srcs.get(),
        args.entryPath,
        platform);
    return resolver.addToIndex(depsFinder);
  }

  public AndroidReactNativeLibrary enhanceForAndroid(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      AndroidReactNativeLibraryDescription.Args args) {
    final ReactNativeDeps reactNativeDeps =
        createReactNativeDeps(params, resolver, args, ReactNativePlatform.ANDROID);

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    BuildTarget originalBuildTarget = params.getBuildTarget();
    BuildRuleParams paramsForBundle =
        params.copyWithBuildTarget(
            BuildTarget.builder(originalBuildTarget)
                .addFlavors(REACT_NATIVE_BUNDLE_FLAVOR)
                .build())
            .copyWithExtraDeps(
                Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(reactNativeDeps)));
    ReactNativeBundle bundle = new ReactNativeBundle(
        paramsForBundle,
        sourcePathResolver,
        args.entryPath,
        ReactNativeFlavors.isDevMode(originalBuildTarget),
        args.bundleName,
        getPackager(),
        ReactNativePlatform.ANDROID,
        reactNativeDeps);
    resolver.addToIndex(bundle);

    ImmutableList.Builder<BuildRule> extraDeps = ImmutableList.builder();
    extraDeps.add(bundle);
    if (args.rDotJavaPackage.isPresent()) {
      BuildRuleParams paramsForResource =
          params.copyWithBuildTarget(
              BuildTarget.builder(originalBuildTarget)
                  .addFlavors(REACT_NATIVE_ANDROID_RES_FLAVOR)
                  .build())
              .copyWithExtraDeps(Suppliers.ofInstance(
                      ImmutableSortedSet.<BuildRule>of(bundle, reactNativeDeps)));

      BuildRule resource = new AndroidResource(
              paramsForResource,
              sourcePathResolver,
 ImmutableSortedSet.<BuildRule>of(),
              new PathSourcePath(params.getProjectFilesystem(), bundle.getPathToResources()),
 ImmutableSortedSet.<Path>of(),
              args.rDotJavaPackage.get(),
 null,
 ImmutableSortedSet.<Path>of(),
 null,
 false,
              Optional.of(
                  Suppliers.memoize(
                      new Supplier<Sha1HashCode>() {
                        @Override
                        public Sha1HashCode get() {
                          return reactNativeDeps.getInputsHash();
                        }
                      })));
      resolver.addToIndex(resource);
      extraDeps.add(resource);
    }

    return new AndroidReactNativeLibrary(
        params.appendExtraDeps(extraDeps.build()),
        sourcePathResolver,
        bundle);
  }

  public ReactNativeBundle enhanceForIos(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      ReactNativeLibraryArgs args) {
    ReactNativeDeps reactNativeDeps =
        createReactNativeDeps(params, resolver, args, ReactNativePlatform.IOS);

    return new ReactNativeBundle(
        params.appendExtraDeps(ImmutableList.of((BuildRule) reactNativeDeps)),
        new SourcePathResolver(resolver),
        args.entryPath,
        ReactNativeFlavors.isDevMode(params.getBuildTarget()),
        args.bundleName,
        getPackager(),
        ReactNativePlatform.IOS,
        reactNativeDeps);
  }

  private SourcePath getPackager() {
    Optional<SourcePath> packager = buckConfig.getPackager();
    if (!packager.isPresent()) {
      throw new HumanReadableException("In order to use a 'react_native_library' rule, please " +
          "specify 'packager' in .buckconfig under the 'react-native' section.");
    }
    return packager.get();
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.Step;
import com.google.common.collect.ImmutableList;

import java.nio.file.Path;

public class AndroidReactNativeLibrary extends AbstractBuildRule implements AndroidPackageable {

  private final ReactNativeBundle bundle;

  protected AndroidReactNativeLibrary(
      BuildRuleParams buildRuleParams,
      SourcePathResolver resolver,
      ReactNativeBundle bundle) {
    super(buildRuleParams, resolver);
    this.bundle = bundle;
  }

  @Override
  public Iterable<AndroidPackageable> getRequiredPackageables() {
    return AndroidPackageableCollector.getPackageableRules(getDeps());
  }

  @Override
  public void addToCollector(AndroidPackageableCollector collector) {
    collector.addAssetsDirectory(
        getBuildTarget(),
        new PathSourcePath(getProjectFilesystem(), bundle.getPathToJSBundleDir()));
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    return ImmutableList.of();
  }

  @Override
  public Path getPathToOutput() {
    return bundle.getPathToOutput();
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbiRule;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.Sha1HashCode;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.shell.ShellStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.google.common.collect.ImmutableList;

import java.nio.file.Path;


public class ReactNativeBundle extends AbstractBuildRule implements AbiRule {

  @AddToRuleKey
  private final SourcePath entryPath;

  @AddToRuleKey
  private final boolean isDevMode;

  @AddToRuleKey
  private final SourcePath jsPackager;

  @AddToRuleKey
  private final ReactNativePlatform platform;

  private final ReactNativeDeps depsFinder;
  private final Path jsOutput;
  private final Path resource;

  protected ReactNativeBundle(
      BuildRuleParams ruleParams,
      SourcePathResolver resolver,
      SourcePath entryPath,
      boolean isDevMode,
      String bundleName,
      SourcePath jsPackager,
      ReactNativePlatform platform,
      ReactNativeDeps depsFinder) {
    super(ruleParams, resolver);
    this.entryPath = entryPath;
    this.isDevMode = isDevMode;
    this.jsPackager = jsPackager;
    this.platform = platform;
    this.depsFinder = depsFinder;
    BuildTarget buildTarget = ruleParams.getBuildTarget();
    this.jsOutput = BuildTargets.getGenPath(buildTarget, "__%s_js__/").resolve(bundleName);
    this.resource = BuildTargets.getGenPath(buildTarget, "__%s_res__/").resolve("res");
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();
    steps.add(new MakeCleanDirectoryStep(jsOutput.getParent()));
    steps.add(new MakeCleanDirectoryStep(resource));

    steps.add(
        new ShellStep() {
          @Override
          public String getShortName() {
            return "bundle_react_native";
          }

          @Override
          protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {
            ProjectFilesystem filesystem = context.getProjectFilesystem();
            return ImmutableList.of(
                getResolver().getPath(jsPackager).toString(),
                "bundle",
                "--entry-file", filesystem.resolve(getResolver().getPath(entryPath)).toString(),
                "--platform", platform.toString(),
                "--dev", isDevMode ? "true" : "false",
                "--bundle-output", filesystem.resolve(jsOutput).toString(),
                "--assets-dest", filesystem.resolve(resource).toString());
          }
        });
    buildableContext.recordArtifact(jsOutput);
    buildableContext.recordArtifact(resource);
    return steps.build();
  }

  public Path getPathToJSBundleDir() {
    return jsOutput.getParent();
  }

  public Path getPathToResources() {
    return resource;
  }

  @Override
  public Path getPathToOutput() {
    return jsOutput;
  }

  @Override
  public Sha1HashCode getAbiKeyForDeps() {
    return depsFinder.getInputsHash();
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.cxx.NativeTestable;
import com.facebook.buck.cxx.Tool;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.CopyStep;
import com.facebook.buck.step.fs.FindAndReplaceStep;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.step.fs.WriteFileStep;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import com.dd.plist.NSObject;
import com.dd.plist.NSNumber;
import com.dd.plist.NSString;

import java.nio.file.Path;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;


public class AppleBundle extends AbstractBuildRule implements NativeTestable {
  private static final Logger LOG = Logger.get(AppleBundle.class);

  @AddToRuleKey
  private final String extension;

  @AddToRuleKey
  private final Optional<SourcePath> infoPlist;

  @AddToRuleKey
  private final ImmutableMap<String, String> infoPlistSubstitutions;

  @AddToRuleKey
  private final Optional<BuildRule> binary;

  @AddToRuleKey
  private final AppleBundleDestinations destinations;

  @AddToRuleKey
  private final Set<SourcePath> resourceDirs;

  @AddToRuleKey
  private final Set<SourcePath> resourceFiles;

  @AddToRuleKey
  private final Tool ibtool;

  @AddToRuleKey
  private final Tool dsymutil;

  @AddToRuleKey
  private final ImmutableSortedSet<BuildTarget> tests;

  @AddToRuleKey
  private final String platformName;

  @AddToRuleKey
  private final String sdkName;

  private final ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs;

  private final Optional<AppleAssetCatalog> mergedAssetCatalog;

  private final String binaryName;
  private final Path bundleRoot;
  private final Path binaryPath;

  AppleBundle(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Either<AppleBundleExtension, String> extension,
      Optional<SourcePath> infoPlist,
      Map<String, String> infoPlistSubstitutions,
      Optional<BuildRule> binary,
      AppleBundleDestinations destinations,
      Set<SourcePath> resourceDirs,
      Set<SourcePath> resourceFiles,
      Tool ibtool,
      Tool dsymutil,
      Set<AppleAssetCatalog> bundledAssetCatalogs,
      Optional<AppleAssetCatalog> mergedAssetCatalog,
      Set<BuildTarget> tests,
      String platformName,
      String sdkName) {
    super(params, resolver);
    this.extension = extension.isLeft() ?
        extension.getLeft().toFileExtension() :
        extension.getRight();
    this.infoPlist = infoPlist;
    this.infoPlistSubstitutions = ImmutableMap.copyOf(infoPlistSubstitutions);
    this.binary = binary;
    this.destinations = destinations;
    this.resourceDirs = resourceDirs;
    this.resourceFiles = resourceFiles;
    this.ibtool = ibtool;
    this.dsymutil = dsymutil;
    this.bundledAssetCatalogs = ImmutableSet.copyOf(bundledAssetCatalogs);
    this.mergedAssetCatalog = mergedAssetCatalog;
    this.binaryName = getBinaryName(getBuildTarget());
    this.bundleRoot = getBundleRoot(getBuildTarget(), this.extension);
    this.binaryPath = this.destinations.getExecutablesPath()
        .resolve(this.binaryName);
    this.tests = ImmutableSortedSet.copyOf(tests);
    this.platformName = platformName;
    this.sdkName = sdkName;
  }

  private static String getBinaryName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  public static Path getBundleRoot(BuildTarget buildTarget, String extension) {
    return BuildTargets
        .getGenPath(buildTarget, "%s")
        .resolve(getBinaryName(buildTarget) + "." + extension);
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return bundleRoot;
  }

  public Path getInfoPlistPath() {
    return getMetadataPath().resolve("Info.plist");
  }

  public Path getUnzippedOutputFilePathToBinary() {
    return this.binaryPath;
  }

  private Path getMetadataPath() {
    return bundleRoot.resolve(destinations.getMetadataPath());
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> stepsBuilder = ImmutableList.builder();

    Path metadataPath = getMetadataPath();

    Path infoPlistInputPath = getResolver().getPath(infoPlist.get());
    Path infoPlistSubstitutionTempPath =
        BuildTargets.getScratchPath(getBuildTarget(), "%s.plist");
    Path infoPlistOutputPath = metadataPath.resolve("Info.plist");

    stepsBuilder.add(
        new MakeCleanDirectoryStep(bundleRoot),
        new MkdirStep(metadataPath),

        new WriteFileStep("APPLWRUN", metadataPath.resolve("PkgInfo")),
        new FindAndReplaceStep(
            infoPlistInputPath,
            infoPlistSubstitutionTempPath,
            InfoPlistSubstitution.createVariableExpansionFunction(
                withDefaults(
                    infoPlistSubstitutions,
                    ImmutableMap.of(
                        "EXECUTABLE_NAME", binaryName,
                        "PRODUCT_NAME", binaryName
                    ))
            )),
        new PlistProcessStep(
            infoPlistSubstitutionTempPath,
            infoPlistOutputPath,
            getInfoPlistAdditionalKeys(platformName, sdkName),
            getInfoPlistOverrideKeys(platformName)));

    if (binary.isPresent()) {
      stepsBuilder.add(
          new MkdirStep(bundleRoot.resolve(this.destinations.getExecutablesPath())));
      Path bundleBinaryPath = bundleRoot.resolve(binaryPath);
      stepsBuilder.add(
          CopyStep.forFile(
              binary.get().getPathToOutput(),
              bundleBinaryPath));
      stepsBuilder.add(
          new DsymStep(
              dsymutil.getCommandPrefix(getResolver()),
              bundleBinaryPath,
              bundleBinaryPath.resolveSibling(
                  bundleBinaryPath.getFileName().toString() + ".dSYM")));
    }

    for (SourcePath dir : resourceDirs) {
      Path bundleDestinationPath = bundleRoot.resolve(this.destinations.getResourcesPath());
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }
    for (SourcePath file : resourceFiles) {
      Path bundleDestinationPath = bundleRoot.resolve(this.destinations.getResourcesPath());
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      Path resolvedFilePath = getResolver().getPath(file);
      Path destinationPath = bundleDestinationPath.resolve(resolvedFilePath.getFileName());
      addResourceProcessingSteps(resolvedFilePath, destinationPath, stepsBuilder);
    }

    for (AppleAssetCatalog bundledAssetCatalog : bundledAssetCatalogs) {
      Path bundleDir = bundledAssetCatalog.getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }

    if (mergedAssetCatalog.isPresent()) {
      Path bundleDir = mergedAssetCatalog.get().getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }


    buildableContext.recordArtifact(bundleRoot);

    return stepsBuilder.build();
  }

  static ImmutableMap<String, String> withDefaults(
      ImmutableMap<String, String> map,
      ImmutableMap<String, String> defaults) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.<String, String>builder()
        .putAll(map);
    for (ImmutableMap.Entry<String, String> entry : defaults.entrySet()) {
      if (!map.containsKey(entry.getKey())) {
        builder = builder.put(entry.getKey(), entry.getValue());
      }
    }
    return builder.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistOverrideKeys(
      String platformName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("LSRequiresIPhoneOS", new NSNumber(false));
    } else {
      keys.put("LSRequiresIPhoneOS", new NSNumber(true));
    }

    return keys.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistAdditionalKeys(
      String platformName,
      String sdkName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("NSHighResolutionCapable", new NSNumber(true));
      keys.put("NSSupportsAutomaticGraphicsSwitching", new NSNumber(true));
    }

    keys.put("DTPlatformName", new NSString(platformName));
    keys.put("DTSDKName", new NSString(sdkName));

    return keys.build();
  }

  private void addResourceProcessingSteps(
      Path sourcePath,
      Path destinationPath,
      ImmutableList.Builder<Step> stepsBuilder) {
    String sourcePathExtension = Files.getFileExtension(sourcePath.toString())
        .toLowerCase(Locale.US);
    switch (sourcePathExtension) {
      case "xib":
        String compiledNibFilename = Files.getNameWithoutExtension(destinationPath.toString()) +
            ".nib";
        Path compiledNibPath = destinationPath.getParent().resolve(compiledNibFilename);
        LOG.debug("Compiling XIB %s to NIB %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new IbtoolStep(
                ibtool.getCommandPrefix(getResolver()),
                sourcePath,
                compiledNibPath));
        break;
      default:
        stepsBuilder.add(CopyStep.forFile(sourcePath, destinationPath));
        break;
    }
  }

  @Override
  public boolean isTestedBy(BuildTarget testRule) {
    if (tests.contains(testRule)) {
      return true;
    }

    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).isTestedBy(testRule);
      }
    }

    return false;
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).getCxxPreprocessorInput(cxxPlatform, headerVisibility);
      }
    }
    return CxxPreprocessorInput.EMPTY;
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.google.common.base.Function;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableSet;

import java.util.Set;

public class AppleResources {

  private AppleResources() { }


  public static <T> ImmutableSet<AppleResourceDescription.Arg> collectRecursiveResources(
      final TargetGraph targetGraph,
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.COPYING,
                ImmutableSet.of(AppleResourceDescription.TYPE)))
        .transform(
            new Function<TargetNode<?>, AppleResourceDescription.Arg>() {
              @Override
              public AppleResourceDescription.Arg apply(TargetNode<?> input) {
                return (AppleResourceDescription.Arg) input.getConstructorArg();
              }
            })
        .toSet();
  }

  public static void addResourceDirsToBuilder(
      ImmutableSet.Builder<SourcePath> resourceDirsBuilder,
      Iterable<AppleResourceDescription.Arg> resourceDescriptions) {
    resourceDirsBuilder.addAll(
        FluentIterable
            .from(resourceDescriptions)
            .transformAndConcat(
                new Function<AppleResourceDescription.Arg, Set<SourcePath>>() {
                  @Override
                  public Set<SourcePath> apply(AppleResourceDescription.Arg arg) {
                    return arg.dirs;
                  }
                })
    );
  }

  public static void addResourceFilesToBuilder(
      ImmutableSet.Builder<SourcePath> resourceFilesBuilder,
      Iterable<AppleResourceDescription.Arg> resourceDescriptions) {
    resourceFilesBuilder.addAll(
        FluentIterable
            .from(resourceDescriptions)
            .transformAndConcat(
                new Function<AppleResourceDescription.Arg, Set<SourcePath>>() {
                  @Override
                  public Set<SourcePath> apply(AppleResourceDescription.Arg arg) {
                    return arg.files;
                  }
                })
    );
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxCompilationDatabase;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

import java.util.Map;
import java.util.Set;

public class AppleTestDescription implements
    Description<AppleTestDescription.Arg>,
    Flavored,
    ImplicitDepsInferringDescription<AppleTestDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("apple_test");

  private static final Logger LOG = Logger.get(AppleTestDescription.class);


  private static final Flavor LIBRARY_FLAVOR = ImmutableFlavor.of("apple-test-library");
  private static final Flavor BUNDLE_FLAVOR = ImmutableFlavor.of("apple-test-bundle");

  private static final Set<Flavor> SUPPORTED_FLAVORS = ImmutableSet.of(
      LIBRARY_FLAVOR, BUNDLE_FLAVOR);

  private static final Predicate<Flavor> IS_SUPPORTED_FLAVOR = Predicates.in(SUPPORTED_FLAVORS);

  private static final Set<Flavor> NON_LIBRARY_FLAVORS = ImmutableSet.of(
      CxxCompilationDatabase.COMPILATION_DATABASE,
      CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR,
      CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR);

  private final AppleConfig appleConfig;
  private final AppleBundleDescription appleBundleDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleTestDescription(
      AppleConfig appleConfig,
      AppleBundleDescription appleBundleDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleConfig = appleConfig;
    this.appleBundleDescription = appleBundleDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return FluentIterable.from(flavors).allMatch(IS_SUPPORTED_FLAVOR) ||
        appleLibraryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    String extension = args.extension.isLeft() ?
        args.extension.getLeft().toFileExtension() :
        args.extension.getRight();
    if (!AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS.contains(extension)) {
      throw new HumanReadableException(
          "Invalid bundle extension for apple_test rule: %s (must be one of %s)",
          extension,
          AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS);
    }
    boolean createBundle = Sets.intersection(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS).isEmpty();
    Sets.SetView<Flavor> nonLibraryFlavors = Sets.difference(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS);
    boolean addDefaultPlatform = nonLibraryFlavors.isEmpty();
    ImmutableSet.Builder<Flavor> extraFlavorsBuilder = ImmutableSet.builder();
    if (createBundle) {
      extraFlavorsBuilder.add(
          LIBRARY_FLAVOR,
          CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR);
    }
    if (addDefaultPlatform) {
      extraFlavorsBuilder.add(defaultCxxPlatform.getFlavor());
    }

    Optional<AppleBundle> testHostApp;
    Optional<SourcePath> testHostAppBinarySourcePath;
    if (args.testHostApp.isPresent()) {
      TargetNode<?> testHostAppNode = params.getTargetGraph().get(args.testHostApp.get());
      Preconditions.checkNotNull(testHostAppNode);

      if (testHostAppNode.getType() != AppleBundleDescription.TYPE) {
        throw new HumanReadableException(
            "Apple test rule %s has unrecognized test_host_app %s type %s (should be %s)",
            params.getBuildTarget(),
            args.testHostApp.get(),
            testHostAppNode.getType(),
            AppleBundleDescription.TYPE);
      }

      AppleBundleDescription.Arg testHostAppDescription = (AppleBundleDescription.Arg)
          testHostAppNode.getConstructorArg();

      testHostApp = Optional.of(
          appleBundleDescription.createBuildRule(
              params.copyWithChanges(
                  BuildTarget.builder(args.testHostApp.get())
                      .addAllFlavors(nonLibraryFlavors)
                      .build(),
                  Suppliers.ofInstance(
                      BuildRules.toBuildRulesFor(
                          args.testHostApp.get(),
                          resolver,
                          testHostAppNode.getDeclaredDeps())),
                  Suppliers.ofInstance(
                      BuildRules.toBuildRulesFor(
                          args.testHostApp.get(),
                          resolver,
                          testHostAppNode.getExtraDeps()))),
              resolver,
              testHostAppDescription));
      testHostAppBinarySourcePath = Optional.<SourcePath>of(
          new BuildTargetSourcePath(
              params.getProjectFilesystem(),
              testHostAppDescription.binary));
    } else {
      testHostApp = Optional.absent();
      testHostAppBinarySourcePath = Optional.absent();
    }

    BuildRule library = appleLibraryDescription.createBuildRule(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget())
                .addAllFlavors(extraFlavorsBuilder.build())
                .build(),
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        resolver,
        args,


        Optional.of(Linker.LinkableDepType.STATIC),
        testHostAppBinarySourcePath);
    if (!createBundle) {
      return library;
    }

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple test requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);
    ImmutableSet<AppleResourceDescription.Arg> resourceDescriptions =
        AppleResources.collectRecursiveResources(
            params.getTargetGraph(),
            ImmutableSet.of(params.getTargetGraph().get(params.getBuildTarget())));
    LOG.debug("Got resource nodes %s", resourceDescriptions);
    ImmutableSet.Builder<SourcePath> resourceDirsBuilder = ImmutableSet.builder();
    AppleResources.addResourceDirsToBuilder(resourceDirsBuilder, resourceDescriptions);
    ImmutableSet<SourcePath> resourceDirs = resourceDirsBuilder.build();

    ImmutableSet.Builder<SourcePath> resourceFilesBuilder = ImmutableSet.builder();
    AppleResources.addResourceFilesToBuilder(resourceFilesBuilder, resourceDescriptions);
    ImmutableSet<SourcePath> resourceFiles = resourceFilesBuilder.build();

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();

    String sdkName = appleCxxPlatform.getAppleSdk().getName();
    String platformName = appleCxxPlatform.getAppleSdk().getApplePlatform().getName();

    AppleBundle bundle = new AppleBundle(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget()).addFlavors(BUNDLE_FLAVOR).build(),


            Suppliers.ofInstance(
                ImmutableSortedSet.<BuildRule>naturalOrder()
                    .add(library)
                    .addAll(mergedAssetCatalog.asSet())
                    .addAll(bundledAssetCatalogs)
                    .addAll(params.getDeclaredDeps())
                    .addAll(
                        BuildRules.toBuildRulesFor(
                            params.getBuildTarget(),
                            resolver,
                            SourcePaths.filterBuildTargetSourcePaths(
                                Iterables.concat(resourceFiles, resourceDirs))))
                    .build()),
            Suppliers.ofInstance(params.getExtraDeps())),
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(library),
        destinations,
        resourceDirs,
        resourceFiles,
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        ImmutableSortedSet.<BuildTarget>of(),
        platformName,
        sdkName);


    Optional<BuildRule> xctoolZipBuildRule;
    if (appleConfig.getXctoolZipTarget().isPresent()) {
      xctoolZipBuildRule = Optional.of(
          resolver.getRule(appleConfig.getXctoolZipTarget().get()));
    } else {
      xctoolZipBuildRule = Optional.absent();
    }

    return new AppleTest(
        appleConfig.getXctoolPath(),
        xctoolZipBuildRule,
        appleCxxPlatform.getXctest(),
        appleCxxPlatform.getOtest(),
        appleConfig.getXctestPlatformNames().contains(platformName),
        platformName,
        Optional.<String>absent(),
        params.copyWithDeps(
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(bundle)),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        sourcePathResolver,
        bundle,
        testHostApp,
        extension,
        args.contacts.get(),
        args.labels.get());
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      AppleTestDescription.Arg constructorArg) {



    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();
    Optional<BuildTarget> xctoolZipTarget = appleConfig.getXctoolZipTarget();
    if (xctoolZipTarget.isPresent()) {
      deps.add(xctoolZipTarget.get());
    }
    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends AppleNativeTargetDescriptionArg implements HasAppleBundleFields {
    public Optional<ImmutableSortedSet<String>> contacts;
    public Optional<ImmutableSortedSet<Label>> labels;
    public Optional<Boolean> canGroup;
    public Optional<BuildTarget> testHostApp;


    public Either<AppleBundleExtension, String> extension;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<String> xcodeProductType;
    public Optional<String> resourcePrefixDir;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }

    public boolean canGroup() {
      return canGroup.or(false);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Hint;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

import java.util.Map;
import java.util.Set;

public class AppleBundleDescription implements Description<AppleBundleDescription.Arg>, Flavored {
  public static final BuildRuleType TYPE = BuildRuleType.of("apple_bundle");

  private final AppleBinaryDescription appleBinaryDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleBundleDescription(
      AppleBinaryDescription appleBinaryDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleBinaryDescription = appleBinaryDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return appleLibraryDescription.hasFlavors(flavors) ||
        appleBinaryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> AppleBundle createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple bundle requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    ImmutableSet.Builder<SourcePath> bundleDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleFilesBuilder = ImmutableSet.builder();
    ImmutableSet<AppleResourceDescription.Arg> resourceDescriptions =
        AppleResources.collectRecursiveResources(
            params.getTargetGraph(),
            ImmutableSet.of(params.getTargetGraph().get(params.getBuildTarget())));
    AppleResources.addResourceDirsToBuilder(bundleDirsBuilder, resourceDescriptions);
    AppleResources.addResourceFilesToBuilder(bundleFilesBuilder, resourceDescriptions);
    ImmutableSet<SourcePath> bundleDirs = bundleDirsBuilder.build();
    ImmutableSet<SourcePath> bundleFiles = bundleFilesBuilder.build();

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();



    BuildRule flavoredBinaryRule = getFlavoredBinaryRule(params, resolver, args);
    BuildRuleParams bundleParamsWithFlavoredBinaryDep = getBundleParamsWithUpdatedDeps(
        params,
        args.binary,
        ImmutableSet.<BuildRule>builder()
            .add(flavoredBinaryRule)
            .addAll(mergedAssetCatalog.asSet())
            .addAll(bundledAssetCatalogs)
            .addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    SourcePaths.filterBuildTargetSourcePaths(
                        Iterables.concat(bundleFiles, bundleDirs))))
            .build());

    return new AppleBundle(
        bundleParamsWithFlavoredBinaryDep,
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(flavoredBinaryRule),
        destinations,
        bundleDirs,
        bundleFiles,
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        args.getTests(),
        appleCxxPlatform.getAppleSdk().getApplePlatform().getName(),
        appleCxxPlatform.getAppleSdk().getName());
  }

  private static <A extends Arg> BuildRule getFlavoredBinaryRule(
      final BuildRuleParams params,
      final BuildRuleResolver resolver,
      final A args) {
    final TargetNode<?> binaryTargetNode = params.getTargetGraph().get(args.binary);
    BuildRuleParams binaryRuleParams = new BuildRuleParams(
        args.binary,
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getDeclaredDeps())),
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getExtraDeps())),
        params.getProjectFilesystem(),
        params.getRuleKeyBuilderFactory(),
        params.getTargetGraph());
    return CxxDescriptionEnhancer.requireBuildRule(
        binaryRuleParams,
        resolver,
        params.getBuildTarget().getFlavors().toArray(new Flavor[0]));
  }

  private static BuildRuleParams getBundleParamsWithUpdatedDeps(
      final BuildRuleParams params,
      final BuildTarget originalBinaryTarget,
      final Set<BuildRule> newDeps) {

    final Predicate<BuildRule> notOriginalBinaryRule = Predicates.not(
        BuildRules.isBuildRuleWithTarget(originalBinaryTarget));
    return params.copyWithDeps(
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getDeclaredDeps())
                .filter(notOriginalBinaryRule)
                .append(newDeps)
                .toSortedSet(Ordering.natural())),
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getExtraDeps())
                .filter(notOriginalBinaryRule)
                .toSortedSet(Ordering.natural())));
  }

  @SuppressFieldNotInitialized
  public static class Arg implements HasAppleBundleFields, HasTests {
    public Either<AppleBundleExtension, String> extension;
    public BuildTarget binary;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<ImmutableMap<String, SourcePath>> headers;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
    @Hint(isDep = false) public Optional<ImmutableSortedSet<BuildTarget>> tests;
    public Optional<String> xcodeProductType;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public ImmutableSortedSet<BuildTarget> getTests() {
      return tests.get();
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.google.common.collect.ImmutableSet;

public class IosReactNativeLibraryDescription
    implements Description<ReactNativeLibraryArgs>, Flavored {

  public static final BuildRuleType TYPE = BuildRuleType.of("ios_react_native_library");

  private final ReactNativeLibraryGraphEnhancer enhancer;

  public IosReactNativeLibraryDescription(ReactNativeBuckConfig buckConfig) {
    this.enhancer = new ReactNativeLibraryGraphEnhancer(buckConfig);
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public ReactNativeLibraryArgs createUnpopulatedConstructorArg() {
    return new ReactNativeLibraryArgs();
  }

  @Override
  public <A extends ReactNativeLibraryArgs> ReactNativeBundle createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    return enhancer.enhanceForIos(params, resolver, args);
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return ReactNativeFlavors.validateFlavors(flavors);
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.android.AndroidResource;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.Sha1HashCode;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;

import java.nio.file.Path;

public class ReactNativeLibraryGraphEnhancer {

  private static final Flavor REACT_NATIVE_DEPS_FLAVOR = ImmutableFlavor.of("rn_deps");
  private static final Flavor REACT_NATIVE_BUNDLE_FLAVOR = ImmutableFlavor.of("bundle");
  private static final Flavor REACT_NATIVE_ANDROID_RES_FLAVOR = ImmutableFlavor.of("android_res");

  private final ReactNativeBuckConfig buckConfig;

  public ReactNativeLibraryGraphEnhancer(ReactNativeBuckConfig buckConfig) {
    this.buckConfig = buckConfig;
  }

  private ReactNativeDeps createReactNativeDeps(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      ReactNativeLibraryArgs args,
      ReactNativePlatform platform) {
    BuildTarget originalBuildTarget = params.getBuildTarget();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);


    BuildTarget depsFinderTarget = BuildTarget.builder(originalBuildTarget)
        .addFlavors(REACT_NATIVE_DEPS_FLAVOR)
        .build();
    BuildRuleParams paramsForDepsFinder = params.copyWithBuildTarget(depsFinderTarget);
    ReactNativeDeps depsFinder = new ReactNativeDeps(
        paramsForDepsFinder,
        sourcePathResolver,
        getPackager(),
        args.srcs.get(),
        args.entryPath,
        platform);
    return resolver.addToIndex(depsFinder);
  }

  public AndroidReactNativeLibrary enhanceForAndroid(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      AndroidReactNativeLibraryDescription.Args args) {
    final ReactNativeDeps reactNativeDeps =
        createReactNativeDeps(params, resolver, args, ReactNativePlatform.ANDROID);

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    BuildTarget originalBuildTarget = params.getBuildTarget();
    BuildRuleParams paramsForBundle =
        params.copyWithBuildTarget(
            BuildTarget.builder(originalBuildTarget)
                .addFlavors(REACT_NATIVE_BUNDLE_FLAVOR)
                .build())
            .copyWithExtraDeps(
                Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(reactNativeDeps)));
    ReactNativeBundle bundle = new ReactNativeBundle(
        paramsForBundle,
        sourcePathResolver,
        args.entryPath,
        ReactNativeFlavors.isDevMode(originalBuildTarget),
        args.bundleName,
        getPackager(),
        ReactNativePlatform.ANDROID,
        reactNativeDeps);
    resolver.addToIndex(bundle);

    ImmutableList.Builder<BuildRule> extraDeps = ImmutableList.builder();
    extraDeps.add(bundle);
    if (args.rDotJavaPackage.isPresent()) {
      BuildRuleParams paramsForResource =
          params.copyWithBuildTarget(
              BuildTarget.builder(originalBuildTarget)
                  .addFlavors(REACT_NATIVE_ANDROID_RES_FLAVOR)
                  .build())
              .copyWithExtraDeps(Suppliers.ofInstance(
                      ImmutableSortedSet.<BuildRule>of(bundle, reactNativeDeps)));

      BuildRule resource = new AndroidResource(
              paramsForResource,
              sourcePathResolver,
 ImmutableSortedSet.<BuildRule>of(),
              new PathSourcePath(params.getProjectFilesystem(), bundle.getResources()),
 ImmutableSortedSet.<Path>of(),
              args.rDotJavaPackage.get(),
 null,
 ImmutableSortedSet.<Path>of(),
 null,
 false,
              Optional.of(
                  Suppliers.memoize(
                      new Supplier<Sha1HashCode>() {
                        @Override
                        public Sha1HashCode get() {
                          return reactNativeDeps.getInputsHash();
                        }
                      })));
      resolver.addToIndex(resource);
      extraDeps.add(resource);
    }

    return new AndroidReactNativeLibrary(
        params.appendExtraDeps(extraDeps.build()),
        sourcePathResolver,
        bundle);
  }

  public ReactNativeBundle enhanceForIos(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      ReactNativeLibraryArgs args) {
    ReactNativeDeps reactNativeDeps =
        createReactNativeDeps(params, resolver, args, ReactNativePlatform.IOS);

    return new ReactNativeBundle(
        params.appendExtraDeps(ImmutableList.of((BuildRule) reactNativeDeps)),
        new SourcePathResolver(resolver),
        args.entryPath,
        ReactNativeFlavors.isDevMode(params.getBuildTarget()),
        args.bundleName,
        getPackager(),
        ReactNativePlatform.IOS,
        reactNativeDeps);
  }

  private SourcePath getPackager() {
    Optional<SourcePath> packager = buckConfig.getPackager();
    if (!packager.isPresent()) {
      throw new HumanReadableException("In order to use a 'react_native_library' rule, please " +
          "specify 'packager' in .buckconfig under the 'react-native' section.");
    }
    return packager.get();
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.Step;
import com.google.common.collect.ImmutableList;

import java.nio.file.Path;

import javax.annotation.Nullable;

public class AndroidReactNativeLibrary extends AbstractBuildRule implements AndroidPackageable {

  private final ReactNativeBundle bundle;

  protected AndroidReactNativeLibrary(
      BuildRuleParams buildRuleParams,
      SourcePathResolver resolver,
      ReactNativeBundle bundle) {
    super(buildRuleParams, resolver);
    this.bundle = bundle;
  }

  @Override
  public Iterable<AndroidPackageable> getRequiredPackageables() {
    return AndroidPackageableCollector.getPackageableRules(getDeps());
  }

  @Override
  public void addToCollector(AndroidPackageableCollector collector) {
    collector.addAssetsDirectory(
        getBuildTarget(),
        new PathSourcePath(getProjectFilesystem(), bundle.getJSBundleDir()));
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    return ImmutableList.of();
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return bundle.getPathToOutput();
  }
}

<code block>


package com.facebook.buck.js;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbiRule;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.Sha1HashCode;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.shell.ShellStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.google.common.collect.ImmutableList;

import java.nio.file.Path;

import javax.annotation.Nullable;


public class ReactNativeBundle extends AbstractBuildRule implements AbiRule {

  @AddToRuleKey
  private final SourcePath entryPath;

  @AddToRuleKey
  private final boolean isDevMode;

  @AddToRuleKey
  private final SourcePath jsPackager;

  @AddToRuleKey
  private final ReactNativePlatform platform;

  @AddToRuleKey
  private final String bundleName;

  private final ReactNativeDeps depsFinder;
  private final Path jsOutputDir;
  private final Path resource;

  protected ReactNativeBundle(
      BuildRuleParams ruleParams,
      SourcePathResolver resolver,
      SourcePath entryPath,
      boolean isDevMode,
      String bundleName,
      SourcePath jsPackager,
      ReactNativePlatform platform,
      ReactNativeDeps depsFinder) {
    super(ruleParams, resolver);
    this.entryPath = entryPath;
    this.isDevMode = isDevMode;
    this.bundleName = bundleName;
    this.jsPackager = jsPackager;
    this.platform = platform;
    this.depsFinder = depsFinder;
    BuildTarget buildTarget = ruleParams.getBuildTarget();
    this.jsOutputDir = getPathToJSBundleDir(buildTarget);
    this.resource = getPathToResources(buildTarget);
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();
    final Path jsOutput = jsOutputDir.resolve(bundleName);
    steps.add(new MakeCleanDirectoryStep(jsOutput.getParent()));
    steps.add(new MakeCleanDirectoryStep(resource));

    steps.add(
        new ShellStep() {
          @Override
          public String getShortName() {
            return "bundle_react_native";
          }

          @Override
          protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {
            ProjectFilesystem filesystem = context.getProjectFilesystem();
            return ImmutableList.of(
                getResolver().getPath(jsPackager).toString(),
                "bundle",
                "--entry-file", filesystem.resolve(getResolver().getPath(entryPath)).toString(),
                "--platform", platform.toString(),
                "--dev", isDevMode ? "true" : "false",
                "--bundle-output", filesystem.resolve(jsOutput).toString(),
                "--assets-dest", filesystem.resolve(resource).toString());
          }
        });
    buildableContext.recordArtifact(jsOutputDir);
    buildableContext.recordArtifact(resource);
    return steps.build();
  }

  public Path getJSBundleDir() {
    return jsOutputDir;
  }

  public Path getResources() {
    return resource;
  }

  public static Path getPathToJSBundleDir(BuildTarget target) {
    return BuildTargets.getGenPath(target, "__%s_js__/");
  }

  public static Path getPathToResources(BuildTarget target) {
    return BuildTargets.getGenPath(target, "__%s_res__/");
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return null;
  }

  @Override
  public Sha1HashCode getAbiKeyForDeps() {
    return depsFinder.getInputsHash();
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.cxx.NativeTestable;
import com.facebook.buck.cxx.Tool;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.CopyStep;
import com.facebook.buck.step.fs.FindAndReplaceStep;
import com.facebook.buck.step.fs.MakeCleanDirectoryStep;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.step.fs.WriteFileStep;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import com.dd.plist.NSObject;
import com.dd.plist.NSNumber;
import com.dd.plist.NSString;

import java.nio.file.Path;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;


public class AppleBundle extends AbstractBuildRule implements NativeTestable {
  private static final Logger LOG = Logger.get(AppleBundle.class);

  @AddToRuleKey
  private final String extension;

  @AddToRuleKey
  private final Optional<SourcePath> infoPlist;

  @AddToRuleKey
  private final ImmutableMap<String, String> infoPlistSubstitutions;

  @AddToRuleKey
  private final Optional<BuildRule> binary;

  @AddToRuleKey
  private final AppleBundleDestinations destinations;

  @AddToRuleKey
  private final Set<SourcePath> resourceDirs;

  @AddToRuleKey
  private final Set<SourcePath> resourceFiles;

  @AddToRuleKey
  private final Set<SourcePath> dirsContainingResourceDirs;

  @AddToRuleKey
  private final Tool ibtool;

  @AddToRuleKey
  private final Tool dsymutil;

  @AddToRuleKey
  private final ImmutableSortedSet<BuildTarget> tests;

  @AddToRuleKey
  private final String platformName;

  @AddToRuleKey
  private final String sdkName;

  private final ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs;

  private final Optional<AppleAssetCatalog> mergedAssetCatalog;

  private final String binaryName;
  private final Path bundleRoot;
  private final Path binaryPath;

  AppleBundle(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Either<AppleBundleExtension, String> extension,
      Optional<SourcePath> infoPlist,
      Map<String, String> infoPlistSubstitutions,
      Optional<BuildRule> binary,
      AppleBundleDestinations destinations,
      Set<SourcePath> resourceDirs,
      Set<SourcePath> resourceFiles,
      Set<SourcePath> dirsContainingResourceDirs,
      Tool ibtool,
      Tool dsymutil,
      Set<AppleAssetCatalog> bundledAssetCatalogs,
      Optional<AppleAssetCatalog> mergedAssetCatalog,
      Set<BuildTarget> tests,
      String platformName,
      String sdkName) {
    super(params, resolver);
    this.extension = extension.isLeft() ?
        extension.getLeft().toFileExtension() :
        extension.getRight();
    this.infoPlist = infoPlist;
    this.infoPlistSubstitutions = ImmutableMap.copyOf(infoPlistSubstitutions);
    this.binary = binary;
    this.destinations = destinations;
    this.resourceDirs = resourceDirs;
    this.resourceFiles = resourceFiles;
    this.dirsContainingResourceDirs = dirsContainingResourceDirs;
    this.ibtool = ibtool;
    this.dsymutil = dsymutil;
    this.bundledAssetCatalogs = ImmutableSet.copyOf(bundledAssetCatalogs);
    this.mergedAssetCatalog = mergedAssetCatalog;
    this.binaryName = getBinaryName(getBuildTarget());
    this.bundleRoot = getBundleRoot(getBuildTarget(), this.extension);
    this.binaryPath = this.destinations.getExecutablesPath()
        .resolve(this.binaryName);
    this.tests = ImmutableSortedSet.copyOf(tests);
    this.platformName = platformName;
    this.sdkName = sdkName;
  }

  private static String getBinaryName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  public static Path getBundleRoot(BuildTarget buildTarget, String extension) {
    return BuildTargets
        .getGenPath(buildTarget, "%s")
        .resolve(getBinaryName(buildTarget) + "." + extension);
  }

  @Override
  @Nullable
  public Path getPathToOutput() {
    return bundleRoot;
  }

  public Path getInfoPlistPath() {
    return getMetadataPath().resolve("Info.plist");
  }

  public Path getUnzippedOutputFilePathToBinary() {
    return this.binaryPath;
  }

  private Path getMetadataPath() {
    return bundleRoot.resolve(destinations.getMetadataPath());
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    ImmutableList.Builder<Step> stepsBuilder = ImmutableList.builder();

    Path metadataPath = getMetadataPath();

    Path infoPlistInputPath = getResolver().getPath(infoPlist.get());
    Path infoPlistSubstitutionTempPath =
        BuildTargets.getScratchPath(getBuildTarget(), "%s.plist");
    Path infoPlistOutputPath = metadataPath.resolve("Info.plist");

    stepsBuilder.add(
        new MakeCleanDirectoryStep(bundleRoot),
        new MkdirStep(metadataPath),

        new WriteFileStep("APPLWRUN", metadataPath.resolve("PkgInfo")),
        new FindAndReplaceStep(
            infoPlistInputPath,
            infoPlistSubstitutionTempPath,
            InfoPlistSubstitution.createVariableExpansionFunction(
                withDefaults(
                    infoPlistSubstitutions,
                    ImmutableMap.of(
                        "EXECUTABLE_NAME", binaryName,
                        "PRODUCT_NAME", binaryName
                    ))
            )),
        new PlistProcessStep(
            infoPlistSubstitutionTempPath,
            infoPlistOutputPath,
            getInfoPlistAdditionalKeys(platformName, sdkName),
            getInfoPlistOverrideKeys(platformName)));

    if (binary.isPresent()) {
      stepsBuilder.add(
          new MkdirStep(bundleRoot.resolve(this.destinations.getExecutablesPath())));
      Path bundleBinaryPath = bundleRoot.resolve(binaryPath);
      stepsBuilder.add(
          CopyStep.forFile(
              binary.get().getPathToOutput(),
              bundleBinaryPath));
      stepsBuilder.add(
          new DsymStep(
              dsymutil.getCommandPrefix(getResolver()),
              bundleBinaryPath,
              bundleBinaryPath.resolveSibling(
                  bundleBinaryPath.getFileName().toString() + ".dSYM")));
    }

    Path bundleDestinationPath = bundleRoot.resolve(this.destinations.getResourcesPath());
    for (SourcePath dir : resourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }
    for (SourcePath dir : dirsContainingResourceDirs) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      stepsBuilder.add(
          CopyStep.forDirectory(
              getResolver().getPath(dir),
              bundleDestinationPath,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }
    for (SourcePath file : resourceFiles) {
      stepsBuilder.add(new MkdirStep(bundleDestinationPath));
      Path resolvedFilePath = getResolver().getPath(file);
      Path destinationPath = bundleDestinationPath.resolve(resolvedFilePath.getFileName());
      addResourceProcessingSteps(resolvedFilePath, destinationPath, stepsBuilder);
    }

    for (AppleAssetCatalog bundledAssetCatalog : bundledAssetCatalogs) {
      Path bundleDir = bundledAssetCatalog.getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
    }

    if (mergedAssetCatalog.isPresent()) {
      Path bundleDir = mergedAssetCatalog.get().getOutputDir();
      stepsBuilder.add(
          CopyStep.forDirectory(
              bundleDir,
              bundleRoot,
              CopyStep.DirectoryMode.CONTENTS_ONLY));
    }


    buildableContext.recordArtifact(bundleRoot);

    return stepsBuilder.build();
  }

  static ImmutableMap<String, String> withDefaults(
      ImmutableMap<String, String> map,
      ImmutableMap<String, String> defaults) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.<String, String>builder()
        .putAll(map);
    for (ImmutableMap.Entry<String, String> entry : defaults.entrySet()) {
      if (!map.containsKey(entry.getKey())) {
        builder = builder.put(entry.getKey(), entry.getValue());
      }
    }
    return builder.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistOverrideKeys(
      String platformName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("LSRequiresIPhoneOS", new NSNumber(false));
    } else {
      keys.put("LSRequiresIPhoneOS", new NSNumber(true));
    }

    return keys.build();
  }

  static ImmutableMap<String, NSObject> getInfoPlistAdditionalKeys(
      String platformName,
      String sdkName) {
    ImmutableMap.Builder<String, NSObject> keys = ImmutableMap.builder();

    if (platformName.contains("osx")) {
      keys.put("NSHighResolutionCapable", new NSNumber(true));
      keys.put("NSSupportsAutomaticGraphicsSwitching", new NSNumber(true));
    }

    keys.put("DTPlatformName", new NSString(platformName));
    keys.put("DTSDKName", new NSString(sdkName));

    return keys.build();
  }

  private void addResourceProcessingSteps(
      Path sourcePath,
      Path destinationPath,
      ImmutableList.Builder<Step> stepsBuilder) {
    String sourcePathExtension = Files.getFileExtension(sourcePath.toString())
        .toLowerCase(Locale.US);
    switch (sourcePathExtension) {
      case "xib":
        String compiledNibFilename = Files.getNameWithoutExtension(destinationPath.toString()) +
            ".nib";
        Path compiledNibPath = destinationPath.getParent().resolve(compiledNibFilename);
        LOG.debug("Compiling XIB %s to NIB %s", sourcePath, destinationPath);
        stepsBuilder.add(
            new IbtoolStep(
                ibtool.getCommandPrefix(getResolver()),
                sourcePath,
                compiledNibPath));
        break;
      default:
        stepsBuilder.add(CopyStep.forFile(sourcePath, destinationPath));
        break;
    }
  }

  @Override
  public boolean isTestedBy(BuildTarget testRule) {
    if (tests.contains(testRule)) {
      return true;
    }

    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).isTestedBy(testRule);
      }
    }

    return false;
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    if (binary.isPresent()) {
      BuildRule binaryRule = binary.get();
      if (binaryRule instanceof NativeTestable) {
        return ((NativeTestable) binaryRule).getCxxPreprocessorInput(cxxPlatform, headerVisibility);
      }
    }
    return CxxPreprocessorInput.EMPTY;
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.IosReactNativeLibraryDescription;
import com.facebook.buck.js.ReactNativeBundle;
import com.facebook.buck.js.ReactNativeLibraryArgs;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableSet;

public class AppleResources {

  private AppleResources() { }


  public static <T> ImmutableSet<AppleResourceDescription.Arg> collectRecursiveResources(
      final TargetGraph targetGraph,
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.COPYING,
                ImmutableSet.of(AppleResourceDescription.TYPE)))
        .transform(
            new Function<TargetNode<?>, AppleResourceDescription.Arg>() {
              @Override
              public AppleResourceDescription.Arg apply(TargetNode<?> input) {
                return (AppleResourceDescription.Arg) input.getConstructorArg();
              }
            })
        .toSet();
  }

  public static <T> void collectResourceDirsAndFiles(
      TargetGraph targetGraph,
      TargetNode<T> targetNode,
      ProjectFilesystem filesystem,
      ImmutableSet.Builder<SourcePath> resourceDirs,
      ImmutableSet.Builder<SourcePath> dirsContainingResourceDirs,
      ImmutableSet.Builder<SourcePath> resourceFiles) {
    Iterable<TargetNode<?>> resourceNodes =
        AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
            targetGraph,
            AppleBuildRules.RecursiveDependenciesMode.COPYING,
            targetNode,
            Optional.of(ImmutableSet.of(
                    AppleResourceDescription.TYPE,
                    IosReactNativeLibraryDescription.TYPE)));

    for (TargetNode<?> resourceNode : resourceNodes) {
      Object constructorArg = resourceNode.getConstructorArg();
      if (constructorArg instanceof AppleResourceDescription.Arg) {
        AppleResourceDescription.Arg appleResource = (AppleResourceDescription.Arg) constructorArg;
        resourceDirs.addAll(appleResource.dirs);
        resourceFiles.addAll(appleResource.files);
      } else {
        Preconditions.checkState(constructorArg instanceof ReactNativeLibraryArgs);
        BuildTarget buildTarget = resourceNode.getBuildTarget();

        dirsContainingResourceDirs.add(
            new BuildTargetSourcePath(
                filesystem,
                buildTarget,
                ReactNativeBundle.getPathToJSBundleDir(buildTarget)),
            new BuildTargetSourcePath(
                filesystem,
                buildTarget,
                ReactNativeBundle.getPathToResources(buildTarget)));
      }
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxCompilationDatabase;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.Label;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

import java.util.Map;
import java.util.Set;

public class AppleTestDescription implements
    Description<AppleTestDescription.Arg>,
    Flavored,
    ImplicitDepsInferringDescription<AppleTestDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("apple_test");


  private static final Flavor LIBRARY_FLAVOR = ImmutableFlavor.of("apple-test-library");
  private static final Flavor BUNDLE_FLAVOR = ImmutableFlavor.of("apple-test-bundle");

  private static final Set<Flavor> SUPPORTED_FLAVORS = ImmutableSet.of(
      LIBRARY_FLAVOR, BUNDLE_FLAVOR);

  private static final Predicate<Flavor> IS_SUPPORTED_FLAVOR = Predicates.in(SUPPORTED_FLAVORS);

  private static final Set<Flavor> NON_LIBRARY_FLAVORS = ImmutableSet.of(
      CxxCompilationDatabase.COMPILATION_DATABASE,
      CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR,
      CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR);

  private final AppleConfig appleConfig;
  private final AppleBundleDescription appleBundleDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleTestDescription(
      AppleConfig appleConfig,
      AppleBundleDescription appleBundleDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleConfig = appleConfig;
    this.appleBundleDescription = appleBundleDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return FluentIterable.from(flavors).allMatch(IS_SUPPORTED_FLAVOR) ||
        appleLibraryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    String extension = args.extension.isLeft() ?
        args.extension.getLeft().toFileExtension() :
        args.extension.getRight();
    if (!AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS.contains(extension)) {
      throw new HumanReadableException(
          "Invalid bundle extension for apple_test rule: %s (must be one of %s)",
          extension,
          AppleBundleExtensions.VALID_XCTOOL_BUNDLE_EXTENSIONS);
    }
    boolean createBundle = Sets.intersection(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS).isEmpty();
    Sets.SetView<Flavor> nonLibraryFlavors = Sets.difference(
        params.getBuildTarget().getFlavors(),
        NON_LIBRARY_FLAVORS);
    boolean addDefaultPlatform = nonLibraryFlavors.isEmpty();
    ImmutableSet.Builder<Flavor> extraFlavorsBuilder = ImmutableSet.builder();
    if (createBundle) {
      extraFlavorsBuilder.add(
          LIBRARY_FLAVOR,
          CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR);
    }
    if (addDefaultPlatform) {
      extraFlavorsBuilder.add(defaultCxxPlatform.getFlavor());
    }

    Optional<AppleBundle> testHostApp;
    Optional<SourcePath> testHostAppBinarySourcePath;
    if (args.testHostApp.isPresent()) {
      TargetNode<?> testHostAppNode = params.getTargetGraph().get(args.testHostApp.get());
      Preconditions.checkNotNull(testHostAppNode);

      if (testHostAppNode.getType() != AppleBundleDescription.TYPE) {
        throw new HumanReadableException(
            "Apple test rule %s has unrecognized test_host_app %s type %s (should be %s)",
            params.getBuildTarget(),
            args.testHostApp.get(),
            testHostAppNode.getType(),
            AppleBundleDescription.TYPE);
      }

      AppleBundleDescription.Arg testHostAppDescription = (AppleBundleDescription.Arg)
          testHostAppNode.getConstructorArg();

      testHostApp = Optional.of(
          appleBundleDescription.createBuildRule(
              params.copyWithChanges(
                  BuildTarget.builder(args.testHostApp.get())
                      .addAllFlavors(nonLibraryFlavors)
                      .build(),
                  Suppliers.ofInstance(
                      BuildRules.toBuildRulesFor(
                          args.testHostApp.get(),
                          resolver,
                          testHostAppNode.getDeclaredDeps())),
                  Suppliers.ofInstance(
                      BuildRules.toBuildRulesFor(
                          args.testHostApp.get(),
                          resolver,
                          testHostAppNode.getExtraDeps()))),
              resolver,
              testHostAppDescription));
      testHostAppBinarySourcePath = Optional.<SourcePath>of(
          new BuildTargetSourcePath(
              params.getProjectFilesystem(),
              testHostAppDescription.binary));
    } else {
      testHostApp = Optional.absent();
      testHostAppBinarySourcePath = Optional.absent();
    }

    BuildRule library = appleLibraryDescription.createBuildRule(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget())
                .addAllFlavors(extraFlavorsBuilder.build())
                .build(),
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        resolver,
        args,


        Optional.of(Linker.LinkableDepType.STATIC),
        testHostAppBinarySourcePath);
    if (!createBundle) {
      return library;
    }

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple test requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);
    ImmutableSet.Builder<SourcePath> resourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> resourceFilesBuilder = ImmutableSet.builder();
    AppleResources.collectResourceDirsAndFiles(
        params.getTargetGraph(),
        Preconditions.checkNotNull(params.getTargetGraph().get(params.getBuildTarget())),
        params.getProjectFilesystem(),
        resourceDirsBuilder,
        dirsContainingResourceDirsBuilder,
        resourceFilesBuilder);

    ImmutableSet<SourcePath> resourceDirs = resourceDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> resourceFiles = resourceFilesBuilder.build();

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();

    String sdkName = appleCxxPlatform.getAppleSdk().getName();
    String platformName = appleCxxPlatform.getAppleSdk().getApplePlatform().getName();

    AppleBundle bundle = new AppleBundle(
        params.copyWithChanges(
            BuildTarget.builder(params.getBuildTarget()).addFlavors(BUNDLE_FLAVOR).build(),


            Suppliers.ofInstance(
                ImmutableSortedSet.<BuildRule>naturalOrder()
                    .add(library)
                    .addAll(mergedAssetCatalog.asSet())
                    .addAll(bundledAssetCatalogs)
                    .addAll(params.getDeclaredDeps())
                    .addAll(
                        BuildRules.toBuildRulesFor(
                            params.getBuildTarget(),
                            resolver,
                            SourcePaths.filterBuildTargetSourcePaths(
                                Iterables.concat(
                                    resourceFiles,
                                    resourceDirs,
                                    dirsContainingResourceDirs))))
                    .build()),
            Suppliers.ofInstance(params.getExtraDeps())),
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(library),
        destinations,
        resourceDirs,
        resourceFiles,
        dirsContainingResourceDirsBuilder.build(),
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        ImmutableSortedSet.<BuildTarget>of(),
        platformName,
        sdkName);


    Optional<BuildRule> xctoolZipBuildRule;
    if (appleConfig.getXctoolZipTarget().isPresent()) {
      xctoolZipBuildRule = Optional.of(
          resolver.getRule(appleConfig.getXctoolZipTarget().get()));
    } else {
      xctoolZipBuildRule = Optional.absent();
    }

    return new AppleTest(
        appleConfig.getXctoolPath(),
        xctoolZipBuildRule,
        appleCxxPlatform.getXctest(),
        appleCxxPlatform.getOtest(),
        appleConfig.getXctestPlatformNames().contains(platformName),
        platformName,
        Optional.<String>absent(),
        params.copyWithDeps(
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of(bundle)),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        sourcePathResolver,
        bundle,
        testHostApp,
        extension,
        args.contacts.get(),
        args.labels.get());
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      AppleTestDescription.Arg constructorArg) {



    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();
    Optional<BuildTarget> xctoolZipTarget = appleConfig.getXctoolZipTarget();
    if (xctoolZipTarget.isPresent()) {
      deps.add(xctoolZipTarget.get());
    }
    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends AppleNativeTargetDescriptionArg implements HasAppleBundleFields {
    public Optional<ImmutableSortedSet<String>> contacts;
    public Optional<ImmutableSortedSet<Label>> labels;
    public Optional<Boolean> canGroup;
    public Optional<BuildTarget> testHostApp;


    public Either<AppleBundleExtension, String> extension;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<String> xcodeProductType;
    public Optional<String> resourcePrefixDir;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }

    public boolean canGroup() {
      return canGroup.or(false);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.Hint;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

import java.util.Map;
import java.util.Set;

public class AppleBundleDescription implements Description<AppleBundleDescription.Arg>, Flavored {
  public static final BuildRuleType TYPE = BuildRuleType.of("apple_bundle");

  private final AppleBinaryDescription appleBinaryDescription;
  private final AppleLibraryDescription appleLibraryDescription;
  private final FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain;
  private final ImmutableMap<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms;
  private final CxxPlatform defaultCxxPlatform;

  public AppleBundleDescription(
      AppleBinaryDescription appleBinaryDescription,
      AppleLibraryDescription appleLibraryDescription,
      FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,
      Map<Flavor, AppleCxxPlatform> platformFlavorsToAppleCxxPlatforms,
      CxxPlatform defaultCxxPlatform) {
    this.appleBinaryDescription = appleBinaryDescription;
    this.appleLibraryDescription = appleLibraryDescription;
    this.cxxPlatformFlavorDomain = cxxPlatformFlavorDomain;
    this.platformFlavorsToAppleCxxPlatforms =
        ImmutableMap.copyOf(platformFlavorsToAppleCxxPlatforms);
    this.defaultCxxPlatform = defaultCxxPlatform;
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return appleLibraryDescription.hasFlavors(flavors) ||
        appleBinaryDescription.hasFlavors(flavors);
  }

  @Override
  public <A extends Arg> AppleBundle createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    CxxPlatform cxxPlatform;
    try {
      cxxPlatform = cxxPlatformFlavorDomain
          .getValue(params.getBuildTarget().getFlavors())
          .or(defaultCxxPlatform);
    } catch (FlavorDomainException e) {
      throw new HumanReadableException(e, "%s: %s", params.getBuildTarget(), e.getMessage());
    }
    AppleCxxPlatform appleCxxPlatform =
        platformFlavorsToAppleCxxPlatforms.get(cxxPlatform.getFlavor());
    if (appleCxxPlatform == null) {
      throw new HumanReadableException(
          "%s: Apple bundle requires an Apple platform, found '%s'",
          params.getBuildTarget(),
          cxxPlatform.getFlavor().getName());
    }

    AppleBundleDestinations destinations =
        AppleBundleDestinations.platformDestinations(
            appleCxxPlatform.getAppleSdk().getApplePlatform());

    ImmutableSet.Builder<SourcePath> bundleDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> dirsContainingResourceDirsBuilder = ImmutableSet.builder();
    ImmutableSet.Builder<SourcePath> bundleFilesBuilder = ImmutableSet.builder();
    AppleResources.collectResourceDirsAndFiles(
        params.getTargetGraph(),
        Preconditions.checkNotNull(params.getTargetGraph().get(params.getBuildTarget())),
        params.getProjectFilesystem(),
        bundleDirsBuilder,
        dirsContainingResourceDirsBuilder,
        bundleFilesBuilder);
    ImmutableSet<SourcePath> bundleDirs = bundleDirsBuilder.build();
    ImmutableSet<SourcePath> dirsContainingResourceDirs = dirsContainingResourceDirsBuilder.build();
    ImmutableSet<SourcePath> bundleFiles = bundleFilesBuilder.build();

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);

    CollectedAssetCatalogs collectedAssetCatalogs =
        AppleDescriptions.createBuildRulesForTransitiveAssetCatalogDependencies(
            params,
            sourcePathResolver,
            appleCxxPlatform.getAppleSdk().getApplePlatform(),
            appleCxxPlatform.getActool());

    Optional<AppleAssetCatalog> mergedAssetCatalog = collectedAssetCatalogs.getMergedAssetCatalog();
    ImmutableSet<AppleAssetCatalog> bundledAssetCatalogs =
        collectedAssetCatalogs.getBundledAssetCatalogs();



    BuildRule flavoredBinaryRule = getFlavoredBinaryRule(params, resolver, args);
    BuildRuleParams bundleParamsWithFlavoredBinaryDep = getBundleParamsWithUpdatedDeps(
        params,
        args.binary,
        ImmutableSet.<BuildRule>builder()
            .add(flavoredBinaryRule)
            .addAll(mergedAssetCatalog.asSet())
            .addAll(bundledAssetCatalogs)
            .addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    SourcePaths.filterBuildTargetSourcePaths(
                        Iterables.concat(
                            bundleFiles,
                            bundleDirs,
                            dirsContainingResourceDirs))))
            .build());

    return new AppleBundle(
        bundleParamsWithFlavoredBinaryDep,
        sourcePathResolver,
        args.extension,
        args.infoPlist,
        args.infoPlistSubstitutions.get(),
        Optional.of(flavoredBinaryRule),
        destinations,
        bundleDirs,
        bundleFiles,
        dirsContainingResourceDirs,
        appleCxxPlatform.getIbtool(),
        appleCxxPlatform.getDsymutil(),
        bundledAssetCatalogs,
        mergedAssetCatalog,
        args.getTests(),
        appleCxxPlatform.getAppleSdk().getApplePlatform().getName(),
        appleCxxPlatform.getAppleSdk().getName());
  }

  private static <A extends Arg> BuildRule getFlavoredBinaryRule(
      final BuildRuleParams params,
      final BuildRuleResolver resolver,
      final A args) {
    final TargetNode<?> binaryTargetNode = params.getTargetGraph().get(args.binary);
    BuildRuleParams binaryRuleParams = new BuildRuleParams(
        args.binary,
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getDeclaredDeps())),
        Suppliers.ofInstance(
            BuildRules.toBuildRulesFor(
                params.getBuildTarget(),
                resolver,
                binaryTargetNode.getExtraDeps())),
        params.getProjectFilesystem(),
        params.getRuleKeyBuilderFactory(),
        params.getTargetGraph());
    return CxxDescriptionEnhancer.requireBuildRule(
        binaryRuleParams,
        resolver,
        params.getBuildTarget().getFlavors().toArray(new Flavor[0]));
  }

  private static BuildRuleParams getBundleParamsWithUpdatedDeps(
      final BuildRuleParams params,
      final BuildTarget originalBinaryTarget,
      final Set<BuildRule> newDeps) {

    final Predicate<BuildRule> notOriginalBinaryRule = Predicates.not(
        BuildRules.isBuildRuleWithTarget(originalBinaryTarget));
    return params.copyWithDeps(
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getDeclaredDeps())
                .filter(notOriginalBinaryRule)
                .append(newDeps)
                .toSortedSet(Ordering.natural())),
        Suppliers.ofInstance(
            FluentIterable
                .from(params.getExtraDeps())
                .filter(notOriginalBinaryRule)
                .toSortedSet(Ordering.natural())));
  }

  @SuppressFieldNotInitialized
  public static class Arg implements HasAppleBundleFields, HasTests {
    public Either<AppleBundleExtension, String> extension;
    public BuildTarget binary;
    public Optional<SourcePath> infoPlist;
    public Optional<ImmutableMap<String, String>> infoPlistSubstitutions;
    public Optional<ImmutableMap<String, SourcePath>> headers;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
    @Hint(isDep = false) public Optional<ImmutableSortedSet<BuildTarget>> tests;
    public Optional<String> xcodeProductType;

    @Override
    public Either<AppleBundleExtension, String> getExtension() {
      return extension;
    }

    @Override
    public Optional<SourcePath> getInfoPlist() {
      return infoPlist;
    }

    @Override
    public ImmutableSortedSet<BuildTarget> getTests() {
      return tests.get();
    }

    @Override
    public Optional<String> getXcodeProductType() {
      return xcodeProductType;
    }
  }
}

<code block>


package com.facebook.buck.js;

import static org.junit.Assume.assumeTrue;

import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.util.environment.Platform;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;

public class IosReactNativeLibraryIntegrationTest {

  @Rule
  public DebuggableTemporaryFolder tmpFolder = new DebuggableTemporaryFolder();

  private ProjectWorkspace workspace;

  @BeforeClass
  public static void setupOnce() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
  }

  @Before
  public void setUp() throws IOException {
    workspace = TestDataHelper.createProjectWorkspaceForScenario(this, "ios_rn", tmpFolder);
    workspace.setUp();
  }
  @Test
  public void testBundleOutputContainsJSAndResources() throws IOException {
    workspace.runBuckBuild("//:DemoApp#iphonesimulator-x86_64").assertSuccess();

    workspace.verify();
  }
}

<code block>


package com.facebook.buck.cxx;

import static com.facebook.buck.cxx.DebugSectionProperty.COMPRESSED;
import static com.facebook.buck.cxx.DebugSectionProperty.STRINGS;
import static java.nio.channels.FileChannel.MapMode.READ_WRITE;
import static java.nio.file.StandardOpenOption.READ;
import static java.nio.file.StandardOpenOption.WRITE;

import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.util.Map;


public class DebugPathSanitizer {

  private static final DebugSectionFinder DEBUG_SECTION_FINDER = new DebugSectionFinder();

  private final int pathSize;
  private final char separator;
  private final Path compilationDirectory;
  private final ImmutableBiMap<Path, Path> other;


  public DebugPathSanitizer(
      int pathSize,
      char separator,
      Path compilationDirectory,
      ImmutableBiMap<Path, Path> other) {
    this.pathSize = pathSize;
    this.separator = separator;
    this.compilationDirectory = compilationDirectory;
    this.other = other;
  }


  public String getExpandedPath(Path path) {
    Preconditions.checkArgument(path.toString().length() <= pathSize);
    return Strings.padEnd(path.toString(), pathSize, separator);
  }

  private ImmutableBiMap<Path, Path> getAllPaths(Optional<Path> workingDir) {
    ImmutableBiMap.Builder<Path, Path> builder = ImmutableBiMap.builder();
    if (workingDir.isPresent()) {
      builder.put(workingDir.get(), compilationDirectory);
    }
    builder.putAll(other);
    return builder.build();
  }

  public String getCompilationDirectory() {
    return getExpandedPath(compilationDirectory);
  }

  public Function<String, String> sanitize(
      final Optional<Path> workingDir,
      final boolean expandPaths) {
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return DebugPathSanitizer.this.sanitize(workingDir, input, expandPaths);
      }
    };
  }


  public String sanitize(Optional<Path> workingDir, String contents, boolean expandPaths) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      String replacement;
      if (expandPaths) {
        replacement = getExpandedPath(entry.getValue());
      } else {
        replacement = entry.getValue().toString();
      }
      contents = contents.replace(entry.getKey().toString(), replacement);
    }
    return contents;
  }

  public String sanitize(Optional<Path> workingDir, String contents) {
    return sanitize(workingDir, contents,  true);
  }

  public String restore(Optional<Path> workingDir, String contents) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      contents = contents.replace(getExpandedPath(entry.getValue()), entry.getKey().toString());
    }
    return contents;
  }


  private void restore(ByteBuffer buffer, ByteBufferReplacer replacer) {


    Optional<ImmutableMap<String, DebugSection>> results = DEBUG_SECTION_FINDER.find(buffer);



    if (results.isPresent()) {
      for (DebugSection section : results.get().values()) {

        Preconditions.checkState(!section.properties.contains(COMPRESSED));
        if (section.properties.contains(STRINGS)) {
          replacer.replace(section.body);
        }
      }
    } else {
      replacer.replace(buffer);
    }
  }

  private void restore(Path path, ByteBufferReplacer replacer) throws IOException {
    try (FileChannel channel = FileChannel.open(path, READ, WRITE)) {
      MappedByteBuffer buffer = channel.map(READ_WRITE, 0, channel.size());
      restore(buffer, replacer);
    }
  }


  private ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir) {
    return new ByteBufferReplacer(
        ImmutableMap.of(
            getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),
            getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
  }



  public void restoreCompilationDirectory(Path path, Path workingDir) throws IOException {
    restore(path, getCompilationDirectoryReplacer(workingDir));
  }

}

<code block>


package com.facebook.buck.cxx;

import static com.facebook.buck.cxx.DebugSectionProperty.COMPRESSED;
import static com.facebook.buck.cxx.DebugSectionProperty.STRINGS;
import static java.nio.channels.FileChannel.MapMode.READ_WRITE;
import static java.nio.file.StandardOpenOption.READ;
import static java.nio.file.StandardOpenOption.WRITE;

import com.facebook.buck.log.Logger;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.ExecutionException;


public class DebugPathSanitizer {

  private static final DebugSectionFinder DEBUG_SECTION_FINDER = new DebugSectionFinder();

  private final int pathSize;
  private final char separator;
  private final Path compilationDirectory;
  private final ImmutableBiMap<Path, Path> other;

  private final LoadingCache<Path, ImmutableBiMap<Path, Path>> pathCache =
      CacheBuilder
          .newBuilder()
          .softValues()
          .build(new CacheLoader<Path, ImmutableBiMap<Path, Path>>() {
            @Override
            public ImmutableBiMap<Path, Path> load(Path key) {
              return getAllPathsWork(key);
            }
          });


  public DebugPathSanitizer(
      int pathSize,
      char separator,
      Path compilationDirectory,
      ImmutableBiMap<Path, Path> other) {
    this.pathSize = pathSize;
    this.separator = separator;
    this.compilationDirectory = compilationDirectory;
    this.other = other;
  }


  public String getExpandedPath(Path path) {
    Preconditions.checkArgument(path.toString().length() <= pathSize);
    return Strings.padEnd(path.toString(), pathSize, separator);
  }

  private ImmutableBiMap<Path, Path> getAllPaths(Optional<Path> workingDir) {
    if (!workingDir.isPresent()) {
      return other;
    }

    try {
      return pathCache.get(workingDir.get());
    } catch (ExecutionException e) {
      Logger.get(DebugPathSanitizer.class).error(
          "Problem loading paths into cache",
          e);
      return getAllPathsWork(workingDir.get());
    }
  }

  private ImmutableBiMap<Path, Path> getAllPathsWork(Path workingDir) {
    ImmutableBiMap.Builder<Path, Path> builder = ImmutableBiMap.builder();
    builder.put(workingDir, compilationDirectory);
    builder.putAll(other);
    return builder.build();
  }

  public String getCompilationDirectory() {
    return getExpandedPath(compilationDirectory);
  }

  public Function<String, String> sanitize(
      final Optional<Path> workingDir,
      final boolean expandPaths) {
    return new Function<String, String>() {
      @Override
      public String apply(String input) {
        return DebugPathSanitizer.this.sanitize(workingDir, input, expandPaths);
      }
    };
  }


  public String sanitize(Optional<Path> workingDir, String contents, boolean expandPaths) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      String replacement;
      if (expandPaths) {
        replacement = getExpandedPath(entry.getValue());
      } else {
        replacement = entry.getValue().toString();
      }
      String pathToReplace = entry.getKey().toString();
      if (contents.contains(pathToReplace)) {



        contents = contents.replace(pathToReplace, replacement);
      }
    }
    return contents;
  }

  public String sanitize(Optional<Path> workingDir, String contents) {
    return sanitize(workingDir, contents,  true);
  }

  public String restore(Optional<Path> workingDir, String contents) {
    for (Map.Entry<Path, Path> entry : getAllPaths(workingDir).entrySet()) {
      contents = contents.replace(getExpandedPath(entry.getValue()), entry.getKey().toString());
    }
    return contents;
  }


  private void restore(ByteBuffer buffer, ByteBufferReplacer replacer) {


    Optional<ImmutableMap<String, DebugSection>> results = DEBUG_SECTION_FINDER.find(buffer);



    if (results.isPresent()) {
      for (DebugSection section : results.get().values()) {

        Preconditions.checkState(!section.properties.contains(COMPRESSED));
        if (section.properties.contains(STRINGS)) {
          replacer.replace(section.body);
        }
      }
    } else {
      replacer.replace(buffer);
    }
  }

  private void restore(Path path, ByteBufferReplacer replacer) throws IOException {
    try (FileChannel channel = FileChannel.open(path, READ, WRITE)) {
      MappedByteBuffer buffer = channel.map(READ_WRITE, 0, channel.size());
      restore(buffer, replacer);
    }
  }


  private ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir) {
    return new ByteBufferReplacer(
        ImmutableMap.of(
            getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),
            getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
  }



  public void restoreCompilationDirectory(Path path, Path workingDir) throws IOException {
    restore(path, getCompilationDirectoryReplacer(workingDir));
  }

}

<code block>


package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.shell.BashStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.DefaultFilteredDirectoryCopier;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.Filters.Density;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Verbosity;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class FilterResourcesStep implements Step {

  private static final Pattern DRAWABLE_PATH_PATTERN = Pattern.compile(
      ".*drawable.*/.*(png|jpg|jpeg|gif|webp)", Pattern.CASE_INSENSITIVE);

  private static final Pattern DRAWABLE_EXCLUDE_PATTERN = Pattern.compile(
      ".*-nodpi.*", Pattern.CASE_INSENSITIVE);

  private static final Logger LOG = Logger.get(FilterResourcesStep.class);

  @VisibleForTesting
  static final Pattern NON_ENGLISH_STRINGS_FILE_PATH = Pattern.compile(
      "(\\b|.*/)res/values-.+/strings.xml", Pattern.CASE_INSENSITIVE);

  @VisibleForTesting
  static final Pattern VALUES_DIR_PATTERN = Pattern.compile(
      "\\b|.*/res/values-([a-z]{2})(?:-r([A-Z]{2}))*/.*");

  private final ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
  private final boolean filterDrawables;
  private final boolean filterStrings;
  private final ImmutableSet<Path> whitelistedStringDirs;
  private final ImmutableSet<String> locales;
  private final FilteredDirectoryCopier filteredDirectoryCopier;
  @Nullable
  private final Set<Filters.Density> targetDensities;
  @Nullable
  private final DrawableFinder drawableFinder;
  @Nullable
  private final ImageScaler imageScaler;


  @VisibleForTesting
  FilterResourcesStep(
      ImmutableBiMap<Path, Path> inResDirToOutResDirMap,
      boolean filterDrawables,
      boolean filterStrings,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      FilteredDirectoryCopier filteredDirectoryCopier,
      @Nullable Set<Filters.Density> targetDensities,
      @Nullable DrawableFinder drawableFinder,
      @Nullable ImageScaler imageScaler) {

    Preconditions.checkArgument(filterDrawables || filterStrings || !locales.isEmpty());
    Preconditions.checkArgument(!filterDrawables ||
        (targetDensities != null && drawableFinder != null));
    this.inResDirToOutResDirMap = inResDirToOutResDirMap;
    this.filterDrawables = filterDrawables;
    this.filterStrings = filterStrings;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.filteredDirectoryCopier = filteredDirectoryCopier;
    this.targetDensities = targetDensities;
    this.drawableFinder = drawableFinder;
    this.imageScaler = imageScaler;
    LOG.info(
        "FilterResourcesStep: filterDrawables: %s; filterStrings: %s",
        filterDrawables,
        filterStrings);
  }

  @Override
  public int execute(ExecutionContext context) {
    try {
      return doExecute(context);
    } catch (Exception e) {
      context.logError(e, "There was an error filtering resources.");
      return 1;
    }
  }

  private int doExecute(ExecutionContext context) throws IOException, InterruptedException {
    List<Predicate<Path>> pathPredicates = Lists.newArrayList();

    boolean canDownscale = imageScaler != null && imageScaler.isAvailable(context);
    LOG.info(
        "FilterResourcesStep: canDownscale: %s. imageScalar non-null: %s.",
        canDownscale,
        imageScaler != null);

    if (filterDrawables) {
      Preconditions.checkNotNull(drawableFinder);
      Set<Path> drawables = drawableFinder.findDrawables(
          inResDirToOutResDirMap.keySet(),
          context.getProjectFilesystem());
      pathPredicates.add(
          Filters.createImageDensityFilter(
              drawables,
              Preconditions.checkNotNull(targetDensities),
              canDownscale));
    }

    if (!locales.isEmpty()) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path input) {
              Matcher matcher = VALUES_DIR_PATTERN.matcher(MorePaths.pathWithUnixSeparators(input));
              if (!matcher.matches() || isPathWhitelisted(input)) {
                return true;
              }
              String locale = matcher.group(1);
              if (matcher.group(2) != null) {
                locale += "_" + matcher.group(2);
              }
              return locales.contains(locale);
            }
          });
    }

    if (filterStrings) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path pathRelativeToProjectRoot) {
              if (!NON_ENGLISH_STRINGS_FILE_PATH.matcher(MorePaths.pathWithUnixSeparators(
                      pathRelativeToProjectRoot))
                  .matches()) {
                return true;
              }

              return isPathWhitelisted(pathRelativeToProjectRoot);
            }
          });
    }


    filteredDirectoryCopier.copyDirs(
        context.getProjectFilesystem(),
        inResDirToOutResDirMap,
        Predicates.and(pathPredicates));


    if (canDownscale && filterDrawables) {
      scaleUnmatchedDrawables(context);
    }

    return 0;
  }

  private boolean isPathWhitelisted(Path path) {
    for (Path whitelistedStringDir : whitelistedStringDirs) {
      if (path.startsWith(whitelistedStringDir)) {
        return true;
      }
    }

    return false;
  }

  @Override
  public String getShortName() {
    return "resource_filtering";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return "Filtering drawable and string resources.";
  }


  private void scaleUnmatchedDrawables(ExecutionContext context)
      throws IOException, InterruptedException {
    ProjectFilesystem filesystem = context.getProjectFilesystem();
    Filters.Density targetDensity = Filters.Density.ORDERING.max(targetDensities);


    Preconditions.checkNotNull(drawableFinder);
    Collection<Path> drawables = drawableFinder.findDrawables(
        inResDirToOutResDirMap.values(),
        context.getProjectFilesystem());
    for (Path drawable : drawables) {
      if (drawable.toString().endsWith(".9.png")) {

        continue;
      }

      Filters.Qualifiers qualifiers = new Filters.Qualifiers(drawable);
      Filters.Density density = qualifiers.density;


      Preconditions.checkNotNull(targetDensities);
      if (!targetDensities.contains(density)) {



        String fromDensity = (density == Density.NO_QUALIFIER ? "" : "-") + density.toString();
        Path destination = Paths.get(MorePaths.pathWithUnixSeparators(drawable).replaceFirst(
            "((?:^|/)drawable[^/]*)" + Pattern.quote(fromDensity) + "(-|$|/)",
            "$1-" + targetDensity + "$2"));

        double factor = targetDensity.value() / density.value();
        if (factor >= 1.0) {

          continue;
        }


        filesystem.createParentDirs(destination);
        Preconditions.checkNotNull(imageScaler);
        imageScaler.scale(factor, drawable, destination, context);


        filesystem.deleteFileAtPath(drawable);


        Path parent = drawable.getParent();
        if (filesystem.listFiles(parent).length == 0) {
          filesystem.deleteFileAtPath(parent);
        }

      }
    }
  }

  public interface DrawableFinder {
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException;
  }

  public static class DefaultDrawableFinder implements DrawableFinder {

    private static final DefaultDrawableFinder instance = new DefaultDrawableFinder();

    public static DefaultDrawableFinder getInstance() {
      return instance;
    }

    @Override
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException {
      final ImmutableSet.Builder<Path> drawableBuilder = ImmutableSet.builder();
      for (Path dir : dirs) {
        filesystem.walkRelativeFileTree(dir, new SimpleFileVisitor<Path>() {
              @Override
              public FileVisitResult visitFile(Path path, BasicFileAttributes attributes) {
                String unixPath = MorePaths.pathWithUnixSeparators(path);
                if (DRAWABLE_PATH_PATTERN.matcher(unixPath).matches() &&
                    !DRAWABLE_EXCLUDE_PATTERN.matcher(unixPath).matches()) {

                  drawableBuilder.add(path);
                }
                return FileVisitResult.CONTINUE;
              }
            });
      }
      return drawableBuilder.build();
    }
  }

  public interface ImageScaler {
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException;
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException;
  }


  public static class ImageMagickScaler implements ImageScaler {

    private static final ImageMagickScaler instance = new ImageMagickScaler();

    public static ImageMagickScaler getInstance() {
      return instance;
    }

    private ExecutionContext getContextWithSilentConsole(ExecutionContext context) {

      Console console = context.getConsole();
      return ExecutionContext.builder()
          .setExecutionContext(context)
          .setConsole(new Console(
              Verbosity.SILENT,
              console.getStdOut(),
              console.getStdErr(),
              console.getAnsi()
          ))
          .build();
    }

    @Override
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException {
      try (ExecutionContext silentContext = getContextWithSilentConsole(context)) {
        return 0 == new BashStep("which convert").execute(silentContext);
      }
    }

    @Override
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException {
      Step convertStep = new BashStep(
          "convert",
          "-adaptive-resize", (int) (factor * 100) + "%",
          Escaper.escapeAsBashString(source),
          Escaper.escapeAsBashString(destination));

      if (0 != convertStep.execute(context)) {
        throw new HumanReadableException("Cannot scale " + source + " to " + destination);
      }
    }
  }


  public static class ResourceFilter implements RuleKeyAppendable {

    static final ResourceFilter EMPTY_FILTER = new ResourceFilter(ImmutableList.<String>of());

    private final Set<String> filter;
    private final Set<Filters.Density> densities;
    private final boolean downscale;

    public ResourceFilter(List<String> resourceFilter) {
      this.filter = ImmutableSet.copyOf(resourceFilter);
      this.densities = Sets.newHashSet();

      boolean downscale = false;
      for (String component : filter) {
        if ("downscale".equals(component)) {
          downscale = true;
        } else {
          densities.add(Filters.Density.from(component));
        }
      }

      this.downscale = downscale;
    }

    public boolean shouldDownscale() {
      return isEnabled() && downscale;
    }

    @Nullable
    public Set<Filters.Density> getDensities() {
      return densities;
    }

    public boolean isEnabled() {
      return !densities.isEmpty();
    }

    public String getDescription() {
      return filter.toString();
    }

    @Override
    public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
      return builder.setReflectively("filter", getDescription());
    }

    @VisibleForTesting
    Set<String> getFilter() {
      return filter;
    }
  }

  public static Builder builder() {
    return new Builder();
  }

  public static class Builder {

    @Nullable
    private ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
    @Nullable
    private ResourceFilter resourceFilter;
    private boolean filterStrings = false;
    private ImmutableSet<Path> whitelistedStringDirs = ImmutableSet.of();
    private ImmutableSet<String> locales = ImmutableSet.of();

    private Builder() {
    }

    public Builder setInResToOutResDirMap(ImmutableBiMap<Path, Path> inResDirToOutResDirMap) {
      this.inResDirToOutResDirMap = inResDirToOutResDirMap;
      return this;
    }

    public Builder setResourceFilter(ResourceFilter resourceFilter) {
      this.resourceFilter = resourceFilter;
      return this;
    }

    public Builder enableStringsFilter() {
      this.filterStrings = true;
      return this;
    }

    public Builder setWhitelistedStringDirs(ImmutableSet<Path> whitelistedStringDirs) {
      this.whitelistedStringDirs = whitelistedStringDirs;
      return this;
    }

    public Builder setLocales(ImmutableSet<String> locales) {
      this.locales = locales;
      return this;
    }

    public FilterResourcesStep build() {
      Preconditions.checkNotNull(resourceFilter);
      LOG.info("FilterResourcesStep.Builder: resource filter: %s", resourceFilter);
      Preconditions.checkNotNull(inResDirToOutResDirMap);
      return new FilterResourcesStep(
          inResDirToOutResDirMap,
          resourceFilter.isEnabled(),
          filterStrings,
          whitelistedStringDirs,
          locales,
          DefaultFilteredDirectoryCopier.getInstance(),
          resourceFilter.getDensities(),
          DefaultDrawableFinder.getInstance(),
          resourceFilter.shouldDownscale() ? ImageMagickScaler.getInstance() : null);
    }
  }
}

<code block>


package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildOutputInitializer;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.InitializableFromDisk;
import com.facebook.buck.rules.OnDiskBuildInfo;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.step.AbstractExecutionStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.nio.file.Paths;

import javax.annotation.Nullable;


public class ResourcesFilter extends AbstractBuildRule
    implements FilteredResourcesProvider, InitializableFromDisk<ResourcesFilter.BuildOutput> {

  private static final String RES_DIRECTORIES_KEY = "res_directories";
  private static final String STRING_FILES_KEY = "string_files";

  static enum ResourceCompressionMode {
    DISABLED( false,  false),
    ENABLED( true,  false),
    ENABLED_WITH_STRINGS_AS_ASSETS(
 true,
 true),
    ;

    private final boolean isCompressResources;
    private final boolean isStoreStringsAsAssets;

    private ResourceCompressionMode(boolean isCompressResources, boolean isStoreStringsAsAssets) {
      this.isCompressResources = isCompressResources;
      this.isStoreStringsAsAssets = isStoreStringsAsAssets;
    }

    public boolean isCompressResources() {
      return isCompressResources;
    }

    public boolean isStoreStringsAsAssets() {
      return isStoreStringsAsAssets;
    }
  }



  private final ImmutableList<SourcePath> resDirectories;
  private final ImmutableSet<SourcePath> whitelistedStringDirs;
  @AddToRuleKey
  private final ImmutableSet<String> locales;
  @AddToRuleKey
  private final ResourceCompressionMode resourceCompressionMode;
  @AddToRuleKey
  private final FilterResourcesStep.ResourceFilter resourceFilter;
  private final BuildOutputInitializer<BuildOutput> buildOutputInitializer;

  public ResourcesFilter(
      BuildRuleParams params,
      SourcePathResolver resolver,
      ImmutableList<SourcePath> resDirectories,
      ImmutableSet<SourcePath> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ResourceCompressionMode resourceCompressionMode,
      FilterResourcesStep.ResourceFilter resourceFilter) {
    super(params, resolver);
    this.resDirectories = resDirectories;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.resourceCompressionMode = resourceCompressionMode;
    this.resourceFilter = resourceFilter;
    this.buildOutputInitializer = new BuildOutputInitializer<>(params.getBuildTarget(), this);
  }

  @Override
  public ImmutableList<SourcePath> getResDirectories() {
    return buildOutputInitializer.getBuildOutput().resDirectories;
  }

  @Override
  public ImmutableList<SourcePath> getStringFiles() {
    return buildOutputInitializer.getBuildOutput().stringFiles;
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      final BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();

    final ImmutableList.Builder<Path> filteredResDirectoriesBuilder = ImmutableList.builder();
    ImmutableSet<Path> whitelistedStringPaths =
        ImmutableSet.copyOf(getResolver().getAllPaths(whitelistedStringDirs));
    ImmutableList<Path> resPaths = getResolver().getAllPaths(resDirectories);
    final FilterResourcesStep filterResourcesStep = createFilterResourcesStep(
        resPaths,
        whitelistedStringPaths,
        locales,
        filteredResDirectoriesBuilder);
    steps.add(filterResourcesStep);

    final ImmutableList.Builder<Path> stringFilesBuilder = ImmutableList.builder();

    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      GetStringsFilesStep getStringsFilesStep = new GetStringsFilesStep(
          resPaths,
          stringFilesBuilder,
          whitelistedStringPaths);
      steps.add(getStringsFilesStep);
    }

    final ImmutableList<Path> filteredResDirectories = filteredResDirectoriesBuilder.build();
    for (Path outputResourceDir : filteredResDirectories) {
      buildableContext.recordArtifact(outputResourceDir);
    }

    steps.add(new AbstractExecutionStep("record_build_output") {
      @Override
      public int execute(ExecutionContext context) {
        buildableContext.addMetadata(
            RES_DIRECTORIES_KEY,
            Iterables.transform(filteredResDirectories, Functions.toStringFunction()));
        buildableContext.addMetadata(
            STRING_FILES_KEY,
            Iterables.transform(stringFilesBuilder.build(), Functions.toStringFunction()));
        return 0;
      }
    });

    return steps.build();
  }


  @VisibleForTesting
  FilterResourcesStep createFilterResourcesStep(
      ImmutableList<Path> resourceDirectories,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ImmutableList.Builder<Path> filteredResDirectories) {
    ImmutableBiMap.Builder<Path, Path> filteredResourcesDirMapBuilder = ImmutableBiMap.builder();
    String resDestinationBasePath = getResDestinationBasePath();
    int count = 0;
    for (Path resDir : resourceDirectories) {
      Path filteredResourceDir = Paths.get(resDestinationBasePath, String.valueOf(count++));
      filteredResourcesDirMapBuilder.put(resDir, filteredResourceDir);
      filteredResDirectories.add(filteredResourceDir);
    }

    ImmutableBiMap<Path, Path> resSourceToDestDirMap = filteredResourcesDirMapBuilder.build();
    FilterResourcesStep.Builder filterResourcesStepBuilder = FilterResourcesStep.builder()
        .setInResToOutResDirMap(resSourceToDestDirMap)
        .setResourceFilter(resourceFilter);

    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      filterResourcesStepBuilder.enableStringsFilter();
      filterResourcesStepBuilder.setWhitelistedStringDirs(whitelistedStringDirs);
    }

    filterResourcesStepBuilder.setLocales(locales);

    return filterResourcesStepBuilder.build();
  }

  private String getResDestinationBasePath() {
    return BuildTargets.getScratchPath(getBuildTarget(), "__filtered__%s__").toString();
  }

  @Override
  public BuildOutput initializeFromDisk(OnDiskBuildInfo onDiskBuildInfo) {
    ImmutableList<SourcePath> resDirectories =
        FluentIterable.from(onDiskBuildInfo.getValues(RES_DIRECTORIES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();
    ImmutableList<SourcePath> stringFiles =
        FluentIterable.from(onDiskBuildInfo.getValues(STRING_FILES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();

    return new BuildOutput(resDirectories, stringFiles);
  }

  @Override
  public BuildOutputInitializer<BuildOutput> getBuildOutputInitializer() {
    return buildOutputInitializer;
  }

  public static class BuildOutput {
    private final ImmutableList<SourcePath> resDirectories;
    private final ImmutableList<SourcePath> stringFiles;

    public BuildOutput(
        ImmutableList<SourcePath> resDirectories,
        ImmutableList<SourcePath> stringFiles) {
      this.resDirectories = resDirectories;
      this.stringFiles = stringFiles;
    }
  }

  @Nullable
  @Override
  public Path getPathToOutput() {
    return null;
  }
}

<code block>


package com.facebook.buck.android;

import static org.easymock.EasyMock.newCapture;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.android.FilterResourcesStep.ImageScaler;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.Verbosity;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.easymock.IAnswer;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class FilterResourcesStepTest {

  private static final String first = "/first-path/res";
  private static final String second = "/second-path/res";
  private static final String third = "/third-path/res";

  private static final ImmutableBiMap<Path, Path> inResDirToOutResDirMap =
      ImmutableBiMap.of(
          Paths.get(first), Paths.get("/dest/1"),
          Paths.get(second), Paths.get("/dest/2"),
          Paths.get(third), Paths.get("/dest/3"));
  private static Set<String> qualifiers = ImmutableSet.of("mdpi", "hdpi", "xhdpi");
  private final Filters.Density targetDensity = Filters.Density.MDPI;
  private final File baseDestination = new File("/dest");

  private final Path scaleSource = getDrawableFile(first, "xhdpi", "other.png");
  private final Path scaleDest = getDrawableFile(first, "mdpi", "other.png");

  private Path getDrawableFile(String dir, String qualifier, String filename) {
    return Paths.get(dir, String.format("drawable-%s", qualifier), filename);
  }

  @Test
  public void testFilterDrawables() throws IOException, InterruptedException {


    ProjectFilesystem filesystem = EasyMock.createMock(ProjectFilesystem.class);
    EasyMock.expect(filesystem.getRootPath()).andStubReturn(Paths.get("."));
    EasyMock
      .expect(filesystem.getFileForRelativePath(EasyMock.<Path>anyObject()))
      .andAnswer(new IAnswer<File>(){
          @Override
          public File answer() throws Throwable {
             return ((Path) EasyMock.getCurrentArguments()[0]).toFile();
          }})
      .anyTimes();
    filesystem.createParentDirs(scaleDest);
    filesystem.deleteFileAtPath(scaleSource);
    Path scaleSourceDir = scaleSource.getParent();
    EasyMock.expect(filesystem.listFiles(scaleSourceDir)).andReturn(new File[0]);
    filesystem.deleteFileAtPath(scaleSourceDir);
    EasyMock.replay(filesystem);


    ExecutionContext context = EasyMock.createMock(ExecutionContext.class);
    ProcessExecutor processExecutor = EasyMock.createMock(ProcessExecutor.class);
    EasyMock.expect(context.getProcessExecutor()).andReturn(processExecutor).anyTimes();
    EasyMock.expect(context.getVerbosity()).andReturn(Verbosity.SILENT).anyTimes();
    EasyMock.expect(context.getProjectFilesystem()).andReturn(filesystem).anyTimes();
    EasyMock.replay(context);


    FilterResourcesStep.DrawableFinder finder = EasyMock.createMock(
        FilterResourcesStep.DrawableFinder.class);


    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);

    Capture<Map<Path, Path>> dirMapCapture = newCapture();
    Capture<Predicate<Path>> predCapture = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.capture(dirMapCapture),
        EasyMock.capture(predCapture));
    EasyMock.replay(copier);

    ImageScaler scaler = EasyMock.createMock(ImageScaler.class);
    scaler.scale(
        0.5,
        scaleSource,
        scaleDest,
        context);

    EasyMock.expect(scaler.isAvailable(context)).andReturn(true);
    EasyMock.replay(scaler);

    FilterResourcesStep command = new FilterResourcesStep(
        inResDirToOutResDirMap,
 true,
 true,
 ImmutableSet.<Path>of(),
 ImmutableSet.<String>of(),
        copier,
        ImmutableSet.of(targetDensity),
        finder,
        scaler);

    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            for (String qualifier : qualifiers) {
              builder.add(getDrawableFile(dir.toString(), qualifier, "some.png"));
            }
          }

          builder.add(scaleSource);

          return builder.build();
        }
      })
      .times(2); 


    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.values(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            builder.add(getDrawableFile(dir.toString(), targetDensity.toString(), "some.png"));
          }

          builder.add(scaleSource);
          return builder.build();
        }
      })
      .once();
    EasyMock.replay(finder);


    ImmutableMap.Builder<Path, Path> dirMapBuilder = ImmutableMap.builder();

    Iterator<Path> destIterator = inResDirToOutResDirMap.values().iterator();
    for (Path dir : inResDirToOutResDirMap.keySet()) {
      Path nextDestination = destIterator.next();
      dirMapBuilder.put(dir, nextDestination);


      assertEquals(baseDestination, nextDestination.getParent().toFile());
    }


    command.execute(context);


    assertEquals(dirMapBuilder.build(), dirMapCapture.getValue());


    Set<Path> drawables = finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem);
    Predicate<Path> expectedPred =
        Filters.createImageDensityFilter(drawables, ImmutableSet.of(targetDensity), false);
    Predicate<Path> capturedPred = predCapture.getValue();
    for (Path drawablePath : drawables) {
      assertEquals(expectedPred.apply(drawablePath), capturedPred.apply(drawablePath));
    }



    EasyMock.verify(copier, context, finder, filesystem, scaler);
  }

  @Test
  public void testFilterStrings() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
 ImmutableBiMap.<Path, Path>of(),
 false,
 true,
 ImmutableSet.of(Paths.get("com/whitelisted/res")),
 ImmutableSet.<String>of(),
        copier,
 null,
 null,
 null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-af/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-af/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testFilterStringsIncludingEnglishStrings() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
 ImmutableBiMap.<Path, Path>of(),
 false,
 true,
 ImmutableSet.of(Paths.get("com/whitelisted/res")),
 ImmutableSet.<String>of(),
        copier,
 null,
 null,
 null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-af/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-af/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testFilterLocales() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
 ImmutableBiMap.<Path, Path>of(),
 false,
 false,
 ImmutableSet.<Path>of(Paths.get("com/whitelisted/res")),
        ImmutableSet.of("es", "es_US"),
        copier,
 null,
 null,
 null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es-rUS/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-es-rES/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-en/strings.xml")));
    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-es-rES/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testNonEnglishStringsPathRegex() {
    assertTrue(matchesRegex("res/values-es/strings.xml"));
    assertFalse(matchesRegex("res/values/strings.xml"));
    assertFalse(matchesRegex("res/values-/strings.xml"));
    assertTrue(matchesRegex("/res/values-es/strings.xml"));
    assertFalse(matchesRegex("rootres/values-es/strings.xml"));
    assertTrue(matchesRegex("root/res/values-es-rUS/strings.xml"));
  }

  private static boolean matchesRegex(String input) {
    return FilterResourcesStep.NON_ENGLISH_STRINGS_FILE_PATH.matcher(input).matches();
  }
}

<code block>


package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.shell.BashStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.DefaultFilteredDirectoryCopier;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.Filters.Density;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Verbosity;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;


public class FilterResourcesStep implements Step {

  private static final Pattern DRAWABLE_PATH_PATTERN = Pattern.compile(
      ".*drawable.*/.*(png|jpg|jpeg|gif|webp)", Pattern.CASE_INSENSITIVE);

  private static final Pattern DRAWABLE_EXCLUDE_PATTERN = Pattern.compile(
      ".*-nodpi.*", Pattern.CASE_INSENSITIVE);

  private static final Logger LOG = Logger.get(FilterResourcesStep.class);

  @VisibleForTesting
  static final Pattern NON_ENGLISH_STRINGS_FILE_PATH = Pattern.compile(
      "\\b|.*/res/values-([a-z]{2})(?:-r([A-Z]{2}))*/strings.xml");

  private final ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
  private final boolean filterDrawables;
  private final boolean enableStringWhitelisting;
  private final ImmutableSet<Path> whitelistedStringDirs;
  private final ImmutableSet<String> locales;
  private final FilteredDirectoryCopier filteredDirectoryCopier;
  @Nullable
  private final Set<Filters.Density> targetDensities;
  @Nullable
  private final DrawableFinder drawableFinder;
  @Nullable
  private final ImageScaler imageScaler;


  @VisibleForTesting
  FilterResourcesStep(
      ImmutableBiMap<Path, Path> inResDirToOutResDirMap,
      boolean filterDrawables,
      boolean enableStringWhitelisting,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      FilteredDirectoryCopier filteredDirectoryCopier,
      @Nullable Set<Filters.Density> targetDensities,
      @Nullable DrawableFinder drawableFinder,
      @Nullable ImageScaler imageScaler) {

    Preconditions.checkArgument(filterDrawables || enableStringWhitelisting || !locales.isEmpty());
    Preconditions.checkArgument(!filterDrawables ||
        (targetDensities != null && drawableFinder != null));
    this.inResDirToOutResDirMap = inResDirToOutResDirMap;
    this.filterDrawables = filterDrawables;
    this.enableStringWhitelisting = enableStringWhitelisting;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.filteredDirectoryCopier = filteredDirectoryCopier;
    this.targetDensities = targetDensities;
    this.drawableFinder = drawableFinder;
    this.imageScaler = imageScaler;
  }

  @Override
  public int execute(ExecutionContext context) {
    try {
      return doExecute(context);
    } catch (Exception e) {
      context.logError(e, "There was an error filtering resources.");
      return 1;
    }
  }

  private int doExecute(ExecutionContext context) throws IOException, InterruptedException {
    List<Predicate<Path>> pathPredicates = Lists.newArrayList();

    boolean canDownscale = imageScaler != null && imageScaler.isAvailable(context);
    LOG.info(
        "FilterResourcesStep: canDownscale: %s. imageScalar non-null: %s.",
        canDownscale,
        imageScaler != null);

    if (filterDrawables) {
      Preconditions.checkNotNull(drawableFinder);
      Set<Path> drawables = drawableFinder.findDrawables(
          inResDirToOutResDirMap.keySet(),
          context.getProjectFilesystem());
      pathPredicates.add(
          Filters.createImageDensityFilter(
              drawables,
              Preconditions.checkNotNull(targetDensities),
              canDownscale));
    }

    final boolean localeFilterEnabled = !locales.isEmpty();
    if (localeFilterEnabled || enableStringWhitelisting) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path path) {
              Matcher matcher = NON_ENGLISH_STRINGS_FILE_PATH.matcher(
                  MorePaths.pathWithUnixSeparators(path));
              if (!matcher.matches()) {
                return true;
              }

              if (enableStringWhitelisting) {
                return isPathWhitelisted(path);
              } else {
                Preconditions.checkState(localeFilterEnabled);
                String locale = matcher.group(1);
                if (matcher.group(2) != null) {
                  locale += "_" + matcher.group(2);
                }

                return locales.contains(locale);
              }
            }
          });
    }


    filteredDirectoryCopier.copyDirs(
        context.getProjectFilesystem(),
        inResDirToOutResDirMap,
        Predicates.and(pathPredicates));


    if (canDownscale && filterDrawables) {
      scaleUnmatchedDrawables(context);
    }

    return 0;
  }

  private boolean isPathWhitelisted(Path path) {
    for (Path whitelistedStringDir : whitelistedStringDirs) {
      if (path.startsWith(whitelistedStringDir)) {
        return true;
      }
    }

    return false;
  }

  @Override
  public String getShortName() {
    return "resource_filtering";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return "Filtering drawable and string resources.";
  }


  private void scaleUnmatchedDrawables(ExecutionContext context)
      throws IOException, InterruptedException {
    ProjectFilesystem filesystem = context.getProjectFilesystem();
    Filters.Density targetDensity = Filters.Density.ORDERING.max(targetDensities);


    Preconditions.checkNotNull(drawableFinder);
    Collection<Path> drawables = drawableFinder.findDrawables(
        inResDirToOutResDirMap.values(),
        context.getProjectFilesystem());
    for (Path drawable : drawables) {
      if (drawable.toString().endsWith(".9.png")) {

        continue;
      }

      Filters.Qualifiers qualifiers = new Filters.Qualifiers(drawable);
      Filters.Density density = qualifiers.density;


      Preconditions.checkNotNull(targetDensities);
      if (!targetDensities.contains(density)) {



        String fromDensity = (density == Density.NO_QUALIFIER ? "" : "-") + density.toString();
        Path destination = Paths.get(MorePaths.pathWithUnixSeparators(drawable).replaceFirst(
            "((?:^|/)drawable[^/]*)" + Pattern.quote(fromDensity) + "(-|$|/)",
            "$1-" + targetDensity + "$2"));

        double factor = targetDensity.value() / density.value();
        if (factor >= 1.0) {

          continue;
        }


        filesystem.createParentDirs(destination);
        Preconditions.checkNotNull(imageScaler);
        imageScaler.scale(factor, drawable, destination, context);


        filesystem.deleteFileAtPath(drawable);


        Path parent = drawable.getParent();
        if (filesystem.listFiles(parent).length == 0) {
          filesystem.deleteFileAtPath(parent);
        }

      }
    }
  }

  public interface DrawableFinder {
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException;
  }

  public static class DefaultDrawableFinder implements DrawableFinder {

    private static final DefaultDrawableFinder instance = new DefaultDrawableFinder();

    public static DefaultDrawableFinder getInstance() {
      return instance;
    }

    @Override
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException {
      final ImmutableSet.Builder<Path> drawableBuilder = ImmutableSet.builder();
      for (Path dir : dirs) {
        filesystem.walkRelativeFileTree(dir, new SimpleFileVisitor<Path>() {
              @Override
              public FileVisitResult visitFile(Path path, BasicFileAttributes attributes) {
                String unixPath = MorePaths.pathWithUnixSeparators(path);
                if (DRAWABLE_PATH_PATTERN.matcher(unixPath).matches() &&
                    !DRAWABLE_EXCLUDE_PATTERN.matcher(unixPath).matches()) {

                  drawableBuilder.add(path);
                }
                return FileVisitResult.CONTINUE;
              }
            });
      }
      return drawableBuilder.build();
    }
  }

  public interface ImageScaler {
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException;
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException;
  }


  public static class ImageMagickScaler implements ImageScaler {

    private static final ImageMagickScaler instance = new ImageMagickScaler();

    public static ImageMagickScaler getInstance() {
      return instance;
    }

    private ExecutionContext getContextWithSilentConsole(ExecutionContext context) {

      Console console = context.getConsole();
      return ExecutionContext.builder()
          .setExecutionContext(context)
          .setConsole(new Console(
              Verbosity.SILENT,
              console.getStdOut(),
              console.getStdErr(),
              console.getAnsi()
          ))
          .build();
    }

    @Override
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException {
      try (ExecutionContext silentContext = getContextWithSilentConsole(context)) {
        return 0 == new BashStep("which convert").execute(silentContext);
      }
    }

    @Override
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException {
      Step convertStep = new BashStep(
          "convert",
          "-adaptive-resize", (int) (factor * 100) + "%",
          Escaper.escapeAsBashString(source),
          Escaper.escapeAsBashString(destination));

      if (0 != convertStep.execute(context)) {
        throw new HumanReadableException("Cannot scale " + source + " to " + destination);
      }
    }
  }


  public static class ResourceFilter implements RuleKeyAppendable {

    static final ResourceFilter EMPTY_FILTER = new ResourceFilter(ImmutableList.<String>of());

    private final Set<String> filter;
    private final Set<Filters.Density> densities;
    private final boolean downscale;

    public ResourceFilter(List<String> resourceFilter) {
      this.filter = ImmutableSet.copyOf(resourceFilter);
      this.densities = Sets.newHashSet();

      boolean downscale = false;
      for (String component : filter) {
        if ("downscale".equals(component)) {
          downscale = true;
        } else {
          densities.add(Filters.Density.from(component));
        }
      }

      this.downscale = downscale;
    }

    public boolean shouldDownscale() {
      return isEnabled() && downscale;
    }

    @Nullable
    public Set<Filters.Density> getDensities() {
      return densities;
    }

    public boolean isEnabled() {
      return !densities.isEmpty();
    }

    public String getDescription() {
      return filter.toString();
    }

    @Override
    public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
      return builder.setReflectively("filter", getDescription());
    }

    @VisibleForTesting
    Set<String> getFilter() {
      return filter;
    }
  }

  public static Builder builder() {
    return new Builder();
  }

  public static class Builder {

    @Nullable
    private ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
    @Nullable
    private ResourceFilter resourceFilter;
    private ImmutableSet<Path> whitelistedStringDirs = ImmutableSet.of();
    private ImmutableSet<String> locales = ImmutableSet.of();
    private boolean enableStringWhitelisting = false;

    private Builder() {
    }

    public Builder setInResToOutResDirMap(ImmutableBiMap<Path, Path> inResDirToOutResDirMap) {
      this.inResDirToOutResDirMap = inResDirToOutResDirMap;
      return this;
    }

    public Builder setResourceFilter(ResourceFilter resourceFilter) {
      this.resourceFilter = resourceFilter;
      return this;
    }

    public Builder enableStringWhitelisting() {
      this.enableStringWhitelisting = true;
      return this;
    }

    public Builder setWhitelistedStringDirs(ImmutableSet<Path> whitelistedStringDirs) {
      this.whitelistedStringDirs = whitelistedStringDirs;
      return this;
    }

    public Builder setLocales(ImmutableSet<String> locales) {
      this.locales = locales;
      return this;
    }

    public FilterResourcesStep build() {
      Preconditions.checkNotNull(resourceFilter);
      LOG.info("FilterResourcesStep.Builder: resource filter: %s", resourceFilter);
      Preconditions.checkNotNull(inResDirToOutResDirMap);
      return new FilterResourcesStep(
          inResDirToOutResDirMap,
          resourceFilter.isEnabled(),
          enableStringWhitelisting,
          whitelistedStringDirs,
          locales,
          DefaultFilteredDirectoryCopier.getInstance(),
          resourceFilter.getDensities(),
          DefaultDrawableFinder.getInstance(),
          resourceFilter.shouldDownscale() ? ImageMagickScaler.getInstance() : null);
    }
  }
}

<code block>


package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildOutputInitializer;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.InitializableFromDisk;
import com.facebook.buck.rules.OnDiskBuildInfo;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.step.AbstractExecutionStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.nio.file.Paths;

import javax.annotation.Nullable;


public class ResourcesFilter extends AbstractBuildRule
    implements FilteredResourcesProvider, InitializableFromDisk<ResourcesFilter.BuildOutput> {

  private static final String RES_DIRECTORIES_KEY = "res_directories";
  private static final String STRING_FILES_KEY = "string_files";

  static enum ResourceCompressionMode {
    DISABLED( false,  false),
    ENABLED( true,  false),
    ENABLED_WITH_STRINGS_AS_ASSETS(
 true,
 true),
    ;

    private final boolean isCompressResources;
    private final boolean isStoreStringsAsAssets;

    private ResourceCompressionMode(boolean isCompressResources, boolean isStoreStringsAsAssets) {
      this.isCompressResources = isCompressResources;
      this.isStoreStringsAsAssets = isStoreStringsAsAssets;
    }

    public boolean isCompressResources() {
      return isCompressResources;
    }

    public boolean isStoreStringsAsAssets() {
      return isStoreStringsAsAssets;
    }
  }



  private final ImmutableList<SourcePath> resDirectories;
  private final ImmutableSet<SourcePath> whitelistedStringDirs;
  @AddToRuleKey
  private final ImmutableSet<String> locales;
  @AddToRuleKey
  private final ResourceCompressionMode resourceCompressionMode;
  @AddToRuleKey
  private final FilterResourcesStep.ResourceFilter resourceFilter;
  private final BuildOutputInitializer<BuildOutput> buildOutputInitializer;

  public ResourcesFilter(
      BuildRuleParams params,
      SourcePathResolver resolver,
      ImmutableList<SourcePath> resDirectories,
      ImmutableSet<SourcePath> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ResourceCompressionMode resourceCompressionMode,
      FilterResourcesStep.ResourceFilter resourceFilter) {
    super(params, resolver);
    this.resDirectories = resDirectories;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.resourceCompressionMode = resourceCompressionMode;
    this.resourceFilter = resourceFilter;
    this.buildOutputInitializer = new BuildOutputInitializer<>(params.getBuildTarget(), this);
  }

  @Override
  public ImmutableList<SourcePath> getResDirectories() {
    return buildOutputInitializer.getBuildOutput().resDirectories;
  }

  @Override
  public ImmutableList<SourcePath> getStringFiles() {
    return buildOutputInitializer.getBuildOutput().stringFiles;
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      final BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();

    final ImmutableList.Builder<Path> filteredResDirectoriesBuilder = ImmutableList.builder();
    ImmutableSet<Path> whitelistedStringPaths =
        ImmutableSet.copyOf(getResolver().getAllPaths(whitelistedStringDirs));
    ImmutableList<Path> resPaths = getResolver().getAllPaths(resDirectories);
    final FilterResourcesStep filterResourcesStep = createFilterResourcesStep(
        resPaths,
        whitelistedStringPaths,
        locales,
        filteredResDirectoriesBuilder);
    steps.add(filterResourcesStep);

    final ImmutableList.Builder<Path> stringFilesBuilder = ImmutableList.builder();

    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      GetStringsFilesStep getStringsFilesStep = new GetStringsFilesStep(
          resPaths,
          stringFilesBuilder,
          whitelistedStringPaths);
      steps.add(getStringsFilesStep);
    }

    final ImmutableList<Path> filteredResDirectories = filteredResDirectoriesBuilder.build();
    for (Path outputResourceDir : filteredResDirectories) {
      buildableContext.recordArtifact(outputResourceDir);
    }

    steps.add(new AbstractExecutionStep("record_build_output") {
      @Override
      public int execute(ExecutionContext context) {
        buildableContext.addMetadata(
            RES_DIRECTORIES_KEY,
            Iterables.transform(filteredResDirectories, Functions.toStringFunction()));
        buildableContext.addMetadata(
            STRING_FILES_KEY,
            Iterables.transform(stringFilesBuilder.build(), Functions.toStringFunction()));
        return 0;
      }
    });

    return steps.build();
  }


  @VisibleForTesting
  FilterResourcesStep createFilterResourcesStep(
      ImmutableList<Path> resourceDirectories,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ImmutableList.Builder<Path> filteredResDirectories) {
    ImmutableBiMap.Builder<Path, Path> filteredResourcesDirMapBuilder = ImmutableBiMap.builder();
    String resDestinationBasePath = getResDestinationBasePath();
    int count = 0;
    for (Path resDir : resourceDirectories) {
      Path filteredResourceDir = Paths.get(resDestinationBasePath, String.valueOf(count++));
      filteredResourcesDirMapBuilder.put(resDir, filteredResourceDir);
      filteredResDirectories.add(filteredResourceDir);
    }

    ImmutableBiMap<Path, Path> resSourceToDestDirMap = filteredResourcesDirMapBuilder.build();
    FilterResourcesStep.Builder filterResourcesStepBuilder = FilterResourcesStep.builder()
        .setInResToOutResDirMap(resSourceToDestDirMap)
        .setResourceFilter(resourceFilter);

    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      filterResourcesStepBuilder.enableStringWhitelisting();
      filterResourcesStepBuilder.setWhitelistedStringDirs(whitelistedStringDirs);
    }

    filterResourcesStepBuilder.setLocales(locales);

    return filterResourcesStepBuilder.build();
  }

  private String getResDestinationBasePath() {
    return BuildTargets.getScratchPath(getBuildTarget(), "__filtered__%s__").toString();
  }

  @Override
  public BuildOutput initializeFromDisk(OnDiskBuildInfo onDiskBuildInfo) {
    ImmutableList<SourcePath> resDirectories =
        FluentIterable.from(onDiskBuildInfo.getValues(RES_DIRECTORIES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();
    ImmutableList<SourcePath> stringFiles =
        FluentIterable.from(onDiskBuildInfo.getValues(STRING_FILES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();

    return new BuildOutput(resDirectories, stringFiles);
  }

  @Override
  public BuildOutputInitializer<BuildOutput> getBuildOutputInitializer() {
    return buildOutputInitializer;
  }

  public static class BuildOutput {
    private final ImmutableList<SourcePath> resDirectories;
    private final ImmutableList<SourcePath> stringFiles;

    public BuildOutput(
        ImmutableList<SourcePath> resDirectories,
        ImmutableList<SourcePath> stringFiles) {
      this.resDirectories = resDirectories;
      this.stringFiles = stringFiles;
    }
  }

  @Nullable
  @Override
  public Path getPathToOutput() {
    return null;
  }
}

<code block>


package com.facebook.buck.android;

import static org.easymock.EasyMock.newCapture;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.android.FilterResourcesStep.ImageScaler;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.Verbosity;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.easymock.IAnswer;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;

public class FilterResourcesStepTest {

  private static final String first = "/first-path/res";
  private static final String second = "/second-path/res";
  private static final String third = "/third-path/res";

  private static final ImmutableBiMap<Path, Path> inResDirToOutResDirMap =
      ImmutableBiMap.of(
          Paths.get(first), Paths.get("/dest/1"),
          Paths.get(second), Paths.get("/dest/2"),
          Paths.get(third), Paths.get("/dest/3"));
  private static Set<String> qualifiers = ImmutableSet.of("mdpi", "hdpi", "xhdpi");
  private final Filters.Density targetDensity = Filters.Density.MDPI;
  private final File baseDestination = new File("/dest");

  private final Path scaleSource = getDrawableFile(first, "xhdpi", "other.png");
  private final Path scaleDest = getDrawableFile(first, "mdpi", "other.png");

  private Path getDrawableFile(String dir, String qualifier, String filename) {
    return Paths.get(dir, String.format("drawable-%s", qualifier), filename);
  }

  @Test
  public void testFilterDrawables() throws IOException, InterruptedException {


    ProjectFilesystem filesystem = EasyMock.createMock(ProjectFilesystem.class);
    EasyMock.expect(filesystem.getRootPath()).andStubReturn(Paths.get("."));
    EasyMock
      .expect(filesystem.getFileForRelativePath(EasyMock.<Path>anyObject()))
      .andAnswer(new IAnswer<File>(){
          @Override
          public File answer() throws Throwable {
             return ((Path) EasyMock.getCurrentArguments()[0]).toFile();
          }})
      .anyTimes();
    filesystem.createParentDirs(scaleDest);
    filesystem.deleteFileAtPath(scaleSource);
    Path scaleSourceDir = scaleSource.getParent();
    EasyMock.expect(filesystem.listFiles(scaleSourceDir)).andReturn(new File[0]);
    filesystem.deleteFileAtPath(scaleSourceDir);
    EasyMock.replay(filesystem);


    ExecutionContext context = EasyMock.createMock(ExecutionContext.class);
    ProcessExecutor processExecutor = EasyMock.createMock(ProcessExecutor.class);
    EasyMock.expect(context.getProcessExecutor()).andReturn(processExecutor).anyTimes();
    EasyMock.expect(context.getVerbosity()).andReturn(Verbosity.SILENT).anyTimes();
    EasyMock.expect(context.getProjectFilesystem()).andReturn(filesystem).anyTimes();
    EasyMock.replay(context);


    FilterResourcesStep.DrawableFinder finder = EasyMock.createMock(
        FilterResourcesStep.DrawableFinder.class);


    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);

    Capture<Map<Path, Path>> dirMapCapture = newCapture();
    Capture<Predicate<Path>> predCapture = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.capture(dirMapCapture),
        EasyMock.capture(predCapture));
    EasyMock.replay(copier);

    ImageScaler scaler = EasyMock.createMock(ImageScaler.class);
    scaler.scale(
        0.5,
        scaleSource,
        scaleDest,
        context);

    EasyMock.expect(scaler.isAvailable(context)).andReturn(true);
    EasyMock.replay(scaler);

    FilterResourcesStep command = new FilterResourcesStep(
        inResDirToOutResDirMap,
 true,
 false,
 ImmutableSet.<Path>of(),
 ImmutableSet.<String>of(),
        copier,
        ImmutableSet.of(targetDensity),
        finder,
        scaler);

    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            for (String qualifier : qualifiers) {
              builder.add(getDrawableFile(dir.toString(), qualifier, "some.png"));
            }
          }

          builder.add(scaleSource);

          return builder.build();
        }
      })
      .times(2); 


    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.values(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            builder.add(getDrawableFile(dir.toString(), targetDensity.toString(), "some.png"));
          }

          builder.add(scaleSource);
          return builder.build();
        }
      })
      .once();
    EasyMock.replay(finder);


    ImmutableMap.Builder<Path, Path> dirMapBuilder = ImmutableMap.builder();

    Iterator<Path> destIterator = inResDirToOutResDirMap.values().iterator();
    for (Path dir : inResDirToOutResDirMap.keySet()) {
      Path nextDestination = destIterator.next();
      dirMapBuilder.put(dir, nextDestination);


      assertEquals(baseDestination, nextDestination.getParent().toFile());
    }


    command.execute(context);


    assertEquals(dirMapBuilder.build(), dirMapCapture.getValue());


    Set<Path> drawables = finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem);
    Predicate<Path> expectedPred =
        Filters.createImageDensityFilter(drawables, ImmutableSet.of(targetDensity), false);
    Predicate<Path> capturedPred = predCapture.getValue();
    for (Path drawablePath : drawables) {
      assertEquals(expectedPred.apply(drawablePath), capturedPred.apply(drawablePath));
    }



    EasyMock.verify(copier, context, finder, filesystem, scaler);
  }

  @Test
  public void testWhitelistFilter() throws IOException {
    Predicate<Path> filePredicate = getTestPathPredicate(
        true, ImmutableSet.of(Paths.get("com/whitelisted/res")), ImmutableSet.<String>of());

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-af/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-af/integers.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-af/strings.xml")));
  }

  @Test
  public void testFilterLocales() throws IOException {
    Predicate<Path> filePredicate = getTestPathPredicate(
        false, ImmutableSet.<Path>of(), ImmutableSet.of("es", "es_US"));

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es-rUS/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/integers.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-en/integers.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-en/strings.xml")));
    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-es-rES/strings.xml")));
  }

  @Test
  public void testUsingWhitelistIgnoresLocaleFilter() throws IOException {
    Predicate<Path> filePredicate = getTestPathPredicate(
        true, ImmutableSet.<Path>of(Paths.get("com/example/res")), ImmutableSet.of("es", "es_US"));

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es-rUS/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/integers.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-en/integers.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-en/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es-rES/strings.xml")));

  }

  @Test
  public void testNonEnglishStringsPathRegex() {
    assertMatchesRegex("path/res/values-es/strings.xml", "es", null);
    assertNotMatchesRegex("res/values/strings.xml");
    assertNotMatchesRegex("res/values-es/integers.xml");
    assertNotMatchesRegex("res/values-/strings.xml");
    assertMatchesRegex("/res/values-es/strings.xml", "es", null);
    assertNotMatchesRegex("rootres/values-es/strings.xml");
    assertMatchesRegex("root/res/values-es-rUS/strings.xml", "es", "US");
  }

  private static void assertMatchesRegex(String path, String language, String country) {
    Matcher matcher = FilterResourcesStep.NON_ENGLISH_STRINGS_FILE_PATH.matcher(path);
    assertTrue(matcher.matches());
    assertEquals(language, matcher.group(1));
    assertEquals(country, matcher.group(2));
  }

  private static void assertNotMatchesRegex(String path) {
    assertFalse(FilterResourcesStep.NON_ENGLISH_STRINGS_FILE_PATH.matcher(path).matches());
  }

  private static Predicate<Path> getTestPathPredicate(
      boolean enableStringWhitelisting,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales) throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
 ImmutableBiMap.<Path, Path>of(),
 false,
 enableStringWhitelisting,
 whitelistedStringDirs,
 locales,
        copier,
 null,
 null,
 null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));

    EasyMock.verify(copier);

    return capturedPredicate.getValue();
  }
}

<code block>


package com.facebook.buck.maven;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.eclipse.aether.repository.RepositoryPolicy.CHECKSUM_POLICY_FAIL;
import static org.eclipse.aether.util.artifact.JavaScopes.TEST;

import com.facebook.buck.graph.MutableDirectedGraph;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.io.Resources;

import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositoryException;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyFilter;
import org.eclipse.aether.impl.DefaultServiceLocator;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.repository.RepositoryPolicy;
import org.eclipse.aether.resolution.ArtifactDescriptorException;
import org.eclipse.aether.resolution.ArtifactDescriptorRequest;
import org.eclipse.aether.resolution.ArtifactDescriptorResult;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResolutionException;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
import org.eclipse.aether.spi.connector.transport.TransporterFactory;
import org.eclipse.aether.spi.locator.ServiceLocator;
import org.eclipse.aether.transport.http.HttpTransporterFactory;
import org.eclipse.aether.util.artifact.JavaScopes;
import org.eclipse.aether.util.artifact.SubArtifact;
import org.eclipse.aether.util.filter.DependencyFilterUtils;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroupString;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

public class Resolver {

  private static final String TEMPLATE =
      Resolver.class.getPackage().getName().replace(".", "/") + "/build-file.st";

  private final Path buckRepoRoot;
  private final Path buckThirdPartyRelativePath;
  private final LocalRepository localRepo;
  private final ImmutableList<RemoteRepository> repos;
  private final ServiceLocator locator;

  public Resolver(
      Path buckRepoRoot,
      Path relativeThirdParty,
      Path localRepoPath,
      String... repoUrls) {
    this.buckRepoRoot = buckRepoRoot;
    this.buckThirdPartyRelativePath = relativeThirdParty;
    this.localRepo = new LocalRepository(localRepoPath.toFile());

    ImmutableList.Builder<RemoteRepository> builder = ImmutableList.builder();
    for (int i = 0; i < repoUrls.length; i++) {
      RemoteRepository.Builder remote =
          new RemoteRepository.Builder("remote " + i, "default", repoUrls[i])
              .setPolicy(new RepositoryPolicy(true, null, CHECKSUM_POLICY_FAIL));
      builder.add(remote.build());
    }
    this.repos = builder.build();

    DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
    locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
    locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
    this.locator = locator;
  }

  public void resolve(String... mavenCoords) throws RepositoryException, IOException {
    RepositorySystem repoSys = locator.getService(RepositorySystem.class);
    RepositorySystemSession session = newSession(repoSys);

    ImmutableMap<String, Artifact> knownDeps = getRunTimeTransitiveDeps(
        repoSys,
        session,
        mavenCoords);




    MutableDirectedGraph<Artifact> graph = buildDependencyGraph(repoSys, session, knownDeps);




    Map<Path, SortedSet<Prebuilt>> buckFiles = new HashMap<>();

    for (Artifact root : graph.getNodes()) {
      int index = root.getGroupId().lastIndexOf('.');
      String projectName = root.getGroupId();
      if (index != -1) {
        projectName = projectName.substring(index + 1);
      }
      Path project = buckRepoRoot.resolve(buckThirdPartyRelativePath).resolve(projectName);
      Files.createDirectories(project);

      SortedSet<Prebuilt> libs = buckFiles.get(project);
      if (libs == null) {
        libs = new TreeSet<>();
        buckFiles.put(project, libs);
      }

      Artifact jar = new DefaultArtifact(
          root.getGroupId(),
          root.getArtifactId(),
          "jar",
          root.getVersion());
      Artifact srcs = new SubArtifact(jar, "sources", "jar");

      ArtifactResult result = repoSys.resolveArtifact(
          session,
          new ArtifactRequest(jar, repos, null));
      Path relativePath = copy(result, project);

      Prebuilt library = new Prebuilt(jar.getArtifactId(), relativePath);
      libs.add(library);

      try {
        result = repoSys.resolveArtifact(session, new ArtifactRequest(srcs, repos, null));
        relativePath = copy(result, project);
        library.setSourceJar(relativePath);
      } catch (ArtifactResolutionException e) {
        System.err.println("Skipping sources for: " + srcs);
      }

      Iterable<Artifact> incoming = graph.getIncomingNodesFor(root);
      for (Artifact artifact : incoming) {
        index = artifact.getGroupId().lastIndexOf('.');
        String groupName = artifact.getGroupId();
        if (index != -1) {
          groupName = groupName.substring(index + 1);
        }
        if (projectName.equals(groupName)) {
          library.addDep(String.format(":%s", artifact.getArtifactId()));
        } else {
          library.addDep(
              String.format(
                  "//%s/%s:%s",
                  buckThirdPartyRelativePath,
                  groupName,
                  artifact.getArtifactId()));
        }
      }

      Iterable<Artifact> outgoing = graph.getOutgoingNodesFor(root);
      for (Artifact artifact : outgoing) {
        index = artifact.getGroupId().lastIndexOf('.');
        String groupName = artifact.getGroupId();
        if (index != -1) {
          groupName = groupName.substring(index + 1);
        }
        if (!groupName.equals(projectName)) {
          library.addVisibility(
              String.format(
                  "//%s/%s:%s",
                  buckThirdPartyRelativePath,
                  groupName,
                  artifact.getArtifactId()));
        }
      }
    }

    URL templateUrl = Resources.getResource(TEMPLATE);
    String template = Resources.toString(templateUrl, UTF_8);
    STGroupString groups = new STGroupString("prebuilt-template", template);

    for (Map.Entry<Path, SortedSet<Prebuilt>> entry : buckFiles.entrySet()) {
      Path buckFile = entry.getKey().resolve("BUCK");
      if (Files.exists(buckFile)) {
        Files.delete(buckFile);
      }

      ST st = Preconditions.checkNotNull(groups.getInstanceOf("/prebuilts"));
      st.add("data", entry.getValue());
      Files.write(buckFile, st.render().getBytes(UTF_8));
    }
  }

  private Path copy(ArtifactResult result, Path destDir) throws IOException {
    Path source = result.getArtifact().getFile().toPath();
    Path sink = destDir.resolve(source.getFileName());

    if (!Files.exists(sink)) {
      Files.copy(source, sink);
    }

    return sink.getFileName();
  }

  private  MutableDirectedGraph<Artifact> buildDependencyGraph(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Map<String, Artifact> knownDeps) throws ArtifactDescriptorException {
    MutableDirectedGraph<Artifact> graph;
    graph = new MutableDirectedGraph<>();
    for (Artifact dep : knownDeps.values()) {
      String key = buildKey(dep);

      Preconditions.checkNotNull(knownDeps.get(key));

      graph.addNode(dep);

      List<Dependency> dependencies = getDependenciesOf(repoSys, session, dep);

      for (Dependency dependency : dependencies) {
        if (dependency.getArtifact() == null) {
          System.out.println("Skipping because artifact missing: " + dependency);
          continue;
        }

        String depKey = buildKey(dependency.getArtifact());
        Artifact actualDep = knownDeps.get(depKey);
        if (actualDep == null) {
          continue;
        }

        if (isTestTime(dependency)) {
          continue;
        }






        Preconditions.checkNotNull(actualDep, key + " -> " + dep + " in " + knownDeps.keySet());
        graph.addNode(actualDep);
        graph.addEdge(actualDep, dep);
      }
    }
    return graph;
  }

  private List<Dependency> getDependenciesOf(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Artifact dep) throws ArtifactDescriptorException {
    ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
    descriptorRequest.setArtifact(dep);
    descriptorRequest.setRepositories(repos);
    descriptorRequest.setRequestContext(JavaScopes.RUNTIME);

    ArtifactDescriptorResult result = repoSys.readArtifactDescriptor(session, descriptorRequest);
    return result.getDependencies();
  }

  private boolean isTestTime(Dependency dependency) {
    return TEST.equals(dependency.getScope());
  }

  private ImmutableMap<String, Artifact> getRunTimeTransitiveDeps(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      String... mavenCoords)
      throws RepositoryException {

    CollectRequest collectRequest = new CollectRequest();
    collectRequest.setRequestContext(JavaScopes.RUNTIME);
    collectRequest.setRepositories(repos);

    for (String coord : mavenCoords) {
      DefaultArtifact artifact = new DefaultArtifact(coord);
      collectRequest.addDependency(new Dependency(artifact, JavaScopes.RUNTIME));

      ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
      descriptorRequest.setArtifact(artifact);


      descriptorRequest.setRepositories(repos);
      ArtifactDescriptorResult descriptorResult = repoSys.readArtifactDescriptor(
          session,
          descriptorRequest);

      for (Dependency dependency : descriptorResult.getDependencies()) {
        if (isTestTime(dependency)) {
          continue;
        }
        collectRequest.addDependency(dependency);
      }
      for (Dependency dependency : descriptorResult.getManagedDependencies()) {
        if (isTestTime(dependency)) {
          continue;
        }
        collectRequest.addManagedDependency(dependency);
      }
    }

    DependencyFilter filter = DependencyFilterUtils.classpathFilter(JavaScopes.RUNTIME);
    DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, filter);

    DependencyResult dependencyResult = repoSys.resolveDependencies(session, dependencyRequest);

    ImmutableSortedMap.Builder<String, Artifact> knownDeps = ImmutableSortedMap.naturalOrder();
    for (ArtifactResult artifactResult : dependencyResult.getArtifactResults()) {
      Artifact node = artifactResult.getArtifact();
      knownDeps.put(buildKey(node), node);
    }
    return knownDeps.build();
  }

  private RepositorySystemSession newSession(RepositorySystem repoSys) {
    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();

    session.setLocalRepositoryManager(repoSys.newLocalRepositoryManager(session, localRepo));
    session.setReadOnly();

    return session;
  }


  private String buildKey(Artifact artifact) {
    return artifact.getGroupId() +
        ':' + artifact.getArtifactId() +
        ':' + artifact.getExtension() +
        ':' + artifact.getClassifier();
  }

  public static void main(String[] args) throws RepositoryException, IOException {
    if (args.length < 5) {
      System.err.println("Usage: java -jar resolver.jar buck-repo third-party " +
              "maven-local-repo maven-url junit:junit:jar:4.12...");
      System.exit(1);
    }

    Path buckRepoRoot = Paths.get(args[0]);
    Path thirdParty = Paths.get(args[1]);
    Path m2 = Paths.get(args[2]);
    String mavenCentral = args[3];
    String[] coords = Arrays.copyOfRange(args, 4, args.length);

    new Resolver(
        buckRepoRoot,
        thirdParty,
        m2,
        mavenCentral)
        .resolve(coords);
  }

  private static class Prebuilt implements Comparable<Prebuilt> {

    private final String name;
    private final Path binaryJar;
    private Path sourceJar;
    private final SortedSet<String> deps = new TreeSet<>(new BuckDepComparator());
    private final SortedSet<String> visibilities = new TreeSet<>(new BuckDepComparator());

    public Prebuilt(String name, Path binaryJar) {
      this.name = name;
      this.binaryJar = binaryJar;
    }

    @SuppressWarnings("unused") 
    public String getName() {
      return name;
    }

    @SuppressWarnings("unused") 
    public Path getBinaryJar() {
      return binaryJar;
    }

    public void setSourceJar(Path sourceJar) {
      this.sourceJar = sourceJar;
    }

    @SuppressWarnings("unused") 
    public Path getSourceJar() {
      return sourceJar;
    }

    public void addDep(String dep) {
      this.deps.add(dep);
    }

    @SuppressWarnings("unused") 
    public SortedSet<String> getDeps() {
      return deps;
    }

    public void addVisibility(String dep) {
      this.visibilities.add(dep);
    }

    @SuppressWarnings("unused") 
    public SortedSet<String> getVisibility() {
      return visibilities;
    }

    @Override
    public int compareTo(Prebuilt that) {
      return this.name.compareTo(that.name);
    }
  }
}

<code block>


package com.facebook.buck.maven;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.file.ExplodingDownloader;
import com.facebook.buck.file.RemoteFileDescription;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.java.PrebuiltJarDescription;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.json.DefaultProjectBuildFileParserFactory;
import com.facebook.buck.json.ProjectBuildFileParser;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.python.PythonBuckConfig;
import com.facebook.buck.rules.Description;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.testutil.integration.HttpdForTests;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hashing;

import org.eclipse.jetty.server.handler.ContextHandler;
import org.eclipse.jetty.server.handler.ResourceHandler;
import org.eclipse.jetty.util.log.StdErrLog;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public class ResolverIntegrationTest {

  @Rule
  public TemporaryFolder temp = new TemporaryFolder();

  private static HttpdForTests httpd;
  private static ProjectBuildFileParser buildFileParser;
  private static Path repo;
  private Path buckRepoRoot;
  private Path thirdParty;
  private Path thirdPartyRelative;
  private Path localRepo;

  @BeforeClass
  public static void setUpFakeMavenRepo() throws Exception {
    repo = TestDataHelper.getTestDataDirectory(new ResolverIntegrationTest());

    if (!Files.exists(repo)) {
      repo = Paths.get("test/com/facebook/buck/maven/testdata");
    }

    httpd = new HttpdForTests();

    ResourceHandler resourceHandler = new ResourceHandler();
    resourceHandler.setDirectoriesListed(true);
    resourceHandler.setResourceBase(repo.toAbsolutePath().toString());

    ContextHandler contextHandler = new ContextHandler("/");
    contextHandler.setHandler(resourceHandler);
    contextHandler.setLogger(new StdErrLog());

    httpd.addHandler(contextHandler);
    httpd.start();
  }

  @AfterClass
  public static void shutDownHttpd() throws Exception {
    httpd.close();
  }

  @BeforeClass
  public static void createParser() {
    ProjectFilesystem filesystem = new FakeProjectFilesystem();
    FakeBuckConfig buckConfig = new FakeBuckConfig();
    ParserConfig parserConfig = new ParserConfig(buckConfig);
    PythonBuckConfig pythonBuckConfig = new PythonBuckConfig(
        buckConfig,
        new ExecutableFinder());

    ImmutableSet<Description<?>> descriptions = ImmutableSet.of(
        new RemoteFileDescription(new ExplodingDownloader()),
        new PrebuiltJarDescription());

    DefaultProjectBuildFileParserFactory parserFactory = new DefaultProjectBuildFileParserFactory(
        filesystem.getRootPath(),
        pythonBuckConfig.getPythonInterpreter(),
        parserConfig.getAllowEmptyGlobs(),
        parserConfig.getBuildFileName(),
        parserConfig.getDefaultIncludes(),
        descriptions);
    buildFileParser = parserFactory.createParser(
        new TestConsole(),
        ImmutableMap.<String, String>of(),
        BuckEventBusFactory.newInstance());
  }

  @AfterClass
  public static void closeParser() throws BuildFileParseException, InterruptedException {
    buildFileParser.close();
  }

  @Before
  public void setUpRepos() throws IOException {
    buckRepoRoot = temp.newFolder().toPath();
    thirdPartyRelative = Paths.get("third-party").resolve("java");
    thirdParty = buckRepoRoot.resolve(thirdPartyRelative);
    localRepo = temp.newFolder().toPath();
  }

  @Test
  public void shouldSetUpAPrivateLibraryIfGivenAMavenCoordWithoutDeps() throws Exception {
    Resolver resolver = new Resolver(
        buckRepoRoot,
        thirdPartyRelative,
        localRepo,
        httpd.getUri("/").toString());

    resolver.resolve("com.example:no-deps:jar:1.0");

    Path groupDir = thirdParty.resolve("example");
    assertTrue(Files.exists(groupDir));

    Path original = repo.resolve("com/example/no-deps/1.0/no-deps-1.0.jar");
    HashCode expected = MorePaths.asByteSource(original).hash(Hashing.sha1());
    Path jarFile = groupDir.resolve("no-deps-1.0.jar");
    HashCode seen = MorePaths.asByteSource(jarFile).hash(Hashing.sha1());
    assertEquals(expected, seen);

    List<Map<String, Object>> rules = buildFileParser.getAll(groupDir.resolve("BUCK"));

    assertEquals(1, rules.size());
    Map<String, Object> rule = rules.get(0);

    assertEquals("no-deps", rule.get("name"));


    assertEquals("no-deps-1.0.jar", rule.get("binaryJar"));


    assertTrue(rule.containsKey("sourceJar"));
    assertNull(rule.get("sourceJar"));


    assertEquals(ImmutableList.of(), rule.get("visibility"));


    assertEquals(ImmutableList.of(), rule.get("deps"));
  }

  @Test
  public void shouldIncludeSourceJarIfOneIsPresent() throws Exception {
    Resolver resolver = new Resolver(
        buckRepoRoot,
        thirdPartyRelative,
        localRepo,
        httpd.getUri("/").toString());

    resolver.resolve("com.example:with-sources:jar:1.0");

    Path groupDir = thirdParty.resolve("example");
    List<Map<String, Object>> rules = buildFileParser.getAll(groupDir.resolve("BUCK"));

    Map<String, Object> rule = rules.get(0);
    assertEquals("with-sources-1.0-sources.jar", rule.get("sourceJar"));
  }

  @Test
  public void shouldSetVisibilityOfTargetToGiveDependenciesAccess() throws Exception {
    Resolver resolver = new Resolver(
        buckRepoRoot,
        thirdPartyRelative,
        localRepo,
        httpd.getUri("/").toString());

    resolver.resolve("com.example:with-deps:jar:1.0");

    Path exampleDir = thirdPartyRelative.resolve("example");
    Map<String, Object> withDeps =
        buildFileParser.getAll(buckRepoRoot.resolve(exampleDir).resolve("BUCK")).get(0);
    Path otherDir = thirdPartyRelative.resolve("othercorp");
    Map<String, Object> noDeps =
        buildFileParser.getAll(buckRepoRoot.resolve(otherDir).resolve("BUCK")).get(0);

    @SuppressWarnings("unchecked")
    List<String> visibility = (List<String>) noDeps.get("visibility");
    assertEquals(1, visibility.size());
    assertEquals(ImmutableList.of(String.format("//%s:with-deps", exampleDir)), visibility);
    assertEquals(ImmutableList.of(), noDeps.get("deps"));

    assertEquals(ImmutableList.of(), withDeps.get("visibility"));
    @SuppressWarnings("unchecked")
    List<String> deps = (List<String>) withDeps.get("deps");
    assertEquals(1, deps.size());
    assertEquals(ImmutableList.of(String.format("//%s:no-deps", otherDir)), deps);
  }

  @Test
  public void shouldOmitTargetsInTheSameBuildFileInVisibilityArguments() throws Exception {
    Resolver resolver = new Resolver(
        buckRepoRoot,
        thirdPartyRelative,
        localRepo,
        httpd.getUri("/").toString());

    resolver.resolve("com.example:deps-in-same-project:jar:1.0");

    Path exampleDir = thirdPartyRelative.resolve("example");
    List<Map<String, Object>> allTargets = buildFileParser.getAll(
        buckRepoRoot.resolve(exampleDir).resolve(
            "BUCK"));

    assertEquals(2, allTargets.size());

    Map<String, Object> noDeps = null;
    for (Map<String, Object> target : allTargets) {
      if ("no-deps".equals(target.get("name"))) {
        noDeps = target;
        break;
      }
    }
    assertNotNull(noDeps);



    assertEquals(0, ((Collection<?>) noDeps.get("visibility")).size());
  }
}

<code block>


package com.facebook.buck.maven;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.eclipse.aether.repository.RepositoryPolicy.CHECKSUM_POLICY_FAIL;
import static org.eclipse.aether.util.artifact.JavaScopes.TEST;

import com.facebook.buck.graph.MutableDirectedGraph;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.io.Resources;

import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositoryException;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyFilter;
import org.eclipse.aether.impl.DefaultServiceLocator;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.repository.RepositoryPolicy;
import org.eclipse.aether.resolution.ArtifactDescriptorException;
import org.eclipse.aether.resolution.ArtifactDescriptorRequest;
import org.eclipse.aether.resolution.ArtifactDescriptorResult;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResolutionException;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
import org.eclipse.aether.spi.connector.transport.TransporterFactory;
import org.eclipse.aether.spi.locator.ServiceLocator;
import org.eclipse.aether.transport.http.HttpTransporterFactory;
import org.eclipse.aether.util.artifact.JavaScopes;
import org.eclipse.aether.util.artifact.SubArtifact;
import org.eclipse.aether.util.filter.DependencyFilterUtils;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroupString;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

public class Resolver {

  private static final String TEMPLATE =
      Resolver.class.getPackage().getName().replace(".", "/") + "/build-file.st";

  private final Path buckRepoRoot;
  private final Path buckThirdPartyRelativePath;
  private final LocalRepository localRepo;
  private final ImmutableList<RemoteRepository> repos;
  private final ServiceLocator locator;

  public Resolver(
      Path buckRepoRoot,
      Path relativeThirdParty,
      Path localRepoPath,
      String... repoUrls) {
    this.buckRepoRoot = buckRepoRoot;
    this.buckThirdPartyRelativePath = relativeThirdParty;
    this.localRepo = new LocalRepository(localRepoPath.toFile());

    ImmutableList.Builder<RemoteRepository> builder = ImmutableList.builder();
    for (int i = 0; i < repoUrls.length; i++) {
      RemoteRepository.Builder remote =
          new RemoteRepository.Builder("remote " + i, "default", repoUrls[i])
              .setPolicy(new RepositoryPolicy(true, null, CHECKSUM_POLICY_FAIL));
      builder.add(remote.build());
    }
    this.repos = builder.build();

    DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
    locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
    locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
    this.locator = locator;
  }

  public void resolve(String... mavenCoords) throws RepositoryException, IOException {
    RepositorySystem repoSys = locator.getService(RepositorySystem.class);
    RepositorySystemSession session = newSession(repoSys);

    ImmutableMap<String, Artifact> knownDeps = getRunTimeTransitiveDeps(
        repoSys,
        session,
        mavenCoords);




    MutableDirectedGraph<Artifact> graph = buildDependencyGraph(repoSys, session, knownDeps);




    Map<Path, SortedSet<Prebuilt>> buckFiles = new HashMap<>();

    for (Artifact artifact : graph.getNodes()) {
      downloadArtifact(artifact, repoSys, session, buckFiles, graph);
    }

    createBuckFiles(buckFiles);
  }

  private void downloadArtifact(
      final Artifact artifactToDownload,
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Map<Path, SortedSet<Prebuilt>> buckFiles,
      MutableDirectedGraph<Artifact> graph)
      throws IOException, ArtifactResolutionException {
    String projectName = getProjectName(artifactToDownload);
    Path project = buckRepoRoot.resolve(buckThirdPartyRelativePath).resolve(projectName);
    Files.createDirectories(project);

    SortedSet<Prebuilt> libs = buckFiles.get(project);
    if (libs == null) {
      libs = new TreeSet<>();
      buckFiles.put(project, libs);
    }

    Prebuilt library = resolveLib(artifactToDownload, repoSys, session, project);
    libs.add(library);


    Iterable<Artifact> incoming = graph.getIncomingNodesFor(artifactToDownload);
    for (Artifact artifact : incoming) {
      String groupName = getProjectName(artifact);
      if (projectName.equals(groupName)) {
        library.addDep(String.format(":%s", artifact.getArtifactId()));
      } else {
        library.addDep(buckThirdPartyRelativePath, artifact);
      }
    }


    Iterable<Artifact> outgoing = graph.getOutgoingNodesFor(artifactToDownload);
    for (Artifact artifact : outgoing) {
      String groupName = getProjectName(artifact);
      if (!groupName.equals(projectName)) {
        library.addVisibility(buckThirdPartyRelativePath, artifact);
      }
    }
  }

  private Prebuilt resolveLib(
      Artifact artifact,
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Path project) throws ArtifactResolutionException, IOException {
    Artifact jar = new DefaultArtifact(
        artifact.getGroupId(),
        artifact.getArtifactId(),
        "jar",
        artifact.getVersion());

    Path relativePath = resolveArtifact(jar, repoSys, session, project);

    Prebuilt library = new Prebuilt(jar.getArtifactId(), relativePath);

    downloadSources(jar, repoSys, session, project, library);
    return library;
  }


  private Path resolveArtifact(
      Artifact artifact,
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Path project)
      throws ArtifactResolutionException, IOException {
    ArtifactResult result = repoSys.resolveArtifact(
        session,
        new ArtifactRequest(artifact, repos, null));
    return copy(result, project);
  }

  private void downloadSources(
      Artifact artifact,
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Path project,
      Prebuilt library) throws IOException {
    Artifact srcs = new SubArtifact(artifact, "sources", "jar");
    try {
      Path relativePath = resolveArtifact(srcs, repoSys, session, project);
      library.setSourceJar(relativePath);
    } catch (ArtifactResolutionException e) {
      System.err.println("Skipping sources for: " + srcs);
    }
  }


  private static String getProjectName(Artifact artifact) {
    int index = artifact.getGroupId().lastIndexOf('.');
    String projectName = artifact.getGroupId();
    if (index != -1) {
      projectName = projectName.substring(index + 1);
    }
    return projectName;
  }

  private void createBuckFiles(Map<Path, SortedSet<Prebuilt>> buckFilesData) throws IOException {
    URL templateUrl = Resources.getResource(TEMPLATE);
    String template = Resources.toString(templateUrl, UTF_8);
    STGroupString groups = new STGroupString("prebuilt-template", template);

    for (Map.Entry<Path, SortedSet<Prebuilt>> entry : buckFilesData.entrySet()) {
      Path buckFile = entry.getKey().resolve("BUCK");
      if (Files.exists(buckFile)) {
        Files.delete(buckFile);
      }

      ST st = Preconditions.checkNotNull(groups.getInstanceOf("/prebuilts"));
      st.add("data", entry.getValue());
      Files.write(buckFile, st.render().getBytes(UTF_8));
    }
  }

  private Path copy(ArtifactResult result, Path destDir) throws IOException {
    Path source = result.getArtifact().getFile().toPath();
    Path sink = destDir.resolve(source.getFileName());

    if (!Files.exists(sink)) {
      Files.copy(source, sink);
    }

    return sink.getFileName();
  }

  private  MutableDirectedGraph<Artifact> buildDependencyGraph(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Map<String, Artifact> knownDeps) throws ArtifactDescriptorException {
    MutableDirectedGraph<Artifact> graph;
    graph = new MutableDirectedGraph<>();
    for (Artifact dep : knownDeps.values()) {
      String key = buildKey(dep);

      Preconditions.checkNotNull(knownDeps.get(key));

      graph.addNode(dep);

      List<Dependency> dependencies = getDependenciesOf(repoSys, session, dep);

      for (Dependency dependency : dependencies) {
        if (dependency.getArtifact() == null) {
          System.out.println("Skipping because artifact missing: " + dependency);
          continue;
        }

        String depKey = buildKey(dependency.getArtifact());
        Artifact actualDep = knownDeps.get(depKey);
        if (actualDep == null) {
          continue;
        }

        if (isTestTime(dependency)) {
          continue;
        }






        Preconditions.checkNotNull(actualDep, key + " -> " + dep + " in " + knownDeps.keySet());
        graph.addNode(actualDep);
        graph.addEdge(actualDep, dep);
      }
    }
    return graph;
  }

  private List<Dependency> getDependenciesOf(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      Artifact dep) throws ArtifactDescriptorException {
    ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
    descriptorRequest.setArtifact(dep);
    descriptorRequest.setRepositories(repos);
    descriptorRequest.setRequestContext(JavaScopes.RUNTIME);

    ArtifactDescriptorResult result = repoSys.readArtifactDescriptor(session, descriptorRequest);
    return result.getDependencies();
  }

  private boolean isTestTime(Dependency dependency) {
    return TEST.equals(dependency.getScope());
  }

  private ImmutableMap<String, Artifact> getRunTimeTransitiveDeps(
      RepositorySystem repoSys,
      RepositorySystemSession session,
      String... mavenCoords)
      throws RepositoryException {

    CollectRequest collectRequest = new CollectRequest();
    collectRequest.setRequestContext(JavaScopes.RUNTIME);
    collectRequest.setRepositories(repos);

    for (String coord : mavenCoords) {
      DefaultArtifact artifact = new DefaultArtifact(coord);
      collectRequest.addDependency(new Dependency(artifact, JavaScopes.RUNTIME));

      ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();
      descriptorRequest.setArtifact(artifact);


      descriptorRequest.setRepositories(repos);
      ArtifactDescriptorResult descriptorResult = repoSys.readArtifactDescriptor(
          session,
          descriptorRequest);

      for (Dependency dependency : descriptorResult.getDependencies()) {
        if (isTestTime(dependency)) {
          continue;
        }
        collectRequest.addDependency(dependency);
      }
      for (Dependency dependency : descriptorResult.getManagedDependencies()) {
        if (isTestTime(dependency)) {
          continue;
        }
        collectRequest.addManagedDependency(dependency);
      }
    }

    DependencyFilter filter = DependencyFilterUtils.classpathFilter(JavaScopes.RUNTIME);
    DependencyRequest dependencyRequest = new DependencyRequest(collectRequest, filter);

    DependencyResult dependencyResult = repoSys.resolveDependencies(session, dependencyRequest);

    ImmutableSortedMap.Builder<String, Artifact> knownDeps = ImmutableSortedMap.naturalOrder();
    for (ArtifactResult artifactResult : dependencyResult.getArtifactResults()) {
      Artifact node = artifactResult.getArtifact();
      knownDeps.put(buildKey(node), node);
    }
    return knownDeps.build();
  }

  private RepositorySystemSession newSession(RepositorySystem repoSys) {
    DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();

    session.setLocalRepositoryManager(repoSys.newLocalRepositoryManager(session, localRepo));
    session.setReadOnly();

    return session;
  }


  private String buildKey(Artifact artifact) {
    return artifact.getGroupId() +
        ':' + artifact.getArtifactId() +
        ':' + artifact.getExtension() +
        ':' + artifact.getClassifier();
  }

  public static void main(String[] args) throws RepositoryException, IOException {
    if (args.length < 5) {
      System.err.println("Usage: java -jar resolver.jar buck-repo third-party " +
              "maven-local-repo maven-url junit:junit:jar:4.12...");
      System.exit(1);
    }

    Path buckRepoRoot = Paths.get(args[0]);
    Path thirdParty = Paths.get(args[1]);
    Path m2 = Paths.get(args[2]);
    String mavenCentral = args[3];
    String[] coords = Arrays.copyOfRange(args, 4, args.length);

    new Resolver(
        buckRepoRoot,
        thirdParty,
        m2,
        mavenCentral)
        .resolve(coords);
  }


  private static class Prebuilt implements Comparable<Prebuilt> {

    private final String name;
    private final Path binaryJar;
    private Path sourceJar;
    private final SortedSet<String> deps = new TreeSet<>(new BuckDepComparator());
    private final SortedSet<String> visibilities = new TreeSet<>(new BuckDepComparator());

    public Prebuilt(String name, Path binaryJar) {
      this.name = name;
      this.binaryJar = binaryJar;
    }

    @SuppressWarnings("unused") 
    public String getName() {
      return name;
    }

    @SuppressWarnings("unused") 
    public Path getBinaryJar() {
      return binaryJar;
    }

    public void setSourceJar(Path sourceJar) {
      this.sourceJar = sourceJar;
    }

    @SuppressWarnings("unused") 
    public Path getSourceJar() {
      return sourceJar;
    }

    public void addDep(String dep) {
      this.deps.add(dep);
    }

    public void addDep(Path buckThirdPartyRelativePath, Artifact artifact) {
      this.addDep(formatDep(buckThirdPartyRelativePath, artifact));
    }

    @SuppressWarnings("unused") 
    public SortedSet<String> getDeps() {
      return deps;
    }

    public void addVisibility(String dep) {
      this.visibilities.add(dep);
    }
    public void addVisibility(Path buckThirdPartyRelativePath, Artifact artifact) {
      this.addVisibility(formatDep(buckThirdPartyRelativePath, artifact));
    }

    private String formatDep(Path buckThirdPartyRelativePath, Artifact artifact) {
      return String.format(
          "//%s/%s:%s",
          buckThirdPartyRelativePath,
          getProjectName(artifact),
          artifact.getArtifactId());
    }

    @SuppressWarnings("unused") 
    public SortedSet<String> getVisibility() {
      return visibilities;
    }

    @Override
    public int compareTo(Prebuilt that) {
      return this.name.compareTo(that.name);
    }
  }
}

<code block>


package com.facebook.buck.maven;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.event.BuckEventBusFactory;
import com.facebook.buck.file.ExplodingDownloader;
import com.facebook.buck.file.RemoteFileDescription;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.java.PrebuiltJarDescription;
import com.facebook.buck.json.BuildFileParseException;
import com.facebook.buck.json.DefaultProjectBuildFileParserFactory;
import com.facebook.buck.json.ProjectBuildFileParser;
import com.facebook.buck.parser.ParserConfig;
import com.facebook.buck.python.PythonBuckConfig;
import com.facebook.buck.rules.Description;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TestConsole;
import com.facebook.buck.testutil.integration.HttpdForTests;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hashing;

import org.eclipse.jetty.server.handler.ContextHandler;
import org.eclipse.jetty.server.handler.ResourceHandler;
import org.eclipse.jetty.util.log.StdErrLog;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public class ResolverIntegrationTest {

  @Rule
  public TemporaryFolder temp = new TemporaryFolder();

  private static HttpdForTests httpd;
  private static ProjectBuildFileParser buildFileParser;
  private static Path repo;
  private Path buckRepoRoot;
  private Path thirdParty;
  private Path thirdPartyRelative;
  private Path localRepo;
  private Resolver resolver;

  @BeforeClass
  public static void setUpFakeMavenRepo() throws Exception {
    repo = TestDataHelper.getTestDataDirectory(new ResolverIntegrationTest());

    if (!Files.exists(repo)) {
      repo = Paths.get("test/com/facebook/buck/maven/testdata");
    }

    httpd = new HttpdForTests();

    ResourceHandler resourceHandler = new ResourceHandler();
    resourceHandler.setDirectoriesListed(true);
    resourceHandler.setResourceBase(repo.toAbsolutePath().toString());

    ContextHandler contextHandler = new ContextHandler("/");
    contextHandler.setHandler(resourceHandler);
    contextHandler.setLogger(new StdErrLog());

    httpd.addHandler(contextHandler);
    httpd.start();
  }

  @AfterClass
  public static void shutDownHttpd() throws Exception {
    httpd.close();
  }

  @BeforeClass
  public static void createParser() {
    ProjectFilesystem filesystem = new FakeProjectFilesystem();
    FakeBuckConfig buckConfig = new FakeBuckConfig();
    ParserConfig parserConfig = new ParserConfig(buckConfig);
    PythonBuckConfig pythonBuckConfig = new PythonBuckConfig(
        buckConfig,
        new ExecutableFinder());

    ImmutableSet<Description<?>> descriptions = ImmutableSet.of(
        new RemoteFileDescription(new ExplodingDownloader()),
        new PrebuiltJarDescription());

    DefaultProjectBuildFileParserFactory parserFactory = new DefaultProjectBuildFileParserFactory(
        filesystem.getRootPath(),
        pythonBuckConfig.getPythonInterpreter(),
        parserConfig.getAllowEmptyGlobs(),
        parserConfig.getBuildFileName(),
        parserConfig.getDefaultIncludes(),
        descriptions);
    buildFileParser = parserFactory.createParser(
        new TestConsole(),
        ImmutableMap.<String, String>of(),
        BuckEventBusFactory.newInstance());
  }

  @AfterClass
  public static void closeParser() throws BuildFileParseException, InterruptedException {
    buildFileParser.close();
  }

  @Before
  public void setUpRepos() throws Exception {
    buckRepoRoot = temp.newFolder().toPath();
    thirdPartyRelative = Paths.get("third-party").resolve("java");
    thirdParty = buckRepoRoot.resolve(thirdPartyRelative);
    localRepo = temp.newFolder().toPath();
    resolver = new Resolver(
        buckRepoRoot,
        thirdPartyRelative,
        localRepo,
        httpd.getUri("/").toString());
  }

  @Test
  public void shouldSetUpAPrivateLibraryIfGivenAMavenCoordWithoutDeps() throws Exception {
    resolver.resolve("com.example:no-deps:jar:1.0");

    Path groupDir = thirdParty.resolve("example");
    assertTrue(Files.exists(groupDir));

    Path original = repo.resolve("com/example/no-deps/1.0/no-deps-1.0.jar");
    HashCode expected = MorePaths.asByteSource(original).hash(Hashing.sha1());
    Path jarFile = groupDir.resolve("no-deps-1.0.jar");
    HashCode seen = MorePaths.asByteSource(jarFile).hash(Hashing.sha1());
    assertEquals(expected, seen);

    List<Map<String, Object>> rules = buildFileParser.getAll(groupDir.resolve("BUCK"));

    assertEquals(1, rules.size());
    Map<String, Object> rule = rules.get(0);

    assertEquals("no-deps", rule.get("name"));


    assertEquals("no-deps-1.0.jar", rule.get("binaryJar"));


    assertTrue(rule.containsKey("sourceJar"));
    assertNull(rule.get("sourceJar"));


    assertEquals(ImmutableList.of(), rule.get("visibility"));


    assertEquals(ImmutableList.of(), rule.get("deps"));
  }

  @Test
  public void shouldIncludeSourceJarIfOneIsPresent() throws Exception {
    resolver.resolve("com.example:with-sources:jar:1.0");

    Path groupDir = thirdParty.resolve("example");
    List<Map<String, Object>> rules = buildFileParser.getAll(groupDir.resolve("BUCK"));

    Map<String, Object> rule = rules.get(0);
    assertEquals("with-sources-1.0-sources.jar", rule.get("sourceJar"));
  }

  @Test
  public void shouldSetVisibilityOfTargetToGiveDependenciesAccess() throws Exception {
    resolver.resolve("com.example:with-deps:jar:1.0");

    Path exampleDir = thirdPartyRelative.resolve("example");
    Map<String, Object> withDeps =
        buildFileParser.getAll(buckRepoRoot.resolve(exampleDir).resolve("BUCK")).get(0);
    Path otherDir = thirdPartyRelative.resolve("othercorp");
    Map<String, Object> noDeps =
        buildFileParser.getAll(buckRepoRoot.resolve(otherDir).resolve("BUCK")).get(0);

    @SuppressWarnings("unchecked")
    List<String> visibility = (List<String>) noDeps.get("visibility");
    assertEquals(1, visibility.size());
    assertEquals(ImmutableList.of(String.format("//%s:with-deps", exampleDir)), visibility);
    assertEquals(ImmutableList.of(), noDeps.get("deps"));

    assertEquals(ImmutableList.of(), withDeps.get("visibility"));
    @SuppressWarnings("unchecked")
    List<String> deps = (List<String>) withDeps.get("deps");
    assertEquals(1, deps.size());
    assertEquals(ImmutableList.of(String.format("//%s:no-deps", otherDir)), deps);
  }

  @Test
  public void shouldOmitTargetsInTheSameBuildFileInVisibilityArguments() throws Exception {
    resolver.resolve("com.example:deps-in-same-project:jar:1.0");

    Path exampleDir = thirdPartyRelative.resolve("example");
    List<Map<String, Object>> allTargets = buildFileParser.getAll(
        buckRepoRoot.resolve(exampleDir).resolve(
            "BUCK"));

    assertEquals(2, allTargets.size());

    Map<String, Object> noDeps = null;
    for (Map<String, Object> target : allTargets) {
      if ("no-deps".equals(target.get("name"))) {
        noDeps = target;
        break;
      }
    }
    assertNotNull(noDeps);



    assertEquals(0, ((Collection<?>) noDeps.get("visibility")).size());
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.facebook.buck.log.Logger;
import com.facebook.buck.util.VersionStringComparator;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.collect.TreeMultimap;

import java.io.BufferedInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;


public class AppleSdkDiscovery {

  private static final Logger LOG = Logger.get(AppleSdkDiscovery.class);

  private static final Ordering<AppleSdk> APPLE_SDK_VERSION_ORDERING =
    Ordering
        .from(new VersionStringComparator())
        .onResultOf(new Function<AppleSdk, String>() {
            @Override
            public String apply(AppleSdk appleSdk) {
                return appleSdk.getVersion();
            }
        });

  private static final String DEFAULT_TOOLCHAIN_ID = "com.apple.dt.toolchain.XcodeDefault";


  private AppleSdkDiscovery() { }


  public static ImmutableMap<AppleSdk, AppleSdkPaths> discoverAppleSdkPaths(
      Optional<Path> developerDir,
      ImmutableList<Path> extraDirs,
      ImmutableMap<String, AppleToolchain> xcodeToolchains)
      throws IOException {
    Optional<AppleToolchain> defaultToolchain =
        Optional.fromNullable(xcodeToolchains.get(DEFAULT_TOOLCHAIN_ID));

    ImmutableMap.Builder<AppleSdk, AppleSdkPaths> appleSdkPathsBuilder = ImmutableMap.builder();

    Iterable<Path> platformPaths = extraDirs;
    if (developerDir.isPresent()) {
      Path platformsDir = developerDir.get().resolve("Platforms");
      LOG.debug("Searching for Xcode platforms under %s", platformsDir);
      platformPaths = Iterables.concat(
        ImmutableSet.of(platformsDir), platformPaths);
    }







    TreeMultimap<ApplePlatform, AppleSdk> orderedSdksForPlatform =
        TreeMultimap.create(
            Ordering.natural(),
            APPLE_SDK_VERSION_ORDERING);

    for (Path platforms : platformPaths) {
      if (!Files.exists(platforms)) {
        LOG.debug("Skipping platform search path %s that does not exist", platforms);
        continue;
      }
      LOG.debug("Searching for Xcode SDKs in %s", platforms);

      try (DirectoryStream<Path> platformStream = Files.newDirectoryStream(
          platforms,
               "*.platform")) {
        for (Path platformDir : platformStream) {
          Path developerSdksPath = platformDir.resolve("Developer/SDKs");
          try (DirectoryStream<Path> sdkStream = Files.newDirectoryStream(
                   developerSdksPath,
                   "*.sdk")) {
            for (Path sdkDir : sdkStream) {
              LOG.debug("Fetching SDK name for %s", sdkDir);
              if (Files.isSymbolicLink(sdkDir)) {
                continue;
              }

              AppleSdk.Builder sdkBuilder = AppleSdk.builder();
              if (buildSdkFromPath(sdkDir, sdkBuilder, xcodeToolchains, defaultToolchain)) {
                AppleSdk sdk = sdkBuilder.build();
                LOG.debug("Found SDK %s", sdk);

                AppleSdkPaths.Builder xcodePathsBuilder = AppleSdkPaths.builder();
                for (AppleToolchain toolchain : sdk.getToolchains()) {
                  xcodePathsBuilder.addToolchainPaths(toolchain.getPath());
                }
                AppleSdkPaths xcodePaths = xcodePathsBuilder
                    .setDeveloperPath(developerDir)
                    .setPlatformPath(platformDir)
                    .setSdkPath(sdkDir)
                    .build();
                appleSdkPathsBuilder.put(sdk, xcodePaths);
                orderedSdksForPlatform.put(sdk.getApplePlatform(), sdk);
              }
            }
          } catch (NoSuchFileException e) {
            LOG.warn(
                e,
                "Couldn't discover SDKs at path %s, ignoring platform %s",
                developerSdksPath,
                platformDir);
          }
        }
      }
    }




    ImmutableMap<AppleSdk, AppleSdkPaths> discoveredSdkPaths = appleSdkPathsBuilder.build();

    for (ApplePlatform platform : orderedSdksForPlatform.keySet()) {
      AppleSdk mostRecentSdkForPlatform = orderedSdksForPlatform.get(platform).last();
      if (!mostRecentSdkForPlatform.getName().equals(platform.getName())) {
        appleSdkPathsBuilder.put(
            mostRecentSdkForPlatform.withName(platform.getName()),
            discoveredSdkPaths.get(mostRecentSdkForPlatform));
      }
    }



    return appleSdkPathsBuilder.build();
  }

  private static void addArchitecturesForPlatform(
      AppleSdk.Builder sdkBuilder,
      ApplePlatform applePlatform) {

    switch (applePlatform.getName()) {
      case ApplePlatform.Name.MACOSX:

      case ApplePlatform.Name.IPHONESIMULATOR:
        sdkBuilder.addArchitectures("i386", "x86_64");
        break;
      case ApplePlatform.Name.IPHONEOS:
        sdkBuilder.addArchitectures("armv7", "arm64");
        break;
      default:
        sdkBuilder.addArchitectures("armv7", "arm64", "i386", "x86_64");
        break;
    }
  }

  private static boolean buildSdkFromPath(
        Path sdkDir,
        AppleSdk.Builder sdkBuilder,
        ImmutableMap<String, AppleToolchain> xcodeToolchains,
        Optional<AppleToolchain> defaultToolchain) throws IOException {
    try (InputStream sdkSettingsPlist = Files.newInputStream(sdkDir.resolve("SDKSettings.plist"));
         BufferedInputStream bufferedSdkSettingsPlist = new BufferedInputStream(sdkSettingsPlist)) {
      NSDictionary sdkSettings;
      try {
        sdkSettings = (NSDictionary) PropertyListParser.parse(bufferedSdkSettingsPlist);
      } catch (Exception e) {
        throw new IOException(e);
      }
      String name = sdkSettings.objectForKey("CanonicalName").toString();
      String version = sdkSettings.objectForKey("Version").toString();
      NSDictionary defaultProperties = (NSDictionary) sdkSettings.objectForKey("DefaultProperties");

      boolean foundToolchain = false;
      NSArray toolchains = (NSArray) sdkSettings.objectForKey("Toolchains");
      if (toolchains != null) {
        for (NSObject toolchainIdObject : toolchains.getArray()) {
          String toolchainId = toolchainIdObject.toString();
          AppleToolchain toolchain = xcodeToolchains.get(toolchainId);
          if (toolchain != null) {
            foundToolchain = true;
            sdkBuilder.addToolchains(toolchain);
          } else {
            LOG.debug("Specified toolchain %s not found for SDK path %s", toolchainId, sdkDir);
          }
        }
      }
      if (!foundToolchain && defaultToolchain.isPresent()) {
        foundToolchain = true;
        sdkBuilder.addToolchains(defaultToolchain.get());
      }
      if (!foundToolchain) {
        LOG.warn("No toolchains found and no default toolchain. Skipping SDK path %s.", sdkDir);
        return false;
      } else {
        NSString platformName = (NSString) defaultProperties.objectForKey("PLATFORM_NAME");
        ApplePlatform applePlatform =
            ApplePlatform.builder().setName(platformName.toString()).build();
        sdkBuilder.setName(name).setVersion(version).setApplePlatform(applePlatform);
        addArchitecturesForPlatform(sdkBuilder, applePlatform);
        return true;
      }
    } catch (FileNotFoundException e) {
      LOG.error(e, "No SDKSettings.plist found under SDK path %s", sdkDir);
      return false;
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractApplePlatform implements Comparable<AbstractApplePlatform> {
  class Name {
    public static final String IPHONEOS = "iphoneos";
    public static final String IPHONESIMULATOR = "iphonesimulator";
    public static final String MACOSX = "macosx";

    private Name() { }
  }


  public abstract String getName();

  @Override
  public int compareTo(AbstractApplePlatform other) {
    return getName().compareTo(other.getName());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.BsdArchiver;
import com.facebook.buck.cxx.ClangCompiler;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.DarwinLinker;
import com.facebook.buck.cxx.DebugPathSanitizer;
import com.facebook.buck.cxx.VersionedTool;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;


public class AppleCxxPlatforms {


  private AppleCxxPlatforms() { }

  private static final Path USR_BIN = Paths.get("usr/bin");

  public static AppleCxxPlatform build(
      AppleSdk targetSdk,
      String minVersion,
      String targetArchitecture,
      AppleSdkPaths sdkPaths,
      BuckConfig buckConfig) {
    return buildWithExecutableChecker(
        targetSdk,
        minVersion,
        targetArchitecture,
        sdkPaths,
        buckConfig,
        new ExecutableFinder());
  }

  @VisibleForTesting
  static AppleCxxPlatform buildWithExecutableChecker(
      AppleSdk targetSdk,
      String minVersion,
      String targetArchitecture,
      AppleSdkPaths sdkPaths,
      BuckConfig buckConfig,
      ExecutableFinder executableFinder) {

    ImmutableList.Builder<Path> toolSearchPathsBuilder = ImmutableList.builder();

    toolSearchPathsBuilder
        .add(sdkPaths.getSdkPath().resolve(USR_BIN))
        .add(sdkPaths.getSdkPath().resolve("Developer").resolve(USR_BIN))
        .add(sdkPaths.getPlatformPath().resolve("Developer").resolve(USR_BIN));
    for (Path toolchainPath : sdkPaths.getToolchainPaths()) {
      toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
    }
    if (sdkPaths.getDeveloperPath().isPresent()) {
      toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
      toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve("Tools"));
    }
    ImmutableList<Path> toolSearchPaths = toolSearchPathsBuilder.build();


    ImmutableList.Builder<String> cflagsBuilder = ImmutableList.builder();
    cflagsBuilder.add("-isysroot", sdkPaths.getSdkPath().toString());
    cflagsBuilder.add("-arch", targetArchitecture);
    switch (targetSdk.getApplePlatform().getName()) {
      case ApplePlatform.Name.IPHONEOS:
        cflagsBuilder.add("-mios-version-min=" + minVersion);
        break;
      case ApplePlatform.Name.IPHONESIMULATOR:
        cflagsBuilder.add("-mios-simulator-version-min=" + minVersion);
        break;
      default:

        cflagsBuilder.add(
            "-m" + targetSdk.getApplePlatform().getName() + "-version-min=" + minVersion);
        break;
    }

    ImmutableList<String> ldflags = ImmutableList.of("-sdk_version", targetSdk.getVersion());
    ImmutableList<String> asflags = ImmutableList.of("-arch", targetArchitecture);

    ImmutableList.Builder<String> versionsBuilder = ImmutableList.builder();
    versionsBuilder.add(targetSdk.getVersion());
    for (AppleToolchain toolchain : targetSdk.getToolchains()) {
      versionsBuilder.add(toolchain.getVersion());
    }
    String version = Joiner.on(':').join(versionsBuilder.build());

    Tool clangPath = new VersionedTool(
        getToolPath("clang", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-clang",
        version);

    Tool clangXxPath = new VersionedTool(
        getToolPath("clang++", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-clang++",
        version);

    Tool ar = new VersionedTool(
        getToolPath("ar", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-ar",
        version);

    Tool strip = new VersionedTool(
        getToolPath("strip", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-strip",
        version);

    Tool actool = new VersionedTool(
        getToolPath("actool", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-actool",
        version);

    Tool ibtool = new VersionedTool(
        getToolPath("ibtool", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-ibtool",
        version);

    Tool xctest = new VersionedTool(
        getToolPath("xctest", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-xctest",
        version);

    Optional<Tool> otest = getOptionalTool(
        "otest",
        toolSearchPaths,
        executableFinder,
        version);

    Tool dsymutil = new VersionedTool(
        getToolPath("dsymutil", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-dsymutil",
        version);

    CxxBuckConfig config = new CxxBuckConfig(buckConfig);

    ImmutableFlavor targetFlavor = ImmutableFlavor.of(
        ImmutableFlavor.replaceInvalidCharacters(
            targetSdk.getName() + "-" + targetArchitecture));

    ImmutableBiMap.Builder<Path, Path> sanitizerPaths = ImmutableBiMap.builder();
    sanitizerPaths.put(sdkPaths.getSdkPath(), Paths.get("APPLE_SDKROOT"));
    sanitizerPaths.put(sdkPaths.getPlatformPath(), Paths.get("APPLE_PLATFORM_DIR"));
    if (sdkPaths.getDeveloperPath().isPresent()) {
      sanitizerPaths.put(sdkPaths.getDeveloperPath().get(), Paths.get("APPLE_DEVELOPER_DIR"));
    }

    DebugPathSanitizer debugPathSanitizer = new DebugPathSanitizer(
        250,
        File.separatorChar,
        Paths.get("."),
        sanitizerPaths.build());

    ImmutableList<String> cflags = cflagsBuilder.build();

    ImmutableMap.Builder<String, String> macrosBuilder = ImmutableMap.builder();
    macrosBuilder.put("SDKROOT", sdkPaths.getSdkPath().toString());
    macrosBuilder.put("PLATFORM_DIR", sdkPaths.getPlatformPath().toString());
    if (sdkPaths.getDeveloperPath().isPresent()) {
      macrosBuilder.put("DEVELOPER_DIR", sdkPaths.getDeveloperPath().get().toString());
    }
    ImmutableMap<String, String> macros = macrosBuilder.build();

    CxxPlatform cxxPlatform = CxxPlatforms.build(
        targetFlavor,
        config,
        clangPath,
        clangPath,
        new ClangCompiler(clangPath),
        new ClangCompiler(clangXxPath),
        clangPath,
        clangXxPath,
        new DarwinLinker(clangPath),
        new DarwinLinker(clangXxPath),
        ldflags,
        strip,
        new BsdArchiver(ar),
        asflags,
        ImmutableList.<String>of(),
        cflags,
        ImmutableList.<String>of(),
        getOptionalTool("lex", toolSearchPaths, executableFinder, version),
        getOptionalTool("yacc", toolSearchPaths, executableFinder, version),
        "dylib",
        Optional.of(debugPathSanitizer),
        macros);

    return AppleCxxPlatform.builder()
        .setCxxPlatform(cxxPlatform)
        .setAppleSdk(targetSdk)
        .setAppleSdkPaths(sdkPaths)
        .setActool(actool)
        .setIbtool(ibtool)
        .setXctest(xctest)
        .setOtest(otest)
        .setDsymutil(dsymutil)
        .build();
  }

  private static Optional<Tool> getOptionalTool(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder,
      String version) {
    return getOptionalToolPath(tool, toolSearchPaths, executableFinder)
        .transform(VersionedTool.fromPath(tool, version))
        .transform(Functions.<Tool>identity());
  }

  private static Path getToolPath(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder) {
    Optional<Path> result = getOptionalToolPath(tool, toolSearchPaths, executableFinder);
    if (!result.isPresent()) {
      throw new HumanReadableException("Cannot find tool %s in paths %s", tool, toolSearchPaths);
    }
    return result.get();
  }

    private static Optional<Path> getOptionalToolPath(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder) {

      return executableFinder.getOptionalExecutable(
          Paths.get(tool),
          toolSearchPaths,
          ImmutableSet.<String>of());
  }

}

<code block>


package com.facebook.buck.apple;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.environment.Platform;

import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class AppleLibraryIntegrationTest {

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  @Test
  public void testAppleLibraryBuildsSomething() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,default");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryBuildsSomethingUsingAppleCxxPlatform() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    assumeTrue(AppleNativeIntegrationTestUtils.isApplePlatformAvailable(
        ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build()));

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,macosx-x86_64");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryHeaderSymlinkTree() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_header_symlink_tree", tmp);
    workspace.setUp();

    BuildTarget buildTarget = BuildTarget.builder("//Libraries/TestLibrary", "TestLibrary")
        .addFlavors(ImmutableFlavor.of("default"))
        .addFlavors(ImmutableFlavor.of("header-symlink-tree"))
        .build();
    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        buildTarget.getFullyQualifiedName());
    result.assertSuccess();

    Path projectRoot = tmp.getRootPath().toRealPath();

    Path inputPath = projectRoot.resolve(
        buildTarget.getBasePath());
    Path outputPath = projectRoot.resolve(
        BuildTargets.getGenPath(buildTarget, "%s"));

    assertIsSymbolicLink(
        outputPath.resolve("PrivateHeader.h"),
        inputPath.resolve("PrivateHeader.h"));
    assertIsSymbolicLink(
        outputPath.resolve("TestLibrary/PrivateHeader.h"),
        inputPath.resolve("PrivateHeader.h"));
    assertIsSymbolicLink(
        outputPath.resolve("PublicHeader.h"),
        inputPath.resolve("PublicHeader.h"));
  }

  @Test
  public void testAppleLibraryExportedHeaderSymlinkTree() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_header_symlink_tree", tmp);
    workspace.setUp();

    BuildTarget buildTarget = BuildTarget.builder("//Libraries/TestLibrary", "TestLibrary")
        .addFlavors(ImmutableFlavor.of("default"))
        .addFlavors(ImmutableFlavor.of("exported-header-symlink-tree"))
        .build();
    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        buildTarget.getFullyQualifiedName());
    result.assertSuccess();

    Path projectRoot = tmp.getRootPath().toRealPath();

    Path inputPath = projectRoot.resolve(
        buildTarget.getBasePath());
    Path outputPath = projectRoot.resolve(
        BuildTargets.getGenPath(buildTarget, "%s"));

    assertIsSymbolicLink(
        outputPath.resolve("TestLibrary/PublicHeader.h"),
        inputPath.resolve("PublicHeader.h"));
  }

  @Test
  public void testAppleLibraryIsHermetic() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_is_hermetic", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult first = workspace.runBuckCommand(
        workspace.getPath("first"),
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,iphonesimulator-x86_64");
    first.assertSuccess();

    ProjectWorkspace.ProcessResult second = workspace.runBuckCommand(
        workspace.getPath("second"),
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,iphonesimulator-x86_64");
    second.assertSuccess();

    assertTrue(
        com.google.common.io.Files.equal(
            workspace.getFile(
                "first/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#compile-TestClass.m.o,iphonesimulator-x86_64/TestClass.m.o"),
            workspace.getFile(
                "second/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#compile-TestClass.m.o,iphonesimulator-x86_64/TestClass.m.o")));
    assertTrue(
        com.google.common.io.Files.equal(
            workspace.getFile(
                "first/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#iphonesimulator-x86_64,static/libTestLibrary.a"),
            workspace.getFile(
                "second/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#iphonesimulator-x86_64,static/libTestLibrary.a")));
  }

  private static void assertIsSymbolicLink(
      Path link,
      Path target) throws IOException {
    assertTrue(Files.isSymbolicLink(link));
    assertEquals(
        target,
        Files.readSymbolicLink(link));
  }
}

<code block>


package com.facebook.buck.apple;

import static com.facebook.buck.testutil.HasConsecutiveItemsMatcher.hasConsecutiveItems;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxLinkableEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.CxxPreprocessAndCompile;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.CxxSourceRuleFactory;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.io.AlwaysFoundExecutableFinder;
import com.facebook.buck.io.FakeExecutableFinder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import org.hamcrest.Matchers;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Map;


public class AppleCxxPlatformsTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void appleSdkPathsBuiltFromDirectory() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    SourcePathResolver resolver = new SourcePathResolver(new BuildRuleResolver());

    assertEquals(
        ImmutableList.of("usr/bin/actool"),
        appleCxxPlatform.getActool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("usr/bin/ibtool"),
        appleCxxPlatform.getIbtool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"),
        appleCxxPlatform.getDsymutil().getCommandPrefix(resolver));

    assertEquals(
        ImmutableList.of("usr/bin/xctest"),
        appleCxxPlatform.getXctest().getCommandPrefix(resolver));
    assertThat(appleCxxPlatform.getOtest().isPresent(), is(true));
    assertEquals(
        ImmutableList.of("Tools/otest"),
        appleCxxPlatform.getOtest().get().getCommandPrefix(resolver));

    assertEquals(
        ImmutableFlavor.of("iphoneos8.0-armv7"),
        cxxPlatform.getFlavor());
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang").toString(),
        cxxPlatform.getCc().getCommandPrefix(resolver).get(0));
    assertThat(
        ImmutableList.<String>builder()
            .addAll(cxxPlatform.getCc().getCommandPrefix(resolver))
            .addAll(cxxPlatform.getCflags())
            .build(),
        hasConsecutiveItems(
            "-isysroot",
            Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk").toString()));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-arch", "armv7"));
    assertThat(
        cxxPlatform.getAsflags(),
        hasConsecutiveItems("-arch", "armv7"));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-mios-version-min=7.0"));
    assertThat(
        cxxPlatform.getLdflags(),
        hasConsecutiveItems(
            "-sdk_version",
            "8.0"));
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++").toString(),
        cxxPlatform.getCxx().getCommandPrefix(resolver).get(0));
    assertEquals(
        Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar")
            .toString(),
        cxxPlatform.getAr().getCommandPrefix(resolver).get(0));
  }

  @Test
  public void platformWithoutOtestIsValid() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos9.0")
        .setVersion("9.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    assertThat(appleCxxPlatform.getOtest().isPresent(), is(false));
  }

  @Test
  public void invalidFlavorCharactersInSdkAreEscaped() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("_(in)+va|id_")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "cha+rs",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    assertEquals(
        ImmutableFlavor.of("__in__va_id_-cha_rs"),
        appleCxxPlatform.getCxxPlatform().getFlavor());
  }

  @Test
  public void cxxToolParamsReadFromBuckConfig() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of(
                        "cflags", "-std=gnu11",
                        "cppflags", "-DCTHING",
                        "cxxflags", "-std=c++11",
                        "cxxppflags", "-DCXXTHING"))),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    assertThat(
        cxxPlatform.getCflags(),
        hasItem("-std=gnu11"));
    assertThat(
        cxxPlatform.getCppflags(),
        hasItems("-std=gnu11", "-DCTHING"));
    assertThat(
        cxxPlatform.getCxxflags(),
        hasItem("-std=c++11"));
    assertThat(
        cxxPlatform.getCxxppflags(),
        hasItems("-std=c++11", "-DCXXTHING"));
  }

  @Test
  public void cxxToolParamsReadFromBuckConfigWithGenFlavor() throws Exception {
AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();


    Flavor testFlavor = ImmutableFlavor.of("test-flavor");

    BuckConfig config = new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of(
                        "cflags", "-std=gnu11",
                        "cppflags", "-DCTHING",
                        "cxxflags", "-std=c++11",
                        "cxxppflags", "-DCXXTHING"),
                    "cxx#" + testFlavor.toString(), ImmutableMap.of(
                        "cflags", "-Wnoerror",
                        "cppflags", "-DCTHING2",
                        "cxxflags", "-Woption",
                        "cxxppflags", "-DCXXTHING2",
                        "default_platform", "iphoneos8.0-armv7")));

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            config,
            new FakeExecutableFinder(paths));

    CxxPlatform defaultCxxPlatform = appleCxxPlatform.getCxxPlatform();

    CxxPlatform cxxPlatform = CxxPlatforms.copyPlatformWithFlavorAndConfig(
      defaultCxxPlatform,
        new CxxBuckConfig(config, testFlavor),
        testFlavor);

    assertThat(
        cxxPlatform.getCflags(),
        hasItems("-std=gnu11", "-Wnoerror"));
    assertThat(
        cxxPlatform.getCppflags(),
        hasItems("-std=gnu11",  "-Wnoerror", "-DCTHING", "-DCTHING2"));
    assertThat(
        cxxPlatform.getCxxflags(),
        hasItems("-std=c++11", "-Woption"));
    assertThat(
        cxxPlatform.getCxxppflags(),
        hasItems("-std=c++11", "-Woption", "-DCXXTHING", "-DCXXTHING2"));
  }

  @Test
  public void pathNotFoundThrows() throws Exception {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(containsString("Cannot find tool"));
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatforms.buildWithExecutableChecker(
        targetSdk,
        "7.0",
        "armv7",
        appleSdkPaths,
        new FakeBuckConfig(),
        new FakeExecutableFinder(ImmutableSet.<Path>of()));
  }

  @Test
  public void simulatorPlatformSetsLinkerFlags() throws Exception {
    AppleSdkPaths appleSdkPaths = AppleSdkPaths.builder()
        .setDeveloperPath(Paths.get("."))
        .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
        .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
        .setName("iphonesimulator8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    assertThat(
        cxxPlatform.getCflags(),
        hasItem("-mios-simulator-version-min=7.0"));
    assertThat(
        cxxPlatform.getCxxldflags(),
        hasItem("-mios-simulator-version-min=7.0"));
  }

  enum Operation {
    PREPROCESS,
    COMPILE,
    PREPROCESS_AND_COMPILE,
  }


  private ImmutableMap<Flavor, RuleKey> constructCompileRuleKeys(
      Operation operation,
      ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    String source = "source.cpp";
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("source.cpp", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxSourceRuleFactory cxxSourceRuleFactory =
          new CxxSourceRuleFactory(
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              resolver,
              pathResolver,
              entry.getValue().getCxxPlatform(),
              ImmutableList.<CxxPreprocessorInput>of(),
              ImmutableList.<String>of());
      CxxPreprocessAndCompile rule;
      switch (operation) {
        case PREPROCESS_AND_COMPILE:
          rule =
              cxxSourceRuleFactory.createPreprocessAndCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC,
                  CxxPreprocessMode.COMBINED);
          break;
        case PREPROCESS:
          rule =
              cxxSourceRuleFactory.createPreprocessBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        case COMPILE:
          rule =
              cxxSourceRuleFactory.createCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX_CPP_OUTPUT,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        default:
          throw new IllegalStateException();
      }
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }


  private ImmutableMap<Flavor, RuleKey> constructLinkRuleKeys(
      ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("input.o", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {
      BuildRule rule =
          CxxLinkableEnhancer.createCxxLinkableBuildRule(
              entry.getValue().getCxxPlatform(),
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              pathResolver,
              ImmutableList.<String>of(),
              ImmutableList.<String>of(),
              target,
              Linker.LinkType.EXECUTABLE,
              Optional.<String>absent(),
              Paths.get("output"),
              ImmutableList.<SourcePath>of(new TestSourcePath("input.o")),
              Linker.LinkableDepType.SHARED,
              ImmutableList.<BuildRule>of(),
              Optional.<Linker.CxxRuntimeType>absent(),
              Optional.<SourcePath>absent());
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }

  private AppleCxxPlatform buildAppleCxxPlatform(Path root) {
    AppleSdkPaths appleSdkPaths = AppleSdkPaths.builder()
        .setDeveloperPath(root)
        .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
        .setSdkPath(
            root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
        .build();
    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();
    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
        .setName("iphonesimulator8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();
    return AppleCxxPlatforms.buildWithExecutableChecker(
        targetSdk,
        "7.0",
        "armv7",
        appleSdkPaths,
        new FakeBuckConfig(),
        new AlwaysFoundExecutableFinder());
  }



  @Test
  public void checkRootAndPlatformDoNotAffectRuleKeys() throws IOException {
    Map<String, ImmutableMap<Flavor, RuleKey>> preprocessAndCompileRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> preprocessRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> compileRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> linkRukeKeys = Maps.newHashMap();



    for (String dir : ImmutableList.of("something", "something else")) {
      AppleCxxPlatform platform = buildAppleCxxPlatform(Paths.get(dir));
      preprocessAndCompileRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.PREPROCESS_AND_COMPILE,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      preprocessRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.PREPROCESS,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      compileRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.COMPILE,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      linkRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructLinkRuleKeys(
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
    }



    assertThat(
        Arrays.toString(preprocessAndCompileRukeKeys.entrySet().toArray()),
        Sets.newHashSet(preprocessAndCompileRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(preprocessRukeKeys.entrySet().toArray()),
        Sets.newHashSet(preprocessRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(compileRukeKeys.entrySet().toArray()),
        Sets.newHashSet(compileRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(linkRukeKeys.entrySet().toArray()),
        Sets.newHashSet(linkRukeKeys.values()),
        Matchers.hasSize(1));

  }

}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;

public class AppleSdkDiscoveryTest {

  @Rule
  public DebuggableTemporaryFolder temp = new DebuggableTemporaryFolder();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  private AppleToolchain getDefaultToolchain(Path path) {
    return AppleToolchain.builder()
        .setIdentifier("com.apple.dt.toolchain.XcodeDefault")
        .setPath(path.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();
  }

  @Test
  public void shouldReturnAnEmptyMapIfNoPlatformsFound() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-empty",
        temp);
    workspace.setUp();
    Path path = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(path)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(path),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(0, sdks.size());
  }

  @Test
  public void shouldFindPlatformsInExtraPlatformDirectories() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-minimal",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ProjectWorkspace emptyWorkspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-empty",
        temp);
    emptyWorkspace.setUp();
    Path path = emptyWorkspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(path));

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addAllToolchains(toolchains.values())
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(path)
            .addToolchainPaths(path.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(path),
            ImmutableList.of(root),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void ignoresInvalidExtraPlatformDirectories() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-minimal",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    Path path = Paths.get("invalid");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addAllToolchains(toolchains.values())
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.of(path),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void shouldNotIgnoreSdkWithUnrecognizedPlatform() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-unknown-platform-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(root),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(2, sdks.size());
  }

  @Test
  public void shouldIgnoreSdkWithBadSymlink() throws Exception {
    Path root = temp.newFolder().toPath();


    File toDelete = File.createTempFile("foo", "bar");
    Path symlink = root.resolve("Platforms/Foo.platform/Developer/NonExistent1.0.sdk");
    Files.createDirectories(symlink.getParent());
    Files.createSymbolicLink(symlink, toDelete.toPath());
    assertTrue(toDelete.delete());

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(root),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(0, sdks.size());
  }

  @Test
  public void appleSdkPathsBuiltFromDirectory() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");
    createSymLinkIosSdks(root, "8.0");

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    AppleSdk iphoneos80Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.0")
            .setVersion("8.0")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
            .build();

    AppleSdk iphonesimulator80Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.0")
            .setVersion("8.0")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk"))
            .build();

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .put(iphoneos80Sdk, iphoneos80Paths)
            .put(iphoneos80Sdk.withName("iphoneos"), iphoneos80Paths)
            .put(iphonesimulator80Sdk, iphonesimulator80Paths)
            .put(iphonesimulator80Sdk.withName("iphonesimulator"), iphonesimulator80Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void noAppleSdksFoundIfDefaultPlatformMissing() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains).entrySet(),
        empty());
  }

  @Test
  public void multipleAppleSdkPathsPerPlatformBuiltFromDirectory() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-multi-version-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    createSymLinkIosSdks(root, "8.1");

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    AppleSdk iphoneos80Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.0")
            .setVersion("8.0")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleSdk iphonesimulator80Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.0")
            .setVersion("8.0")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
            .build();

    AppleSdk iphoneos81Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.1")
            .setVersion("8.1")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos81Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
            .build();

    AppleSdk iphonesimulator81Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.1")
            .setVersion("8.1")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator81Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .put(iphoneos80Sdk, iphoneos80Paths)
            .put(iphonesimulator80Sdk, iphonesimulator80Paths)
            .put(iphoneos81Sdk, iphoneos81Paths)
            .put(iphoneos81Sdk.withName("iphoneos"), iphoneos81Paths)
            .put(iphonesimulator81Sdk, iphonesimulator81Paths)
            .put(iphonesimulator81Sdk.withName("iphonesimulator"), iphonesimulator81Paths)
            .build();

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains),
        equalTo(expected));
  }

  private void createSymLinkIosSdks(Path root, String version) throws IOException {
    Set<String> sdks = ImmutableSet.of("iPhoneOS", "iPhoneSimulator");
    for (String sdk : sdks) {
      Path sdkDir = root.resolve(String.format("Platforms/%s.platform/Developer/SDKs", sdk));

      if (!Files.exists(sdkDir)) {
        continue;
      }

      Path actual = sdkDir.resolve(String.format("%s.sdk", sdk));
      Path link = sdkDir.resolve(String.format("%s%s.sdk", sdk, version));
      Files.createSymbolicLink(link, actual);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.facebook.buck.log.Logger;
import com.facebook.buck.util.VersionStringComparator;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.collect.TreeMultimap;

import java.io.BufferedInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;


public class AppleSdkDiscovery {

  private static final Logger LOG = Logger.get(AppleSdkDiscovery.class);

  private static final Ordering<AppleSdk> APPLE_SDK_VERSION_ORDERING =
    Ordering
        .from(new VersionStringComparator())
        .onResultOf(new Function<AppleSdk, String>() {
            @Override
            public String apply(AppleSdk appleSdk) {
                return appleSdk.getVersion();
            }
        });

  private static final String DEFAULT_TOOLCHAIN_ID = "com.apple.dt.toolchain.XcodeDefault";


  private AppleSdkDiscovery() { }


  public static ImmutableMap<AppleSdk, AppleSdkPaths> discoverAppleSdkPaths(
      Optional<Path> developerDir,
      ImmutableList<Path> extraDirs,
      ImmutableMap<String, AppleToolchain> xcodeToolchains)
      throws IOException {
    Optional<AppleToolchain> defaultToolchain =
        Optional.fromNullable(xcodeToolchains.get(DEFAULT_TOOLCHAIN_ID));

    ImmutableMap.Builder<AppleSdk, AppleSdkPaths> appleSdkPathsBuilder = ImmutableMap.builder();

    Iterable<Path> platformPaths = extraDirs;
    if (developerDir.isPresent()) {
      Path platformsDir = developerDir.get().resolve("Platforms");
      LOG.debug("Searching for Xcode platforms under %s", platformsDir);
      platformPaths = Iterables.concat(
        ImmutableSet.of(platformsDir), platformPaths);
    }







    TreeMultimap<ApplePlatform, AppleSdk> orderedSdksForPlatform =
        TreeMultimap.create(
            Ordering.natural(),
            APPLE_SDK_VERSION_ORDERING);

    for (Path platforms : platformPaths) {
      if (!Files.exists(platforms)) {
        LOG.debug("Skipping platform search path %s that does not exist", platforms);
        continue;
      }
      LOG.debug("Searching for Xcode SDKs in %s", platforms);

      try (DirectoryStream<Path> platformStream = Files.newDirectoryStream(
          platforms,
               "*.platform")) {
        for (Path platformDir : platformStream) {
          Path developerSdksPath = platformDir.resolve("Developer/SDKs");
          try (DirectoryStream<Path> sdkStream = Files.newDirectoryStream(
                   developerSdksPath,
                   "*.sdk")) {
            for (Path sdkDir : sdkStream) {
              LOG.debug("Fetching SDK name for %s", sdkDir);
              if (Files.isSymbolicLink(sdkDir)) {
                continue;
              }

              AppleSdk.Builder sdkBuilder = AppleSdk.builder();
              if (buildSdkFromPath(sdkDir, sdkBuilder, xcodeToolchains, defaultToolchain)) {
                AppleSdk sdk = sdkBuilder.build();
                LOG.debug("Found SDK %s", sdk);

                AppleSdkPaths.Builder xcodePathsBuilder = AppleSdkPaths.builder();
                for (AppleToolchain toolchain : sdk.getToolchains()) {
                  xcodePathsBuilder.addToolchainPaths(toolchain.getPath());
                }
                AppleSdkPaths xcodePaths = xcodePathsBuilder
                    .setDeveloperPath(developerDir)
                    .setPlatformPath(platformDir)
                    .setSdkPath(sdkDir)
                    .build();
                appleSdkPathsBuilder.put(sdk, xcodePaths);
                orderedSdksForPlatform.put(sdk.getApplePlatform(), sdk);
              }
            }
          } catch (NoSuchFileException e) {
            LOG.warn(
                e,
                "Couldn't discover SDKs at path %s, ignoring platform %s",
                developerSdksPath,
                platformDir);
          }
        }
      }
    }




    ImmutableMap<AppleSdk, AppleSdkPaths> discoveredSdkPaths = appleSdkPathsBuilder.build();

    for (ApplePlatform platform : orderedSdksForPlatform.keySet()) {
      AppleSdk mostRecentSdkForPlatform = orderedSdksForPlatform.get(platform).last();
      if (!mostRecentSdkForPlatform.getName().equals(platform.getName())) {
        appleSdkPathsBuilder.put(
            mostRecentSdkForPlatform.withName(platform.getName()),
            discoveredSdkPaths.get(mostRecentSdkForPlatform));
      }
    }



    return appleSdkPathsBuilder.build();
  }

  private static void addArchitecturesForPlatform(
      AppleSdk.Builder sdkBuilder,
      ApplePlatform applePlatform) {

    switch (applePlatform.getName()) {
      case ApplePlatform.Name.MACOSX:

      case ApplePlatform.Name.IPHONESIMULATOR:
        sdkBuilder.addArchitectures("i386", "x86_64");
        break;
      case ApplePlatform.Name.IPHONEOS:
        sdkBuilder.addArchitectures("armv7", "arm64");
        break;
      case ApplePlatform.Name.WATCHSIMULATOR:
        sdkBuilder.addArchitectures("i386");
        break;
      case ApplePlatform.Name.WATCHOS:
        sdkBuilder.addArchitectures("armv7k");
        break;
      default:
        sdkBuilder.addArchitectures("armv7", "arm64", "i386", "x86_64");
        break;
    }
  }

  private static boolean buildSdkFromPath(
        Path sdkDir,
        AppleSdk.Builder sdkBuilder,
        ImmutableMap<String, AppleToolchain> xcodeToolchains,
        Optional<AppleToolchain> defaultToolchain) throws IOException {
    try (InputStream sdkSettingsPlist = Files.newInputStream(sdkDir.resolve("SDKSettings.plist"));
         BufferedInputStream bufferedSdkSettingsPlist = new BufferedInputStream(sdkSettingsPlist)) {
      NSDictionary sdkSettings;
      try {
        sdkSettings = (NSDictionary) PropertyListParser.parse(bufferedSdkSettingsPlist);
      } catch (Exception e) {
        throw new IOException(e);
      }
      String name = sdkSettings.objectForKey("CanonicalName").toString();
      String version = sdkSettings.objectForKey("Version").toString();
      NSDictionary defaultProperties = (NSDictionary) sdkSettings.objectForKey("DefaultProperties");

      boolean foundToolchain = false;
      NSArray toolchains = (NSArray) sdkSettings.objectForKey("Toolchains");
      if (toolchains != null) {
        for (NSObject toolchainIdObject : toolchains.getArray()) {
          String toolchainId = toolchainIdObject.toString();
          AppleToolchain toolchain = xcodeToolchains.get(toolchainId);
          if (toolchain != null) {
            foundToolchain = true;
            sdkBuilder.addToolchains(toolchain);
          } else {
            LOG.debug("Specified toolchain %s not found for SDK path %s", toolchainId, sdkDir);
          }
        }
      }
      if (!foundToolchain && defaultToolchain.isPresent()) {
        foundToolchain = true;
        sdkBuilder.addToolchains(defaultToolchain.get());
      }
      if (!foundToolchain) {
        LOG.warn("No toolchains found and no default toolchain. Skipping SDK path %s.", sdkDir);
        return false;
      } else {
        NSString platformName = (NSString) defaultProperties.objectForKey("PLATFORM_NAME");
        ApplePlatform applePlatform =
            ApplePlatform.builder().setName(platformName.toString()).build();
        sdkBuilder.setName(name).setVersion(version).setApplePlatform(applePlatform);
        addArchitecturesForPlatform(sdkBuilder, applePlatform);
        return true;
      }
    } catch (FileNotFoundException e) {
      LOG.error(e, "No SDKSettings.plist found under SDK path %s", sdkDir);
      return false;
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractApplePlatform implements Comparable<AbstractApplePlatform> {
  class Name {
    public static final String IPHONEOS = "iphoneos";
    public static final String IPHONESIMULATOR = "iphonesimulator";
    public static final String WATCHOS = "watchos";
    public static final String WATCHSIMULATOR = "watchsimulator";
    public static final String MACOSX = "macosx";

    private Name() { }
  }


  public abstract String getName();

  @Override
  public int compareTo(AbstractApplePlatform other) {
    return getName().compareTo(other.getName());
  }
}

<code block>


package com.facebook.buck.apple;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.BsdArchiver;
import com.facebook.buck.cxx.ClangCompiler;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.DarwinLinker;
import com.facebook.buck.cxx.DebugPathSanitizer;
import com.facebook.buck.cxx.VersionedTool;
import com.facebook.buck.io.ExecutableFinder;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.Tool;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;


public class AppleCxxPlatforms {


  private AppleCxxPlatforms() { }

  private static final Path USR_BIN = Paths.get("usr/bin");

  public static AppleCxxPlatform build(
      AppleSdk targetSdk,
      String minVersion,
      String targetArchitecture,
      AppleSdkPaths sdkPaths,
      BuckConfig buckConfig) {
    return buildWithExecutableChecker(
        targetSdk,
        minVersion,
        targetArchitecture,
        sdkPaths,
        buckConfig,
        new ExecutableFinder());
  }

  @VisibleForTesting
  static AppleCxxPlatform buildWithExecutableChecker(
      AppleSdk targetSdk,
      String minVersion,
      String targetArchitecture,
      AppleSdkPaths sdkPaths,
      BuckConfig buckConfig,
      ExecutableFinder executableFinder) {

    ImmutableList.Builder<Path> toolSearchPathsBuilder = ImmutableList.builder();

    toolSearchPathsBuilder
        .add(sdkPaths.getSdkPath().resolve(USR_BIN))
        .add(sdkPaths.getSdkPath().resolve("Developer").resolve(USR_BIN))
        .add(sdkPaths.getPlatformPath().resolve("Developer").resolve(USR_BIN));
    for (Path toolchainPath : sdkPaths.getToolchainPaths()) {
      toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
    }
    if (sdkPaths.getDeveloperPath().isPresent()) {
      toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
      toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve("Tools"));
    }
    ImmutableList<Path> toolSearchPaths = toolSearchPathsBuilder.build();


    ImmutableList.Builder<String> cflagsBuilder = ImmutableList.builder();
    cflagsBuilder.add("-isysroot", sdkPaths.getSdkPath().toString());
    cflagsBuilder.add("-arch", targetArchitecture);
    switch (targetSdk.getApplePlatform().getName()) {
      case ApplePlatform.Name.IPHONEOS:
        cflagsBuilder.add("-mios-version-min=" + minVersion);
        break;
      case ApplePlatform.Name.IPHONESIMULATOR:
        cflagsBuilder.add("-mios-simulator-version-min=" + minVersion);
        break;
      case ApplePlatform.Name.WATCHOS:
        cflagsBuilder.add("-mwatchos-version-min=" + minVersion);
        break;
      case ApplePlatform.Name.WATCHSIMULATOR:
        cflagsBuilder.add("-mwatchos-simulator-version-min=" + minVersion);
        break;
      default:

        cflagsBuilder.add(
            "-m" + targetSdk.getApplePlatform().getName() + "-version-min=" + minVersion);
        break;
    }

    ImmutableList<String> ldflags = ImmutableList.of("-sdk_version", targetSdk.getVersion());
    ImmutableList<String> asflags = ImmutableList.of("-arch", targetArchitecture);

    ImmutableList.Builder<String> versionsBuilder = ImmutableList.builder();
    versionsBuilder.add(targetSdk.getVersion());
    for (AppleToolchain toolchain : targetSdk.getToolchains()) {
      versionsBuilder.add(toolchain.getVersion());
    }
    String version = Joiner.on(':').join(versionsBuilder.build());

    Tool clangPath = new VersionedTool(
        getToolPath("clang", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-clang",
        version);

    Tool clangXxPath = new VersionedTool(
        getToolPath("clang++", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-clang++",
        version);

    Tool ar = new VersionedTool(
        getToolPath("ar", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-ar",
        version);

    Tool strip = new VersionedTool(
        getToolPath("strip", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-strip",
        version);

    Tool actool = new VersionedTool(
        getToolPath("actool", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-actool",
        version);

    Tool ibtool = new VersionedTool(
        getToolPath("ibtool", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-ibtool",
        version);

    Tool xctest = new VersionedTool(
        getToolPath("xctest", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-xctest",
        version);

    Optional<Tool> otest = getOptionalTool(
        "otest",
        toolSearchPaths,
        executableFinder,
        version);

    Tool dsymutil = new VersionedTool(
        getToolPath("dsymutil", toolSearchPaths, executableFinder),
        ImmutableList.<String>of(),
        "apple-dsymutil",
        version);

    CxxBuckConfig config = new CxxBuckConfig(buckConfig);

    ImmutableFlavor targetFlavor = ImmutableFlavor.of(
        ImmutableFlavor.replaceInvalidCharacters(
            targetSdk.getName() + "-" + targetArchitecture));

    ImmutableBiMap.Builder<Path, Path> sanitizerPaths = ImmutableBiMap.builder();
    sanitizerPaths.put(sdkPaths.getSdkPath(), Paths.get("APPLE_SDKROOT"));
    sanitizerPaths.put(sdkPaths.getPlatformPath(), Paths.get("APPLE_PLATFORM_DIR"));
    if (sdkPaths.getDeveloperPath().isPresent()) {
      sanitizerPaths.put(sdkPaths.getDeveloperPath().get(), Paths.get("APPLE_DEVELOPER_DIR"));
    }

    DebugPathSanitizer debugPathSanitizer = new DebugPathSanitizer(
        250,
        File.separatorChar,
        Paths.get("."),
        sanitizerPaths.build());

    ImmutableList<String> cflags = cflagsBuilder.build();

    ImmutableMap.Builder<String, String> macrosBuilder = ImmutableMap.builder();
    macrosBuilder.put("SDKROOT", sdkPaths.getSdkPath().toString());
    macrosBuilder.put("PLATFORM_DIR", sdkPaths.getPlatformPath().toString());
    if (sdkPaths.getDeveloperPath().isPresent()) {
      macrosBuilder.put("DEVELOPER_DIR", sdkPaths.getDeveloperPath().get().toString());
    }
    ImmutableMap<String, String> macros = macrosBuilder.build();

    CxxPlatform cxxPlatform = CxxPlatforms.build(
        targetFlavor,
        config,
        clangPath,
        clangPath,
        new ClangCompiler(clangPath),
        new ClangCompiler(clangXxPath),
        clangPath,
        clangXxPath,
        new DarwinLinker(clangPath),
        new DarwinLinker(clangXxPath),
        ldflags,
        strip,
        new BsdArchiver(ar),
        asflags,
        ImmutableList.<String>of(),
        cflags,
        ImmutableList.<String>of(),
        getOptionalTool("lex", toolSearchPaths, executableFinder, version),
        getOptionalTool("yacc", toolSearchPaths, executableFinder, version),
        "dylib",
        Optional.of(debugPathSanitizer),
        macros);

    return AppleCxxPlatform.builder()
        .setCxxPlatform(cxxPlatform)
        .setAppleSdk(targetSdk)
        .setAppleSdkPaths(sdkPaths)
        .setActool(actool)
        .setIbtool(ibtool)
        .setXctest(xctest)
        .setOtest(otest)
        .setDsymutil(dsymutil)
        .build();
  }

  private static Optional<Tool> getOptionalTool(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder,
      String version) {
    return getOptionalToolPath(tool, toolSearchPaths, executableFinder)
        .transform(VersionedTool.fromPath(tool, version))
        .transform(Functions.<Tool>identity());
  }

  private static Path getToolPath(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder) {
    Optional<Path> result = getOptionalToolPath(tool, toolSearchPaths, executableFinder);
    if (!result.isPresent()) {
      throw new HumanReadableException("Cannot find tool %s in paths %s", tool, toolSearchPaths);
    }
    return result.get();
  }

    private static Optional<Path> getOptionalToolPath(
      String tool,
      ImmutableList<Path> toolSearchPaths,
      ExecutableFinder executableFinder) {

      return executableFinder.getOptionalExecutable(
          Paths.get(tool),
          toolSearchPaths,
          ImmutableSet.<String>of());
  }

}

<code block>


package com.facebook.buck.apple;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.environment.Platform;

import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class AppleLibraryIntegrationTest {

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  @Test
  public void testAppleLibraryBuildsSomething() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,default");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryBuildsForWatchOS() throws IOException {
    assumeTrue(AppleNativeIntegrationTestUtils.isApplePlatformAvailable(
            ApplePlatform.builder().setName(ApplePlatform.Name.WATCHOS).build()));

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#watchos-armv7k,static");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryBuildsForWatchSimulator() throws IOException {
    assumeTrue(AppleNativeIntegrationTestUtils.isApplePlatformAvailable(
            ApplePlatform.builder().setName(ApplePlatform.Name.WATCHSIMULATOR).build()));

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#watchsimulator-i386,static");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryBuildsSomethingUsingAppleCxxPlatform() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    assumeTrue(AppleNativeIntegrationTestUtils.isApplePlatformAvailable(
            ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build()));

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_builds_something", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,macosx-x86_64");
    result.assertSuccess();

    assertTrue(Files.exists(tmp.getRootPath().resolve(BuckConstant.GEN_DIR)));
  }

  @Test
  public void testAppleLibraryHeaderSymlinkTree() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_header_symlink_tree", tmp);
    workspace.setUp();

    BuildTarget buildTarget = BuildTarget.builder("//Libraries/TestLibrary", "TestLibrary")
        .addFlavors(ImmutableFlavor.of("default"))
        .addFlavors(ImmutableFlavor.of("header-symlink-tree"))
        .build();
    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        buildTarget.getFullyQualifiedName());
    result.assertSuccess();

    Path projectRoot = tmp.getRootPath().toRealPath();

    Path inputPath = projectRoot.resolve(
        buildTarget.getBasePath());
    Path outputPath = projectRoot.resolve(
        BuildTargets.getGenPath(buildTarget, "%s"));

    assertIsSymbolicLink(
        outputPath.resolve("PrivateHeader.h"),
        inputPath.resolve("PrivateHeader.h"));
    assertIsSymbolicLink(
        outputPath.resolve("TestLibrary/PrivateHeader.h"),
        inputPath.resolve("PrivateHeader.h"));
    assertIsSymbolicLink(
        outputPath.resolve("PublicHeader.h"),
        inputPath.resolve("PublicHeader.h"));
  }

  @Test
  public void testAppleLibraryExportedHeaderSymlinkTree() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);

    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_header_symlink_tree", tmp);
    workspace.setUp();

    BuildTarget buildTarget = BuildTarget.builder("//Libraries/TestLibrary", "TestLibrary")
        .addFlavors(ImmutableFlavor.of("default"))
        .addFlavors(ImmutableFlavor.of("exported-header-symlink-tree"))
        .build();
    ProjectWorkspace.ProcessResult result = workspace.runBuckCommand(
        "build",
        buildTarget.getFullyQualifiedName());
    result.assertSuccess();

    Path projectRoot = tmp.getRootPath().toRealPath();

    Path inputPath = projectRoot.resolve(
        buildTarget.getBasePath());
    Path outputPath = projectRoot.resolve(
        BuildTargets.getGenPath(buildTarget, "%s"));

    assertIsSymbolicLink(
        outputPath.resolve("TestLibrary/PublicHeader.h"),
        inputPath.resolve("PublicHeader.h"));
  }

  @Test
  public void testAppleLibraryIsHermetic() throws IOException {
    assumeTrue(Platform.detect() == Platform.MACOS);
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this, "apple_library_is_hermetic", tmp);
    workspace.setUp();

    ProjectWorkspace.ProcessResult first = workspace.runBuckCommand(
        workspace.getPath("first"),
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,iphonesimulator-x86_64");
    first.assertSuccess();

    ProjectWorkspace.ProcessResult second = workspace.runBuckCommand(
        workspace.getPath("second"),
        "build",
        "//Libraries/TestLibrary:TestLibrary#static,iphonesimulator-x86_64");
    second.assertSuccess();

    assertTrue(
        com.google.common.io.Files.equal(
            workspace.getFile(
                "first/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#compile-TestClass.m.o,iphonesimulator-x86_64/TestClass.m.o"),
            workspace.getFile(
                "second/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#compile-TestClass.m.o,iphonesimulator-x86_64/TestClass.m.o")));
    assertTrue(
        com.google.common.io.Files.equal(
            workspace.getFile(
                "first/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#iphonesimulator-x86_64,static/libTestLibrary.a"),
            workspace.getFile(
                "second/buck-out/gen/Libraries/TestLibrary/" +
                    "TestLibrary#iphonesimulator-x86_64,static/libTestLibrary.a")));
  }

  private static void assertIsSymbolicLink(
      Path link,
      Path target) throws IOException {
    assertTrue(Files.isSymbolicLink(link));
    assertEquals(
        target,
        Files.readSymbolicLink(link));
  }
}

<code block>


package com.facebook.buck.apple;

import static com.facebook.buck.testutil.HasConsecutiveItemsMatcher.hasConsecutiveItems;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;

import com.facebook.buck.cli.BuckConfig;
import com.facebook.buck.cxx.CxxBuckConfig;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxLinkableEnhancer;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPlatforms;
import com.facebook.buck.cxx.CxxPreprocessAndCompile;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.CxxSourceRuleFactory;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.io.AlwaysFoundExecutableFinder;
import com.facebook.buck.io.FakeExecutableFinder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import org.hamcrest.Matchers;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Map;


public class AppleCxxPlatformsTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Test
  public void iphoneOSSdkPathsBuiltFromDirectory() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    SourcePathResolver resolver = new SourcePathResolver(new BuildRuleResolver());

    assertEquals(
        ImmutableList.of("usr/bin/actool"),
        appleCxxPlatform.getActool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("usr/bin/ibtool"),
        appleCxxPlatform.getIbtool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"),
        appleCxxPlatform.getDsymutil().getCommandPrefix(resolver));

    assertEquals(
        ImmutableList.of("usr/bin/xctest"),
        appleCxxPlatform.getXctest().getCommandPrefix(resolver));
    assertThat(appleCxxPlatform.getOtest().isPresent(), is(true));
    assertEquals(
        ImmutableList.of("Tools/otest"),
        appleCxxPlatform.getOtest().get().getCommandPrefix(resolver));

    assertEquals(
        ImmutableFlavor.of("iphoneos8.0-armv7"),
        cxxPlatform.getFlavor());
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang").toString(),
        cxxPlatform.getCc().getCommandPrefix(resolver).get(0));
    assertThat(
        ImmutableList.<String>builder()
            .addAll(cxxPlatform.getCc().getCommandPrefix(resolver))
            .addAll(cxxPlatform.getCflags())
            .build(),
        hasConsecutiveItems(
            "-isysroot",
            Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk").toString()));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-arch", "armv7"));
    assertThat(
        cxxPlatform.getAsflags(),
        hasConsecutiveItems("-arch", "armv7"));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-mios-version-min=7.0"));
    assertThat(
        cxxPlatform.getLdflags(),
        hasConsecutiveItems(
            "-sdk_version",
            "8.0"));
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++").toString(),
        cxxPlatform.getCxx().getCommandPrefix(resolver).get(0));
    assertEquals(
        Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar")
            .toString(),
        cxxPlatform.getAr().getCommandPrefix(resolver).get(0));
  }

  @Test
  public void watchOSSdkPathsBuiltFromDirectory() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/WatchOS.platform"))
            .setSdkPath(Paths.get("Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.WATCHOS).build())
        .setName("watchos2.0")
        .setVersion("2.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/WatchOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/WatchOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "2.0",
            "armv7k",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    SourcePathResolver resolver = new SourcePathResolver(new BuildRuleResolver());

    assertEquals(
        ImmutableList.of("usr/bin/actool"),
        appleCxxPlatform.getActool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("usr/bin/ibtool"),
        appleCxxPlatform.getIbtool().getCommandPrefix(resolver));
    assertEquals(
        ImmutableList.of("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"),
        appleCxxPlatform.getDsymutil().getCommandPrefix(resolver));

    assertEquals(
        ImmutableList.of("usr/bin/xctest"),
        appleCxxPlatform.getXctest().getCommandPrefix(resolver));

    assertEquals(
        ImmutableFlavor.of("watchos2.0-armv7k"),
        cxxPlatform.getFlavor());
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang").toString(),
        cxxPlatform.getCc().getCommandPrefix(resolver).get(0));
    assertThat(
        ImmutableList.<String>builder()
            .addAll(cxxPlatform.getCc().getCommandPrefix(resolver))
            .addAll(cxxPlatform.getCflags())
            .build(),
        hasConsecutiveItems(
            "-isysroot",
            Paths.get("Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.0.sdk").toString()));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-arch", "armv7k"));
    assertThat(
        cxxPlatform.getCflags(),
        hasConsecutiveItems("-mwatchos-version-min=2.0"));
    assertThat(
        cxxPlatform.getLdflags(),
        hasConsecutiveItems(
            "-sdk_version",
            "2.0"));
    assertEquals(
        Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++").toString(),
        cxxPlatform.getCxx().getCommandPrefix(resolver).get(0));
    assertEquals(
        Paths.get("Platforms/WatchOS.platform/Developer/usr/bin/ar")
            .toString(),
        cxxPlatform.getAr().getCommandPrefix(resolver).get(0));
  }

  @Test
  public void platformWithoutOtestIsValid() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos9.0")
        .setVersion("9.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    assertThat(appleCxxPlatform.getOtest().isPresent(), is(false));
  }

  @Test
  public void invalidFlavorCharactersInSdkAreEscaped() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("_(in)+va|id_")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "cha+rs",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    assertEquals(
        ImmutableFlavor.of("__in__va_id_-cha_rs"),
        appleCxxPlatform.getCxxPlatform().getFlavor());
  }

  @Test
  public void cxxToolParamsReadFromBuckConfig() throws Exception {
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of(
                        "cflags", "-std=gnu11",
                        "cppflags", "-DCTHING",
                        "cxxflags", "-std=c++11",
                        "cxxppflags", "-DCXXTHING"))),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    assertThat(
        cxxPlatform.getCflags(),
        hasItem("-std=gnu11"));
    assertThat(
        cxxPlatform.getCppflags(),
        hasItems("-std=gnu11", "-DCTHING"));
    assertThat(
        cxxPlatform.getCxxflags(),
        hasItem("-std=c++11"));
    assertThat(
        cxxPlatform.getCxxppflags(),
        hasItems("-std=c++11", "-DCXXTHING"));
  }

  @Test
  public void cxxToolParamsReadFromBuckConfigWithGenFlavor() throws Exception {
AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneOS.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();


    Flavor testFlavor = ImmutableFlavor.of("test-flavor");

    BuckConfig config = new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of(
                        "cflags", "-std=gnu11",
                        "cppflags", "-DCTHING",
                        "cxxflags", "-std=c++11",
                        "cxxppflags", "-DCXXTHING"),
                    "cxx#" + testFlavor.toString(), ImmutableMap.of(
                        "cflags", "-Wnoerror",
                        "cppflags", "-DCTHING2",
                        "cxxflags", "-Woption",
                        "cxxppflags", "-DCXXTHING2",
                        "default_platform", "iphoneos8.0-armv7")));

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            config,
            new FakeExecutableFinder(paths));

    CxxPlatform defaultCxxPlatform = appleCxxPlatform.getCxxPlatform();

    CxxPlatform cxxPlatform = CxxPlatforms.copyPlatformWithFlavorAndConfig(
        defaultCxxPlatform,
        new CxxBuckConfig(config, testFlavor),
        testFlavor);

    assertThat(
        cxxPlatform.getCflags(),
        hasItems("-std=gnu11", "-Wnoerror"));
    assertThat(
        cxxPlatform.getCppflags(),
        hasItems("-std=gnu11",  "-Wnoerror", "-DCTHING", "-DCTHING2"));
    assertThat(
        cxxPlatform.getCxxflags(),
        hasItems("-std=c++11", "-Woption"));
    assertThat(
        cxxPlatform.getCxxppflags(),
        hasItems("-std=c++11", "-Woption", "-DCXXTHING", "-DCXXTHING2"));
  }

  @Test
  public void pathNotFoundThrows() throws Exception {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(containsString("Cannot find tool"));
    AppleSdkPaths appleSdkPaths =
        AppleSdkPaths.builder()
            .setDeveloperPath(Paths.get("."))
            .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
            .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
        .setName("iphoneos8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatforms.buildWithExecutableChecker(
        targetSdk,
        "7.0",
        "armv7",
        appleSdkPaths,
        new FakeBuckConfig(),
        new FakeExecutableFinder(ImmutableSet.<Path>of()));
  }

  @Test
  public void iphoneOSSimulatorPlatformSetsLinkerFlags() throws Exception {
    AppleSdkPaths appleSdkPaths = AppleSdkPaths.builder()
        .setDeveloperPath(Paths.get("."))
        .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setPlatformPath(Paths.get("Platforms/iPhoneOS.platform"))
        .setSdkPath(Paths.get("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .add(Paths.get("Tools/otest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
        .setName("iphonesimulator8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "7.0",
            "armv7",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    assertThat(
        cxxPlatform.getCflags(),
        hasItem("-mios-simulator-version-min=7.0"));
    assertThat(
        cxxPlatform.getCxxldflags(),
        hasItem("-mios-simulator-version-min=7.0"));
  }

  @Test
  public void watchOSSimulatorPlatformSetsLinkerFlags() throws Exception {
    AppleSdkPaths appleSdkPaths = AppleSdkPaths.builder()
        .setDeveloperPath(Paths.get("."))
        .addToolchainPaths(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setPlatformPath(Paths.get("Platforms/WatchSimulator.platform"))
        .setSdkPath(
            Paths.get("Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator2.0.sdk")
        )
        .build();

    ImmutableSet<Path> paths = ImmutableSet.<Path>builder()
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil"))
        .add(Paths.get("Toolchains/XcodeDefault.xctoolchain/usr/bin/strip"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/libtool"))
        .add(Paths.get("Platforms/iPhoneSimulator.platform/Developer/usr/bin/ar"))
        .add(Paths.get("usr/bin/actool"))
        .add(Paths.get("usr/bin/ibtool"))
        .add(Paths.get("usr/bin/xctest"))
        .build();

    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(Paths.get("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();

    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.WATCHSIMULATOR).build())
        .setName("watchsimulator2.0")
        .setVersion("2.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();

    AppleCxxPlatform appleCxxPlatform =
        AppleCxxPlatforms.buildWithExecutableChecker(
            targetSdk,
            "2.0",
            "armv7k",
            appleSdkPaths,
            new FakeBuckConfig(),
            new FakeExecutableFinder(paths));

    CxxPlatform cxxPlatform = appleCxxPlatform.getCxxPlatform();

    assertThat(
        cxxPlatform.getCflags(),
        hasItem("-mwatchos-simulator-version-min=2.0"));
    assertThat(
        cxxPlatform.getCxxldflags(),
        hasItem("-mwatchos-simulator-version-min=2.0"));
  }

  enum Operation {
    PREPROCESS,
    COMPILE,
    PREPROCESS_AND_COMPILE,
  }


  private ImmutableMap<Flavor, RuleKey> constructCompileRuleKeys(
      Operation operation,
      ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    String source = "source.cpp";
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("source.cpp", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxSourceRuleFactory cxxSourceRuleFactory =
          new CxxSourceRuleFactory(
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              resolver,
              pathResolver,
              entry.getValue().getCxxPlatform(),
              ImmutableList.<CxxPreprocessorInput>of(),
              ImmutableList.<String>of());
      CxxPreprocessAndCompile rule;
      switch (operation) {
        case PREPROCESS_AND_COMPILE:
          rule =
              cxxSourceRuleFactory.createPreprocessAndCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC,
                  CxxPreprocessMode.COMBINED);
          break;
        case PREPROCESS:
          rule =
              cxxSourceRuleFactory.createPreprocessBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        case COMPILE:
          rule =
              cxxSourceRuleFactory.createCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX_CPP_OUTPUT,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        default:
          throw new IllegalStateException();
      }
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }


  private ImmutableMap<Flavor, RuleKey> constructLinkRuleKeys(
      ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("input.o", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {
      BuildRule rule =
          CxxLinkableEnhancer.createCxxLinkableBuildRule(
              entry.getValue().getCxxPlatform(),
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              pathResolver,
              ImmutableList.<String>of(),
              ImmutableList.<String>of(),
              target,
              Linker.LinkType.EXECUTABLE,
              Optional.<String>absent(),
              Paths.get("output"),
              ImmutableList.<SourcePath>of(new TestSourcePath("input.o")),
              Linker.LinkableDepType.SHARED,
              ImmutableList.<BuildRule>of(),
              Optional.<Linker.CxxRuntimeType>absent(),
              Optional.<SourcePath>absent());
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }

  private AppleCxxPlatform buildAppleCxxPlatform(Path root) {
    AppleSdkPaths appleSdkPaths = AppleSdkPaths.builder()
        .setDeveloperPath(root)
        .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
        .setSdkPath(
            root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
        .build();
    AppleToolchain toolchain = AppleToolchain.builder()
        .setIdentifier("com.apple.dt.XcodeDefault")
        .setPath(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();
    AppleSdk targetSdk = AppleSdk.builder()
        .setApplePlatform(
            ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
        .setName("iphonesimulator8.0")
        .setVersion("8.0")
        .setToolchains(ImmutableList.of(toolchain))
        .build();
    return AppleCxxPlatforms.buildWithExecutableChecker(
        targetSdk,
        "7.0",
        "armv7",
        appleSdkPaths,
        new FakeBuckConfig(),
        new AlwaysFoundExecutableFinder());
  }



  @Test
  public void checkRootAndPlatformDoNotAffectRuleKeys() throws IOException {
    Map<String, ImmutableMap<Flavor, RuleKey>> preprocessAndCompileRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> preprocessRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> compileRukeKeys = Maps.newHashMap();
    Map<String, ImmutableMap<Flavor, RuleKey>> linkRukeKeys = Maps.newHashMap();



    for (String dir : ImmutableList.of("something", "something else")) {
      AppleCxxPlatform platform = buildAppleCxxPlatform(Paths.get(dir));
      preprocessAndCompileRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.PREPROCESS_AND_COMPILE,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      preprocessRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.PREPROCESS,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      compileRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructCompileRuleKeys(
              Operation.COMPILE,
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
      linkRukeKeys.put(
          String.format("AppleCxxPlatform(%s)", dir),
          constructLinkRuleKeys(
              ImmutableMap.of(platform.getCxxPlatform().getFlavor(), platform)));
    }



    assertThat(
        Arrays.toString(preprocessAndCompileRukeKeys.entrySet().toArray()),
        Sets.newHashSet(preprocessAndCompileRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(preprocessRukeKeys.entrySet().toArray()),
        Sets.newHashSet(preprocessRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(compileRukeKeys.entrySet().toArray()),
        Sets.newHashSet(compileRukeKeys.values()),
        Matchers.hasSize(1));
    assertThat(
        Arrays.toString(linkRukeKeys.entrySet().toArray()),
        Sets.newHashSet(linkRukeKeys.values()),
        Matchers.hasSize(1));

  }

}

<code block>


package com.facebook.buck.apple;

import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.testutil.integration.ProjectWorkspace;
import com.facebook.buck.testutil.integration.TestDataHelper;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class AppleSdkDiscoveryTest {

  @Rule
  public DebuggableTemporaryFolder temp = new DebuggableTemporaryFolder();

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  private AppleToolchain getDefaultToolchain(Path path) {
    return AppleToolchain.builder()
        .setIdentifier("com.apple.dt.toolchain.XcodeDefault")
        .setPath(path.resolve("Toolchains/XcodeDefault.xctoolchain"))
        .setVersion("1")
        .build();
  }

  @Test
  public void shouldReturnAnEmptyMapIfNoPlatformsFound() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-empty",
        temp);
    workspace.setUp();
    Path path = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(path)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(path),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(0, sdks.size());
  }

  @Test
  public void shouldFindPlatformsInExtraPlatformDirectories() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-minimal",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ProjectWorkspace emptyWorkspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-empty",
        temp);
    emptyWorkspace.setUp();
    Path path = emptyWorkspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(path));

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addAllToolchains(toolchains.values())
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(path)
            .addToolchainPaths(path.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(path),
            ImmutableList.of(root),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void ignoresInvalidExtraPlatformDirectories() throws IOException {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery-minimal",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    Path path = Paths.get("invalid");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addAllToolchains(toolchains.values())
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.of(path),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void shouldNotIgnoreSdkWithUnrecognizedPlatform() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-unknown-platform-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(root),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(2, sdks.size());
  }

  @Test
  public void shouldIgnoreSdkWithBadSymlink() throws Exception {
    Path root = temp.newFolder().toPath();


    File toDelete = File.createTempFile("foo", "bar");
    Path symlink = root.resolve("Platforms/Foo.platform/Developer/NonExistent1.0.sdk");
    Files.createDirectories(symlink.getParent());
    Files.createSymbolicLink(symlink, toDelete.toPath());
    assertTrue(toDelete.delete());

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root)
    );
    ImmutableMap<AppleSdk, AppleSdkPaths> sdks = AppleSdkDiscovery.discoverAppleSdkPaths(
        Optional.of(root),
        ImmutableList.<Path>of(),
        toolchains);

    assertEquals(0, sdks.size());
  }

  @Test
  public void appleSdkPathsBuiltFromDirectory() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");
    createSymLinkIosSdks(root, "8.0");
    createSymLinkWatchosSdks(root, "2.0");

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    AppleSdk iphoneos80Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.0")
            .setVersion("8.0")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
            .build();

    AppleSdk iphonesimulator80Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.0")
            .setVersion("8.0")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk"))
            .build();

    AppleSdk watchos20Sdk =
        AppleSdk.builder()
            .setName("watchos2.0")
            .setVersion("2.0")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.WATCHOS).build())
            .addArchitectures("armv7k")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths watchos20Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/WatchOS.platform"))
            .setSdkPath(root.resolve("Platforms/WatchOS.platform/Developer/SDKs/WatchOS.sdk"))
            .build();

    AppleSdk watchsimulator20Sdk =
        AppleSdk.builder()
            .setName("watchsimulator2.0")
            .setVersion("2.0")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.WATCHSIMULATOR).build())
            .addArchitectures("i386")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths watchsimulator20Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/WatchSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator.sdk"))
            .build();

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .put(iphoneos80Sdk, iphoneos80Paths)
            .put(iphoneos80Sdk.withName("iphoneos"), iphoneos80Paths)
            .put(iphonesimulator80Sdk, iphonesimulator80Paths)
            .put(iphonesimulator80Sdk.withName("iphonesimulator"), iphonesimulator80Paths)
            .put(watchos20Sdk, watchos20Paths)
            .put(watchos20Sdk.withName("watchos"), watchos20Paths)
            .put(watchsimulator20Sdk, watchsimulator20Paths)
            .put(watchsimulator20Sdk.withName("watchsimulator"), watchsimulator20Paths)
            .build();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains),
        equalTo(expected));
  }

  @Test
  public void noAppleSdksFoundIfDefaultPlatformMissing() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of();

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains).entrySet(),
        empty());
  }

  @Test
  public void multipleAppleSdkPathsPerPlatformBuiltFromDirectory() throws Exception {
    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(
        this,
        "sdk-multi-version-discovery",
        temp);
    workspace.setUp();
    Path root = workspace.getPath("");

    createSymLinkIosSdks(root, "8.1");

    AppleSdk macosx109Sdk =
        AppleSdk.builder()
            .setName("macosx10.9")
            .setVersion("10.9")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.MACOSX).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths macosx109Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/MacOSX.platform"))
            .setSdkPath(root.resolve("Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk"))
            .build();

    AppleSdk iphoneos80Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.0")
            .setVersion("8.0")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.0.sdk"))
            .build();

    AppleSdk iphonesimulator80Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.0")
            .setVersion("8.0")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator80Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk"))
            .build();

    AppleSdk iphoneos81Sdk =
        AppleSdk.builder()
            .setName("iphoneos8.1")
            .setVersion("8.1")
            .setApplePlatform(ApplePlatform.builder().setName(ApplePlatform.Name.IPHONEOS).build())
            .addArchitectures("armv7", "arm64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphoneos81Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneOS.platform"))
            .setSdkPath(root.resolve("Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"))
            .build();

    AppleSdk iphonesimulator81Sdk =
        AppleSdk.builder()
            .setName("iphonesimulator8.1")
            .setVersion("8.1")
            .setApplePlatform(
                ApplePlatform.builder().setName(ApplePlatform.Name.IPHONESIMULATOR).build())
            .addArchitectures("i386", "x86_64")
            .addToolchains(getDefaultToolchain(root))
            .build();
    AppleSdkPaths iphonesimulator81Paths =
        AppleSdkPaths.builder()
            .setDeveloperPath(root)
            .addToolchainPaths(root.resolve("Toolchains/XcodeDefault.xctoolchain"))
            .setPlatformPath(root.resolve("Platforms/iPhoneSimulator.platform"))
            .setSdkPath(
                root.resolve(
                    "Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk"))
            .build();

    ImmutableMap<AppleSdk, AppleSdkPaths> expected =
        ImmutableMap.<AppleSdk, AppleSdkPaths>builder()
            .put(macosx109Sdk, macosx109Paths)
            .put(macosx109Sdk.withName("macosx"), macosx109Paths)
            .put(iphoneos80Sdk, iphoneos80Paths)
            .put(iphonesimulator80Sdk, iphonesimulator80Paths)
            .put(iphoneos81Sdk, iphoneos81Paths)
            .put(iphoneos81Sdk.withName("iphoneos"), iphoneos81Paths)
            .put(iphonesimulator81Sdk, iphonesimulator81Paths)
            .put(iphonesimulator81Sdk.withName("iphonesimulator"), iphonesimulator81Paths)
            .build();

    ImmutableMap<String, AppleToolchain> toolchains = ImmutableMap.of(
        "com.apple.dt.toolchain.XcodeDefault",
        getDefaultToolchain(root));

    assertThat(
        AppleSdkDiscovery.discoverAppleSdkPaths(
            Optional.of(root),
            ImmutableList.<Path>of(),
            toolchains),
        equalTo(expected));
  }

  private void createSymLinkIosSdks(Path root, String version) throws IOException {
    createSymLinkSdks(ImmutableSet.of("iPhoneOS", "iPhoneSimulator"), root, version);
  }

  private void createSymLinkWatchosSdks(Path root, String version) throws IOException {
    createSymLinkSdks(ImmutableSet.of("WatchOS", "WatchSimulator"), root, version);
  }

  private void createSymLinkSdks(
      Iterable<String> sdks,
      Path root,
      String version) throws IOException {
    for (String sdk : sdks) {
      Path sdkDir = root.resolve(String.format("Platforms/%s.platform/Developer/SDKs", sdk));

      if (!Files.exists(sdkDir)) {
        continue;
      }

      Path actual = sdkDir.resolve(String.format("%s.sdk", sdk));
      Path link = sdkDir.resolve(String.format("%s%s.sdk", sdk, version));
      Files.createSymbolicLink(link, actual);
    }
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.facebook.buck.apple.clang.HeaderMap;
import com.facebook.buck.apple.xcode.GidGenerator;
import com.facebook.buck.apple.xcode.XcodeprojSerializer;
import com.facebook.buck.apple.xcode.xcodeproj.PBXAggregateTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildFile;
import com.facebook.buck.apple.xcode.xcodeproj.PBXCopyFilesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXFileReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXGroup;
import com.facebook.buck.apple.xcode.xcodeproj.PBXNativeTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXProject;
import com.facebook.buck.apple.xcode.xcodeproj.PBXReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXShellScriptBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXTarget;
import com.facebook.buck.apple.xcode.xcodeproj.ProductType;
import com.facebook.buck.apple.xcode.xcodeproj.SourceTreePath;
import com.facebook.buck.apple.xcode.xcodeproj.XCBuildConfiguration;
import com.facebook.buck.apple.xcode.xcodeproj.XCConfigurationList;
import com.facebook.buck.apple.xcode.xcodeproj.XCVersionGroup;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.IosReactNativeLibraryDescription;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuckVersion;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.parser.NoSuchBuildTargetException;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.FrameworkPath;
import com.facebook.buck.rules.coercer.SourceList;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleDescription;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import com.google.common.io.BaseEncoding;
import com.google.common.util.concurrent.UncheckedExecutionException;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ProjectGenerator {
  private static final Logger LOG = Logger.get(ProjectGenerator.class);

  public enum Option {

    USE_SHORT_NAMES_FOR_TARGETS,


    CREATE_DIRECTORY_STRUCTURE,


    GENERATE_READ_ONLY_FILES,


    INCLUDE_TESTS,
    ;
  }


  public static final ImmutableSet<Option> SEPARATED_PROJECT_OPTIONS = ImmutableSet.of(
      Option.USE_SHORT_NAMES_FOR_TARGETS);


  public static final ImmutableSet<Option> COMBINED_PROJECT_OPTIONS = ImmutableSet.of(
      Option.CREATE_DIRECTORY_STRUCTURE,
      Option.USE_SHORT_NAMES_FOR_TARGETS);

  public static final String PATH_TO_ASSET_CATALOG_COMPILER = System.getProperty(
      "buck.path_to_compile_asset_catalogs_py",
      "src/com/facebook/buck/apple/compile_asset_catalogs.py");
  public static final String PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT = System.getProperty(
      "buck.path_to_compile_asset_catalogs_build_phase_sh",
      "src/com/facebook/buck/apple/compile_asset_catalogs_build_phase.sh");
  public static final String PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT =
      System.getProperty(
          "buck.path_override_for_asset_catalog_build_phase",
          null);

  private static final FileAttribute<?> READ_ONLY_FILE_ATTRIBUTE =
    PosixFilePermissions.asFileAttribute(
        ImmutableSet.of(
            PosixFilePermission.OWNER_READ,
            PosixFilePermission.GROUP_READ,
            PosixFilePermission.OTHERS_READ));

  public static final Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> GET_EXPORTED_LINKER_FLAGS =
      new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
        @Override
        public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
          return input.getConstructorArg().exportedLinkerFlags.get();
        }
      };

  public static final Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> GET_EXPORTED_PREPROCESSOR_FLAGS =
      new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
        @Override
        public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
          return input.getConstructorArg().exportedPreprocessorFlags.get();
        }
      };

  private static final ImmutableSet<CxxSource.Type> SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES =
      ImmutableSet.of(CxxSource.Type.CXX, CxxSource.Type.OBJCXX);

  private final Function<SourcePath, Path> sourcePathResolver;
  private final TargetGraph targetGraph;
  private final ProjectFilesystem projectFilesystem;
  private final Optional<Path> reactNativeServer;
  private final Path outputDirectory;
  private final String projectName;
  private final ImmutableSet<BuildTarget> initialTargets;
  private final Path projectPath;
  private final Path placedAssetCatalogBuildPhaseScript;
  private final PathRelativizer pathRelativizer;

  private final String buildFileName;
  private final ImmutableSet<Option> options;
  private final Optional<BuildTarget> targetToBuildWithBuck;
  private final ImmutableList<String> buildWithBuckFlags;

  private ImmutableSet<TargetNode<AppleTestDescription.Arg>> testsToGenerateAsStaticLibraries =
      ImmutableSet.of();
  private ImmutableMultimap<AppleTestBundleParamsKey, TargetNode<AppleTestDescription.Arg>>
      additionalCombinedTestTargets = ImmutableMultimap.of();


  private final PBXProject project;
  private final LoadingCache<TargetNode<?>, Optional<PBXTarget>> targetNodeToProjectTarget;
  private boolean shouldPlaceAssetCatalogCompiler = false;
  private final ImmutableMultimap.Builder<TargetNode<?>, PBXTarget>
      targetNodeToGeneratedProjectTargetBuilder;
  private boolean projectGenerated;
  private final List<Path> headerSymlinkTrees;
  private final ImmutableSet.Builder<PBXTarget> buildableCombinedTestTargets =
      ImmutableSet.builder();
  private final ImmutableSet.Builder<BuildTarget> requiredBuildTargetsBuilder =
      ImmutableSet.builder();
  private final Function<? super TargetNode<?>, Path> outputPathOfNode;


  private final ImmutableSet.Builder<String> targetConfigNamesBuilder;

  private final Map<String, String> gidsToTargetNames;

  public ProjectGenerator(
      TargetGraph targetGraph,
      Set<BuildTarget> initialTargets,
      ProjectFilesystem projectFilesystem,
      Optional<Path> reactNativeServer,
      Path outputDirectory,
      String projectName,
      String buildFileName,
      Set<Option> options,
      Optional<BuildTarget> targetToBuildWithBuck,
      ImmutableList<String> buildWithBuckFlags,
      Function<? super TargetNode<?>, Path> outputPathOfNode) {
    this.sourcePathResolver = new Function<SourcePath, Path>() {
      @Override
      public Path apply(SourcePath input) {
        return resolveSourcePath(input);
      }
    };

    this.targetGraph = targetGraph;
    this.initialTargets = ImmutableSet.copyOf(initialTargets);
    this.projectFilesystem = projectFilesystem;
    this.reactNativeServer = reactNativeServer;
    this.outputDirectory = outputDirectory;
    this.projectName = projectName;
    this.buildFileName = buildFileName;
    this.options = ImmutableSet.copyOf(options);
    this.targetToBuildWithBuck = targetToBuildWithBuck;
    this.buildWithBuckFlags = buildWithBuckFlags;
    this.outputPathOfNode = outputPathOfNode;

    this.projectPath = outputDirectory.resolve(projectName + ".xcodeproj");
    this.pathRelativizer = new PathRelativizer(
        outputDirectory,
        sourcePathResolver);

    LOG.debug(
        "Output directory %s, profile fs root path %s, repo root relative to output dir %s",
        this.outputDirectory,
        projectFilesystem.getRootPath(),
        this.pathRelativizer.outputDirToRootRelative(Paths.get(".")));

    this.placedAssetCatalogBuildPhaseScript =
        BuckConstant.SCRATCH_PATH.resolve("xcode-scripts/compile_asset_catalogs_build_phase.sh");

    this.project = new PBXProject(projectName);
    this.headerSymlinkTrees = new ArrayList<>();

    this.targetNodeToGeneratedProjectTargetBuilder = ImmutableMultimap.builder();
    this.targetNodeToProjectTarget = CacheBuilder.newBuilder().build(
        new CacheLoader<TargetNode<?>, Optional<PBXTarget>>() {
          @Override
          public Optional<PBXTarget> load(TargetNode<?> key) throws Exception {
            return generateProjectTarget(key);
          }
        });

    targetConfigNamesBuilder = ImmutableSet.builder();
    gidsToTargetNames = new HashMap<>();
  }


  public ProjectGenerator setTestsToGenerateAsStaticLibraries(
      Set<TargetNode<AppleTestDescription.Arg>> set) {
    Preconditions.checkState(!projectGenerated);
    this.testsToGenerateAsStaticLibraries = ImmutableSet.copyOf(set);
    return this;
  }


  public ProjectGenerator setAdditionalCombinedTestTargets(
      Multimap<AppleTestBundleParamsKey, TargetNode<AppleTestDescription.Arg>> targets) {
    Preconditions.checkState(!projectGenerated);
    this.additionalCombinedTestTargets = ImmutableMultimap.copyOf(targets);
    return this;
  }

  @VisibleForTesting
  PBXProject getGeneratedProject() {
    return project;
  }

  @VisibleForTesting
  List<Path> getGeneratedHeaderSymlinkTrees() {
    return headerSymlinkTrees;
  }

  public Path getProjectPath() {
    return projectPath;
  }

  public ImmutableMultimap<BuildTarget, PBXTarget> getBuildTargetToGeneratedTargetMap() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    ImmutableMultimap.Builder<BuildTarget, PBXTarget> buildTargetToPbxTargetMap =
        ImmutableMultimap.builder();
    for (Map.Entry<TargetNode<?>, PBXTarget> entry :
        targetNodeToGeneratedProjectTargetBuilder.build().entries()) {
      buildTargetToPbxTargetMap.put(entry.getKey().getBuildTarget(), entry.getValue());
    }
    return buildTargetToPbxTargetMap.build();
  }

  public ImmutableSet<PBXTarget> getBuildableCombinedTestTargets() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    return buildableCombinedTestTargets.build();
  }

  public ImmutableSet<BuildTarget> getRequiredBuildTargets() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    return requiredBuildTargetsBuilder.build();
  }

  public void createXcodeProjects() throws IOException {
    LOG.debug("Creating projects for targets %s", initialTargets);

    try {
      for (TargetNode<?> targetNode : targetGraph.getNodes()) {
        if (isBuiltByCurrentProject(targetNode.getBuildTarget())) {
          LOG.debug("Including rule %s in project", targetNode);

          Optional<PBXTarget> target = targetNodeToProjectTarget.getUnchecked(targetNode);
          if (target.isPresent()) {
            targetNodeToGeneratedProjectTargetBuilder.put(targetNode, target.get());
          }
        } else {
          LOG.verbose("Excluding rule %s (not built by current project)", targetNode);
        }
      }

      if (targetToBuildWithBuck.isPresent()) {
        generateAggregateTarget(
            Preconditions.checkNotNull(targetGraph.get(targetToBuildWithBuck.get())));
      }

      int combinedTestIndex = 0;
      for (AppleTestBundleParamsKey key : additionalCombinedTestTargets.keySet()) {
        generateCombinedTestTarget(
            deriveCombinedTestTargetNameFromKey(key, combinedTestIndex++),
            key,
            additionalCombinedTestTargets.get(key));
      }

      for (String configName : targetConfigNamesBuilder.build()) {
        XCBuildConfiguration outputConfig = project
            .getBuildConfigurationList()
            .getBuildConfigurationsByName()
            .getUnchecked(configName);
        outputConfig.setBuildSettings(new NSDictionary());
      }

      writeProjectFile(project);

      if (shouldPlaceAssetCatalogCompiler) {
        Path placedAssetCatalogCompilerPath = projectFilesystem.getPathForRelativePath(
            BuckConstant.SCRATCH_PATH.resolve(
                "xcode-scripts/compile_asset_catalogs.py"));
        LOG.debug("Ensuring asset catalog is copied to path [%s]", placedAssetCatalogCompilerPath);
        projectFilesystem.createParentDirs(placedAssetCatalogCompilerPath);
        projectFilesystem.createParentDirs(placedAssetCatalogBuildPhaseScript);
        projectFilesystem.copyFile(
            Paths.get(PATH_TO_ASSET_CATALOG_COMPILER),
            placedAssetCatalogCompilerPath);
        projectFilesystem.copyFile(
            Paths.get(PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT),
            placedAssetCatalogBuildPhaseScript);
      }
      projectGenerated = true;
    } catch (UncheckedExecutionException e) {


      UncheckedExecutionException originalException = e;
      while (e.getCause() instanceof UncheckedExecutionException) {
        e = (UncheckedExecutionException) e.getCause();
      }
      if (e.getCause() instanceof HumanReadableException) {
        throw (HumanReadableException) e.getCause();
      } else {
        throw originalException;
      }
    }
  }

  private void generateAggregateTarget(TargetNode<?> targetNode) {
    final BuildTarget buildTarget = targetNode.getBuildTarget();
    ImmutableMap<String, ImmutableMap<String, String>> configs =
        getAppleNativeNode(targetGraph, targetNode).get().getConstructorArg().configs.get();
    String productName = getXcodeTargetName(buildTarget) + "-Buck";

    PBXShellScriptBuildPhase shellScriptBuildPhase = new PBXShellScriptBuildPhase();
    ImmutableList<String> command = ImmutableList
        .<String>builder()
        .add("buck")
        .add("build")
        .addAll(Iterables.transform(buildWithBuckFlags, Escaper.BASH_ESCAPER))
        .add(Escaper.escapeAsBashString(buildTarget.getFullyQualifiedName()))
        .build();

    shellScriptBuildPhase.setShellScript(Joiner.on(' ').join(command));

    XCConfigurationList configurationList = new XCConfigurationList();
    PBXGroup group = project
        .getMainGroup()
        .getOrCreateDescendantGroupByPath(
            FluentIterable
                .from(buildTarget.getBasePath())
                .transform(Functions.toStringFunction())
                .toList())
        .getOrCreateChildGroupByName(getXcodeTargetName(buildTarget));
    for (String configurationName : configs.keySet()) {
      XCBuildConfiguration configuration = configurationList
          .getBuildConfigurationsByName()
          .getUnchecked(configurationName);
      configuration.setBaseConfigurationReference(
          getConfigurationFileReference(
              group,
              getConfigurationNameToXcconfigPath(buildTarget).apply(configurationName)));

      NSDictionary inlineSettings = new NSDictionary();
      inlineSettings.put("HEADER_SEARCH_PATHS", "");
      inlineSettings.put("LIBRARY_SEARCH_PATHS", "");
      inlineSettings.put("FRAMEWORK_SEARCH_PATHS", "");
      configuration.setBuildSettings(inlineSettings);
    }

    PBXAggregateTarget aggregateTarget = new PBXAggregateTarget(productName);
    aggregateTarget.setProductName(productName);
    aggregateTarget.getBuildPhases().add(shellScriptBuildPhase);
    aggregateTarget.setBuildConfigurationList(configurationList);
    project.getTargets().add(aggregateTarget);

    targetNodeToGeneratedProjectTargetBuilder.put(targetNode, aggregateTarget);
  }

  @SuppressWarnings("unchecked")
  private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode)
      throws IOException {
    Preconditions.checkState(
        isBuiltByCurrentProject(targetNode.getBuildTarget()),
        "should not generate rule if it shouldn't be built by current project");
    Optional<PBXTarget> result = Optional.absent();
    if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      result = Optional.<PBXTarget>of(
          generateAppleLibraryTarget(
              project,
              (TargetNode<AppleNativeTargetDescriptionArg>) targetNode,
              Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      result = Optional.<PBXTarget>of(
          generateAppleBinaryTarget(
              project,
              (TargetNode<AppleNativeTargetDescriptionArg>) targetNode));
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      TargetNode<AppleBundleDescription.Arg> bundleTargetNode =
          (TargetNode<AppleBundleDescription.Arg>) targetNode;
      result = Optional.<PBXTarget>of(
          generateAppleBundleTarget(
              project,
              bundleTargetNode,
              (TargetNode<AppleNativeTargetDescriptionArg>) Preconditions.checkNotNull(
                  targetGraph.get(bundleTargetNode.getConstructorArg().binary)),
              Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
    } else if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
      TargetNode<AppleTestDescription.Arg> testTargetNode =
          (TargetNode<AppleTestDescription.Arg>) targetNode;
      Optional<TargetNode<AppleBundleDescription.Arg>> testHostBundle;
      if (testTargetNode.getConstructorArg().testHostApp.isPresent()) {
        BuildTarget testHostBundleTarget =
            testTargetNode.getConstructorArg().testHostApp.get();
        TargetNode<?> testHostBundleNode = targetGraph.get(testHostBundleTarget);
        Preconditions.checkNotNull(testHostBundleNode);
        if (testHostBundleNode.getType() != AppleBundleDescription.TYPE) {
          throw new HumanReadableException(
              "The test host target '%s' has the wrong type (%s), must be apple_bundle",
              testHostBundleTarget,
              testHostBundleNode.getType());
        }
        testHostBundle = Optional.of((TargetNode<AppleBundleDescription.Arg>) testHostBundleNode);
      } else {
        testHostBundle = Optional.absent();
      }
      if (testsToGenerateAsStaticLibraries.contains(testTargetNode)) {
        result = Optional.<PBXTarget>of(
            generateAppleLibraryTarget(
                project,
                testTargetNode,
                testHostBundle));
      } else {
        result = Optional.<PBXTarget>of(
            generateAppleBundleTarget(
                project,
                testTargetNode,
                testTargetNode,
                testHostBundle));
      }
    } else if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {




      TargetNode<AppleResourceDescription.Arg> resource =
          (TargetNode<AppleResourceDescription.Arg>) targetNode;
      AppleResourceDescription.Arg arg = resource.getConstructorArg();
      for (SourcePath dir : arg.dirs) {
        if (dir instanceof PathSourcePath &&
            !projectFilesystem.isDirectory(sourcePathResolver.apply(dir))) {
          throw new HumanReadableException(
              "%s specified in the dirs parameter of %s is not a directory",
              dir.toString(), resource.toString());
        }
      }
      for (SourcePath file : arg.files) {
        if (file instanceof PathSourcePath &&
            !projectFilesystem.isFile(sourcePathResolver.apply(file))) {
          throw new HumanReadableException(
              "%s specified in the files parameter of %s is not a regular file",
              file.toString(), resource.toString());
        }
      }
    }

    return result;
  }

  PBXNativeTarget generateAppleBundleTarget(
      PBXProject project,
      TargetNode<? extends HasAppleBundleFields> targetNode,
      TargetNode<? extends AppleNativeTargetDescriptionArg> binaryNode,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    Optional<Path> infoPlistPath;
    if (targetNode.getConstructorArg().getInfoPlist().isPresent()) {
      infoPlistPath = Optional.of(
          Preconditions.checkNotNull(
              sourcePathResolver.apply(targetNode.getConstructorArg().getInfoPlist().get())));
    } else {
      infoPlistPath = Optional.absent();
    }

    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.of(targetNode),
        binaryNode,
        bundleToTargetProductType(targetNode, binaryNode),
        "%s." + getExtensionString(targetNode.getConstructorArg().getExtension()),
        infoPlistPath,
 true,
        AppleResources.collectRecursiveResources(targetGraph, ImmutableList.of(targetNode)),
        AppleBuildRules.collectRecursiveAssetCatalogs(targetGraph, ImmutableList.of(targetNode)),
        bundleLoaderNode);


    Iterable<TargetNode<?>> copiedRules = AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
        targetGraph,
        AppleBuildRules.RecursiveDependenciesMode.COPYING,
        targetNode,
        Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES));
    generateCopyFilesBuildPhases(target, copiedRules);

    LOG.debug("Generated iOS bundle target %s", target);
    return target;
  }

  private PBXNativeTarget generateAppleBinaryTarget(
      PBXProject project,
      TargetNode<AppleNativeTargetDescriptionArg> targetNode)
      throws IOException {
    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent(),
        targetNode,
        ProductType.TOOL,
        "%s",
        Optional.<Path>absent(),
 true,
        ImmutableSet.<AppleResourceDescription.Arg>of(),
        ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent());
    LOG.debug("Generated Apple binary target %s", target);
    return target;
  }

  private PBXNativeTarget generateAppleLibraryTarget(
      PBXProject project,
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    boolean isShared = targetNode
        .getBuildTarget()
        .getFlavors()
        .contains(CxxDescriptionEnhancer.SHARED_FLAVOR);
    ProductType productType = isShared ?
        ProductType.DYNAMIC_LIBRARY :
        ProductType.STATIC_LIBRARY;
    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent(),
        targetNode,
        productType,
        AppleBuildRules.getOutputFileNameFormatForLibrary(isShared),
        Optional.<Path>absent(),
 isShared,
        ImmutableSet.<AppleResourceDescription.Arg>of(),
        ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),
        bundleLoaderNode);
    LOG.debug("Generated iOS library target %s", target);
    return target;
  }

  private PBXNativeTarget generateBinaryTarget(
      PBXProject project,
      Optional<? extends TargetNode<? extends HasAppleBundleFields>> bundle,
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      ProductType productType,
      String productOutputFormat,
      Optional<Path> infoPlistOptional,
      boolean includeFrameworks,
      ImmutableSet<AppleResourceDescription.Arg> resources,
      ImmutableSet<AppleAssetCatalogDescription.Arg> assetCatalogs,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    Optional<String> targetGid = targetNode.getConstructorArg().gid;
    LOG.debug("Generating binary target for node %s (GID %s)", targetNode, targetGid);
    if (targetGid.isPresent()) {


      String thisTargetName = targetNode.getBuildTarget().getFullyQualifiedName();
      String conflictingTargetName = gidsToTargetNames.get(targetGid.get());
      if (conflictingTargetName != null) {
        throw new HumanReadableException(
            "Targets %s have the same hardcoded GID (%s)",
            ImmutableSortedSet.of(thisTargetName, conflictingTargetName),
            targetGid.get());
      }
      gidsToTargetNames.put(targetGid.get(), thisTargetName);
    }

    TargetNode<?> buildTargetNode = bundle.isPresent() ? bundle.get() : targetNode;
    final BuildTarget buildTarget = buildTargetNode.getBuildTarget();

    String productName = getProductName(buildTarget);
    AppleNativeTargetDescriptionArg arg = targetNode.getConstructorArg();
    NewNativeTargetProjectMutator mutator = new NewNativeTargetProjectMutator(
        pathRelativizer,
        sourcePathResolver);
    ImmutableSet<SourcePath> exportedHeaders =
        ImmutableSet.copyOf(getHeaderSourcePaths(arg.exportedHeaders));
    ImmutableSet<SourcePath> headers = ImmutableSet.copyOf(getHeaderSourcePaths(arg.headers));
    mutator
        .setTargetName(getXcodeTargetName(buildTarget))
        .setProduct(
            productType,
            productName,
            Paths.get(String.format(productOutputFormat, productName)))
        .setGid(targetGid)
        .setShouldGenerateCopyHeadersPhase(
            !targetNode.getConstructorArg().getUseBuckHeaderMaps())
        .setSourcesWithFlags(ImmutableSet.copyOf(arg.srcs.get()))
        .setExtraXcodeSources(ImmutableSet.copyOf(arg.extraXcodeSources.get()))
        .setPublicHeaders(exportedHeaders)
        .setPrivateHeaders(headers)
        .setPrefixHeader(arg.prefixHeader)
        .setResources(resources);

    if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE)) {
      mutator.setTargetGroupPath(
          FluentIterable
              .from(buildTarget.getBasePath())
              .transform(Functions.toStringFunction())
              .toList());
    }

    if (!assetCatalogs.isEmpty()) {
      mutator.setAssetCatalogs(getAndMarkAssetCatalogBuildScript(), assetCatalogs);
    }

    if (includeFrameworks) {
      ImmutableSet.Builder<FrameworkPath> frameworksBuilder = ImmutableSet.builder();
      frameworksBuilder.addAll(targetNode.getConstructorArg().frameworks.get());
      frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(ImmutableList.of(targetNode)));
      mutator.setFrameworks(frameworksBuilder.build());
      mutator.setArchives(
          collectRecursiveLibraryDependencies(ImmutableList.of(targetNode)));
    }



    ImmutableList.Builder<TargetNode<?>> preScriptPhases = ImmutableList.builder();
    ImmutableList.Builder<TargetNode<?>> postScriptPhases = ImmutableList.builder();
    if (bundle.isPresent() && targetNode != bundle.get()) {
      collectBuildScriptDependencies(
          targetGraph.getAll(bundle.get().getDeclaredDeps()),
          preScriptPhases,
          postScriptPhases);
    }
    collectBuildScriptDependencies(
        targetGraph.getAll(targetNode.getDeclaredDeps()),
        preScriptPhases,
        postScriptPhases);
    mutator.setPreBuildRunScriptPhases(preScriptPhases.build());
    mutator.setPostBuildRunScriptPhases(postScriptPhases.build());
    boolean skipRNBundle = ReactNativeFlavors.skipBundling(buildTargetNode.getBuildTarget());
    mutator.skipReactNativeBundle(skipRNBundle);

    if (skipRNBundle && reactNativeServer.isPresent()) {
      mutator.setAdditionalRunScripts(
          ImmutableList.of(projectFilesystem.resolve(reactNativeServer.get())));
    }

    NewNativeTargetProjectMutator.Result targetBuilderResult;
    try {
      targetBuilderResult = mutator.buildTargetAndAddToProject(project);
    } catch (NoSuchBuildTargetException e) {
      throw new HumanReadableException(e);
    }
    PBXGroup targetGroup = targetBuilderResult.targetGroup;

    SourceTreePath buckFilePath = new SourceTreePath(
        PBXReference.SourceTree.SOURCE_ROOT,
        pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName));
    PBXFileReference buckReference =
        targetGroup.getOrCreateFileReferenceBySourceTreePath(buckFilePath);
    buckReference.setExplicitFileType(Optional.of("text.script.python"));


    ImmutableMap.Builder<String, String> extraSettingsBuilder = ImmutableMap.builder();
    extraSettingsBuilder
        .put("TARGET_NAME", getProductName(buildTarget))
        .put("SRCROOT", pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
    if (bundleLoaderNode.isPresent()) {
      TargetNode<AppleBundleDescription.Arg> bundleLoader = bundleLoaderNode.get();
      String bundleLoaderProductName = getProductName(bundleLoader.getBuildTarget());
      String bundleName = bundleLoaderProductName + "." +
          getExtensionString(bundleLoader.getConstructorArg().getExtension());
      String bundleLoaderOutputPath = Joiner.on('/').join(
          getTargetOutputPath(bundleLoader),
          bundleName,

          bundleLoaderProductName);
      extraSettingsBuilder
          .put("BUNDLE_LOADER", bundleLoaderOutputPath)
          .put("TEST_HOST", "$(BUNDLE_LOADER)");
    }
    if (infoPlistOptional.isPresent()) {
      Path infoPlistPath = pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
      extraSettingsBuilder.put("INFOPLIST_FILE", infoPlistPath.toString());
    }
    Optional<SourcePath> prefixHeaderOptional = targetNode.getConstructorArg().prefixHeader;
    if (prefixHeaderOptional.isPresent()) {
        Path prefixHeaderRelative = sourcePathResolver.apply(prefixHeaderOptional.get());
        Path prefixHeaderPath = pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
        extraSettingsBuilder.put("GCC_PREFIX_HEADER", prefixHeaderPath.toString());
        extraSettingsBuilder.put("GCC_PRECOMPILE_PREFIX_HEADER", "YES");
    }
    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      extraSettingsBuilder.put("USE_HEADERMAP", "NO");
    }

    ImmutableMap.Builder<String, String> defaultSettingsBuilder = ImmutableMap.builder();
    defaultSettingsBuilder.put(
        "REPO_ROOT",
        projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
    defaultSettingsBuilder.put("PRODUCT_NAME", getProductName(buildTarget));
    if (bundle.isPresent()) {
      defaultSettingsBuilder.put(
          "WRAPPER_EXTENSION",
          getExtensionString(bundle.get().getConstructorArg().getExtension()));
    }
    String publicHeadersPath =
        getHeaderOutputPath(buildTargetNode, targetNode.getConstructorArg().headerPathPrefix);
    LOG.debug("Public headers path for %s: %s", targetNode, publicHeadersPath);
    defaultSettingsBuilder.put("PUBLIC_HEADERS_FOLDER_PATH", publicHeadersPath);




    defaultSettingsBuilder.put(
        "BUILT_PRODUCTS_DIR",


        Joiner.on('/').join("$SYMROOT", "$CONFIGURATION$EFFECTIVE_PLATFORM_NAME"));
    defaultSettingsBuilder.put("CONFIGURATION_BUILD_DIR", "$BUILT_PRODUCTS_DIR");
    if (!bundle.isPresent() && targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      defaultSettingsBuilder.put("EXECUTABLE_PREFIX", "lib");
    }

    ImmutableMap.Builder<String, String> appendConfigsBuilder = ImmutableMap.builder();

    appendConfigsBuilder
        .put(
            "HEADER_SEARCH_PATHS",
            Joiner.on(' ').join(
                Iterables.concat(
                    collectRecursiveHeaderSearchPaths(targetNode),
                    collectRecursiveHeaderMaps(targetNode))))
        .put(
            "LIBRARY_SEARCH_PATHS",
            Joiner.on(' ').join(
                collectRecursiveLibrarySearchPaths(ImmutableSet.of(targetNode))))
        .put(
            "FRAMEWORK_SEARCH_PATHS",
            Joiner.on(' ').join(
                collectRecursiveFrameworkSearchPaths(ImmutableList.of(targetNode))))
        .put(
            "OTHER_CFLAGS",
            Joiner
                .on(' ')
                .join(
                    Iterables.concat(
                        targetNode.getConstructorArg().compilerFlags.get(),
                        targetNode.getConstructorArg().preprocessorFlags.get(),
                        collectRecursiveExportedPreprocessorFlags(ImmutableList.of(targetNode)))))
        .put(
            "OTHER_LDFLAGS",
            Joiner
                .on(' ')
                .join(
                    MoreIterables.zipAndConcat(
                        Iterables.cycle("-Xlinker"),
                        Iterables.concat(
                            targetNode.getConstructorArg().linkerFlags.get(),
                            collectRecursiveExportedLinkerFlags(ImmutableList.of(targetNode))))));

    ImmutableMap<CxxSource.Type, ImmutableList<String>> langPreprocessorFlags =
        targetNode.getConstructorArg().langPreprocessorFlags.get();

    Sets.SetView<CxxSource.Type> unsupportedLangPreprocessorFlags =
        Sets.difference(langPreprocessorFlags.keySet(), SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES);

    if (!unsupportedLangPreprocessorFlags.isEmpty()) {
      throw new HumanReadableException(
          "%s: Xcode project generation does not support specified lang_preprocessor_flags keys: " +
          "%s",
          buildTarget,
          unsupportedLangPreprocessorFlags);
    }

    ImmutableSet.Builder<String> allCxxFlagsBuilder = ImmutableSet.builder();
    ImmutableList<String> cxxFlags = langPreprocessorFlags.get(CxxSource.Type.CXX);
    if (cxxFlags != null) {
      allCxxFlagsBuilder.addAll(cxxFlags);
    }
    ImmutableList<String> objcxxFlags = langPreprocessorFlags.get(CxxSource.Type.OBJCXX);
    if (objcxxFlags != null) {
      allCxxFlagsBuilder.addAll(objcxxFlags);
    }
    ImmutableSet<String> allCxxFlags = allCxxFlagsBuilder.build();
    if (!allCxxFlags.isEmpty()) {
      appendConfigsBuilder.put(
          "OTHER_CPLUSPLUSFLAGS",
          Joiner.on(' ').join(allCxxFlags));
    }

    PBXNativeTarget target = targetBuilderResult.target;

    setTargetBuildConfigurations(
        getConfigurationNameToXcconfigPath(buildTarget),
        target,
        targetGroup,
        targetNode.getConstructorArg().configs.get(),
        extraSettingsBuilder.build(),
        defaultSettingsBuilder.build(),
        appendConfigsBuilder.build());


    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      Path headerPathPrefix =
          AppleDescriptions.getHeaderPathPrefix(arg, targetNode.getBuildTarget());
      createHeaderSymlinkTree(
          sourcePathResolver,
          AppleDescriptions.convertAppleHeadersToPublicCxxHeaders(
              sourcePathResolver,
              headerPathPrefix,
              arg),
          AppleDescriptions.getPathToHeaderSymlinkTree(targetNode, HeaderVisibility.PUBLIC).get());
      createHeaderSymlinkTree(
          sourcePathResolver,
          AppleDescriptions.convertAppleHeadersToPrivateCxxHeaders(
              sourcePathResolver,
              headerPathPrefix,
              arg),
          AppleDescriptions.getPathToHeaderSymlinkTree(targetNode, HeaderVisibility.PRIVATE).get());
    }


    addCoreDataModelBuildPhase(
        targetGroup,
        FluentIterable
            .from(targetNode.getDeps())
            .transform(
                new Function<BuildTarget, TargetNode<?>>() {
                  @Override
                  public TargetNode<?> apply(BuildTarget input) {
                    return Preconditions.checkNotNull(targetGraph.get(input));
                  }
                })
            .filter(
                new Predicate<TargetNode<?>>() {
                  @Override
                  public boolean apply(TargetNode<?> input) {
                    return CoreDataModelDescription.TYPE.equals(input.getType());
                  }
                })
            .transform(
                new Function<TargetNode<?>, CoreDataModelDescription.Arg>() {
                  @Override
                  public CoreDataModelDescription.Arg apply(TargetNode<?> input) {
                    return (CoreDataModelDescription.Arg) input.getConstructorArg();
                  }
                })
            .toSet());

    return target;
  }

  private Function<String, Path> getConfigurationNameToXcconfigPath(final BuildTarget buildTarget) {
    return new Function<String, Path>() {
      @Override
      public Path apply(String input) {
        return BuildTargets.getGenPath(buildTarget, "%s-" + input + ".xcconfig");
      }
    };
  }

  private Iterable<SourcePath> getHeaderSourcePaths(
      Optional<SourceList> headers) {
    if (!headers.isPresent()) {
      return ImmutableList.of();
    } else if (headers.get().getUnnamedSources().isPresent()) {
      return headers.get().getUnnamedSources().get();
    } else {
      return headers.get().getNamedSources().get().values();
    }
  }

  private void generateCombinedTestTarget(
      final String productName,
      AppleTestBundleParamsKey key,
      ImmutableCollection<TargetNode<AppleTestDescription.Arg>> tests)
      throws IOException {
    ImmutableSet.Builder<PBXFileReference> testLibs = ImmutableSet.builder();
    for (TargetNode<AppleTestDescription.Arg> test : tests) {
      testLibs.add(getOrCreateTestLibraryFileReference(test));
    }
    NewNativeTargetProjectMutator mutator = new NewNativeTargetProjectMutator(
        pathRelativizer,
        sourcePathResolver)
        .setTargetName(productName)
        .setProduct(
            dylibProductTypeByBundleExtension(key.getExtension().getLeft()).get(),
            productName,
            Paths.get(productName + "." + getExtensionString(key.getExtension())))
        .setShouldGenerateCopyHeadersPhase(false)
        .setSourcesWithFlags(
            ImmutableSet.of(
                SourceWithFlags.of(
                    new PathSourcePath(projectFilesystem, emptyFileWithExtension("c")))))
        .setArchives(Sets.union(collectRecursiveLibraryDependencies(tests), testLibs.build()))
        .setResources(AppleResources.collectRecursiveResources(targetGraph, tests))
        .setAssetCatalogs(
            getAndMarkAssetCatalogBuildScript(),
            AppleBuildRules.collectRecursiveAssetCatalogs(targetGraph, tests));

    ImmutableSet.Builder<FrameworkPath> frameworksBuilder = ImmutableSet.builder();
    frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(tests));
    for (TargetNode<AppleTestDescription.Arg> test : tests) {
      frameworksBuilder.addAll(test.getConstructorArg().frameworks.get());
    }
    mutator.setFrameworks(frameworksBuilder.build());

    NewNativeTargetProjectMutator.Result result;
    try {
      result = mutator.buildTargetAndAddToProject(project);
    } catch (NoSuchBuildTargetException e) {
      throw new HumanReadableException(e);
    }

    ImmutableMap.Builder<String, String> overrideBuildSettingsBuilder =
        ImmutableMap.<String, String>builder()
            .put("GCC_PREFIX_HEADER", "")
            .put("USE_HEADERMAP", "NO");
    if (key.getInfoPlist().isPresent()) {
      overrideBuildSettingsBuilder.put(
          "INFOPLIST_FILE",
          pathRelativizer.outputDirToRootRelative(
                sourcePathResolver.apply(key.getInfoPlist().get())).toString());
    }
    setTargetBuildConfigurations(
        new Function<String, Path>() {
          @Override
          public Path apply(String input) {
            return outputDirectory.resolve(
                String.format("xcconfigs/%s-%s.xcconfig", productName, input));
          }
        },
        result.target,
        result.targetGroup,
        key.getConfigs().get(),
        overrideBuildSettingsBuilder.build(),
        ImmutableMap.of(
            "PRODUCT_NAME", productName,
            "WRAPPER_EXTENSION", getExtensionString(key.getExtension())),
        ImmutableMap.of(
            "FRAMEWORK_SEARCH_PATHS",
            Joiner.on(' ').join(collectRecursiveFrameworkSearchPaths(tests)),
            "LIBRARY_SEARCH_PATHS",
            Joiner.on(' ').join(collectRecursiveLibrarySearchPaths(tests)),
            "OTHER_LDFLAGS",
            Joiner.on(' ').join(
                MoreIterables.zipAndConcat(
                    Iterables.cycle("-Xlinker"),
                    Iterables.concat(
                        key.getLinkerFlags(),
                        collectRecursiveExportedLinkerFlags(tests))))));
    buildableCombinedTestTargets.add(result.target);
  }

  private String deriveCombinedTestTargetNameFromKey(
      AppleTestBundleParamsKey key,
      int combinedTestIndex) {
    return Joiner.on("-").join(
        "_BuckCombinedTest",
        getExtensionString(key.getExtension()),
        combinedTestIndex);

  }


  private void setTargetBuildConfigurations(
      Function<String, Path> configurationNameToXcconfigPath,
      PBXTarget target,
      PBXGroup targetGroup,
      ImmutableMap<String, ImmutableMap<String, String>> configurations,
      ImmutableMap<String, String> overrideBuildSettings,
      ImmutableMap<String, String> defaultBuildSettings,
      ImmutableMap<String, String> appendBuildSettings)
      throws IOException {

    for (Map.Entry<String, ImmutableMap<String, String>> configurationEntry :
        configurations.entrySet()) {
      targetConfigNamesBuilder.add(configurationEntry.getKey());

      ImmutableMap<String, String> targetLevelInlineSettings =
          configurationEntry.getValue();

      XCBuildConfiguration outputConfiguration = target
          .getBuildConfigurationList()
          .getBuildConfigurationsByName()
          .getUnchecked(configurationEntry.getKey());

      HashMap<String, String> combinedOverrideConfigs = Maps.newHashMap(overrideBuildSettings);
      for (Map.Entry<String, String> entry: defaultBuildSettings.entrySet()) {
        String existingSetting = targetLevelInlineSettings.get(entry.getKey());
        if (existingSetting == null) {
          combinedOverrideConfigs.put(entry.getKey(), entry.getValue());
        }
      }

      for (Map.Entry<String, String> entry : appendBuildSettings.entrySet()) {
        String existingSetting = targetLevelInlineSettings.get(entry.getKey());
        String settingPrefix = existingSetting != null ? existingSetting : "$(inherited)";
        combinedOverrideConfigs.put(entry.getKey(), settingPrefix + " " + entry.getValue());
      }

      Iterable<Map.Entry<String, String>> entries = Iterables.concat(
          targetLevelInlineSettings.entrySet(),
          combinedOverrideConfigs.entrySet());

      Path xcconfigPath = configurationNameToXcconfigPath.apply(configurationEntry.getKey());
      projectFilesystem.mkdirs(Preconditions.checkNotNull(xcconfigPath).getParent());

      StringBuilder stringBuilder = new StringBuilder();
      for (Map.Entry<String, String> entry : entries) {
        stringBuilder.append(entry.getKey());
        stringBuilder.append(" = ");
        stringBuilder.append(entry.getValue());
        stringBuilder.append('\n');
      }
      String xcconfigContents = stringBuilder.toString();

      if (MorePaths.fileContentsDiffer(
          new ByteArrayInputStream(xcconfigContents.getBytes(Charsets.UTF_8)),
          xcconfigPath,
          projectFilesystem)) {
        if (shouldGenerateReadOnlyFiles()) {
          projectFilesystem.writeContentsToPath(
              xcconfigContents,
              xcconfigPath,
              READ_ONLY_FILE_ATTRIBUTE);
        } else {
          projectFilesystem.writeContentsToPath(
              xcconfigContents,
              xcconfigPath);
        }
      }

      PBXFileReference fileReference = getConfigurationFileReference(targetGroup, xcconfigPath);
      outputConfiguration.setBaseConfigurationReference(fileReference);
    }
  }

  private PBXFileReference getConfigurationFileReference(PBXGroup targetGroup, Path xcconfigPath) {
    return targetGroup
        .getOrCreateChildGroupByName("Configurations")
        .getOrCreateFileReferenceBySourceTreePath(
            new SourceTreePath(
                PBXReference.SourceTree.SOURCE_ROOT,
                pathRelativizer.outputDirToRootRelative(xcconfigPath)));
  }

  private void collectBuildScriptDependencies(
      Iterable<TargetNode<?>> targetNodes,
      ImmutableList.Builder<TargetNode<?>> preRules,
      ImmutableList.Builder<TargetNode<?>> postRules) {
    for (TargetNode<?> targetNode : targetNodes) {
      BuildRuleType type = targetNode.getType();
      if (type.equals(XcodePostbuildScriptDescription.TYPE) ||
          type.equals(IosReactNativeLibraryDescription.TYPE)) {
        postRules.add(targetNode);
      } else if (
          type.equals(XcodePrebuildScriptDescription.TYPE) ||
          type.equals(GenruleDescription.TYPE)) {
        preRules.add(targetNode);
      }
    }
  }

  private void createHeaderSymlinkTree(
      Function<SourcePath, Path> pathResolver,
      Map<String, SourcePath> contents,
      Path headerSymlinkTreeRoot) throws IOException {
    LOG.verbose(
        "Building header symlink tree at %s with contents %s",
        headerSymlinkTreeRoot,
        contents);
    ImmutableSortedMap.Builder<Path, Path> resolvedContentsBuilder =
        ImmutableSortedMap.naturalOrder();
    for (Map.Entry<String, SourcePath> entry : contents.entrySet()) {
      Path link = headerSymlinkTreeRoot.resolve(entry.getKey());
      Path existing = projectFilesystem.resolve(pathResolver.apply(entry.getValue()));
      resolvedContentsBuilder.put(link, existing);
    }
    ImmutableSortedMap<Path, Path> resolvedContents = resolvedContentsBuilder.build();

    Path headerMapLocation = getHeaderMapLocationFromSymlinkTreeRoot(headerSymlinkTreeRoot);

    Path hashCodeFilePath = headerSymlinkTreeRoot.resolve(".contents-hash");
    Optional<String> currentHashCode = projectFilesystem.readFileIfItExists(hashCodeFilePath);
    String newHashCode = getHeaderSymlinkTreeHashCode(resolvedContents).toString();
    if (Optional.of(newHashCode).equals(currentHashCode)) {
      LOG.debug(
          "Symlink tree at %s is up to date, not regenerating (key %s).",
          headerSymlinkTreeRoot,
          newHashCode);
    } else {
      LOG.debug(
          "Updating symlink tree at %s (old key %s, new key %s).",
          headerSymlinkTreeRoot,
          currentHashCode,
          newHashCode);
      projectFilesystem.deleteRecursivelyIfExists(headerSymlinkTreeRoot);
      projectFilesystem.mkdirs(headerSymlinkTreeRoot);
      for (Map.Entry<Path, Path> entry : resolvedContents.entrySet()) {
        Path link = entry.getKey();
        Path existing = entry.getValue();
        projectFilesystem.createParentDirs(link);
        projectFilesystem.createSymLink(link, existing,  false);
      }
      projectFilesystem.writeContentsToPath(newHashCode, hashCodeFilePath);

      HeaderMap.Builder headerMapBuilder = new HeaderMap.Builder();
      for (Map.Entry<String, SourcePath> entry : contents.entrySet()) {
        headerMapBuilder.add(
            entry.getKey(),
            projectFilesystem.resolve(headerSymlinkTreeRoot).resolve(entry.getKey()));
      }
      projectFilesystem.writeBytesToPath(headerMapBuilder.build().getBytes(), headerMapLocation);
    }
    headerSymlinkTrees.add(headerSymlinkTreeRoot);
  }

  private HashCode getHeaderSymlinkTreeHashCode(ImmutableSortedMap<Path, Path> contents) {
    Hasher hasher = Hashing.sha1().newHasher();
    hasher.putBytes(BuckVersion.getVersion().getBytes(Charsets.UTF_8));
    for (Map.Entry<Path, Path> entry : contents.entrySet()) {
      byte[] key = entry.getKey().toString().getBytes(Charsets.UTF_8);
      byte[] value = entry.getValue().toString().getBytes(Charsets.UTF_8);
      hasher.putInt(key.length);
      hasher.putBytes(key);
      hasher.putInt(value.length);
      hasher.putBytes(value);
    }
    return hasher.hash();
  }

  private void addCoreDataModelBuildPhase(
      PBXGroup targetGroup,
      Iterable<CoreDataModelDescription.Arg> dataModels) throws IOException {


    for (final CoreDataModelDescription.Arg dataModel : dataModels) {

      PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");

      if (CoreDataModelDescription.isVersionedDataModel(dataModel)) {




        final String currentVersionFileName = ".xccurrentversion";
        final String currentVersionKey = "_XCCurrentVersionName";

        final XCVersionGroup versionGroup =
            resourcesGroup.getOrCreateChildVersionGroupsBySourceTreePath(
                new SourceTreePath(
                    PBXReference.SourceTree.SOURCE_ROOT,
                    pathRelativizer.outputDirToRootRelative(dataModel.path)));

        projectFilesystem.walkRelativeFileTree(
            dataModel.path,
            new SimpleFileVisitor<Path>() {
              @Override
              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                if (dir.equals(dataModel.path)) {
                  return FileVisitResult.CONTINUE;
                }
                versionGroup.getOrCreateFileReferenceBySourceTreePath(
                    new SourceTreePath(
                        PBXReference.SourceTree.SOURCE_ROOT,
                        pathRelativizer.outputDirToRootRelative(dir)));
                return FileVisitResult.SKIP_SUBTREE;
              }
            });

        Path currentVersionPath = dataModel.path.resolve(currentVersionFileName);
        try (InputStream in = projectFilesystem.newFileInputStream(currentVersionPath)) {
          NSObject rootObject;
          try {
            rootObject = PropertyListParser.parse(in);
          } catch (IOException e) {
            throw e;
          } catch (Exception e) {
            rootObject = null;
          }
          if (!(rootObject instanceof NSDictionary)) {
            throw new HumanReadableException("Malformed %s file.", currentVersionFileName);
          }
          NSDictionary rootDictionary = (NSDictionary) rootObject;
          NSObject currentVersionName = rootDictionary.objectForKey(currentVersionKey);
          if (!(currentVersionName instanceof NSString)) {
            throw new HumanReadableException("Malformed %s file.", currentVersionFileName);
          }
          PBXFileReference ref = versionGroup.getOrCreateFileReferenceBySourceTreePath(
              new SourceTreePath(
                  PBXReference.SourceTree.SOURCE_ROOT,
                  pathRelativizer.outputDirToRootRelative(
                      dataModel.path.resolve(currentVersionName.toString()))));
          versionGroup.setCurrentVersion(Optional.of(ref));
        } catch (NoSuchFileException e) {
          if (versionGroup.getChildren().size() == 1) {
            versionGroup.setCurrentVersion(Optional.of(Iterables.get(
                        versionGroup.getChildren(),
                        0)));
          }
        }
      } else {
        resourcesGroup.getOrCreateFileReferenceBySourceTreePath(
            new SourceTreePath(
                PBXReference.SourceTree.SOURCE_ROOT,
                pathRelativizer.outputDirToRootRelative(dataModel.path)));
      }
    }
  }

  private Optional<PBXCopyFilesBuildPhase.Destination> getDestination(TargetNode<?> targetNode) {
    if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      AppleBundleDescription.Arg arg = (AppleBundleDescription.Arg) targetNode.getConstructorArg();
      AppleBundleExtension extension = arg.extension.isLeft() ?
          arg.extension.getLeft() :
          AppleBundleExtension.BUNDLE;
      switch (extension) {
        case FRAMEWORK:
          return Optional.of(PBXCopyFilesBuildPhase.Destination.FRAMEWORKS);
        case APPEX:
        case PLUGIN:
          return Optional.of(PBXCopyFilesBuildPhase.Destination.PLUGINS);
        case APP:
          return Optional.of(PBXCopyFilesBuildPhase.Destination.EXECUTABLES);

      default:
          return Optional.of(PBXCopyFilesBuildPhase.Destination.PRODUCTS);
      }
    } else if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      if (targetNode
          .getBuildTarget()
          .getFlavors()
          .contains(CxxDescriptionEnhancer.SHARED_FLAVOR)) {
        return Optional.of(PBXCopyFilesBuildPhase.Destination.FRAMEWORKS);
      } else {
        return Optional.absent();
      }
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      return Optional.of(PBXCopyFilesBuildPhase.Destination.EXECUTABLES);
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }
  }

  private void generateCopyFilesBuildPhases(
      PBXNativeTarget target,
      Iterable<TargetNode<?>> copiedNodes) {


    ImmutableSetMultimap.Builder<PBXCopyFilesBuildPhase.Destination, TargetNode<?>>
        ruleByDestinationBuilder = ImmutableSetMultimap.builder();
    for (TargetNode<?> copiedNode : copiedNodes) {
      Optional<PBXCopyFilesBuildPhase.Destination> optionalDestination =
          getDestination(copiedNode);
      if (optionalDestination.isPresent()) {
        ruleByDestinationBuilder.put(optionalDestination.get(), copiedNode);
      }
    }
    ImmutableSetMultimap<PBXCopyFilesBuildPhase.Destination, TargetNode<?>> ruleByDestination =
        ruleByDestinationBuilder.build();


    for (PBXCopyFilesBuildPhase.Destination destination : ruleByDestination.keySet()) {
      PBXCopyFilesBuildPhase copyFilesBuildPhase = new PBXCopyFilesBuildPhase(destination, "");
      target.getBuildPhases().add(copyFilesBuildPhase);
      for (TargetNode<?> targetNode : ruleByDestination.get(destination)) {
        PBXFileReference fileReference = getLibraryFileReference(targetNode);
        copyFilesBuildPhase.getFiles().add(new PBXBuildFile(fileReference));
      }
    }
  }


  private Path writeProjectFile(PBXProject project) throws IOException {
    XcodeprojSerializer serializer = new XcodeprojSerializer(
        new GidGenerator(ImmutableSet.copyOf(gidsToTargetNames.keySet())),
        project);
    NSDictionary rootObject = serializer.toPlist();
    Path xcodeprojDir = outputDirectory.resolve(projectName + ".xcodeproj");
    projectFilesystem.mkdirs(xcodeprojDir);
    Path serializedProject = xcodeprojDir.resolve("project.pbxproj");
    String contentsToWrite = rootObject.toXMLPropertyList();

    if (MorePaths.fileContentsDiffer(
            new ByteArrayInputStream(contentsToWrite.getBytes(Charsets.UTF_8)),
            serializedProject,
            projectFilesystem)) {
      LOG.debug("Regenerating project at %s", serializedProject);
      if (shouldGenerateReadOnlyFiles()) {
        projectFilesystem.writeContentsToPath(
            contentsToWrite,
            serializedProject,
            READ_ONLY_FILE_ATTRIBUTE);
      } else {
        projectFilesystem.writeContentsToPath(
            contentsToWrite,
            serializedProject);
      }
    } else {
      LOG.debug("Not regenerating project at %s (contents have not changed)", serializedProject);
    }
    return xcodeprojDir;
  }

  private static String getProductName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  private String getHeaderOutputPath(
      TargetNode<?> buildTargetNode,
      Optional<String> headerPathPrefix) {

    return Joiner.on('/').join(
        getBuiltProductsRelativeTargetOutputPath(buildTargetNode),
        "Headers",
        headerPathPrefix.or("$TARGET_NAME"));
  }


  private Path getHeaderSymlinkTreeRelativePath(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      HeaderVisibility headerVisibility) {
    Optional<Path> treeRoot = AppleDescriptions.getPathToHeaderSymlinkTree(
        targetNode,
        headerVisibility);
    Preconditions.checkState(
        treeRoot.isPresent(),
        "%s does not have a header symlink tree.",
        targetNode);
    return pathRelativizer.outputDirToRootRelative(treeRoot.get());
  }

  private Path getHeaderMapLocationFromSymlinkTreeRoot(Path headerSymlinkTreeRoot) {
    return headerSymlinkTreeRoot.resolve(".tree.hmap");
  }

  private String getHeaderSearchPath(TargetNode<?> targetNode) {
    return Joiner.on('/').join(
        getTargetOutputPath(targetNode),
        "Headers");
  }

  private String getBuiltProductsRelativeTargetOutputPath(TargetNode<?> targetNode) {
    if (targetNode.getType().equals(AppleBinaryDescription.TYPE) ||
        targetNode.getType().equals(AppleTestDescription.TYPE) ||
        (targetNode.getType().equals(AppleBundleDescription.TYPE) &&
            !isFrameworkBundle((AppleBundleDescription.Arg) targetNode.getConstructorArg()))) {



      return ".";
    } else {
      return BaseEncoding
          .base32()
          .omitPadding()
          .encode(targetNode.getBuildTarget().getFullyQualifiedName().getBytes());
    }
  }

  private String getTargetOutputPath(TargetNode<?> targetNode) {
    return Joiner.on('/').join(
        "$BUILT_PRODUCTS_DIR",
        getBuiltProductsRelativeTargetOutputPath(targetNode));
  }

  @SuppressWarnings("unchecked")
  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getAppleNativeNodeOfType(
      TargetGraph targetGraph,
      TargetNode<?> targetNode,
      Set<BuildRuleType> nodeTypes,
      Set<AppleBundleExtension> bundleExtensions) {
    Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode = Optional.absent();
    if (nodeTypes.contains(targetNode.getType())) {
      nativeNode = Optional.of((TargetNode<AppleNativeTargetDescriptionArg>) targetNode);
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      TargetNode<AppleBundleDescription.Arg> bundle =
          (TargetNode<AppleBundleDescription.Arg>) targetNode;
      Either<AppleBundleExtension, String> extension = bundle.getConstructorArg().getExtension();
      if (extension.isLeft() && bundleExtensions.contains(extension.getLeft())) {
        nativeNode = Optional.of(
            Preconditions.checkNotNull(
                (TargetNode<AppleNativeTargetDescriptionArg>) targetGraph.get(
                    bundle.getConstructorArg().binary)));
      }
    }
    return nativeNode;
  }

  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getAppleNativeNode(
      TargetGraph targetGraph,
      TargetNode<?> targetNode) {
    return getAppleNativeNodeOfType(
        targetGraph,
        targetNode,
        ImmutableSet.of(
            AppleBinaryDescription.TYPE,
            AppleLibraryDescription.TYPE),
        ImmutableSet.of(
            AppleBundleExtension.APP,
            AppleBundleExtension.FRAMEWORK));
  }

  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getLibraryNode(
      TargetGraph targetGraph,
      TargetNode<?> targetNode) {
    return getAppleNativeNodeOfType(
        targetGraph,
        targetNode,
        ImmutableSet.of(
            AppleLibraryDescription.TYPE),
        ImmutableSet.of(
            AppleBundleExtension.FRAMEWORK));
  }

  private ImmutableSet<String> collectRecursiveHeaderSearchPaths(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    LOG.debug("Collecting recursive header search paths for %s...", targetNode);
    return FluentIterable
        .from(
            AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.BUILDING,
                targetNode,
                Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES)))
        .filter(
            new Predicate<TargetNode<?>>() {
              @Override
              public boolean apply(TargetNode<?> input) {
                Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
                    getAppleNativeNode(targetGraph, input);
                return nativeNode.isPresent() &&
                    !nativeNode.get().getConstructorArg().getUseBuckHeaderMaps();
              }
            })
        .transform(
            new Function<TargetNode<?>, String>() {
              @Override
              public String apply(TargetNode<?> input) {
                String result = getHeaderSearchPath(input);
                LOG.debug("Header search path for %s: %s", input, result);
                return result;
              }
            })
        .toSet();
  }

  private ImmutableSet<Path> collectRecursiveHeaderMaps(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();

    for (Path headerSymlinkTreePath : collectRecursiveHeaderSymlinkTrees(targetNode)) {
      builder.add(getHeaderMapLocationFromSymlinkTreeRoot(headerSymlinkTreePath));
    }

    return builder.build();
  }

  private ImmutableSet<Path> collectRecursiveHeaderSymlinkTrees(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();

    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      builder.add(getHeaderSymlinkTreeRelativePath(targetNode, HeaderVisibility.PRIVATE));
      builder.add(getHeaderSymlinkTreeRelativePath(targetNode, HeaderVisibility.PUBLIC));
    }

    for (TargetNode<?> input :
        AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
            targetGraph,
            AppleBuildRules.RecursiveDependenciesMode.BUILDING,
            targetNode,
            Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))) {
      Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
          getAppleNativeNode(targetGraph, input);
      if (nativeNode.isPresent() && nativeNode.get().getConstructorArg().getUseBuckHeaderMaps()) {
        builder.add(
            getHeaderSymlinkTreeRelativePath(
                nativeNode.get(),
                HeaderVisibility.PUBLIC));
      }
    }

    addHeaderSymlinkTreesForSourceUnderTest(targetNode, builder, HeaderVisibility.PRIVATE);

    return builder.build();
  }

  private void addHeaderSymlinkTreesForSourceUnderTest(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      ImmutableSet.Builder<Path> headerSymlinkTreesBuilder,
      HeaderVisibility headerVisibility) {
    ImmutableSet<TargetNode<?>> directDependencies = ImmutableSet.copyOf(
        targetGraph.getAll(targetNode.getDeps()));
    for (TargetNode<?> dependency : directDependencies) {
      Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
          getAppleNativeNode(targetGraph, dependency);
      if (nativeNode.isPresent() &&
          isSourceUnderTest(dependency, nativeNode.get(), targetNode) &&
          nativeNode.get().getConstructorArg().getUseBuckHeaderMaps()) {
        headerSymlinkTreesBuilder.add(
            getHeaderSymlinkTreeRelativePath(
                nativeNode.get(),
                headerVisibility));
      }
    }
  }

  private boolean isSourceUnderTest(
      TargetNode<?> dependencyNode,
      TargetNode<AppleNativeTargetDescriptionArg> nativeNode,
      TargetNode<?> testNode) {
    boolean isSourceUnderTest =
        nativeNode.getConstructorArg().getTests().contains(testNode.getBuildTarget());

    if (dependencyNode != nativeNode && dependencyNode.getConstructorArg() instanceof HasTests) {
      ImmutableSortedSet<BuildTarget> tests =
          ((HasTests) dependencyNode.getConstructorArg()).getTests();
      if (tests.contains(testNode.getBuildTarget())) {
        isSourceUnderTest = true;
      }
    }

    return isSourceUnderTest;
  }

  private <T> ImmutableSet<String> collectRecursiveLibrarySearchPaths(
      Iterable<TargetNode<T>> targetNodes) {
    return new ImmutableSet.Builder<String>()
        .add("$BUILT_PRODUCTS_DIR")
        .addAll(
            collectRecursiveSearchPathsForFrameworkPaths(
                targetNodes,
                FrameworkPath.FrameworkType.LIBRARY))
        .build();
  }

  private <T> ImmutableSet<String> collectRecursiveFrameworkSearchPaths(
      Iterable<TargetNode<T>> targetNodes) {
    return new ImmutableSet.Builder<String>()
        .add("$BUILT_PRODUCTS_DIR")
        .addAll(
            collectRecursiveSearchPathsForFrameworkPaths(
                targetNodes,
                FrameworkPath.FrameworkType.FRAMEWORK))
        .build();
  }

  private <T> Iterable<FrameworkPath> collectRecursiveFrameworkDependencies(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<FrameworkPath>>() {
              @Override
              public Iterable<FrameworkPath> apply(TargetNode<?> input) {
                Optional<TargetNode<AppleNativeTargetDescriptionArg>> library =
                    getLibraryNode(targetGraph, input);
                if (library.isPresent() &&
                    !AppleLibraryDescription.isSharedLibraryTarget(
                        library.get().getBuildTarget())) {
                  return library.get().getConstructorArg().frameworks.get();
                } else {
                  return ImmutableList.of();
                }
              }
            });
  }

  private <T> Iterable<String> collectRecursiveSearchPathsForFrameworkPaths(
      Iterable<TargetNode<T>> targetNodes,
      final FrameworkPath.FrameworkType type) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<String>>() {
              @Override
              public Iterable<String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(getTargetFrameworkSearchPaths(type))
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> Iterable<String> collectRecursiveExportedPreprocessorFlags(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.BUILDING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<? extends String>>() {
              @Override
              public Iterable<? extends String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(GET_EXPORTED_PREPROCESSOR_FLAGS)
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> Iterable<String> collectRecursiveExportedLinkerFlags(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<? extends String>>() {
              @Override
              public Iterable<String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(GET_EXPORTED_LINKER_FLAGS)
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> ImmutableSet<PBXFileReference> collectRecursiveLibraryDependencies(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))
        .filter(getLibraryWithSourcesToCompilePredicate())
        .transform(
            new Function<TargetNode<?>, PBXFileReference>() {
              @Override
              public PBXFileReference apply(TargetNode<?> input) {
                return getLibraryFileReference(input);
              }
            }).toSet();
  }

  private Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> getTargetFrameworkSearchPaths(final FrameworkPath.FrameworkType type) {

    final Predicate<FrameworkPath> byType = Predicates.compose(
        Predicates.equalTo(type),
        FrameworkPath.getFrameworkTypeFunction(sourcePathResolver));

    final Function<FrameworkPath, Path> toSearchPath = FrameworkPath
        .getUnexpandedSearchPathFunction(
            sourcePathResolver,
            pathRelativizer.outputDirToRootRelative());

    return new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
      @Override
      public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
        return FluentIterable
            .from(input.getConstructorArg().frameworks.get())
            .filter(byType)
            .transform(toSearchPath)
            .transform(Functions.toStringFunction());
      }
    };
  }

  private SourceTreePath getProductsSourceTreePath(TargetNode<?> targetNode) {
    String productName = getProductName(targetNode.getBuildTarget());
    String productOutputName;

    if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      String productOutputFormat = AppleBuildRules.getOutputFileNameFormatForLibrary(
          targetNode
              .getBuildTarget()
              .getFlavors()
              .contains(CxxDescriptionEnhancer.SHARED_FLAVOR));
      productOutputName = String.format(productOutputFormat, productName);
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE) ||
        targetNode.getType().equals(AppleTestDescription.TYPE)) {
      HasAppleBundleFields arg = (HasAppleBundleFields) targetNode.getConstructorArg();
      productOutputName = productName + "." + getExtensionString(arg.getExtension());
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      productOutputName = productName;
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }

    return new SourceTreePath(
        PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
        Paths.get(productOutputName));
  }

  private PBXFileReference getLibraryFileReference(TargetNode<?> targetNode) {


    SourceTreePath productsPath = getProductsSourceTreePath(targetNode);

    if (targetNode.getType().equals(AppleLibraryDescription.TYPE) ||
        targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      return project.getMainGroup()
          .getOrCreateChildGroupByName("Frameworks")
          .getOrCreateFileReferenceBySourceTreePath(productsPath);
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      return project.getMainGroup()
          .getOrCreateChildGroupByName("Dependencies")
          .getOrCreateFileReferenceBySourceTreePath(productsPath);
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }
  }


  private PBXFileReference getOrCreateTestLibraryFileReference(
      TargetNode<AppleTestDescription.Arg> test) {
    SourceTreePath path = new SourceTreePath(
        PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
        Paths.get(getBuiltProductsRelativeTargetOutputPath(test)).resolve(
            String.format(
                AppleBuildRules.getOutputFileNameFormatForLibrary(false),
                getProductName(test.getBuildTarget()))));
    return project.getMainGroup()
        .getOrCreateChildGroupByName("Test Libraries")
        .getOrCreateFileReferenceBySourceTreePath(path);
  }


  private boolean isBuiltByCurrentProject(BuildTarget buildTarget) {
    return initialTargets.contains(buildTarget);
  }

  private String getXcodeTargetName(BuildTarget target) {
    return options.contains(Option.USE_SHORT_NAMES_FOR_TARGETS)
        ? target.getShortName()
        : target.getFullyQualifiedName();
  }

  @SuppressWarnings("incomplete-switch")
  ProductType bundleToTargetProductType(
      TargetNode<? extends HasAppleBundleFields> targetNode,
      TargetNode<? extends AppleNativeTargetDescriptionArg> binaryNode) {
    if (targetNode.getConstructorArg().getXcodeProductType().isPresent()) {
      return ProductType.of(targetNode.getConstructorArg().getXcodeProductType().get());
    } else if (targetNode.getConstructorArg().getExtension().isLeft()) {
      AppleBundleExtension extension = targetNode.getConstructorArg().getExtension().getLeft();

      if (binaryNode.getType().equals(AppleLibraryDescription.TYPE)) {
        if (binaryNode.getBuildTarget().getFlavors().contains(
            CxxDescriptionEnhancer.SHARED_FLAVOR)) {
          Optional<ProductType> productType =
              dylibProductTypeByBundleExtension(extension);
          if (productType.isPresent()) {
            return productType.get();
          }
        } else {
          switch (extension) {
            case FRAMEWORK:
              return ProductType.STATIC_FRAMEWORK;
          }
        }
      } else if (binaryNode.getType().equals(AppleBinaryDescription.TYPE)) {
        switch (extension) {
          case APP:
            return ProductType.APPLICATION;
        }
      } else if (binaryNode.getType().equals(AppleTestDescription.TYPE)) {
        switch (extension) {
          case OCTEST:
            return ProductType.BUNDLE;
          case XCTEST:
            return ProductType.UNIT_TEST;
        }
      }
    }

    return ProductType.BUNDLE;
  }

  private boolean shouldGenerateReadOnlyFiles() {
    return options.contains(Option.GENERATE_READ_ONLY_FILES);
  }

  private static String getExtensionString(Either<AppleBundleExtension, String> extension) {
    return extension.isLeft() ? extension.getLeft().toFileExtension() : extension.getRight();
  }

  private static boolean isFrameworkBundle(HasAppleBundleFields arg) {
    return arg.getExtension().isLeft() &&
        arg.getExtension().getLeft().equals(AppleBundleExtension.FRAMEWORK);
  }


  private Path getAndMarkAssetCatalogBuildScript() {
    if (PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT != null) {
      return Paths.get(PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT);
    } else {


      shouldPlaceAssetCatalogCompiler = true;
      return placedAssetCatalogBuildPhaseScript;
    }
  }

  private Path emptyFileWithExtension(String extension) {
    Path path = BuckConstant.GEN_PATH.resolve("xcode-scripts/emptyFile." + extension);
    if (!projectFilesystem.exists(path)) {
      try {
        projectFilesystem.createParentDirs(path);
        projectFilesystem.newFileOutputStream(path).close();
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
    return path;
  }

  private Path resolveSourcePath(SourcePath sourcePath) {
    if (sourcePath instanceof PathSourcePath) {
      return ((PathSourcePath) sourcePath).getRelativePath();
    }
    Preconditions.checkArgument(sourcePath instanceof BuildTargetSourcePath);
    BuildTargetSourcePath buildTargetSourcePath = (BuildTargetSourcePath) sourcePath;
    BuildTarget buildTarget = buildTargetSourcePath.getTarget();
    TargetNode<?> node = Preconditions.checkNotNull(targetGraph.get(buildTarget));
    Optional<TargetNode<ExportFileDescription.Arg>> exportFileNode = node.castArg(
        ExportFileDescription.Arg.class);
    if (!exportFileNode.isPresent()) {
      Path output = outputPathOfNode.apply(node);
      if (output == null) {
        throw new HumanReadableException(
            "The target '%s' does not have an output.",
            node.getBuildTarget());
      }
      requiredBuildTargetsBuilder.add(buildTarget);
      return output;
    }

    Optional<SourcePath> src = exportFileNode.get().getConstructorArg().src;
    if (!src.isPresent()) {
      return buildTarget.getBasePath().resolve(buildTarget.getShortNameAndFlavorPostfix());
    }

    return resolveSourcePath(src.get());
  }

  private Predicate<TargetNode<?>> getLibraryWithSourcesToCompilePredicate() {
    return new Predicate<TargetNode<?>>() {
      @Override
      public boolean apply(TargetNode<?> input) {
        Optional<TargetNode<AppleNativeTargetDescriptionArg>> library =
            getLibraryNode(targetGraph, input);
        if (!library.isPresent()) {
          return false;
        }
        return (library.get().getConstructorArg().srcs.get().size() != 0);
      }
    };
  }


  private static Optional<ProductType> dylibProductTypeByBundleExtension(
      AppleBundleExtension extension) {
    switch (extension) {
      case FRAMEWORK:
        return Optional.of(ProductType.FRAMEWORK);
      case APPEX:
        return Optional.of(ProductType.APP_EXTENSION);
      case BUNDLE:
        return Optional.of(ProductType.BUNDLE);
      case OCTEST:
        return Optional.of(ProductType.BUNDLE);
      case XCTEST:
        return Optional.of(ProductType.UNIT_TEST);

      default:
        return Optional.absent();
    }
  }
}

<code block>


package com.facebook.buck.apple.xcode.xcodeproj;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractProductType {
  public static final ProductType STATIC_LIBRARY = ProductType.of(
      "com.apple.product-type.library.static");
  public static final ProductType DYNAMIC_LIBRARY = ProductType.of(
      "com.apple.product-type.library.dynamic");
  public static final ProductType TOOL = ProductType.of(
      "com.apple.product-type.tool");
  public static final ProductType BUNDLE = ProductType.of(
      "com.apple.product-type.bundle");
  public static final ProductType FRAMEWORK = ProductType.of(
      "com.apple.product-type.framework");
  public static final ProductType STATIC_FRAMEWORK = ProductType.of(
      "com.apple.product-type.framework.static");
  public static final ProductType APPLICATION = ProductType.of(
      "com.apple.product-type.application");
  public static final ProductType UNIT_TEST = ProductType.of(
      "com.apple.product-type.bundle.unit-test");
  public static final ProductType APP_EXTENSION = ProductType.of(
      "com.apple.product-type.app-extension");

  @Value.Parameter
  public abstract String getIdentifier();

  @Override
  public String toString() {
    return getIdentifier();
  }
}

<code block>


package com.facebook.buck.apple.xcode.xcodeproj;

import com.facebook.buck.apple.xcode.XcodeprojSerializer;

public class PBXCopyFilesBuildPhase extends PBXBuildPhase {

  public enum Destination {
    ABSOLUTE(0),
    WRAPPER(1),
    EXECUTABLES(6),
    RESOURCES(7),
    FRAMEWORKS(10),
    SHARED_FRAMEWORKS(11),
    SHARED_SUPPORT(12),
    PLUGINS(13),
    JAVA_RESOURCES(15),
    PRODUCTS(16),
    ;

    private int value;

    public int getValue() {
      return value;
    }

    private Destination(int value) {
      this.value = value;
    }
  }


  private Destination dstSubfolderSpec;


  private String path;

  public PBXCopyFilesBuildPhase(Destination dstSubfolderSpec, String path) {
    this.dstSubfolderSpec = dstSubfolderSpec;
    this.path = path;
  }

  public Destination getDstSubfolderSpec() {
    return dstSubfolderSpec;
  }

  public String getPath() {
    return path;
  }

  @Override
  public String isa() {
    return "PBXCopyFilesBuildPhase";
  }

  @Override
  public void serializeInto(XcodeprojSerializer s) {
    super.serializeInto(s);
    s.addField("dstSubfolderSpec", dstSubfolderSpec.getValue());
    s.addField("dstPath", path);
  }
}

<code block>


package com.facebook.buck.apple;

import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertHasSingletonCopyFilesPhaseWithFileEntries;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertHasSingletonFrameworksPhaseWithFrameworkEntries;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertTargetExistsAndReturnTarget;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.getSingletonPhaseByType;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.endsWith;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.dd.plist.NSDictionary;
import com.dd.plist.NSString;
import com.facebook.buck.apple.clang.HeaderMap;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildFile;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXFileReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXGroup;
import com.facebook.buck.apple.xcode.xcodeproj.PBXHeadersBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXProject;
import com.facebook.buck.apple.xcode.xcodeproj.PBXReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXResourcesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXShellScriptBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXSourcesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXVariantGroup;
import com.facebook.buck.apple.xcode.xcodeproj.ProductType;
import com.facebook.buck.apple.xcode.xcodeproj.SourceTreePath;
import com.facebook.buck.apple.xcode.xcodeproj.XCBuildConfiguration;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.IosReactNativeLibraryBuilder;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.FrameworkPath;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.ExportFileBuilder;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.AllExistingProjectFilesystem;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.facebook.buck.timing.SettableFakeClock;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.io.ByteStreams;

import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;

public class ProjectGeneratorTest {

  private static final Path OUTPUT_DIRECTORY = Paths.get("_gen");
  private static final String PROJECT_NAME = "GeneratedProject";
  private static final String PROJECT_CONTAINER = PROJECT_NAME + ".xcodeproj";
  private static final Path OUTPUT_PROJECT_BUNDLE_PATH =
      OUTPUT_DIRECTORY.resolve(PROJECT_CONTAINER);
  private static final Path OUTPUT_PROJECT_FILE_PATH =
      OUTPUT_PROJECT_BUNDLE_PATH.resolve("project.pbxproj");

  private SettableFakeClock clock;
  private ProjectFilesystem projectFilesystem;
  private FakeProjectFilesystem fakeProjectFilesystem;

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws IOException {
    clock = new SettableFakeClock(0, 0);
    fakeProjectFilesystem = new FakeProjectFilesystem(clock);
    projectFilesystem = fakeProjectFilesystem;


    projectFilesystem.writeContentsToPath(
        "",
        Paths.get(ProjectGenerator.PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get(ProjectGenerator.PATH_TO_ASSET_CATALOG_COMPILER));


    projectFilesystem.createParentDirs(Paths.get("foodir", "foo.png"));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get("foodir", "foo.png"));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get("bar.png"));
    fakeProjectFilesystem.touch(Paths.get("Base.lproj", "Bar.storyboard"));
  }

  @Test
  public void testProjectStructureForEmptyProject() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    projectGenerator.createXcodeProjects();

    Optional<String> pbxproj = projectFilesystem.readFileIfItExists(OUTPUT_PROJECT_FILE_PATH);
    assertTrue(pbxproj.isPresent());
  }

  @Test
  public void testCreateDirectoryStructure() throws IOException {
    BuildTarget buildTarget1 = BuildTarget.builder("//foo/bar", "target1").build();
    TargetNode<?> node1 = AppleLibraryBuilder.createBuilder(buildTarget1).build();

    BuildTarget buildTarget2 = BuildTarget.builder("//foo/foo", "target2").build();
    TargetNode<?> node2 = AppleLibraryBuilder.createBuilder(buildTarget2).build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node1, node2),
        ImmutableSet.of(
            ProjectGenerator.Option.CREATE_DIRECTORY_STRUCTURE,
            ProjectGenerator.Option.USE_SHORT_NAMES_FOR_TARGETS));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup mainGroup = project.getMainGroup();

    PBXGroup groupFoo = null;
    for (PBXReference reference : mainGroup.getChildren()) {
      if (reference instanceof PBXGroup && "foo".equals(reference.getName())) {
        groupFoo = (PBXGroup) reference;
      }
    }
    assertNotNull("Project should have a group called foo", groupFoo);

    assertEquals("foo", groupFoo.getName());
    assertThat(groupFoo.getChildren(), hasSize(2));

    PBXGroup groupFooBar = (PBXGroup) Iterables.get(groupFoo.getChildren(), 0);
    assertEquals("bar", groupFooBar.getName());
    assertThat(groupFooBar.getChildren(), hasSize(1));

    PBXGroup groupFooFoo = (PBXGroup) Iterables.get(groupFoo.getChildren(), 1);
    assertEquals("foo", groupFooFoo.getName());
    assertThat(groupFooFoo.getChildren(), hasSize(1));

    PBXGroup groupFooBarTarget1 = (PBXGroup) Iterables.get(groupFooBar.getChildren(), 0);
    assertEquals("target1", groupFooBarTarget1.getName());

    PBXGroup groupFooFooTarget2 = (PBXGroup) Iterables.get(groupFooFoo.getChildren(), 0);
    assertEquals("target2", groupFooFooTarget2.getName());
  }

  @Test
  public void shouldNotCreateHeaderSymlinkTreesWhenTheyAreDisabled() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/foo.h")))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();


    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(0));
  }

  @Test
  public void testLibraryHeaderGroupsWithHeaderSymlinkTrees() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/foo.h"),
                new TestSourcePath("HeaderGroup2/baz.h")))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(buildTarget.getFullyQualifiedName());
    PBXGroup sourcesGroup = targetGroup.getOrCreateChildGroupByName("Sources");

    assertThat(sourcesGroup.getChildren(), hasSize(2));

    PBXGroup group1 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 0);
    assertEquals("HeaderGroup1", group1.getName());
    assertThat(group1.getChildren(), hasSize(2));
    PBXFileReference fileRefFoo = (PBXFileReference) Iterables.get(group1.getChildren(), 0);
    assertEquals("bar.h", fileRefFoo.getName());
    PBXFileReference fileRefBar = (PBXFileReference) Iterables.get(group1.getChildren(), 1);
    assertEquals("foo.h", fileRefBar.getName());

    PBXGroup group2 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 1);
    assertEquals("HeaderGroup2", group2.getName());
    assertThat(group2.getChildren(), hasSize(1));
    PBXFileReference fileRefBaz = (PBXFileReference) Iterables.get(group2.getChildren(), 0);
    assertEquals("baz.h", fileRefBaz.getName());


    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:lib");
    assertEquals(
        Optional.<PBXBuildPhase>absent(),
        Iterables.tryFind(
            target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
              @Override
              public boolean apply(PBXBuildPhase input) {
                return input instanceof PBXHeadersBuildPhase;
              }
            }));

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-public-header-symlink-tree",
        headerSymlinkTrees.get(0).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-public-header-symlink-tree"),
        ImmutableMap.of("lib/bar.h", "HeaderGroup1/bar.h"));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.<String, String>builder()
            .put("lib/foo.h", "HeaderGroup1/foo.h")
            .put("lib/baz.h", "HeaderGroup2/baz.h")
            .put("foo.h", "HeaderGroup1/foo.h")
            .put("bar.h", "HeaderGroup1/bar.h")
            .put("baz.h", "HeaderGroup2/baz.h")
            .build());
  }

  @Test
  public void testLibraryHeaderGroupsWithMappedHeaders() throws IOException {
    BuildTarget privateGeneratedTarget = BuildTarget.builder("//foo", "generated1.h").build();
    BuildTarget publicGeneratedTarget = BuildTarget.builder("//foo", "generated2.h").build();

    TargetNode<?> privateGeneratedNode =
        ExportFileBuilder.newExportFileBuilder(privateGeneratedTarget).build();
    TargetNode<?> publicGeneratedNode =
        ExportFileBuilder.newExportFileBuilder(publicGeneratedTarget).build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "any/name.h", new TestSourcePath("HeaderGroup1/foo.h"),
                "different/name.h", new TestSourcePath("HeaderGroup2/baz.h"),
                "one/more/name.h", new BuildTargetSourcePath(privateGeneratedTarget)))
        .setExportedHeaders(
            ImmutableMap.<String, SourcePath>of(
                "yet/another/name.h", new TestSourcePath("HeaderGroup1/bar.h"),
                "and/one/more.h", new BuildTargetSourcePath(publicGeneratedTarget)))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node, privateGeneratedNode, publicGeneratedNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(buildTarget.getFullyQualifiedName());
    PBXGroup sourcesGroup = targetGroup.getOrCreateChildGroupByName("Sources");

    assertThat(sourcesGroup.getChildren(), hasSize(3));

    PBXGroup group1 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 0);
    assertEquals("HeaderGroup1", group1.getName());
    assertThat(group1.getChildren(), hasSize(2));
    PBXFileReference fileRefFoo = (PBXFileReference) Iterables.get(group1.getChildren(), 0);
    assertEquals("bar.h", fileRefFoo.getName());
    PBXFileReference fileRefBar = (PBXFileReference) Iterables.get(group1.getChildren(), 1);
    assertEquals("foo.h", fileRefBar.getName());

    PBXGroup group2 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 1);
    assertEquals("HeaderGroup2", group2.getName());
    assertThat(group2.getChildren(), hasSize(1));
    PBXFileReference fileRefBaz = (PBXFileReference) Iterables.get(group2.getChildren(), 0);
    assertEquals("baz.h", fileRefBaz.getName());

    PBXGroup group3 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 2);
    assertEquals("foo", group3.getName());
    assertThat(group3.getChildren(), hasSize(2));
    PBXFileReference fileRefGenerated1 = (PBXFileReference) Iterables.get(group3.getChildren(), 0);
    assertEquals("generated1.h", fileRefGenerated1.getName());
    PBXFileReference fileRefGenerated2 = (PBXFileReference) Iterables.get(group3.getChildren(), 1);
    assertEquals("generated2.h", fileRefGenerated2.getName());


    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:lib");
    assertEquals(
        Optional.<PBXBuildPhase>absent(),
        Iterables.tryFind(
            target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
              @Override
              public boolean apply(PBXBuildPhase input) {
                return input instanceof PBXHeadersBuildPhase;
              }
            }));

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-public-header-symlink-tree",
        headerSymlinkTrees.get(0).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-public-header-symlink-tree"),
        ImmutableMap.of(
            "yet/another/name.h", "HeaderGroup1/bar.h",
            "and/one/more.h", "foo/generated2.h"));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of(
            "any/name.h", "HeaderGroup1/foo.h",
            "different/name.h", "HeaderGroup2/baz.h",
            "one/more/name.h", "foo/generated1.h"));
  }

  @Test
  public void testHeaderSymlinkTreesAreRegeneratedWhenKeyChanges() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "value.h"));

    node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "new-key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertFalse(
        projectFilesystem.isSymLink(
            Paths.get(
                "buck-out/gen/foo/lib-private-header-symlink-tree/key.h")));
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("new-key.h", "value.h"));
  }

  @Test
  public void testHeaderSymlinkTreesAreRegeneratedWhenValueChanges() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "value.h"));

    node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("new-value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "new-value.h"));
  }

  @Test
  public void testHeaderSymlinkTreesWithHeadersVisibleForTesting() throws IOException {
    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested library in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  @Test
  public void testHeaderSymlinkTreesWithTestsAndLibraryBundles() throws IOException {
    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setBinary(libraryTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(bundleTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, bundleNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested library in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  @Test
  public void testHeaderSymlinkTreesWithTestsAndBinaryBundles() throws IOException {
    BuildTarget binaryTarget = BuildTarget.builder("//foo", "bin").build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setBinary(binaryTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(bundleTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(binaryNode, bundleNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested binary in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/bin-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/bin-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  private void assertThatHeaderSymlinkTreeContains(Path root, ImmutableMap<String, String> content)
      throws IOException {
    for (Map.Entry<String, String> entry : content.entrySet()) {
      Path link = root.resolve(Paths.get(entry.getKey()));
      Path target = Paths.get(entry.getValue()).toAbsolutePath();
      assertTrue(projectFilesystem.isSymLink(link));
      assertEquals(
          target,
          projectFilesystem.readSymLink(link));
    }


    byte[] headerMapBytes;
    try (InputStream headerMapInputStream =
             projectFilesystem.newFileInputStream(root.resolve(".tree.hmap"))) {
      headerMapBytes = ByteStreams.toByteArray(headerMapInputStream);
    }
    HeaderMap headerMap = HeaderMap.deserialize(headerMapBytes);
    assertNotNull(headerMap);
    assertThat(headerMap.getNumEntries(), equalTo(content.size()));
    for (String key : content.keySet()) {
      assertThat(
          headerMap.lookup(key),
          equalTo(projectFilesystem.resolve(root).resolve(key).toString()));
    }
  }

  @Test
  public void testAppleLibraryRule() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")),
                    SourceWithFlags.of(new TestSourcePath("bar.m")))))
        .setExtraXcodeSources(
            Optional.of(
                ImmutableList.<SourcePath>of(
                    new TestSourcePath("libsomething.a"))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(new TestSourcePath("foo.h")))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    assertHasConfigurations(target, "Debug");
    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target, ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "bar.m", Optional.<String>absent(),
            "libsomething.a", Optional.<String>absent()));


    {
      PBXBuildPhase headersBuildPhase =
          Iterables.find(target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
            @Override
            public boolean apply(PBXBuildPhase input) {
              return input instanceof PBXHeadersBuildPhase;
            }
          });
      PBXBuildFile headerBuildFile = Iterables.getOnlyElement(headersBuildPhase.getFiles());

      String headerBuildFilePath = assertFileRefIsRelativeAndResolvePath(
          headerBuildFile.getFileRef());
      assertEquals(
          projectFilesystem.getRootPath().resolve("foo.h").toAbsolutePath().normalize().toString(),
          headerBuildFilePath);
    }


    assertFalse(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void testAppleLibraryConfiguresOutputPaths() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .setPrefixHeader(Optional.<SourcePath>of(new TestSourcePath("Foo/Foo-Prefix.pch")))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "../Foo/Foo-Prefix.pch",
        settings.get("GCC_PREFIX_HEADER"));
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWM33PHJWGSYQ/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleFrameworkConfiguresPublicHeaderPaths() throws IOException {
    BuildTarget libTarget = BuildTarget.builder("//foo", "lib")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libNode = AppleLibraryBuilder
        .createBuilder(libTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget frameworkTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> frameworkNode = AppleBundleBuilder
        .createBuilder(frameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(libTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(libNode, frameworkNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget frameworkPbxTarget = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bundle");
    assertEquals(frameworkPbxTarget.getProductType(), ProductType.FRAMEWORK);
    assertThat(frameworkPbxTarget.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference frameworkProductReference = frameworkPbxTarget.getProductReference();
    assertEquals("bundle.framework", frameworkProductReference.getName());
    assertEquals(Optional.of("wrapper.framework"), frameworkProductReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(
        frameworkTarget, frameworkPbxTarget, "Debug");
    assertEquals("framework", settings.get("WRAPPER_EXTENSION"));
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWM33PHJRHK3TENRSQ/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryConfiguresSharedLibraryOutputPaths() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//hi", "lib")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//hi:lib#shared");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.DYNAMIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWQ2J2NRUWEI3TNBQXEZLE/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryDoesntOverrideHeaderOutputPath() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.of("PUBLIC_HEADERS_FOLDER_PATH", "FooHeaders"))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "FooHeaders",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryCompilerAndPreprocessorFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setCompilerFlags(Optional.of(ImmutableList.of("-fhello")))
        .setPreprocessorFlags(Optional.of(ImmutableList.of("-fworld")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -fhello -fworld", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryCompilerAndPreprocessorFlagsDontPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setCompilerFlags(Optional.of(ImmutableList.of("-fhello")))
        .setPreprocessorFlags(Optional.of(ImmutableList.of("-fworld")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) ", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedPreprocessorFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedPreprocessorFlags(Optional.of(ImmutableList.of("-DHELLO")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -DHELLO", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedPreprocessorFlagsPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedPreprocessorFlags(Optional.of(ImmutableList.of("-DHELLO")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -DHELLO", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryLinkerFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryLinkerFlagsDontPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) ", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedLinkerFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedLinkerFlagsPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testConfigurationSerializationWithoutExistingXcconfig() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.of("CUSTOM_SETTING", "VALUE"))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    assertHasConfigurations(target, "Debug");
    XCBuildConfiguration configuration = target
        .getBuildConfigurationList().getBuildConfigurationsByName().asMap().get("Debug");
    assertEquals(configuration.getBuildSettings().count(), 0);

    PBXFileReference xcconfigReference = configuration.getBaseConfigurationReference();
    assertEquals(xcconfigReference.getPath(), "../buck-out/gen/foo/lib-Debug.xcconfig");

    ImmutableMap<String, String> settings = getBuildSettings(
        buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "VALUE",
        settings.get("CUSTOM_SETTING"));
  }

  @Test
  public void testAppleLibraryDependentsSearchHeadersAndLibraries() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs =
        ImmutableSortedMap.of(
            "Debug", ImmutableMap.<String, String>of());

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryDependentsInheritSearchPaths() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "USER_HEADER_SEARCH_PATHS", "user_headers",
            "LIBRARY_SEARCH_PATHS", "libraries",
            "FRAMEWORK_SEARCH_PATHS", "frameworks"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "user_headers",
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "frameworks $BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryTransitiveDependentsSearchHeadersAndLibraries() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug", ImmutableMap.<String, String>of());

    BuildTarget libraryDepTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> libraryDepNode = AppleLibraryBuilder
        .createBuilder(libraryDepTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryDepTarget)))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryDepNode, libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR/F4XWEYLSHJWGSYQ/Headers " +
            "$BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryWithoutSources() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "LIBRARY_SEARCH_PATHS", "libraries"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));

    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of("fooTest.m", Optional.<String>absent()));

    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$SDKROOT/Library.framework"));
  }

  @Test
  public void testAppleLibraryWithoutSourcesWithHeaders() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "LIBRARY_SEARCH_PATHS", "libraries"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));

    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of("fooTest.m", Optional.<String>absent()));

    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$SDKROOT/Library.framework"));
  }

  @Test
  public void testAppleTestRule() throws IOException {
    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(testNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");
    assertEquals(target.getProductType(), ProductType.UNIT_TEST);
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("xctest.xctest", productReference.getName());
  }

  @Test
  public void testAppleBinaryRule() throws IOException {
    BuildTarget depTarget = BuildTarget.builder("//dep", "dep").build();
    TargetNode<?> depNode = AppleLibraryBuilder
        .createBuilder(depTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget binaryTarget = BuildTarget.builder("//foo", "binary").build();
    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")))))
        .setExtraXcodeSources(
            Optional.of(
                ImmutableList.<SourcePath>of(
                    new TestSourcePath("libsomething.a"))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("foo.h")))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Foo.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(depTarget)))
        .setGid(Optional.<String>absent())
        .setHeaderPathPrefix(Optional.<String>absent())
        .setUseBuckHeaderMaps(Optional.of(false))
        .setPrefixHeader(Optional.<SourcePath>absent())
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(depNode, binaryNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:binary");
    assertHasConfigurations(target, "Debug");
    assertEquals(target.getProductType(), ProductType.TOOL);
    assertEquals("Should have exact number of build phases", 3, target.getBuildPhases().size());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "libsomething.a", Optional.<String>absent()));
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$SDKROOT/Foo.framework",

            "$BUILT_PRODUCTS_DIR/libdep.a"));



    assertFalse(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void testAppleBundleRuleWithPreBuildScriptDependency() throws IOException {
    BuildTarget scriptTarget = BuildTarget.builder("//foo", "pre_build_script").build();
    TargetNode<?> scriptNode = XcodePrebuildScriptBuilder
        .createBuilder(scriptTarget)
        .setCmd("script.sh")
        .build();

    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of())
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(scriptTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(scriptNode, resourceNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("script.sh"));


    assertThat(
        target.getBuildPhases().get(0),
        instanceOf(PBXShellScriptBuildPhase.class));

    assertThat(
        target.getBuildPhases().get(1),
        instanceOf(PBXResourcesBuildPhase.class));
  }

  @Test
  public void testAppleBundleRuleWithPostBuildScriptDependency() throws IOException {
    BuildTarget scriptTarget = BuildTarget.builder("//foo", "post_build_script").build();
    TargetNode<?> scriptNode = XcodePostbuildScriptBuilder
        .createBuilder(scriptTarget)
        .setCmd("script.sh")
        .build();

    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of())
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(scriptTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(scriptNode, resourceNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("script.sh"));


    assertThat(
        target.getBuildPhases().get(0),
        instanceOf(PBXResourcesBuildPhase.class));

    assertThat(
        target.getBuildPhases().get(1),
        instanceOf(PBXShellScriptBuildPhase.class));
  }

  @Test
  public void testAppleBundleRuleWithRNLibraryDependency() throws IOException {
    BuildTarget rnLibraryTarget = BuildTarget.builder("//foo", "rn_library").build();
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(new FakeBuckConfig(
        ImmutableMap.of("react-native", ImmutableMap.of("packager", "react-native/packager.sh")),
        filesystem));
    TargetNode<?>  rnLibraryNode = IosReactNativeLibraryBuilder
        .builder(rnLibraryTarget, buckConfig)
        .setBundleName("Apps/Foo/FooBundle.js")
        .setEntryPath(new PathSourcePath(filesystem, Paths.get("js/FooApp.js")))
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(rnLibraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(rnLibraryNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        startsWith("BASE_DIR="));
  }

  @Test
  public void testNoBundleFlavoredAppleBundleRuleWithRNLibraryDependency() throws IOException {
    BuildTarget rnLibraryTarget = BuildTarget.builder("//foo", "rn_library").build();
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(new FakeBuckConfig(
        ImmutableMap.of("react-native", ImmutableMap.of("packager", "react-native/packager.sh")),
        filesystem));
    TargetNode<?>  rnLibraryNode = IosReactNativeLibraryBuilder
        .builder(rnLibraryTarget, buckConfig)
        .setBundleName("Apps/Foo/FooBundle.js")
        .setEntryPath(new PathSourcePath(filesystem, Paths.get("js/FooApp.js")))
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle")
        .addFlavors(ReactNativeFlavors.DO_NOT_BUNDLE)
        .build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(rnLibraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(rnLibraryNode, sharedLibraryNode, bundleNode),
        ImmutableSet.<ProjectGenerator.Option>of(),
        Optional.of(Paths.get("js/react-native/runServer.sh")));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle#rn_no_bundle");
    assertThat(target.getName(), equalTo("//foo:bundle#rn_no_bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    Iterator<PBXShellScriptBuildPhase> phases = Iterables.filter(
        target.getBuildPhases(),
        PBXShellScriptBuildPhase.class).iterator();

    assertThat(phases.hasNext(), is(true));
    assertThat(
        phases.next().getShellScript(),
        containsString("rm -rf ${JS_OUT}"));

    assertThat(phases.hasNext(), is(true));
    assertThat(
        phases.next().getShellScript(),
        endsWith("js/react-native/runServer.sh"));

    assertThat(phases.hasNext(), is(false));
  }

  @Test
  public void testAppleBundleRuleForSharedLibraryFramework() throws IOException {
    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> node = AppleBundleBuilder
        .createBuilder(buildTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(sharedLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(sharedLibraryNode, node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:bundle");
    assertEquals(target.getProductType(), ProductType.FRAMEWORK);
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("bundle.framework", productReference.getName());
    assertEquals(Optional.of("wrapper.framework"), productReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "framework",
        settings.get("WRAPPER_EXTENSION"));
  }

  @Test
  public void testAppleResourceWithVariantGroupSetsFileTypeBasedOnPath() throws IOException {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of())
        .setDirs(ImmutableSet.<SourcePath>of())
        .setVariants(
            Optional.<Set<SourcePath>>of(
                ImmutableSet.<SourcePath>of(
                    new TestSourcePath("Base.lproj/Bar.storyboard"))))
        .build();
    BuildTarget fooLibraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooLibraryNode = AppleLibraryBuilder
        .createBuilder(fooLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(fooLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooLibraryNode, bundleNode, resourceNode),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(bundleTarget.getFullyQualifiedName());
    PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");
    PBXVariantGroup storyboardGroup = (PBXVariantGroup) Iterables.get(
        resourcesGroup.getChildren(),
        0);
    List<PBXReference> storyboardGroupChildren = storyboardGroup.getChildren();
    assertEquals(1, storyboardGroupChildren.size());
    assertTrue(storyboardGroupChildren.get(0) instanceof PBXFileReference);
    PBXFileReference baseStoryboardReference = (PBXFileReference) storyboardGroupChildren.get(0);

    assertEquals("Base", baseStoryboardReference.getName());


    assertEquals(Optional.of("file.storyboard"), baseStoryboardReference.getLastKnownFileType());
    assertEquals(Optional.<String>absent(), baseStoryboardReference.getExplicitFileType());
  }

  @Test
  public void testAppleBundleRuleWithCustomXcodeProductType() throws IOException {
    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "custombundle").build();
    TargetNode<?> node = AppleBundleBuilder
        .createBuilder(buildTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(sharedLibraryTarget)
        .setXcodeProductType(Optional.of("com.facebook.buck.niftyProductType"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(sharedLibraryNode, node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:custombundle");
    assertEquals(
        target.getProductType(),
        ProductType.of("com.facebook.buck.niftyProductType"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("custombundle.framework", productReference.getName());
    assertEquals(Optional.of("wrapper.framework"), productReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "framework",
        settings.get("WRAPPER_EXTENSION"));
  }

  @Test
  public void testCoreDataModelRuleAddsReference() throws IOException {
    BuildTarget modelTarget = BuildTarget.builder("//foo", "model").build();
    TargetNode<?> modelNode = CoreDataModelBuilder
        .createBuilder(modelTarget)
        .setPath(new TestSourcePath("foo.xcdatamodel").getRelativePath())
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(modelTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(modelNode, libraryNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(libraryTarget.getFullyQualifiedName());
    PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");

    assertThat(resourcesGroup.getChildren(), hasSize(1));

    PBXFileReference modelReference = (PBXFileReference) Iterables.get(
        resourcesGroup.getChildren(),
        0);
    assertEquals("foo.xcdatamodel", modelReference.getName());
  }

  @Test
  public void ruleToTargetMapContainsPBXTarget() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")),
                    SourceWithFlags.of(new TestSourcePath("bar.m")))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("foo.h")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    assertEquals(
        buildTarget, Iterables.getOnlyElement(
            projectGenerator.getBuildTargetToGeneratedTargetMap().keySet()));

    PBXTarget target = Iterables.getOnlyElement(
        projectGenerator.getBuildTargetToGeneratedTargetMap().values());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target, ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "bar.m", Optional.<String>absent()));
  }

  @Test
  public void generatedGidsForTargetsAreStable() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:foo");
    String expectedGID = String.format(
        "%08X%08X%08X", target.isa().hashCode(), target.getName().hashCode(), 0);
    assertEquals(
        "expected GID has correct value (value from which it's derived have not changed)",
        "E66DC04E2245423200000000", expectedGID);
    assertEquals("generated GID is same as expected", expectedGID, target.getGlobalID());
  }

  @Test
  public void stopsLinkingRecursiveDependenciesAtSharedLibraries() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("empty.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticLibraryTarget)))
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentSharedLibraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(
            dependentStaticLibraryNode,
            dependentSharedLibraryNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libshared.dylib"));
  }

  @Test
  public void stopsLinkingRecursiveDependenciesAtBundles() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticLibraryTarget)))
        .build();

    BuildTarget dependentFrameworkTarget = BuildTarget.builder("//dep", "framework").build();
    TargetNode<?> dependentFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentSharedLibraryTarget)
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentFrameworkTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(
            dependentStaticLibraryNode,
            dependentSharedLibraryNode,
            dependentFrameworkNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$BUILT_PRODUCTS_DIR/framework.framework"));
  }

  @Test
  public void stopsCopyingRecursiveDependenciesAtBundles() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentStaticFrameworkTarget = BuildTarget
        .builder("//dep", "static-framework")
        .build();
    TargetNode<?> dependentStaticFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentStaticFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticFrameworkTarget)))
        .build();

    BuildTarget dependentFrameworkTarget = BuildTarget.builder("//dep", "framework").build();
    TargetNode<?> dependentFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentSharedLibraryTarget)
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentFrameworkTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(

        ImmutableSet.<TargetNode<?>>of(
            dependentStaticLibraryNode,
            dependentStaticFrameworkNode,
            dependentSharedLibraryNode,
            dependentFrameworkNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonCopyFilesPhaseWithFileEntries(
        target,
        ImmutableList.of("$BUILT_PRODUCTS_DIR/framework.framework"));
  }

  @Test
  public void bundlesDontLinkTheirOwnBinary() throws IOException {
    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 0, target.getBuildPhases().size());
  }

  @Test
  public void resourcesInDependenciesPropagatesToBundles() throws IOException {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "res").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of(new TestSourcePath("foodir")))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleLibraryTarget = BuildTarget.builder("//foo", "bundlelib").build();
    TargetNode<?> bundleLibraryNode = AppleLibraryBuilder
        .createBuilder(bundleLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(bundleLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(resourceNode, libraryNode, bundleLibraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        generatedProject,
        "//foo:bundle");
    assertHasSingletonResourcesPhaseWithEntries(target, "bar.png", "foodir");
  }

  @Test
  public void assetCatalogsInDependenciesPropogatesToBundles() throws IOException {
    BuildTarget assetCatalogTarget = BuildTarget.builder("//foo", "asset_catalog").build();
    TargetNode<?> assetCatalogNode = AppleAssetCatalogBuilder
        .createBuilder(assetCatalogTarget)
        .setDirs(ImmutableSortedSet.of(Paths.get("AssetCatalog.xcassets")))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(assetCatalogTarget)))
        .build();

    BuildTarget bundleLibraryTarget = BuildTarget.builder("//foo", "bundlelib").build();
    TargetNode<?> bundleLibraryNode = AppleLibraryBuilder
        .createBuilder(bundleLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(bundleLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(assetCatalogNode, libraryNode, bundleLibraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        generatedProject,
        "//foo:bundle");
    assertTrue(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void generatedTargetConfigurationHasRepoRootSet() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "rule").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    ImmutableMap<String, String> settings = getBuildSettings(
        buildTarget, generatedProject.getTargets().get(0), "Debug");
    assertThat(settings, hasKey("REPO_ROOT"));
    assertEquals(
        projectFilesystem.getRootPath().toAbsolutePath().normalize().toString(),
        settings.get("REPO_ROOT"));
  }


  @Test
  public void generatedProjectConfigurationListIsUnionOfAllTargetConfigurations()
      throws IOException {
    BuildTarget buildTarget1 = BuildTarget.builder("//foo", "rule1").build();
    TargetNode<?> node1 = AppleLibraryBuilder
        .createBuilder(buildTarget1)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Conf1", ImmutableMap.<String, String>of(),
                    "Conf2", ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget2 = BuildTarget.builder("//foo", "rule2").build();
    TargetNode<?> node2 = AppleLibraryBuilder
        .createBuilder(buildTarget2)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Conf2", ImmutableMap.<String, String>of(),
                    "Conf3", ImmutableMap.<String, String>of())))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node1, node2));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    Map<String, XCBuildConfiguration> configurations =
        generatedProject.getBuildConfigurationList().getBuildConfigurationsByName().asMap();
    assertThat(configurations, hasKey("Conf1"));
    assertThat(configurations, hasKey("Conf2"));
    assertThat(configurations, hasKey("Conf3"));
  }

  @Test
  public void shouldEmitFilesForBuildSettingPrefixedFrameworks() throws IOException {
    BuildTarget buildTarget = BuildTarget
        .builder("//foo", "rule")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
                            Paths.get("libfoo.a"))),
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("libfoo.a"))),
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SOURCE_ROOT,
                            Paths.get("libfoo.a"))))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(generatedProject, "//foo:rule#shared");
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libfoo.a",
            "$SDKROOT/libfoo.a",
            "$SOURCE_ROOT/libfoo.a"));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$(inherited) ",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR $SDKROOT $SOURCE_ROOT",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR",
        settings.get("FRAMEWORK_SEARCH_PATHS"));

  }

  @Test
  public void testGeneratedProjectIsNotReadOnlyIfOptionNotSpecified() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    projectGenerator.createXcodeProjects();

    assertTrue(fakeProjectFilesystem.getFileAttributesAtPath(OUTPUT_PROJECT_FILE_PATH).isEmpty());
  }

  @Test
  public void testGeneratedProjectIsReadOnlyIfOptionSpecified() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(),
        ImmutableSet.of(ProjectGenerator.Option.GENERATE_READ_ONLY_FILES));

    projectGenerator.createXcodeProjects();

    ImmutableSet<PosixFilePermission> permissions =
      ImmutableSet.of(
          PosixFilePermission.OWNER_READ,
          PosixFilePermission.GROUP_READ,
          PosixFilePermission.OTHERS_READ);
    FileAttribute<?> expectedAttribute = PosixFilePermissions.asFileAttribute(permissions);





    FileAttribute<?> actualAttribute =
      Iterables.getOnlyElement(
          fakeProjectFilesystem.getFileAttributesAtPath(OUTPUT_PROJECT_FILE_PATH));
    assertEquals(
        expectedAttribute.value(),
        actualAttribute.value());
  }

  @Test
  public void targetGidInDescriptionSetsTargetGidInGeneratedProject() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setGid(Optional.of("D00D64738"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    assertThat(target.getGlobalID(), equalTo("D00D64738"));
  }

  @Test
  public void targetGidInDescriptionReservesGidFromUseByAnotherTarget() throws IOException {
    BuildTarget fooTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooNode = AppleLibraryBuilder
        .createBuilder(fooTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    BuildTarget barTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> barNode = AppleLibraryBuilder
        .createBuilder(barTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooNode, barNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//bar:lib");



    String expectedGID = String.format(
        "%08X%08X%08X", target.isa().hashCode(), target.getName().hashCode(), 1);
    assertEquals(
        "expected GID has correct value",
        "E66DC04E36F2D8BE00000001", expectedGID);
    assertEquals("generated GID is same as expected", expectedGID, target.getGlobalID());
  }

  @Test
  public void conflictingHardcodedGidsThrow() throws IOException {
    BuildTarget fooTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooNode = AppleLibraryBuilder
        .createBuilder(fooTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    BuildTarget barTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> barNode = AppleLibraryBuilder
        .createBuilder(barTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooNode, barNode));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "Targets [//bar:lib, //foo:lib] have the same hardcoded GID (E66DC04E36F2D8BE00000000)");

    projectGenerator.createXcodeProjects();
  }

  @Test
  public void projectIsRewrittenIfContentsHaveChanged() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(49152);
    projectGenerator.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));

    BuildTarget buildTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .build();
    ProjectGenerator projectGenerator2 = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    clock.setCurrentTimeMillis(64738);
    projectGenerator2.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(64738L));
  }

  @Test
  public void projectIsNotRewrittenIfContentsHaveNotChanged() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(49152);
    projectGenerator.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));

    ProjectGenerator projectGenerator2 = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(64738);
    projectGenerator2.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));
  }

  @Test
  public void nonexistentResourceDirectoryShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(),
        ImmutableSet.<SourcePath>of(new TestSourcePath("nonexistent-directory")));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "nonexistent-directory specified in the dirs parameter of //foo:res is not a directory");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void nonexistentResourceFileShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(new TestSourcePath("nonexistent-file.png")),
        ImmutableSet.<SourcePath>of());

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "nonexistent-file.png specified in the files parameter of //foo:res is not a regular file");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingFileAsResourceDirectoryShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(),
        ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "bar.png specified in the dirs parameter of //foo:res is not a directory");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingDirectoryAsResourceFileShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(new TestSourcePath("foodir")),
        ImmutableSet.<SourcePath>of());

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "foodir specified in the files parameter of //foo:res is not a regular file");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingBuildTargetSourcePathInResourceDirsOrFilesDoesNotThrow() throws IOException {
    BuildTarget buildTarget = BuildTargetFactory.newInstance("//some:rule");
    SourcePath sourcePath = new BuildTargetSourcePath(buildTarget);
    TargetNode<?> generatingTarget = GenruleBuilder.newGenruleBuilder(buildTarget)
        .setCmd("echo HI")
        .build();

    ImmutableSet<TargetNode<?>> nodes = FluentIterable.from(
        setupSimpleLibraryWithResources(
            ImmutableSet.of(sourcePath),
            ImmutableSet.of(sourcePath)))
        .append(generatingTarget)
        .toSet();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void testGeneratingTestsAsStaticLibraries() throws IOException {
    TargetNode<AppleTestDescription.Arg> libraryTestStatic =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "libraryTestStatic").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .build();
    TargetNode<AppleTestDescription.Arg> libraryTestNotStatic =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "libraryTestNotStatic").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableList.<TargetNode<?>>of(libraryTestStatic, libraryTestNotStatic));
    projectGenerator
        .setTestsToGenerateAsStaticLibraries(ImmutableSet.of(libraryTestStatic))
        .createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget libraryTestStaticTarget =
        assertTargetExistsAndReturnTarget(project, "//foo:libraryTestStatic");
    PBXTarget libraryTestNotStaticTarget =
        assertTargetExistsAndReturnTarget(project, "//foo:libraryTestNotStatic");
    assertThat(
        libraryTestStaticTarget.getProductType(),
        equalTo(ProductType.STATIC_LIBRARY));
    assertThat(
        libraryTestNotStaticTarget.getProductType(),
        equalTo(ProductType.UNIT_TEST));
  }

  @Test
  public void testGeneratingCombinedTests() throws IOException {
    TargetNode<AppleResourceDescription.Arg> testLibDepResource =
        AppleResourceBuilder.createBuilder(BuildTarget.builder("//lib", "deplibresource").build())
            .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
            .setDirs(ImmutableSet.<SourcePath>of())
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> testLibDepLib =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//libs", "deplib").build())
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTestLibDep.framework"))))))
            .setDeps(Optional.of(ImmutableSortedSet.of(testLibDepResource.getBuildTarget())))
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> dep1 =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//foo", "dep1").build())
            .setDeps(Optional.of(ImmutableSortedSet.of(testLibDepLib.getBuildTarget())))
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTestLib.framework"))))))
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> dep2 =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//foo", "dep2").build())
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .build();
    TargetNode<AppleTestDescription.Arg> xctest1 =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "xctest1").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .setDeps(Optional.of(ImmutableSortedSet.of(dep1.getBuildTarget())))
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTest.framework"))))))
            .build();
    TargetNode<AppleTestDescription.Arg> xctest2 =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "xctest2").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .setDeps(Optional.of(ImmutableSortedSet.of(dep2.getBuildTarget())))
            .build();

    ProjectGenerator projectGenerator = new ProjectGenerator(
        TargetGraphFactory.newInstance(
            testLibDepResource,
            testLibDepLib,
            dep1,
            dep2,
            xctest1,
            xctest2),
        ImmutableSet.<BuildTarget>of(),
        projectFilesystem,
 Optional.<Path>absent(),
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        ProjectGenerator.SEPARATED_PROJECT_OPTIONS,
        Optional.<BuildTarget>absent(),
        ImmutableList.<String>of(),
        new Function<TargetNode<?>, Path>() {
          @Nullable
          @Override
          public Path apply(TargetNode<?> input) {
            return null;
          }
        })
        .setTestsToGenerateAsStaticLibraries(ImmutableSet.of(xctest1, xctest2))
        .setAdditionalCombinedTestTargets(
            ImmutableMultimap.of(
                AppleTestBundleParamsKey.fromAppleTestDescriptionArg(xctest1.getConstructorArg()),
                xctest1,
                AppleTestBundleParamsKey.fromAppleTestDescriptionArg(xctest2.getConstructorArg()),
                xctest2));
    projectGenerator.createXcodeProjects();

    ImmutableSet<PBXTarget> combinedTestTargets =
        projectGenerator.getBuildableCombinedTestTargets();
    assertThat(combinedTestTargets, hasSize(1));
    assertThat(combinedTestTargets, hasItem(targetWithName("_BuckCombinedTest-xctest-0")));

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "_BuckCombinedTest-xctest-0");
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            BuckConstant.GEN_PATH.resolve("xcode-scripts/emptyFile.c").toString(),
            Optional.<String>absent()));
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libxctest1.a",
            "$BUILT_PRODUCTS_DIR/libxctest2.a",
            "$BUILT_PRODUCTS_DIR/libdeplib.a",
            "$BUILT_PRODUCTS_DIR/libdep1.a",
            "$BUILT_PRODUCTS_DIR/libdep2.a",
            "$SDKROOT/DeclaredInTestLib.framework",
            "$SDKROOT/DeclaredInTestLibDep.framework",
            "$SDKROOT/DeclaredInTest.framework"));
    assertHasSingletonResourcesPhaseWithEntries(
        target,
        "bar.png");
  }

  @Test
  public void testResolvingExportFile() throws IOException {
    BuildTarget source1Target = BuildTarget.builder("//Vendor", "source1").build();
    BuildTarget source2Target = BuildTarget.builder("//Vendor", "source2").build();
    BuildTarget source2RefTarget = BuildTarget.builder("//Vendor", "source2ref").build();
    BuildTarget source3Target = BuildTarget.builder("//Vendor", "source3").build();
    BuildTarget headerTarget = BuildTarget.builder("//Vendor", "header").build();
    BuildTarget libTarget = BuildTarget.builder("//Libraries", "foo").build();

    TargetNode<ExportFileDescription.Arg> source1 = ExportFileBuilder
        .newExportFileBuilder(source1Target)
        .setSrc(new PathSourcePath(projectFilesystem, Paths.get("Vendor/sources/source1")))
        .build();

    TargetNode<ExportFileDescription.Arg> source2 = ExportFileBuilder
        .newExportFileBuilder(source2Target)
        .setSrc(new PathSourcePath(projectFilesystem, Paths.get("Vendor/source2")))
        .build();

    TargetNode<ExportFileDescription.Arg> source2Ref = ExportFileBuilder
        .newExportFileBuilder(source2RefTarget)
        .setSrc(new BuildTargetSourcePath(source2Target))
        .build();

    TargetNode<ExportFileDescription.Arg> source3 = ExportFileBuilder
        .newExportFileBuilder(source3Target)
        .build();

    TargetNode<ExportFileDescription.Arg> header = ExportFileBuilder
        .newExportFileBuilder(headerTarget)
        .build();

    TargetNode<AppleNativeTargetDescriptionArg> library = AppleLibraryBuilder
        .createBuilder(libTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source1Target)),
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source2RefTarget)),
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source3Target)))))
        .setPrefixHeader(
            Optional.<SourcePath>of(new BuildTargetSourcePath(headerTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(
            source1,
            source2,
            source2Ref,
            source3,
            header,
            library));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        libTarget.toString());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            "Vendor/sources/source1", Optional.<String>absent(),
            "Vendor/source2", Optional.<String>absent(),
            "Vendor/source3", Optional.<String>absent()));

    ImmutableMap<String, String> settings = getBuildSettings(libTarget, target, "Debug");
    assertEquals("../Vendor/header", settings.get("GCC_PREFIX_HEADER"));
  }

  @Test
  public void applicationTestUsesHostAppAsTestHostAndBundleLoader() throws IOException {
    BuildTarget hostAppBinaryTarget = BuildTarget.builder("//foo", "HostAppBinary").build();
    TargetNode<?> hostAppBinaryNode = AppleBinaryBuilder
        .createBuilder(hostAppBinaryTarget)
        .build();

    BuildTarget hostAppTarget = BuildTarget.builder("//foo", "HostApp").build();
    TargetNode<?> hostAppNode = AppleBundleBuilder
        .createBuilder(hostAppTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setBinary(hostAppBinaryTarget)
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "AppTest").build();
    TargetNode<?> testNode = AppleTestBuilder.createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setTestHostApp(Optional.of(hostAppTarget))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(hostAppBinaryNode, hostAppNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:AppTest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, testPBXTarget, "Debug");
    assertEquals("$BUILT_PRODUCTS_DIR/./HostApp.app/HostApp", settings.get("BUNDLE_LOADER"));
    assertEquals("$(BUNDLE_LOADER)", settings.get("TEST_HOST"));
  }

  @Test
  public void aggregateTargetForBuildWithBuck() throws IOException {
    BuildTarget binaryTarget = BuildTarget.builder("//foo", "binary").build();
    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")))))
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.<TargetNode<?>>of(binaryNode);
    ProjectGenerator projectGenerator = new ProjectGenerator(
        TargetGraphFactory.newInstance(nodes),
        FluentIterable.from(nodes).transform(HasBuildTarget.TO_TARGET).toSet(),
        projectFilesystem,
 Optional.<Path>absent(),
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        ImmutableSet.<ProjectGenerator.Option>of(),
        Optional.of(binaryTarget),
        ImmutableList.of("--flag", "value with spaces"),
        Functions.<Path>constant(null));
    projectGenerator.createXcodeProjects();

    PBXTarget buildWithBuckTarget = null;
    for (PBXTarget target : projectGenerator.getGeneratedProject().getTargets()) {
      if (target.getProductName() != null &&
          target.getProductName().endsWith("-Buck")) {
        buildWithBuckTarget = target;
      }
    }
    assertThat(buildWithBuckTarget, is(notNullValue()));

    assertHasConfigurations(buildWithBuckTarget, "Debug");
    assertEquals(
        "Should have exact number of build phases",
        1,
        buildWithBuckTarget.getBuildPhases().size());
    PBXBuildPhase buildPhase = Iterables.getOnlyElement(buildWithBuckTarget.getBuildPhases());
    assertThat(buildPhase, instanceOf(PBXShellScriptBuildPhase.class));
    PBXShellScriptBuildPhase shellScriptBuildPhase = (PBXShellScriptBuildPhase) buildPhase;
    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("buck build --flag 'value with spaces' " + binaryTarget.getFullyQualifiedName()));
  }

  @Test
  public void cxxFlagsPropagatedToConfig() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setLangPreprocessorFlags(
            Optional.of(
                ImmutableMap.of(
                    CxxSource.Type.CXX, ImmutableList.of("-std=c++11", "-stdlib=libc++"),
                    CxxSource.Type.OBJCXX, ImmutableList.of("-std=c++11", "-stdlib=libc++"))))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.mm")))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -std=c++11 -stdlib=libc++", settings.get("OTHER_CPLUSPLUSFLAGS"));
  }

  @Test
  public void unsupportedLangPreprocessorFlagsThrows() throws IOException {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "//foo:lib: Xcode project generation does not support specified lang_preprocessor_flags " +
        "keys: [ASSEMBLER]");

    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setLangPreprocessorFlags(
            Optional.of(
                ImmutableMap.of(
                    CxxSource.Type.ASSEMBLER, ImmutableList.of("-Xawesome"))))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.mm")))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes) {
    return createProjectGeneratorForCombinedProject(
        nodes,
        ImmutableSet.<ProjectGenerator.Option>of());
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes,
      ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions) {
    return createProjectGeneratorForCombinedProject(
        nodes,
        projectGeneratorOptions,
        Optional.<Path>absent());
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes,
      ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions,
      Optional<Path> reactNativeServer) {
    ImmutableSet<BuildTarget> initialBuildTargets = FluentIterable
        .from(nodes)
        .transform(HasBuildTarget.TO_TARGET)
        .toSet();

    return new ProjectGenerator(
        TargetGraphFactory.newInstance(ImmutableSet.copyOf(nodes)),
        initialBuildTargets,
        projectFilesystem,
        reactNativeServer,
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        projectGeneratorOptions,
        Optional.<BuildTarget>absent(),
        ImmutableList.<String>of(),
        Functions.<Path>constant(null));
  }

  private ImmutableSet<TargetNode<?>> setupSimpleLibraryWithResources(
      ImmutableSet<SourcePath> resourceFiles,
      ImmutableSet<SourcePath> resourceDirectories) {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "res").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(resourceFiles)
        .setDirs(resourceDirectories)
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    return ImmutableSet.of(resourceNode, libraryNode);
  }

  private String assertFileRefIsRelativeAndResolvePath(PBXReference fileRef) {
    assert(!fileRef.getPath().startsWith("/"));
    assertEquals(
        "file path should be relative to project directory",
        PBXReference.SourceTree.SOURCE_ROOT,
        fileRef.getSourceTree());
    return projectFilesystem.resolve(OUTPUT_DIRECTORY).resolve(fileRef.getPath())
        .normalize().toString();
  }

  private void assertHasConfigurations(PBXTarget target, String... names) {
    Map<String, XCBuildConfiguration> buildConfigurationMap =
        target.getBuildConfigurationList().getBuildConfigurationsByName().asMap();
    assertEquals(
        "Configuration list has expected number of entries",
        names.length, buildConfigurationMap.size());

    for (String name : names) {
      XCBuildConfiguration configuration = buildConfigurationMap.get(name);

      assertNotNull("Configuration entry exists", configuration);
      assertEquals("Configuration name is same as key", name, configuration.getName());
      assertTrue(
          "Configuration has xcconfig file",
          configuration.getBaseConfigurationReference().getPath().endsWith(".xcconfig"));
    }
  }

  private void assertHasSingletonSourcesPhaseWithSourcesAndFlags(
      PBXTarget target,
      ImmutableMap<String, Optional<String>> sourcesAndFlags) {

    PBXSourcesBuildPhase sourcesBuildPhase =
        getSingletonPhaseByType(target, PBXSourcesBuildPhase.class);

    assertEquals(
        "Sources build phase should have correct number of sources",
        sourcesAndFlags.size(), sourcesBuildPhase.getFiles().size());


    ImmutableMap.Builder<String, Optional<String>> absolutePathFlagMapBuilder =
        ImmutableMap.builder();
    for (Map.Entry<String, Optional<String>> name : sourcesAndFlags.entrySet()) {
      absolutePathFlagMapBuilder.put(
          projectFilesystem.getRootPath().resolve(name.getKey()).toAbsolutePath()
              .normalize().toString(),
          name.getValue());
    }
    ImmutableMap<String, Optional<String>> absolutePathFlagMap = absolutePathFlagMapBuilder.build();

    for (PBXBuildFile file : sourcesBuildPhase.getFiles()) {
      String filePath = assertFileRefIsRelativeAndResolvePath(file.getFileRef());
      Optional<String> flags = absolutePathFlagMap.get(filePath);
      assertNotNull(String.format("Unexpected file ref '%s' found", filePath), flags);
      if (flags.isPresent()) {
        assertTrue("Build file should have settings dictionary", file.getSettings().isPresent());

        NSDictionary buildFileSettings = file.getSettings().get();
        NSString compilerFlags = (NSString) buildFileSettings.get("COMPILER_FLAGS");

        assertNotNull("Build file settings should have COMPILER_FLAGS entry", compilerFlags);
        assertEquals(
            "Build file settings should be expected value",
            flags.get(), compilerFlags.getContent());
      } else {
        assertFalse(
            "Build file should not have settings dictionary", file.getSettings().isPresent());
      }
    }
  }

  private void assertHasSingletonResourcesPhaseWithEntries(PBXTarget target, String... resources) {
    PBXResourcesBuildPhase buildPhase =
        getSingletonPhaseByType(target, PBXResourcesBuildPhase.class);
    assertEquals("Resources phase should have right number of elements",
        resources.length, buildPhase.getFiles().size());

    ImmutableSet.Builder<String> expectedResourceSetBuilder = ImmutableSet.builder();
    for (String resource : resources) {
      expectedResourceSetBuilder.add(
          projectFilesystem.getRootPath().resolve(resource).toAbsolutePath()
              .normalize().toString());
    }
    ImmutableSet<String> expectedResourceSet = expectedResourceSetBuilder.build();

    for (PBXBuildFile file : buildPhase.getFiles()) {
      String source = assertFileRefIsRelativeAndResolvePath(file.getFileRef());
      assertTrue(
          "Resource should be in list of expected resources: " + source,
          expectedResourceSet.contains(source));
    }
  }

  private ImmutableMap<String, String> getBuildSettings(
      BuildTarget buildTarget, PBXTarget target, String config) {
    assertHasConfigurations(target, config);
    return ProjectGeneratorTestUtils.getBuildSettings(
        projectFilesystem, buildTarget, target, config);
  }

  private boolean hasShellScriptPhaseToCompileAssetCatalogs(PBXTarget target) {
    boolean found = false;
    for (PBXBuildPhase phase : target.getBuildPhases()) {
      if (phase.getClass().equals(PBXShellScriptBuildPhase.class)) {
        PBXShellScriptBuildPhase shellScriptBuildPhase = (PBXShellScriptBuildPhase) phase;
        if (shellScriptBuildPhase.getShellScript().contains("compile_asset_catalogs")) {
          found = true;
        }
      }
    }

    return found;
  }

  private Matcher<PBXTarget> targetWithName(String name) {
    return new FeatureMatcher<PBXTarget, String>(
        org.hamcrest.Matchers.equalTo(name),
        "target with name",
        "name") {
      @Override
      protected String featureValueOf(PBXTarget pbxTarget) {
        return pbxTarget.getName();
      }
    };
  }
}

<code block>


package com.facebook.buck.apple;

import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.facebook.buck.apple.clang.HeaderMap;
import com.facebook.buck.apple.xcode.GidGenerator;
import com.facebook.buck.apple.xcode.XcodeprojSerializer;
import com.facebook.buck.apple.xcode.xcodeproj.CopyFilePhaseDestinationSpec;
import com.facebook.buck.apple.xcode.xcodeproj.PBXAggregateTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildFile;
import com.facebook.buck.apple.xcode.xcodeproj.PBXCopyFilesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXFileReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXGroup;
import com.facebook.buck.apple.xcode.xcodeproj.PBXNativeTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXProject;
import com.facebook.buck.apple.xcode.xcodeproj.PBXReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXShellScriptBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXTarget;
import com.facebook.buck.apple.xcode.xcodeproj.ProductType;
import com.facebook.buck.apple.xcode.xcodeproj.SourceTreePath;
import com.facebook.buck.apple.xcode.xcodeproj.XCBuildConfiguration;
import com.facebook.buck.apple.xcode.xcodeproj.XCConfigurationList;
import com.facebook.buck.apple.xcode.xcodeproj.XCVersionGroup;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.HeaderVisibility;
import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.IosReactNativeLibraryDescription;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuckVersion;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.HasTests;
import com.facebook.buck.parser.NoSuchBuildTargetException;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.FrameworkPath;
import com.facebook.buck.rules.coercer.SourceList;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleDescription;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.hash.HashCode;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import com.google.common.io.BaseEncoding;
import com.google.common.util.concurrent.UncheckedExecutionException;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ProjectGenerator {
  private static final Logger LOG = Logger.get(ProjectGenerator.class);

  public enum Option {

    USE_SHORT_NAMES_FOR_TARGETS,


    CREATE_DIRECTORY_STRUCTURE,


    GENERATE_READ_ONLY_FILES,


    INCLUDE_TESTS,
    ;
  }


  public static final ImmutableSet<Option> SEPARATED_PROJECT_OPTIONS = ImmutableSet.of(
      Option.USE_SHORT_NAMES_FOR_TARGETS);


  public static final ImmutableSet<Option> COMBINED_PROJECT_OPTIONS = ImmutableSet.of(
      Option.CREATE_DIRECTORY_STRUCTURE,
      Option.USE_SHORT_NAMES_FOR_TARGETS);

  public static final String PATH_TO_ASSET_CATALOG_COMPILER = System.getProperty(
      "buck.path_to_compile_asset_catalogs_py",
      "src/com/facebook/buck/apple/compile_asset_catalogs.py");
  public static final String PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT = System.getProperty(
      "buck.path_to_compile_asset_catalogs_build_phase_sh",
      "src/com/facebook/buck/apple/compile_asset_catalogs_build_phase.sh");
  public static final String PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT =
      System.getProperty(
          "buck.path_override_for_asset_catalog_build_phase",
          null);

  private static final FileAttribute<?> READ_ONLY_FILE_ATTRIBUTE =
      PosixFilePermissions.asFileAttribute(
          ImmutableSet.of(
              PosixFilePermission.OWNER_READ,
              PosixFilePermission.GROUP_READ,
              PosixFilePermission.OTHERS_READ));

  public static final Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> GET_EXPORTED_LINKER_FLAGS =
      new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
        @Override
        public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
          return input.getConstructorArg().exportedLinkerFlags.get();
        }
      };

  public static final Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> GET_EXPORTED_PREPROCESSOR_FLAGS =
      new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
        @Override
        public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
          return input.getConstructorArg().exportedPreprocessorFlags.get();
        }
      };

  private static final ImmutableSet<CxxSource.Type> SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES =
      ImmutableSet.of(CxxSource.Type.CXX, CxxSource.Type.OBJCXX);

  private final Function<SourcePath, Path> sourcePathResolver;
  private final TargetGraph targetGraph;
  private final ProjectFilesystem projectFilesystem;
  private final Optional<Path> reactNativeServer;
  private final Path outputDirectory;
  private final String projectName;
  private final ImmutableSet<BuildTarget> initialTargets;
  private final Path projectPath;
  private final Path placedAssetCatalogBuildPhaseScript;
  private final PathRelativizer pathRelativizer;

  private final String buildFileName;
  private final ImmutableSet<Option> options;
  private final Optional<BuildTarget> targetToBuildWithBuck;
  private final ImmutableList<String> buildWithBuckFlags;

  private ImmutableSet<TargetNode<AppleTestDescription.Arg>> testsToGenerateAsStaticLibraries =
      ImmutableSet.of();
  private ImmutableMultimap<AppleTestBundleParamsKey, TargetNode<AppleTestDescription.Arg>>
      additionalCombinedTestTargets = ImmutableMultimap.of();


  private final PBXProject project;
  private final LoadingCache<TargetNode<?>, Optional<PBXTarget>> targetNodeToProjectTarget;
  private boolean shouldPlaceAssetCatalogCompiler = false;
  private final ImmutableMultimap.Builder<TargetNode<?>, PBXTarget>
      targetNodeToGeneratedProjectTargetBuilder;
  private boolean projectGenerated;
  private final List<Path> headerSymlinkTrees;
  private final ImmutableSet.Builder<PBXTarget> buildableCombinedTestTargets =
      ImmutableSet.builder();
  private final ImmutableSet.Builder<BuildTarget> requiredBuildTargetsBuilder =
      ImmutableSet.builder();
  private final Function<? super TargetNode<?>, Path> outputPathOfNode;


  private final ImmutableSet.Builder<String> targetConfigNamesBuilder;

  private final Map<String, String> gidsToTargetNames;

  public ProjectGenerator(
      TargetGraph targetGraph,
      Set<BuildTarget> initialTargets,
      ProjectFilesystem projectFilesystem,
      Optional<Path> reactNativeServer,
      Path outputDirectory,
      String projectName,
      String buildFileName,
      Set<Option> options,
      Optional<BuildTarget> targetToBuildWithBuck,
      ImmutableList<String> buildWithBuckFlags,
      Function<? super TargetNode<?>, Path> outputPathOfNode) {
    this.sourcePathResolver = new Function<SourcePath, Path>() {
      @Override
      public Path apply(SourcePath input) {
        return resolveSourcePath(input);
      }
    };

    this.targetGraph = targetGraph;
    this.initialTargets = ImmutableSet.copyOf(initialTargets);
    this.projectFilesystem = projectFilesystem;
    this.reactNativeServer = reactNativeServer;
    this.outputDirectory = outputDirectory;
    this.projectName = projectName;
    this.buildFileName = buildFileName;
    this.options = ImmutableSet.copyOf(options);
    this.targetToBuildWithBuck = targetToBuildWithBuck;
    this.buildWithBuckFlags = buildWithBuckFlags;
    this.outputPathOfNode = outputPathOfNode;

    this.projectPath = outputDirectory.resolve(projectName + ".xcodeproj");
    this.pathRelativizer = new PathRelativizer(
        outputDirectory,
        sourcePathResolver);

    LOG.debug(
        "Output directory %s, profile fs root path %s, repo root relative to output dir %s",
        this.outputDirectory,
        projectFilesystem.getRootPath(),
        this.pathRelativizer.outputDirToRootRelative(Paths.get(".")));

    this.placedAssetCatalogBuildPhaseScript =
        BuckConstant.SCRATCH_PATH.resolve("xcode-scripts/compile_asset_catalogs_build_phase.sh");

    this.project = new PBXProject(projectName);
    this.headerSymlinkTrees = new ArrayList<>();

    this.targetNodeToGeneratedProjectTargetBuilder = ImmutableMultimap.builder();
    this.targetNodeToProjectTarget = CacheBuilder.newBuilder().build(
        new CacheLoader<TargetNode<?>, Optional<PBXTarget>>() {
          @Override
          public Optional<PBXTarget> load(TargetNode<?> key) throws Exception {
            return generateProjectTarget(key);
          }
        });

    targetConfigNamesBuilder = ImmutableSet.builder();
    gidsToTargetNames = new HashMap<>();
  }


  public ProjectGenerator setTestsToGenerateAsStaticLibraries(
      Set<TargetNode<AppleTestDescription.Arg>> set) {
    Preconditions.checkState(!projectGenerated);
    this.testsToGenerateAsStaticLibraries = ImmutableSet.copyOf(set);
    return this;
  }


  public ProjectGenerator setAdditionalCombinedTestTargets(
      Multimap<AppleTestBundleParamsKey, TargetNode<AppleTestDescription.Arg>> targets) {
    Preconditions.checkState(!projectGenerated);
    this.additionalCombinedTestTargets = ImmutableMultimap.copyOf(targets);
    return this;
  }

  @VisibleForTesting
  PBXProject getGeneratedProject() {
    return project;
  }

  @VisibleForTesting
  List<Path> getGeneratedHeaderSymlinkTrees() {
    return headerSymlinkTrees;
  }

  public Path getProjectPath() {
    return projectPath;
  }

  public ImmutableMultimap<BuildTarget, PBXTarget> getBuildTargetToGeneratedTargetMap() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    ImmutableMultimap.Builder<BuildTarget, PBXTarget> buildTargetToPbxTargetMap =
        ImmutableMultimap.builder();
    for (Map.Entry<TargetNode<?>, PBXTarget> entry :
        targetNodeToGeneratedProjectTargetBuilder.build().entries()) {
      buildTargetToPbxTargetMap.put(entry.getKey().getBuildTarget(), entry.getValue());
    }
    return buildTargetToPbxTargetMap.build();
  }

  public ImmutableSet<PBXTarget> getBuildableCombinedTestTargets() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    return buildableCombinedTestTargets.build();
  }

  public ImmutableSet<BuildTarget> getRequiredBuildTargets() {
    Preconditions.checkState(projectGenerated, "Must have called createXcodeProjects");
    return requiredBuildTargetsBuilder.build();
  }

  public void createXcodeProjects() throws IOException {
    LOG.debug("Creating projects for targets %s", initialTargets);

    try {
      for (TargetNode<?> targetNode : targetGraph.getNodes()) {
        if (isBuiltByCurrentProject(targetNode.getBuildTarget())) {
          LOG.debug("Including rule %s in project", targetNode);

          Optional<PBXTarget> target = targetNodeToProjectTarget.getUnchecked(targetNode);
          if (target.isPresent()) {
            targetNodeToGeneratedProjectTargetBuilder.put(targetNode, target.get());
          }
        } else {
          LOG.verbose("Excluding rule %s (not built by current project)", targetNode);
        }
      }

      if (targetToBuildWithBuck.isPresent()) {
        generateAggregateTarget(
            Preconditions.checkNotNull(targetGraph.get(targetToBuildWithBuck.get())));
      }

      int combinedTestIndex = 0;
      for (AppleTestBundleParamsKey key : additionalCombinedTestTargets.keySet()) {
        generateCombinedTestTarget(
            deriveCombinedTestTargetNameFromKey(key, combinedTestIndex++),
            key,
            additionalCombinedTestTargets.get(key));
      }

      for (String configName : targetConfigNamesBuilder.build()) {
        XCBuildConfiguration outputConfig = project
            .getBuildConfigurationList()
            .getBuildConfigurationsByName()
            .getUnchecked(configName);
        outputConfig.setBuildSettings(new NSDictionary());
      }

      writeProjectFile(project);

      if (shouldPlaceAssetCatalogCompiler) {
        Path placedAssetCatalogCompilerPath = projectFilesystem.getPathForRelativePath(
            BuckConstant.SCRATCH_PATH.resolve(
                "xcode-scripts/compile_asset_catalogs.py"));
        LOG.debug("Ensuring asset catalog is copied to path [%s]", placedAssetCatalogCompilerPath);
        projectFilesystem.createParentDirs(placedAssetCatalogCompilerPath);
        projectFilesystem.createParentDirs(placedAssetCatalogBuildPhaseScript);
        projectFilesystem.copyFile(
            Paths.get(PATH_TO_ASSET_CATALOG_COMPILER),
            placedAssetCatalogCompilerPath);
        projectFilesystem.copyFile(
            Paths.get(PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT),
            placedAssetCatalogBuildPhaseScript);
      }
      projectGenerated = true;
    } catch (UncheckedExecutionException e) {


      UncheckedExecutionException originalException = e;
      while (e.getCause() instanceof UncheckedExecutionException) {
        e = (UncheckedExecutionException) e.getCause();
      }
      if (e.getCause() instanceof HumanReadableException) {
        throw (HumanReadableException) e.getCause();
      } else {
        throw originalException;
      }
    }
  }

  private void generateAggregateTarget(TargetNode<?> targetNode) {
    final BuildTarget buildTarget = targetNode.getBuildTarget();
    ImmutableMap<String, ImmutableMap<String, String>> configs =
        getAppleNativeNode(targetGraph, targetNode).get().getConstructorArg().configs.get();
    String productName = getXcodeTargetName(buildTarget) + "-Buck";

    PBXShellScriptBuildPhase shellScriptBuildPhase = new PBXShellScriptBuildPhase();
    ImmutableList<String> command = ImmutableList
        .<String>builder()
        .add("buck")
        .add("build")
        .addAll(Iterables.transform(buildWithBuckFlags, Escaper.BASH_ESCAPER))
        .add(Escaper.escapeAsBashString(buildTarget.getFullyQualifiedName()))
        .build();

    shellScriptBuildPhase.setShellScript(Joiner.on(' ').join(command));

    XCConfigurationList configurationList = new XCConfigurationList();
    PBXGroup group = project
        .getMainGroup()
        .getOrCreateDescendantGroupByPath(
            FluentIterable
                .from(buildTarget.getBasePath())
                .transform(Functions.toStringFunction())
                .toList())
        .getOrCreateChildGroupByName(getXcodeTargetName(buildTarget));
    for (String configurationName : configs.keySet()) {
      XCBuildConfiguration configuration = configurationList
          .getBuildConfigurationsByName()
          .getUnchecked(configurationName);
      configuration.setBaseConfigurationReference(
          getConfigurationFileReference(
              group,
              getConfigurationNameToXcconfigPath(buildTarget).apply(configurationName)));

      NSDictionary inlineSettings = new NSDictionary();
      inlineSettings.put("HEADER_SEARCH_PATHS", "");
      inlineSettings.put("LIBRARY_SEARCH_PATHS", "");
      inlineSettings.put("FRAMEWORK_SEARCH_PATHS", "");
      configuration.setBuildSettings(inlineSettings);
    }

    PBXAggregateTarget aggregateTarget = new PBXAggregateTarget(productName);
    aggregateTarget.setProductName(productName);
    aggregateTarget.getBuildPhases().add(shellScriptBuildPhase);
    aggregateTarget.setBuildConfigurationList(configurationList);
    project.getTargets().add(aggregateTarget);

    targetNodeToGeneratedProjectTargetBuilder.put(targetNode, aggregateTarget);
  }

  @SuppressWarnings("unchecked")
  private Optional<PBXTarget> generateProjectTarget(TargetNode<?> targetNode)
      throws IOException {
    Preconditions.checkState(
        isBuiltByCurrentProject(targetNode.getBuildTarget()),
        "should not generate rule if it shouldn't be built by current project");
    Optional<PBXTarget> result = Optional.absent();
    if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      result = Optional.<PBXTarget>of(
          generateAppleLibraryTarget(
              project,
              (TargetNode<AppleNativeTargetDescriptionArg>) targetNode,
              Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      result = Optional.<PBXTarget>of(
          generateAppleBinaryTarget(
              project,
              (TargetNode<AppleNativeTargetDescriptionArg>) targetNode));
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      TargetNode<AppleBundleDescription.Arg> bundleTargetNode =
          (TargetNode<AppleBundleDescription.Arg>) targetNode;
      result = Optional.<PBXTarget>of(
          generateAppleBundleTarget(
              project,
              bundleTargetNode,
              (TargetNode<AppleNativeTargetDescriptionArg>) Preconditions.checkNotNull(
                  targetGraph.get(bundleTargetNode.getConstructorArg().binary)),
              Optional.<TargetNode<AppleBundleDescription.Arg>>absent()));
    } else if (targetNode.getType().equals(AppleTestDescription.TYPE)) {
      TargetNode<AppleTestDescription.Arg> testTargetNode =
          (TargetNode<AppleTestDescription.Arg>) targetNode;
      Optional<TargetNode<AppleBundleDescription.Arg>> testHostBundle;
      if (testTargetNode.getConstructorArg().testHostApp.isPresent()) {
        BuildTarget testHostBundleTarget =
            testTargetNode.getConstructorArg().testHostApp.get();
        TargetNode<?> testHostBundleNode = targetGraph.get(testHostBundleTarget);
        Preconditions.checkNotNull(testHostBundleNode);
        if (testHostBundleNode.getType() != AppleBundleDescription.TYPE) {
          throw new HumanReadableException(
              "The test host target '%s' has the wrong type (%s), must be apple_bundle",
              testHostBundleTarget,
              testHostBundleNode.getType());
        }
        testHostBundle = Optional.of((TargetNode<AppleBundleDescription.Arg>) testHostBundleNode);
      } else {
        testHostBundle = Optional.absent();
      }
      if (testsToGenerateAsStaticLibraries.contains(testTargetNode)) {
        result = Optional.<PBXTarget>of(
            generateAppleLibraryTarget(
                project,
                testTargetNode,
                testHostBundle));
      } else {
        result = Optional.<PBXTarget>of(
            generateAppleBundleTarget(
                project,
                testTargetNode,
                testTargetNode,
                testHostBundle));
      }
    } else if (targetNode.getType().equals(AppleResourceDescription.TYPE)) {




      TargetNode<AppleResourceDescription.Arg> resource =
          (TargetNode<AppleResourceDescription.Arg>) targetNode;
      AppleResourceDescription.Arg arg = resource.getConstructorArg();
      for (SourcePath dir : arg.dirs) {
        if (dir instanceof PathSourcePath &&
            !projectFilesystem.isDirectory(sourcePathResolver.apply(dir))) {
          throw new HumanReadableException(
              "%s specified in the dirs parameter of %s is not a directory",
              dir.toString(), resource.toString());
        }
      }
      for (SourcePath file : arg.files) {
        if (file instanceof PathSourcePath &&
            !projectFilesystem.isFile(sourcePathResolver.apply(file))) {
          throw new HumanReadableException(
              "%s specified in the files parameter of %s is not a regular file",
              file.toString(), resource.toString());
        }
      }
    }

    return result;
  }

  PBXNativeTarget generateAppleBundleTarget(
      PBXProject project,
      TargetNode<? extends HasAppleBundleFields> targetNode,
      TargetNode<? extends AppleNativeTargetDescriptionArg> binaryNode,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    Optional<Path> infoPlistPath;
    if (targetNode.getConstructorArg().getInfoPlist().isPresent()) {
      infoPlistPath = Optional.of(
          Preconditions.checkNotNull(
              sourcePathResolver.apply(targetNode.getConstructorArg().getInfoPlist().get())));
    } else {
      infoPlistPath = Optional.absent();
    }

    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.of(targetNode),
        binaryNode,
        bundleToTargetProductType(targetNode, binaryNode),
        "%s." + getExtensionString(targetNode.getConstructorArg().getExtension()),
        infoPlistPath,
 true,
        AppleResources.collectRecursiveResources(targetGraph, ImmutableList.of(targetNode)),
        AppleBuildRules.collectRecursiveAssetCatalogs(targetGraph, ImmutableList.of(targetNode)),
        bundleLoaderNode);


    Iterable<TargetNode<?>> copiedRules = AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
        targetGraph,
        AppleBuildRules.RecursiveDependenciesMode.COPYING,
        targetNode,
        Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES));
    generateCopyFilesBuildPhases(target, copiedRules);

    LOG.debug("Generated iOS bundle target %s", target);
    return target;
  }

  private PBXNativeTarget generateAppleBinaryTarget(
      PBXProject project,
      TargetNode<AppleNativeTargetDescriptionArg> targetNode)
      throws IOException {
    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent(),
        targetNode,
        ProductType.TOOL,
        "%s",
        Optional.<Path>absent(),
 true,
        ImmutableSet.<AppleResourceDescription.Arg>of(),
        ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent());
    LOG.debug("Generated Apple binary target %s", target);
    return target;
  }

  private PBXNativeTarget generateAppleLibraryTarget(
      PBXProject project,
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    boolean isShared = targetNode
        .getBuildTarget()
        .getFlavors()
        .contains(CxxDescriptionEnhancer.SHARED_FLAVOR);
    ProductType productType = isShared ?
        ProductType.DYNAMIC_LIBRARY :
        ProductType.STATIC_LIBRARY;
    PBXNativeTarget target = generateBinaryTarget(
        project,
        Optional.<TargetNode<AppleBundleDescription.Arg>>absent(),
        targetNode,
        productType,
        AppleBuildRules.getOutputFileNameFormatForLibrary(isShared),
        Optional.<Path>absent(),
 isShared,
        ImmutableSet.<AppleResourceDescription.Arg>of(),
        ImmutableSet.<AppleAssetCatalogDescription.Arg>of(),
        bundleLoaderNode);
    LOG.debug("Generated iOS library target %s", target);
    return target;
  }

  private PBXNativeTarget generateBinaryTarget(
      PBXProject project,
      Optional<? extends TargetNode<? extends HasAppleBundleFields>> bundle,
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      ProductType productType,
      String productOutputFormat,
      Optional<Path> infoPlistOptional,
      boolean includeFrameworks,
      ImmutableSet<AppleResourceDescription.Arg> resources,
      ImmutableSet<AppleAssetCatalogDescription.Arg> assetCatalogs,
      Optional<TargetNode<AppleBundleDescription.Arg>> bundleLoaderNode)
      throws IOException {
    Optional<String> targetGid = targetNode.getConstructorArg().gid;
    LOG.debug("Generating binary target for node %s (GID %s)", targetNode, targetGid);
    if (targetGid.isPresent()) {


      String thisTargetName = targetNode.getBuildTarget().getFullyQualifiedName();
      String conflictingTargetName = gidsToTargetNames.get(targetGid.get());
      if (conflictingTargetName != null) {
        throw new HumanReadableException(
            "Targets %s have the same hardcoded GID (%s)",
            ImmutableSortedSet.of(thisTargetName, conflictingTargetName),
            targetGid.get());
      }
      gidsToTargetNames.put(targetGid.get(), thisTargetName);
    }

    TargetNode<?> buildTargetNode = bundle.isPresent() ? bundle.get() : targetNode;
    final BuildTarget buildTarget = buildTargetNode.getBuildTarget();

    String productName = getProductName(buildTarget);
    AppleNativeTargetDescriptionArg arg = targetNode.getConstructorArg();
    NewNativeTargetProjectMutator mutator = new NewNativeTargetProjectMutator(
        pathRelativizer,
        sourcePathResolver);
    ImmutableSet<SourcePath> exportedHeaders =
        ImmutableSet.copyOf(getHeaderSourcePaths(arg.exportedHeaders));
    ImmutableSet<SourcePath> headers = ImmutableSet.copyOf(getHeaderSourcePaths(arg.headers));
    mutator
        .setTargetName(getXcodeTargetName(buildTarget))
        .setProduct(
            productType,
            productName,
            Paths.get(String.format(productOutputFormat, productName)))
        .setGid(targetGid)
        .setShouldGenerateCopyHeadersPhase(
            !targetNode.getConstructorArg().getUseBuckHeaderMaps())
        .setSourcesWithFlags(ImmutableSet.copyOf(arg.srcs.get()))
        .setExtraXcodeSources(ImmutableSet.copyOf(arg.extraXcodeSources.get()))
        .setPublicHeaders(exportedHeaders)
        .setPrivateHeaders(headers)
        .setPrefixHeader(arg.prefixHeader)
        .setResources(resources);

    if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE)) {
      mutator.setTargetGroupPath(
          FluentIterable
              .from(buildTarget.getBasePath())
              .transform(Functions.toStringFunction())
              .toList());
    }

    if (!assetCatalogs.isEmpty()) {
      mutator.setAssetCatalogs(getAndMarkAssetCatalogBuildScript(), assetCatalogs);
    }

    if (includeFrameworks) {
      ImmutableSet.Builder<FrameworkPath> frameworksBuilder = ImmutableSet.builder();
      frameworksBuilder.addAll(targetNode.getConstructorArg().frameworks.get());
      frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(ImmutableList.of(targetNode)));
      mutator.setFrameworks(frameworksBuilder.build());
      mutator.setArchives(
          collectRecursiveLibraryDependencies(ImmutableList.of(targetNode)));
    }



    ImmutableList.Builder<TargetNode<?>> preScriptPhases = ImmutableList.builder();
    ImmutableList.Builder<TargetNode<?>> postScriptPhases = ImmutableList.builder();
    if (bundle.isPresent() && targetNode != bundle.get()) {
      collectBuildScriptDependencies(
          targetGraph.getAll(bundle.get().getDeclaredDeps()),
          preScriptPhases,
          postScriptPhases);
    }
    collectBuildScriptDependencies(
        targetGraph.getAll(targetNode.getDeclaredDeps()),
        preScriptPhases,
        postScriptPhases);
    mutator.setPreBuildRunScriptPhases(preScriptPhases.build());
    mutator.setPostBuildRunScriptPhases(postScriptPhases.build());
    boolean skipRNBundle = ReactNativeFlavors.skipBundling(buildTargetNode.getBuildTarget());
    mutator.skipReactNativeBundle(skipRNBundle);

    if (skipRNBundle && reactNativeServer.isPresent()) {
      mutator.setAdditionalRunScripts(
          ImmutableList.of(projectFilesystem.resolve(reactNativeServer.get())));
    }

    NewNativeTargetProjectMutator.Result targetBuilderResult;
    try {
      targetBuilderResult = mutator.buildTargetAndAddToProject(project);
    } catch (NoSuchBuildTargetException e) {
      throw new HumanReadableException(e);
    }
    PBXGroup targetGroup = targetBuilderResult.targetGroup;

    SourceTreePath buckFilePath = new SourceTreePath(
        PBXReference.SourceTree.SOURCE_ROOT,
        pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName));
    PBXFileReference buckReference =
        targetGroup.getOrCreateFileReferenceBySourceTreePath(buckFilePath);
    buckReference.setExplicitFileType(Optional.of("text.script.python"));


    ImmutableMap.Builder<String, String> extraSettingsBuilder = ImmutableMap.builder();
    extraSettingsBuilder
        .put("TARGET_NAME", getProductName(buildTarget))
        .put("SRCROOT", pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
    if (bundleLoaderNode.isPresent()) {
      TargetNode<AppleBundleDescription.Arg> bundleLoader = bundleLoaderNode.get();
      String bundleLoaderProductName = getProductName(bundleLoader.getBuildTarget());
      String bundleName = bundleLoaderProductName + "." +
          getExtensionString(bundleLoader.getConstructorArg().getExtension());
      String bundleLoaderOutputPath = Joiner.on('/').join(
          getTargetOutputPath(bundleLoader),
          bundleName,

          bundleLoaderProductName);
      extraSettingsBuilder
          .put("BUNDLE_LOADER", bundleLoaderOutputPath)
          .put("TEST_HOST", "$(BUNDLE_LOADER)");
    }
    if (infoPlistOptional.isPresent()) {
      Path infoPlistPath = pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
      extraSettingsBuilder.put("INFOPLIST_FILE", infoPlistPath.toString());
    }
    Optional<SourcePath> prefixHeaderOptional = targetNode.getConstructorArg().prefixHeader;
    if (prefixHeaderOptional.isPresent()) {
      Path prefixHeaderRelative = sourcePathResolver.apply(prefixHeaderOptional.get());
      Path prefixHeaderPath = pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
      extraSettingsBuilder.put("GCC_PREFIX_HEADER", prefixHeaderPath.toString());
      extraSettingsBuilder.put("GCC_PRECOMPILE_PREFIX_HEADER", "YES");
    }
    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      extraSettingsBuilder.put("USE_HEADERMAP", "NO");
    }

    ImmutableMap.Builder<String, String> defaultSettingsBuilder = ImmutableMap.builder();
    defaultSettingsBuilder.put(
        "REPO_ROOT",
        projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
    defaultSettingsBuilder.put("PRODUCT_NAME", getProductName(buildTarget));
    if (bundle.isPresent()) {
      defaultSettingsBuilder.put(
          "WRAPPER_EXTENSION",
          getExtensionString(bundle.get().getConstructorArg().getExtension()));
    }
    String publicHeadersPath =
        getHeaderOutputPath(buildTargetNode, targetNode.getConstructorArg().headerPathPrefix);
    LOG.debug("Public headers path for %s: %s", targetNode, publicHeadersPath);
    defaultSettingsBuilder.put("PUBLIC_HEADERS_FOLDER_PATH", publicHeadersPath);




    defaultSettingsBuilder.put(
        "BUILT_PRODUCTS_DIR",


        Joiner.on('/').join("$SYMROOT", "$CONFIGURATION$EFFECTIVE_PLATFORM_NAME"));
    defaultSettingsBuilder.put("CONFIGURATION_BUILD_DIR", "$BUILT_PRODUCTS_DIR");
    if (!bundle.isPresent() && targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      defaultSettingsBuilder.put("EXECUTABLE_PREFIX", "lib");
    }

    ImmutableMap.Builder<String, String> appendConfigsBuilder = ImmutableMap.builder();

    appendConfigsBuilder
        .put(
            "HEADER_SEARCH_PATHS",
            Joiner.on(' ').join(
                Iterables.concat(
                    collectRecursiveHeaderSearchPaths(targetNode),
                    collectRecursiveHeaderMaps(targetNode))))
        .put(
            "LIBRARY_SEARCH_PATHS",
            Joiner.on(' ').join(
                collectRecursiveLibrarySearchPaths(ImmutableSet.of(targetNode))))
        .put(
            "FRAMEWORK_SEARCH_PATHS",
            Joiner.on(' ').join(
                collectRecursiveFrameworkSearchPaths(ImmutableList.of(targetNode))))
        .put(
            "OTHER_CFLAGS",
            Joiner
                .on(' ')
                .join(
                    Iterables.concat(
                        targetNode.getConstructorArg().compilerFlags.get(),
                        targetNode.getConstructorArg().preprocessorFlags.get(),
                        collectRecursiveExportedPreprocessorFlags(ImmutableList.of(targetNode)))))
        .put(
            "OTHER_LDFLAGS",
            Joiner
                .on(' ')
                .join(
                    MoreIterables.zipAndConcat(
                        Iterables.cycle("-Xlinker"),
                        Iterables.concat(
                            targetNode.getConstructorArg().linkerFlags.get(),
                            collectRecursiveExportedLinkerFlags(ImmutableList.of(targetNode))))));

    ImmutableMap<CxxSource.Type, ImmutableList<String>> langPreprocessorFlags =
        targetNode.getConstructorArg().langPreprocessorFlags.get();

    Sets.SetView<CxxSource.Type> unsupportedLangPreprocessorFlags =
        Sets.difference(langPreprocessorFlags.keySet(), SUPPORTED_LANG_PREPROCESSOR_FLAG_TYPES);

    if (!unsupportedLangPreprocessorFlags.isEmpty()) {
      throw new HumanReadableException(
          "%s: Xcode project generation does not support specified lang_preprocessor_flags keys: " +
              "%s",
          buildTarget,
          unsupportedLangPreprocessorFlags);
    }

    ImmutableSet.Builder<String> allCxxFlagsBuilder = ImmutableSet.builder();
    ImmutableList<String> cxxFlags = langPreprocessorFlags.get(CxxSource.Type.CXX);
    if (cxxFlags != null) {
      allCxxFlagsBuilder.addAll(cxxFlags);
    }
    ImmutableList<String> objcxxFlags = langPreprocessorFlags.get(CxxSource.Type.OBJCXX);
    if (objcxxFlags != null) {
      allCxxFlagsBuilder.addAll(objcxxFlags);
    }
    ImmutableSet<String> allCxxFlags = allCxxFlagsBuilder.build();
    if (!allCxxFlags.isEmpty()) {
      appendConfigsBuilder.put(
          "OTHER_CPLUSPLUSFLAGS",
          Joiner.on(' ').join(allCxxFlags));
    }

    PBXNativeTarget target = targetBuilderResult.target;

    setTargetBuildConfigurations(
        getConfigurationNameToXcconfigPath(buildTarget),
        target,
        targetGroup,
        targetNode.getConstructorArg().configs.get(),
        extraSettingsBuilder.build(),
        defaultSettingsBuilder.build(),
        appendConfigsBuilder.build());


    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      Path headerPathPrefix =
          AppleDescriptions.getHeaderPathPrefix(arg, targetNode.getBuildTarget());
      createHeaderSymlinkTree(
          sourcePathResolver,
          AppleDescriptions.convertAppleHeadersToPublicCxxHeaders(
              sourcePathResolver,
              headerPathPrefix,
              arg),
          AppleDescriptions.getPathToHeaderSymlinkTree(targetNode, HeaderVisibility.PUBLIC).get());
      createHeaderSymlinkTree(
          sourcePathResolver,
          AppleDescriptions.convertAppleHeadersToPrivateCxxHeaders(
              sourcePathResolver,
              headerPathPrefix,
              arg),
          AppleDescriptions.getPathToHeaderSymlinkTree(targetNode, HeaderVisibility.PRIVATE).get());
    }


    addCoreDataModelBuildPhase(
        targetGroup,
        FluentIterable
            .from(targetNode.getDeps())
            .transform(
                new Function<BuildTarget, TargetNode<?>>() {
                  @Override
                  public TargetNode<?> apply(BuildTarget input) {
                    return Preconditions.checkNotNull(targetGraph.get(input));
                  }
                })
            .filter(
                new Predicate<TargetNode<?>>() {
                  @Override
                  public boolean apply(TargetNode<?> input) {
                    return CoreDataModelDescription.TYPE.equals(input.getType());
                  }
                })
            .transform(
                new Function<TargetNode<?>, CoreDataModelDescription.Arg>() {
                  @Override
                  public CoreDataModelDescription.Arg apply(TargetNode<?> input) {
                    return (CoreDataModelDescription.Arg) input.getConstructorArg();
                  }
                })
            .toSet());

    return target;
  }

  private Function<String, Path> getConfigurationNameToXcconfigPath(final BuildTarget buildTarget) {
    return new Function<String, Path>() {
      @Override
      public Path apply(String input) {
        return BuildTargets.getGenPath(buildTarget, "%s-" + input + ".xcconfig");
      }
    };
  }

  private Iterable<SourcePath> getHeaderSourcePaths(
      Optional<SourceList> headers) {
    if (!headers.isPresent()) {
      return ImmutableList.of();
    } else if (headers.get().getUnnamedSources().isPresent()) {
      return headers.get().getUnnamedSources().get();
    } else {
      return headers.get().getNamedSources().get().values();
    }
  }

  private void generateCombinedTestTarget(
      final String productName,
      AppleTestBundleParamsKey key,
      ImmutableCollection<TargetNode<AppleTestDescription.Arg>> tests)
      throws IOException {
    ImmutableSet.Builder<PBXFileReference> testLibs = ImmutableSet.builder();
    for (TargetNode<AppleTestDescription.Arg> test : tests) {
      testLibs.add(getOrCreateTestLibraryFileReference(test));
    }
    NewNativeTargetProjectMutator mutator = new NewNativeTargetProjectMutator(
        pathRelativizer,
        sourcePathResolver)
        .setTargetName(productName)
        .setProduct(
            dylibProductTypeByBundleExtension(key.getExtension().getLeft()).get(),
            productName,
            Paths.get(productName + "." + getExtensionString(key.getExtension())))
        .setShouldGenerateCopyHeadersPhase(false)
        .setSourcesWithFlags(
            ImmutableSet.of(
                SourceWithFlags.of(
                    new PathSourcePath(projectFilesystem, emptyFileWithExtension("c")))))
        .setArchives(Sets.union(collectRecursiveLibraryDependencies(tests), testLibs.build()))
        .setResources(AppleResources.collectRecursiveResources(targetGraph, tests))
        .setAssetCatalogs(
            getAndMarkAssetCatalogBuildScript(),
            AppleBuildRules.collectRecursiveAssetCatalogs(targetGraph, tests));

    ImmutableSet.Builder<FrameworkPath> frameworksBuilder = ImmutableSet.builder();
    frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(tests));
    for (TargetNode<AppleTestDescription.Arg> test : tests) {
      frameworksBuilder.addAll(test.getConstructorArg().frameworks.get());
    }
    mutator.setFrameworks(frameworksBuilder.build());

    NewNativeTargetProjectMutator.Result result;
    try {
      result = mutator.buildTargetAndAddToProject(project);
    } catch (NoSuchBuildTargetException e) {
      throw new HumanReadableException(e);
    }

    ImmutableMap.Builder<String, String> overrideBuildSettingsBuilder =
        ImmutableMap.<String, String>builder()
            .put("GCC_PREFIX_HEADER", "")
            .put("USE_HEADERMAP", "NO");
    if (key.getInfoPlist().isPresent()) {
      overrideBuildSettingsBuilder.put(
          "INFOPLIST_FILE",
          pathRelativizer.outputDirToRootRelative(
              sourcePathResolver.apply(key.getInfoPlist().get())).toString());
    }
    setTargetBuildConfigurations(
        new Function<String, Path>() {
          @Override
          public Path apply(String input) {
            return outputDirectory.resolve(
                String.format("xcconfigs/%s-%s.xcconfig", productName, input));
          }
        },
        result.target,
        result.targetGroup,
        key.getConfigs().get(),
        overrideBuildSettingsBuilder.build(),
        ImmutableMap.of(
            "PRODUCT_NAME", productName,
            "WRAPPER_EXTENSION", getExtensionString(key.getExtension())),
        ImmutableMap.of(
            "FRAMEWORK_SEARCH_PATHS",
            Joiner.on(' ').join(collectRecursiveFrameworkSearchPaths(tests)),
            "LIBRARY_SEARCH_PATHS",
            Joiner.on(' ').join(collectRecursiveLibrarySearchPaths(tests)),
            "OTHER_LDFLAGS",
            Joiner.on(' ').join(
                MoreIterables.zipAndConcat(
                    Iterables.cycle("-Xlinker"),
                    Iterables.concat(
                        key.getLinkerFlags(),
                        collectRecursiveExportedLinkerFlags(tests))))));
    buildableCombinedTestTargets.add(result.target);
  }

  private String deriveCombinedTestTargetNameFromKey(
      AppleTestBundleParamsKey key,
      int combinedTestIndex) {
    return Joiner.on("-").join(
        "_BuckCombinedTest",
        getExtensionString(key.getExtension()),
        combinedTestIndex);

  }


  private void setTargetBuildConfigurations(
      Function<String, Path> configurationNameToXcconfigPath,
      PBXTarget target,
      PBXGroup targetGroup,
      ImmutableMap<String, ImmutableMap<String, String>> configurations,
      ImmutableMap<String, String> overrideBuildSettings,
      ImmutableMap<String, String> defaultBuildSettings,
      ImmutableMap<String, String> appendBuildSettings)
      throws IOException {

    for (Map.Entry<String, ImmutableMap<String, String>> configurationEntry :
        configurations.entrySet()) {
      targetConfigNamesBuilder.add(configurationEntry.getKey());

      ImmutableMap<String, String> targetLevelInlineSettings =
          configurationEntry.getValue();

      XCBuildConfiguration outputConfiguration = target
          .getBuildConfigurationList()
          .getBuildConfigurationsByName()
          .getUnchecked(configurationEntry.getKey());

      HashMap<String, String> combinedOverrideConfigs = Maps.newHashMap(overrideBuildSettings);
      for (Map.Entry<String, String> entry: defaultBuildSettings.entrySet()) {
        String existingSetting = targetLevelInlineSettings.get(entry.getKey());
        if (existingSetting == null) {
          combinedOverrideConfigs.put(entry.getKey(), entry.getValue());
        }
      }

      for (Map.Entry<String, String> entry : appendBuildSettings.entrySet()) {
        String existingSetting = targetLevelInlineSettings.get(entry.getKey());
        String settingPrefix = existingSetting != null ? existingSetting : "$(inherited)";
        combinedOverrideConfigs.put(entry.getKey(), settingPrefix + " " + entry.getValue());
      }

      Iterable<Map.Entry<String, String>> entries = Iterables.concat(
          targetLevelInlineSettings.entrySet(),
          combinedOverrideConfigs.entrySet());

      Path xcconfigPath = configurationNameToXcconfigPath.apply(configurationEntry.getKey());
      projectFilesystem.mkdirs(Preconditions.checkNotNull(xcconfigPath).getParent());

      StringBuilder stringBuilder = new StringBuilder();
      for (Map.Entry<String, String> entry : entries) {
        stringBuilder.append(entry.getKey());
        stringBuilder.append(" = ");
        stringBuilder.append(entry.getValue());
        stringBuilder.append('\n');
      }
      String xcconfigContents = stringBuilder.toString();

      if (MorePaths.fileContentsDiffer(
          new ByteArrayInputStream(xcconfigContents.getBytes(Charsets.UTF_8)),
          xcconfigPath,
          projectFilesystem)) {
        if (shouldGenerateReadOnlyFiles()) {
          projectFilesystem.writeContentsToPath(
              xcconfigContents,
              xcconfigPath,
              READ_ONLY_FILE_ATTRIBUTE);
        } else {
          projectFilesystem.writeContentsToPath(
              xcconfigContents,
              xcconfigPath);
        }
      }

      PBXFileReference fileReference = getConfigurationFileReference(targetGroup, xcconfigPath);
      outputConfiguration.setBaseConfigurationReference(fileReference);
    }
  }

  private PBXFileReference getConfigurationFileReference(PBXGroup targetGroup, Path xcconfigPath) {
    return targetGroup
        .getOrCreateChildGroupByName("Configurations")
        .getOrCreateFileReferenceBySourceTreePath(
            new SourceTreePath(
                PBXReference.SourceTree.SOURCE_ROOT,
                pathRelativizer.outputDirToRootRelative(xcconfigPath)));
  }

  private void collectBuildScriptDependencies(
      Iterable<TargetNode<?>> targetNodes,
      ImmutableList.Builder<TargetNode<?>> preRules,
      ImmutableList.Builder<TargetNode<?>> postRules) {
    for (TargetNode<?> targetNode : targetNodes) {
      BuildRuleType type = targetNode.getType();
      if (type.equals(XcodePostbuildScriptDescription.TYPE) ||
          type.equals(IosReactNativeLibraryDescription.TYPE)) {
        postRules.add(targetNode);
      } else if (
          type.equals(XcodePrebuildScriptDescription.TYPE) ||
              type.equals(GenruleDescription.TYPE)) {
        preRules.add(targetNode);
      }
    }
  }

  private void createHeaderSymlinkTree(
      Function<SourcePath, Path> pathResolver,
      Map<String, SourcePath> contents,
      Path headerSymlinkTreeRoot) throws IOException {
    LOG.verbose(
        "Building header symlink tree at %s with contents %s",
        headerSymlinkTreeRoot,
        contents);
    ImmutableSortedMap.Builder<Path, Path> resolvedContentsBuilder =
        ImmutableSortedMap.naturalOrder();
    for (Map.Entry<String, SourcePath> entry : contents.entrySet()) {
      Path link = headerSymlinkTreeRoot.resolve(entry.getKey());
      Path existing = projectFilesystem.resolve(pathResolver.apply(entry.getValue()));
      resolvedContentsBuilder.put(link, existing);
    }
    ImmutableSortedMap<Path, Path> resolvedContents = resolvedContentsBuilder.build();

    Path headerMapLocation = getHeaderMapLocationFromSymlinkTreeRoot(headerSymlinkTreeRoot);

    Path hashCodeFilePath = headerSymlinkTreeRoot.resolve(".contents-hash");
    Optional<String> currentHashCode = projectFilesystem.readFileIfItExists(hashCodeFilePath);
    String newHashCode = getHeaderSymlinkTreeHashCode(resolvedContents).toString();
    if (Optional.of(newHashCode).equals(currentHashCode)) {
      LOG.debug(
          "Symlink tree at %s is up to date, not regenerating (key %s).",
          headerSymlinkTreeRoot,
          newHashCode);
    } else {
      LOG.debug(
          "Updating symlink tree at %s (old key %s, new key %s).",
          headerSymlinkTreeRoot,
          currentHashCode,
          newHashCode);
      projectFilesystem.deleteRecursivelyIfExists(headerSymlinkTreeRoot);
      projectFilesystem.mkdirs(headerSymlinkTreeRoot);
      for (Map.Entry<Path, Path> entry : resolvedContents.entrySet()) {
        Path link = entry.getKey();
        Path existing = entry.getValue();
        projectFilesystem.createParentDirs(link);
        projectFilesystem.createSymLink(link, existing,  false);
      }
      projectFilesystem.writeContentsToPath(newHashCode, hashCodeFilePath);

      HeaderMap.Builder headerMapBuilder = new HeaderMap.Builder();
      for (Map.Entry<String, SourcePath> entry : contents.entrySet()) {
        headerMapBuilder.add(
            entry.getKey(),
            projectFilesystem.resolve(headerSymlinkTreeRoot).resolve(entry.getKey()));
      }
      projectFilesystem.writeBytesToPath(headerMapBuilder.build().getBytes(), headerMapLocation);
    }
    headerSymlinkTrees.add(headerSymlinkTreeRoot);
  }

  private HashCode getHeaderSymlinkTreeHashCode(ImmutableSortedMap<Path, Path> contents) {
    Hasher hasher = Hashing.sha1().newHasher();
    hasher.putBytes(BuckVersion.getVersion().getBytes(Charsets.UTF_8));
    for (Map.Entry<Path, Path> entry : contents.entrySet()) {
      byte[] key = entry.getKey().toString().getBytes(Charsets.UTF_8);
      byte[] value = entry.getValue().toString().getBytes(Charsets.UTF_8);
      hasher.putInt(key.length);
      hasher.putBytes(key);
      hasher.putInt(value.length);
      hasher.putBytes(value);
    }
    return hasher.hash();
  }

  private void addCoreDataModelBuildPhase(
      PBXGroup targetGroup,
      Iterable<CoreDataModelDescription.Arg> dataModels) throws IOException {


    for (final CoreDataModelDescription.Arg dataModel : dataModels) {

      PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");

      if (CoreDataModelDescription.isVersionedDataModel(dataModel)) {




        final String currentVersionFileName = ".xccurrentversion";
        final String currentVersionKey = "_XCCurrentVersionName";

        final XCVersionGroup versionGroup =
            resourcesGroup.getOrCreateChildVersionGroupsBySourceTreePath(
                new SourceTreePath(
                    PBXReference.SourceTree.SOURCE_ROOT,
                    pathRelativizer.outputDirToRootRelative(dataModel.path)));

        projectFilesystem.walkRelativeFileTree(
            dataModel.path,
            new SimpleFileVisitor<Path>() {
              @Override
              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                if (dir.equals(dataModel.path)) {
                  return FileVisitResult.CONTINUE;
                }
                versionGroup.getOrCreateFileReferenceBySourceTreePath(
                    new SourceTreePath(
                        PBXReference.SourceTree.SOURCE_ROOT,
                        pathRelativizer.outputDirToRootRelative(dir)));
                return FileVisitResult.SKIP_SUBTREE;
              }
            });

        Path currentVersionPath = dataModel.path.resolve(currentVersionFileName);
        try (InputStream in = projectFilesystem.newFileInputStream(currentVersionPath)) {
          NSObject rootObject;
          try {
            rootObject = PropertyListParser.parse(in);
          } catch (IOException e) {
            throw e;
          } catch (Exception e) {
            rootObject = null;
          }
          if (!(rootObject instanceof NSDictionary)) {
            throw new HumanReadableException("Malformed %s file.", currentVersionFileName);
          }
          NSDictionary rootDictionary = (NSDictionary) rootObject;
          NSObject currentVersionName = rootDictionary.objectForKey(currentVersionKey);
          if (!(currentVersionName instanceof NSString)) {
            throw new HumanReadableException("Malformed %s file.", currentVersionFileName);
          }
          PBXFileReference ref = versionGroup.getOrCreateFileReferenceBySourceTreePath(
              new SourceTreePath(
                  PBXReference.SourceTree.SOURCE_ROOT,
                  pathRelativizer.outputDirToRootRelative(
                      dataModel.path.resolve(currentVersionName.toString()))));
          versionGroup.setCurrentVersion(Optional.of(ref));
        } catch (NoSuchFileException e) {
          if (versionGroup.getChildren().size() == 1) {
            versionGroup.setCurrentVersion(Optional.of(Iterables.get(
                        versionGroup.getChildren(),
                        0)));
          }
        }
      } else {
        resourcesGroup.getOrCreateFileReferenceBySourceTreePath(
            new SourceTreePath(
                PBXReference.SourceTree.SOURCE_ROOT,
                pathRelativizer.outputDirToRootRelative(dataModel.path)));
      }
    }
  }

  private Optional<CopyFilePhaseDestinationSpec> getDestinationSpec(TargetNode<?> targetNode) {
    if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      AppleBundleDescription.Arg arg = (AppleBundleDescription.Arg) targetNode.getConstructorArg();
      AppleBundleExtension extension = arg.extension.isLeft() ?
          arg.extension.getLeft() :
          AppleBundleExtension.BUNDLE;
      switch (extension) {
        case FRAMEWORK:
          return Optional.of(
              CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.FRAMEWORKS)
          );
        case APPEX:
        case PLUGIN:
          return Optional.of(
              CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.PLUGINS)
          );
        case APP:
          if (isWatchApplicationNode(targetNode)) {
            return Optional.of(
                CopyFilePhaseDestinationSpec.builder()
                    .setDestination(PBXCopyFilesBuildPhase.Destination.PRODUCTS)
                    .setPath("$(CONTENTS_FOLDER_PATH)/Watch")
                    .build()
            );
          } else {
            return Optional.of(
                CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.EXECUTABLES)
            );
          }

        default:
          return Optional.of(
              CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.PRODUCTS)
          );
      }
    } else if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      if (targetNode
          .getBuildTarget()
          .getFlavors()
          .contains(CxxDescriptionEnhancer.SHARED_FLAVOR)) {
        return Optional.of(
            CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.FRAMEWORKS)
        );
      } else {
        return Optional.absent();
      }
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      return Optional.of(
          CopyFilePhaseDestinationSpec.of(PBXCopyFilesBuildPhase.Destination.EXECUTABLES)
      );
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }
  }

  private void generateCopyFilesBuildPhases(
      PBXNativeTarget target,
      Iterable<TargetNode<?>> copiedNodes) {


    ImmutableSetMultimap.Builder<CopyFilePhaseDestinationSpec, TargetNode<?>>
        ruleByDestinationSpecBuilder = ImmutableSetMultimap.builder();
    for (TargetNode<?> copiedNode : copiedNodes) {
      Optional<CopyFilePhaseDestinationSpec> optionalDestinationSpec =
          getDestinationSpec(copiedNode);
      if (optionalDestinationSpec.isPresent()) {
        ruleByDestinationSpecBuilder.put(optionalDestinationSpec.get(), copiedNode);
      }
    }

    ImmutableSetMultimap<CopyFilePhaseDestinationSpec, TargetNode<?>> ruleByDestinationSpec =
        ruleByDestinationSpecBuilder.build();


    for (CopyFilePhaseDestinationSpec destinationSpec : ruleByDestinationSpec.keySet()) {
      Iterable<TargetNode<?>> targetNodes = ruleByDestinationSpec.get(destinationSpec);
      generateSingleCopyFilesBuildPhase(target, destinationSpec, targetNodes);
    }
  }

  private void generateSingleCopyFilesBuildPhase(
      PBXNativeTarget target,
      CopyFilePhaseDestinationSpec destinationSpec,
      Iterable<TargetNode<?>> targetNodes) {
    PBXCopyFilesBuildPhase copyFilesBuildPhase = new PBXCopyFilesBuildPhase(destinationSpec);
    target.getBuildPhases().add(copyFilesBuildPhase);
    for (TargetNode<?> targetNode : targetNodes) {
      PBXFileReference fileReference = getLibraryFileReference(targetNode);
      copyFilesBuildPhase.getFiles().add(new PBXBuildFile(fileReference));
    }
  }


  private Path writeProjectFile(PBXProject project) throws IOException {
    XcodeprojSerializer serializer = new XcodeprojSerializer(
        new GidGenerator(ImmutableSet.copyOf(gidsToTargetNames.keySet())),
        project);
    NSDictionary rootObject = serializer.toPlist();
    Path xcodeprojDir = outputDirectory.resolve(projectName + ".xcodeproj");
    projectFilesystem.mkdirs(xcodeprojDir);
    Path serializedProject = xcodeprojDir.resolve("project.pbxproj");
    String contentsToWrite = rootObject.toXMLPropertyList();

    if (MorePaths.fileContentsDiffer(
        new ByteArrayInputStream(contentsToWrite.getBytes(Charsets.UTF_8)),
        serializedProject,
        projectFilesystem)) {
      LOG.debug("Regenerating project at %s", serializedProject);
      if (shouldGenerateReadOnlyFiles()) {
        projectFilesystem.writeContentsToPath(
            contentsToWrite,
            serializedProject,
            READ_ONLY_FILE_ATTRIBUTE);
      } else {
        projectFilesystem.writeContentsToPath(
            contentsToWrite,
            serializedProject);
      }
    } else {
      LOG.debug("Not regenerating project at %s (contents have not changed)", serializedProject);
    }
    return xcodeprojDir;
  }

  private static String getProductName(BuildTarget buildTarget) {
    return buildTarget.getShortName();
  }

  private String getHeaderOutputPath(
      TargetNode<?> buildTargetNode,
      Optional<String> headerPathPrefix) {

    return Joiner.on('/').join(
        getBuiltProductsRelativeTargetOutputPath(buildTargetNode),
        "Headers",
        headerPathPrefix.or("$TARGET_NAME"));
  }


  private Path getHeaderSymlinkTreeRelativePath(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      HeaderVisibility headerVisibility) {
    Optional<Path> treeRoot = AppleDescriptions.getPathToHeaderSymlinkTree(
        targetNode,
        headerVisibility);
    Preconditions.checkState(
        treeRoot.isPresent(),
        "%s does not have a header symlink tree.",
        targetNode);
    return pathRelativizer.outputDirToRootRelative(treeRoot.get());
  }

  private Path getHeaderMapLocationFromSymlinkTreeRoot(Path headerSymlinkTreeRoot) {
    return headerSymlinkTreeRoot.resolve(".tree.hmap");
  }

  private String getHeaderSearchPath(TargetNode<?> targetNode) {
    return Joiner.on('/').join(
        getTargetOutputPath(targetNode),
        "Headers");
  }

  private String getBuiltProductsRelativeTargetOutputPath(TargetNode<?> targetNode) {
    if (targetNode.getType().equals(AppleBinaryDescription.TYPE) ||
        targetNode.getType().equals(AppleTestDescription.TYPE) ||
        (targetNode.getType().equals(AppleBundleDescription.TYPE) &&
            !isFrameworkBundle((AppleBundleDescription.Arg) targetNode.getConstructorArg()))) {



      return ".";
    } else {
      return BaseEncoding
          .base32()
          .omitPadding()
          .encode(targetNode.getBuildTarget().getFullyQualifiedName().getBytes());
    }
  }

  private String getTargetOutputPath(TargetNode<?> targetNode) {
    return Joiner.on('/').join(
        "$BUILT_PRODUCTS_DIR",
        getBuiltProductsRelativeTargetOutputPath(targetNode));
  }

  @SuppressWarnings("unchecked")
  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getAppleNativeNodeOfType(
      TargetGraph targetGraph,
      TargetNode<?> targetNode,
      Set<BuildRuleType> nodeTypes,
      Set<AppleBundleExtension> bundleExtensions) {
    Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode = Optional.absent();
    if (nodeTypes.contains(targetNode.getType())) {
      nativeNode = Optional.of((TargetNode<AppleNativeTargetDescriptionArg>) targetNode);
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      TargetNode<AppleBundleDescription.Arg> bundle =
          (TargetNode<AppleBundleDescription.Arg>) targetNode;
      Either<AppleBundleExtension, String> extension = bundle.getConstructorArg().getExtension();
      if (extension.isLeft() && bundleExtensions.contains(extension.getLeft())) {
        nativeNode = Optional.of(
            Preconditions.checkNotNull(
                (TargetNode<AppleNativeTargetDescriptionArg>) targetGraph.get(
                    bundle.getConstructorArg().binary)));
      }
    }
    return nativeNode;
  }

  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getAppleNativeNode(
      TargetGraph targetGraph,
      TargetNode<?> targetNode) {
    return getAppleNativeNodeOfType(
        targetGraph,
        targetNode,
        ImmutableSet.of(
            AppleBinaryDescription.TYPE,
            AppleLibraryDescription.TYPE),
        ImmutableSet.of(
            AppleBundleExtension.APP,
            AppleBundleExtension.FRAMEWORK));
  }

  private static Optional<TargetNode<AppleNativeTargetDescriptionArg>> getLibraryNode(
      TargetGraph targetGraph,
      TargetNode<?> targetNode) {
    return getAppleNativeNodeOfType(
        targetGraph,
        targetNode,
        ImmutableSet.of(
            AppleLibraryDescription.TYPE),
        ImmutableSet.of(
            AppleBundleExtension.FRAMEWORK));
  }

  private ImmutableSet<String> collectRecursiveHeaderSearchPaths(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    LOG.debug("Collecting recursive header search paths for %s...", targetNode);
    return FluentIterable
        .from(
            AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.BUILDING,
                targetNode,
                Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES)))
        .filter(
            new Predicate<TargetNode<?>>() {
              @Override
              public boolean apply(TargetNode<?> input) {
                Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
                    getAppleNativeNode(targetGraph, input);
                return nativeNode.isPresent() &&
                    !nativeNode.get().getConstructorArg().getUseBuckHeaderMaps();
              }
            })
        .transform(
            new Function<TargetNode<?>, String>() {
              @Override
              public String apply(TargetNode<?> input) {
                String result = getHeaderSearchPath(input);
                LOG.debug("Header search path for %s: %s", input, result);
                return result;
              }
            })
        .toSet();
  }

  private ImmutableSet<Path> collectRecursiveHeaderMaps(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();

    for (Path headerSymlinkTreePath : collectRecursiveHeaderSymlinkTrees(targetNode)) {
      builder.add(getHeaderMapLocationFromSymlinkTreeRoot(headerSymlinkTreePath));
    }

    return builder.build();
  }

  private ImmutableSet<Path> collectRecursiveHeaderSymlinkTrees(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode) {
    ImmutableSet.Builder<Path> builder = ImmutableSet.builder();

    if (targetNode.getConstructorArg().getUseBuckHeaderMaps()) {
      builder.add(getHeaderSymlinkTreeRelativePath(targetNode, HeaderVisibility.PRIVATE));
      builder.add(getHeaderSymlinkTreeRelativePath(targetNode, HeaderVisibility.PUBLIC));
    }

    for (TargetNode<?> input :
        AppleBuildRules.getRecursiveTargetNodeDependenciesOfTypes(
            targetGraph,
            AppleBuildRules.RecursiveDependenciesMode.BUILDING,
            targetNode,
            Optional.of(AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))) {
      Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
          getAppleNativeNode(targetGraph, input);
      if (nativeNode.isPresent() && nativeNode.get().getConstructorArg().getUseBuckHeaderMaps()) {
        builder.add(
            getHeaderSymlinkTreeRelativePath(
                nativeNode.get(),
                HeaderVisibility.PUBLIC));
      }
    }

    addHeaderSymlinkTreesForSourceUnderTest(targetNode, builder, HeaderVisibility.PRIVATE);

    return builder.build();
  }

  private void addHeaderSymlinkTreesForSourceUnderTest(
      TargetNode<? extends AppleNativeTargetDescriptionArg> targetNode,
      ImmutableSet.Builder<Path> headerSymlinkTreesBuilder,
      HeaderVisibility headerVisibility) {
    ImmutableSet<TargetNode<?>> directDependencies = ImmutableSet.copyOf(
        targetGraph.getAll(targetNode.getDeps()));
    for (TargetNode<?> dependency : directDependencies) {
      Optional<TargetNode<AppleNativeTargetDescriptionArg>> nativeNode =
          getAppleNativeNode(targetGraph, dependency);
      if (nativeNode.isPresent() &&
          isSourceUnderTest(dependency, nativeNode.get(), targetNode) &&
          nativeNode.get().getConstructorArg().getUseBuckHeaderMaps()) {
        headerSymlinkTreesBuilder.add(
            getHeaderSymlinkTreeRelativePath(
                nativeNode.get(),
                headerVisibility));
      }
    }
  }

  private boolean isSourceUnderTest(
      TargetNode<?> dependencyNode,
      TargetNode<AppleNativeTargetDescriptionArg> nativeNode,
      TargetNode<?> testNode) {
    boolean isSourceUnderTest =
        nativeNode.getConstructorArg().getTests().contains(testNode.getBuildTarget());

    if (dependencyNode != nativeNode && dependencyNode.getConstructorArg() instanceof HasTests) {
      ImmutableSortedSet<BuildTarget> tests =
          ((HasTests) dependencyNode.getConstructorArg()).getTests();
      if (tests.contains(testNode.getBuildTarget())) {
        isSourceUnderTest = true;
      }
    }

    return isSourceUnderTest;
  }

  private <T> ImmutableSet<String> collectRecursiveLibrarySearchPaths(
      Iterable<TargetNode<T>> targetNodes) {
    return new ImmutableSet.Builder<String>()
        .add("$BUILT_PRODUCTS_DIR")
        .addAll(
            collectRecursiveSearchPathsForFrameworkPaths(
                targetNodes,
                FrameworkPath.FrameworkType.LIBRARY))
        .build();
  }

  private <T> ImmutableSet<String> collectRecursiveFrameworkSearchPaths(
      Iterable<TargetNode<T>> targetNodes) {
    return new ImmutableSet.Builder<String>()
        .add("$BUILT_PRODUCTS_DIR")
        .addAll(
            collectRecursiveSearchPathsForFrameworkPaths(
                targetNodes,
                FrameworkPath.FrameworkType.FRAMEWORK))
        .build();
  }

  private <T> Iterable<FrameworkPath> collectRecursiveFrameworkDependencies(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<FrameworkPath>>() {
              @Override
              public Iterable<FrameworkPath> apply(TargetNode<?> input) {
                Optional<TargetNode<AppleNativeTargetDescriptionArg>> library =
                    getLibraryNode(targetGraph, input);
                if (library.isPresent() &&
                    !AppleLibraryDescription.isSharedLibraryTarget(
                        library.get().getBuildTarget())) {
                  return library.get().getConstructorArg().frameworks.get();
                } else {
                  return ImmutableList.of();
                }
              }
            });
  }

  private <T> Iterable<String> collectRecursiveSearchPathsForFrameworkPaths(
      Iterable<TargetNode<T>> targetNodes,
      final FrameworkPath.FrameworkType type) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<String>>() {
              @Override
              public Iterable<String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(getTargetFrameworkSearchPaths(type))
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> Iterable<String> collectRecursiveExportedPreprocessorFlags(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.BUILDING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<? extends String>>() {
              @Override
              public Iterable<? extends String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(GET_EXPORTED_PREPROCESSOR_FLAGS)
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> Iterable<String> collectRecursiveExportedLinkerFlags(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                ImmutableSet.of(AppleLibraryDescription.TYPE)))
        .append(targetNodes)
        .transformAndConcat(
            new Function<TargetNode<?>, Iterable<? extends String>>() {
              @Override
              public Iterable<String> apply(TargetNode<?> input) {
                return input
                    .castArg(AppleNativeTargetDescriptionArg.class)
                    .transform(GET_EXPORTED_LINKER_FLAGS)
                    .or(ImmutableSet.<String>of());
              }
            });
  }

  private <T> ImmutableSet<PBXFileReference> collectRecursiveLibraryDependencies(
      Iterable<TargetNode<T>> targetNodes) {
    return FluentIterable
        .from(targetNodes)
        .transformAndConcat(
            AppleBuildRules.newRecursiveRuleDependencyTransformer(
                targetGraph,
                AppleBuildRules.RecursiveDependenciesMode.LINKING,
                AppleBuildRules.XCODE_TARGET_BUILD_RULE_TYPES))
        .filter(getLibraryWithSourcesToCompilePredicate())
        .transform(
            new Function<TargetNode<?>, PBXFileReference>() {
              @Override
              public PBXFileReference apply(TargetNode<?> input) {
                return getLibraryFileReference(input);
              }
            }).toSet();
  }

  private Function<
      TargetNode<AppleNativeTargetDescriptionArg>,
      Iterable<String>> getTargetFrameworkSearchPaths(final FrameworkPath.FrameworkType type) {

    final Predicate<FrameworkPath> byType = Predicates.compose(
        Predicates.equalTo(type),
        FrameworkPath.getFrameworkTypeFunction(sourcePathResolver));

    final Function<FrameworkPath, Path> toSearchPath = FrameworkPath
        .getUnexpandedSearchPathFunction(
            sourcePathResolver,
            pathRelativizer.outputDirToRootRelative());

    return new Function<TargetNode<AppleNativeTargetDescriptionArg>, Iterable<String>>() {
      @Override
      public Iterable<String> apply(TargetNode<AppleNativeTargetDescriptionArg> input) {
        return FluentIterable
            .from(input.getConstructorArg().frameworks.get())
            .filter(byType)
            .transform(toSearchPath)
            .transform(Functions.toStringFunction());
      }
    };
  }

  private SourceTreePath getProductsSourceTreePath(TargetNode<?> targetNode) {
    String productName = getProductName(targetNode.getBuildTarget());
    String productOutputName;

    if (targetNode.getType().equals(AppleLibraryDescription.TYPE)) {
      String productOutputFormat = AppleBuildRules.getOutputFileNameFormatForLibrary(
          targetNode
              .getBuildTarget()
              .getFlavors()
              .contains(CxxDescriptionEnhancer.SHARED_FLAVOR));
      productOutputName = String.format(productOutputFormat, productName);
    } else if (targetNode.getType().equals(AppleBundleDescription.TYPE) ||
        targetNode.getType().equals(AppleTestDescription.TYPE)) {
      HasAppleBundleFields arg = (HasAppleBundleFields) targetNode.getConstructorArg();
      productOutputName = productName + "." + getExtensionString(arg.getExtension());
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      productOutputName = productName;
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }

    return new SourceTreePath(
        PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
        Paths.get(productOutputName));
  }

  private PBXFileReference getLibraryFileReference(TargetNode<?> targetNode) {


    SourceTreePath productsPath = getProductsSourceTreePath(targetNode);

    if (isWatchApplicationNode(targetNode)) {
      return project.getMainGroup()
          .getOrCreateChildGroupByName("Products")
          .getOrCreateFileReferenceBySourceTreePath(productsPath);
    } else if (targetNode.getType().equals(AppleLibraryDescription.TYPE) ||
        targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      return project.getMainGroup()
          .getOrCreateChildGroupByName("Frameworks")
          .getOrCreateFileReferenceBySourceTreePath(productsPath);
    } else if (targetNode.getType().equals(AppleBinaryDescription.TYPE)) {
      return project.getMainGroup()
          .getOrCreateChildGroupByName("Dependencies")
          .getOrCreateFileReferenceBySourceTreePath(productsPath);
    } else {
      throw new RuntimeException("Unexpected type: " + targetNode.getType());
    }
  }


  private PBXFileReference getOrCreateTestLibraryFileReference(
      TargetNode<AppleTestDescription.Arg> test) {
    SourceTreePath path = new SourceTreePath(
        PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
        Paths.get(getBuiltProductsRelativeTargetOutputPath(test)).resolve(
            String.format(
                AppleBuildRules.getOutputFileNameFormatForLibrary(false),
                getProductName(test.getBuildTarget()))));
    return project.getMainGroup()
        .getOrCreateChildGroupByName("Test Libraries")
        .getOrCreateFileReferenceBySourceTreePath(path);
  }


  private boolean isBuiltByCurrentProject(BuildTarget buildTarget) {
    return initialTargets.contains(buildTarget);
  }

  private String getXcodeTargetName(BuildTarget target) {
    return options.contains(Option.USE_SHORT_NAMES_FOR_TARGETS)
        ? target.getShortName()
        : target.getFullyQualifiedName();
  }

  @SuppressWarnings("incomplete-switch")
  ProductType bundleToTargetProductType(
      TargetNode<? extends HasAppleBundleFields> targetNode,
      TargetNode<? extends AppleNativeTargetDescriptionArg> binaryNode) {
    if (targetNode.getConstructorArg().getXcodeProductType().isPresent()) {
      return ProductType.of(targetNode.getConstructorArg().getXcodeProductType().get());
    } else if (targetNode.getConstructorArg().getExtension().isLeft()) {
      AppleBundleExtension extension = targetNode.getConstructorArg().getExtension().getLeft();

      if (binaryNode.getType().equals(AppleLibraryDescription.TYPE)) {
        if (binaryNode.getBuildTarget().getFlavors().contains(
            CxxDescriptionEnhancer.SHARED_FLAVOR)) {
          Optional<ProductType> productType =
              dylibProductTypeByBundleExtension(extension);
          if (productType.isPresent()) {
            return productType.get();
          }
        } else {
          switch (extension) {
            case FRAMEWORK:
              return ProductType.STATIC_FRAMEWORK;
          }
        }
      } else if (binaryNode.getType().equals(AppleBinaryDescription.TYPE)) {
        switch (extension) {
          case APP:
            return ProductType.APPLICATION;
        }
      } else if (binaryNode.getType().equals(AppleTestDescription.TYPE)) {
        switch (extension) {
          case OCTEST:
            return ProductType.BUNDLE;
          case XCTEST:
            return ProductType.UNIT_TEST;
        }
      }
    }

    return ProductType.BUNDLE;
  }

  private boolean shouldGenerateReadOnlyFiles() {
    return options.contains(Option.GENERATE_READ_ONLY_FILES);
  }

  private static String getExtensionString(Either<AppleBundleExtension, String> extension) {
    return extension.isLeft() ? extension.getLeft().toFileExtension() : extension.getRight();
  }

  private static boolean isFrameworkBundle(HasAppleBundleFields arg) {
    return arg.getExtension().isLeft() &&
        arg.getExtension().getLeft().equals(AppleBundleExtension.FRAMEWORK);
  }


  private Path getAndMarkAssetCatalogBuildScript() {
    if (PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT != null) {
      return Paths.get(PATH_OVERRIDE_FOR_ASSET_CATALOG_BUILD_PHASE_SCRIPT);
    } else {


      shouldPlaceAssetCatalogCompiler = true;
      return placedAssetCatalogBuildPhaseScript;
    }
  }

  private Path emptyFileWithExtension(String extension) {
    Path path = BuckConstant.GEN_PATH.resolve("xcode-scripts/emptyFile." + extension);
    if (!projectFilesystem.exists(path)) {
      try {
        projectFilesystem.createParentDirs(path);
        projectFilesystem.newFileOutputStream(path).close();
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
    return path;
  }

  private Path resolveSourcePath(SourcePath sourcePath) {
    if (sourcePath instanceof PathSourcePath) {
      return ((PathSourcePath) sourcePath).getRelativePath();
    }
    Preconditions.checkArgument(sourcePath instanceof BuildTargetSourcePath);
    BuildTargetSourcePath buildTargetSourcePath = (BuildTargetSourcePath) sourcePath;
    BuildTarget buildTarget = buildTargetSourcePath.getTarget();
    TargetNode<?> node = Preconditions.checkNotNull(targetGraph.get(buildTarget));
    Optional<TargetNode<ExportFileDescription.Arg>> exportFileNode = node.castArg(
        ExportFileDescription.Arg.class);
    if (!exportFileNode.isPresent()) {
      Path output = outputPathOfNode.apply(node);
      if (output == null) {
        throw new HumanReadableException(
            "The target '%s' does not have an output.",
            node.getBuildTarget());
      }
      requiredBuildTargetsBuilder.add(buildTarget);
      return output;
    }

    Optional<SourcePath> src = exportFileNode.get().getConstructorArg().src;
    if (!src.isPresent()) {
      return buildTarget.getBasePath().resolve(buildTarget.getShortNameAndFlavorPostfix());
    }

    return resolveSourcePath(src.get());
  }

  private Predicate<TargetNode<?>> getLibraryWithSourcesToCompilePredicate() {
    return new Predicate<TargetNode<?>>() {
      @Override
      public boolean apply(TargetNode<?> input) {
        Optional<TargetNode<AppleNativeTargetDescriptionArg>> library =
            getLibraryNode(targetGraph, input);
        if (!library.isPresent()) {
          return false;
        }
        return (library.get().getConstructorArg().srcs.get().size() != 0);
      }
    };
  }


  private static Optional<ProductType> dylibProductTypeByBundleExtension(
      AppleBundleExtension extension) {
    switch (extension) {
      case FRAMEWORK:
        return Optional.of(ProductType.FRAMEWORK);
      case APPEX:
        return Optional.of(ProductType.APP_EXTENSION);
      case BUNDLE:
        return Optional.of(ProductType.BUNDLE);
      case OCTEST:
        return Optional.of(ProductType.BUNDLE);
      case XCTEST:
        return Optional.of(ProductType.UNIT_TEST);

      default:
        return Optional.absent();
    }
  }


  private static boolean isWatchApplicationNode(TargetNode<?> targetNode) {
    if (targetNode.getType().equals(AppleBundleDescription.TYPE)) {
      AppleBundleDescription.Arg arg = (AppleBundleDescription.Arg) targetNode.getConstructorArg();
      return arg.getXcodeProductType().equals(
          Optional.of(ProductType.WATCH_APPLICATION.getIdentifier())
      );
    }
    return false;
  }
}

<code block>


package com.facebook.buck.apple.xcode.xcodeproj;

import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.base.Optional;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
interface AbstractCopyFilePhaseDestinationSpec {

  @Value.Parameter
  PBXCopyFilesBuildPhase.Destination getDestination();

  Optional<String> getPath();

}


<code block>


package com.facebook.buck.apple.xcode.xcodeproj;

import com.facebook.buck.util.immutables.BuckStyleImmutable;

import org.immutables.value.Value;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractProductType {
  public static final ProductType STATIC_LIBRARY = ProductType.of(
      "com.apple.product-type.library.static");
  public static final ProductType DYNAMIC_LIBRARY = ProductType.of(
      "com.apple.product-type.library.dynamic");
  public static final ProductType TOOL = ProductType.of(
      "com.apple.product-type.tool");
  public static final ProductType BUNDLE = ProductType.of(
      "com.apple.product-type.bundle");
  public static final ProductType FRAMEWORK = ProductType.of(
      "com.apple.product-type.framework");
  public static final ProductType STATIC_FRAMEWORK = ProductType.of(
      "com.apple.product-type.framework.static");
  public static final ProductType APPLICATION = ProductType.of(
      "com.apple.product-type.application");
  public static final ProductType WATCH_APPLICATION = ProductType.of(
      "com.apple.product-type.application.watchapp2");
  public static final ProductType UNIT_TEST = ProductType.of(
      "com.apple.product-type.bundle.unit-test");
  public static final ProductType APP_EXTENSION = ProductType.of(
      "com.apple.product-type.app-extension");

  @Value.Parameter
  public abstract String getIdentifier();

  @Override
  public String toString() {
    return getIdentifier();
  }
}

<code block>


package com.facebook.buck.apple.xcode.xcodeproj;

import com.facebook.buck.apple.xcode.XcodeprojSerializer;

public class PBXCopyFilesBuildPhase extends PBXBuildPhase {

  public enum Destination {
    ABSOLUTE(0),
    WRAPPER(1),
    EXECUTABLES(6),
    RESOURCES(7),
    FRAMEWORKS(10),
    SHARED_FRAMEWORKS(11),
    SHARED_SUPPORT(12),
    PLUGINS(13),
    JAVA_RESOURCES(15),
    PRODUCTS(16),
    ;

    private int value;

    public int getValue() {
      return value;
    }

    private Destination(int value) {
      this.value = value;
    }
  }


  private CopyFilePhaseDestinationSpec dstSubfolderSpec;

  public PBXCopyFilesBuildPhase(CopyFilePhaseDestinationSpec dstSubfolderSpec) {
    this.dstSubfolderSpec = dstSubfolderSpec;
  }

  public CopyFilePhaseDestinationSpec getDstSubfolderSpec() {
    return dstSubfolderSpec;
  }

  @Override
  public String isa() {
    return "PBXCopyFilesBuildPhase";
  }

  @Override
  public void serializeInto(XcodeprojSerializer s) {
    super.serializeInto(s);
    s.addField("dstSubfolderSpec", dstSubfolderSpec.getDestination().getValue());
    s.addField("dstPath", dstSubfolderSpec.getPath().or(""));
  }
}

<code block>


package com.facebook.buck.apple;

import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertHasSingletonCopyFilesPhaseWithFileEntries;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertHasSingletonFrameworksPhaseWithFrameworkEntries;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.assertTargetExistsAndReturnTarget;
import static com.facebook.buck.apple.ProjectGeneratorTestUtils.getSingletonPhaseByType;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.endsWith;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.hamcrest.Matchers.hasKey;
import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.dd.plist.NSDictionary;
import com.dd.plist.NSString;
import com.facebook.buck.apple.clang.HeaderMap;
import com.facebook.buck.apple.xcode.xcodeproj.CopyFilePhaseDestinationSpec;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildFile;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXCopyFilesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXFileReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXGroup;
import com.facebook.buck.apple.xcode.xcodeproj.PBXHeadersBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXProject;
import com.facebook.buck.apple.xcode.xcodeproj.PBXReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXResourcesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXShellScriptBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXSourcesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXVariantGroup;
import com.facebook.buck.apple.xcode.xcodeproj.ProductType;
import com.facebook.buck.apple.xcode.xcodeproj.SourceTreePath;
import com.facebook.buck.apple.xcode.xcodeproj.XCBuildConfiguration;
import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.cxx.CxxDescriptionEnhancer;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.js.IosReactNativeLibraryBuilder;
import com.facebook.buck.js.ReactNativeBuckConfig;
import com.facebook.buck.js.ReactNativeFlavors;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.FrameworkPath;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.ExportFileBuilder;
import com.facebook.buck.shell.ExportFileDescription;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.AllExistingProjectFilesystem;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.facebook.buck.timing.SettableFakeClock;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.io.ByteStreams;

import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;

public class ProjectGeneratorTest {

  private static final Path OUTPUT_DIRECTORY = Paths.get("_gen");
  private static final String PROJECT_NAME = "GeneratedProject";
  private static final String PROJECT_CONTAINER = PROJECT_NAME + ".xcodeproj";
  private static final Path OUTPUT_PROJECT_BUNDLE_PATH =
      OUTPUT_DIRECTORY.resolve(PROJECT_CONTAINER);
  private static final Path OUTPUT_PROJECT_FILE_PATH =
      OUTPUT_PROJECT_BUNDLE_PATH.resolve("project.pbxproj");

  private SettableFakeClock clock;
  private ProjectFilesystem projectFilesystem;
  private FakeProjectFilesystem fakeProjectFilesystem;

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws IOException {
    clock = new SettableFakeClock(0, 0);
    fakeProjectFilesystem = new FakeProjectFilesystem(clock);
    projectFilesystem = fakeProjectFilesystem;


    projectFilesystem.writeContentsToPath(
        "",
        Paths.get(ProjectGenerator.PATH_TO_ASSET_CATALOG_BUILD_PHASE_SCRIPT));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get(ProjectGenerator.PATH_TO_ASSET_CATALOG_COMPILER));


    projectFilesystem.createParentDirs(Paths.get("foodir", "foo.png"));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get("foodir", "foo.png"));
    projectFilesystem.writeContentsToPath(
        "",
        Paths.get("bar.png"));
    fakeProjectFilesystem.touch(Paths.get("Base.lproj", "Bar.storyboard"));
  }

  @Test
  public void testProjectStructureForEmptyProject() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    projectGenerator.createXcodeProjects();

    Optional<String> pbxproj = projectFilesystem.readFileIfItExists(OUTPUT_PROJECT_FILE_PATH);
    assertTrue(pbxproj.isPresent());
  }

  @Test
  public void testCreateDirectoryStructure() throws IOException {
    BuildTarget buildTarget1 = BuildTarget.builder("//foo/bar", "target1").build();
    TargetNode<?> node1 = AppleLibraryBuilder.createBuilder(buildTarget1).build();

    BuildTarget buildTarget2 = BuildTarget.builder("//foo/foo", "target2").build();
    TargetNode<?> node2 = AppleLibraryBuilder.createBuilder(buildTarget2).build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node1, node2),
        ImmutableSet.of(
            ProjectGenerator.Option.CREATE_DIRECTORY_STRUCTURE,
            ProjectGenerator.Option.USE_SHORT_NAMES_FOR_TARGETS));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup mainGroup = project.getMainGroup();

    PBXGroup groupFoo = null;
    for (PBXReference reference : mainGroup.getChildren()) {
      if (reference instanceof PBXGroup && "foo".equals(reference.getName())) {
        groupFoo = (PBXGroup) reference;
      }
    }
    assertNotNull("Project should have a group called foo", groupFoo);

    assertEquals("foo", groupFoo.getName());
    assertThat(groupFoo.getChildren(), hasSize(2));

    PBXGroup groupFooBar = (PBXGroup) Iterables.get(groupFoo.getChildren(), 0);
    assertEquals("bar", groupFooBar.getName());
    assertThat(groupFooBar.getChildren(), hasSize(1));

    PBXGroup groupFooFoo = (PBXGroup) Iterables.get(groupFoo.getChildren(), 1);
    assertEquals("foo", groupFooFoo.getName());
    assertThat(groupFooFoo.getChildren(), hasSize(1));

    PBXGroup groupFooBarTarget1 = (PBXGroup) Iterables.get(groupFooBar.getChildren(), 0);
    assertEquals("target1", groupFooBarTarget1.getName());

    PBXGroup groupFooFooTarget2 = (PBXGroup) Iterables.get(groupFooFoo.getChildren(), 0);
    assertEquals("target2", groupFooFooTarget2.getName());
  }

  @Test
  public void shouldNotCreateHeaderSymlinkTreesWhenTheyAreDisabled() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/foo.h")))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();


    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(0));
  }

  @Test
  public void testLibraryHeaderGroupsWithHeaderSymlinkTrees() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/foo.h"),
                new TestSourcePath("HeaderGroup2/baz.h")))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(buildTarget.getFullyQualifiedName());
    PBXGroup sourcesGroup = targetGroup.getOrCreateChildGroupByName("Sources");

    assertThat(sourcesGroup.getChildren(), hasSize(2));

    PBXGroup group1 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 0);
    assertEquals("HeaderGroup1", group1.getName());
    assertThat(group1.getChildren(), hasSize(2));
    PBXFileReference fileRefFoo = (PBXFileReference) Iterables.get(group1.getChildren(), 0);
    assertEquals("bar.h", fileRefFoo.getName());
    PBXFileReference fileRefBar = (PBXFileReference) Iterables.get(group1.getChildren(), 1);
    assertEquals("foo.h", fileRefBar.getName());

    PBXGroup group2 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 1);
    assertEquals("HeaderGroup2", group2.getName());
    assertThat(group2.getChildren(), hasSize(1));
    PBXFileReference fileRefBaz = (PBXFileReference) Iterables.get(group2.getChildren(), 0);
    assertEquals("baz.h", fileRefBaz.getName());


    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:lib");
    assertEquals(
        Optional.<PBXBuildPhase>absent(),
        Iterables.tryFind(
            target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
              @Override
              public boolean apply(PBXBuildPhase input) {
                return input instanceof PBXHeadersBuildPhase;
              }
            }));

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-public-header-symlink-tree",
        headerSymlinkTrees.get(0).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-public-header-symlink-tree"),
        ImmutableMap.of("lib/bar.h", "HeaderGroup1/bar.h"));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.<String, String>builder()
            .put("lib/foo.h", "HeaderGroup1/foo.h")
            .put("lib/baz.h", "HeaderGroup2/baz.h")
            .put("foo.h", "HeaderGroup1/foo.h")
            .put("bar.h", "HeaderGroup1/bar.h")
            .put("baz.h", "HeaderGroup2/baz.h")
            .build());
  }

  @Test
  public void testLibraryHeaderGroupsWithMappedHeaders() throws IOException {
    BuildTarget privateGeneratedTarget = BuildTarget.builder("//foo", "generated1.h").build();
    BuildTarget publicGeneratedTarget = BuildTarget.builder("//foo", "generated2.h").build();

    TargetNode<?> privateGeneratedNode =
        ExportFileBuilder.newExportFileBuilder(privateGeneratedTarget).build();
    TargetNode<?> publicGeneratedNode =
        ExportFileBuilder.newExportFileBuilder(publicGeneratedTarget).build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "any/name.h", new TestSourcePath("HeaderGroup1/foo.h"),
                "different/name.h", new TestSourcePath("HeaderGroup2/baz.h"),
                "one/more/name.h", new BuildTargetSourcePath(privateGeneratedTarget)))
        .setExportedHeaders(
            ImmutableMap.<String, SourcePath>of(
                "yet/another/name.h", new TestSourcePath("HeaderGroup1/bar.h"),
                "and/one/more.h", new BuildTargetSourcePath(publicGeneratedTarget)))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node, privateGeneratedNode, publicGeneratedNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(buildTarget.getFullyQualifiedName());
    PBXGroup sourcesGroup = targetGroup.getOrCreateChildGroupByName("Sources");

    assertThat(sourcesGroup.getChildren(), hasSize(3));

    PBXGroup group1 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 0);
    assertEquals("HeaderGroup1", group1.getName());
    assertThat(group1.getChildren(), hasSize(2));
    PBXFileReference fileRefFoo = (PBXFileReference) Iterables.get(group1.getChildren(), 0);
    assertEquals("bar.h", fileRefFoo.getName());
    PBXFileReference fileRefBar = (PBXFileReference) Iterables.get(group1.getChildren(), 1);
    assertEquals("foo.h", fileRefBar.getName());

    PBXGroup group2 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 1);
    assertEquals("HeaderGroup2", group2.getName());
    assertThat(group2.getChildren(), hasSize(1));
    PBXFileReference fileRefBaz = (PBXFileReference) Iterables.get(group2.getChildren(), 0);
    assertEquals("baz.h", fileRefBaz.getName());

    PBXGroup group3 = (PBXGroup) Iterables.get(sourcesGroup.getChildren(), 2);
    assertEquals("foo", group3.getName());
    assertThat(group3.getChildren(), hasSize(2));
    PBXFileReference fileRefGenerated1 = (PBXFileReference) Iterables.get(group3.getChildren(), 0);
    assertEquals("generated1.h", fileRefGenerated1.getName());
    PBXFileReference fileRefGenerated2 = (PBXFileReference) Iterables.get(group3.getChildren(), 1);
    assertEquals("generated2.h", fileRefGenerated2.getName());


    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:lib");
    assertEquals(
        Optional.<PBXBuildPhase>absent(),
        Iterables.tryFind(
            target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
              @Override
              public boolean apply(PBXBuildPhase input) {
                return input instanceof PBXHeadersBuildPhase;
              }
            }));

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-public-header-symlink-tree",
        headerSymlinkTrees.get(0).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-public-header-symlink-tree"),
        ImmutableMap.of(
            "yet/another/name.h", "HeaderGroup1/bar.h",
            "and/one/more.h", "foo/generated2.h"));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of(
            "any/name.h", "HeaderGroup1/foo.h",
            "different/name.h", "HeaderGroup2/baz.h",
            "one/more/name.h", "foo/generated1.h"));
  }

  @Test
  public void testHeaderSymlinkTreesAreRegeneratedWhenKeyChanges() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "value.h"));

    node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "new-key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertFalse(
        projectFilesystem.isSymLink(
            Paths.get(
                "buck-out/gen/foo/lib-private-header-symlink-tree/key.h")));
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("new-key.h", "value.h"));
  }

  @Test
  public void testHeaderSymlinkTreesAreRegeneratedWhenValueChanges() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    List<Path> headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "value.h"));

    node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(Optional.of(ImmutableList.<SourceWithFlags>of()))
        .setHeaders(
            ImmutableMap.<String, SourcePath>of(
                "key.h", new TestSourcePath("new-value.h")))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    headerSymlinkTrees = projectGenerator.getGeneratedHeaderSymlinkTrees();
    assertThat(headerSymlinkTrees, hasSize(2));

    assertEquals(
        "buck-out/gen/foo/lib-private-header-symlink-tree",
        headerSymlinkTrees.get(1).toString());
    assertThatHeaderSymlinkTreeContains(
        Paths.get("buck-out/gen/foo/lib-private-header-symlink-tree"),
        ImmutableMap.of("key.h", "new-value.h"));
  }

  @Test
  public void testHeaderSymlinkTreesWithHeadersVisibleForTesting() throws IOException {
    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested library in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  @Test
  public void testHeaderSymlinkTreesWithTestsAndLibraryBundles() throws IOException {
    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setBinary(libraryTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(bundleTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, bundleNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested library in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/lib-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  @Test
  public void testHeaderSymlinkTreesWithTestsAndBinaryBundles() throws IOException {
    BuildTarget binaryTarget = BuildTarget.builder("//foo", "bin").build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    BuildTarget testTarget = BuildTarget.builder("//foo", "test").build();

    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.h"),
                        ImmutableList.of("public")),
                    SourceWithFlags.of(
                        new TestSourcePath("bar.h")))))
        .setUseBuckHeaderMaps(Optional.of(true))
        .build();

    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setBinary(binaryTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setTests(Optional.of(ImmutableSortedSet.of(testTarget)))
        .build();

    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Default",
                    ImmutableMap.<String, String>of())))
        .setUseBuckHeaderMaps(Optional.of(true))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setDeps(Optional.of(ImmutableSortedSet.of(bundleTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(binaryNode, bundleNode, testNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(project, "//foo:test");

    ImmutableMap<String, String> buildSettings =
        getBuildSettings(testTarget, testPBXTarget, "Default");

    assertEquals(
        "test binary should use header symlink trees for both public and non-public headers " +
            "of the tested binary in HEADER_SEARCH_PATHS",
        "$(inherited) " +
            "../buck-out/gen/foo/test-private-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/test-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/bin-public-header-symlink-tree/.tree.hmap " +
            "../buck-out/gen/foo/bin-private-header-symlink-tree/.tree.hmap",
        buildSettings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "USER_HEADER_SEARCH_PATHS should not be set",
        null,
        buildSettings.get("USER_HEADER_SEARCH_PATHS"));
  }

  private void assertThatHeaderSymlinkTreeContains(Path root, ImmutableMap<String, String> content)
      throws IOException {
    for (Map.Entry<String, String> entry : content.entrySet()) {
      Path link = root.resolve(Paths.get(entry.getKey()));
      Path target = Paths.get(entry.getValue()).toAbsolutePath();
      assertTrue(projectFilesystem.isSymLink(link));
      assertEquals(
          target,
          projectFilesystem.readSymLink(link));
    }


    byte[] headerMapBytes;
    try (InputStream headerMapInputStream =
             projectFilesystem.newFileInputStream(root.resolve(".tree.hmap"))) {
      headerMapBytes = ByteStreams.toByteArray(headerMapInputStream);
    }
    HeaderMap headerMap = HeaderMap.deserialize(headerMapBytes);
    assertNotNull(headerMap);
    assertThat(headerMap.getNumEntries(), equalTo(content.size()));
    for (String key : content.keySet()) {
      assertThat(
          headerMap.lookup(key),
          equalTo(projectFilesystem.resolve(root).resolve(key).toString()));
    }
  }

  @Test
  public void testAppleLibraryRule() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")),
                    SourceWithFlags.of(new TestSourcePath("bar.m")))))
        .setExtraXcodeSources(
            Optional.of(
                ImmutableList.<SourcePath>of(
                    new TestSourcePath("libsomething.a"))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(new TestSourcePath("foo.h")))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    assertHasConfigurations(target, "Debug");
    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target, ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "bar.m", Optional.<String>absent(),
            "libsomething.a", Optional.<String>absent()));


    {
      PBXBuildPhase headersBuildPhase =
          Iterables.find(target.getBuildPhases(), new Predicate<PBXBuildPhase>() {
            @Override
            public boolean apply(PBXBuildPhase input) {
              return input instanceof PBXHeadersBuildPhase;
            }
          });
      PBXBuildFile headerBuildFile = Iterables.getOnlyElement(headersBuildPhase.getFiles());

      String headerBuildFilePath = assertFileRefIsRelativeAndResolvePath(
          headerBuildFile.getFileRef());
      assertEquals(
          projectFilesystem.getRootPath().resolve("foo.h").toAbsolutePath().normalize().toString(),
          headerBuildFilePath);
    }


    assertFalse(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void testAppleLibraryConfiguresOutputPaths() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .setPrefixHeader(Optional.<SourcePath>of(new TestSourcePath("Foo/Foo-Prefix.pch")))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "../Foo/Foo-Prefix.pch",
        settings.get("GCC_PREFIX_HEADER"));
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWM33PHJWGSYQ/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleFrameworkConfiguresPublicHeaderPaths() throws IOException {
    BuildTarget libTarget = BuildTarget.builder("//foo", "lib")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libNode = AppleLibraryBuilder
        .createBuilder(libTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget frameworkTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> frameworkNode = AppleBundleBuilder
        .createBuilder(frameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(libTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(libNode, frameworkNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget frameworkPbxTarget = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bundle");
    assertEquals(frameworkPbxTarget.getProductType(), ProductType.FRAMEWORK);
    assertThat(frameworkPbxTarget.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference frameworkProductReference = frameworkPbxTarget.getProductReference();
    assertEquals("bundle.framework", frameworkProductReference.getName());
    assertEquals(Optional.of("wrapper.framework"), frameworkProductReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(
        frameworkTarget, frameworkPbxTarget, "Debug");
    assertEquals("framework", settings.get("WRAPPER_EXTENSION"));
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWM33PHJRHK3TENRSQ/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryConfiguresSharedLibraryOutputPaths() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//hi", "lib")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setHeaderPathPrefix(Optional.of("MyHeaderPathPrefix"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//hi:lib#shared");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.DYNAMIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "F4XWQ2J2NRUWEI3TNBQXEZLE/Headers/MyHeaderPathPrefix",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryDoesntOverrideHeaderOutputPath() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.of("PUBLIC_HEADERS_FOLDER_PATH", "FooHeaders"))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "FooHeaders",
        settings.get("PUBLIC_HEADERS_FOLDER_PATH"));
  }

  @Test
  public void testAppleLibraryCompilerAndPreprocessorFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setCompilerFlags(Optional.of(ImmutableList.of("-fhello")))
        .setPreprocessorFlags(Optional.of(ImmutableList.of("-fworld")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -fhello -fworld", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryCompilerAndPreprocessorFlagsDontPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setCompilerFlags(Optional.of(ImmutableList.of("-fhello")))
        .setPreprocessorFlags(Optional.of(ImmutableList.of("-fworld")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) ", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedPreprocessorFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedPreprocessorFlags(Optional.of(ImmutableList.of("-DHELLO")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -DHELLO", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedPreprocessorFlagsPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedPreprocessorFlags(Optional.of(ImmutableList.of("-DHELLO")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -DHELLO", settings.get("OTHER_CFLAGS"));
  }

  @Test
  public void testAppleLibraryLinkerFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryLinkerFlagsDontPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) ", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedLinkerFlags() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testAppleLibraryExportedLinkerFlagsPropagate() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExportedLinkerFlags(Optional.of(ImmutableList.of("-lhello")))
        .build();

    BuildTarget dependentBuildTarget = BuildTarget.builder("//foo", "bin").build();
    TargetNode<?> dependentNode = AppleBinaryBuilder
        .createBuilder(dependentBuildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setDeps(Optional.of(ImmutableSortedSet.of(buildTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node, dependentNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:bin");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -Xlinker -lhello", settings.get("OTHER_LDFLAGS"));
  }

  @Test
  public void testConfigurationSerializationWithoutExistingXcconfig() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.of("CUSTOM_SETTING", "VALUE"))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    assertThat(target.getProductType(), equalTo(ProductType.STATIC_LIBRARY));

    assertHasConfigurations(target, "Debug");
    XCBuildConfiguration configuration = target
        .getBuildConfigurationList().getBuildConfigurationsByName().asMap().get("Debug");
    assertEquals(configuration.getBuildSettings().count(), 0);

    PBXFileReference xcconfigReference = configuration.getBaseConfigurationReference();
    assertEquals(xcconfigReference.getPath(), "../buck-out/gen/foo/lib-Debug.xcconfig");

    ImmutableMap<String, String> settings = getBuildSettings(
        buildTarget, target, "Debug");
    assertEquals(
        "$SYMROOT/$CONFIGURATION$EFFECTIVE_PLATFORM_NAME",
        settings.get("BUILT_PRODUCTS_DIR"));
    assertEquals(
        "$BUILT_PRODUCTS_DIR",
        settings.get("CONFIGURATION_BUILD_DIR"));
    assertEquals(
        "VALUE",
        settings.get("CUSTOM_SETTING"));
  }

  @Test
  public void testAppleLibraryDependentsSearchHeadersAndLibraries() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs =
        ImmutableSortedMap.of(
            "Debug", ImmutableMap.<String, String>of());

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryDependentsInheritSearchPaths() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "USER_HEADER_SEARCH_PATHS", "user_headers",
            "LIBRARY_SEARCH_PATHS", "libraries",
            "FRAMEWORK_SEARCH_PATHS", "frameworks"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "user_headers",
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "frameworks $BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryTransitiveDependentsSearchHeadersAndLibraries() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug", ImmutableMap.<String, String>of());

    BuildTarget libraryDepTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> libraryDepNode = AppleLibraryBuilder
        .createBuilder(libraryDepTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryDepTarget)))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Test.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryDepNode, libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR/F4XWEYLSHJWGSYQ/Headers " +
            "$BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) " +
            "$BUILT_PRODUCTS_DIR $SDKROOT",
        settings.get("FRAMEWORK_SEARCH_PATHS"));
  }

  @Test
  public void testAppleLibraryWithoutSources() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "LIBRARY_SEARCH_PATHS", "libraries"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));

    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of("fooTest.m", Optional.<String>absent()));

    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$SDKROOT/Library.framework"));
  }

  @Test
  public void testAppleLibraryWithoutSourcesWithHeaders() throws IOException {
    ImmutableSortedMap<String, ImmutableMap<String, String>> configs = ImmutableSortedMap.of(
        "Debug",
        ImmutableMap.of(
            "HEADER_SEARCH_PATHS", "headers",
            "LIBRARY_SEARCH_PATHS", "libraries"));

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setExportedHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("HeaderGroup1/bar.h")))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Library.framework"))))))
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setConfigs(Optional.of(configs))
        .setUseBuckHeaderMaps(Optional.of(false))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("fooTest.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, target, "Debug");
    assertEquals(
        "headers $BUILT_PRODUCTS_DIR/F4XWM33PHJWGSYQ/Headers",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        "libraries $BUILT_PRODUCTS_DIR",
        settings.get("LIBRARY_SEARCH_PATHS"));

    assertEquals("Should have exact number of build phases", 2, target.getBuildPhases().size());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of("fooTest.m", Optional.<String>absent()));

    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$SDKROOT/Library.framework"));
  }

  @Test
  public void testAppleTestRule() throws IOException {
    BuildTarget testTarget = BuildTarget.builder("//foo", "xctest").build();
    TargetNode<?> testNode = AppleTestBuilder
        .createBuilder(testTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(testNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:xctest");
    assertEquals(target.getProductType(), ProductType.UNIT_TEST);
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("xctest.xctest", productReference.getName());
  }

  @Test
  public void testAppleBinaryRule() throws IOException {
    BuildTarget depTarget = BuildTarget.builder("//dep", "dep").build();
    TargetNode<?> depNode = AppleLibraryBuilder
        .createBuilder(depTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setUseBuckHeaderMaps(Optional.of(false))
        .build();

    BuildTarget binaryTarget = BuildTarget.builder("//foo", "binary").build();
    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")))))
        .setExtraXcodeSources(
            Optional.of(
                ImmutableList.<SourcePath>of(
                    new TestSourcePath("libsomething.a"))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("foo.h")))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("Foo.framework"))))))
        .setDeps(Optional.of(ImmutableSortedSet.of(depTarget)))
        .setGid(Optional.<String>absent())
        .setHeaderPathPrefix(Optional.<String>absent())
        .setUseBuckHeaderMaps(Optional.of(false))
        .setPrefixHeader(Optional.<SourcePath>absent())
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(depNode, binaryNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:binary");
    assertHasConfigurations(target, "Debug");
    assertEquals(target.getProductType(), ProductType.TOOL);
    assertEquals("Should have exact number of build phases", 3, target.getBuildPhases().size());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "libsomething.a", Optional.<String>absent()));
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$SDKROOT/Foo.framework",

            "$BUILT_PRODUCTS_DIR/libdep.a"));



    assertFalse(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void testAppleBundleRuleWithPreBuildScriptDependency() throws IOException {
    BuildTarget scriptTarget = BuildTarget.builder("//foo", "pre_build_script").build();
    TargetNode<?> scriptNode = XcodePrebuildScriptBuilder
        .createBuilder(scriptTarget)
        .setCmd("script.sh")
        .build();

    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of())
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(scriptTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(scriptNode, resourceNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("script.sh"));


    assertThat(
        target.getBuildPhases().get(0),
        instanceOf(PBXShellScriptBuildPhase.class));

    assertThat(
        target.getBuildPhases().get(1),
        instanceOf(PBXResourcesBuildPhase.class));
  }

  @Test
  public void testAppleBundleRuleWithPostBuildScriptDependency() throws IOException {
    BuildTarget scriptTarget = BuildTarget.builder("//foo", "post_build_script").build();
    TargetNode<?> scriptNode = XcodePostbuildScriptBuilder
        .createBuilder(scriptTarget)
        .setCmd("script.sh")
        .build();

    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of())
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(scriptTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(scriptNode, resourceNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("script.sh"));


    assertThat(
        target.getBuildPhases().get(0),
        instanceOf(PBXResourcesBuildPhase.class));

    assertThat(
        target.getBuildPhases().get(1),
        instanceOf(PBXShellScriptBuildPhase.class));
  }

  @Test
  public void testAppleBundleRuleWithRNLibraryDependency() throws IOException {
    BuildTarget rnLibraryTarget = BuildTarget.builder("//foo", "rn_library").build();
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(new FakeBuckConfig(
        ImmutableMap.of("react-native", ImmutableMap.of("packager", "react-native/packager.sh")),
        filesystem));
    TargetNode<?>  rnLibraryNode = IosReactNativeLibraryBuilder
        .builder(rnLibraryTarget, buckConfig)
        .setBundleName("Apps/Foo/FooBundle.js")
        .setEntryPath(new PathSourcePath(filesystem, Paths.get("js/FooApp.js")))
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(rnLibraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(rnLibraryNode, sharedLibraryNode, bundleNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle");
    assertThat(target.getName(), equalTo("//foo:bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    PBXShellScriptBuildPhase shellScriptBuildPhase =
        getSingletonPhaseByType(
            target,
            PBXShellScriptBuildPhase.class);

    assertThat(
        shellScriptBuildPhase.getShellScript(),
        startsWith("BASE_DIR="));
  }

  @Test
  public void testNoBundleFlavoredAppleBundleRuleWithRNLibraryDependency() throws IOException {
    BuildTarget rnLibraryTarget = BuildTarget.builder("//foo", "rn_library").build();
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    ReactNativeBuckConfig buckConfig = new ReactNativeBuckConfig(new FakeBuckConfig(
        ImmutableMap.of("react-native", ImmutableMap.of("packager", "react-native/packager.sh")),
        filesystem));
    TargetNode<?>  rnLibraryNode = IosReactNativeLibraryBuilder
        .builder(rnLibraryTarget, buckConfig)
        .setBundleName("Apps/Foo/FooBundle.js")
        .setEntryPath(new PathSourcePath(filesystem, Paths.get("js/FooApp.js")))
        .build();

    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle")
        .addFlavors(ReactNativeFlavors.DO_NOT_BUNDLE)
        .build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(sharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(rnLibraryTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(rnLibraryNode, sharedLibraryNode, bundleNode),
        ImmutableSet.<ProjectGenerator.Option>of(),
        Optional.of(Paths.get("js/react-native/runServer.sh")));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        project, "//foo:bundle#rn_no_bundle");
    assertThat(target.getName(), equalTo("//foo:bundle#rn_no_bundle"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));

    Iterator<PBXShellScriptBuildPhase> phases = Iterables.filter(
        target.getBuildPhases(),
        PBXShellScriptBuildPhase.class).iterator();

    assertThat(phases.hasNext(), is(true));
    assertThat(
        phases.next().getShellScript(),
        containsString("rm -rf ${JS_OUT}"));

    assertThat(phases.hasNext(), is(true));
    assertThat(
        phases.next().getShellScript(),
        endsWith("js/react-native/runServer.sh"));

    assertThat(phases.hasNext(), is(false));
  }

  @Test
  public void testAppleBundleRuleForSharedLibraryFramework() throws IOException {
    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> node = AppleBundleBuilder
        .createBuilder(buildTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(sharedLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(sharedLibraryNode, node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:bundle");
    assertEquals(target.getProductType(), ProductType.FRAMEWORK);
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("bundle.framework", productReference.getName());
    assertEquals(Optional.of("wrapper.framework"), productReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "framework",
        settings.get("WRAPPER_EXTENSION"));
  }

  @Test
  public void testAppleResourceWithVariantGroupSetsFileTypeBasedOnPath() throws IOException {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "resource").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of())
        .setDirs(ImmutableSet.<SourcePath>of())
        .setVariants(
            Optional.<Set<SourcePath>>of(
                ImmutableSet.<SourcePath>of(
                    new TestSourcePath("Base.lproj/Bar.storyboard"))))
        .build();
    BuildTarget fooLibraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooLibraryNode = AppleLibraryBuilder
        .createBuilder(fooLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();
    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(fooLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooLibraryNode, bundleNode, resourceNode),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(bundleTarget.getFullyQualifiedName());
    PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");
    PBXVariantGroup storyboardGroup = (PBXVariantGroup) Iterables.get(
        resourcesGroup.getChildren(),
        0);
    List<PBXReference> storyboardGroupChildren = storyboardGroup.getChildren();
    assertEquals(1, storyboardGroupChildren.size());
    assertTrue(storyboardGroupChildren.get(0) instanceof PBXFileReference);
    PBXFileReference baseStoryboardReference = (PBXFileReference) storyboardGroupChildren.get(0);

    assertEquals("Base", baseStoryboardReference.getName());


    assertEquals(Optional.of("file.storyboard"), baseStoryboardReference.getLastKnownFileType());
    assertEquals(Optional.<String>absent(), baseStoryboardReference.getExplicitFileType());
  }

  @Test
  public void testAppleBundleRuleWithCustomXcodeProductType() throws IOException {
    BuildTarget sharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> sharedLibraryNode = AppleLibraryBuilder
        .createBuilder(sharedLibraryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget = BuildTarget.builder("//foo", "custombundle").build();
    TargetNode<?> node = AppleBundleBuilder
        .createBuilder(buildTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(sharedLibraryTarget)
        .setXcodeProductType(Optional.of("com.facebook.buck.niftyProductType"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(sharedLibraryNode, node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "//foo:custombundle");
    assertEquals(
        target.getProductType(),
        ProductType.of("com.facebook.buck.niftyProductType"));
    assertThat(target.isa(), equalTo("PBXNativeTarget"));
    PBXFileReference productReference = target.getProductReference();
    assertEquals("custombundle.framework", productReference.getName());
    assertEquals(Optional.of("wrapper.framework"), productReference.getExplicitFileType());

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "framework",
        settings.get("WRAPPER_EXTENSION"));
  }

  @Test
  public void testCoreDataModelRuleAddsReference() throws IOException {
    BuildTarget modelTarget = BuildTarget.builder("//foo", "model").build();
    TargetNode<?> modelNode = CoreDataModelBuilder
        .createBuilder(modelTarget)
        .setPath(new TestSourcePath("foo.xcdatamodel").getRelativePath())
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(modelTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(modelNode, libraryNode));

    projectGenerator.createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXGroup targetGroup =
        project.getMainGroup().getOrCreateChildGroupByName(libraryTarget.getFullyQualifiedName());
    PBXGroup resourcesGroup = targetGroup.getOrCreateChildGroupByName("Resources");

    assertThat(resourcesGroup.getChildren(), hasSize(1));

    PBXFileReference modelReference = (PBXFileReference) Iterables.get(
        resourcesGroup.getChildren(),
        0);
    assertEquals("foo.xcdatamodel", modelReference.getName());
  }

  @Test
  public void testAppleWatchTarget() throws IOException {
    BuildTarget watchAppBinaryTarget = BuildTarget.builder("//foo", "WatchAppBinary").build();
    TargetNode<?> watchAppBinaryNode = AppleBinaryBuilder
        .createBuilder(watchAppBinaryTarget)
        .build();

    BuildTarget watchAppTarget = BuildTarget.builder("//foo", "WatchApp").build();
    TargetNode<?> watchAppNode = AppleBundleBuilder
        .createBuilder(watchAppTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setXcodeProductType(Optional.<String>of("com.apple.product-type.application.watchapp2"))
        .setBinary(watchAppBinaryTarget)
        .build();

    BuildTarget hostAppBinaryTarget = BuildTarget.builder("//foo", "HostAppBinary").build();
    TargetNode<?> hostAppBinaryNode = AppleBinaryBuilder
        .createBuilder(hostAppBinaryTarget)
        .build();

    BuildTarget hostAppTarget = BuildTarget.builder("//foo", "HostApp").build();
    TargetNode<?> hostAppNode = AppleBundleBuilder
        .createBuilder(hostAppTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setBinary(hostAppBinaryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(watchAppTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(watchAppNode, watchAppBinaryNode, hostAppNode, hostAppBinaryNode));
    projectGenerator.createXcodeProjects();


    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:HostApp");
    assertEquals(target.getProductType(), ProductType.APPLICATION);

    assertHasSingletonCopyFilesPhaseWithFileEntries(
        target,
        ImmutableList.of("$BUILT_PRODUCTS_DIR/WatchApp.app"));

    PBXCopyFilesBuildPhase copyBuildPhase = getSingletonPhaseByType(
        target,
        PBXCopyFilesBuildPhase.class
    );
    assertEquals(
        copyBuildPhase.getDstSubfolderSpec(),
        CopyFilePhaseDestinationSpec.builder()
            .setDestination(PBXCopyFilesBuildPhase.Destination.PRODUCTS)
            .setPath("$(CONTENTS_FOLDER_PATH)/Watch")
            .build()
    );
  }

  @Test
  public void ruleToTargetMapContainsPBXTarget() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")),
                    SourceWithFlags.of(new TestSourcePath("bar.m")))))
        .setHeaders(
            ImmutableSortedSet.<SourcePath>of(
                new TestSourcePath("foo.h")))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    assertEquals(
        buildTarget, Iterables.getOnlyElement(
            projectGenerator.getBuildTargetToGeneratedTargetMap().keySet()));

    PBXTarget target = Iterables.getOnlyElement(
        projectGenerator.getBuildTargetToGeneratedTargetMap().values());
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target, ImmutableMap.of(
            "foo.m", Optional.of("-foo"),
            "bar.m", Optional.<String>absent()));
  }

  @Test
  public void generatedGidsForTargetsAreStable() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:foo");
    String expectedGID = String.format(
        "%08X%08X%08X", target.isa().hashCode(), target.getName().hashCode(), 0);
    assertEquals(
        "expected GID has correct value (value from which it's derived have not changed)",
        "E66DC04E2245423200000000", expectedGID);
    assertEquals("generated GID is same as expected", expectedGID, target.getGlobalID());
  }

  @Test
  public void stopsLinkingRecursiveDependenciesAtSharedLibraries() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("empty.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticLibraryTarget)))
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentSharedLibraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(
            dependentStaticLibraryNode,
            dependentSharedLibraryNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libshared.dylib"));
  }

  @Test
  public void stopsLinkingRecursiveDependenciesAtBundles() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticLibraryTarget)))
        .build();

    BuildTarget dependentFrameworkTarget = BuildTarget.builder("//dep", "framework").build();
    TargetNode<?> dependentFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentSharedLibraryTarget)
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentFrameworkTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(
            dependentStaticLibraryNode,
            dependentSharedLibraryNode,
            dependentFrameworkNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of("$BUILT_PRODUCTS_DIR/framework.framework"));
  }

  @Test
  public void stopsCopyingRecursiveDependenciesAtBundles() throws IOException {
    BuildTarget dependentStaticLibraryTarget = BuildTarget.builder("//dep", "static").build();
    TargetNode<?> dependentStaticLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentStaticFrameworkTarget = BuildTarget
        .builder("//dep", "static-framework")
        .build();
    TargetNode<?> dependentStaticFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentStaticFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentStaticLibraryTarget)
        .build();

    BuildTarget dependentSharedLibraryTarget = BuildTarget
        .builder("//dep", "shared")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> dependentSharedLibraryNode = AppleLibraryBuilder
        .createBuilder(dependentSharedLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentStaticFrameworkTarget)))
        .build();

    BuildTarget dependentFrameworkTarget = BuildTarget.builder("//dep", "framework").build();
    TargetNode<?> dependentFrameworkNode = AppleBundleBuilder
        .createBuilder(dependentFrameworkTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.FRAMEWORK))
        .setBinary(dependentSharedLibraryTarget)
        .build();

    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
        .setDeps(Optional.of(ImmutableSortedSet.of(dependentFrameworkTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(

        ImmutableSet.<TargetNode<?>>of(
            dependentStaticLibraryNode,
            dependentStaticFrameworkNode,
            dependentSharedLibraryNode,
            dependentFrameworkNode,
            libraryNode,
            bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 2, target.getBuildPhases().size());
    assertHasSingletonCopyFilesPhaseWithFileEntries(
        target,
        ImmutableList.of("$BUILT_PRODUCTS_DIR/framework.framework"));
  }

  @Test
  public void bundlesDontLinkTheirOwnBinary() throws IOException {
    BuildTarget libraryTarget = BuildTarget
        .builder("//foo", "library")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "final").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(libraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(libraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:final");
    assertEquals(target.getProductType(), ProductType.BUNDLE);
    assertEquals("Should have exact number of build phases ", 0, target.getBuildPhases().size());
  }

  @Test
  public void resourcesInDependenciesPropagatesToBundles() throws IOException {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "res").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
        .setDirs(ImmutableSet.<SourcePath>of(new TestSourcePath("foodir")))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    BuildTarget bundleLibraryTarget = BuildTarget.builder("//foo", "bundlelib").build();
    TargetNode<?> bundleLibraryNode = AppleLibraryBuilder
        .createBuilder(bundleLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(bundleLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(resourceNode, libraryNode, bundleLibraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        generatedProject,
        "//foo:bundle");
    assertHasSingletonResourcesPhaseWithEntries(target, "bar.png", "foodir");
  }

  @Test
  public void assetCatalogsInDependenciesPropogatesToBundles() throws IOException {
    BuildTarget assetCatalogTarget = BuildTarget.builder("//foo", "asset_catalog").build();
    TargetNode<?> assetCatalogNode = AppleAssetCatalogBuilder
        .createBuilder(assetCatalogTarget)
        .setDirs(ImmutableSortedSet.of(Paths.get("AssetCatalog.xcassets")))
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(assetCatalogTarget)))
        .build();

    BuildTarget bundleLibraryTarget = BuildTarget.builder("//foo", "bundlelib").build();
    TargetNode<?> bundleLibraryNode = AppleLibraryBuilder
        .createBuilder(bundleLibraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(libraryTarget)))
        .build();

    BuildTarget bundleTarget = BuildTarget.builder("//foo", "bundle").build();
    TargetNode<?> bundleNode = AppleBundleBuilder
        .createBuilder(bundleTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.BUNDLE))
        .setBinary(bundleLibraryTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(assetCatalogNode, libraryNode, bundleLibraryNode, bundleNode));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(
        generatedProject,
        "//foo:bundle");
    assertTrue(hasShellScriptPhaseToCompileAssetCatalogs(target));
  }

  @Test
  public void generatedTargetConfigurationHasRepoRootSet() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "rule").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node),
        ImmutableSet.<ProjectGenerator.Option>of());
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    ImmutableMap<String, String> settings = getBuildSettings(
        buildTarget, generatedProject.getTargets().get(0), "Debug");
    assertThat(settings, hasKey("REPO_ROOT"));
    assertEquals(
        projectFilesystem.getRootPath().toAbsolutePath().normalize().toString(),
        settings.get("REPO_ROOT"));
  }


  @Test
  public void generatedProjectConfigurationListIsUnionOfAllTargetConfigurations()
      throws IOException {
    BuildTarget buildTarget1 = BuildTarget.builder("//foo", "rule1").build();
    TargetNode<?> node1 = AppleLibraryBuilder
        .createBuilder(buildTarget1)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Conf1", ImmutableMap.<String, String>of(),
                    "Conf2", ImmutableMap.<String, String>of())))
        .build();

    BuildTarget buildTarget2 = BuildTarget.builder("//foo", "rule2").build();
    TargetNode<?> node2 = AppleLibraryBuilder
        .createBuilder(buildTarget2)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Conf2", ImmutableMap.<String, String>of(),
                    "Conf3", ImmutableMap.<String, String>of())))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(node1, node2));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    Map<String, XCBuildConfiguration> configurations =
        generatedProject.getBuildConfigurationList().getBuildConfigurationsByName().asMap();
    assertThat(configurations, hasKey("Conf1"));
    assertThat(configurations, hasKey("Conf2"));
    assertThat(configurations, hasKey("Conf3"));
  }

  @Test
  public void shouldEmitFilesForBuildSettingPrefixedFrameworks() throws IOException {
    BuildTarget buildTarget = BuildTarget
        .builder("//foo", "rule")
        .addFlavors(CxxDescriptionEnhancer.SHARED_FLAVOR)
        .build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setUseBuckHeaderMaps(Optional.of(false))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setFrameworks(
            Optional.of(
                ImmutableSortedSet.of(
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.BUILT_PRODUCTS_DIR,
                            Paths.get("libfoo.a"))),
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SDKROOT,
                            Paths.get("libfoo.a"))),
                    FrameworkPath.ofSourceTreePath(
                        new SourceTreePath(
                            PBXReference.SourceTree.SOURCE_ROOT,
                            Paths.get("libfoo.a"))))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXProject generatedProject = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(generatedProject, "//foo:rule#shared");
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libfoo.a",
            "$SDKROOT/libfoo.a",
            "$SOURCE_ROOT/libfoo.a"));

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals(
        "$(inherited) ",
        settings.get("HEADER_SEARCH_PATHS"));
    assertEquals(
        null,
        settings.get("USER_HEADER_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR $SDKROOT $SOURCE_ROOT",
        settings.get("LIBRARY_SEARCH_PATHS"));
    assertEquals(
        "$(inherited) $BUILT_PRODUCTS_DIR",
        settings.get("FRAMEWORK_SEARCH_PATHS"));

  }

  @Test
  public void testGeneratedProjectIsNotReadOnlyIfOptionNotSpecified() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    projectGenerator.createXcodeProjects();

    assertTrue(fakeProjectFilesystem.getFileAttributesAtPath(OUTPUT_PROJECT_FILE_PATH).isEmpty());
  }

  @Test
  public void testGeneratedProjectIsReadOnlyIfOptionSpecified() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(),
        ImmutableSet.of(ProjectGenerator.Option.GENERATE_READ_ONLY_FILES));

    projectGenerator.createXcodeProjects();

    ImmutableSet<PosixFilePermission> permissions =
      ImmutableSet.of(
          PosixFilePermission.OWNER_READ,
          PosixFilePermission.GROUP_READ,
          PosixFilePermission.OTHERS_READ);
    FileAttribute<?> expectedAttribute = PosixFilePermissions.asFileAttribute(permissions);





    FileAttribute<?> actualAttribute =
      Iterables.getOnlyElement(
          fakeProjectFilesystem.getFileAttributesAtPath(OUTPUT_PROJECT_FILE_PATH));
    assertEquals(
        expectedAttribute.value(),
        actualAttribute.value());
  }

  @Test
  public void targetGidInDescriptionSetsTargetGidInGeneratedProject() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setGid(Optional.of("D00D64738"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    assertThat(target.getGlobalID(), equalTo("D00D64738"));
  }

  @Test
  public void targetGidInDescriptionReservesGidFromUseByAnotherTarget() throws IOException {
    BuildTarget fooTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooNode = AppleLibraryBuilder
        .createBuilder(fooTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    BuildTarget barTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> barNode = AppleLibraryBuilder
        .createBuilder(barTarget)
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooNode, barNode));
    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//bar:lib");



    String expectedGID = String.format(
        "%08X%08X%08X", target.isa().hashCode(), target.getName().hashCode(), 1);
    assertEquals(
        "expected GID has correct value",
        "E66DC04E36F2D8BE00000001", expectedGID);
    assertEquals("generated GID is same as expected", expectedGID, target.getGlobalID());
  }

  @Test
  public void conflictingHardcodedGidsThrow() throws IOException {
    BuildTarget fooTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> fooNode = AppleLibraryBuilder
        .createBuilder(fooTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    BuildTarget barTarget = BuildTarget.builder("//bar", "lib").build();
    TargetNode<?> barNode = AppleLibraryBuilder
        .createBuilder(barTarget)
        .setGid(Optional.of("E66DC04E36F2D8BE00000000"))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(fooNode, barNode));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "Targets [//bar:lib, //foo:lib] have the same hardcoded GID (E66DC04E36F2D8BE00000000)");

    projectGenerator.createXcodeProjects();
  }

  @Test
  public void projectIsRewrittenIfContentsHaveChanged() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(49152);
    projectGenerator.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));

    BuildTarget buildTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .build();
    ProjectGenerator projectGenerator2 = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    clock.setCurrentTimeMillis(64738);
    projectGenerator2.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(64738L));
  }

  @Test
  public void projectIsNotRewrittenIfContentsHaveNotChanged() throws IOException {
    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(49152);
    projectGenerator.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));

    ProjectGenerator projectGenerator2 = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of());

    clock.setCurrentTimeMillis(64738);
    projectGenerator2.createXcodeProjects();
    assertThat(
        projectFilesystem.getLastModifiedTime(OUTPUT_PROJECT_FILE_PATH),
        equalTo(49152L));
  }

  @Test
  public void nonexistentResourceDirectoryShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(),
        ImmutableSet.<SourcePath>of(new TestSourcePath("nonexistent-directory")));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "nonexistent-directory specified in the dirs parameter of //foo:res is not a directory");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void nonexistentResourceFileShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(new TestSourcePath("nonexistent-file.png")),
        ImmutableSet.<SourcePath>of());

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "nonexistent-file.png specified in the files parameter of //foo:res is not a regular file");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingFileAsResourceDirectoryShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(),
        ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")));

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "bar.png specified in the dirs parameter of //foo:res is not a directory");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingDirectoryAsResourceFileShouldThrow() throws IOException {
    ImmutableSet<TargetNode<?>> nodes = setupSimpleLibraryWithResources(
        ImmutableSet.<SourcePath>of(new TestSourcePath("foodir")),
        ImmutableSet.<SourcePath>of());

    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "foodir specified in the files parameter of //foo:res is not a regular file");

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void usingBuildTargetSourcePathInResourceDirsOrFilesDoesNotThrow() throws IOException {
    BuildTarget buildTarget = BuildTargetFactory.newInstance("//some:rule");
    SourcePath sourcePath = new BuildTargetSourcePath(buildTarget);
    TargetNode<?> generatingTarget = GenruleBuilder.newGenruleBuilder(buildTarget)
        .setCmd("echo HI")
        .build();

    ImmutableSet<TargetNode<?>> nodes = FluentIterable.from(
        setupSimpleLibraryWithResources(
            ImmutableSet.of(sourcePath),
            ImmutableSet.of(sourcePath)))
        .append(generatingTarget)
        .toSet();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(nodes);
    projectGenerator.createXcodeProjects();
  }

  @Test
  public void testGeneratingTestsAsStaticLibraries() throws IOException {
    TargetNode<AppleTestDescription.Arg> libraryTestStatic =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "libraryTestStatic").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .build();
    TargetNode<AppleTestDescription.Arg> libraryTestNotStatic =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "libraryTestNotStatic").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableList.<TargetNode<?>>of(libraryTestStatic, libraryTestNotStatic));
    projectGenerator
        .setTestsToGenerateAsStaticLibraries(ImmutableSet.of(libraryTestStatic))
        .createXcodeProjects();

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget libraryTestStaticTarget =
        assertTargetExistsAndReturnTarget(project, "//foo:libraryTestStatic");
    PBXTarget libraryTestNotStaticTarget =
        assertTargetExistsAndReturnTarget(project, "//foo:libraryTestNotStatic");
    assertThat(
        libraryTestStaticTarget.getProductType(),
        equalTo(ProductType.STATIC_LIBRARY));
    assertThat(
        libraryTestNotStaticTarget.getProductType(),
        equalTo(ProductType.UNIT_TEST));
  }

  @Test
  public void testGeneratingCombinedTests() throws IOException {
    TargetNode<AppleResourceDescription.Arg> testLibDepResource =
        AppleResourceBuilder.createBuilder(BuildTarget.builder("//lib", "deplibresource").build())
            .setFiles(ImmutableSet.<SourcePath>of(new TestSourcePath("bar.png")))
            .setDirs(ImmutableSet.<SourcePath>of())
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> testLibDepLib =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//libs", "deplib").build())
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTestLibDep.framework"))))))
            .setDeps(Optional.of(ImmutableSortedSet.of(testLibDepResource.getBuildTarget())))
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> dep1 =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//foo", "dep1").build())
            .setDeps(Optional.of(ImmutableSortedSet.of(testLibDepLib.getBuildTarget())))
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTestLib.framework"))))))
            .build();
    TargetNode<AppleNativeTargetDescriptionArg> dep2 =
        AppleLibraryBuilder.createBuilder(BuildTarget.builder("//foo", "dep2").build())
            .setSrcs(Optional.of(ImmutableList.of(SourceWithFlags.of(new TestSourcePath("e.m")))))
            .build();
    TargetNode<AppleTestDescription.Arg> xctest1 =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "xctest1").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .setDeps(Optional.of(ImmutableSortedSet.of(dep1.getBuildTarget())))
            .setFrameworks(
                Optional.of(
                    ImmutableSortedSet.of(
                        FrameworkPath.ofSourceTreePath(
                            new SourceTreePath(
                                PBXReference.SourceTree.SDKROOT,
                                Paths.get("DeclaredInTest.framework"))))))
            .build();
    TargetNode<AppleTestDescription.Arg> xctest2 =
        AppleTestBuilder.createBuilder(BuildTarget.builder("//foo", "xctest2").build())
            .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
            .setDeps(Optional.of(ImmutableSortedSet.of(dep2.getBuildTarget())))
            .build();

    ProjectGenerator projectGenerator = new ProjectGenerator(
        TargetGraphFactory.newInstance(
            testLibDepResource,
            testLibDepLib,
            dep1,
            dep2,
            xctest1,
            xctest2),
        ImmutableSet.<BuildTarget>of(),
        projectFilesystem,
 Optional.<Path>absent(),
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        ProjectGenerator.SEPARATED_PROJECT_OPTIONS,
        Optional.<BuildTarget>absent(),
        ImmutableList.<String>of(),
        new Function<TargetNode<?>, Path>() {
          @Nullable
          @Override
          public Path apply(TargetNode<?> input) {
            return null;
          }
        })
        .setTestsToGenerateAsStaticLibraries(ImmutableSet.of(xctest1, xctest2))
        .setAdditionalCombinedTestTargets(
            ImmutableMultimap.of(
                AppleTestBundleParamsKey.fromAppleTestDescriptionArg(xctest1.getConstructorArg()),
                xctest1,
                AppleTestBundleParamsKey.fromAppleTestDescriptionArg(xctest2.getConstructorArg()),
                xctest2));
    projectGenerator.createXcodeProjects();

    ImmutableSet<PBXTarget> combinedTestTargets =
        projectGenerator.getBuildableCombinedTestTargets();
    assertThat(combinedTestTargets, hasSize(1));
    assertThat(combinedTestTargets, hasItem(targetWithName("_BuckCombinedTest-xctest-0")));

    PBXProject project = projectGenerator.getGeneratedProject();
    PBXTarget target = assertTargetExistsAndReturnTarget(project, "_BuckCombinedTest-xctest-0");
    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            BuckConstant.GEN_PATH.resolve("xcode-scripts/emptyFile.c").toString(),
            Optional.<String>absent()));
    assertHasSingletonFrameworksPhaseWithFrameworkEntries(
        target,
        ImmutableList.of(
            "$BUILT_PRODUCTS_DIR/libxctest1.a",
            "$BUILT_PRODUCTS_DIR/libxctest2.a",
            "$BUILT_PRODUCTS_DIR/libdeplib.a",
            "$BUILT_PRODUCTS_DIR/libdep1.a",
            "$BUILT_PRODUCTS_DIR/libdep2.a",
            "$SDKROOT/DeclaredInTestLib.framework",
            "$SDKROOT/DeclaredInTestLibDep.framework",
            "$SDKROOT/DeclaredInTest.framework"));
    assertHasSingletonResourcesPhaseWithEntries(
        target,
        "bar.png");
  }

  @Test
  public void testResolvingExportFile() throws IOException {
    BuildTarget source1Target = BuildTarget.builder("//Vendor", "source1").build();
    BuildTarget source2Target = BuildTarget.builder("//Vendor", "source2").build();
    BuildTarget source2RefTarget = BuildTarget.builder("//Vendor", "source2ref").build();
    BuildTarget source3Target = BuildTarget.builder("//Vendor", "source3").build();
    BuildTarget headerTarget = BuildTarget.builder("//Vendor", "header").build();
    BuildTarget libTarget = BuildTarget.builder("//Libraries", "foo").build();

    TargetNode<ExportFileDescription.Arg> source1 = ExportFileBuilder
        .newExportFileBuilder(source1Target)
        .setSrc(new PathSourcePath(projectFilesystem, Paths.get("Vendor/sources/source1")))
        .build();

    TargetNode<ExportFileDescription.Arg> source2 = ExportFileBuilder
        .newExportFileBuilder(source2Target)
        .setSrc(new PathSourcePath(projectFilesystem, Paths.get("Vendor/source2")))
        .build();

    TargetNode<ExportFileDescription.Arg> source2Ref = ExportFileBuilder
        .newExportFileBuilder(source2RefTarget)
        .setSrc(new BuildTargetSourcePath(source2Target))
        .build();

    TargetNode<ExportFileDescription.Arg> source3 = ExportFileBuilder
        .newExportFileBuilder(source3Target)
        .build();

    TargetNode<ExportFileDescription.Arg> header = ExportFileBuilder
        .newExportFileBuilder(headerTarget)
        .build();

    TargetNode<AppleNativeTargetDescriptionArg> library = AppleLibraryBuilder
        .createBuilder(libTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source1Target)),
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source2RefTarget)),
                    SourceWithFlags.of(
                        new BuildTargetSourcePath(source3Target)))))
        .setPrefixHeader(
            Optional.<SourcePath>of(new BuildTargetSourcePath(headerTarget)))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(
            source1,
            source2,
            source2Ref,
            source3,
            header,
            library));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        libTarget.toString());

    assertHasSingletonSourcesPhaseWithSourcesAndFlags(
        target,
        ImmutableMap.of(
            "Vendor/sources/source1", Optional.<String>absent(),
            "Vendor/source2", Optional.<String>absent(),
            "Vendor/source3", Optional.<String>absent()));

    ImmutableMap<String, String> settings = getBuildSettings(libTarget, target, "Debug");
    assertEquals("../Vendor/header", settings.get("GCC_PREFIX_HEADER"));
  }

  @Test
  public void applicationTestUsesHostAppAsTestHostAndBundleLoader() throws IOException {
    BuildTarget hostAppBinaryTarget = BuildTarget.builder("//foo", "HostAppBinary").build();
    TargetNode<?> hostAppBinaryNode = AppleBinaryBuilder
        .createBuilder(hostAppBinaryTarget)
        .build();

    BuildTarget hostAppTarget = BuildTarget.builder("//foo", "HostApp").build();
    TargetNode<?> hostAppNode = AppleBundleBuilder
        .createBuilder(hostAppTarget)
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.APP))
        .setBinary(hostAppBinaryTarget)
        .build();

    BuildTarget testTarget = BuildTarget.builder("//foo", "AppTest").build();
    TargetNode<?> testNode = AppleTestBuilder.createBuilder(testTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setExtension(Either.<AppleBundleExtension, String>ofLeft(AppleBundleExtension.XCTEST))
        .setTestHostApp(Optional.of(hostAppTarget))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.of(hostAppBinaryNode, hostAppNode, testNode),
        ImmutableSet.<ProjectGenerator.Option>of());

    projectGenerator.createXcodeProjects();

    PBXTarget testPBXTarget = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:AppTest");

    ImmutableMap<String, String> settings = getBuildSettings(testTarget, testPBXTarget, "Debug");
    assertEquals("$BUILT_PRODUCTS_DIR/./HostApp.app/HostApp", settings.get("BUNDLE_LOADER"));
    assertEquals("$(BUNDLE_LOADER)", settings.get("TEST_HOST"));
  }

  @Test
  public void aggregateTargetForBuildWithBuck() throws IOException {
    BuildTarget binaryTarget = BuildTarget.builder("//foo", "binary").build();
    TargetNode<?> binaryNode = AppleBinaryBuilder
        .createBuilder(binaryTarget)
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(
                    SourceWithFlags.of(
                        new TestSourcePath("foo.m"), ImmutableList.of("-foo")))))
        .build();

    ImmutableSet<TargetNode<?>> nodes = ImmutableSet.<TargetNode<?>>of(binaryNode);
    ProjectGenerator projectGenerator = new ProjectGenerator(
        TargetGraphFactory.newInstance(nodes),
        FluentIterable.from(nodes).transform(HasBuildTarget.TO_TARGET).toSet(),
        projectFilesystem,
 Optional.<Path>absent(),
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        ImmutableSet.<ProjectGenerator.Option>of(),
        Optional.of(binaryTarget),
        ImmutableList.of("--flag", "value with spaces"),
        Functions.<Path>constant(null));
    projectGenerator.createXcodeProjects();

    PBXTarget buildWithBuckTarget = null;
    for (PBXTarget target : projectGenerator.getGeneratedProject().getTargets()) {
      if (target.getProductName() != null &&
          target.getProductName().endsWith("-Buck")) {
        buildWithBuckTarget = target;
      }
    }
    assertThat(buildWithBuckTarget, is(notNullValue()));

    assertHasConfigurations(buildWithBuckTarget, "Debug");
    assertEquals(
        "Should have exact number of build phases",
        1,
        buildWithBuckTarget.getBuildPhases().size());
    PBXBuildPhase buildPhase = Iterables.getOnlyElement(buildWithBuckTarget.getBuildPhases());
    assertThat(buildPhase, instanceOf(PBXShellScriptBuildPhase.class));
    PBXShellScriptBuildPhase shellScriptBuildPhase = (PBXShellScriptBuildPhase) buildPhase;
    assertThat(
        shellScriptBuildPhase.getShellScript(),
        equalTo("buck build --flag 'value with spaces' " + binaryTarget.getFullyQualifiedName()));
  }

  @Test
  public void cxxFlagsPropagatedToConfig() throws IOException {
    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setLangPreprocessorFlags(
            Optional.of(
                ImmutableMap.of(
                    CxxSource.Type.CXX, ImmutableList.of("-std=c++11", "-stdlib=libc++"),
                    CxxSource.Type.OBJCXX, ImmutableList.of("-std=c++11", "-stdlib=libc++"))))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.mm")))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();

    PBXTarget target = assertTargetExistsAndReturnTarget(
        projectGenerator.getGeneratedProject(),
        "//foo:lib");

    ImmutableMap<String, String> settings = getBuildSettings(buildTarget, target, "Debug");
    assertEquals("$(inherited) -std=c++11 -stdlib=libc++", settings.get("OTHER_CPLUSPLUSFLAGS"));
  }

  @Test
  public void unsupportedLangPreprocessorFlagsThrows() throws IOException {
    thrown.expect(HumanReadableException.class);
    thrown.expectMessage(
        "//foo:lib: Xcode project generation does not support specified lang_preprocessor_flags " +
        "keys: [ASSEMBLER]");

    BuildTarget buildTarget = BuildTarget.builder("//foo", "lib").build();
    TargetNode<?> node = AppleLibraryBuilder
        .createBuilder(buildTarget)
        .setLangPreprocessorFlags(
            Optional.of(
                ImmutableMap.of(
                    CxxSource.Type.ASSEMBLER, ImmutableList.of("-Xawesome"))))
        .setConfigs(
            Optional.of(
                ImmutableSortedMap.of(
                    "Debug",
                    ImmutableMap.<String, String>of())))
        .setSrcs(
            Optional.of(
                ImmutableList.of(SourceWithFlags.of(new TestSourcePath("foo.mm")))))
        .build();

    ProjectGenerator projectGenerator = createProjectGeneratorForCombinedProject(
        ImmutableSet.<TargetNode<?>>of(node));

    projectGenerator.createXcodeProjects();
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes) {
    return createProjectGeneratorForCombinedProject(
        nodes,
        ImmutableSet.<ProjectGenerator.Option>of());
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes,
      ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions) {
    return createProjectGeneratorForCombinedProject(
        nodes,
        projectGeneratorOptions,
        Optional.<Path>absent());
  }

  private ProjectGenerator createProjectGeneratorForCombinedProject(
      Iterable<TargetNode<?>> nodes,
      ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions,
      Optional<Path> reactNativeServer) {
    ImmutableSet<BuildTarget> initialBuildTargets = FluentIterable
        .from(nodes)
        .transform(HasBuildTarget.TO_TARGET)
        .toSet();

    return new ProjectGenerator(
        TargetGraphFactory.newInstance(ImmutableSet.copyOf(nodes)),
        initialBuildTargets,
        projectFilesystem,
        reactNativeServer,
        OUTPUT_DIRECTORY,
        PROJECT_NAME,
        "BUCK",
        projectGeneratorOptions,
        Optional.<BuildTarget>absent(),
        ImmutableList.<String>of(),
        Functions.<Path>constant(null));
  }

  private ImmutableSet<TargetNode<?>> setupSimpleLibraryWithResources(
      ImmutableSet<SourcePath> resourceFiles,
      ImmutableSet<SourcePath> resourceDirectories) {
    BuildTarget resourceTarget = BuildTarget.builder("//foo", "res").build();
    TargetNode<?> resourceNode = AppleResourceBuilder
        .createBuilder(resourceTarget)
        .setFiles(resourceFiles)
        .setDirs(resourceDirectories)
        .build();

    BuildTarget libraryTarget = BuildTarget.builder("//foo", "foo").build();
    TargetNode<?> libraryNode = AppleLibraryBuilder
        .createBuilder(libraryTarget)
        .setDeps(Optional.of(ImmutableSortedSet.of(resourceTarget)))
        .build();

    return ImmutableSet.of(resourceNode, libraryNode);
  }

  private String assertFileRefIsRelativeAndResolvePath(PBXReference fileRef) {
    assert(!fileRef.getPath().startsWith("/"));
    assertEquals(
        "file path should be relative to project directory",
        PBXReference.SourceTree.SOURCE_ROOT,
        fileRef.getSourceTree());
    return projectFilesystem.resolve(OUTPUT_DIRECTORY).resolve(fileRef.getPath())
        .normalize().toString();
  }

  private void assertHasConfigurations(PBXTarget target, String... names) {
    Map<String, XCBuildConfiguration> buildConfigurationMap =
        target.getBuildConfigurationList().getBuildConfigurationsByName().asMap();
    assertEquals(
        "Configuration list has expected number of entries",
        names.length, buildConfigurationMap.size());

    for (String name : names) {
      XCBuildConfiguration configuration = buildConfigurationMap.get(name);

      assertNotNull("Configuration entry exists", configuration);
      assertEquals("Configuration name is same as key", name, configuration.getName());
      assertTrue(
          "Configuration has xcconfig file",
          configuration.getBaseConfigurationReference().getPath().endsWith(".xcconfig"));
    }
  }

  private void assertHasSingletonSourcesPhaseWithSourcesAndFlags(
      PBXTarget target,
      ImmutableMap<String, Optional<String>> sourcesAndFlags) {

    PBXSourcesBuildPhase sourcesBuildPhase =
        getSingletonPhaseByType(target, PBXSourcesBuildPhase.class);

    assertEquals(
        "Sources build phase should have correct number of sources",
        sourcesAndFlags.size(), sourcesBuildPhase.getFiles().size());


    ImmutableMap.Builder<String, Optional<String>> absolutePathFlagMapBuilder =
        ImmutableMap.builder();
    for (Map.Entry<String, Optional<String>> name : sourcesAndFlags.entrySet()) {
      absolutePathFlagMapBuilder.put(
          projectFilesystem.getRootPath().resolve(name.getKey()).toAbsolutePath()
              .normalize().toString(),
          name.getValue());
    }
    ImmutableMap<String, Optional<String>> absolutePathFlagMap = absolutePathFlagMapBuilder.build();

    for (PBXBuildFile file : sourcesBuildPhase.getFiles()) {
      String filePath = assertFileRefIsRelativeAndResolvePath(file.getFileRef());
      Optional<String> flags = absolutePathFlagMap.get(filePath);
      assertNotNull(String.format("Unexpected file ref '%s' found", filePath), flags);
      if (flags.isPresent()) {
        assertTrue("Build file should have settings dictionary", file.getSettings().isPresent());

        NSDictionary buildFileSettings = file.getSettings().get();
        NSString compilerFlags = (NSString) buildFileSettings.get("COMPILER_FLAGS");

        assertNotNull("Build file settings should have COMPILER_FLAGS entry", compilerFlags);
        assertEquals(
            "Build file settings should be expected value",
            flags.get(), compilerFlags.getContent());
      } else {
        assertFalse(
            "Build file should not have settings dictionary", file.getSettings().isPresent());
      }
    }
  }

  private void assertHasSingletonResourcesPhaseWithEntries(PBXTarget target, String... resources) {
    PBXResourcesBuildPhase buildPhase =
        getSingletonPhaseByType(target, PBXResourcesBuildPhase.class);
    assertEquals("Resources phase should have right number of elements",
        resources.length, buildPhase.getFiles().size());

    ImmutableSet.Builder<String> expectedResourceSetBuilder = ImmutableSet.builder();
    for (String resource : resources) {
      expectedResourceSetBuilder.add(
          projectFilesystem.getRootPath().resolve(resource).toAbsolutePath()
              .normalize().toString());
    }
    ImmutableSet<String> expectedResourceSet = expectedResourceSetBuilder.build();

    for (PBXBuildFile file : buildPhase.getFiles()) {
      String source = assertFileRefIsRelativeAndResolvePath(file.getFileRef());
      assertTrue(
          "Resource should be in list of expected resources: " + source,
          expectedResourceSet.contains(source));
    }
  }

  private ImmutableMap<String, String> getBuildSettings(
      BuildTarget buildTarget, PBXTarget target, String config) {
    assertHasConfigurations(target, config);
    return ProjectGeneratorTestUtils.getBuildSettings(
        projectFilesystem, buildTarget, target, config);
  }

  private boolean hasShellScriptPhaseToCompileAssetCatalogs(PBXTarget target) {
    boolean found = false;
    for (PBXBuildPhase phase : target.getBuildPhases()) {
      if (phase.getClass().equals(PBXShellScriptBuildPhase.class)) {
        PBXShellScriptBuildPhase shellScriptBuildPhase = (PBXShellScriptBuildPhase) phase;
        if (shellScriptBuildPhase.getShellScript().contains("compile_asset_catalogs")) {
          found = true;
        }
      }
    }

    return found;
  }

  private Matcher<PBXTarget> targetWithName(String name) {
    return new FeatureMatcher<PBXTarget, String>(
        org.hamcrest.Matchers.equalTo(name),
        "target with name",
        "name") {
      @Override
      protected String featureValueOf(PBXTarget pbxTarget) {
        return pbxTarget.getName();
      }
    };
  }
}

<code block>

package com.facebook.buck.android;

import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessables;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.cxx.NativeLinkable;
import com.facebook.buck.cxx.NativeLinkableInput;
import com.facebook.buck.cxx.NativeLinkables;
import com.facebook.buck.file.WriteFile;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.macros.EnvironmentVariableMacroExpander;
import com.facebook.buck.rules.macros.MacroExpander;
import com.facebook.buck.rules.macros.MacroHandler;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.MoreIterables;
import com.facebook.buck.util.MoreStrings;
import com.facebook.buck.util.environment.Platform;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;
import java.util.Map;
import java.util.regex.Pattern;

public class NdkLibraryDescription implements Description<NdkLibraryDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("ndk_library");

  private static final Flavor MAKEFILE_FLAVOR = ImmutableFlavor.of("makefile");

  private static final Pattern EXTENSIONS_REGEX =
      Pattern.compile(
              ".*\\." +
              MoreStrings.regexPatternForAny("mk", "h", "hpp", "c", "cpp", "cc", "cxx") + "$");

  public static final MacroHandler MACRO_HANDLER = new MacroHandler(
      ImmutableMap.<String, MacroExpander>of(
          "env", new EnvironmentVariableMacroExpander(Platform.detect())
      )
  );

  private final Optional<String> ndkVersion;
  private final ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms;

  public NdkLibraryDescription(
      Optional<String> ndkVersion,
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    this.ndkVersion = ndkVersion;
    this.cxxPlatforms = Preconditions.checkNotNull(cxxPlatforms);
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  private Iterable<String> escapeForMakefile(Iterable<String> args) {
    ImmutableList.Builder<String> escapedArgs = ImmutableList.builder();

    for (String arg : args) {
      String escapedArg = arg;







      escapedArg = Escaper.escapeAsShellString(escapedArg);
      for (int i = 0; i < 4; i++) {
        escapedArg = Escaper.escapeAsMakefileValueString(escapedArg);
      }



      if (arg.startsWith(BuckConstant.BUCK_OUTPUT_DIRECTORY)) {
        escapedArg = "$(BUCK_PROJECT_DIR)/" + escapedArg;
      }

      escapedArgs.add(escapedArg);
    }

    return escapedArgs.build();
  }

  private String getTargetArchAbi(NdkCxxPlatforms.TargetCpuType cpuType) {
    switch (cpuType) {
      case ARM:
        return "armeabi";
      case ARMV7:
        return "armeabi-v7a";
      case X86:
        return "x86";
      case MIPS:
        return "mips";
      default:
        throw new IllegalStateException();
    }
  }

  @VisibleForTesting
  protected static Path getGeneratedMakefilePath(BuildTarget target) {
    return BuildTargets.getGenPath(target, "Android.%s.mk");
  }


  private Pair<BuildRule, Iterable<BuildRule>> generateMakefile(
      final BuildRuleParams params,
      BuildRuleResolver resolver) {

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList.Builder<String> outputLinesBuilder = ImmutableList.builder();
    ImmutableSortedSet.Builder<BuildRule> deps = ImmutableSortedSet.naturalOrder();

    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxPlatform cxxPlatform = entry.getValue().getCxxPlatform();

      CxxPreprocessorInput cxxPreprocessorInput;
      try {


        cxxPreprocessorInput = CxxPreprocessorInput.concat(
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                params.getDeps(),
                Predicates.instanceOf(NdkLibrary.class)));
      } catch (CxxPreprocessorInput.ConflictingHeadersException e) {
        throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
      }



      deps.addAll(
          pathResolver.filterBuildRuleInputs(
              cxxPreprocessorInput.getIncludes().getPrefixHeaders()));
      deps.addAll(
          pathResolver.filterBuildRuleInputs(
              cxxPreprocessorInput.getIncludes().getNameToPathMap().values()));
      deps.addAll(resolver.getAllRules(cxxPreprocessorInput.getRules()));



      Iterable<String> ppflags = Iterables.concat(
          cxxPreprocessorInput.getPreprocessorFlags().get(CxxSource.Type.C),
          MoreIterables.zipAndConcat(
              Iterables.cycle("-I"),
              FluentIterable.from(cxxPreprocessorInput.getIncludeRoots())
                  .transform(Functions.toStringFunction())),
          MoreIterables.zipAndConcat(
              Iterables.cycle("-isystem"),
              FluentIterable.from(cxxPreprocessorInput.getIncludeRoots())
                  .transform(Functions.toStringFunction())));
      String localCflags = Joiner.on(' ').join(escapeForMakefile(ppflags));



      NativeLinkableInput nativeLinkableInput =
          NativeLinkables.getTransitiveNativeLinkableInput(
              cxxPlatform,
              params.getDeps(),
              Linker.LinkableDepType.SHARED,
              Predicates.or(
                  Predicates.instanceOf(NativeLinkable.class),
                  Predicates.instanceOf(NdkLibrary.class)),
 true);



      deps.addAll(pathResolver.filterBuildRuleInputs(nativeLinkableInput.getInputs()));



      String localLdflags = Joiner.on(' ').join(escapeForMakefile(nativeLinkableInput.getArgs()));


      if (!localCflags.isEmpty() || !localLdflags.isEmpty()) {
        NdkCxxPlatforms.TargetCpuType targetCpuType = entry.getKey();
        String targetArchAbi = getTargetArchAbi(targetCpuType);

        outputLinesBuilder.add(String.format("ifeq ($(TARGET_ARCH_ABI),%s)", targetArchAbi));
        if (!localCflags.isEmpty()) {
          outputLinesBuilder.add("BUCK_DEP_CFLAGS=" + localCflags);
        }
        if (!localLdflags.isEmpty()) {
          outputLinesBuilder.add("BUCK_DEP_LDFLAGS=" + localLdflags);
        }
        outputLinesBuilder.add("endif");
        outputLinesBuilder.add("");
      }
    }


    String ndksubst = NdkCxxPlatforms.ANDROID_NDK_ROOT;

    outputLinesBuilder.addAll(
        ImmutableList.copyOf(new String[] {

              "ifeq ($(BUCK_ALREADY_HOOKED_CFLAGS),)",
              "BUCK_ALREADY_HOOKED_CFLAGS := 1",

              "ifeq ($(filter clang%,$(NDK_TOOLCHAIN_VERSION)),)",

              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(NDK_ROOT)/=" + ndksubst + "/",
              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(abspath $(BUCK_PROJECT_DIR))/=./",


              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(BUCK_PROJECT_DIR)/=./",
              "NDK_APP_CFLAGS += -fdebug-prefix-map=./=" +
              ".$(subst $(abspath $(BUCK_PROJECT_DIR)),,$(abspath $(CURDIR)))/",
              "NDK_APP_CFLAGS += -fno-record-gcc-switches",
              "ifeq ($(filter 4.6,$(TOOLCHAIN_VERSION)),)",



              "NDK_APP_CPPFLAGS += -fno-canonical-system-headers",



              "NDK_APP_CFLAGS += -gno-record-gcc-switches",
              "endif", 
              "endif", 



              "BUCK_SAVED_IMPORTS := $(__ndk_import_dirs)",
              "__ndk_import_dirs :=",
              "$(foreach __dir,$(BUCK_SAVED_IMPORTS),\\",
              "$(call import-add-path-optional,\\",
              "$(if $(filter $(abspath $(BUCK_PROJECT_DIR))%,$(__dir)),\\",
              "$(BUCK_PROJECT_DIR)$(patsubst $(abspath $(BUCK_PROJECT_DIR))%,%,$(__dir)),\\",
              "$(__dir))))",
              "endif", 
            }));

    outputLinesBuilder.add("include Android.mk");

    BuildTarget makefileTarget = BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(MAKEFILE_FLAVOR)
        .build();
    BuildRuleParams makefileParams = params.copyWithChanges(
        makefileTarget,
        Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()),
        Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));
    final Path makefilePath = getGeneratedMakefilePath(params.getBuildTarget());
    final String contents = Joiner.on(System.lineSeparator()).join(outputLinesBuilder.build());

    return new Pair<BuildRule, Iterable<BuildRule>>(
        new WriteFile(makefileParams, pathResolver, contents, makefilePath),
        deps.build());
  }

  @VisibleForTesting
  protected ImmutableSortedSet<SourcePath> findSources(
      final ProjectFilesystem filesystem,
      final Path buildRulePath) {
    final ImmutableSortedSet.Builder<SourcePath> srcs = ImmutableSortedSet.naturalOrder();

    try {
      final Path rootDirectory = filesystem.resolve(buildRulePath);
      Files.walkFileTree(
          rootDirectory,
          EnumSet.of(FileVisitOption.FOLLOW_LINKS),
 Integer.MAX_VALUE,
          new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                throws IOException {
              if (EXTENSIONS_REGEX.matcher(file.toString()).matches()) {
                srcs.add(
                    new PathSourcePath(
                        filesystem,
                        buildRulePath.resolve(rootDirectory.relativize(file))));
              }

              return super.visitFile(file, attrs);
            }
          });
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    return srcs.build();
  }

  @Override
  public <A extends Arg> NdkLibrary createBuildRule(
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    Pair<BuildRule, Iterable<BuildRule>> makefilePair = generateMakefile(params, resolver);
    resolver.addToIndex(makefilePair.getFirst());
    return new NdkLibrary(
        params.appendExtraDeps(
            ImmutableSortedSet.<BuildRule>naturalOrder()
                .add(makefilePair.getFirst())
                .addAll(makefilePair.getSecond())
                .build()),
        new SourcePathResolver(resolver),
        getGeneratedMakefilePath(params.getBuildTarget()),
        findSources(params.getProjectFilesystem(), params.getBuildTarget().getBasePath()),
        args.flags.get(),
        args.isAsset.or(false),
        ndkVersion,
        MACRO_HANDLER.getExpander(
            params.getBuildTarget(),
            resolver,
            params.getProjectFilesystem()));
  }

  @SuppressFieldNotInitialized
  public static class Arg {
    public Optional<ImmutableList<String>> flags;
    public Optional<Boolean> isAsset;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
  }

}

<code block>


package com.facebook.buck.ocaml;

import com.facebook.buck.cxx.CxxPreprocessables;
import com.facebook.buck.cxx.CxxPreprocessorDep;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.cxx.NativeLinkableInput;
import com.facebook.buck.cxx.NativeLinkables;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.coercer.OCamlSource;
import com.facebook.buck.util.Ansi;
import com.facebook.buck.util.CapturingPrintStream;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.Verbosity;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.List;


public class OCamlRuleBuilder {

  private static final Flavor OCAML_STATIC_FLAVOR = ImmutableFlavor.of("static");
  private static final Flavor OCAML_LINK_BINARY_FLAVOR = ImmutableFlavor.of("binary");

  private OCamlRuleBuilder() {
  }

  public static Function<BuildRule, ImmutableList<String>> getLibInclude(
      final boolean isBytecode) {
    return
      new Function<BuildRule, ImmutableList<String>>() {
        @Override
        public ImmutableList<String> apply(BuildRule input) {
          if (input instanceof OCamlLibrary) {
            OCamlLibrary library = (OCamlLibrary) input;
            if (isBytecode) {
                return ImmutableList.copyOf(library.getBytecodeIncludeDirs());
            } else {
              return ImmutableList.of(library.getIncludeLibDir().toString());
            }
          } else {
            return ImmutableList.of();
          }
        }
      };
  }

  public static ImmutableList<SourcePath> getInput(Iterable<OCamlSource> source) {
    return ImmutableList.copyOf(
        FluentIterable.from(source)
            .transform(
                new Function<OCamlSource, SourcePath>() {
                  @Override
                  public SourcePath apply(OCamlSource input) {
                    return input.getSource();
                  }
                })
    );
  }

  @VisibleForTesting
  protected static BuildTarget createStaticLibraryBuildTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(OCAML_STATIC_FLAVOR).build();
  }

  @VisibleForTesting
  protected static BuildTarget createOCamlLinkTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(OCAML_LINK_BINARY_FLAVOR).build();
  }

  public static AbstractBuildRule createBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    boolean noYaccOrLexSources = FluentIterable.from(srcs).transform(OCamlSource.TO_SOURCE_PATH)
        .filter(OCamlUtil.sourcePathExt(
                  pathResolver,
                  OCamlCompilables.OCAML_MLL,
                  OCamlCompilables.OCAML_MLY))
        .isEmpty();
    if (noYaccOrLexSources) {
      return createFineGrainedBuildRule(
          ocamlBuckConfig,
          params,
          resolver,
          srcs,
          isLibrary,
          argFlags,
          linkerFlags);
    } else {
      return createBulkBuildRule(
          ocamlBuckConfig,
          params,
          resolver,
          srcs,
          isLibrary,
          argFlags,
          linkerFlags);
    }
  }

  public static AbstractBuildRule createBulkBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    CxxPreprocessorInput cxxPreprocessorInputFromDeps;
    try {
      cxxPreprocessorInputFromDeps = CxxPreprocessorInput.concat(
          CxxPreprocessables.getTransitiveCxxPreprocessorInput(
              ocamlBuckConfig.getCxxPlatform(),
              FluentIterable.from(params.getDeps())
                  .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
    } catch (CxxPreprocessorInput.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> includes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(false))
        .toList();

    ImmutableList<String> bytecodeIncludes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(true))
        .toList();

    NativeLinkableInput linkableInput = NativeLinkables.getTransitiveNativeLinkableInput(
        ocamlBuckConfig.getCxxPlatform(),
        params.getDeps(),
        Linker.LinkableDepType.STATIC,
 false);

    ImmutableList<OCamlLibrary> ocamlInput = OCamlUtil.getTransitiveOCamlInput(params.getDeps());

    ImmutableSortedSet.Builder<BuildRule> allDepsBuilder = ImmutableSortedSet.naturalOrder();
    allDepsBuilder.addAll(pathResolver.filterBuildRuleInputs(getInput(srcs)));
    allDepsBuilder.addAll(pathResolver.filterBuildRuleInputs(linkableInput.getInputs()));
    for (OCamlLibrary library : ocamlInput) {
      allDepsBuilder.addAll(library.getCompileDeps());
      allDepsBuilder.addAll(library.getBytecodeCompileDeps());
    }
    ImmutableSortedSet<BuildRule> allDeps = allDepsBuilder.build();

    BuildTarget buildTarget =
        isLibrary ? createStaticLibraryBuildTarget(params.getBuildTarget())
            : createOCamlLinkTarget(params.getBuildTarget());
    final BuildRuleParams compileParams = params.copyWithChanges(
        buildTarget,
 Suppliers.ofInstance(allDeps),
 Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));

    ImmutableList.Builder<String> flagsBuilder = ImmutableList.builder();
    flagsBuilder.addAll(argFlags);

    ImmutableSortedSet.Builder<BuildRule> compileDepsBuilder = ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeCompileDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeLinkDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    for (OCamlLibrary library : ocamlInput) {
      compileDepsBuilder.addAll(library.getCompileDeps());
      bytecodeCompileDepsBuilder.addAll(library.getBytecodeCompileDeps());
      bytecodeLinkDepsBuilder.addAll(library.getBytecodeLinkDeps());
    }
    OCamlBuildContext ocamlContext =
        OCamlBuildContext.builder(ocamlBuckConfig)
            .setFlags(flagsBuilder.build())
            .setIncludes(includes)
            .setBytecodeIncludes(bytecodeIncludes)
            .setOCamlInput(ocamlInput)
            .setLinkableInput(linkableInput)
            .setBuildTarget(buildTarget)
            .setLibrary(isLibrary)
            .setCxxPreprocessorInput(cxxPreprocessorInputFromDeps)
            .setInput(pathResolver.getAllPaths(getInput(srcs)))
            .setCompileDeps(compileDepsBuilder.build())
            .setBytecodeCompileDeps(bytecodeCompileDepsBuilder.build())
            .setBytecodeLinkDeps(bytecodeLinkDepsBuilder.build())
            .build();

    final OCamlBuild ocamlLibraryBuild = new OCamlBuild(
        compileParams,
        pathResolver,
        ocamlContext,
        ocamlBuckConfig.getCCompiler(),
        ocamlBuckConfig.getCxxCompiler());
    resolver.addToIndex(ocamlLibraryBuild);

    if (isLibrary) {
      return new OCamlStaticLibrary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .add(ocamlLibraryBuild)
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          compileParams,
          linkerFlags,
          FluentIterable.from(srcs)
              .transform(OCamlSource.TO_SOURCE_PATH)
              .transform(pathResolver.getPathFunction())
              .filter(OCamlUtil.ext(OCamlCompilables.OCAML_C))
              .transform(ocamlContext.toCOutput())
              .transform(
                  SourcePaths.getToBuildTargetSourcePath(
                      params.getProjectFilesystem(),
                      compileParams.getBuildTarget()))
              .toList(),
          ocamlContext,
          ocamlLibraryBuild,
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild),
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild),
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild));
    } else {
      return new OCamlBinary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .add(ocamlLibraryBuild)
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          ocamlLibraryBuild);
    }
  }

  public static AbstractBuildRule createFineGrainedBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    CxxPreprocessorInput cxxPreprocessorInputFromDeps;
    try {
      cxxPreprocessorInputFromDeps = CxxPreprocessorInput.concat(
          CxxPreprocessables.getTransitiveCxxPreprocessorInput(
              ocamlBuckConfig.getCxxPlatform(),
              FluentIterable.from(params.getDeps())
                  .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
    } catch (CxxPreprocessorInput.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> includes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(false))
        .toList();

    ImmutableList<String> bytecodeIncludes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(true))
        .toList();

    NativeLinkableInput linkableInput = NativeLinkables.getTransitiveNativeLinkableInput(
        ocamlBuckConfig.getCxxPlatform(),
        params.getDeps(),
        Linker.LinkableDepType.STATIC,
 false);

    ImmutableList<OCamlLibrary> ocamlInput = OCamlUtil.getTransitiveOCamlInput(params.getDeps());

    ImmutableList<SourcePath> allInputs =
        ImmutableList.<SourcePath>builder()
            .addAll(getInput(srcs))
            .addAll(linkableInput.getInputs())
            .build();

    BuildTarget buildTarget =
        isLibrary ? createStaticLibraryBuildTarget(params.getBuildTarget())
            : createOCamlLinkTarget(params.getBuildTarget());

    final BuildRuleParams compileParams = params.copyWithChanges(
        buildTarget,
 Suppliers.ofInstance(
            ImmutableSortedSet.copyOf(pathResolver.filterBuildRuleInputs(allInputs))),
 Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));

    ImmutableList.Builder<String> flagsBuilder = ImmutableList.builder();
    flagsBuilder.addAll(argFlags);

    ImmutableSortedSet.Builder<BuildRule> compileDepsBuilder = ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeCompileDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeLinkDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    for (OCamlLibrary library : ocamlInput) {
      compileDepsBuilder.addAll(library.getCompileDeps());
      bytecodeCompileDepsBuilder.addAll(library.getBytecodeCompileDeps());
      bytecodeLinkDepsBuilder.addAll(library.getBytecodeLinkDeps());
    }
    OCamlBuildContext ocamlContext =
        OCamlBuildContext.builder(ocamlBuckConfig)
            .setFlags(flagsBuilder.build())
            .setIncludes(includes)
            .setBytecodeIncludes(bytecodeIncludes)
            .setOCamlInput(ocamlInput)
            .setLinkableInput(linkableInput)
            .setBuildTarget(buildTarget)
            .setLibrary(isLibrary)
            .setCxxPreprocessorInput(cxxPreprocessorInputFromDeps)
            .setInput(pathResolver.getAllPaths(getInput(srcs)))
            .setCompileDeps(compileDepsBuilder.build())
            .setBytecodeCompileDeps(bytecodeCompileDepsBuilder.build())
            .setBytecodeLinkDeps(bytecodeLinkDepsBuilder.build())
            .build();

    File baseDir = params.getProjectFilesystem().getRootPath().toAbsolutePath().toFile();
    ImmutableMap<Path, ImmutableList<Path>> mlInput = getMLInputWithDeps(
        baseDir,
        ocamlContext);

    ImmutableList<SourcePath> cInput = getCInput(pathResolver, getInput(srcs));

    OCamlBuildRulesGenerator generator = new OCamlBuildRulesGenerator(
        compileParams,
        pathResolver,
        resolver,
        ocamlContext,
        mlInput,
        cInput,
        ocamlBuckConfig.getCCompiler(),
        ocamlBuckConfig.getCxxCompiler());

    OCamlGeneratedBuildRules result = generator.generate();

    if (isLibrary) {
      return new OCamlStaticLibrary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .addAll(result.getRules())
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          compileParams,
          linkerFlags,
          result.getObjectFiles(),
          ocamlContext,
          result.getRules().get(0),
          result.getCompileDeps(),
          result.getBytecodeCompileDeps(),
          ImmutableSortedSet.<BuildRule>naturalOrder()
              .add(result.getBytecodeLink())
              .addAll(pathResolver.filterBuildRuleInputs(result.getObjectFiles()))
              .build());
    } else {
      return new OCamlBinary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .addAll(result.getRules())
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          result.getRules().get(0));
    }
  }

  private static ImmutableList<SourcePath> getCInput(
      SourcePathResolver resolver,
      ImmutableList<SourcePath> input) {
    return FluentIterable
        .from(input)
        .filter(OCamlUtil.sourcePathExt(resolver, OCamlCompilables.OCAML_C))
        .toList();
  }

  private static ImmutableMap<Path, ImmutableList<Path>> getMLInputWithDeps(
      File baseDir,
      OCamlBuildContext ocamlContext) {
    OCamlDepToolStep depToolStep = new OCamlDepToolStep(
        ocamlContext.getOcamlDepTool().get(),
        ocamlContext.getMLInput(),
        ocamlContext.getIncludeFlags( false,  true));
    ImmutableList<String> cmd = depToolStep.getShellCommand(null);
    Optional<String> depsString;
    try {
      depsString = executeProcessAndGetStdout(baseDir, cmd);
    } catch (IOException e) {
      throw new HumanReadableException(
          e,
          "Unable to execute ocamldep due to io error: %s",
          Joiner.on(" ").join(cmd));
    } catch (InterruptedException e) {
      throw new HumanReadableException(e,
          "Unable to calculate dependencies. ocamldep is interrupted: %s",
          Joiner.on(" ").join(cmd));
    }
    if (depsString.isPresent()) {
      OCamlDependencyGraphGenerator graphGenerator = new OCamlDependencyGraphGenerator();
      return filterCurrentRuleInput(
          ocamlContext.getMLInput(),
          graphGenerator.generateDependencyMap(depsString.get()));
    } else {
      throw new HumanReadableException("ocamldep execution failed");
    }
  }

  private static ImmutableMap<Path, ImmutableList<Path>> filterCurrentRuleInput(
      final List<Path> mlInput,
      ImmutableMap<Path, ImmutableList<Path>> deps) {
    ImmutableMap.Builder<Path, ImmutableList<Path>> builder = ImmutableMap.builder();
    for (ImmutableMap.Entry<Path, ImmutableList<Path>> entry : deps.entrySet()) {
      if (mlInput.contains(entry.getKey())) {
        builder.put(entry.getKey(),
            FluentIterable.from(entry.getValue())
              .filter(new Predicate<Path>() {
                        @Override
                        public boolean apply(Path input) {
                          return mlInput.contains(input);
                        }
                      }).toList()
            );
      }
    }
    return builder.build();
  }

  private static Optional<String> executeProcessAndGetStdout(
      File baseDir,
      ImmutableList<String> cmd) throws IOException, InterruptedException {
    CapturingPrintStream stdout = new CapturingPrintStream();
    CapturingPrintStream stderr = new CapturingPrintStream();

    ImmutableSet.Builder<ProcessExecutor.Option> options = ImmutableSet.builder();
    options.add(ProcessExecutor.Option.EXPECTING_STD_OUT);
    Console console = new Console(Verbosity.SILENT, stdout, stderr, Ansi.withoutTty());
    ProcessExecutor exe = new ProcessExecutor(console);
    ProcessBuilder processBuilder = new ProcessBuilder(cmd);
    processBuilder.directory(baseDir);
    ProcessExecutor.Result result = exe.execute(
        processBuilder.start(),
        options.build(),
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
    if (result.getExitCode() != 0) {
      throw new HumanReadableException(stderr.getContentsAsString(StandardCharsets.UTF_8));
    }

    return result.getStdout();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

public class CxxLibraryDescription implements
    Description<CxxLibraryDescription.Arg>,
    ImplicitDepsInferringDescription<CxxLibraryDescription.Arg>,
    Flavored {

  public enum Type {
    HEADERS,
    EXPORTED_HEADERS,
    SHARED,
    STATIC_PIC,
    STATIC,
    MACH_O_BUNDLE,
  }

  public static final BuildRuleType TYPE = BuildRuleType.of("cxx_library");

  private static final FlavorDomain<Type> LIBRARY_TYPE =
      new FlavorDomain<>(
          "C/C++ Library Type",
          ImmutableMap.<Flavor, Type>builder()
              .put(CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR, Type.HEADERS)
              .put(
                  CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR,
                  Type.EXPORTED_HEADERS)
              .put(CxxDescriptionEnhancer.SHARED_FLAVOR, Type.SHARED)
              .put(CxxDescriptionEnhancer.STATIC_PIC_FLAVOR, Type.STATIC_PIC)
              .put(CxxDescriptionEnhancer.STATIC_FLAVOR, Type.STATIC)
              .put(CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR, Type.MACH_O_BUNDLE)
              .build());

  private final CxxBuckConfig cxxBuckConfig;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;
  private final CxxPreprocessMode preprocessMode;

  public CxxLibraryDescription(
      CxxBuckConfig cxxBuckConfig,
      FlavorDomain<CxxPlatform> cxxPlatforms,
      CxxPreprocessMode preprocessMode) {
    this.cxxBuckConfig = cxxBuckConfig;
    this.cxxPlatforms = cxxPlatforms;
    this.preprocessMode = preprocessMode;
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return cxxPlatforms.containsAnyOf(flavors) ||
        flavors.contains(CxxCompilationDatabase.COMPILATION_DATABASE);
  }

  private static ImmutableCollection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<Path> frameworkSearchPaths) {



    BuildTarget rawTarget =
        params.getBuildTarget()
            .withoutFlavors(
                ImmutableSet.<Flavor>builder()
                    .addAll(LIBRARY_TYPE.getFlavors())
                    .add(cxxPlatform.getFlavor())
                    .build());
    Optional<BuildRule> rawRule = ruleResolver.getRuleOptional(rawTarget);
    if (rawRule.isPresent()) {
      CxxLibrary rule = (CxxLibrary) rawRule.get();
      return rule.getTransitiveCxxPreprocessorInput(cxxPlatform, HeaderVisibility.PUBLIC).values();
    }


    SymlinkTree symlinkTree =
        CxxDescriptionEnhancer.requireHeaderSymlinkTree(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
 false,
            ImmutableMap.<String, SourcePath>of(),
            ImmutableMap.<String, SourcePath>of(),
            exportedHeaders,
            HeaderVisibility.PUBLIC);
    Map<BuildTarget, CxxPreprocessorInput> input = Maps.newLinkedHashMap();
    input.put(
        params.getBuildTarget(),
        CxxPreprocessorInput.builder()
            .addRules(symlinkTree.getBuildTarget())
            .putAllPreprocessorFlags(exportedPreprocessorFlags)
            .setIncludes(
                CxxHeaders.builder()
                    .putAllNameToPathMap(symlinkTree.getLinks())
                    .putAllFullNameToPathMap(symlinkTree.getFullLinks())
                    .build())
            .addIncludeRoots(symlinkTree.getRoot())
            .addAllFrameworkRoots(frameworkSearchPaths)
            .build());
    for (BuildRule rule : params.getDeps()) {
      if (rule instanceof CxxPreprocessorDep) {
        input.putAll(
            ((CxxPreprocessorDep) rule).getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                HeaderVisibility.PUBLIC));
      }
    }
    return ImmutableList.copyOf(input.values());
  }

  private static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requireObjects(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {

    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.requireLexYaccSources(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
            lexSources,
            yaccSources);

    SymlinkTree headerSymlinkTree =
        CxxDescriptionEnhancer.requireHeaderSymlinkTree(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
 true,
            lexSources,
            yaccSources,
            headers,
            HeaderVisibility.PRIVATE);

    CxxPreprocessorInput cxxPreprocessorInputFromDependencies =
        CxxDescriptionEnhancer.combineCxxPreprocessorInput(
            params,
            cxxPlatform,
            preprocessorFlags,
            prefixHeaders,
            ImmutableList.of(headerSymlinkTree),
            ImmutableList.<Path>of(),
            getTransitiveCxxPreprocessorInput(
                params,
                ruleResolver,
                pathResolver,
                cxxPlatform,
                exportedPreprocessorFlags,
                exportedHeaders,
                frameworkSearchPaths));

    ImmutableMap<String, CxxSource> allSources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(sources)
            .putAll(lexYaccSources.getCxxSources())
            .build();


    return CxxSourceRuleFactory.requirePreprocessAndCompileRules(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        cxxPreprocessorInputFromDependencies,
        compilerFlags,
        preprocessMode,
        allSources,
        pic);
  }


  private static BuildRule createStaticLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        pic);


    BuildTarget staticTarget =
        CxxDescriptionEnhancer.createStaticLibraryBuildTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            pic);
    Path staticLibraryPath =
        CxxDescriptionEnhancer.getStaticLibraryPath(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            pic);
    return Archives.createArchiveRule(
        pathResolver,
        staticTarget,
        params,
        cxxPlatform.getAr(),
        cxxPlatform.getArExpectedGlobalHeader(),
        staticLibraryPath,
        ImmutableList.copyOf(objects.values()));
  }


  private static BuildRule createSharedLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<String> linkerFlags,
      ImmutableList<Path> frameworkSearchPaths,
      Optional<String> soname,
      CxxPreprocessMode preprocessMode,
      Optional<Linker.CxxRuntimeType> cxxRuntimeType,
      Linker.LinkType linkType,
      Linker.LinkableDepType linkableDepType,
      Optional<SourcePath> bundleLoader) {


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        CxxSourceRuleFactory.PicType.PIC);


    BuildTarget sharedTarget =
        CxxDescriptionEnhancer.createSharedLibraryBuildTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor());
    String sharedLibrarySoname =
        soname.or(
            CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
                params.getBuildTarget(), cxxPlatform));
    Path sharedLibraryPath = CxxDescriptionEnhancer.getSharedLibraryPath(
        params.getBuildTarget(),
        sharedLibrarySoname,
        cxxPlatform);
    ImmutableList.Builder<String> extraCxxLdFlagsBuilder = ImmutableList.builder();
    extraCxxLdFlagsBuilder.addAll(
        MoreIterables.zipAndConcat(
            Iterables.cycle("-F"),
            Iterables.transform(frameworkSearchPaths, Functions.toStringFunction())));
    ImmutableList<String> extraCxxLdFlags = extraCxxLdFlagsBuilder.build();

    return CxxLinkableEnhancer.createCxxLinkableBuildRule(
            cxxPlatform,
            params,
            pathResolver,
            extraCxxLdFlags,
            linkerFlags,
            sharedTarget,
            linkType,
            Optional.of(sharedLibrarySoname),
            sharedLibraryPath,
            objects.values(),
            linkableDepType,
            params.getDeps(),
            cxxRuntimeType,
            bundleLoader);
  }


  private static CxxCompilationDatabase createCompilationDatabase(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode) {
    BuildRuleParams paramsWithoutCompilationDatabaseFlavor = CxxCompilationDatabase
        .paramsWithoutCompilationDatabaseFlavor(params);



    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        paramsWithoutCompilationDatabaseFlavor,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        CxxSourceRuleFactory.PicType.PIC);

    return CxxCompilationDatabase.createCompilationDatabase(
        params,
        pathResolver,
        preprocessMode,
        objects.keySet());
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  public static Arg createEmptyConstructorArg() {
    Arg arg = new Arg();
    arg.deps = Optional.of(ImmutableSortedSet.<BuildTarget>of());
    arg.srcs = Optional.of(
        Either.<ImmutableList<SourceWithFlags>, ImmutableMap<String, SourceWithFlags>>ofLeft(
            ImmutableList.<SourceWithFlags>of()));
    arg.prefixHeaders = Optional.of(ImmutableList.<SourcePath>of());
    arg.headers = Optional.of(
        Either.<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>ofLeft(
            ImmutableList.<SourcePath>of()));
    arg.exportedHeaders = Optional.of(
        Either.<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>ofLeft(
            ImmutableList.<SourcePath>of()));
    arg.compilerFlags = Optional.of(ImmutableList.<String>of());
    arg.platformCompilerFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedPreprocessorFlags = Optional.of(ImmutableList.<String>of());
    arg.exportedPlatformPreprocessorFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedLangPreprocessorFlags = Optional.of(
        ImmutableMap.<CxxSource.Type, ImmutableList<String>>of());
    arg.preprocessorFlags = Optional.of(ImmutableList.<String>of());
    arg.platformPreprocessorFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.langPreprocessorFlags = Optional.of(
        ImmutableMap.<CxxSource.Type, ImmutableList<String>>of());
    arg.linkerFlags = Optional.of(ImmutableList.<String>of());
    arg.exportedLinkerFlags = Optional.of(ImmutableList.<String>of());
    arg.platformLinkerFlags = Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedPlatformLinkerFlags = Optional.of(
        ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.cxxRuntimeType = Optional.absent();
    arg.forceStatic = Optional.absent();
    arg.linkWhole = Optional.absent();
    arg.lexSrcs = Optional.of(ImmutableList.<SourcePath>of());
    arg.yaccSrcs = Optional.of(ImmutableList.<SourcePath>of());
    arg.headerNamespace = Optional.absent();
    arg.soname = Optional.absent();
    arg.frameworkSearchPaths = Optional.of(ImmutableList.<Path>of());
    arg.tests = Optional.of(ImmutableSortedSet.<BuildTarget>of());
    arg.supportedPlatformsRegex = Optional.absent();
    return arg;
  }


  public static <A extends Arg> SymlinkTree createHeaderSymlinkTreeBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args) {
    return CxxDescriptionEnhancer.createHeaderSymlinkTree(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
 true,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        HeaderVisibility.PRIVATE);
  }


  public static <A extends Arg> SymlinkTree createExportedHeaderSymlinkTreeBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args) {
    return CxxDescriptionEnhancer.createHeaderSymlinkTree(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
 false,
        ImmutableMap.<String, SourcePath>of(),
        ImmutableMap.<String, SourcePath>of(),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        HeaderVisibility.PUBLIC);
  }


  public static <A extends Arg> BuildRule createStaticLibraryBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {
    return createStaticLibrary(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        args.frameworkSearchPaths.get(),
        preprocessMode,
        pic);
  }


  public static <A extends Arg> BuildRule createSharedLibraryBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode,
      Linker.LinkType linkType,
      Linker.LinkableDepType linkableDepType,
      Optional<SourcePath> bundleLoader) {
    ImmutableList.Builder<String> linkerFlags = ImmutableList.builder();

    linkerFlags.addAll(
        CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()));

    linkerFlags.addAll(
        CxxFlags.getFlags(
            args.exportedLinkerFlags,
            args.exportedPlatformLinkerFlags,
            cxxPlatform.getFlavor()));

    return createSharedLibrary(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        linkerFlags.build(),
        args.frameworkSearchPaths.get(),
        args.soname,
        preprocessMode,
        args.cxxRuntimeType,
        linkType,
        linkableDepType,
        bundleLoader);
  }


  public static <A extends Arg> CxxCompilationDatabase createCompilationDatabaseBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode) {
    return createCompilationDatabase(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        args.frameworkSearchPaths.get(),
        preprocessMode);
  }

  public static TypeAndPlatform getTypeAndPlatform(
      BuildTarget buildTarget,
      FlavorDomain<CxxPlatform> platforms) {


    Optional<Map.Entry<Flavor, Type>> type;
    Optional<Map.Entry<Flavor, CxxPlatform>> platform;
    try {
      type = LIBRARY_TYPE.getFlavorAndValue(
          ImmutableSet.copyOf(buildTarget.getFlavors()));
      platform = platforms.getFlavorAndValue(
          ImmutableSet.copyOf(buildTarget.getFlavors()));
    } catch (FlavorDomainException e) {
      throw new HumanReadableException("%s: %s", buildTarget, e.getMessage());
    }
    return TypeAndPlatform.of(type, platform);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    TypeAndPlatform typeAndPlatform = getTypeAndPlatform(
        params.getBuildTarget(),
        cxxPlatforms);
    return createBuildRule(
        params,
        resolver,
        args,
        typeAndPlatform,
        Optional.<Linker.LinkableDepType>absent(),
        Optional.<SourcePath>absent());
  }

  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      final A args,
      TypeAndPlatform typeAndPlatform,
      Optional<Linker.LinkableDepType> linkableDepType,
      Optional<SourcePath> bundleLoader) {
    Optional<Map.Entry<Flavor, CxxPlatform>> platform = typeAndPlatform.getPlatform();

    if (params.getBuildTarget().getFlavors()
        .contains(CxxCompilationDatabase.COMPILATION_DATABASE)) {

      return createCompilationDatabaseBuildRule(
          params,
          resolver,
          platform.isPresent()
              ? platform.get().getValue()
              : DefaultCxxPlatforms.build(cxxBuckConfig),
          args,
          preprocessMode);
    }


    Optional<Map.Entry<Flavor, Type>> type = typeAndPlatform.getType();



    if (type.isPresent() && platform.isPresent()) {
      Set<Flavor> flavors = Sets.newHashSet(params.getBuildTarget().getFlavors());
      flavors.remove(type.get().getKey());
      BuildTarget target = BuildTarget
          .builder(params.getBuildTarget().getUnflavoredBuildTarget())
          .addAllFlavors(flavors)
          .build();
      BuildRuleParams typeParams =
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(params.getDeclaredDeps()),
              Suppliers.ofInstance(params.getExtraDeps()));
      if (type.get().getValue().equals(Type.HEADERS)) {
        return createHeaderSymlinkTreeBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args);
      } else if (type.get().getValue().equals(Type.EXPORTED_HEADERS)) {
          return createExportedHeaderSymlinkTreeBuildRule(
              typeParams,
              resolver,
              platform.get().getValue(),
              args);
      } else if (type.get().getValue().equals(Type.SHARED)) {
        return createSharedLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            Linker.LinkType.SHARED,
            linkableDepType.or(Linker.LinkableDepType.SHARED),
            Optional.<SourcePath>absent());
      } else if (type.get().getValue().equals(Type.MACH_O_BUNDLE)) {
        return createSharedLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            Linker.LinkType.MACH_O_BUNDLE,
            linkableDepType.or(Linker.LinkableDepType.SHARED),
            bundleLoader);
      } else if (type.get().getValue().equals(Type.STATIC)) {
        return createStaticLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            CxxSourceRuleFactory.PicType.PDC);
      } else {
        return createStaticLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            CxxSourceRuleFactory.PicType.PIC);
      }
    }


    boolean hasObjects = false;
    if (args.srcs.isPresent()) {
      Either<ImmutableList<SourceWithFlags>, ImmutableMap<String, SourceWithFlags>> either =
          args.srcs.get();
      if (either.isLeft()) {
        hasObjects = !either.getLeft().isEmpty();
      } else {
        hasObjects = !either.getRight().isEmpty();
      }
    }
    hasObjects |=
          !args.lexSrcs.get().isEmpty() ||
          !args.yaccSrcs.get().isEmpty();



    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return new CxxLibrary(
        params,
        resolver,
        pathResolver,
        !hasObjects,
        new Function<CxxPlatform, ImmutableMultimap<CxxSource.Type, String>>() {
          @Override
          public ImmutableMultimap<CxxSource.Type, String> apply(CxxPlatform input) {
            return CxxFlags.getLanguageFlags(
                args.exportedPreprocessorFlags,
                args.exportedPlatformPreprocessorFlags,
                args.exportedLangPreprocessorFlags,
                input.getFlavor());
          }
        },
        new Function<CxxPlatform, ImmutableList<String>>() {
          @Override
          public ImmutableList<String> apply(CxxPlatform input) {
            return CxxFlags.getFlags(
                args.exportedLinkerFlags,
                args.exportedPlatformLinkerFlags,
                input.getFlavor());
          }
        },
        args.supportedPlatformsRegex,
        args.frameworkSearchPaths.get(),
        args.forceStatic.or(false) ? CxxLibrary.Linkage.STATIC : CxxLibrary.Linkage.ANY,
        args.linkWhole.or(false),
        args.soname,
        args.tests.get());
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      Arg constructorArg) {
    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();

    if (constructorArg.lexSrcs.isPresent() && !constructorArg.lexSrcs.get().isEmpty()) {
      deps.add(cxxBuckConfig.getLexDep());
    }

    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends CxxConstructorArg {
    public Optional<Either<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>>
        exportedHeaders;
    public Optional<ImmutableList<String>> exportedPreprocessorFlags;
    public Optional<ImmutableList<Pair<String, ImmutableList<String>>>>
        exportedPlatformPreprocessorFlags;
    public Optional<ImmutableMap<CxxSource.Type, ImmutableList<String>>>
        exportedLangPreprocessorFlags;
    public Optional<ImmutableList<String>> exportedLinkerFlags;
    public Optional<ImmutableList<Pair<String, ImmutableList<String>>>>
        exportedPlatformLinkerFlags;
    public Optional<String> supportedPlatformsRegex;
    public Optional<String> soname;
    public Optional<Boolean> forceStatic;
    public Optional<Boolean> linkWhole;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.python.PythonUtil;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Path;
import java.util.Map;

public class CxxPythonExtensionDescription implements
    Description<CxxPythonExtensionDescription.Arg>,
    ImplicitDepsInferringDescription<CxxPythonExtensionDescription.Arg> {

  private enum Type {
    EXTENSION,
  }

  private static final FlavorDomain<Type> LIBRARY_TYPE =
      new FlavorDomain<>(
          "C/C++ Library Type",
          ImmutableMap.of(
              CxxDescriptionEnhancer.SHARED_FLAVOR, Type.EXTENSION));

  public static final BuildRuleType TYPE = BuildRuleType.of("cxx_python_extension");

  private final CxxBuckConfig cxxBuckConfig;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;

  public CxxPythonExtensionDescription(
      CxxBuckConfig cxxBuckConfig,
      FlavorDomain<CxxPlatform> cxxPlatforms) {
    this.cxxBuckConfig = cxxBuckConfig;
    this.cxxPlatforms = cxxPlatforms;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @VisibleForTesting
  protected BuildTarget getExtensionTarget(BuildTarget target, Flavor platform) {
    return CxxDescriptionEnhancer.createSharedLibraryBuildTarget(target, platform);
  }

  @VisibleForTesting
  protected String getExtensionName(BuildTarget target) {

    return String.format("%s.so", target.getShortName());
  }

  @VisibleForTesting
  protected Path getExtensionPath(BuildTarget target, Flavor platform) {
    return BuildTargets.getGenPath(getExtensionTarget(target, platform), "%s")
        .resolve(getExtensionName(target));
  }

  private <A extends Arg> BuildRule createExtensionBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      CxxPlatform cxxPlatform,
      A args) {
    SourcePathResolver pathResolver = new SourcePathResolver(ruleResolver);


    ImmutableMap<String, CxxSource> srcs =
        CxxDescriptionEnhancer.parseCxxSources(params, ruleResolver, args);
    ImmutableMap<Path, SourcePath> headers =
        CxxDescriptionEnhancer.parseHeaders(
            params,
            ruleResolver,
            args);
    ImmutableMap<String, SourcePath> lexSrcs =
        CxxDescriptionEnhancer.parseLexSources(params, ruleResolver, args);
    ImmutableMap<String, SourcePath> yaccSrcs =
        CxxDescriptionEnhancer.parseYaccSources(params, ruleResolver, args);

    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.createLexYaccBuildRules(
            params,
            ruleResolver,
            cxxPlatform,
            ImmutableList.<String>of(),
            lexSrcs,
            ImmutableList.<String>of(),
            yaccSrcs);



    SymlinkTree headerSymlinkTree = CxxDescriptionEnhancer.requireHeaderSymlinkTree(
        params,
        ruleResolver,
        new SourcePathResolver(ruleResolver),
        cxxPlatform,
 true,
        lexSrcs,
        yaccSrcs,
        headers,
        HeaderVisibility.PRIVATE);
    CxxPreprocessorInput cxxPreprocessorInput =
        CxxDescriptionEnhancer.combineCxxPreprocessorInput(
            params,
            cxxPlatform,
            CxxFlags.getLanguageFlags(
                args.preprocessorFlags,
                args.platformPreprocessorFlags,
                args.langPreprocessorFlags,
                cxxPlatform.getFlavor()),
            args.prefixHeaders.get(),
            ImmutableList.of(headerSymlinkTree),
            ImmutableList.<Path>of(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                params.getDeps()));

    ImmutableMap<String, CxxSource> allSources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(srcs)
            .putAll(lexYaccSources.getCxxSources())
            .build();


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> picObjects =
        CxxSourceRuleFactory.requirePreprocessAndCompileRules(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            CxxFlags.getFlags(
                args.compilerFlags,
                args.platformCompilerFlags,
                cxxPlatform.getFlavor()),
            cxxBuckConfig.getPreprocessMode(),
            allSources,
            CxxSourceRuleFactory.PicType.PIC);


    String extensionName = getExtensionName(params.getBuildTarget());
    Path extensionPath = getExtensionPath(params.getBuildTarget(), cxxPlatform.getFlavor());
    return CxxLinkableEnhancer.createCxxLinkableBuildRule(
        cxxPlatform,
        params,
        pathResolver,
 ImmutableList.<String>of(),
 CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()),
        getExtensionTarget(params.getBuildTarget(), cxxPlatform.getFlavor()),
        Linker.LinkType.SHARED,
        Optional.of(extensionName),
        extensionPath,
        picObjects.values(),
        Linker.LinkableDepType.SHARED,
        params.getDeps(),
        args.cxxRuntimeType,
        Optional.<SourcePath>absent());
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      A args) {



    Optional<Map.Entry<Flavor, Type>> type;
    Optional<Map.Entry<Flavor, CxxPlatform>> platform;
    try {
      type = LIBRARY_TYPE.getFlavorAndValue(
          ImmutableSet.copyOf(params.getBuildTarget().getFlavors()));
      platform = cxxPlatforms.getFlavorAndValue(
          ImmutableSet.copyOf(params.getBuildTarget().getFlavors()));
    } catch (FlavorDomainException e) {
      throw new HumanReadableException("%s: %s", params.getBuildTarget(), e.getMessage());
    }




    if (type.isPresent()) {
      Preconditions.checkState(type.get().getValue() == Type.EXTENSION);
      Preconditions.checkState(platform.isPresent());
      return createExtensionBuildRule(params, ruleResolver, platform.get().getValue(), args);
    }



    SourcePathResolver pathResolver = new SourcePathResolver(ruleResolver);
    Path baseModule = PythonUtil.getBasePath(params.getBuildTarget(), args.baseModule);
    return new CxxPythonExtension(
        params,
        ruleResolver,
        pathResolver,
        baseModule.resolve(getExtensionName(params.getBuildTarget())));
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      Arg constructorArg) {
    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();

    deps.add(cxxBuckConfig.getPythonDep());

    if (constructorArg.lexSrcs.isPresent() && !constructorArg.lexSrcs.get().isEmpty()) {
      deps.add(cxxBuckConfig.getLexDep());
    }

    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends CxxConstructorArg {
    public Optional<String> baseModule;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.io.Files;

import java.nio.file.Path;
import java.util.Collections;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CxxDescriptionEnhancer {

  private static final Logger LOG = Logger.get(CxxDescriptionEnhancer.class);

  public static final Flavor HEADER_SYMLINK_TREE_FLAVOR = ImmutableFlavor.of("header-symlink-tree");
  public static final Flavor EXPORTED_HEADER_SYMLINK_TREE_FLAVOR =
      ImmutableFlavor.of("exported-header-symlink-tree");
  public static final Flavor STATIC_FLAVOR = ImmutableFlavor.of("static");
  public static final Flavor STATIC_PIC_FLAVOR = ImmutableFlavor.of("static-pic");
  public static final Flavor SHARED_FLAVOR = ImmutableFlavor.of("shared");
  public static final Flavor MACH_O_BUNDLE_FLAVOR = ImmutableFlavor.of("mach-o-bundle");

  public static final Flavor CXX_LINK_BINARY_FLAVOR = ImmutableFlavor.of("binary");
  public static final Flavor LEX_YACC_SOURCE_FLAVOR = ImmutableFlavor.of("lex_yacc_sources");

  private CxxDescriptionEnhancer() {}

  private static BuildTarget createLexYaccSourcesBuildTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(LEX_YACC_SOURCE_FLAVOR).build();
  }

  public static CxxHeaderSourceSpec requireLexYaccSources(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources) {
    BuildTarget lexYaccTarget = createLexYaccSourcesBuildTarget(params.getBuildTarget());


    Optional<BuildRule> rule = ruleResolver.getRuleOptional(lexYaccTarget);
    if (rule.isPresent()) {
      @SuppressWarnings("unchecked")
      ContainerBuildRule<CxxHeaderSourceSpec> containerRule =
          (ContainerBuildRule<CxxHeaderSourceSpec>) rule.get();
      return containerRule.get();
    }


    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.createLexYaccBuildRules(
            params,
            ruleResolver,
            cxxPlatform,
            ImmutableList.<String>of(),
            lexSources,
            ImmutableList.<String>of(),
            yaccSources);

    ruleResolver.addToIndex(
        ContainerBuildRule.of(
            params,
            pathResolver,
            lexYaccTarget,
            lexYaccSources));

    return lexYaccSources;
  }

  public static SymlinkTree createHeaderSymlinkTree(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      boolean includeLexYaccHeaders,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMap<Path, SourcePath> headers,
      HeaderVisibility headerVisibility) {

    BuildTarget headerSymlinkTreeTarget =
        CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);
    Path headerSymlinkTreeRoot =
        CxxDescriptionEnhancer.getHeaderSymlinkTreePath(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);

    CxxHeaderSourceSpec lexYaccSources;
    if (includeLexYaccHeaders) {
      lexYaccSources = requireLexYaccSources(
          params,
          ruleResolver,
          pathResolver,
          cxxPlatform,
          lexSources,
          yaccSources);
    } else {
      lexYaccSources = CxxHeaderSourceSpec.builder().build();
    }

    return CxxPreprocessables.createHeaderSymlinkTreeBuildRule(
        pathResolver,
        headerSymlinkTreeTarget,
        params,
        headerSymlinkTreeRoot,
        ImmutableMap.<Path, SourcePath>builder()
            .putAll(headers)
            .putAll(lexYaccSources.getCxxHeaders())
            .build());
  }

  public static SymlinkTree requireHeaderSymlinkTree(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      boolean includeLexYaccHeaders,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMap<Path, SourcePath> headers,
      HeaderVisibility headerVisibility) {
    BuildTarget headerSymlinkTreeTarget =
        CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);


    Optional<BuildRule> rule = ruleResolver.getRuleOptional(headerSymlinkTreeTarget);
    if (rule.isPresent()) {
      Preconditions.checkState(rule.get() instanceof SymlinkTree);
      return (SymlinkTree) rule.get();
    }

    SymlinkTree symlinkTree = createHeaderSymlinkTree(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        includeLexYaccHeaders,
        lexSources,
        yaccSources,
        headers,
        headerVisibility);

    ruleResolver.addToIndex(symlinkTree);

    return symlinkTree;
  }


  public static BuildTarget createHeaderSymlinkTreeTarget(
      BuildTarget target,
      Flavor platform,
      HeaderVisibility headerVisibility) {
    return BuildTarget
        .builder(target)
        .addFlavors(platform)
        .addFlavors(getHeaderSymlinkTreeFlavor(headerVisibility))
        .build();
  }


  public static Path getHeaderSymlinkTreePath(
      BuildTarget target,
      Flavor platform,
      HeaderVisibility headerVisibility) {
    return BuildTargets.getGenPath(
        createHeaderSymlinkTreeTarget(target, platform, headerVisibility),
        "%s");
  }

  public static Flavor getHeaderSymlinkTreeFlavor(HeaderVisibility headerVisibility) {
    switch (headerVisibility) {
      case PUBLIC:
        return EXPORTED_HEADER_SYMLINK_TREE_FLAVOR;
      case PRIVATE:
        return HEADER_SYMLINK_TREE_FLAVOR;
      default:
        throw new RuntimeException("Unexpected value of enum ExportMode");
    }
  }

  private static ImmutableMap<Path, SourcePath> getHeaderMapFromArgParameter(
      SourcePathResolver pathResolver,
      BuildTarget buildTarget,
      Optional<String> headerNamespace,
      String parameterName,
      Optional<Either<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>> parameter) {
    ImmutableMap<String, SourcePath> headers;
    if (!parameter.isPresent()) {
      headers = ImmutableMap.of();
    } else if (parameter.get().isRight()) {
      headers = parameter.get().getRight();
    } else {
      headers = pathResolver.getSourcePathNames(
          buildTarget,
          parameterName,
          parameter.get().getLeft());
    }
    return CxxPreprocessables.resolveHeaderMap(
        headerNamespace.transform(MorePaths.TO_PATH)
            .or(buildTarget.getBasePath()),
        headers);
  }


  public static ImmutableMap<Path, SourcePath> parseHeaders(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    return getHeaderMapFromArgParameter(
        new SourcePathResolver(resolver),
        params.getBuildTarget(),
        args.headerNamespace,
        "headers",
        args.headers);
  }


  public static ImmutableMap<Path, SourcePath> parseExportedHeaders(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxLibraryDescription.Arg args) {
    return getHeaderMapFromArgParameter(
        new SourcePathResolver(resolver),
        params.getBuildTarget(),
        args.headerNamespace,
        "exportedHeaders",
        args.exportedHeaders);
  }


  public static ImmutableMap<String, CxxSource> parseCxxSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    ImmutableMap<String, SourceWithFlags> sources;
    if (!args.srcs.isPresent()) {
      sources = ImmutableMap.of();
    } else if (args.srcs.get().isRight()) {
      sources = args.srcs.get().getRight();
    } else {
      SourcePathResolver pathResolver = new SourcePathResolver(resolver);
      sources = pathResolver.getSourcePathNames(
          params.getBuildTarget(),
          "srcs",
          args.srcs.get().getLeft(),
          SourceWithFlags.TO_SOURCE_PATH);
    }
    return CxxCompilableEnhancer.resolveCxxSources(sources);
  }

  public static ImmutableMap<String, SourcePath> parseLexSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return pathResolver.getSourcePathNames(
        params.getBuildTarget(),
        "lexSrcs",
        args.lexSrcs.or(ImmutableList.<SourcePath>of()));
  }

  public static ImmutableMap<String, SourcePath> parseYaccSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return pathResolver.getSourcePathNames(
        params.getBuildTarget(),
        "yaccSrcs",
        args.yaccSrcs.or(ImmutableList.<SourcePath>of()));
  }

  @VisibleForTesting
  protected static BuildTarget createLexBuildTarget(BuildTarget target, String name) {
    return BuildTarget
        .builder(target.getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    "lex-%s",
                    name.replace('/', '-').replace('.', '-').replace('+', '-').replace(' ', '-'))))
        .build();
  }

  @VisibleForTesting
  protected static BuildTarget createYaccBuildTarget(BuildTarget target, String name) {
    return BuildTarget
        .builder(target.getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    "yacc-%s",
                    name.replace('/', '-').replace('.', '-').replace('+', '-').replace(' ', '-'))))
        .build();
  }


  @VisibleForTesting
  protected static Path getYaccOutputPrefix(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createYaccBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name);
  }


  @VisibleForTesting
  protected static Path getLexSourceOutputPath(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createLexBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name + ".cc");
  }


  @VisibleForTesting
  protected static Path getLexHeaderOutputPath(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createLexBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name + ".h");
  }


  public static CxxHeaderSourceSpec createLexYaccBuildRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      ImmutableList<String> lexFlags,
      ImmutableMap<String, SourcePath> lexSrcs,
      ImmutableList<String> yaccFlags,
      ImmutableMap<String, SourcePath> yaccSrcs) {
    if (!lexSrcs.isEmpty() && !cxxPlatform.getLex().isPresent()) {
      throw new HumanReadableException(
          "Platform %s must support lex to compile srcs %s",
          cxxPlatform,
          lexSrcs);
    }

    if (!yaccSrcs.isEmpty() && !cxxPlatform.getYacc().isPresent()) {
      throw new HumanReadableException(
          "Platform %s must support yacc to compile srcs %s",
          cxxPlatform,
          yaccSrcs);
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableMap.Builder<String, CxxSource> lexYaccCxxSourcesBuilder = ImmutableMap.builder();
    ImmutableMap.Builder<Path, SourcePath> lexYaccHeadersBuilder = ImmutableMap.builder();



    for (ImmutableMap.Entry<String, SourcePath> ent : lexSrcs.entrySet()) {
      final String name = ent.getKey();
      final SourcePath source = ent.getValue();

      BuildTarget target = createLexBuildTarget(params.getBuildTarget(), name);
      Path outputSource = getLexSourceOutputPath(target, name);
      Path outputHeader = getLexHeaderOutputPath(target, name);


      Lex lex = new Lex(
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(
                  ImmutableSortedSet.copyOf(
                      pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),
              Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
          pathResolver,
          cxxPlatform.getLex().get(),
          ImmutableList.<String>builder()
              .addAll(cxxPlatform.getLexFlags())
              .addAll(lexFlags)
              .build(),
          outputSource,
          outputHeader,
          source);
      resolver.addToIndex(lex);


      lexYaccCxxSourcesBuilder.put(
          name + ".cc",
          CxxSource.of(
              CxxSource.Type.CXX,
              new BuildTargetSourcePath(
                  lex.getProjectFilesystem(),
                  lex.getBuildTarget(),
                  outputSource),
              ImmutableList.<String>of()));
      lexYaccHeadersBuilder.put(
          params.getBuildTarget().getBasePath().resolve(name + ".h"),
          new BuildTargetSourcePath(
              lex.getProjectFilesystem(),
              lex.getBuildTarget(),
              outputHeader));
    }



    for (ImmutableMap.Entry<String, SourcePath> ent : yaccSrcs.entrySet()) {
      final String name = ent.getKey();
      final SourcePath source = ent.getValue();

      BuildTarget target = createYaccBuildTarget(params.getBuildTarget(), name);
      Path outputPrefix = getYaccOutputPrefix(target, Files.getNameWithoutExtension(name));


      Yacc yacc = new Yacc(
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(
                  ImmutableSortedSet.copyOf(
                      pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),
              Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
          pathResolver,
          cxxPlatform.getYacc().get(),
          ImmutableList.<String>builder()
              .addAll(cxxPlatform.getYaccFlags())
              .addAll(yaccFlags)
              .build(),
          outputPrefix,
          source);
      resolver.addToIndex(yacc);


      lexYaccCxxSourcesBuilder.put(
          name + ".cc",
          CxxSource.of(
              CxxSource.Type.CXX,
              new BuildTargetSourcePath(
                  yacc.getProjectFilesystem(),
                  yacc.getBuildTarget(),
                  Yacc.getSourceOutputPath(outputPrefix)),
              ImmutableList.<String>of()));

      lexYaccHeadersBuilder.put(
          params.getBuildTarget().getBasePath().resolve(name + ".h"),
          new BuildTargetSourcePath(
              yacc.getProjectFilesystem(),
              yacc.getBuildTarget(),
              Yacc.getHeaderOutputPath(outputPrefix)));
    }

    return CxxHeaderSourceSpec.of(
        lexYaccHeadersBuilder.build(),
        lexYaccCxxSourcesBuilder.build());
  }

  public static CxxPreprocessorInput combineCxxPreprocessorInput(
      BuildRuleParams params,
      CxxPlatform cxxPlatform,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableList<SymlinkTree> headerSymlinkTrees,
      ImmutableList<Path> frameworkSearchPaths,
      Iterable<CxxPreprocessorInput> cxxPreprocessorInputFromDeps) {


    BuildTarget targetWithoutFlavor = BuildTarget.of(
        params.getBuildTarget().getUnflavoredBuildTarget());
    ImmutableList.Builder<CxxPreprocessorInput> cxxPreprocessorInputFromTestedRulesBuilder =
        ImmutableList.builder();
    for (BuildRule rule : params.getDeps()) {
      if (rule instanceof NativeTestable) {
        NativeTestable testable = (NativeTestable) rule;
        if (testable.isTestedBy(targetWithoutFlavor)) {
          LOG.debug(
              "Adding private includes of tested rule %s to testing rule %s",
              rule.getBuildTarget(),
              params.getBuildTarget());
          cxxPreprocessorInputFromTestedRulesBuilder.add(
              testable.getCxxPreprocessorInput(
                  cxxPlatform,
                  HeaderVisibility.PRIVATE));
        }
      }
    }

    ImmutableList<CxxPreprocessorInput> cxxPreprocessorInputFromTestedRules =
        cxxPreprocessorInputFromTestedRulesBuilder.build();
    LOG.verbose(
        "Rules tested by target %s added private includes %s",
        params.getBuildTarget(),
        cxxPreprocessorInputFromTestedRules);

    ImmutableMap.Builder<Path, SourcePath> allLinks = ImmutableMap.builder();
    ImmutableMap.Builder<Path, SourcePath> allFullLinks = ImmutableMap.builder();
    ImmutableList.Builder<Path> allIncludeRoots = ImmutableList.builder();
    for (SymlinkTree headerSymlinkTree : headerSymlinkTrees) {
      allLinks.putAll(headerSymlinkTree.getLinks());
      allFullLinks.putAll(headerSymlinkTree.getFullLinks());
      allIncludeRoots.add(headerSymlinkTree.getRoot());
    }

    CxxPreprocessorInput localPreprocessorInput =
        CxxPreprocessorInput.builder()
            .addAllRules(Iterables.transform(headerSymlinkTrees, HasBuildTarget.TO_TARGET))
            .putAllPreprocessorFlags(preprocessorFlags)
            .setIncludes(
                CxxHeaders.builder()
                    .addAllPrefixHeaders(prefixHeaders)
                    .putAllNameToPathMap(allLinks.build())
                    .putAllFullNameToPathMap(allFullLinks.build())
                    .build())
            .addAllIncludeRoots(allIncludeRoots.build())
            .addAllFrameworkRoots(frameworkSearchPaths)
            .build();

    try {
      return CxxPreprocessorInput.concat(
          Iterables.concat(
              Collections.singleton(localPreprocessorInput),
              cxxPreprocessorInputFromDeps,
              cxxPreprocessorInputFromTestedRules));
    } catch (CxxPreprocessorInput.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
    }
  }

  public static BuildTarget createStaticLibraryBuildTarget(
      BuildTarget target,
      Flavor platform,
      CxxSourceRuleFactory.PicType pic) {
    return BuildTarget.builder(target)
        .addFlavors(platform)
        .addFlavors(pic == CxxSourceRuleFactory.PicType.PDC ? STATIC_FLAVOR : STATIC_PIC_FLAVOR)
        .build();
  }

  public static BuildTarget createSharedLibraryBuildTarget(
      BuildTarget target,
      Flavor platform) {
    return BuildTarget.builder(target).addFlavors(platform).addFlavors(SHARED_FLAVOR).build();
  }

  public static Path getStaticLibraryPath(
      BuildTarget target,
      Flavor platform,
      CxxSourceRuleFactory.PicType pic) {
    String name = String.format("lib%s.a", target.getShortName());
    return BuildTargets.getGenPath(createStaticLibraryBuildTarget(target, platform, pic), "%s")
        .resolve(name);
  }

  public static String getDefaultSharedLibrarySoname(BuildTarget target, CxxPlatform platform) {
    String libName =
        Joiner.on('_').join(
            ImmutableList.builder()
                .addAll(
                    FluentIterable.from(target.getBasePath())
                        .transform(Functions.toStringFunction())
                        .filter(Predicates.not(Predicates.equalTo(""))))
                .add(
                    target
                        .withoutFlavors(ImmutableSet.of(platform.getFlavor()))
                        .getShortNameAndFlavorPostfix())
                .build());
    String extension = platform.getSharedLibraryExtension();
    return String.format("lib%s.%s", libName, extension);
  }

  public static Path getSharedLibraryPath(
      BuildTarget target,
      String soname,
      CxxPlatform platform) {
    return BuildTargets.getGenPath(
        createSharedLibraryBuildTarget(target, platform.getFlavor()),
        "%s/" + soname);
  }

  @VisibleForTesting
  protected static Path getOutputPath(BuildTarget target) {
    return BuildTargets.getGenPath(target, "%s/" + target.getShortNameAndFlavorPostfix());
  }

  @VisibleForTesting
  protected static BuildTarget createCxxLinkTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(CXX_LINK_BINARY_FLAVOR).build();
  }

  static class CxxLinkAndCompileRules {
    final CxxLink cxxLink;
    final ImmutableSortedSet<CxxPreprocessAndCompile> compileRules;
    CxxLinkAndCompileRules(
        CxxLink cxxLink,
        ImmutableSortedSet<CxxPreprocessAndCompile> compileRules) {
      this.cxxLink = cxxLink;
      this.compileRules = compileRules;
    }
  }

  public static CxxLinkAndCompileRules createBuildRulesForCxxBinaryDescriptionArg(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      CxxBinaryDescription.Arg args,
      CxxPreprocessMode preprocessMode) {

    ImmutableMap<String, CxxSource> srcs = parseCxxSources(params, resolver, args);
    ImmutableMap<Path, SourcePath> headers = parseHeaders(params, resolver, args);
    ImmutableMap<String, SourcePath> lexSrcs = parseLexSources(params, resolver, args);
    ImmutableMap<String, SourcePath> yaccSrcs = parseYaccSources(params, resolver, args);

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);


    CxxHeaderSourceSpec lexYaccSources =
        requireLexYaccSources(
            params,
            resolver,
            sourcePathResolver,
            cxxPlatform,
            lexSrcs,
            yaccSrcs);



    SymlinkTree headerSymlinkTree = requireHeaderSymlinkTree(
        params,
        resolver,
        sourcePathResolver,
        cxxPlatform,
 true,
        lexSrcs,
        yaccSrcs,
        headers,
        HeaderVisibility.PRIVATE);
    CxxPreprocessorInput cxxPreprocessorInput =
        combineCxxPreprocessorInput(
            params,
            cxxPlatform,
            CxxFlags.getLanguageFlags(
                args.preprocessorFlags,
                args.platformPreprocessorFlags,
                args.langPreprocessorFlags,
                cxxPlatform.getFlavor()),
            args.prefixHeaders.get(),
            ImmutableList.of(headerSymlinkTree),
            args.frameworkSearchPaths.get(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                FluentIterable.from(params.getDeps())
                    .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));


    ImmutableMap<String, CxxSource> sources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(srcs)
            .putAll(lexYaccSources.getCxxSources())
            .build();



    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects =
        CxxSourceRuleFactory.requirePreprocessAndCompileRules(
            params,
            resolver,
            sourcePathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            CxxFlags.getFlags(
                args.compilerFlags,
                args.platformCompilerFlags,
                cxxPlatform.getFlavor()),
            preprocessMode,
            sources,
            CxxSourceRuleFactory.PicType.PDC);



    Path output = getOutputPath(params.getBuildTarget());
    CxxLink cxxLink = CxxLinkableEnhancer.createCxxLinkableBuildRule(
        cxxPlatform,
        params,
        sourcePathResolver,
 ImmutableList.<String>of(),
 CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()),
        createCxxLinkTarget(params.getBuildTarget()),
        Linker.LinkType.EXECUTABLE,
        Optional.<String>absent(),
        output,
        objects.values(),
        (args.linkStyle.or(CxxBinaryDescription.LinkStyle.STATIC) ==
            CxxBinaryDescription.LinkStyle.STATIC)
        ? Linker.LinkableDepType.STATIC
        : Linker.LinkableDepType.SHARED,
        params.getDeps(),
        args.cxxRuntimeType,
        Optional.<SourcePath>absent());
    resolver.addToIndex(cxxLink);

    return new CxxLinkAndCompileRules(cxxLink, ImmutableSortedSet.copyOf(objects.keySet()));
  }

  private static <T> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      TargetNode<T> node,
      Flavor... flavors) {
    BuildTarget target = BuildTarget.builder(params.getBuildTarget()).addFlavors(flavors).build();
    Description<T> description = node.getDescription();
    T args = node.getConstructorArg();
    return description.createBuildRule(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        ruleResolver,
        args);
  }


  public static BuildRule requireBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      Flavor... flavors) {
    BuildTarget target = BuildTarget.builder(params.getBuildTarget()).addFlavors(flavors).build();
    Optional<BuildRule> rule = ruleResolver.getRuleOptional(target);
    if (!rule.isPresent()) {
      TargetNode<?> node = params.getTargetGraph().get(params.getBuildTarget());
      Preconditions.checkNotNull(
          node,
          String.format("%s not in target graph", params.getBuildTarget()));
      rule = Optional.of(createBuildRule(params, ruleResolver, node, flavors));
      ruleResolver.addToIndex(rule.get());
    }
    return rule.get();
  }


  public static Function<String, String> createErrorMessagePathProcessor(
      final Function<String, String> pathProcessor) {
    return new Function<String, String>() {

      private final ImmutableList<Pattern> patterns =
          ImmutableList.of(
              Pattern.compile(
                  "(?<=^(?:In file included |\\s+)from )" +
                  "(?<path>[^:]+)" +
                  "(?=[:,](?:\\d+[:,](?:\\d+[:,])?)?$)"),
              Pattern.compile(
                  "^(?<path>[^:]+)(?=:(?:\\d+:(?:\\d+:)?)? )"));

      @Override
      public String apply(String line) {
        for (Pattern pattern : patterns) {
          Matcher m = pattern.matcher(line);
          if (m.find()) {
            return m.replaceAll(pathProcessor.apply(m.group("path")));
          }
        }
        return line;
      }

    };
  }

  public static ImmutableList<String> getPlatformFlags(
      ImmutableList<Pair<String, ImmutableList<String>>> platformFlags,
      String platform) {

    ImmutableList.Builder<String> platformFlagsBuilder = ImmutableList.builder();

    for (Pair<String, ImmutableList<String>> pair : platformFlags) {
      Pattern pattern = Pattern.compile(pair.getFirst());
      Matcher matcher = pattern.matcher(platform);
      if (matcher.find()) {
        platformFlagsBuilder.addAll(pair.getSecond());
        break;
      }
    }

    return platformFlagsBuilder.build();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.graph.AbstractBreadthFirstTraversal;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Map;

public class CxxPreprocessables {

  private CxxPreprocessables() {}


  public static ImmutableMap<Path, SourcePath> resolveHeaderMap(
      Path basePath,
      ImmutableMap<String, SourcePath> headers) {

    ImmutableMap.Builder<Path, SourcePath> headerMap = ImmutableMap.builder();



    for (ImmutableMap.Entry<String, SourcePath> ent : headers.entrySet()) {
      Path path = basePath.resolve(ent.getKey());
      headerMap.put(path, ent.getValue());
    }

    return headerMap.build();
  }


  public static Collection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      final CxxPlatform cxxPlatform,
      Iterable<? extends BuildRule> inputs,
      final Predicate<Object> traverse) {




    final Map<BuildTarget, CxxPreprocessorInput> deps = Maps.newLinkedHashMap();


    AbstractBreadthFirstTraversal<BuildRule> visitor =
        new AbstractBreadthFirstTraversal<BuildRule>(inputs) {
          @Override
          public ImmutableSet<BuildRule> visit(BuildRule rule) {
            if (rule instanceof CxxPreprocessorDep) {
              CxxPreprocessorDep dep = (CxxPreprocessorDep) rule;
              deps.putAll(
                  dep.getTransitiveCxxPreprocessorInput(cxxPlatform, HeaderVisibility.PUBLIC));
              return ImmutableSet.of();
            }
            return traverse.apply(rule) ? rule.getDeps() : ImmutableSet.<BuildRule>of();
          }
        };
    visitor.start();


    return deps.values();
  }

  public static Collection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      final CxxPlatform cxxPlatform,
      Iterable<? extends BuildRule> inputs) {
    return getTransitiveCxxPreprocessorInput(
        cxxPlatform,
        inputs,
        Predicates.alwaysTrue());
  }


  public static SymlinkTree createHeaderSymlinkTreeBuildRule(
      SourcePathResolver resolver,
      BuildTarget target,
      BuildRuleParams params,
      Path root,
      ImmutableMap<Path, SourcePath> links) {

    return new SymlinkTree(
        params.copyWithChanges(
            target,

            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        resolver,
        root,
        links);
  }


  public static CxxPreprocessorInput getCxxPreprocessorInput(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      Flavor flavor,
      HeaderVisibility headerVisibility,
      Multimap<CxxSource.Type, String> exportedPreprocessorFlags,
      Iterable<Path> frameworkSearchPaths) {
    BuildRule rule = CxxDescriptionEnhancer.requireBuildRule(
        params,
        ruleResolver,
        flavor,
        CxxDescriptionEnhancer.getHeaderSymlinkTreeFlavor(headerVisibility));
    Preconditions.checkState(rule instanceof SymlinkTree);
    SymlinkTree symlinkTree = (SymlinkTree) rule;
    return CxxPreprocessorInput.builder()
        .addRules(symlinkTree.getBuildTarget())
        .putAllPreprocessorFlags(exportedPreprocessorFlags)
        .setIncludes(
            CxxHeaders.builder()
                .putAllNameToPathMap(symlinkTree.getLinks())
                .putAllFullNameToPathMap(symlinkTree.getFullLinks())
                .build())
        .addIncludeRoots(symlinkTree.getRoot())
        .addAllFrameworkRoots(frameworkSearchPaths)
        .build();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

public class CxxSourceRuleFactory {

  private static final Logger LOG = Logger.get(CxxSourceRuleFactory.class);
  private static final String COMPILE_FLAVOR_PREFIX = "compile-";
  private static final String PREPROCESS_FLAVOR_PREFIX = "preprocess-";

  private final BuildRuleParams params;
  private final BuildRuleResolver resolver;
  private final SourcePathResolver pathResolver;
  private final CxxPlatform cxxPlatform;
  private final CxxPreprocessorInput cxxPreprocessorInput;
  private final ImmutableList<String> compilerFlags;

  private final Supplier<ImmutableList<BuildRule>> preprocessDeps = Suppliers.memoize(
      new Supplier<ImmutableList<BuildRule>>() {
        @Override
        public ImmutableList<BuildRule> get() {
          return ImmutableList.<BuildRule>builder()

              .addAll(
                  pathResolver.filterBuildRuleInputs(
                      ImmutableList.<SourcePath>builder()
                          .addAll(cxxPreprocessorInput.getIncludes().getPrefixHeaders())
                          .addAll(cxxPreprocessorInput.getIncludes().getNameToPathMap().values())
                          .build()))


              .addAll(
                  BuildRules.toBuildRulesFor(
                      params.getBuildTarget(),
                      resolver,
                      cxxPreprocessorInput.getRules()))
              .build();
        }
      });

  @VisibleForTesting
  public CxxSourceRuleFactory(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      CxxPreprocessorInput cxxPreprocessorInput,
      ImmutableList<String> compilerFlags) {
    this.params = params;
    this.resolver = resolver;
    this.pathResolver = pathResolver;
    this.cxxPlatform = cxxPlatform;
    this.cxxPreprocessorInput = cxxPreprocessorInput;
    this.compilerFlags = compilerFlags;
  }


  private Iterable<String> iXassembler(Iterable<String> args) {
    return MoreIterables.zipAndConcat(
        Iterables.cycle("-Xassembler"),
        args);
  }

  private ImmutableList<String> getPreprocessFlags(CxxSource.Type type) {
    return ImmutableList.<String>builder()
        .addAll(CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, type))
        .addAll(cxxPreprocessorInput.getPreprocessorFlags().get(type))
        .build();
  }


  private String getPreprocessOutputName(CxxSource.Type type, String name) {
    CxxSource.Type outputType = CxxSourceTypes.getPreprocessorOutputType(type);
    return name + "." + Iterables.get(outputType.getExtensions(), 0);
  }


  @VisibleForTesting
  public BuildTarget createPreprocessBuildTarget(
      String name,
      CxxSource.Type type,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getPreprocessOutputName(type, name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    PREPROCESS_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isPreprocessFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(PREPROCESS_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }


  @VisibleForTesting
  Path getPreprocessOutputPath(BuildTarget target, CxxSource.Type type, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getPreprocessOutputName(type, name));
  }

  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Tool tool = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());


    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> args =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(getPreprocessFlags(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocess(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        args,
        getPreprocessOutputPath(target, source.getType(), name),
        source.getPath(),
        source.getType(),
        ImmutableList.copyOf(cxxPreprocessorInput.getIncludeRoots()),
        ImmutableList.copyOf(cxxPreprocessorInput.getSystemIncludeRoots()),
        ImmutableList.copyOf(cxxPreprocessorInput.getFrameworkRoots()),
        cxxPreprocessorInput.getIncludes(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessBuildRule(resolver, name, source, pic);
  }


  private String getCompileOutputName(String name) {
    return name + ".o";
  }


  @VisibleForTesting
  Path getCompileOutputPath(BuildTarget target, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getCompileOutputName(name));
  }


  @VisibleForTesting
  public BuildTarget createCompileBuildTarget(
      String name,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getCompileOutputName(name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    COMPILE_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isCompileFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(COMPILE_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }



  private Tool getCompiler(CxxSource.Type type) {
    return CxxSourceTypes.needsCxxCompiler(type) ?
      cxxPlatform.getCxx() :
      cxxPlatform.getCc();
  }

  private ImmutableList<String> getCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCflags());
    }



    if (type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCxxflags());
    }


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT ||
        type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(compilerFlags);
    }


    args.addAll(iXassembler(cxxPlatform.getAsflags()));

    return args.build();
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isCompilableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Tool tool = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))
            .build();


    ImmutableList<String> args =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(getCompileFlags(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.compile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        args,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requireCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createCompileBuildRule(resolver, name, source, pic);
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Tool tool = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> compilerFlags = ImmutableList.<String>builder()

        .addAll(pic.getFlags())

        .addAll(getCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

        .addAll(source.getFlags())
        .build();

    LOG.verbose("Creating preprocess and compile %s for %s", target, source);


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocessAndCompile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        getPreprocessFlags(source.getType()),
        tool,
        compilerFlags,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        ImmutableList.copyOf(cxxPreprocessorInput.getIncludeRoots()),
        ImmutableList.copyOf(cxxPreprocessorInput.getSystemIncludeRoots()),
        ImmutableList.copyOf(cxxPreprocessorInput.getFrameworkRoots()),
        cxxPreprocessorInput.getIncludes(), cxxPlatform.getDebugPathSanitizer(), strategy);
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
  }

  private ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleResolver resolver,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {

    ImmutableList.Builder<CxxPreprocessAndCompile> objects = ImmutableList.builder();

    for (Map.Entry<String, CxxSource> entry : sources.entrySet()) {
      String name = entry.getKey();
      CxxSource source = entry.getValue();

      Preconditions.checkState(
          CxxSourceTypes.isPreprocessableType(source.getType()) ||
              CxxSourceTypes.isCompilableType(source.getType()));

      switch (strategy) {

        case PIPED:
        case COMBINED: {
          CxxPreprocessAndCompile rule;



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            rule = requirePreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
          } else {
            rule = requireCompileBuildRule(resolver, name, source, pic);
          }

          objects.add(rule);
          break;
        }

        case SEPARATE: {



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            CxxPreprocessAndCompile rule = requirePreprocessBuildRule(resolver, name, source, pic);
            source = CxxSource.copyOf(source)
                .withType(CxxSourceTypes.getPreprocessorOutputType(source.getType()))
                .withPath(
                    new BuildTargetSourcePath(
                        params.getProjectFilesystem(),
                        rule.getBuildTarget()));
          }


          CxxPreprocessAndCompile rule = requireCompileBuildRule(resolver, name, source, pic);
          objects.add(rule);

          break;
        }


        default:
          throw new IllegalStateException();
      }
    }

    final ProjectFilesystem projectFilesystem = params.getProjectFilesystem();
    return FluentIterable
        .from(objects.build())
        .toMap(new Function<CxxPreprocessAndCompile, SourcePath>() {
          @Override
          public SourcePath apply(CxxPreprocessAndCompile input) {
            return new BuildTargetSourcePath(projectFilesystem, input.getBuildTarget());
          }
        });
  }

  public static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      CxxPreprocessorInput cxxPreprocessorInput,
      ImmutableList<String> compilerFlags,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {
    CxxSourceRuleFactory factory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            compilerFlags);
    return factory.requirePreprocessAndCompileRules(resolver, strategy, sources, pic);
  }

  public enum PicType {


    PIC("-fPIC"),


    PDC;

    private final ImmutableList<String> flags;

    PicType(String... flags) {
      this.flags = ImmutableList.copyOf(flags);
    }

    public ImmutableList<String> getFlags() {
      return flags;
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Multimap;

import org.immutables.value.Value;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


@Value.Immutable
@BuckStyleImmutable
abstract class AbstractCxxPreprocessorInput {


  @Value.Parameter
  public abstract Set<BuildTarget> getRules();

  @Value.Parameter
  public abstract Multimap<CxxSource.Type, String> getPreprocessorFlags();

  @Value.Parameter
  @Value.Default
  public CxxHeaders getIncludes() {
    return CxxHeaders.builder().build();
  }


  @Value.Parameter
  public abstract List<Path> getIncludeRoots();


  @Value.Parameter
  public abstract List<Path> getSystemIncludeRoots();


  @Value.Parameter
  public abstract List<Path> getFrameworkRoots();

  public static final CxxPreprocessorInput EMPTY = CxxPreprocessorInput.builder().build();

  public static CxxPreprocessorInput.Builder builder() {
    return CxxPreprocessorInput.builder();
  }

  private static void addAllEntriesToIncludeMap(
      Map<Path, SourcePath> destination,
      Map<Path, SourcePath> source) throws ConflictingHeadersException {
    for (Map.Entry<Path, SourcePath> entry : source.entrySet()) {
      SourcePath original = destination.put(entry.getKey(), entry.getValue());
      if (original != null && !original.equals(entry.getValue())) {
        throw new ConflictingHeadersException(entry.getKey(), original, entry.getValue());
      }
    }
  }

  public static CxxPreprocessorInput concat(Iterable<CxxPreprocessorInput> inputs)
      throws ConflictingHeadersException {
    ImmutableSet.Builder<BuildTarget> rules = ImmutableSet.builder();
    ImmutableMultimap.Builder<CxxSource.Type, String> preprocessorFlags =
      ImmutableMultimap.builder();
    ImmutableList.Builder<SourcePath> prefixHeaders = ImmutableList.builder();
    Map<Path, SourcePath> includeNameToPathMap = new HashMap<>();
    Map<Path, SourcePath> includeFullNameToPathMap = new HashMap<>();
    ImmutableList.Builder<Path> includeRoots = ImmutableList.builder();
    ImmutableList.Builder<Path> systemIncludeRoots = ImmutableList.builder();
    ImmutableList.Builder<Path> frameworkRoots = ImmutableList.builder();

    for (CxxPreprocessorInput input : inputs) {
      rules.addAll(input.getRules());
      preprocessorFlags.putAll(input.getPreprocessorFlags());
      prefixHeaders.addAll(input.getIncludes().getPrefixHeaders());
      addAllEntriesToIncludeMap(
          includeNameToPathMap,
          input.getIncludes().getNameToPathMap());
      addAllEntriesToIncludeMap(
          includeFullNameToPathMap,
          input.getIncludes().getFullNameToPathMap());
      includeRoots.addAll(input.getIncludeRoots());
      systemIncludeRoots.addAll(input.getSystemIncludeRoots());
      frameworkRoots.addAll(input.getFrameworkRoots());
    }

    return CxxPreprocessorInput.of(
        rules.build(),
        preprocessorFlags.build(),
        CxxHeaders.builder()
            .addAllPrefixHeaders(prefixHeaders.build())
            .putAllNameToPathMap(includeNameToPathMap)
            .putAllFullNameToPathMap(includeFullNameToPathMap)
            .build(),
        includeRoots.build(),
        systemIncludeRoots.build(),
        frameworkRoots.build());
  }

  @SuppressWarnings("serial")
  public static class ConflictingHeadersException extends Exception {
    public ConflictingHeadersException(Path key, SourcePath value1, SourcePath value2) {
      super(
          String.format(
              "'%s' maps to both %s.",
              key,
              ImmutableSortedSet.of(value1, value2)));
    }

    public HumanReadableException getHumanReadableExceptionForBuildTarget(BuildTarget buildTarget) {
      return new HumanReadableException(
          this,
          "Target '%s' uses conflicting header file mappings. %s",
          buildTarget,
          getMessage());
    }
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;


public class CxxPreprocessAndCompile extends AbstractBuildRule implements RuleKeyAppendable {

  @AddToRuleKey
  private final CxxPreprocessAndCompileStep.Operation operation;
  @AddToRuleKey
  private final Optional<Tool> preprocessor;
  private final Optional<ImmutableList<String>> preprocessorFlags;
  @AddToRuleKey
  private final Optional<Tool> compiler;
  private final Optional<ImmutableList<String>> compilerFlags;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @AddToRuleKey
  private final SourcePath input;
  private final CxxSource.Type inputType;
  private final ImmutableList<Path> includeRoots;
  private final ImmutableList<Path> systemIncludeRoots;
  private final ImmutableList<Path> frameworkRoots;
  @AddToRuleKey
  private final CxxHeaders includes;
  private final DebugPathSanitizer sanitizer;

  @VisibleForTesting
  CxxPreprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      CxxPreprocessAndCompileStep.Operation operation,
      Optional<Tool> preprocessor,
      Optional<ImmutableList<String>> preprocessorFlags,
      Optional<Tool> compiler,
      Optional<ImmutableList<String>> compilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      CxxHeaders includes,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    Preconditions.checkState(operation.isPreprocess() == preprocessor.isPresent());
    Preconditions.checkState(operation.isPreprocess() == preprocessorFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == compiler.isPresent());
    Preconditions.checkState(operation.isCompile() == compilerFlags.isPresent());
    this.operation = operation;
    this.preprocessor = preprocessor;
    this.preprocessorFlags = preprocessorFlags;
    this.compiler = compiler;
    this.compilerFlags = compilerFlags;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.includeRoots = includeRoots;
    this.systemIncludeRoots = systemIncludeRoots;
    this.frameworkRoots = frameworkRoots;
    this.includes = includes;
    this.sanitizer = sanitizer;
  }


  public static CxxPreprocessAndCompile compile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool compiler,
      ImmutableList<String> flags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(compiler),
        Optional.of(flags),
        output,
        input,
        inputType,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        CxxHeaders.builder().build(),
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocess(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool preprocessor,
      ImmutableList<String> flags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      CxxHeaders includes,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(preprocessor),
        Optional.of(flags),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool preprocessor,
      ImmutableList<String> preprocessorFlags,
      Tool compiler,
      ImmutableList<String> compilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      CxxHeaders includes,
      DebugPathSanitizer sanitizer,
      CxxPreprocessMode strategy) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        (strategy == CxxPreprocessMode.PIPED
            ? CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE
            : CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO),
        Optional.of(preprocessor),
        Optional.of(preprocessorFlags),
        Optional.of(compiler),
        Optional.of(compilerFlags),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        (strategy == CxxPreprocessMode.COMBINED
            ? sanitizer
            : sanitizer.changePathSize(0)));
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {


    ImmutableList<String> flags = ImmutableList.<String>builder()
        .addAll(this.preprocessorFlags.or(ImmutableList.<String>of()))
        .addAll(this.compilerFlags.or(ImmutableList.<String>of()))
        .build();
    flags = FluentIterable.from(flags)
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
    builder.setReflectively("flags", flags);
    ImmutableList<String> frameworkRoots = FluentIterable.from(this.frameworkRoots)
        .transform(Functions.toStringFunction())
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
    builder.setReflectively("frameworkRoots", frameworkRoots);



    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      builder.setReflectively("compilationDirectory", sanitizer.getCompilationDirectory());
    }

    return builder;
  }

  @VisibleForTesting
  CxxPreprocessAndCompileStep makeMainStep() {



    ImmutableMap.Builder<Path, Path> replacementPathsBuilder = ImmutableMap.builder();
    for (Map.Entry<Path, SourcePath> entry : includes.getFullNameToPathMap().entrySet()) {
      replacementPathsBuilder.put(entry.getKey(), getResolver().getPath(entry.getValue()));
    }
    ImmutableMap<Path, Path> replacementPaths = replacementPathsBuilder.build();

    Optional<ImmutableList<String>> preprocessorCommand;
    if (preprocessor.isPresent()) {
      preprocessorCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(preprocessor.get().getCommandPrefix(getResolver()))
              .addAll(getPreprocessorSuffix())
              .build());
    } else {
      preprocessorCommand = Optional.absent();
    }

    Optional<ImmutableList<String>> compilerCommand;
    if (compiler.isPresent()) {
      compilerCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(compiler.get().getCommandPrefix(getResolver()))
              .addAll(getCompilerSuffix())
              .build());
    } else {
      compilerCommand = Optional.absent();
    }

    return new CxxPreprocessAndCompileStep(
        operation,
        output,
        getResolver().getPath(input),
        inputType,
        preprocessorCommand,
        compilerCommand,
        replacementPaths,
        sanitizer);
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        makeMainStep());
  }

  private ImmutableList<String> getPreprocessorSuffix() {
    Preconditions.checkState(operation.isPreprocess());
    return ImmutableList.<String>builder()
        .addAll(preprocessorFlags.get())
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-include"),
                FluentIterable.from(includes.getPrefixHeaders())
                    .transform(getResolver().getPathFunction())
                    .transform(Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-I"),
                Iterables.transform(includeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-isystem"),
                Iterables.transform(systemIncludeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-F"),
                Iterables.transform(frameworkRoots, Functions.toStringFunction())))
        .build();
  }

  private ImmutableList<String> getCompilerSuffix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> suffix = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      suffix.addAll(getPreprocessorSuffix());
    }
    suffix.addAll(compilerFlags.get());
    return suffix.build();
  }

  public ImmutableList<String> getCompileCommandCombinedWithPreprocessBuildRule(
      CxxPreprocessAndCompile preprocessBuildRule) {
    if (!operation.isCompile() ||
        !preprocessBuildRule.operation.isPreprocess()) {
      throw new HumanReadableException(
          "%s is not preprocess rule or %s is not compile rule.",
          preprocessBuildRule,
          this);
    }
    ImmutableList.Builder<String> cmd = ImmutableList.builder();
    cmd.addAll(compiler.get().getCommandPrefix(getResolver()));
    cmd.add("-x", preprocessBuildRule.inputType.getLanguage());
    cmd.add("-c");
    cmd.addAll(preprocessBuildRule.getPreprocessorSuffix());
    cmd.addAll(getCompilerSuffix());
    cmd.add("-o", output.toString());
    cmd.add(getResolver().getPath(preprocessBuildRule.input).toString());
    return cmd.build();
  }

  public ImmutableList<String> getCommand() {
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      return makeMainStep().getCommand();
    }
    return getCompileCommandCombinedWithPreprocessBuildRule(this);
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPreprocessorFlags() {
    return preprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getCompilerFlags() {
    return compilerFlags;
  }

  public Path getOutput() {
    return output;
  }

  public SourcePath getInput() {
    return input;
  }

  public CxxHeaders getIncludes() {
    return includes;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.collect.ImmutableSortedSet;

import org.immutables.value.Value;

import java.nio.file.Path;
import java.util.List;
import java.util.Map;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractCxxHeaders implements RuleKeyAppendable {


  abstract List<SourcePath> getPrefixHeaders();


  abstract Map<Path, SourcePath> getNameToPathMap();


  abstract Map<Path, SourcePath> getFullNameToPathMap();

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    builder.setReflectively("prefixHeaders", getPrefixHeaders());

    for (Path path : ImmutableSortedSet.copyOf(getNameToPathMap().keySet())) {
      SourcePath source = getNameToPathMap().get(path);
      builder.setReflectively("include(" + path + ")", source);
    }

    return builder;
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.python.PythonPackageComponents;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class PrebuiltCxxLibrary extends AbstractCxxLibrary {

  private final BuildRuleParams params;
  private final BuildRuleResolver ruleResolver;
  private final SourcePathResolver pathResolver;
  private final ImmutableList<Path> includeDirs;
  private final Optional<String> libDir;
  private final Optional<String> libName;
  private final ImmutableList<String> exportedLinkerFlags;
  private final ImmutableList<Pair<String, ImmutableList<String>>> exportedPlatformLinkerFlags;
  private final Optional<String> soname;
  private final boolean headerOnly;
  private final boolean linkWhole;
  private final boolean provided;


  private final Map<Pair<Flavor, HeaderVisibility>, ImmutableMap<BuildTarget, CxxPreprocessorInput>>
      cxxPreprocessorInputCache = Maps.newHashMap();

  public PrebuiltCxxLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      ImmutableList<Path> includeDirs,
      Optional<String> libDir,
      Optional<String> libName,
      ImmutableList<String> exportedLinkerFlags,
      ImmutableList<Pair<String, ImmutableList<String>>> exportedPlatformLinkerFlags,
      Optional<String> soname,
      boolean headerOnly,
      boolean linkWhole,
      boolean provided) {
    super(params, pathResolver);
    this.params = params;
    this.ruleResolver = ruleResolver;
    this.pathResolver = pathResolver;
    this.includeDirs = includeDirs;
    this.libDir = libDir;
    this.libName = libName;
    this.exportedLinkerFlags = exportedLinkerFlags;
    this.exportedPlatformLinkerFlags = exportedPlatformLinkerFlags;
    this.soname = soname;
    this.headerOnly = headerOnly;
    this.linkWhole = linkWhole;
    this.provided = provided;
  }


  private SourcePath requireSharedLibrary(CxxPlatform cxxPlatform) {
    Path sharedLibraryPath =
        PrebuiltCxxLibraryDescription.getSharedLibraryPath(
            getBuildTarget(),
            cxxPlatform,
            libDir,
            libName);


    if (params.getProjectFilesystem().exists(sharedLibraryPath)) {
      return new PathSourcePath(params.getProjectFilesystem(), sharedLibraryPath);
    }


    BuildRule sharedLibrary =
        CxxDescriptionEnhancer.requireBuildRule(
            params,
            ruleResolver,
            cxxPlatform.getFlavor(),
            CxxDescriptionEnhancer.SHARED_FLAVOR);

    return new BuildTargetSourcePath(
        sharedLibrary.getProjectFilesystem(),
        sharedLibrary.getBuildTarget());
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    switch (headerVisibility) {
      case PUBLIC:
        return CxxPreprocessorInput.builder()

            .addAllSystemIncludeRoots(includeDirs)
            .build();
      case PRIVATE:
        return CxxPreprocessorInput.EMPTY;
    }



    throw new RuntimeException("Invalid header visibility: " + headerVisibility);
  }


  @Override
  public ImmutableMap<BuildTarget, CxxPreprocessorInput>
      getTransitiveCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
    Pair<Flavor, HeaderVisibility> key = new Pair<>(cxxPlatform.getFlavor(), headerVisibility);
    ImmutableMap<BuildTarget, CxxPreprocessorInput> result = cxxPreprocessorInputCache.get(key);
    if (result == null) {
      Map<BuildTarget, CxxPreprocessorInput> builder = Maps.newLinkedHashMap();
      builder.put(getBuildTarget(), getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      for (BuildRule dep : getDeps()) {
        if (dep instanceof CxxPreprocessorDep) {
          builder.putAll(
              ((CxxPreprocessorDep) dep).getTransitiveCxxPreprocessorInput(
                  cxxPlatform,
                  headerVisibility));
        }
      }
      result = ImmutableMap.copyOf(builder);
      cxxPreprocessorInputCache.put(key, result);
    }
    return result;
  }

  @Override
  public NativeLinkableInput getNativeLinkableInput(
      CxxPlatform cxxPlatform,
      Linker.LinkableDepType type) {



    ImmutableList.Builder<SourcePath> librariesBuilder = ImmutableList.builder();
    ImmutableList.Builder<String> linkerArgsBuilder = ImmutableList.builder();
    linkerArgsBuilder.addAll(exportedLinkerFlags);
    linkerArgsBuilder.addAll(
        CxxDescriptionEnhancer.getPlatformFlags(
            exportedPlatformLinkerFlags,
            cxxPlatform.getFlavor().toString()));
    if (!headerOnly) {
      if (provided || type == Linker.LinkableDepType.SHARED) {
        SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
        librariesBuilder.add(sharedLibrary);
        linkerArgsBuilder.add(pathResolver.getPath(sharedLibrary).toString());
      } else {
        Path staticLibraryPath =
            PrebuiltCxxLibraryDescription.getStaticLibraryPath(
                getBuildTarget(),
                cxxPlatform,
                libDir,
                libName);
        librariesBuilder.add(new PathSourcePath(getProjectFilesystem(), staticLibraryPath));
        if (linkWhole) {
          Linker linker = cxxPlatform.getLd();
          linkerArgsBuilder.addAll(linker.linkWhole(staticLibraryPath.toString()));
        } else {
          linkerArgsBuilder.add(staticLibraryPath.toString());
        }
      }
    }
    final ImmutableList<SourcePath> libraries = librariesBuilder.build();
    final ImmutableList<String> linkerArgs = linkerArgsBuilder.build();

    return NativeLinkableInput.of( libraries,  linkerArgs);
  }

  @Override
  public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform) {
    return Optional.absent();
  }

  @Override
  public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform) {
    String resolvedSoname =
        PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(), cxxPlatform, soname, libName);


    ImmutableMap.Builder<Path, SourcePath> nativeLibrariesBuilder = ImmutableMap.builder();
    if (!headerOnly && !provided) {
      SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
      nativeLibrariesBuilder.put(
          Paths.get(resolvedSoname),
          sharedLibrary);
    }
    ImmutableMap<Path, SourcePath> nativeLibraries = nativeLibrariesBuilder.build();

    return PythonPackageComponents.of(
 ImmutableMap.<Path, SourcePath>of(),
 ImmutableMap.<Path, SourcePath>of(),
        nativeLibraries,
 ImmutableSet.<SourcePath>of(),
 Optional.<Boolean>absent());
  }

  @Override
  public Iterable<AndroidPackageable> getRequiredPackageables() {
    return AndroidPackageableCollector.getPackageableRules(params.getDeps());
  }

  @Override
  public void addToCollector(AndroidPackageableCollector collector) {
    collector.addNativeLinkable(this);
  }

  @Override
  public ImmutableMap<String, SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) {
    String resolvedSoname =
        PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(), cxxPlatform, soname, libName);
    ImmutableMap.Builder<String, SourcePath> solibs = ImmutableMap.builder();
    if (!headerOnly && !provided) {
      SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
      solibs.put(resolvedSoname, sharedLibrary);
    }
    return solibs.build();
  }

  @Override
  public boolean isTestedBy(BuildTarget buildTarget) {
    return false;
  }
}

<code block>


package com.facebook.buck.android;

import static org.junit.Assert.assertThat;

import com.facebook.buck.cxx.CxxLinkableEnhancer;
import com.facebook.buck.cxx.CxxPreprocessAndCompile;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.CxxSourceRuleFactory;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.io.AlwaysFoundExecutableFinder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.util.environment.Platform;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import org.hamcrest.Matchers;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Map;

public class NdkCxxPlatformTest {

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  enum Operation {
    PREPROCESS,
    COMPILE,
    PREPROCESS_AND_COMPILE,
  }


  private ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey> constructCompileRuleKeys(
      Operation operation,
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    String source = "source.cpp";
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("source.cpp", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxSourceRuleFactory cxxSourceRuleFactory =
          new CxxSourceRuleFactory(
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              resolver,
              pathResolver,
              entry.getValue().getCxxPlatform(),
              CxxPreprocessorInput.EMPTY,
              ImmutableList.<String>of());
      CxxPreprocessAndCompile rule;
      switch (operation) {
        case PREPROCESS_AND_COMPILE:
          rule =
              cxxSourceRuleFactory.createPreprocessAndCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC,
                  CxxPreprocessMode.COMBINED);
          break;
        case PREPROCESS:
          rule =
              cxxSourceRuleFactory.createPreprocessBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        case COMPILE:
          rule =
              cxxSourceRuleFactory.createCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX_CPP_OUTPUT,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        default:
          throw new IllegalStateException();
      }
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }


  private ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey> constructLinkRuleKeys(
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("input.o", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      BuildRule rule =
          CxxLinkableEnhancer.createCxxLinkableBuildRule(
              entry.getValue().getCxxPlatform(),
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              pathResolver,
              ImmutableList.<String>of(),
              ImmutableList.<String>of(),
              target,
              Linker.LinkType.EXECUTABLE,
              Optional.<String>absent(),
              Paths.get("output"),
              ImmutableList.<SourcePath>of(new TestSourcePath("input.o")),
              Linker.LinkableDepType.SHARED,
              ImmutableList.<BuildRule>of(),
              Optional.<Linker.CxxRuntimeType>absent(),
              Optional.<SourcePath>absent());
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }



  @Test
  public void checkRootAndPlatformDoNotAffectRuleKeys() throws IOException {


    ImmutableList<Pair<NdkCxxPlatforms.Compiler.Type, NdkCxxPlatforms.CxxRuntime>> configs =
        ImmutableList.of(
            new Pair<>(NdkCxxPlatforms.Compiler.Type.GCC, NdkCxxPlatforms.CxxRuntime.GNUSTL),
            new Pair<>(NdkCxxPlatforms.Compiler.Type.CLANG, NdkCxxPlatforms.CxxRuntime.GNUSTL),
            new Pair<>(NdkCxxPlatforms.Compiler.Type.CLANG, NdkCxxPlatforms.CxxRuntime.LIBCXX));
    for (Pair<NdkCxxPlatforms.Compiler.Type, NdkCxxPlatforms.CxxRuntime> config : configs) {
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          preprocessAndCompileRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          preprocessRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          compileRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          linkRukeKeys = Maps.newHashMap();



      for (String dir : ImmutableList.of("something", "something else")) {
        for (Platform platform :
            ImmutableList.of(Platform.LINUX, Platform.MACOS, Platform.WINDOWS)) {
          tmp.create();
          Path root = tmp.newFolder(dir).toPath();
          FakeProjectFilesystem filesystem = new FakeProjectFilesystem(root.toFile());
          filesystem.writeContentsToPath("something", Paths.get("RELEASE.TXT"));
          ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> platforms =
              NdkCxxPlatforms.getPlatforms(
                  filesystem,
                  ImmutableNdkCxxPlatforms.Compiler.builder()
                      .setType(config.getFirst())
                      .setVersion("gcc-version")
                      .setGccVersion("clang-version")
                      .build(),
                  NdkCxxPlatforms.CxxRuntime.GNUSTL,
                  "target-app-platform",
                  platform,
                  new AlwaysFoundExecutableFinder());
          preprocessAndCompileRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.PREPROCESS_AND_COMPILE, platforms));
          preprocessRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.PREPROCESS, platforms));
          compileRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.COMPILE, platforms));
          linkRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructLinkRuleKeys(platforms));
          tmp.delete();
        }
      }



      assertThat(
          Arrays.toString(preprocessAndCompileRukeKeys.entrySet().toArray()),
          Sets.newHashSet(preprocessAndCompileRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(preprocessRukeKeys.entrySet().toArray()),
          Sets.newHashSet(preprocessRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(compileRukeKeys.entrySet().toArray()),
          Sets.newHashSet(compileRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(linkRukeKeys.entrySet().toArray()),
          Sets.newHashSet(linkRukeKeys.values()),
          Matchers.hasSize(1));
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxPreprocessablesTest {

  private static final ProjectFilesystem PROJECT_FILESYSTEM = new FakeProjectFilesystem();

  private static class FakeCxxPreprocessorDep extends FakeBuildRule
      implements CxxPreprocessorDep {

    private final CxxPreprocessorInput input;

    public FakeCxxPreprocessorDep(
        BuildRuleParams params,
        SourcePathResolver resolver,
        CxxPreprocessorInput input) {
      super(params, resolver);
      this.input = Preconditions.checkNotNull(input);
    }

    @Override
    public CxxPreprocessorInput getCxxPreprocessorInput(
        CxxPlatform cxxPlatform,
        HeaderVisibility headerVisibility) {
      return input;
    }

    @Override
    public ImmutableMap<BuildTarget, CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
        CxxPlatform cxxPlatform,
        HeaderVisibility headerVisibility) {
      ImmutableMap.Builder<BuildTarget, CxxPreprocessorInput> builder = ImmutableMap.builder();
      builder.put(getBuildTarget(), getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      for (BuildRule dep : getDeps()) {
        if (dep instanceof CxxPreprocessorDep) {
          builder.putAll(
              ((CxxPreprocessorDep) dep).getTransitiveCxxPreprocessorInput(
                  cxxPlatform,
                  headerVisibility));
          }
        }
      return builder.build();
    }

  }

  private static FakeCxxPreprocessorDep createFakeCxxPreprocessorDep(
      BuildTarget target,
      SourcePathResolver resolver,
      CxxPreprocessorInput input,
      BuildRule... deps) {
    return new FakeCxxPreprocessorDep(
        new FakeBuildRuleParamsBuilder(target)
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver, input);
  }

  private static FakeCxxPreprocessorDep createFakeCxxPreprocessorDep(
      String target,
      SourcePathResolver resolver,
      CxxPreprocessorInput input,
      BuildRule... deps) {
    return createFakeCxxPreprocessorDep(
        BuildTargetFactory.newInstance(target),
        resolver,
        input,
        deps);
  }

  private static FakeBuildRule createFakeBuildRule(
      BuildTarget target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(target)
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Rule
  public ExpectedException exception = ExpectedException.none();

  @Test
  public void resolveHeaderMap() {
    BuildTarget target = BuildTargetFactory.newInstance("//hello/world:test");
    ImmutableMap<String, SourcePath> headerMap = ImmutableMap.<String, SourcePath>of(
        "foo/bar.h", new TestSourcePath("header1.h"),
        "foo/hello.h", new TestSourcePath("header2.h"));


    ImmutableMap<Path, SourcePath> expected = ImmutableMap.<Path, SourcePath>of(
        target.getBasePath().resolve("foo/bar.h"), new TestSourcePath("header1.h"),
        target.getBasePath().resolve("foo/hello.h"), new TestSourcePath("header2.h"));
    ImmutableMap<Path, SourcePath> actual = CxxPreprocessables.resolveHeaderMap(
        target.getBasePath(), headerMap);
    assertEquals(expected, actual);
  }

  @Test
  public void getTransitiveCxxPreprocessorInput() throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));


    BuildTarget cppDepTarget1 = BuildTargetFactory.newInstance("//:cpp1");
    CxxPreprocessorInput input1 = CxxPreprocessorInput.builder()
        .addRules(cppDepTarget1)
        .putPreprocessorFlags(CxxSource.Type.C, "-Dtest=yes")
        .putPreprocessorFlags(CxxSource.Type.CXX, "-Dtest=yes")
        .addIncludeRoots(Paths.get("foo/bar"), Paths.get("hello"))
        .addSystemIncludeRoots(Paths.get("/usr/include"))
        .build();
    BuildTarget depTarget1 = BuildTargetFactory.newInstance("//:dep1");
    FakeCxxPreprocessorDep dep1 = createFakeCxxPreprocessorDep(depTarget1, pathResolver, input1);


    BuildTarget cppDepTarget2 = BuildTargetFactory.newInstance("//:cpp2");
    CxxPreprocessorInput input2 = CxxPreprocessorInput.builder()
        .addRules(cppDepTarget2)
        .putPreprocessorFlags(CxxSource.Type.C, "-DBLAH")
        .putPreprocessorFlags(CxxSource.Type.CXX, "-DBLAH")
        .addIncludeRoots(Paths.get("goodbye"))
        .addSystemIncludeRoots(Paths.get("test"))
        .build();
    BuildTarget depTarget2 = BuildTargetFactory.newInstance("//:dep2");
    FakeCxxPreprocessorDep dep2 = createFakeCxxPreprocessorDep(depTarget2, pathResolver, input2);


    BuildTarget depTarget3 = BuildTargetFactory.newInstance("//:dep3");
    CxxPreprocessorInput nothing = CxxPreprocessorInput.EMPTY;
    FakeCxxPreprocessorDep dep3 = createFakeCxxPreprocessorDep(depTarget3,
        pathResolver,
        nothing, dep1, dep2);



    ImmutableList<CxxPreprocessorInput> expected = ImmutableList.of(nothing, input1, input2);
    ImmutableList<CxxPreprocessorInput> actual = ImmutableList.copyOf(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.<BuildRule>of(dep3)));
    assertEquals(expected, actual);
  }

  @Test
  public void createHeaderSymlinkTreeBuildRuleHasNoDeps() {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);


    FakeBuildRule dep = createFakeBuildRule(
        BuildTargetFactory.newInstance("//random:dep"),
        pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = new FakeBuildRuleParamsBuilder(target)
        .setDeps(ImmutableSortedSet.<BuildRule>of(dep))
        .build();
    Path root = Paths.get("root");



    Genrule genrule = (Genrule) GenruleBuilder
        .newGenruleBuilder(BuildTargetFactory.newInstance("//:genrule"))
        .setOut("foo/bar.o")
        .build(resolver);



    ImmutableMap<Path, SourcePath> links = ImmutableMap.<Path, SourcePath>of(
        Paths.get("link1"),
        new TestSourcePath("hello"),
        Paths.get("link2"),
        new BuildTargetSourcePath(PROJECT_FILESYSTEM, genrule.getBuildTarget()));


    SymlinkTree symlinkTree = CxxPreprocessables.createHeaderSymlinkTreeBuildRule(
        pathResolver,
        target,
        params,
        root,
        links);




    assertTrue(symlinkTree.getDeps().isEmpty());
  }

  @Test
  public void getTransitiveNativeLinkableInputDoesNotTraversePastNonNativeLinkables()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));


    String sentinal = "bottom";
    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .putPreprocessorFlags(CxxSource.Type.C, sentinal)
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);



    BuildRule middle = new FakeBuildRule("//:middle", pathResolver, bottom);


    CxxPreprocessorInput topInput = CxxPreprocessorInput.EMPTY;
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, middle);



    CxxPreprocessorInput totalInput = CxxPreprocessorInput.concat(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.of(top)));
    assertTrue(bottomInput.getPreprocessorFlags().get(CxxSource.Type.C).contains(sentinal));
    assertFalse(totalInput.getPreprocessorFlags().get(CxxSource.Type.C).contains(sentinal));
  }

  @Test
  public void combiningTransitiveDependenciesThrowsForConflictingHeaders()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));

    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("bottom/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("bottom/file.h"))
                .build())
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);

    CxxPreprocessorInput topInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("top/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("top/file.h"))
                .build())
        .build();
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, bottom);

    exception.expect(CxxPreprocessorInput.ConflictingHeadersException.class);
    exception.expectMessage(String.format(
            "'%s' maps to both [%s, %s].",
            Paths.get("prefix/file.h"),
            Paths.get("bottom/file.h"),
            Paths.get("top/file.h")));

    CxxPreprocessorInput.concat(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.of(top)));
  }

  @Test
  public void combiningTransitiveDependenciesDoesNotThrowForCompatibleHeaders()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));

    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);

    CxxPreprocessorInput topInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, bottom);

    CxxPreprocessorInput expected = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();

    assertEquals(
        expected,
        CxxPreprocessorInput.concat(
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                ImmutableList.of(top))));
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.python.PythonPackageComponents;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Test;

import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxBinaryDescriptionTest {

  private static FakeBuildRule createFakeBuildRule(
      String target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(BuildTargetFactory.newInstance(target))
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Test
  @SuppressWarnings("PMD.UseAssertTrueInsteadOfAssertEquals")
  public void createBuildRule() {
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem();
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    CxxPlatform cxxPlatform = CxxBinaryBuilder.createDefaultPlatform();


    String genHeaderName = "test/foo.h";
    BuildTarget genHeaderTarget = BuildTargetFactory.newInstance("//:genHeader");
    Genrule genHeader = (Genrule) GenruleBuilder
        .newGenruleBuilder(genHeaderTarget)
        .setOut(genHeaderName)
        .build(resolver);


    String genSourceName = "test/foo.cpp";
    BuildTarget genSourceTarget = BuildTargetFactory.newInstance("//:genSource");
    Genrule genSource = (Genrule) GenruleBuilder
        .newGenruleBuilder(genSourceTarget)
        .setOut(genSourceName)
        .build(resolver);


    final BuildRule header = createFakeBuildRule("//:header", pathResolver);
    final BuildRule headerSymlinkTree = createFakeBuildRule("//:symlink", pathResolver);
    final Path headerSymlinkTreeRoot = Paths.get("symlink/tree/root");
    final BuildRule archive = createFakeBuildRule("//:archive", pathResolver);
    final Path archiveOutput = Paths.get("output/path/lib.a");
    BuildTarget depTarget = BuildTargetFactory.newInstance("//:dep");
    BuildRuleParams depParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
    AbstractCxxLibrary dep = new AbstractCxxLibrary(depParams, pathResolver) {

      @Override
      public CxxPreprocessorInput getCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
        return CxxPreprocessorInput.builder()
            .addRules(
                header.getBuildTarget(),
                headerSymlinkTree.getBuildTarget())
            .addIncludeRoots(headerSymlinkTreeRoot)
            .build();
      }

      @Override
      public ImmutableMap<BuildTarget, CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
        return ImmutableMap.of(
            getBuildTarget(),
            getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      }

      @Override
      public NativeLinkableInput getNativeLinkableInput(
          CxxPlatform cxxPlatform,
          Linker.LinkableDepType type) {
        return NativeLinkableInput.of(
            ImmutableList.<SourcePath>of(
                new BuildTargetSourcePath(getProjectFilesystem(), archive.getBuildTarget())),
            ImmutableList.of(archiveOutput.toString()));
      }

      @Override
      public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform) {
        return Optional.absent();
      }

      @Override
      public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform) {
        return PythonPackageComponents.of(
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableSet.<SourcePath>of(),
            Optional.<Boolean>absent());
      }

      @Override
      public Iterable<AndroidPackageable> getRequiredPackageables() {
        return ImmutableList.of();
      }

      @Override
      public void addToCollector(AndroidPackageableCollector collector) {}

      @Override
      public ImmutableMap<String, SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) {
        return ImmutableMap.of();
      }

      @Override
      public boolean isTestedBy(BuildTarget buildTarget) {
        return false;
      }
    };
    resolver.addAllToIndex(ImmutableList.of(header, headerSymlinkTree, archive, dep));


    BuildTarget target = BuildTargetFactory.newInstance("//:rule");
    CxxBinaryBuilder cxxBinaryBuilder =
        (CxxBinaryBuilder) new CxxBinaryBuilder(target)
              .setSrcs(
                  ImmutableList.of(
                      SourceWithFlags.of(new TestSourcePath("test/bar.cpp")),
                      SourceWithFlags.of(
                          new BuildTargetSourcePath(
                              projectFilesystem,
                              genSource.getBuildTarget()))))
              .setHeaders(
                  ImmutableList.<SourcePath>of(
                      new TestSourcePath("test/bar.h"),
                      new BuildTargetSourcePath(projectFilesystem, genHeader.getBuildTarget())))
              .setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
    CxxBinary binRule = (CxxBinary) cxxBinaryBuilder.build(resolver);
    CxxLink rule = binRule.getRule();
    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            cxxBinaryBuilder.createBuildRuleParams(resolver, projectFilesystem, TargetGraph.EMPTY),
            resolver,
            pathResolver,
            cxxPlatform,
            CxxPreprocessorInput.EMPTY,
            ImmutableList.<String>of());



    assertEquals(
        ImmutableSet.of(
            cxxSourceRuleFactory.createCompileBuildTarget(
                "test/bar.cpp",
                CxxSourceRuleFactory.PicType.PDC),
            cxxSourceRuleFactory.createCompileBuildTarget(
                genSourceName,
                CxxSourceRuleFactory.PicType.PDC),
            archive.getBuildTarget()),
        FluentIterable.from(rule.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule preprocessRule1 = resolver.getRule(
        cxxSourceRuleFactory.createPreprocessBuildTarget(
            "test/bar.cpp",
            CxxSource.Type.CXX,
            CxxSourceRuleFactory.PicType.PDC));
    assertEquals(
        ImmutableSet.of(
            genHeaderTarget,
            headerSymlinkTree.getBuildTarget(),
            header.getBuildTarget(),
            CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
                target,
                cxxPlatform.getFlavor(),
                HeaderVisibility.PRIVATE)),
        FluentIterable.from(preprocessRule1.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule compileRule1 = resolver.getRule(
        cxxSourceRuleFactory.createCompileBuildTarget(
            "test/bar.cpp",
            CxxSourceRuleFactory.PicType.PDC));
    assertNotNull(compileRule1);
    assertEquals(
        ImmutableSet.of(
            preprocessRule1.getBuildTarget()),
        FluentIterable.from(compileRule1.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule preprocessRule2 = resolver.getRule(
        cxxSourceRuleFactory.createPreprocessBuildTarget(
            genSourceName,
            CxxSource.Type.CXX,
            CxxSourceRuleFactory.PicType.PDC));
    assertEquals(
        ImmutableSet.of(
            genHeaderTarget,
            genSourceTarget,
            headerSymlinkTree.getBuildTarget(),
            header.getBuildTarget(),
            CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
                target,
                cxxPlatform.getFlavor(),
                HeaderVisibility.PRIVATE)),
        FluentIterable.from(preprocessRule2.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule compileRule2 = resolver.getRule(
        cxxSourceRuleFactory.createCompileBuildTarget(
            genSourceName,
            CxxSourceRuleFactory.PicType.PDC));
    assertNotNull(compileRule2);
    assertEquals(
        ImmutableSet.of(
            preprocessRule2.getBuildTarget()),
        FluentIterable.from(compileRule2.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());
  }

}

<code block>

package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.FakeBuildContext;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.FakeBuildableContext;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.MoreAsserts;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Test;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class CxxCompilationDatabaseTest {

  private void runCombinedTest(
      CxxPreprocessMode strategy,
      ImmutableList<String> expectedArguments) {
    BuildTarget testBuildTarget = BuildTarget
        .builder(BuildTargetFactory.newInstance("//foo:baz"))
        .addAllFlavors(
            ImmutableSet.of(CxxCompilationDatabase.COMPILATION_DATABASE))
        .build();
    BuildRuleParams testBuildRuleParams = new FakeBuildRuleParamsBuilder(testBuildTarget)
        .setTargetGraph(
            TargetGraphFactory.newInstance(
                new CxxLibraryBuilder(testBuildTarget).build()))
        .build();

    BuildRuleResolver testBuildRuleResolver = new BuildRuleResolver();
    SourcePathResolver testSourcePathResolver = new SourcePathResolver(testBuildRuleResolver);

    BuildTarget preprocessTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("preprocess-test.cpp"))
        .build();
    BuildTarget compileTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("compile-test.cpp"))
        .build();

    ImmutableSortedSet.Builder<CxxPreprocessAndCompile> rules = ImmutableSortedSet.naturalOrder();
    CxxPreprocessAndCompileStep.Operation operation;
    BuildRuleParams compileBuildRuleParams;
    switch (strategy) {
      case SEPARATE:
        operation = CxxPreprocessAndCompileStep.Operation.COMPILE;
        CxxPreprocessAndCompile preprocessRule = new CxxPreprocessAndCompile(
            new FakeBuildRuleParamsBuilder(preprocessTarget).build(),
            testSourcePathResolver,
            operation,
            Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),
            Optional.of(ImmutableList.<String>of()),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Paths.get("test.o"),
            new TestSourcePath("test.cpp"),
            CxxSource.Type.CXX,
            ImmutableList.of(
                Paths.get("foo/bar"),
                Paths.get("test")),
            ImmutableList.<Path>of(),
            ImmutableList.<Path>of(),
            CxxHeaders.builder().build(),
            CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);
        rules.add(preprocessRule);
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget)
            .setDeps(ImmutableSortedSet.<BuildRule>of(preprocessRule))
            .build();
        break;
      case COMBINED:
        operation = CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO;
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget).build();
        break;
      case PIPED:
        operation = CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE;
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget).build();
        break;
      default:
        throw new RuntimeException("Invalid strategy");
    }
    rules.add(
        new CxxPreprocessAndCompile(
            compileBuildRuleParams,
            testSourcePathResolver,
            operation,
            Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),
            Optional.of(ImmutableList.<String>of()),
            Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
            Optional.of(ImmutableList.<String>of()),
            Paths.get("test.o"),
            new TestSourcePath("test.cpp"),
            CxxSource.Type.CXX,
            ImmutableList.of(
                Paths.get("foo/bar"),
                Paths.get("test")),
            ImmutableList.<Path>of(),
            ImmutableList.<Path>of(),
            CxxHeaders.builder().build(),
            CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER));

    CxxCompilationDatabase compilationDatabase = CxxCompilationDatabase.createCompilationDatabase(
        testBuildRuleParams,
        testSourcePathResolver,
        strategy,
        rules.build());

    assertEquals(
        "getPathToOutput() should be a function of the build target.",
        Paths.get("buck-out/gen/foo/__baz#compilation-database.json"),
        compilationDatabase.getPathToOutput());

    BuildContext buildContext = FakeBuildContext.NOOP_CONTEXT;
    BuildableContext buildableContext = new FakeBuildableContext();
    List<Step> buildSteps = compilationDatabase.getBuildSteps(buildContext, buildableContext);
    assertEquals(2, buildSteps.size());
    assertTrue(buildSteps.get(0) instanceof MkdirStep);
    assertTrue(buildSteps.get(1) instanceof
            CxxCompilationDatabase.GenerateCompilationCommandsJson);

    final String root = "/Users/user/src";
    final Path fakeRoot = Paths.get(root);
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem() {
      @Override
      public Path resolve(Path relativePath) {
        return fakeRoot.resolve(relativePath);
      }
    };
    ExecutionContext context = TestExecutionContext
        .newBuilder()
        .setProjectFilesystem(projectFilesystem)
        .build();
    CxxCompilationDatabase.GenerateCompilationCommandsJson step =
        (CxxCompilationDatabase.GenerateCompilationCommandsJson) buildSteps.get(1);
    Iterable<CxxCompilationDatabaseEntry> observedEntries =
        step.createEntries(context);
    Iterable<CxxCompilationDatabaseEntry> expectedEntries =
        ImmutableList.of(
          new CxxCompilationDatabaseEntry(
              root + "/foo",
              root + "/test.cpp",
              expectedArguments));
    MoreAsserts.assertIterablesEquals(expectedEntries, observedEntries);
  }

  @Test
  public void testCompilationDatabseWithCombinedPreprocessAndCompileStrategy() {
    runCombinedTest(CxxPreprocessMode.COMBINED,
        ImmutableList.of(
            "compiler",
            "-I",
            "foo/bar",
            "-I",
            "test",
            "-x",
            "c++",
            "-c",
            "test.cpp",
            "-o",
            "test.o"));
  }

  @Test
  public void testCompilationDatabseWithPipedPreprocessAndCompileStrategy() {
    runCombinedTest(CxxPreprocessMode.PIPED,
        ImmutableList.of(
            "compiler",
            "-x",
            "c++",
            "-c",
            "-I",
            "foo/bar",
            "-I",
            "test",
            "-o",
            "test.o",
            "test.cpp"));
  }

  @Test
  public void testCompilationDatabseWithSeperatedPreprocessAndCompileStrategy() {
    BuildTarget testBuildTarget = BuildTarget
        .builder(BuildTargetFactory.newInstance("//foo:baz"))
        .addAllFlavors(
            ImmutableSet.of(CxxCompilationDatabase.COMPILATION_DATABASE))
        .build();
    BuildRuleParams testBuildRuleParams = new FakeBuildRuleParamsBuilder(testBuildTarget)
        .setTargetGraph(
            TargetGraphFactory.newInstance(
                new CxxLibraryBuilder(testBuildTarget).build()))
        .build();

    BuildRuleResolver testBuildRuleResolver = new BuildRuleResolver();
    SourcePathResolver testSourcePathResolver = new SourcePathResolver(testBuildRuleResolver);

    BuildTarget preprocessTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("preprocess-test.cpp"))
        .build();
    BuildRuleParams preprocessBuildRuleParams = new FakeBuildRuleParamsBuilder(preprocessTarget)
        .build();
    CxxPreprocessAndCompile testPreprocessRule = new CxxPreprocessAndCompile(
        preprocessBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
        Optional.of(ImmutableList.<String>of()),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Paths.get("test.ii"),
        new TestSourcePath("test.cpp"),
        CxxSource.Type.CXX_CPP_OUTPUT,
        ImmutableList.of(
            Paths.get("foo/bar"),
            Paths.get("test")),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        CxxHeaders.builder().build(),
        CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);

    BuildTarget compileTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("compile-test.cpp"))
        .build();
    BuildRuleParams compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(testPreprocessRule))
        .build();
    CxxPreprocessAndCompile testCompileRule = new CxxPreprocessAndCompile(
        compileBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
        Optional.of(ImmutableList.<String>of()),
        Paths.get("test.o"),
        new TestSourcePath("test.ii"),
        CxxSource.Type.CXX_CPP_OUTPUT,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        CxxHeaders.builder().build(),
        CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);

    CxxCompilationDatabase compilationDatabase = CxxCompilationDatabase.createCompilationDatabase(
        testBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessMode.SEPARATE,
        ImmutableSortedSet.of(testPreprocessRule, testCompileRule));

    assertEquals(
        "getPathToOutput() should be a function of the build target.",
        Paths.get("buck-out/gen/foo/__baz#compilation-database.json"),
        compilationDatabase.getPathToOutput());

    BuildContext buildContext = FakeBuildContext.NOOP_CONTEXT;
    BuildableContext buildableContext = new FakeBuildableContext();
    List<Step> buildSteps = compilationDatabase.getBuildSteps(buildContext, buildableContext);
    assertEquals(2, buildSteps.size());
    assertTrue(buildSteps.get(0) instanceof MkdirStep);
    assertTrue(buildSteps.get(1) instanceof
            CxxCompilationDatabase.GenerateCompilationCommandsJson);

    final String root = "/Users/user/src";
    final Path fakeRoot = Paths.get(root);
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem() {
      @Override
      public Path resolve(Path relativePath) {
        return fakeRoot.resolve(relativePath);
      }
    };
    ExecutionContext context = TestExecutionContext
        .newBuilder()
        .setProjectFilesystem(projectFilesystem)
        .build();
    CxxCompilationDatabase.GenerateCompilationCommandsJson step =
        (CxxCompilationDatabase.GenerateCompilationCommandsJson) buildSteps.get(1);
    Iterable<CxxCompilationDatabaseEntry> observedEntries =
        step.createEntries(context);
    Iterable<CxxCompilationDatabaseEntry> expectedEntries =
        ImmutableList.of(
            new CxxCompilationDatabaseEntry(
                root + "/foo",
                root + "/test.cpp",
                ImmutableList.of(
                    "compiler",
                    "-x",
                    "c++-cpp-output",
                    "-c",
                    "-I",
                    "foo/bar",
                    "-I",
                    "test",
                    "-o",
                    "test.o",
                    "test.cpp")));
    MoreAsserts.assertIterablesEquals(expectedEntries, observedEntries);
  }
}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import org.junit.Test;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxPreprocessAndCompileTest {

  private static final Tool DEFAULT_PREPROCESSOR = new HashedFileTool(Paths.get("preprocessor"));
  private static final Tool DEFAULT_COMPILER = new HashedFileTool(Paths.get("compiler"));
  private static final ImmutableList<String> DEFAULT_FLAGS =
      ImmutableList.of("-fsanitize=address");
  private static final Path DEFAULT_OUTPUT = Paths.get("test.o");
  private static final SourcePath DEFAULT_INPUT = new TestSourcePath("test.cpp");
  private static final CxxSource.Type DEFAULT_INPUT_TYPE = CxxSource.Type.CXX;
  private static final CxxHeaders DEFAULT_INCLUDES =
      CxxHeaders.builder()
          .putNameToPathMap(Paths.get("test.h"), new TestSourcePath("foo/test.h"))
          .build();
  private static final ImmutableList<Path> DEFAULT_INCLUDE_ROOTS = ImmutableList.of(
      Paths.get("foo/bar"),
      Paths.get("test"));
  private static final ImmutableList<Path> DEFAULT_SYSTEM_INCLUDE_ROOTS = ImmutableList.of(
      Paths.get("/usr/include"),
      Paths.get("/include"));
  private static final ImmutableList<Path> DEFAULT_FRAMEWORK_ROOTS = ImmutableList.of();
  private static final DebugPathSanitizer DEFAULT_SANITIZER =
      CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER;

  private RuleKey generateRuleKey(
      RuleKeyBuilderFactory factory,
      AbstractBuildRule rule) {

    RuleKey.Builder builder = factory.newInstance(rule);
    return builder.build();
  }

  @Test
  public void testThatInputChangesCauseRuleKeyChanges() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("preprocessor", Strings.repeat("a", 40))
                    .put("compiler", Strings.repeat("a", 40))
                    .put("test.o", Strings.repeat("b", 40))
                    .put("test.cpp", Strings.repeat("c", 40))
                    .put("different", Strings.repeat("d", 40))
                    .put("foo/test.h", Strings.repeat("e", 40))
                    .put("path/to/a/plugin.so", Strings.repeat("f", 40))
                    .put("path/to/a/different/plugin.so", Strings.repeat("a0", 40))
                    .build()),
            pathResolver);


    RuleKey defaultRuleKey = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));


    RuleKey compilerChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.<Tool>of(new HashedFileTool(Paths.get("different"))),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, compilerChange);


    RuleKey operationChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(DEFAULT_FLAGS),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, operationChange);


    RuleKey flagsChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(ImmutableList.of("-different")),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, flagsChange);


    RuleKey inputChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            new TestSourcePath("different"),
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, inputChange);



    RuleKey includesChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            ImmutableList.of(Paths.get("different")),
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertEquals(defaultRuleKey, includesChange);



    RuleKey systemIncludesChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            ImmutableList.of(Paths.get("different")),
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertEquals(defaultRuleKey, systemIncludesChange);


    RuleKey frameworkRootsChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            ImmutableList.of(Paths.get("different")), DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, frameworkRootsChange);
  }

  @Test
  public void sanitizedPathsInFlagsDoNotAffectRuleKey() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("preprocessor", Strings.repeat("a", 40))
                    .put("compiler", Strings.repeat("a", 40))
                    .put("test.o", Strings.repeat("b", 40))
                    .put("test.cpp", Strings.repeat("c", 40))
                    .put("different", Strings.repeat("d", 40))
                    .put("foo/test.h", Strings.repeat("e", 40))
                    .put("path/to/a/plugin.so", Strings.repeat("f", 40))
                    .put("path/to/a/different/plugin.so", Strings.repeat("a0", 40))
                    .build()),
            pathResolver);


    int pathSize = 10;
    DebugPathSanitizer sanitizer1 = new DebugPathSanitizer(
        pathSize,
        File.separatorChar,
        Paths.get("PWD"),
        ImmutableBiMap.of(Paths.get("something"), Paths.get("A")));
    DebugPathSanitizer sanitizer2 = new DebugPathSanitizer(
        pathSize,
        File.separatorChar,
        Paths.get("PWD"),
        ImmutableBiMap.of(Paths.get("different"), Paths.get("A")));


    ImmutableList<String> flags1 = ImmutableList.of("-Isomething/foo");
    RuleKey ruleKey1 = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(flags1),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, sanitizer1));


    ImmutableList<String> flags2 = ImmutableList.of("-Idifferent/foo");
    RuleKey ruleKey2 = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(flags2),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, sanitizer2));

    assertEquals(ruleKey1, ruleKey2);
  }

  @Test
  public void usesCorrectCommandForCompile() {


    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ImmutableList<String> flags = ImmutableList.of("-ffunction-sections");
    Path output = Paths.get("test.o");
    Path input = Paths.get("test.ii");

    CxxPreprocessAndCompile buildRule = new CxxPreprocessAndCompile(
        params,
        pathResolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(DEFAULT_COMPILER),
        Optional.of(flags),
        output,
        new TestSourcePath(input.toString()),
        DEFAULT_INPUT_TYPE,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        DEFAULT_FRAMEWORK_ROOTS, CxxHeaders.builder().build(), DEFAULT_SANITIZER);

    ImmutableList<String> expectedCompileCommand = ImmutableList.<String>builder()
        .add("compiler")
        .add("-ffunction-sections")
        .add("-x", "c++")
        .add("-c")
        .add(input.toString())
        .add("-o", output.toString())
        .build();
    ImmutableList<String> actualCompileCommand = buildRule.makeMainStep().getCommand();
    assertEquals(expectedCompileCommand, actualCompileCommand);
  }

  @Test
  public void usesCorrectCommandForPreprocess() {


    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ImmutableList<String> flags = ImmutableList.of("-Dtest=blah");
    Path output = Paths.get("test.ii");
    Path input = Paths.get("test.cpp");

    CxxPreprocessAndCompile buildRule = new CxxPreprocessAndCompile(
        params,
        pathResolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(DEFAULT_PREPROCESSOR),
        Optional.of(flags),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        new TestSourcePath(input.toString()),
        DEFAULT_INPUT_TYPE,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        DEFAULT_FRAMEWORK_ROOTS, CxxHeaders.builder().build(), DEFAULT_SANITIZER);


    ImmutableList<String> expectedPreprocessCommand = ImmutableList.<String>builder()
        .add("preprocessor")
        .add("-Dtest=blah")
        .add("-x", "c++")
        .add("-E")
        .add(input.toString())
        .build();
    ImmutableList<String> actualPreprocessCommand = buildRule.makeMainStep().getCommand();
    assertEquals(expectedPreprocessCommand, actualPreprocessCommand);
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePathResolver;
import com.google.common.collect.ImmutableList;

public class CxxSourceRuleFactoryHelper {

  private CxxSourceRuleFactoryHelper() {}

  public static CxxSourceRuleFactory of(BuildTarget target, CxxPlatform cxxPlatform) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    return new CxxSourceRuleFactory(
        BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxPreprocessorInput.EMPTY,
        ImmutableList.<String>of());
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Predicates;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxDescriptionEnhancerTest {

  @Test
  public void createLexYaccBuildRules() throws IOException {
    BuildRuleResolver resolver = new BuildRuleResolver();


    FakeProjectFilesystem filesystem = new FakeProjectFilesystem();
    Path lexPath = Paths.get("lex");
    filesystem.touch(lexPath);
    Path yaccPath = Paths.get("yacc");
    filesystem.touch(yaccPath);
    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.of(
                "lex", lexPath.toString(),
                "yacc", yaccPath.toString())),
        filesystem);
    CxxPlatform cxxBuckConfig = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));


    BuildTarget target = BuildTargetFactory.newInstance("//:test");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);


    String lexSourceName = "test.ll";
    BuildTarget genruleTarget = BuildTargetFactory.newInstance("//:genrule_lex");
    Genrule genrule = (Genrule) GenruleBuilder
        .newGenruleBuilder(genruleTarget)
        .setOut(lexSourceName)
        .build(resolver);
    SourcePath lexSource = new BuildTargetSourcePath(filesystem, genrule.getBuildTarget());


    String yaccSourceName = "test.yy";
    SourcePath yaccSource = new TestSourcePath(yaccSourceName);


    CxxHeaderSourceSpec actual = CxxDescriptionEnhancer.createLexYaccBuildRules(
        params,
        resolver,
        cxxBuckConfig,
        ImmutableList.<String>of(),
        ImmutableMap.of(lexSourceName, lexSource),
        ImmutableList.<String>of(),
        ImmutableMap.of(yaccSourceName, yaccSource));


    Lex lex = (Lex) resolver.getRule(
        CxxDescriptionEnhancer.createLexBuildTarget(target, lexSourceName));
    assertNotNull(lex);
    assertEquals(
        ImmutableSortedSet.<BuildRule>of(genrule),
        lex.getDeps());


    Yacc yacc = (Yacc) resolver.getRule(
        CxxDescriptionEnhancer.createYaccBuildTarget(target, yaccSourceName));
    assertNotNull(yacc);
    assertEquals(
        ImmutableSortedSet.<BuildRule>of(),
        yacc.getDeps());


    Path lexOutputSource = CxxDescriptionEnhancer.getLexSourceOutputPath(target, lexSourceName);
    Path lexOutputHeader = CxxDescriptionEnhancer.getLexHeaderOutputPath(target, lexSourceName);
    Path yaccOutputPrefix =
        CxxDescriptionEnhancer.getYaccOutputPrefix(
            target,
            Files.getNameWithoutExtension(yaccSourceName));
    Path yaccOutputSource = Yacc.getSourceOutputPath(yaccOutputPrefix);
    Path yaccOutputHeader = Yacc.getHeaderOutputPath(yaccOutputPrefix);
    CxxHeaderSourceSpec expected =
        CxxHeaderSourceSpec.of(
            ImmutableMap.<Path, SourcePath>of(
                target.getBasePath().resolve(lexSourceName + ".h"),
                new BuildTargetSourcePath(filesystem, lex.getBuildTarget(), lexOutputHeader),
                target.getBasePath().resolve(yaccSourceName + ".h"),
                new BuildTargetSourcePath(filesystem, yacc.getBuildTarget(), yaccOutputHeader)),
            ImmutableMap.of(
                lexSourceName + ".cc",
                CxxSource.of(
                    CxxSource.Type.CXX,
                    new BuildTargetSourcePath(filesystem, lex.getBuildTarget(), lexOutputSource),
                    ImmutableList.<String>of()),
                yaccSourceName + ".cc",
                CxxSource.of(
                    CxxSource.Type.CXX,
                    new BuildTargetSourcePath(filesystem, yacc.getBuildTarget(), yaccOutputSource),
                    ImmutableList.<String>of())));
    assertEquals(expected, actual);
  }

  @Test
  public void libraryTestIncludesPrivateHeadersOfLibraryUnderTest() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());

    BuildTarget libTarget = BuildTargetFactory.newInstance("//:lib");
    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");

    BuildRuleParams libParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(libTarget);
    FakeCxxLibrary libRule = new FakeCxxLibrary(
        libParams,
        pathResolver,
        BuildTargetFactory.newInstance("//:header"),
        BuildTargetFactory.newInstance("//:symlink"),
        Paths.get("symlink/tree/lib"),
        BuildTargetFactory.newInstance("//:privateheader"),
        BuildTargetFactory.newInstance("//:privatesymlink"),
        Paths.get("private/symlink/tree/lib"),
        new FakeBuildRule("//:archive", pathResolver),
        Paths.get("output/path/lib.a"),
        new FakeBuildRule("//:shared", pathResolver),
        Paths.get("output/path/lib.so"),
        "lib.so",

        ImmutableSortedSet.of(testTarget)
    );

    BuildRuleParams testParams = new FakeBuildRuleParamsBuilder(testTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(libRule))
        .build();

    CxxPreprocessorInput combinedInput = CxxDescriptionEnhancer.combineCxxPreprocessorInput(
        testParams,
        CxxPlatformUtils.DEFAULT_PLATFORM,
        ImmutableMultimap.<CxxSource.Type, String>of(),
        ImmutableList.<SourcePath>of(),
        ImmutableList.<SymlinkTree>of(),
        ImmutableList.<Path>of(),
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            CxxPlatformUtils.DEFAULT_PLATFORM,
            FluentIterable.from(testParams.getDeps())
                .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));

    assertThat(
        "Test of library should include both public and private headers",
        combinedInput.getIncludeRoots(),
        hasItems(
            Paths.get("symlink/tree/lib"),
            Paths.get("private/symlink/tree/lib")));
  }

  @Test
  public void nonTestLibraryDepDoesNotIncludePrivateHeadersOfLibrary() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());

    BuildTarget libTarget = BuildTargetFactory.newInstance("//:lib");

    BuildRuleParams libParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(libTarget);
    FakeCxxLibrary libRule = new FakeCxxLibrary(
        libParams,
        pathResolver,
        BuildTargetFactory.newInstance("//:header"),
        BuildTargetFactory.newInstance("//:symlink"),
        Paths.get("symlink/tree/lib"),
        BuildTargetFactory.newInstance("//:privateheader"),
        BuildTargetFactory.newInstance("//:privatesymlink"),
        Paths.get("private/symlink/tree/lib"),
        new FakeBuildRule("//:archive", pathResolver),
        Paths.get("output/path/lib.a"),
        new FakeBuildRule("//:shared", pathResolver),
        Paths.get("output/path/lib.so"),
        "lib.so",

        ImmutableSortedSet.<BuildTarget>of()
    );

    BuildTarget otherLibDepTarget = BuildTargetFactory.newInstance("//:other");
    BuildRuleParams otherLibDepParams = new FakeBuildRuleParamsBuilder(otherLibDepTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(libRule))
        .build();

    CxxPreprocessorInput otherInput = CxxDescriptionEnhancer.combineCxxPreprocessorInput(
        otherLibDepParams,
        CxxPlatformUtils.DEFAULT_PLATFORM,
        ImmutableMultimap.<CxxSource.Type, String>of(),
        ImmutableList.<SourcePath>of(),
        ImmutableList.<SymlinkTree>of(),
        ImmutableList.<Path>of(),
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            CxxPlatformUtils.DEFAULT_PLATFORM,
            FluentIterable.from(otherLibDepParams.getDeps())
                .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));

    assertThat(
        "Non-test rule with library dep should include public and not private headers",
        otherInput.getIncludeRoots(),
        allOf(
            hasItem(Paths.get("symlink/tree/lib")),
            not(hasItem(Paths.get("private/symlink/tree/lib")))));
  }

  @Test
  public void buildTargetsWithDifferentFlavorsProduceDifferentDefaultSonames() {
    BuildTarget target1 = BuildTargetFactory.newInstance("//:rule#one");
    BuildTarget target2 = BuildTargetFactory.newInstance("//:rule#two");
    assertNotEquals(
        CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
            target1,
            CxxPlatformUtils.DEFAULT_PLATFORM),
        CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
            target2,
            CxxPlatformUtils.DEFAULT_PLATFORM));
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.testutil.AllExistingProjectFilesystem;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;

import org.hamcrest.Matchers;
import org.junit.Test;

import java.util.Collections;
import java.util.List;

public class CxxSourceRuleFactoryTest {

  private static final ProjectFilesystem PROJECT_FILESYSTEM = new FakeProjectFilesystem();

  private static final CxxPlatform CXX_PLATFORM = DefaultCxxPlatforms.build(
      new CxxBuckConfig(new FakeBuckConfig()));

  private static <T> void assertContains(ImmutableList<T> container, Iterable<T> items) {
    for (T item : items) {
      assertThat(container, Matchers.hasItem(item));
    }
  }

  private static FakeBuildRule createFakeBuildRule(
      String target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(BuildTargetFactory.newInstance(target))
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Test
  public void createPreprocessBuildRulePropagatesCxxPreprocessorDeps() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    FakeBuildRule dep = resolver.addToIndex(
        new FakeBuildRule(
            "//:dep1",
            new SourcePathResolver(new BuildRuleResolver())));

    CxxPreprocessorInput cxxPreprocessorInput =
        CxxPreprocessorInput.builder()
            .addRules(dep.getBuildTarget())
            .build();

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            CXX_PLATFORM,
            cxxPreprocessorInput,
            ImmutableList.<String>of());

    String name = "foo/bar.cpp";
    SourcePath input = new PathSourcePath(PROJECT_FILESYSTEM, target.getBasePath().resolve(name));
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        input,
        ImmutableList.<String>of());

    BuildRule cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocess.getDeps());
    cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocess.getDeps());
  }

  @Test
  public void preprocessFlagsFromPlatformArePropagated() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> platformFlags = ImmutableList.of("-some", "-flags");
    CxxPlatform platform = DefaultCxxPlatforms.build(
        new CxxBuckConfig(
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of("cxxppflags", Joiner.on(" ").join(platformFlags))))));

    CxxPreprocessorInput cxxPreprocessorInput = CxxPreprocessorInput.EMPTY;

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            platform,
            cxxPreprocessorInput,
            ImmutableList.<String>of());

    String name = "source.cpp";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(cxxPreprocess.getPreprocessorFlags().get(), platformFlags));
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(
            cxxPreprocessAndCompile.getPreprocessorFlags().get(),
            platformFlags));
  }

  @Test
  public void checkCorrectFlagsAreUsedForPreprocessBuildRules() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(buildRuleResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    Joiner space = Joiner.on(" ");

    ImmutableList<String> explicitCppflags = ImmutableList.of("-explicit-cppflag");
    ImmutableList<String> explicitCxxppflags = ImmutableList.of("-explicit-cxxppflag");
    CxxPreprocessorInput cxxPreprocessorInput =
        CxxPreprocessorInput.builder()
            .putAllPreprocessorFlags(CxxSource.Type.C, explicitCppflags)
            .putAllPreprocessorFlags(CxxSource.Type.CXX, explicitCxxppflags)
            .build();

    ImmutableList<String> asppflags = ImmutableList.of("-asppflag", "-asppflag");

    SourcePath cpp = new TestSourcePath("cpp");
    ImmutableList<String> cppflags = ImmutableList.of("-cppflag", "-cppflag");

    SourcePath cxxpp = new TestSourcePath("cxxpp");
    ImmutableList<String> cxxppflags = ImmutableList.of("-cxxppflag", "-cxxppflag");

    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.<String, String>builder()
                .put("asppflags", space.join(asppflags))
                .put("cpp", sourcePathResolver.getPath(cpp).toString())
                .put("cppflags", space.join(cppflags))
                .put("cxxpp", sourcePathResolver.getPath(cxxpp).toString())
                .put("cxxppflags", space.join(cxxppflags))
                .build()),
        filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            sourcePathResolver,
            platform,
            cxxPreprocessorInput,
            ImmutableList.<String>of());

    String cSourceName = "test.c";
    List<String> perFileFlagsForTestC =
        ImmutableList.of("-per-file-flag-for-c-file", "-and-another-one");
    CxxSource cSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cSourceName),
        perFileFlagsForTestC);
    CxxPreprocessAndCompile cPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cPreprocess.getPreprocessorFlags().get(), explicitCppflags);
    assertContains(cPreprocess.getPreprocessorFlags().get(), cppflags);
    assertContains(cPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestC);
    CxxPreprocessAndCompile cPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), perFileFlagsForTestC);

    String cxxSourceName = "test.cpp";
    List<String> perFileFlagsForTestCpp =
        ImmutableList.of("-per-file-flag-for-cpp-file");
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(cxxSourceName),
        perFileFlagsForTestCpp);
    CxxPreprocessAndCompile cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), explicitCxxppflags);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), cxxppflags);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestCpp);
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), perFileFlagsForTestCpp);

    String assemblerWithCppSourceName = "test.S";
    List<String> perFileFlagsForTestS =
        ImmutableList.of("-a-flag-for-s-file", "-another-one", "-one-more");
    CxxSource assemblerWithCppSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER_WITH_CPP,
        new TestSourcePath(assemblerWithCppSourceName),
        perFileFlagsForTestS);
    CxxPreprocessAndCompile assemblerWithCppPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            assemblerWithCppSourceName,
            assemblerWithCppSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(assemblerWithCppPreprocess.getPreprocessorFlags().get(), asppflags);
    assertContains(assemblerWithCppPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestS);
    CxxPreprocessAndCompile assemblerWithCppPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            assemblerWithCppSourceName,
            assemblerWithCppSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(
        assemblerWithCppPreprocessAndCompile.getCompilerFlags().get(),
        perFileFlagsForTestS);
  }

  @Test
  public void createCompileBuildRulePropagatesBuildRuleSourcePathDeps() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    FakeBuildRule dep = createFakeBuildRule("//:test", new SourcePathResolver(resolver));
    resolver.addToIndex(dep);
    SourcePath input = new BuildTargetSourcePath(PROJECT_FILESYSTEM, dep.getBuildTarget());
    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            CXX_PLATFORM,
            CxxPreprocessorInput.EMPTY,
            ImmutableList.<String>of());

    String nameCompile = "foo/bar.ii";
    CxxSource cxxSourceCompile = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        input,
        ImmutableList.<String>of());
    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            nameCompile,
            cxxSourceCompile,
            CxxSourceRuleFactory.PicType.PDC);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxCompile.getDeps());

    String namePreprocessAndCompile = "foo/bar.cpp";
    CxxSource cxxSourcePreprocessAndCompile = CxxSource.of(
        CxxSource.Type.CXX,
        input,
        ImmutableList.<String>of());
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            namePreprocessAndCompile,
            cxxSourcePreprocessAndCompile,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocessAndCompile.getDeps());
  }

  @Test
  @SuppressWarnings("PMD.UseAssertTrueInsteadOfAssertEquals")
  public void createCompileBuildRulePicOption() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            CXX_PLATFORM,
            CxxPreprocessorInput.EMPTY,
            ImmutableList.<String>of());

    String name = "foo/bar.ii";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        new TestSourcePath(name),
        ImmutableList.<String>of());



    CxxPreprocessAndCompile noPicCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertFalse(noPicCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PDC),
        noPicCompile.getBuildTarget());



    CxxPreprocessAndCompile picCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PIC);
    assertTrue(picCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PIC),
        picCompile.getBuildTarget());

    name = "foo/bar.cpp";
    cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());



    CxxPreprocessAndCompile noPicPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertFalse(noPicPreprocessAndCompile.getPreprocessorFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PDC),
        noPicPreprocessAndCompile.getBuildTarget());



    CxxPreprocessAndCompile picPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PIC,
            CxxPreprocessMode.SEPARATE);
    assertTrue(picPreprocessAndCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PIC),
        picPreprocessAndCompile.getBuildTarget());
  }

  @Test
  public void compilerFlagsFromPlatformArePropagated() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    ImmutableList<String> platformFlags = ImmutableList.of("-some", "-flags");
    CxxPlatform platform = DefaultCxxPlatforms.build(
        new CxxBuckConfig(
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of("cxxflags", Joiner.on(" ").join(platformFlags))))));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            platform,
            CxxPreprocessorInput.EMPTY,
            ImmutableList.<String>of());

    String name = "source.ii";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(cxxCompile.getCompilerFlags().get(), platformFlags));

    name = "source.cpp";
    cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(
            cxxPreprocessAndCompile.getPreprocessorFlags().get(),
            platformFlags));
  }

  @Test
  public void checkCorrectFlagsAreUsedForCompileBuildRules() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(buildRuleResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    Joiner space = Joiner.on(" ");

    ImmutableList<String> explicitCompilerFlags = ImmutableList.of("-explicit-compilerflag");

    SourcePath as = new TestSourcePath("as");
    ImmutableList<String> asflags = ImmutableList.of("-asflag", "-asflag");

    SourcePath cc = new TestSourcePath("cc");
    ImmutableList<String> cflags = ImmutableList.of("-cflag", "-cflag");

    SourcePath cxx = new TestSourcePath("cxx");
    ImmutableList<String> cxxflags = ImmutableList.of("-cxxflag", "-cxxflag");

    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.<String, String>builder()
                .put("as", sourcePathResolver.getPath(as).toString())
                .put("asflags", space.join(asflags))
                .put("cc", sourcePathResolver.getPath(cc).toString())
                .put("cflags", space.join(cflags))
                .put("cxx", sourcePathResolver.getPath(cxx).toString())
                .put("cxxflags", space.join(cxxflags))
                .build()),
        filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            sourcePathResolver,
            platform,
            CxxPreprocessorInput.EMPTY,
            explicitCompilerFlags);

    String cSourceName = "test.i";
    List<String> cSourcePerFileFlags = ImmutableList.of("-c-source-par-file-flag");
    CxxSource cSource = CxxSource.of(
        CxxSource.Type.C_CPP_OUTPUT,
        new TestSourcePath(cSourceName),
        cSourcePerFileFlags);
    CxxPreprocessAndCompile cCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cCompile.getCompilerFlags().get(), cflags);
    assertContains(cCompile.getCompilerFlags().get(), asflags);
    assertContains(cCompile.getCompilerFlags().get(), cSourcePerFileFlags);

    cSourceName = "test.c";
    cSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cSourceName),
        cSourcePerFileFlags);
    CxxPreprocessAndCompile cPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), cflags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), cSourcePerFileFlags);

    String cxxSourceName = "test.ii";
    List<String> cxxSourcePerFileFlags = ImmutableList.of("-cxx-source-par-file-flag");
    CxxSource cxxSource =
        CxxSource.of(
            CxxSource.Type.CXX_CPP_OUTPUT,
            new TestSourcePath(cxxSourceName),
            cxxSourcePerFileFlags);
    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cxxCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cxxCompile.getCompilerFlags().get(), cxxflags);
    assertContains(cxxCompile.getCompilerFlags().get(), asflags);
    assertContains(cxxCompile.getCompilerFlags().get(), cxxSourcePerFileFlags);

    cxxSourceName = "test.cpp";
    cxxSource =
        CxxSource.of(
            CxxSource.Type.CXX,
            new TestSourcePath(cxxSourceName),
            cxxSourcePerFileFlags);
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), cxxflags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), cxxSourcePerFileFlags);

    String cCppOutputSourceName = "test2.i";
    List<String> cCppOutputSourcePerFileFlags =
        ImmutableList.of("-c-cpp-output-source-par-file-flag");
    CxxSource cCppOutputSource = CxxSource.of(
        CxxSource.Type.C_CPP_OUTPUT,
        new TestSourcePath(cCppOutputSourceName),
        cCppOutputSourcePerFileFlags);
    CxxPreprocessAndCompile cCppOutputCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cCppOutputSourceName,
            cCppOutputSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), cflags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), asflags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), cCppOutputSourcePerFileFlags);

    cCppOutputSourceName = "test2.c";
    cCppOutputSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cCppOutputSourceName),
        cCppOutputSourcePerFileFlags);
    CxxPreprocessAndCompile cCppOutputPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cCppOutputSourceName,
            cCppOutputSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(
        cCppOutputPreprocessAndCompile.getCompilerFlags().get(),
        explicitCompilerFlags);
    assertContains(cCppOutputPreprocessAndCompile.getCompilerFlags().get(), cflags);
    assertContains(cCppOutputPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(
        cCppOutputPreprocessAndCompile.getCompilerFlags().get(),
        cCppOutputSourcePerFileFlags);

    String assemblerSourceName = "test.s";
    List<String> assemblerSourcePerFileFlags = ImmutableList.of("-assember-source-par-file-flag");
    CxxSource assemblerSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER,
        new TestSourcePath(assemblerSourceName),
        assemblerSourcePerFileFlags);
    CxxPreprocessAndCompile assemblerCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            assemblerSourceName,
            assemblerSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(assemblerCompile.getCompilerFlags().get(), asflags);
    assertContains(assemblerCompile.getCompilerFlags().get(), assemblerSourcePerFileFlags);

    assemblerSourceName = "test.S";
    assemblerSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER_WITH_CPP,
        new TestSourcePath(assemblerSourceName),
        assemblerSourcePerFileFlags);
    CxxPreprocessAndCompile assemblerPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            assemblerSourceName,
            assemblerSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(assemblerPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(
        assemblerPreprocessAndCompile.getCompilerFlags().get(),
        assemblerSourcePerFileFlags);
  }




  @Test
  public void checkCorrectFlagsAreUsedForObjcAndObjcxx() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();

    ImmutableList<String> explicitCompilerFlags = ImmutableList.of("-fobjc-arc");

    FakeBuckConfig buckConfig = new FakeBuckConfig(filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            new SourcePathResolver(buildRuleResolver),
            platform,
            CxxPreprocessorInput.EMPTY,
            explicitCompilerFlags);

    String objcSourceName = "test.mi";
    CxxSource objcSource = CxxSource.of(
        CxxSource.Type.OBJC_CPP_OUTPUT,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(objcCompile.getCompilerFlags().get(), explicitCompilerFlags);

    objcSourceName = "test.m";
    objcSource = CxxSource.of(
        CxxSource.Type.OBJC,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(objcPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);

    String objcxxSourceName = "test.mii";
    CxxSource objcxxSource = CxxSource.of(
        CxxSource.Type.OBJCXX_CPP_OUTPUT,
        new TestSourcePath(objcxxSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            objcxxSourceName,
            objcxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(objcxxCompile.getCompilerFlags().get(), explicitCompilerFlags);

    objcxxSourceName = "test.mm";
    objcxxSource = CxxSource.of(
        CxxSource.Type.OBJCXX,
        new TestSourcePath(objcxxSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcxxSourceName,
            objcxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(objcxxPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
  }

  @Test
  public void duplicateRuleFetchedFromResolver() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();

    FakeBuckConfig buckConfig = new FakeBuckConfig(filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            new SourcePathResolver(buildRuleResolver),
            platform,
            CxxPreprocessorInput.EMPTY,
            ImmutableList.<String>of());

    String objcSourceName = "test.m";
    CxxSource objcSource = CxxSource.of(
        CxxSource.Type.OBJC,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);


    CxxPreprocessAndCompile objcCompile2 =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);

    assertEquals(objcCompile.getBuildTarget(), objcCompile2.getBuildTarget());
  }
}

<code block>

package com.facebook.buck.android;

import com.facebook.buck.cxx.CxxHeaders;
import com.facebook.buck.cxx.CxxPlatform;
import com.facebook.buck.cxx.CxxPreprocessables;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.cxx.NativeLinkable;
import com.facebook.buck.cxx.NativeLinkableInput;
import com.facebook.buck.cxx.NativeLinkables;
import com.facebook.buck.file.WriteFile;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.macros.EnvironmentVariableMacroExpander;
import com.facebook.buck.rules.macros.MacroExpander;
import com.facebook.buck.rules.macros.MacroHandler;
import com.facebook.buck.util.BuckConstant;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.MoreIterables;
import com.facebook.buck.util.MoreStrings;
import com.facebook.buck.util.environment.Platform;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;
import java.util.Map;
import java.util.regex.Pattern;

public class NdkLibraryDescription implements Description<NdkLibraryDescription.Arg> {

  public static final BuildRuleType TYPE = BuildRuleType.of("ndk_library");

  private static final Flavor MAKEFILE_FLAVOR = ImmutableFlavor.of("makefile");

  private static final Pattern EXTENSIONS_REGEX =
      Pattern.compile(
              ".*\\." +
              MoreStrings.regexPatternForAny("mk", "h", "hpp", "c", "cpp", "cc", "cxx") + "$");

  public static final MacroHandler MACRO_HANDLER = new MacroHandler(
      ImmutableMap.<String, MacroExpander>of(
          "env", new EnvironmentVariableMacroExpander(Platform.detect())
      )
  );

  private final Optional<String> ndkVersion;
  private final ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms;

  public NdkLibraryDescription(
      Optional<String> ndkVersion,
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    this.ndkVersion = ndkVersion;
    this.cxxPlatforms = Preconditions.checkNotNull(cxxPlatforms);
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  private Iterable<String> escapeForMakefile(Iterable<String> args) {
    ImmutableList.Builder<String> escapedArgs = ImmutableList.builder();

    for (String arg : args) {
      String escapedArg = arg;







      escapedArg = Escaper.escapeAsShellString(escapedArg);
      for (int i = 0; i < 4; i++) {
        escapedArg = Escaper.escapeAsMakefileValueString(escapedArg);
      }



      if (arg.startsWith(BuckConstant.BUCK_OUTPUT_DIRECTORY)) {
        escapedArg = "$(BUCK_PROJECT_DIR)/" + escapedArg;
      }

      escapedArgs.add(escapedArg);
    }

    return escapedArgs.build();
  }

  private String getTargetArchAbi(NdkCxxPlatforms.TargetCpuType cpuType) {
    switch (cpuType) {
      case ARM:
        return "armeabi";
      case ARMV7:
        return "armeabi-v7a";
      case X86:
        return "x86";
      case MIPS:
        return "mips";
      default:
        throw new IllegalStateException();
    }
  }

  @VisibleForTesting
  protected static Path getGeneratedMakefilePath(BuildTarget target) {
    return BuildTargets.getGenPath(target, "Android.%s.mk");
  }


  private Pair<BuildRule, Iterable<BuildRule>> generateMakefile(
      final BuildRuleParams params,
      BuildRuleResolver resolver) {

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList.Builder<String> outputLinesBuilder = ImmutableList.builder();
    ImmutableSortedSet.Builder<BuildRule> deps = ImmutableSortedSet.naturalOrder();

    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxPlatform cxxPlatform = entry.getValue().getCxxPlatform();

      CxxPreprocessorInput cxxPreprocessorInput;
      try {


        cxxPreprocessorInput = CxxPreprocessorInput.concat(
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                params.getDeps(),
                Predicates.instanceOf(NdkLibrary.class)));
      } catch (CxxHeaders.ConflictingHeadersException e) {
        throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
      }



      deps.addAll(
          pathResolver.filterBuildRuleInputs(
              cxxPreprocessorInput.getIncludes().getPrefixHeaders()));
      deps.addAll(
          pathResolver.filterBuildRuleInputs(
              cxxPreprocessorInput.getIncludes().getNameToPathMap().values()));
      deps.addAll(resolver.getAllRules(cxxPreprocessorInput.getRules()));



      Iterable<String> ppflags = Iterables.concat(
          cxxPreprocessorInput.getPreprocessorFlags().get(CxxSource.Type.C),
          MoreIterables.zipAndConcat(
              Iterables.cycle("-I"),
              FluentIterable.from(cxxPreprocessorInput.getIncludeRoots())
                  .transform(Functions.toStringFunction())),
          MoreIterables.zipAndConcat(
              Iterables.cycle("-isystem"),
              FluentIterable.from(cxxPreprocessorInput.getIncludeRoots())
                  .transform(Functions.toStringFunction())));
      String localCflags = Joiner.on(' ').join(escapeForMakefile(ppflags));



      NativeLinkableInput nativeLinkableInput =
          NativeLinkables.getTransitiveNativeLinkableInput(
              cxxPlatform,
              params.getDeps(),
              Linker.LinkableDepType.SHARED,
              Predicates.or(
                  Predicates.instanceOf(NativeLinkable.class),
                  Predicates.instanceOf(NdkLibrary.class)),
 true);



      deps.addAll(pathResolver.filterBuildRuleInputs(nativeLinkableInput.getInputs()));



      String localLdflags = Joiner.on(' ').join(escapeForMakefile(nativeLinkableInput.getArgs()));


      if (!localCflags.isEmpty() || !localLdflags.isEmpty()) {
        NdkCxxPlatforms.TargetCpuType targetCpuType = entry.getKey();
        String targetArchAbi = getTargetArchAbi(targetCpuType);

        outputLinesBuilder.add(String.format("ifeq ($(TARGET_ARCH_ABI),%s)", targetArchAbi));
        if (!localCflags.isEmpty()) {
          outputLinesBuilder.add("BUCK_DEP_CFLAGS=" + localCflags);
        }
        if (!localLdflags.isEmpty()) {
          outputLinesBuilder.add("BUCK_DEP_LDFLAGS=" + localLdflags);
        }
        outputLinesBuilder.add("endif");
        outputLinesBuilder.add("");
      }
    }


    String ndksubst = NdkCxxPlatforms.ANDROID_NDK_ROOT;

    outputLinesBuilder.addAll(
        ImmutableList.copyOf(new String[] {

              "ifeq ($(BUCK_ALREADY_HOOKED_CFLAGS),)",
              "BUCK_ALREADY_HOOKED_CFLAGS := 1",

              "ifeq ($(filter clang%,$(NDK_TOOLCHAIN_VERSION)),)",

              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(NDK_ROOT)/=" + ndksubst + "/",
              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(abspath $(BUCK_PROJECT_DIR))/=./",


              "NDK_APP_CFLAGS += -fdebug-prefix-map=$(BUCK_PROJECT_DIR)/=./",
              "NDK_APP_CFLAGS += -fdebug-prefix-map=./=" +
              ".$(subst $(abspath $(BUCK_PROJECT_DIR)),,$(abspath $(CURDIR)))/",
              "NDK_APP_CFLAGS += -fno-record-gcc-switches",
              "ifeq ($(filter 4.6,$(TOOLCHAIN_VERSION)),)",



              "NDK_APP_CPPFLAGS += -fno-canonical-system-headers",



              "NDK_APP_CFLAGS += -gno-record-gcc-switches",
              "endif", 
              "endif", 



              "BUCK_SAVED_IMPORTS := $(__ndk_import_dirs)",
              "__ndk_import_dirs :=",
              "$(foreach __dir,$(BUCK_SAVED_IMPORTS),\\",
              "$(call import-add-path-optional,\\",
              "$(if $(filter $(abspath $(BUCK_PROJECT_DIR))%,$(__dir)),\\",
              "$(BUCK_PROJECT_DIR)$(patsubst $(abspath $(BUCK_PROJECT_DIR))%,%,$(__dir)),\\",
              "$(__dir))))",
              "endif", 
            }));

    outputLinesBuilder.add("include Android.mk");

    BuildTarget makefileTarget = BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(MAKEFILE_FLAVOR)
        .build();
    BuildRuleParams makefileParams = params.copyWithChanges(
        makefileTarget,
        Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()),
        Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));
    final Path makefilePath = getGeneratedMakefilePath(params.getBuildTarget());
    final String contents = Joiner.on(System.lineSeparator()).join(outputLinesBuilder.build());

    return new Pair<BuildRule, Iterable<BuildRule>>(
        new WriteFile(makefileParams, pathResolver, contents, makefilePath),
        deps.build());
  }

  @VisibleForTesting
  protected ImmutableSortedSet<SourcePath> findSources(
      final ProjectFilesystem filesystem,
      final Path buildRulePath) {
    final ImmutableSortedSet.Builder<SourcePath> srcs = ImmutableSortedSet.naturalOrder();

    try {
      final Path rootDirectory = filesystem.resolve(buildRulePath);
      Files.walkFileTree(
          rootDirectory,
          EnumSet.of(FileVisitOption.FOLLOW_LINKS),
 Integer.MAX_VALUE,
          new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                throws IOException {
              if (EXTENSIONS_REGEX.matcher(file.toString()).matches()) {
                srcs.add(
                    new PathSourcePath(
                        filesystem,
                        buildRulePath.resolve(rootDirectory.relativize(file))));
              }

              return super.visitFile(file, attrs);
            }
          });
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    return srcs.build();
  }

  @Override
  public <A extends Arg> NdkLibrary createBuildRule(
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {

    Pair<BuildRule, Iterable<BuildRule>> makefilePair = generateMakefile(params, resolver);
    resolver.addToIndex(makefilePair.getFirst());
    return new NdkLibrary(
        params.appendExtraDeps(
            ImmutableSortedSet.<BuildRule>naturalOrder()
                .add(makefilePair.getFirst())
                .addAll(makefilePair.getSecond())
                .build()),
        new SourcePathResolver(resolver),
        getGeneratedMakefilePath(params.getBuildTarget()),
        findSources(params.getProjectFilesystem(), params.getBuildTarget().getBasePath()),
        args.flags.get(),
        args.isAsset.or(false),
        ndkVersion,
        MACRO_HANDLER.getExpander(
            params.getBuildTarget(),
            resolver,
            params.getProjectFilesystem()));
  }

  @SuppressFieldNotInitialized
  public static class Arg {
    public Optional<ImmutableList<String>> flags;
    public Optional<Boolean> isAsset;
    public Optional<ImmutableSortedSet<BuildTarget>> deps;
  }

}

<code block>


package com.facebook.buck.ocaml;

import com.facebook.buck.cxx.CxxHeaders;
import com.facebook.buck.cxx.CxxPreprocessables;
import com.facebook.buck.cxx.CxxPreprocessorDep;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.cxx.NativeLinkableInput;
import com.facebook.buck.cxx.NativeLinkables;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.rules.coercer.OCamlSource;
import com.facebook.buck.util.Ansi;
import com.facebook.buck.util.CapturingPrintStream;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.Verbosity;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.List;


public class OCamlRuleBuilder {

  private static final Flavor OCAML_STATIC_FLAVOR = ImmutableFlavor.of("static");
  private static final Flavor OCAML_LINK_BINARY_FLAVOR = ImmutableFlavor.of("binary");

  private OCamlRuleBuilder() {
  }

  public static Function<BuildRule, ImmutableList<String>> getLibInclude(
      final boolean isBytecode) {
    return
      new Function<BuildRule, ImmutableList<String>>() {
        @Override
        public ImmutableList<String> apply(BuildRule input) {
          if (input instanceof OCamlLibrary) {
            OCamlLibrary library = (OCamlLibrary) input;
            if (isBytecode) {
                return ImmutableList.copyOf(library.getBytecodeIncludeDirs());
            } else {
              return ImmutableList.of(library.getIncludeLibDir().toString());
            }
          } else {
            return ImmutableList.of();
          }
        }
      };
  }

  public static ImmutableList<SourcePath> getInput(Iterable<OCamlSource> source) {
    return ImmutableList.copyOf(
        FluentIterable.from(source)
            .transform(
                new Function<OCamlSource, SourcePath>() {
                  @Override
                  public SourcePath apply(OCamlSource input) {
                    return input.getSource();
                  }
                })
    );
  }

  @VisibleForTesting
  protected static BuildTarget createStaticLibraryBuildTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(OCAML_STATIC_FLAVOR).build();
  }

  @VisibleForTesting
  protected static BuildTarget createOCamlLinkTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(OCAML_LINK_BINARY_FLAVOR).build();
  }

  public static AbstractBuildRule createBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    boolean noYaccOrLexSources = FluentIterable.from(srcs).transform(OCamlSource.TO_SOURCE_PATH)
        .filter(OCamlUtil.sourcePathExt(
                  pathResolver,
                  OCamlCompilables.OCAML_MLL,
                  OCamlCompilables.OCAML_MLY))
        .isEmpty();
    if (noYaccOrLexSources) {
      return createFineGrainedBuildRule(
          ocamlBuckConfig,
          params,
          resolver,
          srcs,
          isLibrary,
          argFlags,
          linkerFlags);
    } else {
      return createBulkBuildRule(
          ocamlBuckConfig,
          params,
          resolver,
          srcs,
          isLibrary,
          argFlags,
          linkerFlags);
    }
  }

  public static AbstractBuildRule createBulkBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    CxxPreprocessorInput cxxPreprocessorInputFromDeps;
    try {
      cxxPreprocessorInputFromDeps = CxxPreprocessorInput.concat(
          CxxPreprocessables.getTransitiveCxxPreprocessorInput(
              ocamlBuckConfig.getCxxPlatform(),
              FluentIterable.from(params.getDeps())
                  .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
    } catch (CxxHeaders.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> includes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(false))
        .toList();

    ImmutableList<String> bytecodeIncludes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(true))
        .toList();

    NativeLinkableInput linkableInput = NativeLinkables.getTransitiveNativeLinkableInput(
        ocamlBuckConfig.getCxxPlatform(),
        params.getDeps(),
        Linker.LinkableDepType.STATIC,
 false);

    ImmutableList<OCamlLibrary> ocamlInput = OCamlUtil.getTransitiveOCamlInput(params.getDeps());

    ImmutableSortedSet.Builder<BuildRule> allDepsBuilder = ImmutableSortedSet.naturalOrder();
    allDepsBuilder.addAll(pathResolver.filterBuildRuleInputs(getInput(srcs)));
    allDepsBuilder.addAll(pathResolver.filterBuildRuleInputs(linkableInput.getInputs()));
    for (OCamlLibrary library : ocamlInput) {
      allDepsBuilder.addAll(library.getCompileDeps());
      allDepsBuilder.addAll(library.getBytecodeCompileDeps());
    }
    ImmutableSortedSet<BuildRule> allDeps = allDepsBuilder.build();

    BuildTarget buildTarget =
        isLibrary ? createStaticLibraryBuildTarget(params.getBuildTarget())
            : createOCamlLinkTarget(params.getBuildTarget());
    final BuildRuleParams compileParams = params.copyWithChanges(
        buildTarget,
 Suppliers.ofInstance(allDeps),
 Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));

    ImmutableList.Builder<String> flagsBuilder = ImmutableList.builder();
    flagsBuilder.addAll(argFlags);

    ImmutableSortedSet.Builder<BuildRule> compileDepsBuilder = ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeCompileDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeLinkDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    for (OCamlLibrary library : ocamlInput) {
      compileDepsBuilder.addAll(library.getCompileDeps());
      bytecodeCompileDepsBuilder.addAll(library.getBytecodeCompileDeps());
      bytecodeLinkDepsBuilder.addAll(library.getBytecodeLinkDeps());
    }
    OCamlBuildContext ocamlContext =
        OCamlBuildContext.builder(ocamlBuckConfig)
            .setFlags(flagsBuilder.build())
            .setIncludes(includes)
            .setBytecodeIncludes(bytecodeIncludes)
            .setOCamlInput(ocamlInput)
            .setLinkableInput(linkableInput)
            .setBuildTarget(buildTarget)
            .setLibrary(isLibrary)
            .setCxxPreprocessorInput(cxxPreprocessorInputFromDeps)
            .setInput(pathResolver.getAllPaths(getInput(srcs)))
            .setCompileDeps(compileDepsBuilder.build())
            .setBytecodeCompileDeps(bytecodeCompileDepsBuilder.build())
            .setBytecodeLinkDeps(bytecodeLinkDepsBuilder.build())
            .build();

    final OCamlBuild ocamlLibraryBuild = new OCamlBuild(
        compileParams,
        pathResolver,
        ocamlContext,
        ocamlBuckConfig.getCCompiler(),
        ocamlBuckConfig.getCxxCompiler());
    resolver.addToIndex(ocamlLibraryBuild);

    if (isLibrary) {
      return new OCamlStaticLibrary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .add(ocamlLibraryBuild)
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          compileParams,
          linkerFlags,
          FluentIterable.from(srcs)
              .transform(OCamlSource.TO_SOURCE_PATH)
              .transform(pathResolver.getPathFunction())
              .filter(OCamlUtil.ext(OCamlCompilables.OCAML_C))
              .transform(ocamlContext.toCOutput())
              .transform(
                  SourcePaths.getToBuildTargetSourcePath(
                      params.getProjectFilesystem(),
                      compileParams.getBuildTarget()))
              .toList(),
          ocamlContext,
          ocamlLibraryBuild,
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild),
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild),
          ImmutableSortedSet.<BuildRule>of(ocamlLibraryBuild));
    } else {
      return new OCamlBinary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .add(ocamlLibraryBuild)
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          ocamlLibraryBuild);
    }
  }

  public static AbstractBuildRule createFineGrainedBuildRule(
      OCamlBuckConfig ocamlBuckConfig,
      final BuildRuleParams params,
      BuildRuleResolver resolver,
      ImmutableList<OCamlSource> srcs,
      boolean isLibrary,
      ImmutableList<String> argFlags,
      final ImmutableList<String> linkerFlags) {
    CxxPreprocessorInput cxxPreprocessorInputFromDeps;
    try {
      cxxPreprocessorInputFromDeps = CxxPreprocessorInput.concat(
          CxxPreprocessables.getTransitiveCxxPreprocessorInput(
              ocamlBuckConfig.getCxxPlatform(),
              FluentIterable.from(params.getDeps())
                  .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
    } catch (CxxHeaders.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> includes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(false))
        .toList();

    ImmutableList<String> bytecodeIncludes = FluentIterable.from(params.getDeps())
        .transformAndConcat(getLibInclude(true))
        .toList();

    NativeLinkableInput linkableInput = NativeLinkables.getTransitiveNativeLinkableInput(
        ocamlBuckConfig.getCxxPlatform(),
        params.getDeps(),
        Linker.LinkableDepType.STATIC,
 false);

    ImmutableList<OCamlLibrary> ocamlInput = OCamlUtil.getTransitiveOCamlInput(params.getDeps());

    ImmutableList<SourcePath> allInputs =
        ImmutableList.<SourcePath>builder()
            .addAll(getInput(srcs))
            .addAll(linkableInput.getInputs())
            .build();

    BuildTarget buildTarget =
        isLibrary ? createStaticLibraryBuildTarget(params.getBuildTarget())
            : createOCamlLinkTarget(params.getBuildTarget());

    final BuildRuleParams compileParams = params.copyWithChanges(
        buildTarget,
 Suppliers.ofInstance(
            ImmutableSortedSet.copyOf(pathResolver.filterBuildRuleInputs(allInputs))),
 Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));

    ImmutableList.Builder<String> flagsBuilder = ImmutableList.builder();
    flagsBuilder.addAll(argFlags);

    ImmutableSortedSet.Builder<BuildRule> compileDepsBuilder = ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeCompileDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    ImmutableSortedSet.Builder<BuildRule> bytecodeLinkDepsBuilder =
        ImmutableSortedSet.naturalOrder();
    for (OCamlLibrary library : ocamlInput) {
      compileDepsBuilder.addAll(library.getCompileDeps());
      bytecodeCompileDepsBuilder.addAll(library.getBytecodeCompileDeps());
      bytecodeLinkDepsBuilder.addAll(library.getBytecodeLinkDeps());
    }
    OCamlBuildContext ocamlContext =
        OCamlBuildContext.builder(ocamlBuckConfig)
            .setFlags(flagsBuilder.build())
            .setIncludes(includes)
            .setBytecodeIncludes(bytecodeIncludes)
            .setOCamlInput(ocamlInput)
            .setLinkableInput(linkableInput)
            .setBuildTarget(buildTarget)
            .setLibrary(isLibrary)
            .setCxxPreprocessorInput(cxxPreprocessorInputFromDeps)
            .setInput(pathResolver.getAllPaths(getInput(srcs)))
            .setCompileDeps(compileDepsBuilder.build())
            .setBytecodeCompileDeps(bytecodeCompileDepsBuilder.build())
            .setBytecodeLinkDeps(bytecodeLinkDepsBuilder.build())
            .build();

    File baseDir = params.getProjectFilesystem().getRootPath().toAbsolutePath().toFile();
    ImmutableMap<Path, ImmutableList<Path>> mlInput = getMLInputWithDeps(
        baseDir,
        ocamlContext);

    ImmutableList<SourcePath> cInput = getCInput(pathResolver, getInput(srcs));

    OCamlBuildRulesGenerator generator = new OCamlBuildRulesGenerator(
        compileParams,
        pathResolver,
        resolver,
        ocamlContext,
        mlInput,
        cInput,
        ocamlBuckConfig.getCCompiler(),
        ocamlBuckConfig.getCxxCompiler());

    OCamlGeneratedBuildRules result = generator.generate();

    if (isLibrary) {
      return new OCamlStaticLibrary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .addAll(result.getRules())
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          compileParams,
          linkerFlags,
          result.getObjectFiles(),
          ocamlContext,
          result.getRules().get(0),
          result.getCompileDeps(),
          result.getBytecodeCompileDeps(),
          ImmutableSortedSet.<BuildRule>naturalOrder()
              .add(result.getBytecodeLink())
              .addAll(pathResolver.filterBuildRuleInputs(result.getObjectFiles()))
              .build());
    } else {
      return new OCamlBinary(
          params.copyWithDeps(
              Suppliers.ofInstance(
                  ImmutableSortedSet.<BuildRule>naturalOrder()
                      .addAll(params.getDeclaredDeps())
                      .addAll(result.getRules())
                      .build()),
              Suppliers.ofInstance(params.getExtraDeps())),
          pathResolver,
          result.getRules().get(0));
    }
  }

  private static ImmutableList<SourcePath> getCInput(
      SourcePathResolver resolver,
      ImmutableList<SourcePath> input) {
    return FluentIterable
        .from(input)
        .filter(OCamlUtil.sourcePathExt(resolver, OCamlCompilables.OCAML_C))
        .toList();
  }

  private static ImmutableMap<Path, ImmutableList<Path>> getMLInputWithDeps(
      File baseDir,
      OCamlBuildContext ocamlContext) {
    OCamlDepToolStep depToolStep = new OCamlDepToolStep(
        ocamlContext.getOcamlDepTool().get(),
        ocamlContext.getMLInput(),
        ocamlContext.getIncludeFlags( false,  true));
    ImmutableList<String> cmd = depToolStep.getShellCommand(null);
    Optional<String> depsString;
    try {
      depsString = executeProcessAndGetStdout(baseDir, cmd);
    } catch (IOException e) {
      throw new HumanReadableException(
          e,
          "Unable to execute ocamldep due to io error: %s",
          Joiner.on(" ").join(cmd));
    } catch (InterruptedException e) {
      throw new HumanReadableException(e,
          "Unable to calculate dependencies. ocamldep is interrupted: %s",
          Joiner.on(" ").join(cmd));
    }
    if (depsString.isPresent()) {
      OCamlDependencyGraphGenerator graphGenerator = new OCamlDependencyGraphGenerator();
      return filterCurrentRuleInput(
          ocamlContext.getMLInput(),
          graphGenerator.generateDependencyMap(depsString.get()));
    } else {
      throw new HumanReadableException("ocamldep execution failed");
    }
  }

  private static ImmutableMap<Path, ImmutableList<Path>> filterCurrentRuleInput(
      final List<Path> mlInput,
      ImmutableMap<Path, ImmutableList<Path>> deps) {
    ImmutableMap.Builder<Path, ImmutableList<Path>> builder = ImmutableMap.builder();
    for (ImmutableMap.Entry<Path, ImmutableList<Path>> entry : deps.entrySet()) {
      if (mlInput.contains(entry.getKey())) {
        builder.put(entry.getKey(),
            FluentIterable.from(entry.getValue())
              .filter(new Predicate<Path>() {
                        @Override
                        public boolean apply(Path input) {
                          return mlInput.contains(input);
                        }
                      }).toList()
            );
      }
    }
    return builder.build();
  }

  private static Optional<String> executeProcessAndGetStdout(
      File baseDir,
      ImmutableList<String> cmd) throws IOException, InterruptedException {
    CapturingPrintStream stdout = new CapturingPrintStream();
    CapturingPrintStream stderr = new CapturingPrintStream();

    ImmutableSet.Builder<ProcessExecutor.Option> options = ImmutableSet.builder();
    options.add(ProcessExecutor.Option.EXPECTING_STD_OUT);
    Console console = new Console(Verbosity.SILENT, stdout, stderr, Ansi.withoutTty());
    ProcessExecutor exe = new ProcessExecutor(console);
    ProcessBuilder processBuilder = new ProcessBuilder(cmd);
    processBuilder.directory(baseDir);
    ProcessExecutor.Result result = exe.execute(
        processBuilder.start(),
        options.build(),
 Optional.<String>absent(),
 Optional.<Long>absent(),
 Optional.<Function<Process, Void>>absent());
    if (result.getExitCode() != 0) {
      throw new HumanReadableException(stderr.getContentsAsString(StandardCharsets.UTF_8));
    }

    return result.getStdout();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.model.Flavored;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

public class CxxLibraryDescription implements
    Description<CxxLibraryDescription.Arg>,
    ImplicitDepsInferringDescription<CxxLibraryDescription.Arg>,
    Flavored {

  public enum Type {
    HEADERS,
    EXPORTED_HEADERS,
    SHARED,
    STATIC_PIC,
    STATIC,
    MACH_O_BUNDLE,
  }

  public static final BuildRuleType TYPE = BuildRuleType.of("cxx_library");

  private static final FlavorDomain<Type> LIBRARY_TYPE =
      new FlavorDomain<>(
          "C/C++ Library Type",
          ImmutableMap.<Flavor, Type>builder()
              .put(CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR, Type.HEADERS)
              .put(
                  CxxDescriptionEnhancer.EXPORTED_HEADER_SYMLINK_TREE_FLAVOR,
                  Type.EXPORTED_HEADERS)
              .put(CxxDescriptionEnhancer.SHARED_FLAVOR, Type.SHARED)
              .put(CxxDescriptionEnhancer.STATIC_PIC_FLAVOR, Type.STATIC_PIC)
              .put(CxxDescriptionEnhancer.STATIC_FLAVOR, Type.STATIC)
              .put(CxxDescriptionEnhancer.MACH_O_BUNDLE_FLAVOR, Type.MACH_O_BUNDLE)
              .build());

  private final CxxBuckConfig cxxBuckConfig;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;
  private final CxxPreprocessMode preprocessMode;

  public CxxLibraryDescription(
      CxxBuckConfig cxxBuckConfig,
      FlavorDomain<CxxPlatform> cxxPlatforms,
      CxxPreprocessMode preprocessMode) {
    this.cxxBuckConfig = cxxBuckConfig;
    this.cxxPlatforms = cxxPlatforms;
    this.preprocessMode = preprocessMode;
  }

  @Override
  public boolean hasFlavors(ImmutableSet<Flavor> flavors) {
    return cxxPlatforms.containsAnyOf(flavors) ||
        flavors.contains(CxxCompilationDatabase.COMPILATION_DATABASE);
  }

  private static ImmutableCollection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<Path> frameworkSearchPaths) {



    BuildTarget rawTarget =
        params.getBuildTarget()
            .withoutFlavors(
                ImmutableSet.<Flavor>builder()
                    .addAll(LIBRARY_TYPE.getFlavors())
                    .add(cxxPlatform.getFlavor())
                    .build());
    Optional<BuildRule> rawRule = ruleResolver.getRuleOptional(rawTarget);
    if (rawRule.isPresent()) {
      CxxLibrary rule = (CxxLibrary) rawRule.get();
      return rule.getTransitiveCxxPreprocessorInput(cxxPlatform, HeaderVisibility.PUBLIC).values();
    }


    SymlinkTree symlinkTree =
        CxxDescriptionEnhancer.requireHeaderSymlinkTree(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
 false,
            ImmutableMap.<String, SourcePath>of(),
            ImmutableMap.<String, SourcePath>of(),
            exportedHeaders,
            HeaderVisibility.PUBLIC);
    Map<BuildTarget, CxxPreprocessorInput> input = Maps.newLinkedHashMap();
    input.put(
        params.getBuildTarget(),
        CxxPreprocessorInput.builder()
            .addRules(symlinkTree.getBuildTarget())
            .putAllPreprocessorFlags(exportedPreprocessorFlags)
            .setIncludes(
                CxxHeaders.builder()
                    .putAllNameToPathMap(symlinkTree.getLinks())
                    .putAllFullNameToPathMap(symlinkTree.getFullLinks())
                    .build())
            .addIncludeRoots(symlinkTree.getRoot())
            .addAllFrameworkRoots(frameworkSearchPaths)
            .build());
    for (BuildRule rule : params.getDeps()) {
      if (rule instanceof CxxPreprocessorDep) {
        input.putAll(
            ((CxxPreprocessorDep) rule).getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                HeaderVisibility.PUBLIC));
      }
    }
    return ImmutableList.copyOf(input.values());
  }

  private static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requireObjects(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {

    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.requireLexYaccSources(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
            lexSources,
            yaccSources);

    SymlinkTree headerSymlinkTree =
        CxxDescriptionEnhancer.requireHeaderSymlinkTree(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
 true,
            lexSources,
            yaccSources,
            headers,
            HeaderVisibility.PRIVATE);

    ImmutableList<CxxPreprocessorInput> cxxPreprocessorInputFromDependencies =
        CxxDescriptionEnhancer.collectCxxPreprocessorInput(
            params,
            cxxPlatform,
            preprocessorFlags,
            prefixHeaders,
            ImmutableList.of(headerSymlinkTree),
            ImmutableList.<Path>of(),
            getTransitiveCxxPreprocessorInput(
                params,
                ruleResolver,
                pathResolver,
                cxxPlatform,
                exportedPreprocessorFlags,
                exportedHeaders,
                frameworkSearchPaths));

    ImmutableMap<String, CxxSource> allSources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(sources)
            .putAll(lexYaccSources.getCxxSources())
            .build();


    return CxxSourceRuleFactory.requirePreprocessAndCompileRules(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        cxxPreprocessorInputFromDependencies,
        compilerFlags,
        preprocessMode,
        allSources,
        pic);
  }


  private static BuildRule createStaticLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        pic);


    BuildTarget staticTarget =
        CxxDescriptionEnhancer.createStaticLibraryBuildTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            pic);
    Path staticLibraryPath =
        CxxDescriptionEnhancer.getStaticLibraryPath(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            pic);
    return Archives.createArchiveRule(
        pathResolver,
        staticTarget,
        params,
        cxxPlatform.getAr(),
        cxxPlatform.getArExpectedGlobalHeader(),
        staticLibraryPath,
        ImmutableList.copyOf(objects.values()));
  }


  private static BuildRule createSharedLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<String> linkerFlags,
      ImmutableList<Path> frameworkSearchPaths,
      Optional<String> soname,
      CxxPreprocessMode preprocessMode,
      Optional<Linker.CxxRuntimeType> cxxRuntimeType,
      Linker.LinkType linkType,
      Linker.LinkableDepType linkableDepType,
      Optional<SourcePath> bundleLoader) {


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        CxxSourceRuleFactory.PicType.PIC);


    BuildTarget sharedTarget =
        CxxDescriptionEnhancer.createSharedLibraryBuildTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor());
    String sharedLibrarySoname =
        soname.or(
            CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
                params.getBuildTarget(), cxxPlatform));
    Path sharedLibraryPath = CxxDescriptionEnhancer.getSharedLibraryPath(
        params.getBuildTarget(),
        sharedLibrarySoname,
        cxxPlatform);
    ImmutableList.Builder<String> extraCxxLdFlagsBuilder = ImmutableList.builder();
    extraCxxLdFlagsBuilder.addAll(
        MoreIterables.zipAndConcat(
            Iterables.cycle("-F"),
            Iterables.transform(frameworkSearchPaths, Functions.toStringFunction())));
    ImmutableList<String> extraCxxLdFlags = extraCxxLdFlagsBuilder.build();

    return CxxLinkableEnhancer.createCxxLinkableBuildRule(
            cxxPlatform,
            params,
            pathResolver,
            extraCxxLdFlags,
            linkerFlags,
            sharedTarget,
            linkType,
            Optional.of(sharedLibrarySoname),
            sharedLibraryPath,
            objects.values(),
            linkableDepType,
            params.getDeps(),
            cxxRuntimeType,
            bundleLoader);
  }


  private static CxxCompilationDatabase createCompilationDatabase(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableMultimap<CxxSource.Type, String> exportedPreprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableMap<Path, SourcePath> headers,
      ImmutableMap<Path, SourcePath> exportedHeaders,
      ImmutableList<String> compilerFlags,
      ImmutableMap<String, CxxSource> sources,
      ImmutableList<Path> frameworkSearchPaths,
      CxxPreprocessMode preprocessMode) {
    BuildRuleParams paramsWithoutCompilationDatabaseFlavor = CxxCompilationDatabase
        .paramsWithoutCompilationDatabaseFlavor(params);



    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects = requireObjects(
        paramsWithoutCompilationDatabaseFlavor,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        lexSources,
        yaccSources,
        preprocessorFlags,
        exportedPreprocessorFlags,
        prefixHeaders,
        headers,
        exportedHeaders,
        compilerFlags,
        sources,
        frameworkSearchPaths,
        preprocessMode,
        CxxSourceRuleFactory.PicType.PIC);

    return CxxCompilationDatabase.createCompilationDatabase(
        params,
        pathResolver,
        preprocessMode,
        objects.keySet());
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  public static Arg createEmptyConstructorArg() {
    Arg arg = new Arg();
    arg.deps = Optional.of(ImmutableSortedSet.<BuildTarget>of());
    arg.srcs = Optional.of(
        Either.<ImmutableList<SourceWithFlags>, ImmutableMap<String, SourceWithFlags>>ofLeft(
            ImmutableList.<SourceWithFlags>of()));
    arg.prefixHeaders = Optional.of(ImmutableList.<SourcePath>of());
    arg.headers = Optional.of(
        Either.<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>ofLeft(
            ImmutableList.<SourcePath>of()));
    arg.exportedHeaders = Optional.of(
        Either.<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>ofLeft(
            ImmutableList.<SourcePath>of()));
    arg.compilerFlags = Optional.of(ImmutableList.<String>of());
    arg.platformCompilerFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedPreprocessorFlags = Optional.of(ImmutableList.<String>of());
    arg.exportedPlatformPreprocessorFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedLangPreprocessorFlags = Optional.of(
        ImmutableMap.<CxxSource.Type, ImmutableList<String>>of());
    arg.preprocessorFlags = Optional.of(ImmutableList.<String>of());
    arg.platformPreprocessorFlags =
        Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.langPreprocessorFlags = Optional.of(
        ImmutableMap.<CxxSource.Type, ImmutableList<String>>of());
    arg.linkerFlags = Optional.of(ImmutableList.<String>of());
    arg.exportedLinkerFlags = Optional.of(ImmutableList.<String>of());
    arg.platformLinkerFlags = Optional.of(ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.exportedPlatformLinkerFlags = Optional.of(
        ImmutableList.<Pair<String, ImmutableList<String>>>of());
    arg.cxxRuntimeType = Optional.absent();
    arg.forceStatic = Optional.absent();
    arg.linkWhole = Optional.absent();
    arg.lexSrcs = Optional.of(ImmutableList.<SourcePath>of());
    arg.yaccSrcs = Optional.of(ImmutableList.<SourcePath>of());
    arg.headerNamespace = Optional.absent();
    arg.soname = Optional.absent();
    arg.frameworkSearchPaths = Optional.of(ImmutableList.<Path>of());
    arg.tests = Optional.of(ImmutableSortedSet.<BuildTarget>of());
    arg.supportedPlatformsRegex = Optional.absent();
    return arg;
  }


  public static <A extends Arg> SymlinkTree createHeaderSymlinkTreeBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args) {
    return CxxDescriptionEnhancer.createHeaderSymlinkTree(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
 true,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        HeaderVisibility.PRIVATE);
  }


  public static <A extends Arg> SymlinkTree createExportedHeaderSymlinkTreeBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args) {
    return CxxDescriptionEnhancer.createHeaderSymlinkTree(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
 false,
        ImmutableMap.<String, SourcePath>of(),
        ImmutableMap.<String, SourcePath>of(),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        HeaderVisibility.PUBLIC);
  }


  public static <A extends Arg> BuildRule createStaticLibraryBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode,
      CxxSourceRuleFactory.PicType pic) {
    return createStaticLibrary(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        args.frameworkSearchPaths.get(),
        preprocessMode,
        pic);
  }


  public static <A extends Arg> BuildRule createSharedLibraryBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode,
      Linker.LinkType linkType,
      Linker.LinkableDepType linkableDepType,
      Optional<SourcePath> bundleLoader) {
    ImmutableList.Builder<String> linkerFlags = ImmutableList.builder();

    linkerFlags.addAll(
        CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()));

    linkerFlags.addAll(
        CxxFlags.getFlags(
            args.exportedLinkerFlags,
            args.exportedPlatformLinkerFlags,
            cxxPlatform.getFlavor()));

    return createSharedLibrary(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        linkerFlags.build(),
        args.frameworkSearchPaths.get(),
        args.soname,
        preprocessMode,
        args.cxxRuntimeType,
        linkType,
        linkableDepType,
        bundleLoader);
  }


  public static <A extends Arg> CxxCompilationDatabase createCompilationDatabaseBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      A args,
      CxxPreprocessMode preprocessMode) {
    return createCompilationDatabase(
        params,
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        CxxDescriptionEnhancer.parseLexSources(params, resolver, args),
        CxxDescriptionEnhancer.parseYaccSources(params, resolver, args),
        CxxFlags.getLanguageFlags(
            args.preprocessorFlags,
            args.platformPreprocessorFlags,
            args.langPreprocessorFlags,
            cxxPlatform.getFlavor()),
        CxxFlags.getLanguageFlags(
            args.exportedPreprocessorFlags,
            args.exportedPlatformPreprocessorFlags,
            args.exportedLangPreprocessorFlags,
            cxxPlatform.getFlavor()),
        args.prefixHeaders.get(),
        CxxDescriptionEnhancer.parseHeaders(params, resolver, args),
        CxxDescriptionEnhancer.parseExportedHeaders(params, resolver, args),
        CxxFlags.getFlags(
            args.compilerFlags,
            args.platformCompilerFlags,
            cxxPlatform.getFlavor()),
        CxxDescriptionEnhancer.parseCxxSources(params, resolver, args),
        args.frameworkSearchPaths.get(),
        preprocessMode);
  }

  public static TypeAndPlatform getTypeAndPlatform(
      BuildTarget buildTarget,
      FlavorDomain<CxxPlatform> platforms) {


    Optional<Map.Entry<Flavor, Type>> type;
    Optional<Map.Entry<Flavor, CxxPlatform>> platform;
    try {
      type = LIBRARY_TYPE.getFlavorAndValue(
          ImmutableSet.copyOf(buildTarget.getFlavors()));
      platform = platforms.getFlavorAndValue(
          ImmutableSet.copyOf(buildTarget.getFlavors()));
    } catch (FlavorDomainException e) {
      throw new HumanReadableException("%s: %s", buildTarget, e.getMessage());
    }
    return TypeAndPlatform.of(type, platform);
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      A args) {
    TypeAndPlatform typeAndPlatform = getTypeAndPlatform(
        params.getBuildTarget(),
        cxxPlatforms);
    return createBuildRule(
        params,
        resolver,
        args,
        typeAndPlatform,
        Optional.<Linker.LinkableDepType>absent(),
        Optional.<SourcePath>absent());
  }

  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      final A args,
      TypeAndPlatform typeAndPlatform,
      Optional<Linker.LinkableDepType> linkableDepType,
      Optional<SourcePath> bundleLoader) {
    Optional<Map.Entry<Flavor, CxxPlatform>> platform = typeAndPlatform.getPlatform();

    if (params.getBuildTarget().getFlavors()
        .contains(CxxCompilationDatabase.COMPILATION_DATABASE)) {

      return createCompilationDatabaseBuildRule(
          params,
          resolver,
          platform.isPresent()
              ? platform.get().getValue()
              : DefaultCxxPlatforms.build(cxxBuckConfig),
          args,
          preprocessMode);
    }


    Optional<Map.Entry<Flavor, Type>> type = typeAndPlatform.getType();



    if (type.isPresent() && platform.isPresent()) {
      Set<Flavor> flavors = Sets.newHashSet(params.getBuildTarget().getFlavors());
      flavors.remove(type.get().getKey());
      BuildTarget target = BuildTarget
          .builder(params.getBuildTarget().getUnflavoredBuildTarget())
          .addAllFlavors(flavors)
          .build();
      BuildRuleParams typeParams =
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(params.getDeclaredDeps()),
              Suppliers.ofInstance(params.getExtraDeps()));
      if (type.get().getValue().equals(Type.HEADERS)) {
        return createHeaderSymlinkTreeBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args);
      } else if (type.get().getValue().equals(Type.EXPORTED_HEADERS)) {
          return createExportedHeaderSymlinkTreeBuildRule(
              typeParams,
              resolver,
              platform.get().getValue(),
              args);
      } else if (type.get().getValue().equals(Type.SHARED)) {
        return createSharedLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            Linker.LinkType.SHARED,
            linkableDepType.or(Linker.LinkableDepType.SHARED),
            Optional.<SourcePath>absent());
      } else if (type.get().getValue().equals(Type.MACH_O_BUNDLE)) {
        return createSharedLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            Linker.LinkType.MACH_O_BUNDLE,
            linkableDepType.or(Linker.LinkableDepType.SHARED),
            bundleLoader);
      } else if (type.get().getValue().equals(Type.STATIC)) {
        return createStaticLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            CxxSourceRuleFactory.PicType.PDC);
      } else {
        return createStaticLibraryBuildRule(
            typeParams,
            resolver,
            platform.get().getValue(),
            args,
            preprocessMode,
            CxxSourceRuleFactory.PicType.PIC);
      }
    }


    boolean hasObjects = false;
    if (args.srcs.isPresent()) {
      Either<ImmutableList<SourceWithFlags>, ImmutableMap<String, SourceWithFlags>> either =
          args.srcs.get();
      if (either.isLeft()) {
        hasObjects = !either.getLeft().isEmpty();
      } else {
        hasObjects = !either.getRight().isEmpty();
      }
    }
    hasObjects |=
          !args.lexSrcs.get().isEmpty() ||
          !args.yaccSrcs.get().isEmpty();



    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return new CxxLibrary(
        params,
        resolver,
        pathResolver,
        !hasObjects,
        new Function<CxxPlatform, ImmutableMultimap<CxxSource.Type, String>>() {
          @Override
          public ImmutableMultimap<CxxSource.Type, String> apply(CxxPlatform input) {
            return CxxFlags.getLanguageFlags(
                args.exportedPreprocessorFlags,
                args.exportedPlatformPreprocessorFlags,
                args.exportedLangPreprocessorFlags,
                input.getFlavor());
          }
        },
        new Function<CxxPlatform, ImmutableList<String>>() {
          @Override
          public ImmutableList<String> apply(CxxPlatform input) {
            return CxxFlags.getFlags(
                args.exportedLinkerFlags,
                args.exportedPlatformLinkerFlags,
                input.getFlavor());
          }
        },
        args.supportedPlatformsRegex,
        args.frameworkSearchPaths.get(),
        args.forceStatic.or(false) ? CxxLibrary.Linkage.STATIC : CxxLibrary.Linkage.ANY,
        args.linkWhole.or(false),
        args.soname,
        args.tests.get());
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      Arg constructorArg) {
    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();

    if (constructorArg.lexSrcs.isPresent() && !constructorArg.lexSrcs.get().isEmpty()) {
      deps.add(cxxBuckConfig.getLexDep());
    }

    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends CxxConstructorArg {
    public Optional<Either<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>>
        exportedHeaders;
    public Optional<ImmutableList<String>> exportedPreprocessorFlags;
    public Optional<ImmutableList<Pair<String, ImmutableList<String>>>>
        exportedPlatformPreprocessorFlags;
    public Optional<ImmutableMap<CxxSource.Type, ImmutableList<String>>>
        exportedLangPreprocessorFlags;
    public Optional<ImmutableList<String>> exportedLinkerFlags;
    public Optional<ImmutableList<Pair<String, ImmutableList<String>>>>
        exportedPlatformLinkerFlags;
    public Optional<String> supportedPlatformsRegex;
    public Optional<String> soname;
    public Optional<Boolean> forceStatic;
    public Optional<Boolean> linkWhole;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.FlavorDomain;
import com.facebook.buck.model.FlavorDomainException;
import com.facebook.buck.python.PythonUtil;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRuleType;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.ImplicitDepsInferringDescription;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.infer.annotation.SuppressFieldNotInitialized;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.nio.file.Path;
import java.util.Map;

public class CxxPythonExtensionDescription implements
    Description<CxxPythonExtensionDescription.Arg>,
    ImplicitDepsInferringDescription<CxxPythonExtensionDescription.Arg> {

  private enum Type {
    EXTENSION,
  }

  private static final FlavorDomain<Type> LIBRARY_TYPE =
      new FlavorDomain<>(
          "C/C++ Library Type",
          ImmutableMap.of(
              CxxDescriptionEnhancer.SHARED_FLAVOR, Type.EXTENSION));

  public static final BuildRuleType TYPE = BuildRuleType.of("cxx_python_extension");

  private final CxxBuckConfig cxxBuckConfig;
  private final FlavorDomain<CxxPlatform> cxxPlatforms;

  public CxxPythonExtensionDescription(
      CxxBuckConfig cxxBuckConfig,
      FlavorDomain<CxxPlatform> cxxPlatforms) {
    this.cxxBuckConfig = cxxBuckConfig;
    this.cxxPlatforms = cxxPlatforms;
  }

  @Override
  public Arg createUnpopulatedConstructorArg() {
    return new Arg();
  }

  @VisibleForTesting
  protected BuildTarget getExtensionTarget(BuildTarget target, Flavor platform) {
    return CxxDescriptionEnhancer.createSharedLibraryBuildTarget(target, platform);
  }

  @VisibleForTesting
  protected String getExtensionName(BuildTarget target) {

    return String.format("%s.so", target.getShortName());
  }

  @VisibleForTesting
  protected Path getExtensionPath(BuildTarget target, Flavor platform) {
    return BuildTargets.getGenPath(getExtensionTarget(target, platform), "%s")
        .resolve(getExtensionName(target));
  }

  private <A extends Arg> BuildRule createExtensionBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      CxxPlatform cxxPlatform,
      A args) {
    SourcePathResolver pathResolver = new SourcePathResolver(ruleResolver);


    ImmutableMap<String, CxxSource> srcs =
        CxxDescriptionEnhancer.parseCxxSources(params, ruleResolver, args);
    ImmutableMap<Path, SourcePath> headers =
        CxxDescriptionEnhancer.parseHeaders(
            params,
            ruleResolver,
            args);
    ImmutableMap<String, SourcePath> lexSrcs =
        CxxDescriptionEnhancer.parseLexSources(params, ruleResolver, args);
    ImmutableMap<String, SourcePath> yaccSrcs =
        CxxDescriptionEnhancer.parseYaccSources(params, ruleResolver, args);

    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.createLexYaccBuildRules(
            params,
            ruleResolver,
            cxxPlatform,
            ImmutableList.<String>of(),
            lexSrcs,
            ImmutableList.<String>of(),
            yaccSrcs);



    SymlinkTree headerSymlinkTree = CxxDescriptionEnhancer.requireHeaderSymlinkTree(
        params,
        ruleResolver,
        new SourcePathResolver(ruleResolver),
        cxxPlatform,
 true,
        lexSrcs,
        yaccSrcs,
        headers,
        HeaderVisibility.PRIVATE);
    ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput =
        CxxDescriptionEnhancer.collectCxxPreprocessorInput(
            params,
            cxxPlatform,
            CxxFlags.getLanguageFlags(
                args.preprocessorFlags,
                args.platformPreprocessorFlags,
                args.langPreprocessorFlags,
                cxxPlatform.getFlavor()),
            args.prefixHeaders.get(),
            ImmutableList.of(headerSymlinkTree),
            ImmutableList.<Path>of(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                params.getDeps()));

    ImmutableMap<String, CxxSource> allSources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(srcs)
            .putAll(lexYaccSources.getCxxSources())
            .build();


    ImmutableMap<CxxPreprocessAndCompile, SourcePath> picObjects =
        CxxSourceRuleFactory.requirePreprocessAndCompileRules(
            params,
            ruleResolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            CxxFlags.getFlags(
                args.compilerFlags,
                args.platformCompilerFlags,
                cxxPlatform.getFlavor()),
            cxxBuckConfig.getPreprocessMode(),
            allSources,
            CxxSourceRuleFactory.PicType.PIC);


    String extensionName = getExtensionName(params.getBuildTarget());
    Path extensionPath = getExtensionPath(params.getBuildTarget(), cxxPlatform.getFlavor());
    return CxxLinkableEnhancer.createCxxLinkableBuildRule(
        cxxPlatform,
        params,
        pathResolver,
 ImmutableList.<String>of(),
 CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()),
        getExtensionTarget(params.getBuildTarget(), cxxPlatform.getFlavor()),
        Linker.LinkType.SHARED,
        Optional.of(extensionName),
        extensionPath,
        picObjects.values(),
        Linker.LinkableDepType.SHARED,
        params.getDeps(),
        args.cxxRuntimeType,
        Optional.<SourcePath>absent());
  }

  @Override
  public <A extends Arg> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      A args) {



    Optional<Map.Entry<Flavor, Type>> type;
    Optional<Map.Entry<Flavor, CxxPlatform>> platform;
    try {
      type = LIBRARY_TYPE.getFlavorAndValue(
          ImmutableSet.copyOf(params.getBuildTarget().getFlavors()));
      platform = cxxPlatforms.getFlavorAndValue(
          ImmutableSet.copyOf(params.getBuildTarget().getFlavors()));
    } catch (FlavorDomainException e) {
      throw new HumanReadableException("%s: %s", params.getBuildTarget(), e.getMessage());
    }




    if (type.isPresent()) {
      Preconditions.checkState(type.get().getValue() == Type.EXTENSION);
      Preconditions.checkState(platform.isPresent());
      return createExtensionBuildRule(params, ruleResolver, platform.get().getValue(), args);
    }



    SourcePathResolver pathResolver = new SourcePathResolver(ruleResolver);
    Path baseModule = PythonUtil.getBasePath(params.getBuildTarget(), args.baseModule);
    return new CxxPythonExtension(
        params,
        ruleResolver,
        pathResolver,
        baseModule.resolve(getExtensionName(params.getBuildTarget())));
  }

  @Override
  public BuildRuleType getBuildRuleType() {
    return TYPE;
  }

  @Override
  public Iterable<BuildTarget> findDepsForTargetFromConstructorArgs(
      BuildTarget buildTarget,
      Arg constructorArg) {
    ImmutableSet.Builder<BuildTarget> deps = ImmutableSet.builder();

    deps.add(cxxBuckConfig.getPythonDep());

    if (constructorArg.lexSrcs.isPresent() && !constructorArg.lexSrcs.get().isEmpty()) {
      deps.add(cxxBuckConfig.getLexDep());
    }

    return deps.build();
  }

  @SuppressFieldNotInitialized
  public static class Arg extends CxxConstructorArg {
    public Optional<String> baseModule;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.Description;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TargetNode;
import com.facebook.buck.rules.coercer.Either;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.io.Files;

import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CxxDescriptionEnhancer {

  private static final Logger LOG = Logger.get(CxxDescriptionEnhancer.class);

  public static final Flavor HEADER_SYMLINK_TREE_FLAVOR = ImmutableFlavor.of("header-symlink-tree");
  public static final Flavor EXPORTED_HEADER_SYMLINK_TREE_FLAVOR =
      ImmutableFlavor.of("exported-header-symlink-tree");
  public static final Flavor STATIC_FLAVOR = ImmutableFlavor.of("static");
  public static final Flavor STATIC_PIC_FLAVOR = ImmutableFlavor.of("static-pic");
  public static final Flavor SHARED_FLAVOR = ImmutableFlavor.of("shared");
  public static final Flavor MACH_O_BUNDLE_FLAVOR = ImmutableFlavor.of("mach-o-bundle");

  public static final Flavor CXX_LINK_BINARY_FLAVOR = ImmutableFlavor.of("binary");
  public static final Flavor LEX_YACC_SOURCE_FLAVOR = ImmutableFlavor.of("lex_yacc_sources");

  private CxxDescriptionEnhancer() {}

  private static BuildTarget createLexYaccSourcesBuildTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(LEX_YACC_SOURCE_FLAVOR).build();
  }

  public static CxxHeaderSourceSpec requireLexYaccSources(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources) {
    BuildTarget lexYaccTarget = createLexYaccSourcesBuildTarget(params.getBuildTarget());


    Optional<BuildRule> rule = ruleResolver.getRuleOptional(lexYaccTarget);
    if (rule.isPresent()) {
      @SuppressWarnings("unchecked")
      ContainerBuildRule<CxxHeaderSourceSpec> containerRule =
          (ContainerBuildRule<CxxHeaderSourceSpec>) rule.get();
      return containerRule.get();
    }


    CxxHeaderSourceSpec lexYaccSources =
        CxxDescriptionEnhancer.createLexYaccBuildRules(
            params,
            ruleResolver,
            cxxPlatform,
            ImmutableList.<String>of(),
            lexSources,
            ImmutableList.<String>of(),
            yaccSources);

    ruleResolver.addToIndex(
        ContainerBuildRule.of(
            params,
            pathResolver,
            lexYaccTarget,
            lexYaccSources));

    return lexYaccSources;
  }

  public static SymlinkTree createHeaderSymlinkTree(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      boolean includeLexYaccHeaders,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMap<Path, SourcePath> headers,
      HeaderVisibility headerVisibility) {

    BuildTarget headerSymlinkTreeTarget =
        CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);
    Path headerSymlinkTreeRoot =
        CxxDescriptionEnhancer.getHeaderSymlinkTreePath(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);

    CxxHeaderSourceSpec lexYaccSources;
    if (includeLexYaccHeaders) {
      lexYaccSources = requireLexYaccSources(
          params,
          ruleResolver,
          pathResolver,
          cxxPlatform,
          lexSources,
          yaccSources);
    } else {
      lexYaccSources = CxxHeaderSourceSpec.builder().build();
    }

    return CxxPreprocessables.createHeaderSymlinkTreeBuildRule(
        pathResolver,
        headerSymlinkTreeTarget,
        params,
        headerSymlinkTreeRoot,
        ImmutableMap.<Path, SourcePath>builder()
            .putAll(headers)
            .putAll(lexYaccSources.getCxxHeaders())
            .build());
  }

  public static SymlinkTree requireHeaderSymlinkTree(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      boolean includeLexYaccHeaders,
      ImmutableMap<String, SourcePath> lexSources,
      ImmutableMap<String, SourcePath> yaccSources,
      ImmutableMap<Path, SourcePath> headers,
      HeaderVisibility headerVisibility) {
    BuildTarget headerSymlinkTreeTarget =
        CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
            params.getBuildTarget(),
            cxxPlatform.getFlavor(),
            headerVisibility);


    Optional<BuildRule> rule = ruleResolver.getRuleOptional(headerSymlinkTreeTarget);
    if (rule.isPresent()) {
      Preconditions.checkState(rule.get() instanceof SymlinkTree);
      return (SymlinkTree) rule.get();
    }

    SymlinkTree symlinkTree = createHeaderSymlinkTree(
        params,
        ruleResolver,
        pathResolver,
        cxxPlatform,
        includeLexYaccHeaders,
        lexSources,
        yaccSources,
        headers,
        headerVisibility);

    ruleResolver.addToIndex(symlinkTree);

    return symlinkTree;
  }


  public static BuildTarget createHeaderSymlinkTreeTarget(
      BuildTarget target,
      Flavor platform,
      HeaderVisibility headerVisibility) {
    return BuildTarget
        .builder(target)
        .addFlavors(platform)
        .addFlavors(getHeaderSymlinkTreeFlavor(headerVisibility))
        .build();
  }


  public static Path getHeaderSymlinkTreePath(
      BuildTarget target,
      Flavor platform,
      HeaderVisibility headerVisibility) {
    return BuildTargets.getGenPath(
        createHeaderSymlinkTreeTarget(target, platform, headerVisibility),
        "%s");
  }

  public static Flavor getHeaderSymlinkTreeFlavor(HeaderVisibility headerVisibility) {
    switch (headerVisibility) {
      case PUBLIC:
        return EXPORTED_HEADER_SYMLINK_TREE_FLAVOR;
      case PRIVATE:
        return HEADER_SYMLINK_TREE_FLAVOR;
      default:
        throw new RuntimeException("Unexpected value of enum ExportMode");
    }
  }

  private static ImmutableMap<Path, SourcePath> getHeaderMapFromArgParameter(
      SourcePathResolver pathResolver,
      BuildTarget buildTarget,
      Optional<String> headerNamespace,
      String parameterName,
      Optional<Either<ImmutableList<SourcePath>, ImmutableMap<String, SourcePath>>> parameter) {
    ImmutableMap<String, SourcePath> headers;
    if (!parameter.isPresent()) {
      headers = ImmutableMap.of();
    } else if (parameter.get().isRight()) {
      headers = parameter.get().getRight();
    } else {
      headers = pathResolver.getSourcePathNames(
          buildTarget,
          parameterName,
          parameter.get().getLeft());
    }
    return CxxPreprocessables.resolveHeaderMap(
        headerNamespace.transform(MorePaths.TO_PATH)
            .or(buildTarget.getBasePath()),
        headers);
  }


  public static ImmutableMap<Path, SourcePath> parseHeaders(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    return getHeaderMapFromArgParameter(
        new SourcePathResolver(resolver),
        params.getBuildTarget(),
        args.headerNamespace,
        "headers",
        args.headers);
  }


  public static ImmutableMap<Path, SourcePath> parseExportedHeaders(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxLibraryDescription.Arg args) {
    return getHeaderMapFromArgParameter(
        new SourcePathResolver(resolver),
        params.getBuildTarget(),
        args.headerNamespace,
        "exportedHeaders",
        args.exportedHeaders);
  }


  public static ImmutableMap<String, CxxSource> parseCxxSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    ImmutableMap<String, SourceWithFlags> sources;
    if (!args.srcs.isPresent()) {
      sources = ImmutableMap.of();
    } else if (args.srcs.get().isRight()) {
      sources = args.srcs.get().getRight();
    } else {
      SourcePathResolver pathResolver = new SourcePathResolver(resolver);
      sources = pathResolver.getSourcePathNames(
          params.getBuildTarget(),
          "srcs",
          args.srcs.get().getLeft(),
          SourceWithFlags.TO_SOURCE_PATH);
    }
    return CxxCompilableEnhancer.resolveCxxSources(sources);
  }

  public static ImmutableMap<String, SourcePath> parseLexSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return pathResolver.getSourcePathNames(
        params.getBuildTarget(),
        "lexSrcs",
        args.lexSrcs.or(ImmutableList.<SourcePath>of()));
  }

  public static ImmutableMap<String, SourcePath> parseYaccSources(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxConstructorArg args) {
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    return pathResolver.getSourcePathNames(
        params.getBuildTarget(),
        "yaccSrcs",
        args.yaccSrcs.or(ImmutableList.<SourcePath>of()));
  }

  @VisibleForTesting
  protected static BuildTarget createLexBuildTarget(BuildTarget target, String name) {
    return BuildTarget
        .builder(target.getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    "lex-%s",
                    name.replace('/', '-').replace('.', '-').replace('+', '-').replace(' ', '-'))))
        .build();
  }

  @VisibleForTesting
  protected static BuildTarget createYaccBuildTarget(BuildTarget target, String name) {
    return BuildTarget
        .builder(target.getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    "yacc-%s",
                    name.replace('/', '-').replace('.', '-').replace('+', '-').replace(' ', '-'))))
        .build();
  }


  @VisibleForTesting
  protected static Path getYaccOutputPrefix(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createYaccBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name);
  }


  @VisibleForTesting
  protected static Path getLexSourceOutputPath(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createLexBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name + ".cc");
  }


  @VisibleForTesting
  protected static Path getLexHeaderOutputPath(BuildTarget target, String name) {
    BuildTarget flavoredTarget = createLexBuildTarget(target, name);
    return BuildTargets.getGenPath(flavoredTarget, "%s/" + name + ".h");
  }


  public static CxxHeaderSourceSpec createLexYaccBuildRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      ImmutableList<String> lexFlags,
      ImmutableMap<String, SourcePath> lexSrcs,
      ImmutableList<String> yaccFlags,
      ImmutableMap<String, SourcePath> yaccSrcs) {
    if (!lexSrcs.isEmpty() && !cxxPlatform.getLex().isPresent()) {
      throw new HumanReadableException(
          "Platform %s must support lex to compile srcs %s",
          cxxPlatform,
          lexSrcs);
    }

    if (!yaccSrcs.isEmpty() && !cxxPlatform.getYacc().isPresent()) {
      throw new HumanReadableException(
          "Platform %s must support yacc to compile srcs %s",
          cxxPlatform,
          yaccSrcs);
    }

    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableMap.Builder<String, CxxSource> lexYaccCxxSourcesBuilder = ImmutableMap.builder();
    ImmutableMap.Builder<Path, SourcePath> lexYaccHeadersBuilder = ImmutableMap.builder();



    for (ImmutableMap.Entry<String, SourcePath> ent : lexSrcs.entrySet()) {
      final String name = ent.getKey();
      final SourcePath source = ent.getValue();

      BuildTarget target = createLexBuildTarget(params.getBuildTarget(), name);
      Path outputSource = getLexSourceOutputPath(target, name);
      Path outputHeader = getLexHeaderOutputPath(target, name);


      Lex lex = new Lex(
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(
                  ImmutableSortedSet.copyOf(
                      pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),
              Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
          pathResolver,
          cxxPlatform.getLex().get(),
          ImmutableList.<String>builder()
              .addAll(cxxPlatform.getLexFlags())
              .addAll(lexFlags)
              .build(),
          outputSource,
          outputHeader,
          source);
      resolver.addToIndex(lex);


      lexYaccCxxSourcesBuilder.put(
          name + ".cc",
          CxxSource.of(
              CxxSource.Type.CXX,
              new BuildTargetSourcePath(
                  lex.getProjectFilesystem(),
                  lex.getBuildTarget(),
                  outputSource),
              ImmutableList.<String>of()));
      lexYaccHeadersBuilder.put(
          params.getBuildTarget().getBasePath().resolve(name + ".h"),
          new BuildTargetSourcePath(
              lex.getProjectFilesystem(),
              lex.getBuildTarget(),
              outputHeader));
    }



    for (ImmutableMap.Entry<String, SourcePath> ent : yaccSrcs.entrySet()) {
      final String name = ent.getKey();
      final SourcePath source = ent.getValue();

      BuildTarget target = createYaccBuildTarget(params.getBuildTarget(), name);
      Path outputPrefix = getYaccOutputPrefix(target, Files.getNameWithoutExtension(name));


      Yacc yacc = new Yacc(
          params.copyWithChanges(
              target,
              Suppliers.ofInstance(
                  ImmutableSortedSet.copyOf(
                      pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),
              Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
          pathResolver,
          cxxPlatform.getYacc().get(),
          ImmutableList.<String>builder()
              .addAll(cxxPlatform.getYaccFlags())
              .addAll(yaccFlags)
              .build(),
          outputPrefix,
          source);
      resolver.addToIndex(yacc);


      lexYaccCxxSourcesBuilder.put(
          name + ".cc",
          CxxSource.of(
              CxxSource.Type.CXX,
              new BuildTargetSourcePath(
                  yacc.getProjectFilesystem(),
                  yacc.getBuildTarget(),
                  Yacc.getSourceOutputPath(outputPrefix)),
              ImmutableList.<String>of()));

      lexYaccHeadersBuilder.put(
          params.getBuildTarget().getBasePath().resolve(name + ".h"),
          new BuildTargetSourcePath(
              yacc.getProjectFilesystem(),
              yacc.getBuildTarget(),
              Yacc.getHeaderOutputPath(outputPrefix)));
    }

    return CxxHeaderSourceSpec.of(
        lexYaccHeadersBuilder.build(),
        lexYaccCxxSourcesBuilder.build());
  }

  public static ImmutableList<CxxPreprocessorInput> collectCxxPreprocessorInput(
      BuildRuleParams params,
      CxxPlatform cxxPlatform,
      ImmutableMultimap<CxxSource.Type, String> preprocessorFlags,
      ImmutableList<SourcePath> prefixHeaders,
      ImmutableList<SymlinkTree> headerSymlinkTrees,
      ImmutableList<Path> frameworkSearchPaths,
      Iterable<CxxPreprocessorInput> cxxPreprocessorInputFromDeps) {


    BuildTarget targetWithoutFlavor = BuildTarget.of(
        params.getBuildTarget().getUnflavoredBuildTarget());
    ImmutableList.Builder<CxxPreprocessorInput> cxxPreprocessorInputFromTestedRulesBuilder =
        ImmutableList.builder();
    for (BuildRule rule : params.getDeps()) {
      if (rule instanceof NativeTestable) {
        NativeTestable testable = (NativeTestable) rule;
        if (testable.isTestedBy(targetWithoutFlavor)) {
          LOG.debug(
              "Adding private includes of tested rule %s to testing rule %s",
              rule.getBuildTarget(),
              params.getBuildTarget());
          cxxPreprocessorInputFromTestedRulesBuilder.add(
              testable.getCxxPreprocessorInput(
                  cxxPlatform,
                  HeaderVisibility.PRIVATE));
        }
      }
    }

    ImmutableList<CxxPreprocessorInput> cxxPreprocessorInputFromTestedRules =
        cxxPreprocessorInputFromTestedRulesBuilder.build();
    LOG.verbose(
        "Rules tested by target %s added private includes %s",
        params.getBuildTarget(),
        cxxPreprocessorInputFromTestedRules);

    ImmutableMap.Builder<Path, SourcePath> allLinks = ImmutableMap.builder();
    ImmutableMap.Builder<Path, SourcePath> allFullLinks = ImmutableMap.builder();
    ImmutableList.Builder<Path> allIncludeRoots = ImmutableList.builder();
    for (SymlinkTree headerSymlinkTree : headerSymlinkTrees) {
      allLinks.putAll(headerSymlinkTree.getLinks());
      allFullLinks.putAll(headerSymlinkTree.getFullLinks());
      allIncludeRoots.add(headerSymlinkTree.getRoot());
    }

    CxxPreprocessorInput localPreprocessorInput =
        CxxPreprocessorInput.builder()
            .addAllRules(Iterables.transform(headerSymlinkTrees, HasBuildTarget.TO_TARGET))
            .putAllPreprocessorFlags(preprocessorFlags)
            .setIncludes(
                CxxHeaders.builder()
                    .addAllPrefixHeaders(prefixHeaders)
                    .putAllNameToPathMap(allLinks.build())
                    .putAllFullNameToPathMap(allFullLinks.build())
                    .build())
            .addAllIncludeRoots(allIncludeRoots.build())
            .addAllFrameworkRoots(frameworkSearchPaths)
            .build();

    return ImmutableList.<CxxPreprocessorInput>builder()
        .add(localPreprocessorInput)
        .addAll(cxxPreprocessorInputFromDeps)
        .addAll(cxxPreprocessorInputFromTestedRules)
        .build();
  }

  public static BuildTarget createStaticLibraryBuildTarget(
      BuildTarget target,
      Flavor platform,
      CxxSourceRuleFactory.PicType pic) {
    return BuildTarget.builder(target)
        .addFlavors(platform)
        .addFlavors(pic == CxxSourceRuleFactory.PicType.PDC ? STATIC_FLAVOR : STATIC_PIC_FLAVOR)
        .build();
  }

  public static BuildTarget createSharedLibraryBuildTarget(
      BuildTarget target,
      Flavor platform) {
    return BuildTarget.builder(target).addFlavors(platform).addFlavors(SHARED_FLAVOR).build();
  }

  public static Path getStaticLibraryPath(
      BuildTarget target,
      Flavor platform,
      CxxSourceRuleFactory.PicType pic) {
    String name = String.format("lib%s.a", target.getShortName());
    return BuildTargets.getGenPath(createStaticLibraryBuildTarget(target, platform, pic), "%s")
        .resolve(name);
  }

  public static String getDefaultSharedLibrarySoname(BuildTarget target, CxxPlatform platform) {
    String libName =
        Joiner.on('_').join(
            ImmutableList.builder()
                .addAll(
                    FluentIterable.from(target.getBasePath())
                        .transform(Functions.toStringFunction())
                        .filter(Predicates.not(Predicates.equalTo(""))))
                .add(
                    target
                        .withoutFlavors(ImmutableSet.of(platform.getFlavor()))
                        .getShortNameAndFlavorPostfix())
                .build());
    String extension = platform.getSharedLibraryExtension();
    return String.format("lib%s.%s", libName, extension);
  }

  public static Path getSharedLibraryPath(
      BuildTarget target,
      String soname,
      CxxPlatform platform) {
    return BuildTargets.getGenPath(
        createSharedLibraryBuildTarget(target, platform.getFlavor()),
        "%s/" + soname);
  }

  @VisibleForTesting
  protected static Path getOutputPath(BuildTarget target) {
    return BuildTargets.getGenPath(target, "%s/" + target.getShortNameAndFlavorPostfix());
  }

  @VisibleForTesting
  protected static BuildTarget createCxxLinkTarget(BuildTarget target) {
    return BuildTarget.builder(target).addFlavors(CXX_LINK_BINARY_FLAVOR).build();
  }

  static class CxxLinkAndCompileRules {
    final CxxLink cxxLink;
    final ImmutableSortedSet<CxxPreprocessAndCompile> compileRules;
    CxxLinkAndCompileRules(
        CxxLink cxxLink,
        ImmutableSortedSet<CxxPreprocessAndCompile> compileRules) {
      this.cxxLink = cxxLink;
      this.compileRules = compileRules;
    }
  }

  public static CxxLinkAndCompileRules createBuildRulesForCxxBinaryDescriptionArg(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      CxxPlatform cxxPlatform,
      CxxBinaryDescription.Arg args,
      CxxPreprocessMode preprocessMode) {

    ImmutableMap<String, CxxSource> srcs = parseCxxSources(params, resolver, args);
    ImmutableMap<Path, SourcePath> headers = parseHeaders(params, resolver, args);
    ImmutableMap<String, SourcePath> lexSrcs = parseLexSources(params, resolver, args);
    ImmutableMap<String, SourcePath> yaccSrcs = parseYaccSources(params, resolver, args);

    SourcePathResolver sourcePathResolver = new SourcePathResolver(resolver);


    CxxHeaderSourceSpec lexYaccSources =
        requireLexYaccSources(
            params,
            resolver,
            sourcePathResolver,
            cxxPlatform,
            lexSrcs,
            yaccSrcs);



    SymlinkTree headerSymlinkTree = requireHeaderSymlinkTree(
        params,
        resolver,
        sourcePathResolver,
        cxxPlatform,
 true,
        lexSrcs,
        yaccSrcs,
        headers,
        HeaderVisibility.PRIVATE);
    ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput =
        collectCxxPreprocessorInput(
            params,
            cxxPlatform,
            CxxFlags.getLanguageFlags(
                args.preprocessorFlags,
                args.platformPreprocessorFlags,
                args.langPreprocessorFlags,
                cxxPlatform.getFlavor()),
            args.prefixHeaders.get(),
            ImmutableList.of(headerSymlinkTree),
            args.frameworkSearchPaths.get(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                FluentIterable.from(params.getDeps())
                    .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));


    ImmutableMap<String, CxxSource> sources =
        ImmutableMap.<String, CxxSource>builder()
            .putAll(srcs)
            .putAll(lexYaccSources.getCxxSources())
            .build();



    ImmutableMap<CxxPreprocessAndCompile, SourcePath> objects =
        CxxSourceRuleFactory.requirePreprocessAndCompileRules(
            params,
            resolver,
            sourcePathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            CxxFlags.getFlags(
                args.compilerFlags,
                args.platformCompilerFlags,
                cxxPlatform.getFlavor()),
            preprocessMode,
            sources,
            CxxSourceRuleFactory.PicType.PDC);



    Path output = getOutputPath(params.getBuildTarget());
    CxxLink cxxLink = CxxLinkableEnhancer.createCxxLinkableBuildRule(
        cxxPlatform,
        params,
        sourcePathResolver,
 ImmutableList.<String>of(),
 CxxFlags.getFlags(
            args.linkerFlags,
            args.platformLinkerFlags,
            cxxPlatform.getFlavor()),
        createCxxLinkTarget(params.getBuildTarget()),
        Linker.LinkType.EXECUTABLE,
        Optional.<String>absent(),
        output,
        objects.values(),
        (args.linkStyle.or(CxxBinaryDescription.LinkStyle.STATIC) ==
            CxxBinaryDescription.LinkStyle.STATIC)
        ? Linker.LinkableDepType.STATIC
        : Linker.LinkableDepType.SHARED,
        params.getDeps(),
        args.cxxRuntimeType,
        Optional.<SourcePath>absent());
    resolver.addToIndex(cxxLink);

    return new CxxLinkAndCompileRules(cxxLink, ImmutableSortedSet.copyOf(objects.keySet()));
  }

  private static <T> BuildRule createBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      TargetNode<T> node,
      Flavor... flavors) {
    BuildTarget target = BuildTarget.builder(params.getBuildTarget()).addFlavors(flavors).build();
    Description<T> description = node.getDescription();
    T args = node.getConstructorArg();
    return description.createBuildRule(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(params.getDeclaredDeps()),
            Suppliers.ofInstance(params.getExtraDeps())),
        ruleResolver,
        args);
  }


  public static BuildRule requireBuildRule(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      Flavor... flavors) {
    BuildTarget target = BuildTarget.builder(params.getBuildTarget()).addFlavors(flavors).build();
    Optional<BuildRule> rule = ruleResolver.getRuleOptional(target);
    if (!rule.isPresent()) {
      TargetNode<?> node = params.getTargetGraph().get(params.getBuildTarget());
      Preconditions.checkNotNull(
          node,
          String.format("%s not in target graph", params.getBuildTarget()));
      rule = Optional.of(createBuildRule(params, ruleResolver, node, flavors));
      ruleResolver.addToIndex(rule.get());
    }
    return rule.get();
  }


  public static Function<String, String> createErrorMessagePathProcessor(
      final Function<String, String> pathProcessor) {
    return new Function<String, String>() {

      private final ImmutableList<Pattern> patterns =
          ImmutableList.of(
              Pattern.compile(
                  "(?<=^(?:In file included |\\s+)from )" +
                  "(?<path>[^:]+)" +
                  "(?=[:,](?:\\d+[:,](?:\\d+[:,])?)?$)"),
              Pattern.compile(
                  "^(?<path>[^:]+)(?=:(?:\\d+:(?:\\d+:)?)? )"));

      @Override
      public String apply(String line) {
        for (Pattern pattern : patterns) {
          Matcher m = pattern.matcher(line);
          if (m.find()) {
            return m.replaceAll(pathProcessor.apply(m.group("path")));
          }
        }
        return line;
      }

    };
  }

  public static ImmutableList<String> getPlatformFlags(
      ImmutableList<Pair<String, ImmutableList<String>>> platformFlags,
      String platform) {

    ImmutableList.Builder<String> platformFlagsBuilder = ImmutableList.builder();

    for (Pair<String, ImmutableList<String>> pair : platformFlags) {
      Pattern pattern = Pattern.compile(pair.getFirst());
      Matcher matcher = pattern.matcher(platform);
      if (matcher.find()) {
        platformFlagsBuilder.addAll(pair.getSecond());
        break;
      }
    }

    return platformFlagsBuilder.build();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.graph.AbstractBreadthFirstTraversal;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Map;

public class CxxPreprocessables {

  private CxxPreprocessables() {}


  public static ImmutableMap<Path, SourcePath> resolveHeaderMap(
      Path basePath,
      ImmutableMap<String, SourcePath> headers) {

    ImmutableMap.Builder<Path, SourcePath> headerMap = ImmutableMap.builder();



    for (ImmutableMap.Entry<String, SourcePath> ent : headers.entrySet()) {
      Path path = basePath.resolve(ent.getKey());
      headerMap.put(path, ent.getValue());
    }

    return headerMap.build();
  }


  public static Collection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      final CxxPlatform cxxPlatform,
      Iterable<? extends BuildRule> inputs,
      final Predicate<Object> traverse) {




    final Map<BuildTarget, CxxPreprocessorInput> deps = Maps.newLinkedHashMap();


    AbstractBreadthFirstTraversal<BuildRule> visitor =
        new AbstractBreadthFirstTraversal<BuildRule>(inputs) {
          @Override
          public ImmutableSet<BuildRule> visit(BuildRule rule) {
            if (rule instanceof CxxPreprocessorDep) {
              CxxPreprocessorDep dep = (CxxPreprocessorDep) rule;
              deps.putAll(
                  dep.getTransitiveCxxPreprocessorInput(cxxPlatform, HeaderVisibility.PUBLIC));
              return ImmutableSet.of();
            }
            return traverse.apply(rule) ? rule.getDeps() : ImmutableSet.<BuildRule>of();
          }
        };
    visitor.start();


    return deps.values();
  }

  public static Collection<CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
      final CxxPlatform cxxPlatform,
      Iterable<? extends BuildRule> inputs) {
    return getTransitiveCxxPreprocessorInput(
        cxxPlatform,
        inputs,
        Predicates.alwaysTrue());
  }


  public static SymlinkTree createHeaderSymlinkTreeBuildRule(
      SourcePathResolver resolver,
      BuildTarget target,
      BuildRuleParams params,
      Path root,
      ImmutableMap<Path, SourcePath> links) {

    return new SymlinkTree(
        params.copyWithChanges(
            target,

            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        resolver,
        root,
        links);
  }


  public static CxxPreprocessorInput getCxxPreprocessorInput(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      Flavor flavor,
      HeaderVisibility headerVisibility,
      Multimap<CxxSource.Type, String> exportedPreprocessorFlags,
      Iterable<Path> frameworkSearchPaths) {
    BuildRule rule = CxxDescriptionEnhancer.requireBuildRule(
        params,
        ruleResolver,
        flavor,
        CxxDescriptionEnhancer.getHeaderSymlinkTreeFlavor(headerVisibility));
    Preconditions.checkState(rule instanceof SymlinkTree);
    SymlinkTree symlinkTree = (SymlinkTree) rule;
    return CxxPreprocessorInput.builder()
        .addRules(symlinkTree.getBuildTarget())
        .putAllPreprocessorFlags(exportedPreprocessorFlags)
        .setIncludes(
            CxxHeaders.builder()
                .setPrefixHeaders(ImmutableSortedSet.<SourcePath>of())
                .setNameToPathMap(ImmutableSortedMap.copyOf(symlinkTree.getLinks()))
                .setFullNameToPathMap(ImmutableSortedMap.copyOf(symlinkTree.getFullLinks()))
                .build())
        .addIncludeRoots(symlinkTree.getRoot())
        .addAllFrameworkRoots(frameworkSearchPaths)
        .build();
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildRules;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nonnull;

public class CxxSourceRuleFactory {

  private static final Logger LOG = Logger.get(CxxSourceRuleFactory.class);
  private static final String COMPILE_FLAVOR_PREFIX = "compile-";
  private static final String PREPROCESS_FLAVOR_PREFIX = "preprocess-";

  private final BuildRuleParams params;
  private final BuildRuleResolver resolver;
  private final SourcePathResolver pathResolver;
  private final CxxPlatform cxxPlatform;
  private final ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput;
  private final ImmutableList<String> compilerFlags;

  private final Supplier<ImmutableList<BuildRule>> preprocessDeps = Suppliers.memoize(
      new Supplier<ImmutableList<BuildRule>>() {
        @Override
        public ImmutableList<BuildRule> get() {
          ImmutableList.Builder<BuildRule> builder = ImmutableList.builder();

          for (CxxPreprocessorInput input : cxxPreprocessorInput) {


            builder.addAll(
                pathResolver.filterBuildRuleInputs(
                    ImmutableList.<SourcePath>builder()
                        .addAll(input.getIncludes().getPrefixHeaders())
                        .addAll(input.getIncludes().getNameToPathMap().values())
                        .build()));



            builder.addAll(
                BuildRules.toBuildRulesFor(
                    params.getBuildTarget(),
                    resolver,
                    input.getRules()));
          }

          return builder.build();
        }
      });

  private final Supplier<ImmutableList<Path>> includeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableList<Path>>() {
            @Override
            public ImmutableList<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_INCLUDE_ROOTS)
                  .toList();
            }
          });

  private final Supplier<ImmutableList<Path>> systemIncludeRoots =
      Suppliers.memoize(
          new Supplier<ImmutableList<Path>>() {
            @Override
            public ImmutableList<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_SYSTEM_INCLUDE_ROOTS)
                  .toList();
            }
          });

  private final Supplier<ImmutableList<Path>> frameworkRoots =
      Suppliers.memoize(
          new Supplier<ImmutableList<Path>>() {
            @Override
            public ImmutableList<Path> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transformAndConcat(CxxPreprocessorInput.GET_FRAMEWORK_ROOTS)
                  .toList();
            }
          });

  private final Supplier<ImmutableList<CxxHeaders>> includes =
      Suppliers.memoize(
          new Supplier<ImmutableList<CxxHeaders>>() {
            @Override
            public ImmutableList<CxxHeaders> get() {
              return FluentIterable.from(cxxPreprocessorInput)
                  .transform(CxxPreprocessorInput.GET_INCLUDES)
                  .toList();
            }
          });

  private final LoadingCache<CxxSource.Type, ImmutableList<String>> preprocessorFlags =
      CacheBuilder.newBuilder()
          .build(
              new CacheLoader<CxxSource.Type, ImmutableList<String>>() {
                @Override
                public ImmutableList<String> load(@Nonnull CxxSource.Type type) {
                  ImmutableList.Builder<String> builder = ImmutableList.builder();
                  builder.addAll(CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, type));
                  for (CxxPreprocessorInput input : cxxPreprocessorInput) {
                    builder.addAll(input.getPreprocessorFlags().get(type));
                  }
                  return builder.build();
                }
              });

  @VisibleForTesting
  public CxxSourceRuleFactory(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags) {
    this.params = params;
    this.resolver = resolver;
    this.pathResolver = pathResolver;
    this.cxxPlatform = cxxPlatform;
    this.cxxPreprocessorInput = cxxPreprocessorInput;
    this.compilerFlags = compilerFlags;
  }


  private Iterable<String> iXassembler(Iterable<String> args) {
    return MoreIterables.zipAndConcat(
        Iterables.cycle("-Xassembler"),
        args);
  }


  private String getPreprocessOutputName(CxxSource.Type type, String name) {
    CxxSource.Type outputType = CxxSourceTypes.getPreprocessorOutputType(type);
    return name + "." + Iterables.get(outputType.getExtensions(), 0);
  }


  @VisibleForTesting
  public BuildTarget createPreprocessBuildTarget(
      String name,
      CxxSource.Type type,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getPreprocessOutputName(type, name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    PREPROCESS_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isPreprocessFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(PREPROCESS_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }


  @VisibleForTesting
  Path getPreprocessOutputPath(BuildTarget target, CxxSource.Type type, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getPreprocessOutputName(type, name));
  }

  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Tool tool = CxxSourceTypes.getPreprocessor(cxxPlatform, source.getType());


    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> args =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(preprocessorFlags.getUnchecked(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocess(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        args,
        getPreprocessOutputPath(target, source.getType(), name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createPreprocessBuildTarget(name, source.getType(), pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessBuildRule(resolver, name, source, pic);
  }


  private String getCompileOutputName(String name) {
    return name + ".o";
  }


  @VisibleForTesting
  Path getCompileOutputPath(BuildTarget target, String name) {
    return BuildTargets.getGenPath(target, "%s").resolve(getCompileOutputName(name));
  }


  @VisibleForTesting
  public BuildTarget createCompileBuildTarget(
      String name,
      PicType pic) {
    String outputName = Flavor.replaceInvalidCharacters(getCompileOutputName(name));
    return BuildTarget
        .builder(params.getBuildTarget())
        .addFlavors(cxxPlatform.getFlavor())
        .addFlavors(
            ImmutableFlavor.of(
                String.format(
                    COMPILE_FLAVOR_PREFIX + "%s%s",
                    pic == PicType.PIC ? "pic-" : "",
                    outputName)))
        .build();
  }

  public static boolean isCompileFlavoredBuildTarget(BuildTarget target) {
    Set<Flavor> flavors = target.getFlavors();
    for (Flavor flavor : flavors) {
      if (flavor.getName().startsWith(COMPILE_FLAVOR_PREFIX)) {
        return true;
      }
    }
    return false;
  }



  private Tool getCompiler(CxxSource.Type type) {
    return CxxSourceTypes.needsCxxCompiler(type) ?
      cxxPlatform.getCxx() :
      cxxPlatform.getCc();
  }

  private ImmutableList<String> getCompileFlags(CxxSource.Type type) {
    ImmutableList.Builder<String> args = ImmutableList.builder();


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCflags());
    }



    if (type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(cxxPlatform.getCxxflags());
    }


    if (type == CxxSource.Type.C_CPP_OUTPUT ||
        type == CxxSource.Type.OBJC_CPP_OUTPUT ||
        type == CxxSource.Type.CXX_CPP_OUTPUT ||
        type == CxxSource.Type.OBJCXX_CPP_OUTPUT) {
      args.addAll(compilerFlags);
    }


    args.addAll(iXassembler(cxxPlatform.getAsflags()));

    return args.build();
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    Preconditions.checkArgument(CxxSourceTypes.isCompilableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Tool tool = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))
            .build();


    ImmutableList<String> args =
        ImmutableList.<String>builder()

            .addAll(pic.getFlags())

            .addAll(getCompileFlags(source.getType()))

            .addAll(source.getFlags())
            .build();


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.compile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        args,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        cxxPlatform.getDebugPathSanitizer());
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requireCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createCompileBuildRule(resolver, name, source, pic);
  }


  @VisibleForTesting
  public CxxPreprocessAndCompile createPreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    Preconditions.checkArgument(CxxSourceTypes.isPreprocessableType(source.getType()));

    BuildTarget target = createCompileBuildTarget(name, pic);
    Tool tool = getCompiler(source.getType());

    ImmutableSortedSet<BuildRule> dependencies =
        ImmutableSortedSet.<BuildRule>naturalOrder()

            .addAll(tool.getBuildRules(pathResolver))

            .addAll(pathResolver.filterBuildRuleInputs(source.getPath()))

            .addAll(preprocessDeps.get())
            .build();


    ImmutableList<String> compilerFlags = ImmutableList.<String>builder()

        .addAll(pic.getFlags())

        .addAll(getCompileFlags(CxxSourceTypes.getPreprocessorOutputType(source.getType())))

        .addAll(source.getFlags())
        .build();

    LOG.verbose("Creating preprocess and compile %s for %s", target, source);


    CxxPreprocessAndCompile result = CxxPreprocessAndCompile.preprocessAndCompile(
        params.copyWithChanges(
            target,
            Suppliers.ofInstance(dependencies),
            Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),
        pathResolver,
        tool,
        preprocessorFlags.getUnchecked(source.getType()),
        tool,
        compilerFlags,
        getCompileOutputPath(target, name),
        source.getPath(),
        source.getType(),
        includeRoots.get(),
        systemIncludeRoots.get(),
        frameworkRoots.get(),
        includes.get(),
        cxxPlatform.getDebugPathSanitizer(),
        strategy);
    resolver.addToIndex(result);
    return result;
  }

  @VisibleForTesting
  CxxPreprocessAndCompile requirePreprocessAndCompileBuildRule(
      BuildRuleResolver resolver,
      String name,
      CxxSource source,
      PicType pic,
      CxxPreprocessMode strategy) {

    BuildTarget target = createCompileBuildTarget(name, pic);
    Optional<CxxPreprocessAndCompile> existingRule = resolver.getRuleOptionalWithType(
        target, CxxPreprocessAndCompile.class);
    if (existingRule.isPresent()) {
      return existingRule.get();
    }

    return createPreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
  }

  private ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleResolver resolver,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {

    ImmutableList.Builder<CxxPreprocessAndCompile> objects = ImmutableList.builder();

    for (Map.Entry<String, CxxSource> entry : sources.entrySet()) {
      String name = entry.getKey();
      CxxSource source = entry.getValue();

      Preconditions.checkState(
          CxxSourceTypes.isPreprocessableType(source.getType()) ||
              CxxSourceTypes.isCompilableType(source.getType()));

      switch (strategy) {

        case PIPED:
        case COMBINED: {
          CxxPreprocessAndCompile rule;



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            rule = requirePreprocessAndCompileBuildRule(resolver, name, source, pic, strategy);
          } else {
            rule = requireCompileBuildRule(resolver, name, source, pic);
          }

          objects.add(rule);
          break;
        }

        case SEPARATE: {



          if (CxxSourceTypes.isPreprocessableType(source.getType())) {
            CxxPreprocessAndCompile rule = requirePreprocessBuildRule(resolver, name, source, pic);
            source = CxxSource.copyOf(source)
                .withType(CxxSourceTypes.getPreprocessorOutputType(source.getType()))
                .withPath(
                    new BuildTargetSourcePath(
                        params.getProjectFilesystem(),
                        rule.getBuildTarget()));
          }


          CxxPreprocessAndCompile rule = requireCompileBuildRule(resolver, name, source, pic);
          objects.add(rule);

          break;
        }


        default:
          throw new IllegalStateException();
      }
    }

    final ProjectFilesystem projectFilesystem = params.getProjectFilesystem();
    return FluentIterable
        .from(objects.build())
        .toMap(new Function<CxxPreprocessAndCompile, SourcePath>() {
          @Override
          public SourcePath apply(CxxPreprocessAndCompile input) {
            return new BuildTargetSourcePath(projectFilesystem, input.getBuildTarget());
          }
        });
  }

  public static ImmutableMap<CxxPreprocessAndCompile, SourcePath> requirePreprocessAndCompileRules(
      BuildRuleParams params,
      BuildRuleResolver resolver,
      SourcePathResolver pathResolver,
      CxxPlatform cxxPlatform,
      ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput,
      ImmutableList<String> compilerFlags,
      CxxPreprocessMode strategy,
      ImmutableMap<String, CxxSource> sources,
      PicType pic) {
    CxxSourceRuleFactory factory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            cxxPlatform,
            cxxPreprocessorInput,
            compilerFlags);
    return factory.requirePreprocessAndCompileRules(resolver, strategy, sources, pic);
  }

  public enum PicType {


    PIC("-fPIC"),


    PDC;

    private final ImmutableList<String> flags;

    PicType(String... flags) {
      this.flags = ImmutableList.copyOf(flags);
    }

    public ImmutableList<String> getFlags() {
      return flags;
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;

import org.immutables.value.Value;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


@Value.Immutable
@BuckStyleImmutable
abstract class AbstractCxxPreprocessorInput {

  public static final Function<CxxPreprocessorInput, CxxHeaders> GET_INCLUDES =
      new Function<CxxPreprocessorInput, CxxHeaders>() {
        @Override
        public CxxHeaders apply(CxxPreprocessorInput input) {
          return input.getIncludes();
        }
      };

  public static final Function<CxxPreprocessorInput, ImmutableList<Path>> GET_INCLUDE_ROOTS =
      new Function<CxxPreprocessorInput, ImmutableList<Path>>() {
        @Override
        public ImmutableList<Path> apply(CxxPreprocessorInput input) {
          return input.getIncludeRoots();
        }
      };

  public static final Function<CxxPreprocessorInput, ImmutableList<Path>> GET_SYSTEM_INCLUDE_ROOTS =
      new Function<CxxPreprocessorInput, ImmutableList<Path>>() {
        @Override
        public ImmutableList<Path> apply(CxxPreprocessorInput input) {
          return input.getSystemIncludeRoots();
        }
      };

  public static final Function<CxxPreprocessorInput, ImmutableList<Path>> GET_FRAMEWORK_ROOTS =
      new Function<CxxPreprocessorInput, ImmutableList<Path>>() {
        @Override
        public ImmutableList<Path> apply(CxxPreprocessorInput input) {
          return input.getFrameworkRoots();
        }
      };


  @Value.Parameter
  public abstract Set<BuildTarget> getRules();

  @Value.Parameter
  public abstract Multimap<CxxSource.Type, String> getPreprocessorFlags();

  @Value.Parameter
  @Value.Default
  public CxxHeaders getIncludes() {
    return CxxHeaders.builder().build();
  }


  @Value.Parameter
  public abstract List<Path> getIncludeRoots();


  @Value.Parameter
  public abstract List<Path> getSystemIncludeRoots();


  @Value.Parameter
  public abstract List<Path> getFrameworkRoots();

  public static final CxxPreprocessorInput EMPTY = CxxPreprocessorInput.builder().build();

  public static CxxPreprocessorInput.Builder builder() {
    return CxxPreprocessorInput.builder();
  }

  public static CxxPreprocessorInput concat(Iterable<CxxPreprocessorInput> inputs)
      throws AbstractCxxHeaders.ConflictingHeadersException {
    ImmutableSet.Builder<BuildTarget> rules = ImmutableSet.builder();
    ImmutableMultimap.Builder<CxxSource.Type, String> preprocessorFlags =
      ImmutableMultimap.builder();
    ImmutableList.Builder<SourcePath> prefixHeaders = ImmutableList.builder();
    Map<Path, SourcePath> includeNameToPathMap = new HashMap<>();
    Map<Path, SourcePath> includeFullNameToPathMap = new HashMap<>();
    ImmutableList.Builder<Path> includeRoots = ImmutableList.builder();
    ImmutableList.Builder<Path> systemIncludeRoots = ImmutableList.builder();
    ImmutableList.Builder<Path> frameworkRoots = ImmutableList.builder();

    for (CxxPreprocessorInput input : inputs) {
      rules.addAll(input.getRules());
      preprocessorFlags.putAll(input.getPreprocessorFlags());
      prefixHeaders.addAll(input.getIncludes().getPrefixHeaders());
      CxxHeaders.addAllEntriesToIncludeMap(
          includeNameToPathMap,
          input.getIncludes().getNameToPathMap());
      CxxHeaders.addAllEntriesToIncludeMap(
          includeFullNameToPathMap,
          input.getIncludes().getFullNameToPathMap());
      includeRoots.addAll(input.getIncludeRoots());
      systemIncludeRoots.addAll(input.getSystemIncludeRoots());
      frameworkRoots.addAll(input.getFrameworkRoots());
    }

    return CxxPreprocessorInput.of(
        rules.build(),
        preprocessorFlags.build(),
        CxxHeaders.builder()
            .addAllPrefixHeaders(prefixHeaders.build())
            .putAllNameToPathMap(includeNameToPathMap)
            .putAllFullNameToPathMap(includeFullNameToPathMap)
            .build(),
        includeRoots.build(),
        systemIncludeRoots.build(),
        frameworkRoots.build());
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.MoreIterables;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.util.Map;


public class CxxPreprocessAndCompile extends AbstractBuildRule implements RuleKeyAppendable {

  @AddToRuleKey
  private final CxxPreprocessAndCompileStep.Operation operation;
  @AddToRuleKey
  private final Optional<Tool> preprocessor;
  private final Optional<ImmutableList<String>> preprocessorFlags;
  @AddToRuleKey
  private final Optional<Tool> compiler;
  private final Optional<ImmutableList<String>> compilerFlags;
  @AddToRuleKey(stringify = true)
  private final Path output;
  @AddToRuleKey
  private final SourcePath input;
  private final CxxSource.Type inputType;
  private final ImmutableList<Path> includeRoots;
  private final ImmutableList<Path> systemIncludeRoots;
  private final ImmutableList<Path> frameworkRoots;
  @AddToRuleKey
  private final ImmutableList<CxxHeaders> includes;
  private final DebugPathSanitizer sanitizer;

  @VisibleForTesting
  CxxPreprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      CxxPreprocessAndCompileStep.Operation operation,
      Optional<Tool> preprocessor,
      Optional<ImmutableList<String>> preprocessorFlags,
      Optional<Tool> compiler,
      Optional<ImmutableList<String>> compilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    super(params, resolver);
    Preconditions.checkState(operation.isPreprocess() == preprocessor.isPresent());
    Preconditions.checkState(operation.isPreprocess() == preprocessorFlags.isPresent());
    Preconditions.checkState(operation.isCompile() == compiler.isPresent());
    Preconditions.checkState(operation.isCompile() == compilerFlags.isPresent());
    this.operation = operation;
    this.preprocessor = preprocessor;
    this.preprocessorFlags = preprocessorFlags;
    this.compiler = compiler;
    this.compilerFlags = compilerFlags;
    this.output = output;
    this.input = input;
    this.inputType = inputType;
    this.includeRoots = includeRoots;
    this.systemIncludeRoots = systemIncludeRoots;
    this.frameworkRoots = frameworkRoots;
    this.includes = includes;
    this.sanitizer = sanitizer;
  }


  public static CxxPreprocessAndCompile compile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool compiler,
      ImmutableList<String> flags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(compiler),
        Optional.of(flags),
        output,
        input,
        inputType,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<CxxHeaders>of(),
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocess(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool preprocessor,
      ImmutableList<String> flags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(preprocessor),
        Optional.of(flags),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        sanitizer);
  }


  public static CxxPreprocessAndCompile preprocessAndCompile(
      BuildRuleParams params,
      SourcePathResolver resolver,
      Tool preprocessor,
      ImmutableList<String> preprocessorFlags,
      Tool compiler,
      ImmutableList<String> compilerFlags,
      Path output,
      SourcePath input,
      CxxSource.Type inputType,
      ImmutableList<Path> includeRoots,
      ImmutableList<Path> systemIncludeRoots,
      ImmutableList<Path> frameworkRoots,
      ImmutableList<CxxHeaders> includes,
      DebugPathSanitizer sanitizer,
      CxxPreprocessMode strategy) {
    return new CxxPreprocessAndCompile(
        params,
        resolver,
        (strategy == CxxPreprocessMode.PIPED
            ? CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE
            : CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO),
        Optional.of(preprocessor),
        Optional.of(preprocessorFlags),
        Optional.of(compiler),
        Optional.of(compilerFlags),
        output,
        input,
        inputType,
        includeRoots,
        systemIncludeRoots,
        frameworkRoots,
        includes,
        (strategy == CxxPreprocessMode.COMBINED
            ? sanitizer
            : sanitizer.changePathSize(0)));
  }

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {


    ImmutableList<String> flags = ImmutableList.<String>builder()
        .addAll(this.preprocessorFlags.or(ImmutableList.<String>of()))
        .addAll(this.compilerFlags.or(ImmutableList.<String>of()))
        .build();
    flags = FluentIterable.from(flags)
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
    builder.setReflectively("flags", flags);
    ImmutableList<String> frameworkRoots = FluentIterable.from(this.frameworkRoots)
        .transform(Functions.toStringFunction())
        .transform(sanitizer.sanitize(Optional.<Path>absent(),  false))
        .toList();
    builder.setReflectively("frameworkRoots", frameworkRoots);



    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      builder.setReflectively("compilationDirectory", sanitizer.getCompilationDirectory());
    }

    return builder;
  }

  @VisibleForTesting
  CxxPreprocessAndCompileStep makeMainStep() {



    ImmutableMap.Builder<Path, Path> replacementPathsBuilder = ImmutableMap.builder();
    try {
      for (Map.Entry<Path, SourcePath> entry :
           CxxHeaders.concat(includes).getFullNameToPathMap().entrySet()) {
        replacementPathsBuilder.put(entry.getKey(), getResolver().getPath(entry.getValue()));
      }
    } catch (CxxHeaders.ConflictingHeadersException e) {
      throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
    }
    ImmutableMap<Path, Path> replacementPaths = replacementPathsBuilder.build();

    Optional<ImmutableList<String>> preprocessorCommand;
    if (preprocessor.isPresent()) {
      preprocessorCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(preprocessor.get().getCommandPrefix(getResolver()))
              .addAll(getPreprocessorSuffix())
              .build());
    } else {
      preprocessorCommand = Optional.absent();
    }

    Optional<ImmutableList<String>> compilerCommand;
    if (compiler.isPresent()) {
      compilerCommand = Optional.of(
          ImmutableList.<String>builder()
              .addAll(compiler.get().getCommandPrefix(getResolver()))
              .addAll(getCompilerSuffix())
              .build());
    } else {
      compilerCommand = Optional.absent();
    }

    return new CxxPreprocessAndCompileStep(
        operation,
        output,
        getResolver().getPath(input),
        inputType,
        preprocessorCommand,
        compilerCommand,
        replacementPaths,
        sanitizer);
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      BuildableContext buildableContext) {
    buildableContext.recordArtifact(output);
    return ImmutableList.of(
        new MkdirStep(output.getParent()),
        makeMainStep());
  }

  private ImmutableList<String> getPreprocessorSuffix() {
    Preconditions.checkState(operation.isPreprocess());
    ImmutableSet.Builder<SourcePath> prefixHeaders = ImmutableSet.builder();
    for (CxxHeaders cxxHeaders : includes) {
      prefixHeaders.addAll(cxxHeaders.getPrefixHeaders());
    }
    return ImmutableList.<String>builder()
        .addAll(preprocessorFlags.get())
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-include"),
                FluentIterable.from(prefixHeaders.build())
                    .transform(getResolver().getPathFunction())
                    .transform(Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-I"),
                Iterables.transform(includeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-isystem"),
                Iterables.transform(systemIncludeRoots, Functions.toStringFunction())))
        .addAll(
            MoreIterables.zipAndConcat(
                Iterables.cycle("-F"),
                Iterables.transform(frameworkRoots, Functions.toStringFunction())))
        .build();
  }

  private ImmutableList<String> getCompilerSuffix() {
    Preconditions.checkState(operation.isCompile());
    ImmutableList.Builder<String> suffix = ImmutableList.builder();
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      suffix.addAll(getPreprocessorSuffix());
    }
    suffix.addAll(compilerFlags.get());
    return suffix.build();
  }

  public ImmutableList<String> getCompileCommandCombinedWithPreprocessBuildRule(
      CxxPreprocessAndCompile preprocessBuildRule) {
    if (!operation.isCompile() ||
        !preprocessBuildRule.operation.isPreprocess()) {
      throw new HumanReadableException(
          "%s is not preprocess rule or %s is not compile rule.",
          preprocessBuildRule,
          this);
    }
    ImmutableList.Builder<String> cmd = ImmutableList.builder();
    cmd.addAll(compiler.get().getCommandPrefix(getResolver()));
    cmd.add("-x", preprocessBuildRule.inputType.getLanguage());
    cmd.add("-c");
    cmd.addAll(preprocessBuildRule.getPreprocessorSuffix());
    cmd.addAll(getCompilerSuffix());
    cmd.add("-o", output.toString());
    cmd.add(getResolver().getPath(preprocessBuildRule.input).toString());
    return cmd.build();
  }

  public ImmutableList<String> getCommand() {
    if (operation == CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO) {
      return makeMainStep().getCommand();
    }
    return getCompileCommandCombinedWithPreprocessBuildRule(this);
  }

  @Override
  public Path getPathToOutput() {
    return output;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getPreprocessorFlags() {
    return preprocessorFlags;
  }

  @VisibleForTesting
  Optional<ImmutableList<String>> getCompilerFlags() {
    return compilerFlags;
  }

  public Path getOutput() {
    return output;
  }

  public SourcePath getInput() {
    return input;
  }

  public ImmutableList<CxxHeaders> getIncludes() {
    return includes;
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.immutables.BuckStyleImmutable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;

import org.immutables.value.Value;

import java.nio.file.Path;
import java.util.List;
import java.util.Map;

@Value.Immutable
@BuckStyleImmutable
abstract class AbstractCxxHeaders implements RuleKeyAppendable {


  abstract List<SourcePath> getPrefixHeaders();


  abstract Map<Path, SourcePath> getNameToPathMap();


  abstract Map<Path, SourcePath> getFullNameToPathMap();

  @Override
  public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
    builder.setReflectively("prefixHeaders", getPrefixHeaders());

    for (Path path : ImmutableSortedSet.copyOf(getNameToPathMap().keySet())) {
      SourcePath source = getNameToPathMap().get(path);
      builder.setReflectively("include(" + path + ")", source);
    }

    return builder;
  }

  public static void addAllEntriesToIncludeMap(
      Map<Path, SourcePath> destination,
      Map<Path, SourcePath> source)
      throws ConflictingHeadersException {
    for (Map.Entry<Path, SourcePath> entry : source.entrySet()) {
      SourcePath original = destination.put(entry.getKey(), entry.getValue());
      if (original != null && !original.equals(entry.getValue())) {
        throw new ConflictingHeadersException(entry.getKey(), original, entry.getValue());
      }
    }
  }

  public static CxxHeaders concat(Iterable<CxxHeaders> headerGroup)
      throws ConflictingHeadersException {

    ImmutableList.Builder<SourcePath> prefixHeaders = ImmutableList.builder();
    Map<Path, SourcePath> nameToPathMap = Maps.newLinkedHashMap();
    Map<Path, SourcePath> fullNameToPathMap = Maps.newLinkedHashMap();

    for (CxxHeaders headers : headerGroup) {
      prefixHeaders.addAll(headers.getPrefixHeaders());
      addAllEntriesToIncludeMap(nameToPathMap, headers.getNameToPathMap());
      addAllEntriesToIncludeMap(fullNameToPathMap, headers.getFullNameToPathMap());
    }

    return CxxHeaders.builder()
        .setPrefixHeaders(prefixHeaders.build())
        .setNameToPathMap(nameToPathMap)
        .setFullNameToPathMap(fullNameToPathMap)
        .build();
  }

  @SuppressWarnings("serial")
  public static class ConflictingHeadersException extends Exception {
    public ConflictingHeadersException(Path key, SourcePath value1, SourcePath value2) {
      super(
          String.format(
              "'%s' maps to both %s.",
              key,
              ImmutableSortedSet.of(value1, value2)));
    }

    public HumanReadableException getHumanReadableExceptionForBuildTarget(BuildTarget buildTarget) {
      return new HumanReadableException(
          this,
          "Target '%s' uses conflicting header file mappings. %s",
          buildTarget,
          getMessage());
    }
  }

}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.Flavor;
import com.facebook.buck.model.Pair;
import com.facebook.buck.python.PythonPackageComponents;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.ImmutableSortedSet;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class PrebuiltCxxLibrary extends AbstractCxxLibrary {

  private final BuildRuleParams params;
  private final BuildRuleResolver ruleResolver;
  private final SourcePathResolver pathResolver;
  private final ImmutableList<Path> includeDirs;
  private final Optional<String> libDir;
  private final Optional<String> libName;
  private final ImmutableList<String> exportedLinkerFlags;
  private final ImmutableList<Pair<String, ImmutableList<String>>> exportedPlatformLinkerFlags;
  private final Optional<String> soname;
  private final boolean headerOnly;
  private final boolean linkWhole;
  private final boolean provided;


  private final Map<Pair<Flavor, HeaderVisibility>, ImmutableMap<BuildTarget, CxxPreprocessorInput>>
      cxxPreprocessorInputCache = Maps.newHashMap();

  public PrebuiltCxxLibrary(
      BuildRuleParams params,
      BuildRuleResolver ruleResolver,
      SourcePathResolver pathResolver,
      ImmutableList<Path> includeDirs,
      Optional<String> libDir,
      Optional<String> libName,
      ImmutableList<String> exportedLinkerFlags,
      ImmutableList<Pair<String, ImmutableList<String>>> exportedPlatformLinkerFlags,
      Optional<String> soname,
      boolean headerOnly,
      boolean linkWhole,
      boolean provided) {
    super(params, pathResolver);
    this.params = params;
    this.ruleResolver = ruleResolver;
    this.pathResolver = pathResolver;
    this.includeDirs = includeDirs;
    this.libDir = libDir;
    this.libName = libName;
    this.exportedLinkerFlags = exportedLinkerFlags;
    this.exportedPlatformLinkerFlags = exportedPlatformLinkerFlags;
    this.soname = soname;
    this.headerOnly = headerOnly;
    this.linkWhole = linkWhole;
    this.provided = provided;
  }


  private SourcePath requireSharedLibrary(CxxPlatform cxxPlatform) {
    Path sharedLibraryPath =
        PrebuiltCxxLibraryDescription.getSharedLibraryPath(
            getBuildTarget(),
            cxxPlatform,
            libDir,
            libName);


    if (params.getProjectFilesystem().exists(sharedLibraryPath)) {
      return new PathSourcePath(params.getProjectFilesystem(), sharedLibraryPath);
    }


    BuildRule sharedLibrary =
        CxxDescriptionEnhancer.requireBuildRule(
            params,
            ruleResolver,
            cxxPlatform.getFlavor(),
            CxxDescriptionEnhancer.SHARED_FLAVOR);

    return new BuildTargetSourcePath(
        sharedLibrary.getProjectFilesystem(),
        sharedLibrary.getBuildTarget());
  }

  @Override
  public CxxPreprocessorInput getCxxPreprocessorInput(
      CxxPlatform cxxPlatform,
      HeaderVisibility headerVisibility) {
    switch (headerVisibility) {
      case PUBLIC:
        return CxxPreprocessorInput.builder()

            .setSystemIncludeRoots(ImmutableSortedSet.copyOf(includeDirs))
            .build();
      case PRIVATE:
        return CxxPreprocessorInput.EMPTY;
    }



    throw new RuntimeException("Invalid header visibility: " + headerVisibility);
  }


  @Override
  public ImmutableMap<BuildTarget, CxxPreprocessorInput>
      getTransitiveCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
    Pair<Flavor, HeaderVisibility> key = new Pair<>(cxxPlatform.getFlavor(), headerVisibility);
    ImmutableMap<BuildTarget, CxxPreprocessorInput> result = cxxPreprocessorInputCache.get(key);
    if (result == null) {
      Map<BuildTarget, CxxPreprocessorInput> builder = Maps.newLinkedHashMap();
      builder.put(getBuildTarget(), getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      for (BuildRule dep : getDeps()) {
        if (dep instanceof CxxPreprocessorDep) {
          builder.putAll(
              ((CxxPreprocessorDep) dep).getTransitiveCxxPreprocessorInput(
                  cxxPlatform,
                  headerVisibility));
        }
      }
      result = ImmutableMap.copyOf(builder);
      cxxPreprocessorInputCache.put(key, result);
    }
    return result;
  }

  @Override
  public NativeLinkableInput getNativeLinkableInput(
      CxxPlatform cxxPlatform,
      Linker.LinkableDepType type) {



    ImmutableList.Builder<SourcePath> librariesBuilder = ImmutableList.builder();
    ImmutableList.Builder<String> linkerArgsBuilder = ImmutableList.builder();
    linkerArgsBuilder.addAll(exportedLinkerFlags);
    linkerArgsBuilder.addAll(
        CxxDescriptionEnhancer.getPlatformFlags(
            exportedPlatformLinkerFlags,
            cxxPlatform.getFlavor().toString()));
    if (!headerOnly) {
      if (provided || type == Linker.LinkableDepType.SHARED) {
        SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
        librariesBuilder.add(sharedLibrary);
        linkerArgsBuilder.add(pathResolver.getPath(sharedLibrary).toString());
      } else {
        Path staticLibraryPath =
            PrebuiltCxxLibraryDescription.getStaticLibraryPath(
                getBuildTarget(),
                cxxPlatform,
                libDir,
                libName);
        librariesBuilder.add(new PathSourcePath(getProjectFilesystem(), staticLibraryPath));
        if (linkWhole) {
          Linker linker = cxxPlatform.getLd();
          linkerArgsBuilder.addAll(linker.linkWhole(staticLibraryPath.toString()));
        } else {
          linkerArgsBuilder.add(staticLibraryPath.toString());
        }
      }
    }
    final ImmutableList<SourcePath> libraries = librariesBuilder.build();
    final ImmutableList<String> linkerArgs = linkerArgsBuilder.build();

    return NativeLinkableInput.of( libraries,  linkerArgs);
  }

  @Override
  public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform) {
    return Optional.absent();
  }

  @Override
  public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform) {
    String resolvedSoname =
        PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(), cxxPlatform, soname, libName);


    ImmutableMap.Builder<Path, SourcePath> nativeLibrariesBuilder = ImmutableMap.builder();
    if (!headerOnly && !provided) {
      SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
      nativeLibrariesBuilder.put(
          Paths.get(resolvedSoname),
          sharedLibrary);
    }
    ImmutableMap<Path, SourcePath> nativeLibraries = nativeLibrariesBuilder.build();

    return PythonPackageComponents.of(
 ImmutableMap.<Path, SourcePath>of(),
 ImmutableMap.<Path, SourcePath>of(),
        nativeLibraries,
 ImmutableSet.<SourcePath>of(),
 Optional.<Boolean>absent());
  }

  @Override
  public Iterable<AndroidPackageable> getRequiredPackageables() {
    return AndroidPackageableCollector.getPackageableRules(params.getDeps());
  }

  @Override
  public void addToCollector(AndroidPackageableCollector collector) {
    collector.addNativeLinkable(this);
  }

  @Override
  public ImmutableMap<String, SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) {
    String resolvedSoname =
        PrebuiltCxxLibraryDescription.getSoname(getBuildTarget(), cxxPlatform, soname, libName);
    ImmutableMap.Builder<String, SourcePath> solibs = ImmutableMap.builder();
    if (!headerOnly && !provided) {
      SourcePath sharedLibrary = requireSharedLibrary(cxxPlatform);
      solibs.put(resolvedSoname, sharedLibrary);
    }
    return solibs.build();
  }

  @Override
  public boolean isTestedBy(BuildTarget buildTarget) {
    return false;
  }
}

<code block>


package com.facebook.buck.android;

import static org.junit.Assert.assertThat;

import com.facebook.buck.cxx.CxxLinkableEnhancer;
import com.facebook.buck.cxx.CxxPreprocessAndCompile;
import com.facebook.buck.cxx.CxxPreprocessMode;
import com.facebook.buck.cxx.CxxPreprocessorInput;
import com.facebook.buck.cxx.CxxSource;
import com.facebook.buck.cxx.CxxSourceRuleFactory;
import com.facebook.buck.cxx.Linker;
import com.facebook.buck.io.AlwaysFoundExecutableFinder;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.Pair;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.integration.DebuggableTemporaryFolder;
import com.facebook.buck.util.environment.Platform;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import org.hamcrest.Matchers;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Map;

public class NdkCxxPlatformTest {

  @Rule
  public DebuggableTemporaryFolder tmp = new DebuggableTemporaryFolder();

  enum Operation {
    PREPROCESS,
    COMPILE,
    PREPROCESS_AND_COMPILE,
  }


  private ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey> constructCompileRuleKeys(
      Operation operation,
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    String source = "source.cpp";
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("source.cpp", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      CxxSourceRuleFactory cxxSourceRuleFactory =
          new CxxSourceRuleFactory(
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              resolver,
              pathResolver,
              entry.getValue().getCxxPlatform(),
              ImmutableList.<CxxPreprocessorInput>of(),
              ImmutableList.<String>of());
      CxxPreprocessAndCompile rule;
      switch (operation) {
        case PREPROCESS_AND_COMPILE:
          rule =
              cxxSourceRuleFactory.createPreprocessAndCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC,
                  CxxPreprocessMode.COMBINED);
          break;
        case PREPROCESS:
          rule =
              cxxSourceRuleFactory.createPreprocessBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        case COMPILE:
          rule =
              cxxSourceRuleFactory.createCompileBuildRule(
                  resolver,
                  source,
                  CxxSource.of(
                      CxxSource.Type.CXX_CPP_OUTPUT,
                      new TestSourcePath(source),
                      ImmutableList.<String>of()),
                  CxxSourceRuleFactory.PicType.PIC);
          break;
        default:
          throw new IllegalStateException();
      }
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }


  private ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey> constructLinkRuleKeys(
      ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> cxxPlatforms) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("input.o", Strings.repeat("a", 40))
                    .build()),
            pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    ImmutableMap.Builder<NdkCxxPlatforms.TargetCpuType, RuleKey> ruleKeys =
        ImmutableMap.builder();
    for (Map.Entry<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {
      BuildRule rule =
          CxxLinkableEnhancer.createCxxLinkableBuildRule(
              entry.getValue().getCxxPlatform(),
              BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
              pathResolver,
              ImmutableList.<String>of(),
              ImmutableList.<String>of(),
              target,
              Linker.LinkType.EXECUTABLE,
              Optional.<String>absent(),
              Paths.get("output"),
              ImmutableList.<SourcePath>of(new TestSourcePath("input.o")),
              Linker.LinkableDepType.SHARED,
              ImmutableList.<BuildRule>of(),
              Optional.<Linker.CxxRuntimeType>absent(),
              Optional.<SourcePath>absent());
      RuleKey.Builder builder = ruleKeyBuilderFactory.newInstance(rule);
      ruleKeys.put(entry.getKey(), builder.build());
    }
    return ruleKeys.build();
  }



  @Test
  public void checkRootAndPlatformDoNotAffectRuleKeys() throws IOException {


    ImmutableList<Pair<NdkCxxPlatforms.Compiler.Type, NdkCxxPlatforms.CxxRuntime>> configs =
        ImmutableList.of(
            new Pair<>(NdkCxxPlatforms.Compiler.Type.GCC, NdkCxxPlatforms.CxxRuntime.GNUSTL),
            new Pair<>(NdkCxxPlatforms.Compiler.Type.CLANG, NdkCxxPlatforms.CxxRuntime.GNUSTL),
            new Pair<>(NdkCxxPlatforms.Compiler.Type.CLANG, NdkCxxPlatforms.CxxRuntime.LIBCXX));
    for (Pair<NdkCxxPlatforms.Compiler.Type, NdkCxxPlatforms.CxxRuntime> config : configs) {
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          preprocessAndCompileRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          preprocessRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          compileRukeKeys = Maps.newHashMap();
      Map<String, ImmutableMap<NdkCxxPlatforms.TargetCpuType, RuleKey>>
          linkRukeKeys = Maps.newHashMap();



      for (String dir : ImmutableList.of("something", "something else")) {
        for (Platform platform :
            ImmutableList.of(Platform.LINUX, Platform.MACOS, Platform.WINDOWS)) {
          tmp.create();
          Path root = tmp.newFolder(dir).toPath();
          FakeProjectFilesystem filesystem = new FakeProjectFilesystem(root.toFile());
          filesystem.writeContentsToPath("something", Paths.get("RELEASE.TXT"));
          ImmutableMap<NdkCxxPlatforms.TargetCpuType, NdkCxxPlatform> platforms =
              NdkCxxPlatforms.getPlatforms(
                  filesystem,
                  ImmutableNdkCxxPlatforms.Compiler.builder()
                      .setType(config.getFirst())
                      .setVersion("gcc-version")
                      .setGccVersion("clang-version")
                      .build(),
                  NdkCxxPlatforms.CxxRuntime.GNUSTL,
                  "target-app-platform",
                  platform,
                  new AlwaysFoundExecutableFinder());
          preprocessAndCompileRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.PREPROCESS_AND_COMPILE, platforms));
          preprocessRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.PREPROCESS, platforms));
          compileRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructCompileRuleKeys(Operation.COMPILE, platforms));
          linkRukeKeys.put(
              String.format("NdkCxxPlatform(%s, %s)", dir, platform),
              constructLinkRuleKeys(platforms));
          tmp.delete();
        }
      }



      assertThat(
          Arrays.toString(preprocessAndCompileRukeKeys.entrySet().toArray()),
          Sets.newHashSet(preprocessAndCompileRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(preprocessRukeKeys.entrySet().toArray()),
          Sets.newHashSet(preprocessRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(compileRukeKeys.entrySet().toArray()),
          Sets.newHashSet(compileRukeKeys.values()),
          Matchers.hasSize(1));
      assertThat(
          Arrays.toString(linkRukeKeys.entrySet().toArray()),
          Sets.newHashSet(linkRukeKeys.values()),
          Matchers.hasSize(1));
    }

  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxPreprocessablesTest {

  private static final ProjectFilesystem PROJECT_FILESYSTEM = new FakeProjectFilesystem();

  private static class FakeCxxPreprocessorDep extends FakeBuildRule
      implements CxxPreprocessorDep {

    private final CxxPreprocessorInput input;

    public FakeCxxPreprocessorDep(
        BuildRuleParams params,
        SourcePathResolver resolver,
        CxxPreprocessorInput input) {
      super(params, resolver);
      this.input = Preconditions.checkNotNull(input);
    }

    @Override
    public CxxPreprocessorInput getCxxPreprocessorInput(
        CxxPlatform cxxPlatform,
        HeaderVisibility headerVisibility) {
      return input;
    }

    @Override
    public ImmutableMap<BuildTarget, CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
        CxxPlatform cxxPlatform,
        HeaderVisibility headerVisibility) {
      ImmutableMap.Builder<BuildTarget, CxxPreprocessorInput> builder = ImmutableMap.builder();
      builder.put(getBuildTarget(), getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      for (BuildRule dep : getDeps()) {
        if (dep instanceof CxxPreprocessorDep) {
          builder.putAll(
              ((CxxPreprocessorDep) dep).getTransitiveCxxPreprocessorInput(
                  cxxPlatform,
                  headerVisibility));
          }
        }
      return builder.build();
    }

  }

  private static FakeCxxPreprocessorDep createFakeCxxPreprocessorDep(
      BuildTarget target,
      SourcePathResolver resolver,
      CxxPreprocessorInput input,
      BuildRule... deps) {
    return new FakeCxxPreprocessorDep(
        new FakeBuildRuleParamsBuilder(target)
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver, input);
  }

  private static FakeCxxPreprocessorDep createFakeCxxPreprocessorDep(
      String target,
      SourcePathResolver resolver,
      CxxPreprocessorInput input,
      BuildRule... deps) {
    return createFakeCxxPreprocessorDep(
        BuildTargetFactory.newInstance(target),
        resolver,
        input,
        deps);
  }

  private static FakeBuildRule createFakeBuildRule(
      BuildTarget target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(target)
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Rule
  public ExpectedException exception = ExpectedException.none();

  @Test
  public void resolveHeaderMap() {
    BuildTarget target = BuildTargetFactory.newInstance("//hello/world:test");
    ImmutableMap<String, SourcePath> headerMap = ImmutableMap.<String, SourcePath>of(
        "foo/bar.h", new TestSourcePath("header1.h"),
        "foo/hello.h", new TestSourcePath("header2.h"));


    ImmutableMap<Path, SourcePath> expected = ImmutableMap.<Path, SourcePath>of(
        target.getBasePath().resolve("foo/bar.h"), new TestSourcePath("header1.h"),
        target.getBasePath().resolve("foo/hello.h"), new TestSourcePath("header2.h"));
    ImmutableMap<Path, SourcePath> actual = CxxPreprocessables.resolveHeaderMap(
        target.getBasePath(), headerMap);
    assertEquals(expected, actual);
  }

  @Test
  public void getTransitiveCxxPreprocessorInput() throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));


    BuildTarget cppDepTarget1 = BuildTargetFactory.newInstance("//:cpp1");
    CxxPreprocessorInput input1 = CxxPreprocessorInput.builder()
        .addRules(cppDepTarget1)
        .putPreprocessorFlags(CxxSource.Type.C, "-Dtest=yes")
        .putPreprocessorFlags(CxxSource.Type.CXX, "-Dtest=yes")
        .addIncludeRoots(Paths.get("foo/bar"), Paths.get("hello"))
        .addSystemIncludeRoots(Paths.get("/usr/include"))
        .build();
    BuildTarget depTarget1 = BuildTargetFactory.newInstance("//:dep1");
    FakeCxxPreprocessorDep dep1 = createFakeCxxPreprocessorDep(depTarget1, pathResolver, input1);


    BuildTarget cppDepTarget2 = BuildTargetFactory.newInstance("//:cpp2");
    CxxPreprocessorInput input2 = CxxPreprocessorInput.builder()
        .addRules(cppDepTarget2)
        .putPreprocessorFlags(CxxSource.Type.C, "-DBLAH")
        .putPreprocessorFlags(CxxSource.Type.CXX, "-DBLAH")
        .addIncludeRoots(Paths.get("goodbye"))
        .addSystemIncludeRoots(Paths.get("test"))
        .build();
    BuildTarget depTarget2 = BuildTargetFactory.newInstance("//:dep2");
    FakeCxxPreprocessorDep dep2 = createFakeCxxPreprocessorDep(depTarget2, pathResolver, input2);


    BuildTarget depTarget3 = BuildTargetFactory.newInstance("//:dep3");
    CxxPreprocessorInput nothing = CxxPreprocessorInput.EMPTY;
    FakeCxxPreprocessorDep dep3 = createFakeCxxPreprocessorDep(depTarget3,
        pathResolver,
        nothing, dep1, dep2);



    ImmutableList<CxxPreprocessorInput> expected = ImmutableList.of(nothing, input1, input2);
    ImmutableList<CxxPreprocessorInput> actual = ImmutableList.copyOf(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.<BuildRule>of(dep3)));
    assertEquals(expected, actual);
  }

  @Test
  public void createHeaderSymlinkTreeBuildRuleHasNoDeps() {
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);


    FakeBuildRule dep = createFakeBuildRule(
        BuildTargetFactory.newInstance("//random:dep"),
        pathResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = new FakeBuildRuleParamsBuilder(target)
        .setDeps(ImmutableSortedSet.<BuildRule>of(dep))
        .build();
    Path root = Paths.get("root");



    Genrule genrule = (Genrule) GenruleBuilder
        .newGenruleBuilder(BuildTargetFactory.newInstance("//:genrule"))
        .setOut("foo/bar.o")
        .build(resolver);



    ImmutableMap<Path, SourcePath> links = ImmutableMap.<Path, SourcePath>of(
        Paths.get("link1"),
        new TestSourcePath("hello"),
        Paths.get("link2"),
        new BuildTargetSourcePath(PROJECT_FILESYSTEM, genrule.getBuildTarget()));


    SymlinkTree symlinkTree = CxxPreprocessables.createHeaderSymlinkTreeBuildRule(
        pathResolver,
        target,
        params,
        root,
        links);




    assertTrue(symlinkTree.getDeps().isEmpty());
  }

  @Test
  public void getTransitiveNativeLinkableInputDoesNotTraversePastNonNativeLinkables()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));


    String sentinal = "bottom";
    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .putPreprocessorFlags(CxxSource.Type.C, sentinal)
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);



    BuildRule middle = new FakeBuildRule("//:middle", pathResolver, bottom);


    CxxPreprocessorInput topInput = CxxPreprocessorInput.EMPTY;
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, middle);



    CxxPreprocessorInput totalInput = CxxPreprocessorInput.concat(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.of(top)));
    assertTrue(bottomInput.getPreprocessorFlags().get(CxxSource.Type.C).contains(sentinal));
    assertFalse(totalInput.getPreprocessorFlags().get(CxxSource.Type.C).contains(sentinal));
  }

  @Test
  public void combiningTransitiveDependenciesThrowsForConflictingHeaders()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));

    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("bottom/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("bottom/file.h"))
                .build())
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);

    CxxPreprocessorInput topInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("top/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("top/file.h"))
                .build())
        .build();
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, bottom);

    exception.expect(CxxHeaders.ConflictingHeadersException.class);
    exception.expectMessage(String.format(
            "'%s' maps to both [%s, %s].",
            Paths.get("prefix/file.h"),
            Paths.get("bottom/file.h"),
            Paths.get("top/file.h")));

    CxxPreprocessorInput.concat(
        CxxPreprocessables.getTransitiveCxxPreprocessorInput(
            cxxPlatform,
            ImmutableList.of(top)));
  }

  @Test
  public void combiningTransitiveDependenciesDoesNotThrowForCompatibleHeaders()
      throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    CxxPlatform cxxPlatform = DefaultCxxPlatforms.build(new CxxBuckConfig(new FakeBuckConfig()));

    CxxPreprocessorInput bottomInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();
    BuildRule bottom = createFakeCxxPreprocessorDep("//:bottom", pathResolver, bottomInput);

    CxxPreprocessorInput topInput = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();
    BuildRule top = createFakeCxxPreprocessorDep("//:top", pathResolver, topInput, bottom);

    CxxPreprocessorInput expected = CxxPreprocessorInput.builder()
        .setIncludes(
            CxxHeaders.builder()
                .putNameToPathMap(
                    Paths.get("prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .putFullNameToPathMap(
                    Paths.get("buck-out/something-else/prefix/file.h"),
                    new TestSourcePath("common/file.h"))
                .build())
        .build();

    assertEquals(
        expected,
        CxxPreprocessorInput.concat(
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                cxxPlatform,
                ImmutableList.of(top))));
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import com.facebook.buck.android.AndroidPackageable;
import com.facebook.buck.android.AndroidPackageableCollector;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.HasBuildTarget;
import com.facebook.buck.python.PythonPackageComponents;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TargetGraph;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.rules.coercer.SourceWithFlags;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Optional;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Test;

import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxBinaryDescriptionTest {

  private static FakeBuildRule createFakeBuildRule(
      String target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(BuildTargetFactory.newInstance(target))
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Test
  @SuppressWarnings("PMD.UseAssertTrueInsteadOfAssertEquals")
  public void createBuildRule() {
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem();
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);
    CxxPlatform cxxPlatform = CxxBinaryBuilder.createDefaultPlatform();


    String genHeaderName = "test/foo.h";
    BuildTarget genHeaderTarget = BuildTargetFactory.newInstance("//:genHeader");
    Genrule genHeader = (Genrule) GenruleBuilder
        .newGenruleBuilder(genHeaderTarget)
        .setOut(genHeaderName)
        .build(resolver);


    String genSourceName = "test/foo.cpp";
    BuildTarget genSourceTarget = BuildTargetFactory.newInstance("//:genSource");
    Genrule genSource = (Genrule) GenruleBuilder
        .newGenruleBuilder(genSourceTarget)
        .setOut(genSourceName)
        .build(resolver);


    final BuildRule header = createFakeBuildRule("//:header", pathResolver);
    final BuildRule headerSymlinkTree = createFakeBuildRule("//:symlink", pathResolver);
    final Path headerSymlinkTreeRoot = Paths.get("symlink/tree/root");
    final BuildRule archive = createFakeBuildRule("//:archive", pathResolver);
    final Path archiveOutput = Paths.get("output/path/lib.a");
    BuildTarget depTarget = BuildTargetFactory.newInstance("//:dep");
    BuildRuleParams depParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
    AbstractCxxLibrary dep = new AbstractCxxLibrary(depParams, pathResolver) {

      @Override
      public CxxPreprocessorInput getCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
        return CxxPreprocessorInput.builder()
            .addRules(
                header.getBuildTarget(),
                headerSymlinkTree.getBuildTarget())
            .addIncludeRoots(headerSymlinkTreeRoot)
            .build();
      }

      @Override
      public ImmutableMap<BuildTarget, CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(
          CxxPlatform cxxPlatform,
          HeaderVisibility headerVisibility) {
        return ImmutableMap.of(
            getBuildTarget(),
            getCxxPreprocessorInput(cxxPlatform, headerVisibility));
      }

      @Override
      public NativeLinkableInput getNativeLinkableInput(
          CxxPlatform cxxPlatform,
          Linker.LinkableDepType type) {
        return NativeLinkableInput.of(
            ImmutableList.<SourcePath>of(
                new BuildTargetSourcePath(getProjectFilesystem(), archive.getBuildTarget())),
            ImmutableList.of(archiveOutput.toString()));
      }

      @Override
      public Optional<Linker.LinkableDepType> getPreferredLinkage(CxxPlatform cxxPlatform) {
        return Optional.absent();
      }

      @Override
      public PythonPackageComponents getPythonPackageComponents(CxxPlatform cxxPlatform) {
        return PythonPackageComponents.of(
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableMap.<Path, SourcePath>of(),
            ImmutableSet.<SourcePath>of(),
            Optional.<Boolean>absent());
      }

      @Override
      public Iterable<AndroidPackageable> getRequiredPackageables() {
        return ImmutableList.of();
      }

      @Override
      public void addToCollector(AndroidPackageableCollector collector) {}

      @Override
      public ImmutableMap<String, SourcePath> getSharedLibraries(CxxPlatform cxxPlatform) {
        return ImmutableMap.of();
      }

      @Override
      public boolean isTestedBy(BuildTarget buildTarget) {
        return false;
      }
    };
    resolver.addAllToIndex(ImmutableList.of(header, headerSymlinkTree, archive, dep));


    BuildTarget target = BuildTargetFactory.newInstance("//:rule");
    CxxBinaryBuilder cxxBinaryBuilder =
        (CxxBinaryBuilder) new CxxBinaryBuilder(target)
              .setSrcs(
                  ImmutableList.of(
                      SourceWithFlags.of(new TestSourcePath("test/bar.cpp")),
                      SourceWithFlags.of(
                          new BuildTargetSourcePath(
                              projectFilesystem,
                              genSource.getBuildTarget()))))
              .setHeaders(
                  ImmutableList.<SourcePath>of(
                      new TestSourcePath("test/bar.h"),
                      new BuildTargetSourcePath(projectFilesystem, genHeader.getBuildTarget())))
              .setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
    CxxBinary binRule = (CxxBinary) cxxBinaryBuilder.build(resolver);
    CxxLink rule = binRule.getRule();
    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            cxxBinaryBuilder.createBuildRuleParams(resolver, projectFilesystem, TargetGraph.EMPTY),
            resolver,
            pathResolver,
            cxxPlatform,
            ImmutableList.<CxxPreprocessorInput>of(),
            ImmutableList.<String>of());



    assertEquals(
        ImmutableSet.of(
            cxxSourceRuleFactory.createCompileBuildTarget(
                "test/bar.cpp",
                CxxSourceRuleFactory.PicType.PDC),
            cxxSourceRuleFactory.createCompileBuildTarget(
                genSourceName,
                CxxSourceRuleFactory.PicType.PDC),
            archive.getBuildTarget()),
        FluentIterable.from(rule.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule preprocessRule1 = resolver.getRule(
        cxxSourceRuleFactory.createPreprocessBuildTarget(
            "test/bar.cpp",
            CxxSource.Type.CXX,
            CxxSourceRuleFactory.PicType.PDC));
    assertEquals(
        ImmutableSet.of(
            genHeaderTarget,
            headerSymlinkTree.getBuildTarget(),
            header.getBuildTarget(),
            CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
                target,
                cxxPlatform.getFlavor(),
                HeaderVisibility.PRIVATE)),
        FluentIterable.from(preprocessRule1.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule compileRule1 = resolver.getRule(
        cxxSourceRuleFactory.createCompileBuildTarget(
            "test/bar.cpp",
            CxxSourceRuleFactory.PicType.PDC));
    assertNotNull(compileRule1);
    assertEquals(
        ImmutableSet.of(
            preprocessRule1.getBuildTarget()),
        FluentIterable.from(compileRule1.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule preprocessRule2 = resolver.getRule(
        cxxSourceRuleFactory.createPreprocessBuildTarget(
            genSourceName,
            CxxSource.Type.CXX,
            CxxSourceRuleFactory.PicType.PDC));
    assertEquals(
        ImmutableSet.of(
            genHeaderTarget,
            genSourceTarget,
            headerSymlinkTree.getBuildTarget(),
            header.getBuildTarget(),
            CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(
                target,
                cxxPlatform.getFlavor(),
                HeaderVisibility.PRIVATE)),
        FluentIterable.from(preprocessRule2.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());



    BuildRule compileRule2 = resolver.getRule(
        cxxSourceRuleFactory.createCompileBuildTarget(
            genSourceName,
            CxxSourceRuleFactory.PicType.PDC));
    assertNotNull(compileRule2);
    assertEquals(
        ImmutableSet.of(
            preprocessRule2.getBuildTarget()),
        FluentIterable.from(compileRule2.getDeps())
            .transform(HasBuildTarget.TO_TARGET)
            .toSet());
  }

}

<code block>

package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.model.ImmutableFlavor;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.FakeBuildContext;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.FakeBuildableContext;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.step.fs.MkdirStep;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.facebook.buck.testutil.MoreAsserts;
import com.facebook.buck.testutil.TargetGraphFactory;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;

import org.junit.Test;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class CxxCompilationDatabaseTest {

  private void runCombinedTest(
      CxxPreprocessMode strategy,
      ImmutableList<String> expectedArguments) {
    BuildTarget testBuildTarget = BuildTarget
        .builder(BuildTargetFactory.newInstance("//foo:baz"))
        .addAllFlavors(
            ImmutableSet.of(CxxCompilationDatabase.COMPILATION_DATABASE))
        .build();
    BuildRuleParams testBuildRuleParams = new FakeBuildRuleParamsBuilder(testBuildTarget)
        .setTargetGraph(
            TargetGraphFactory.newInstance(
                new CxxLibraryBuilder(testBuildTarget).build()))
        .build();

    BuildRuleResolver testBuildRuleResolver = new BuildRuleResolver();
    SourcePathResolver testSourcePathResolver = new SourcePathResolver(testBuildRuleResolver);

    BuildTarget preprocessTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("preprocess-test.cpp"))
        .build();
    BuildTarget compileTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("compile-test.cpp"))
        .build();

    ImmutableSortedSet.Builder<CxxPreprocessAndCompile> rules = ImmutableSortedSet.naturalOrder();
    CxxPreprocessAndCompileStep.Operation operation;
    BuildRuleParams compileBuildRuleParams;
    switch (strategy) {
      case SEPARATE:
        operation = CxxPreprocessAndCompileStep.Operation.COMPILE;
        CxxPreprocessAndCompile preprocessRule = new CxxPreprocessAndCompile(
            new FakeBuildRuleParamsBuilder(preprocessTarget).build(),
            testSourcePathResolver,
            operation,
            Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),
            Optional.of(ImmutableList.<String>of()),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Paths.get("test.o"),
            new TestSourcePath("test.cpp"),
            CxxSource.Type.CXX,
            ImmutableList.of(
                Paths.get("foo/bar"),
                Paths.get("test")),
            ImmutableList.<Path>of(),
            ImmutableList.<Path>of(),
            ImmutableList.<CxxHeaders>of(),
            CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);
        rules.add(preprocessRule);
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget)
            .setDeps(ImmutableSortedSet.<BuildRule>of(preprocessRule))
            .build();
        break;
      case COMBINED:
        operation = CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO;
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget).build();
        break;
      case PIPED:
        operation = CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE;
        compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget).build();
        break;
      default:
        throw new RuntimeException("Invalid strategy");
    }
    rules.add(
        new CxxPreprocessAndCompile(
            compileBuildRuleParams,
            testSourcePathResolver,
            operation,
            Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),
            Optional.of(ImmutableList.<String>of()),
            Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
            Optional.of(ImmutableList.<String>of()),
            Paths.get("test.o"),
            new TestSourcePath("test.cpp"),
            CxxSource.Type.CXX,
            ImmutableList.of(
                Paths.get("foo/bar"),
                Paths.get("test")),
            ImmutableList.<Path>of(),
            ImmutableList.<Path>of(),
            ImmutableList.<CxxHeaders>of(),
            CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER));

    CxxCompilationDatabase compilationDatabase = CxxCompilationDatabase.createCompilationDatabase(
        testBuildRuleParams,
        testSourcePathResolver,
        strategy,
        rules.build());

    assertEquals(
        "getPathToOutput() should be a function of the build target.",
        Paths.get("buck-out/gen/foo/__baz#compilation-database.json"),
        compilationDatabase.getPathToOutput());

    BuildContext buildContext = FakeBuildContext.NOOP_CONTEXT;
    BuildableContext buildableContext = new FakeBuildableContext();
    List<Step> buildSteps = compilationDatabase.getBuildSteps(buildContext, buildableContext);
    assertEquals(2, buildSteps.size());
    assertTrue(buildSteps.get(0) instanceof MkdirStep);
    assertTrue(buildSteps.get(1) instanceof
            CxxCompilationDatabase.GenerateCompilationCommandsJson);

    final String root = "/Users/user/src";
    final Path fakeRoot = Paths.get(root);
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem() {
      @Override
      public Path resolve(Path relativePath) {
        return fakeRoot.resolve(relativePath);
      }
    };
    ExecutionContext context = TestExecutionContext
        .newBuilder()
        .setProjectFilesystem(projectFilesystem)
        .build();
    CxxCompilationDatabase.GenerateCompilationCommandsJson step =
        (CxxCompilationDatabase.GenerateCompilationCommandsJson) buildSteps.get(1);
    Iterable<CxxCompilationDatabaseEntry> observedEntries =
        step.createEntries(context);
    Iterable<CxxCompilationDatabaseEntry> expectedEntries =
        ImmutableList.of(
          new CxxCompilationDatabaseEntry(
              root + "/foo",
              root + "/test.cpp",
              expectedArguments));
    MoreAsserts.assertIterablesEquals(expectedEntries, observedEntries);
  }

  @Test
  public void testCompilationDatabseWithCombinedPreprocessAndCompileStrategy() {
    runCombinedTest(CxxPreprocessMode.COMBINED,
        ImmutableList.of(
            "compiler",
            "-I",
            "foo/bar",
            "-I",
            "test",
            "-x",
            "c++",
            "-c",
            "test.cpp",
            "-o",
            "test.o"));
  }

  @Test
  public void testCompilationDatabseWithPipedPreprocessAndCompileStrategy() {
    runCombinedTest(CxxPreprocessMode.PIPED,
        ImmutableList.of(
            "compiler",
            "-x",
            "c++",
            "-c",
            "-I",
            "foo/bar",
            "-I",
            "test",
            "-o",
            "test.o",
            "test.cpp"));
  }

  @Test
  public void testCompilationDatabseWithSeperatedPreprocessAndCompileStrategy() {
    BuildTarget testBuildTarget = BuildTarget
        .builder(BuildTargetFactory.newInstance("//foo:baz"))
        .addAllFlavors(
            ImmutableSet.of(CxxCompilationDatabase.COMPILATION_DATABASE))
        .build();
    BuildRuleParams testBuildRuleParams = new FakeBuildRuleParamsBuilder(testBuildTarget)
        .setTargetGraph(
            TargetGraphFactory.newInstance(
                new CxxLibraryBuilder(testBuildTarget).build()))
        .build();

    BuildRuleResolver testBuildRuleResolver = new BuildRuleResolver();
    SourcePathResolver testSourcePathResolver = new SourcePathResolver(testBuildRuleResolver);

    BuildTarget preprocessTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("preprocess-test.cpp"))
        .build();
    BuildRuleParams preprocessBuildRuleParams = new FakeBuildRuleParamsBuilder(preprocessTarget)
        .build();
    CxxPreprocessAndCompile testPreprocessRule = new CxxPreprocessAndCompile(
        preprocessBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
        Optional.of(ImmutableList.<String>of()),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Paths.get("test.ii"),
        new TestSourcePath("test.cpp"),
        CxxSource.Type.CXX_CPP_OUTPUT,
        ImmutableList.of(
            Paths.get("foo/bar"),
            Paths.get("test")),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<CxxHeaders>of(),
        CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);

    BuildTarget compileTarget = BuildTarget
        .builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget())
        .addFlavors(
            ImmutableFlavor.of("compile-test.cpp"))
        .build();
    BuildRuleParams compileBuildRuleParams = new FakeBuildRuleParamsBuilder(compileTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(testPreprocessRule))
        .build();
    CxxPreprocessAndCompile testCompileRule = new CxxPreprocessAndCompile(
        compileBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.<Tool>of(new HashedFileTool(Paths.get("compiler"))),
        Optional.of(ImmutableList.<String>of()),
        Paths.get("test.o"),
        new TestSourcePath("test.ii"),
        CxxSource.Type.CXX_CPP_OUTPUT,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        ImmutableList.<CxxHeaders>of(),
        CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);

    CxxCompilationDatabase compilationDatabase = CxxCompilationDatabase.createCompilationDatabase(
        testBuildRuleParams,
        testSourcePathResolver,
        CxxPreprocessMode.SEPARATE,
        ImmutableSortedSet.of(testPreprocessRule, testCompileRule));

    assertEquals(
        "getPathToOutput() should be a function of the build target.",
        Paths.get("buck-out/gen/foo/__baz#compilation-database.json"),
        compilationDatabase.getPathToOutput());

    BuildContext buildContext = FakeBuildContext.NOOP_CONTEXT;
    BuildableContext buildableContext = new FakeBuildableContext();
    List<Step> buildSteps = compilationDatabase.getBuildSteps(buildContext, buildableContext);
    assertEquals(2, buildSteps.size());
    assertTrue(buildSteps.get(0) instanceof MkdirStep);
    assertTrue(buildSteps.get(1) instanceof
            CxxCompilationDatabase.GenerateCompilationCommandsJson);

    final String root = "/Users/user/src";
    final Path fakeRoot = Paths.get(root);
    ProjectFilesystem projectFilesystem = new FakeProjectFilesystem() {
      @Override
      public Path resolve(Path relativePath) {
        return fakeRoot.resolve(relativePath);
      }
    };
    ExecutionContext context = TestExecutionContext
        .newBuilder()
        .setProjectFilesystem(projectFilesystem)
        .build();
    CxxCompilationDatabase.GenerateCompilationCommandsJson step =
        (CxxCompilationDatabase.GenerateCompilationCommandsJson) buildSteps.get(1);
    Iterable<CxxCompilationDatabaseEntry> observedEntries =
        step.createEntries(context);
    Iterable<CxxCompilationDatabaseEntry> expectedEntries =
        ImmutableList.of(
            new CxxCompilationDatabaseEntry(
                root + "/foo",
                root + "/test.cpp",
                ImmutableList.of(
                    "compiler",
                    "-x",
                    "c++-cpp-output",
                    "-c",
                    "-I",
                    "foo/bar",
                    "-I",
                    "test",
                    "-o",
                    "test.o",
                    "test.cpp")));
    MoreAsserts.assertIterablesEquals(expectedEntries, observedEntries);
  }
}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.keys.DefaultRuleKeyBuilderFactory;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyBuilderFactory;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.testutil.FakeFileHashCache;
import com.google.common.base.Optional;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import org.junit.Test;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxPreprocessAndCompileTest {

  private static final Tool DEFAULT_PREPROCESSOR = new HashedFileTool(Paths.get("preprocessor"));
  private static final Tool DEFAULT_COMPILER = new HashedFileTool(Paths.get("compiler"));
  private static final ImmutableList<String> DEFAULT_FLAGS =
      ImmutableList.of("-fsanitize=address");
  private static final Path DEFAULT_OUTPUT = Paths.get("test.o");
  private static final SourcePath DEFAULT_INPUT = new TestSourcePath("test.cpp");
  private static final CxxSource.Type DEFAULT_INPUT_TYPE = CxxSource.Type.CXX;
  private static final ImmutableList<CxxHeaders> DEFAULT_INCLUDES =
      ImmutableList.of(
          CxxHeaders.builder()
              .putNameToPathMap(Paths.get("test.h"), new TestSourcePath("foo/test.h"))
              .build());
  private static final ImmutableList<Path> DEFAULT_INCLUDE_ROOTS = ImmutableList.of(
      Paths.get("foo/bar"),
      Paths.get("test"));
  private static final ImmutableList<Path> DEFAULT_SYSTEM_INCLUDE_ROOTS = ImmutableList.of(
      Paths.get("/usr/include"),
      Paths.get("/include"));
  private static final ImmutableList<Path> DEFAULT_FRAMEWORK_ROOTS = ImmutableList.of();
  private static final DebugPathSanitizer DEFAULT_SANITIZER =
      CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER;

  private RuleKey generateRuleKey(
      RuleKeyBuilderFactory factory,
      AbstractBuildRule rule) {

    RuleKey.Builder builder = factory.newInstance(rule);
    return builder.build();
  }

  @Test
  public void testThatInputChangesCauseRuleKeyChanges() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("preprocessor", Strings.repeat("a", 40))
                    .put("compiler", Strings.repeat("a", 40))
                    .put("test.o", Strings.repeat("b", 40))
                    .put("test.cpp", Strings.repeat("c", 40))
                    .put("different", Strings.repeat("d", 40))
                    .put("foo/test.h", Strings.repeat("e", 40))
                    .put("path/to/a/plugin.so", Strings.repeat("f", 40))
                    .put("path/to/a/different/plugin.so", Strings.repeat("a0", 40))
                    .build()),
            pathResolver);


    RuleKey defaultRuleKey = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS,
            DEFAULT_INCLUDES,
            DEFAULT_SANITIZER));


    RuleKey compilerChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.<Tool>of(new HashedFileTool(Paths.get("different"))),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, compilerChange);


    RuleKey operationChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(DEFAULT_FLAGS),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, operationChange);


    RuleKey flagsChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(ImmutableList.of("-different")),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, flagsChange);


    RuleKey inputChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            new TestSourcePath("different"),
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, inputChange);



    RuleKey includesChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            ImmutableList.of(Paths.get("different")),
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertEquals(defaultRuleKey, includesChange);



    RuleKey systemIncludesChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            ImmutableList.of(Paths.get("different")),
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertEquals(defaultRuleKey, systemIncludesChange);


    RuleKey frameworkRootsChange = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.COMPILE,
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            Optional.of(DEFAULT_COMPILER),
            Optional.of(DEFAULT_FLAGS),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            ImmutableList.of(Paths.get("different")), DEFAULT_INCLUDES, DEFAULT_SANITIZER));
    assertNotEquals(defaultRuleKey, frameworkRootsChange);
  }

  @Test
  public void sanitizedPathsInFlagsDoNotAffectRuleKey() {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    RuleKeyBuilderFactory ruleKeyBuilderFactory =
        new DefaultRuleKeyBuilderFactory(
            FakeFileHashCache.createFromStrings(
                ImmutableMap.<String, String>builder()
                    .put("preprocessor", Strings.repeat("a", 40))
                    .put("compiler", Strings.repeat("a", 40))
                    .put("test.o", Strings.repeat("b", 40))
                    .put("test.cpp", Strings.repeat("c", 40))
                    .put("different", Strings.repeat("d", 40))
                    .put("foo/test.h", Strings.repeat("e", 40))
                    .put("path/to/a/plugin.so", Strings.repeat("f", 40))
                    .put("path/to/a/different/plugin.so", Strings.repeat("a0", 40))
                    .build()),
            pathResolver);


    int pathSize = 10;
    DebugPathSanitizer sanitizer1 = new DebugPathSanitizer(
        pathSize,
        File.separatorChar,
        Paths.get("PWD"),
        ImmutableBiMap.of(Paths.get("something"), Paths.get("A")));
    DebugPathSanitizer sanitizer2 = new DebugPathSanitizer(
        pathSize,
        File.separatorChar,
        Paths.get("PWD"),
        ImmutableBiMap.of(Paths.get("different"), Paths.get("A")));


    ImmutableList<String> flags1 = ImmutableList.of("-Isomething/foo");
    RuleKey ruleKey1 = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(flags1),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, sanitizer1));


    ImmutableList<String> flags2 = ImmutableList.of("-Idifferent/foo");
    RuleKey ruleKey2 = generateRuleKey(
        ruleKeyBuilderFactory,
        new CxxPreprocessAndCompile(
            params,
            pathResolver,
            CxxPreprocessAndCompileStep.Operation.PREPROCESS,
            Optional.of(DEFAULT_PREPROCESSOR),
            Optional.of(flags2),
            Optional.<Tool>absent(),
            Optional.<ImmutableList<String>>absent(),
            DEFAULT_OUTPUT,
            DEFAULT_INPUT,
            DEFAULT_INPUT_TYPE,
            DEFAULT_INCLUDE_ROOTS,
            DEFAULT_SYSTEM_INCLUDE_ROOTS,
            DEFAULT_FRAMEWORK_ROOTS, DEFAULT_INCLUDES, sanitizer2));

    assertEquals(ruleKey1, ruleKey2);
  }

  @Test
  public void usesCorrectCommandForCompile() {


    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ImmutableList<String> flags = ImmutableList.of("-ffunction-sections");
    Path output = Paths.get("test.o");
    Path input = Paths.get("test.ii");

    CxxPreprocessAndCompile buildRule = new CxxPreprocessAndCompile(
        params,
        pathResolver,
        CxxPreprocessAndCompileStep.Operation.COMPILE,
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        Optional.of(DEFAULT_COMPILER),
        Optional.of(flags),
        output,
        new TestSourcePath(input.toString()),
        DEFAULT_INPUT_TYPE,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        DEFAULT_FRAMEWORK_ROOTS,
        ImmutableList.of(CxxHeaders.builder().build()),
        DEFAULT_SANITIZER);

    ImmutableList<String> expectedCompileCommand = ImmutableList.<String>builder()
        .add("compiler")
        .add("-ffunction-sections")
        .add("-x", "c++")
        .add("-c")
        .add(input.toString())
        .add("-o", output.toString())
        .build();
    ImmutableList<String> actualCompileCommand = buildRule.makeMainStep().getCommand();
    assertEquals(expectedCompileCommand, actualCompileCommand);
  }

  @Test
  public void usesCorrectCommandForPreprocess() {


    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ImmutableList<String> flags = ImmutableList.of("-Dtest=blah");
    Path output = Paths.get("test.ii");
    Path input = Paths.get("test.cpp");

    CxxPreprocessAndCompile buildRule = new CxxPreprocessAndCompile(
        params,
        pathResolver,
        CxxPreprocessAndCompileStep.Operation.PREPROCESS,
        Optional.of(DEFAULT_PREPROCESSOR),
        Optional.of(flags),
        Optional.<Tool>absent(),
        Optional.<ImmutableList<String>>absent(),
        output,
        new TestSourcePath(input.toString()),
        DEFAULT_INPUT_TYPE,
        ImmutableList.<Path>of(),
        ImmutableList.<Path>of(),
        DEFAULT_FRAMEWORK_ROOTS,
        ImmutableList.of(CxxHeaders.builder().build()),
        DEFAULT_SANITIZER);


    ImmutableList<String> expectedPreprocessCommand = ImmutableList.<String>builder()
        .add("preprocessor")
        .add("-Dtest=blah")
        .add("-x", "c++")
        .add("-E")
        .add(input.toString())
        .build();
    ImmutableList<String> actualPreprocessCommand = buildRule.makeMainStep().getCommand();
    assertEquals(expectedPreprocessCommand, actualPreprocessCommand);
  }
}

<code block>


package com.facebook.buck.cxx;

import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.SourcePathResolver;
import com.google.common.collect.ImmutableList;

public class CxxSourceRuleFactoryHelper {

  private CxxSourceRuleFactoryHelper() {}

  public static CxxSourceRuleFactory of(BuildTarget target, CxxPlatform cxxPlatform) {
    BuildRuleResolver resolver = new BuildRuleResolver();
    return new CxxSourceRuleFactory(
        BuildRuleParamsFactory.createTrivialBuildRuleParams(target),
        resolver,
        new SourcePathResolver(resolver),
        cxxPlatform,
        ImmutableList.<CxxPreprocessorInput>of(),
        ImmutableList.<String>of());
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SymlinkTree;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.shell.Genrule;
import com.facebook.buck.shell.GenruleBuilder;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Predicates;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.Files;

import org.junit.Test;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CxxDescriptionEnhancerTest {

  @Test
  public void createLexYaccBuildRules() throws IOException {
    BuildRuleResolver resolver = new BuildRuleResolver();


    FakeProjectFilesystem filesystem = new FakeProjectFilesystem();
    Path lexPath = Paths.get("lex");
    filesystem.touch(lexPath);
    Path yaccPath = Paths.get("yacc");
    filesystem.touch(yaccPath);
    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.of(
                "lex", lexPath.toString(),
                "yacc", yaccPath.toString())),
        filesystem);
    CxxPlatform cxxBuckConfig = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));


    BuildTarget target = BuildTargetFactory.newInstance("//:test");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);


    String lexSourceName = "test.ll";
    BuildTarget genruleTarget = BuildTargetFactory.newInstance("//:genrule_lex");
    Genrule genrule = (Genrule) GenruleBuilder
        .newGenruleBuilder(genruleTarget)
        .setOut(lexSourceName)
        .build(resolver);
    SourcePath lexSource = new BuildTargetSourcePath(filesystem, genrule.getBuildTarget());


    String yaccSourceName = "test.yy";
    SourcePath yaccSource = new TestSourcePath(yaccSourceName);


    CxxHeaderSourceSpec actual = CxxDescriptionEnhancer.createLexYaccBuildRules(
        params,
        resolver,
        cxxBuckConfig,
        ImmutableList.<String>of(),
        ImmutableMap.of(lexSourceName, lexSource),
        ImmutableList.<String>of(),
        ImmutableMap.of(yaccSourceName, yaccSource));


    Lex lex = (Lex) resolver.getRule(
        CxxDescriptionEnhancer.createLexBuildTarget(target, lexSourceName));
    assertNotNull(lex);
    assertEquals(
        ImmutableSortedSet.<BuildRule>of(genrule),
        lex.getDeps());


    Yacc yacc = (Yacc) resolver.getRule(
        CxxDescriptionEnhancer.createYaccBuildTarget(target, yaccSourceName));
    assertNotNull(yacc);
    assertEquals(
        ImmutableSortedSet.<BuildRule>of(),
        yacc.getDeps());


    Path lexOutputSource = CxxDescriptionEnhancer.getLexSourceOutputPath(target, lexSourceName);
    Path lexOutputHeader = CxxDescriptionEnhancer.getLexHeaderOutputPath(target, lexSourceName);
    Path yaccOutputPrefix =
        CxxDescriptionEnhancer.getYaccOutputPrefix(
            target,
            Files.getNameWithoutExtension(yaccSourceName));
    Path yaccOutputSource = Yacc.getSourceOutputPath(yaccOutputPrefix);
    Path yaccOutputHeader = Yacc.getHeaderOutputPath(yaccOutputPrefix);
    CxxHeaderSourceSpec expected =
        CxxHeaderSourceSpec.of(
            ImmutableMap.<Path, SourcePath>of(
                target.getBasePath().resolve(lexSourceName + ".h"),
                new BuildTargetSourcePath(filesystem, lex.getBuildTarget(), lexOutputHeader),
                target.getBasePath().resolve(yaccSourceName + ".h"),
                new BuildTargetSourcePath(filesystem, yacc.getBuildTarget(), yaccOutputHeader)),
            ImmutableMap.of(
                lexSourceName + ".cc",
                CxxSource.of(
                    CxxSource.Type.CXX,
                    new BuildTargetSourcePath(filesystem, lex.getBuildTarget(), lexOutputSource),
                    ImmutableList.<String>of()),
                yaccSourceName + ".cc",
                CxxSource.of(
                    CxxSource.Type.CXX,
                    new BuildTargetSourcePath(filesystem, yacc.getBuildTarget(), yaccOutputSource),
                    ImmutableList.<String>of())));
    assertEquals(expected, actual);
  }

  @Test
  public void libraryTestIncludesPrivateHeadersOfLibraryUnderTest() throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());

    BuildTarget libTarget = BuildTargetFactory.newInstance("//:lib");
    BuildTarget testTarget = BuildTargetFactory.newInstance("//:test");

    BuildRuleParams libParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(libTarget);
    FakeCxxLibrary libRule = new FakeCxxLibrary(
        libParams,
        pathResolver,
        BuildTargetFactory.newInstance("//:header"),
        BuildTargetFactory.newInstance("//:symlink"),
        Paths.get("symlink/tree/lib"),
        BuildTargetFactory.newInstance("//:privateheader"),
        BuildTargetFactory.newInstance("//:privatesymlink"),
        Paths.get("private/symlink/tree/lib"),
        new FakeBuildRule("//:archive", pathResolver),
        Paths.get("output/path/lib.a"),
        new FakeBuildRule("//:shared", pathResolver),
        Paths.get("output/path/lib.so"),
        "lib.so",

        ImmutableSortedSet.of(testTarget)
    );

    BuildRuleParams testParams = new FakeBuildRuleParamsBuilder(testTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(libRule))
        .build();

    ImmutableList<CxxPreprocessorInput> combinedInput =
        CxxDescriptionEnhancer.collectCxxPreprocessorInput(
            testParams,
            CxxPlatformUtils.DEFAULT_PLATFORM,
            ImmutableMultimap.<CxxSource.Type, String>of(),
            ImmutableList.<SourcePath>of(),
            ImmutableList.<SymlinkTree>of(),
            ImmutableList.<Path>of(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                CxxPlatformUtils.DEFAULT_PLATFORM,
                FluentIterable.from(testParams.getDeps())
                    .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));

    assertThat(
        "Test of library should include both public and private headers",
        CxxPreprocessorInput.concat(combinedInput).getIncludeRoots(),
        hasItems(
            Paths.get("symlink/tree/lib"),
            Paths.get("private/symlink/tree/lib")));
  }

  @Test
  public void nonTestLibraryDepDoesNotIncludePrivateHeadersOfLibrary() throws Exception {
    SourcePathResolver pathResolver = new SourcePathResolver(new BuildRuleResolver());

    BuildTarget libTarget = BuildTargetFactory.newInstance("//:lib");

    BuildRuleParams libParams = BuildRuleParamsFactory.createTrivialBuildRuleParams(libTarget);
    FakeCxxLibrary libRule = new FakeCxxLibrary(
        libParams,
        pathResolver,
        BuildTargetFactory.newInstance("//:header"),
        BuildTargetFactory.newInstance("//:symlink"),
        Paths.get("symlink/tree/lib"),
        BuildTargetFactory.newInstance("//:privateheader"),
        BuildTargetFactory.newInstance("//:privatesymlink"),
        Paths.get("private/symlink/tree/lib"),
        new FakeBuildRule("//:archive", pathResolver),
        Paths.get("output/path/lib.a"),
        new FakeBuildRule("//:shared", pathResolver),
        Paths.get("output/path/lib.so"),
        "lib.so",

        ImmutableSortedSet.<BuildTarget>of()
    );

    BuildTarget otherLibDepTarget = BuildTargetFactory.newInstance("//:other");
    BuildRuleParams otherLibDepParams = new FakeBuildRuleParamsBuilder(otherLibDepTarget)
        .setDeps(ImmutableSortedSet.<BuildRule>of(libRule))
        .build();

    ImmutableList<CxxPreprocessorInput> otherInput =
        CxxDescriptionEnhancer.collectCxxPreprocessorInput(
            otherLibDepParams,
            CxxPlatformUtils.DEFAULT_PLATFORM,
            ImmutableMultimap.<CxxSource.Type, String>of(),
            ImmutableList.<SourcePath>of(),
            ImmutableList.<SymlinkTree>of(),
            ImmutableList.<Path>of(),
            CxxPreprocessables.getTransitiveCxxPreprocessorInput(
                CxxPlatformUtils.DEFAULT_PLATFORM,
                FluentIterable.from(otherLibDepParams.getDeps())
                    .filter(Predicates.instanceOf(CxxPreprocessorDep.class))));

    assertThat(
        "Non-test rule with library dep should include public and not private headers",
        CxxPreprocessorInput.concat(otherInput).getIncludeRoots(),
        allOf(
            hasItem(Paths.get("symlink/tree/lib")),
            not(hasItem(Paths.get("private/symlink/tree/lib")))));
  }

  @Test
  public void buildTargetsWithDifferentFlavorsProduceDifferentDefaultSonames() {
    BuildTarget target1 = BuildTargetFactory.newInstance("//:rule#one");
    BuildTarget target2 = BuildTargetFactory.newInstance("//:rule#two");
    assertNotEquals(
        CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
            target1,
            CxxPlatformUtils.DEFAULT_PLATFORM),
        CxxDescriptionEnhancer.getDefaultSharedLibrarySoname(
            target2,
            CxxPlatformUtils.DEFAULT_PLATFORM));
  }

}

<code block>


package com.facebook.buck.cxx;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.cli.FakeBuckConfig;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.model.BuildTarget;
import com.facebook.buck.model.BuildTargetFactory;
import com.facebook.buck.rules.BuildRule;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildRuleParamsFactory;
import com.facebook.buck.rules.BuildRuleResolver;
import com.facebook.buck.rules.BuildTargetSourcePath;
import com.facebook.buck.rules.FakeBuildRule;
import com.facebook.buck.rules.FakeBuildRuleParamsBuilder;
import com.facebook.buck.rules.PathSourcePath;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.TestSourcePath;
import com.facebook.buck.testutil.AllExistingProjectFilesystem;
import com.facebook.buck.testutil.FakeProjectFilesystem;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;

import org.hamcrest.Matchers;
import org.junit.Test;

import java.util.Collections;
import java.util.List;

public class CxxSourceRuleFactoryTest {

  private static final ProjectFilesystem PROJECT_FILESYSTEM = new FakeProjectFilesystem();

  private static final CxxPlatform CXX_PLATFORM = DefaultCxxPlatforms.build(
      new CxxBuckConfig(new FakeBuckConfig()));

  private static <T> void assertContains(ImmutableList<T> container, Iterable<T> items) {
    for (T item : items) {
      assertThat(container, Matchers.hasItem(item));
    }
  }

  private static FakeBuildRule createFakeBuildRule(
      String target,
      SourcePathResolver resolver,
      BuildRule... deps) {
    return new FakeBuildRule(
        new FakeBuildRuleParamsBuilder(BuildTargetFactory.newInstance(target))
            .setDeps(ImmutableSortedSet.copyOf(deps))
            .build(),
        resolver);
  }

  @Test
  public void createPreprocessBuildRulePropagatesCxxPreprocessorDeps() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    FakeBuildRule dep = resolver.addToIndex(
        new FakeBuildRule(
            "//:dep1",
            new SourcePathResolver(new BuildRuleResolver())));

    CxxPreprocessorInput cxxPreprocessorInput =
        CxxPreprocessorInput.builder()
            .addRules(dep.getBuildTarget())
            .build();

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            CXX_PLATFORM,
            ImmutableList.of(cxxPreprocessorInput),
            ImmutableList.<String>of());

    String name = "foo/bar.cpp";
    SourcePath input = new PathSourcePath(PROJECT_FILESYSTEM, target.getBasePath().resolve(name));
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        input,
        ImmutableList.<String>of());

    BuildRule cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocess.getDeps());
    cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocess.getDeps());
  }

  @Test
  public void preprocessFlagsFromPlatformArePropagated() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();
    SourcePathResolver pathResolver = new SourcePathResolver(resolver);

    ImmutableList<String> platformFlags = ImmutableList.of("-some", "-flags");
    CxxPlatform platform = DefaultCxxPlatforms.build(
        new CxxBuckConfig(
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of("cxxppflags", Joiner.on(" ").join(platformFlags))))));

    CxxPreprocessorInput cxxPreprocessorInput = CxxPreprocessorInput.EMPTY;

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            pathResolver,
            platform,
            ImmutableList.of(cxxPreprocessorInput),
            ImmutableList.<String>of());

    String name = "source.cpp";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(cxxPreprocess.getPreprocessorFlags().get(), platformFlags));
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(
            cxxPreprocessAndCompile.getPreprocessorFlags().get(),
            platformFlags));
  }

  @Test
  public void checkCorrectFlagsAreUsedForPreprocessBuildRules() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(buildRuleResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    Joiner space = Joiner.on(" ");

    ImmutableList<String> explicitCppflags = ImmutableList.of("-explicit-cppflag");
    ImmutableList<String> explicitCxxppflags = ImmutableList.of("-explicit-cxxppflag");
    CxxPreprocessorInput cxxPreprocessorInput =
        CxxPreprocessorInput.builder()
            .putAllPreprocessorFlags(CxxSource.Type.C, explicitCppflags)
            .putAllPreprocessorFlags(CxxSource.Type.CXX, explicitCxxppflags)
            .build();

    ImmutableList<String> asppflags = ImmutableList.of("-asppflag", "-asppflag");

    SourcePath cpp = new TestSourcePath("cpp");
    ImmutableList<String> cppflags = ImmutableList.of("-cppflag", "-cppflag");

    SourcePath cxxpp = new TestSourcePath("cxxpp");
    ImmutableList<String> cxxppflags = ImmutableList.of("-cxxppflag", "-cxxppflag");

    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.<String, String>builder()
                .put("asppflags", space.join(asppflags))
                .put("cpp", sourcePathResolver.getPath(cpp).toString())
                .put("cppflags", space.join(cppflags))
                .put("cxxpp", sourcePathResolver.getPath(cxxpp).toString())
                .put("cxxppflags", space.join(cxxppflags))
                .build()),
        filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            sourcePathResolver,
            platform,
            ImmutableList.of(cxxPreprocessorInput),
            ImmutableList.<String>of());

    String cSourceName = "test.c";
    List<String> perFileFlagsForTestC =
        ImmutableList.of("-per-file-flag-for-c-file", "-and-another-one");
    CxxSource cSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cSourceName),
        perFileFlagsForTestC);
    CxxPreprocessAndCompile cPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cPreprocess.getPreprocessorFlags().get(), explicitCppflags);
    assertContains(cPreprocess.getPreprocessorFlags().get(), cppflags);
    assertContains(cPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestC);
    CxxPreprocessAndCompile cPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), perFileFlagsForTestC);

    String cxxSourceName = "test.cpp";
    List<String> perFileFlagsForTestCpp =
        ImmutableList.of("-per-file-flag-for-cpp-file");
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(cxxSourceName),
        perFileFlagsForTestCpp);
    CxxPreprocessAndCompile cxxPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), explicitCxxppflags);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), cxxppflags);
    assertContains(cxxPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestCpp);
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), perFileFlagsForTestCpp);

    String assemblerWithCppSourceName = "test.S";
    List<String> perFileFlagsForTestS =
        ImmutableList.of("-a-flag-for-s-file", "-another-one", "-one-more");
    CxxSource assemblerWithCppSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER_WITH_CPP,
        new TestSourcePath(assemblerWithCppSourceName),
        perFileFlagsForTestS);
    CxxPreprocessAndCompile assemblerWithCppPreprocess =
        cxxSourceRuleFactory.requirePreprocessBuildRule(
            buildRuleResolver,
            assemblerWithCppSourceName,
            assemblerWithCppSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(assemblerWithCppPreprocess.getPreprocessorFlags().get(), asppflags);
    assertContains(assemblerWithCppPreprocess.getPreprocessorFlags().get(), perFileFlagsForTestS);
    CxxPreprocessAndCompile assemblerWithCppPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            assemblerWithCppSourceName,
            assemblerWithCppSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(
        assemblerWithCppPreprocessAndCompile.getCompilerFlags().get(),
        perFileFlagsForTestS);
  }

  @Test
  public void createCompileBuildRulePropagatesBuildRuleSourcePathDeps() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    FakeBuildRule dep = createFakeBuildRule("//:test", new SourcePathResolver(resolver));
    resolver.addToIndex(dep);
    SourcePath input = new BuildTargetSourcePath(PROJECT_FILESYSTEM, dep.getBuildTarget());
    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            CXX_PLATFORM,
            ImmutableList.<CxxPreprocessorInput>of(),
            ImmutableList.<String>of());

    String nameCompile = "foo/bar.ii";
    CxxSource cxxSourceCompile = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        input,
        ImmutableList.<String>of());
    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            nameCompile,
            cxxSourceCompile,
            CxxSourceRuleFactory.PicType.PDC);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxCompile.getDeps());

    String namePreprocessAndCompile = "foo/bar.cpp";
    CxxSource cxxSourcePreprocessAndCompile = CxxSource.of(
        CxxSource.Type.CXX,
        input,
        ImmutableList.<String>of());
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            namePreprocessAndCompile,
            cxxSourcePreprocessAndCompile,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertEquals(ImmutableSortedSet.<BuildRule>of(dep), cxxPreprocessAndCompile.getDeps());
  }

  @Test
  @SuppressWarnings("PMD.UseAssertTrueInsteadOfAssertEquals")
  public void createCompileBuildRulePicOption() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            CXX_PLATFORM,
            ImmutableList.<CxxPreprocessorInput>of(),
            ImmutableList.<String>of());

    String name = "foo/bar.ii";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        new TestSourcePath(name),
        ImmutableList.<String>of());



    CxxPreprocessAndCompile noPicCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertFalse(noPicCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PDC),
        noPicCompile.getBuildTarget());



    CxxPreprocessAndCompile picCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PIC);
    assertTrue(picCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PIC),
        picCompile.getBuildTarget());

    name = "foo/bar.cpp";
    cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());



    CxxPreprocessAndCompile noPicPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertFalse(noPicPreprocessAndCompile.getPreprocessorFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PDC),
        noPicPreprocessAndCompile.getBuildTarget());



    CxxPreprocessAndCompile picPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PIC,
            CxxPreprocessMode.SEPARATE);
    assertTrue(picPreprocessAndCompile.getCompilerFlags().get().contains("-fPIC"));
    assertEquals(
        cxxSourceRuleFactory.createCompileBuildTarget(
            name,
            CxxSourceRuleFactory.PicType.PIC),
        picPreprocessAndCompile.getBuildTarget());
  }

  @Test
  public void compilerFlagsFromPlatformArePropagated() {
    BuildTarget target = BuildTargetFactory.newInstance("//foo:bar");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    BuildRuleResolver resolver = new BuildRuleResolver();

    ImmutableList<String> platformFlags = ImmutableList.of("-some", "-flags");
    CxxPlatform platform = DefaultCxxPlatforms.build(
        new CxxBuckConfig(
            new FakeBuckConfig(
                ImmutableMap.of(
                    "cxx", ImmutableMap.of("cxxflags", Joiner.on(" ").join(platformFlags))))));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            resolver,
            new SourcePathResolver(resolver),
            platform,
            ImmutableList.<CxxPreprocessorInput>of(),
            ImmutableList.<String>of());

    String name = "source.ii";
    CxxSource cxxSource = CxxSource.of(
        CxxSource.Type.CXX_CPP_OUTPUT,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(cxxCompile.getCompilerFlags().get(), platformFlags));

    name = "source.cpp";
    cxxSource = CxxSource.of(
        CxxSource.Type.CXX,
        new TestSourcePath(name),
        ImmutableList.<String>of());


    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            resolver,
            name,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertNotEquals(
        -1,
        Collections.indexOfSubList(
            cxxPreprocessAndCompile.getPreprocessorFlags().get(),
            platformFlags));
  }

  @Test
  public void checkCorrectFlagsAreUsedForCompileBuildRules() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    SourcePathResolver sourcePathResolver = new SourcePathResolver(buildRuleResolver);
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();
    Joiner space = Joiner.on(" ");

    ImmutableList<String> explicitCompilerFlags = ImmutableList.of("-explicit-compilerflag");

    SourcePath as = new TestSourcePath("as");
    ImmutableList<String> asflags = ImmutableList.of("-asflag", "-asflag");

    SourcePath cc = new TestSourcePath("cc");
    ImmutableList<String> cflags = ImmutableList.of("-cflag", "-cflag");

    SourcePath cxx = new TestSourcePath("cxx");
    ImmutableList<String> cxxflags = ImmutableList.of("-cxxflag", "-cxxflag");

    FakeBuckConfig buckConfig = new FakeBuckConfig(
        ImmutableMap.of(
            "cxx", ImmutableMap.<String, String>builder()
                .put("as", sourcePathResolver.getPath(as).toString())
                .put("asflags", space.join(asflags))
                .put("cc", sourcePathResolver.getPath(cc).toString())
                .put("cflags", space.join(cflags))
                .put("cxx", sourcePathResolver.getPath(cxx).toString())
                .put("cxxflags", space.join(cxxflags))
                .build()),
        filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            sourcePathResolver,
            platform,
            ImmutableList.<CxxPreprocessorInput>of(),
            explicitCompilerFlags);

    String cSourceName = "test.i";
    List<String> cSourcePerFileFlags = ImmutableList.of("-c-source-par-file-flag");
    CxxSource cSource = CxxSource.of(
        CxxSource.Type.C_CPP_OUTPUT,
        new TestSourcePath(cSourceName),
        cSourcePerFileFlags);
    CxxPreprocessAndCompile cCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cCompile.getCompilerFlags().get(), cflags);
    assertContains(cCompile.getCompilerFlags().get(), asflags);
    assertContains(cCompile.getCompilerFlags().get(), cSourcePerFileFlags);

    cSourceName = "test.c";
    cSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cSourceName),
        cSourcePerFileFlags);
    CxxPreprocessAndCompile cPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cSourceName,
            cSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), cflags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(cPreprocessAndCompile.getCompilerFlags().get(), cSourcePerFileFlags);

    String cxxSourceName = "test.ii";
    List<String> cxxSourcePerFileFlags = ImmutableList.of("-cxx-source-par-file-flag");
    CxxSource cxxSource =
        CxxSource.of(
            CxxSource.Type.CXX_CPP_OUTPUT,
            new TestSourcePath(cxxSourceName),
            cxxSourcePerFileFlags);
    CxxPreprocessAndCompile cxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cxxCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cxxCompile.getCompilerFlags().get(), cxxflags);
    assertContains(cxxCompile.getCompilerFlags().get(), asflags);
    assertContains(cxxCompile.getCompilerFlags().get(), cxxSourcePerFileFlags);

    cxxSourceName = "test.cpp";
    cxxSource =
        CxxSource.of(
            CxxSource.Type.CXX,
            new TestSourcePath(cxxSourceName),
            cxxSourcePerFileFlags);
    CxxPreprocessAndCompile cxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cxxSourceName,
            cxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), cxxflags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(cxxPreprocessAndCompile.getCompilerFlags().get(), cxxSourcePerFileFlags);

    String cCppOutputSourceName = "test2.i";
    List<String> cCppOutputSourcePerFileFlags =
        ImmutableList.of("-c-cpp-output-source-par-file-flag");
    CxxSource cCppOutputSource = CxxSource.of(
        CxxSource.Type.C_CPP_OUTPUT,
        new TestSourcePath(cCppOutputSourceName),
        cCppOutputSourcePerFileFlags);
    CxxPreprocessAndCompile cCppOutputCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            cCppOutputSourceName,
            cCppOutputSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), explicitCompilerFlags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), cflags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), asflags);
    assertContains(cCppOutputCompile.getCompilerFlags().get(), cCppOutputSourcePerFileFlags);

    cCppOutputSourceName = "test2.c";
    cCppOutputSource = CxxSource.of(
        CxxSource.Type.C,
        new TestSourcePath(cCppOutputSourceName),
        cCppOutputSourcePerFileFlags);
    CxxPreprocessAndCompile cCppOutputPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            cCppOutputSourceName,
            cCppOutputSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(
        cCppOutputPreprocessAndCompile.getCompilerFlags().get(),
        explicitCompilerFlags);
    assertContains(cCppOutputPreprocessAndCompile.getCompilerFlags().get(), cflags);
    assertContains(cCppOutputPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(
        cCppOutputPreprocessAndCompile.getCompilerFlags().get(),
        cCppOutputSourcePerFileFlags);

    String assemblerSourceName = "test.s";
    List<String> assemblerSourcePerFileFlags = ImmutableList.of("-assember-source-par-file-flag");
    CxxSource assemblerSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER,
        new TestSourcePath(assemblerSourceName),
        assemblerSourcePerFileFlags);
    CxxPreprocessAndCompile assemblerCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            assemblerSourceName,
            assemblerSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(assemblerCompile.getCompilerFlags().get(), asflags);
    assertContains(assemblerCompile.getCompilerFlags().get(), assemblerSourcePerFileFlags);

    assemblerSourceName = "test.S";
    assemblerSource = CxxSource.of(
        CxxSource.Type.ASSEMBLER_WITH_CPP,
        new TestSourcePath(assemblerSourceName),
        assemblerSourcePerFileFlags);
    CxxPreprocessAndCompile assemblerPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            assemblerSourceName,
            assemblerSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(assemblerPreprocessAndCompile.getCompilerFlags().get(), asflags);
    assertContains(
        assemblerPreprocessAndCompile.getCompilerFlags().get(),
        assemblerSourcePerFileFlags);
  }




  @Test
  public void checkCorrectFlagsAreUsedForObjcAndObjcxx() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();

    ImmutableList<String> explicitCompilerFlags = ImmutableList.of("-fobjc-arc");

    FakeBuckConfig buckConfig = new FakeBuckConfig(filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            new SourcePathResolver(buildRuleResolver),
            platform,
            ImmutableList.<CxxPreprocessorInput>of(),
            explicitCompilerFlags);

    String objcSourceName = "test.mi";
    CxxSource objcSource = CxxSource.of(
        CxxSource.Type.OBJC_CPP_OUTPUT,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(objcCompile.getCompilerFlags().get(), explicitCompilerFlags);

    objcSourceName = "test.m";
    objcSource = CxxSource.of(
        CxxSource.Type.OBJC,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(objcPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);

    String objcxxSourceName = "test.mii";
    CxxSource objcxxSource = CxxSource.of(
        CxxSource.Type.OBJCXX_CPP_OUTPUT,
        new TestSourcePath(objcxxSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcxxCompile =
        cxxSourceRuleFactory.requireCompileBuildRule(
            buildRuleResolver,
            objcxxSourceName,
            objcxxSource,
            CxxSourceRuleFactory.PicType.PDC);
    assertContains(objcxxCompile.getCompilerFlags().get(), explicitCompilerFlags);

    objcxxSourceName = "test.mm";
    objcxxSource = CxxSource.of(
        CxxSource.Type.OBJCXX,
        new TestSourcePath(objcxxSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcxxPreprocessAndCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcxxSourceName,
            objcxxSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);
    assertContains(objcxxPreprocessAndCompile.getCompilerFlags().get(), explicitCompilerFlags);
  }

  @Test
  public void duplicateRuleFetchedFromResolver() {
    BuildRuleResolver buildRuleResolver = new BuildRuleResolver();
    BuildTarget target = BuildTargetFactory.newInstance("//:target");
    BuildRuleParams params = BuildRuleParamsFactory.createTrivialBuildRuleParams(target);
    ProjectFilesystem filesystem = new AllExistingProjectFilesystem();

    FakeBuckConfig buckConfig = new FakeBuckConfig(filesystem);
    CxxPlatform platform = DefaultCxxPlatforms.build(new CxxBuckConfig(buckConfig));

    CxxSourceRuleFactory cxxSourceRuleFactory =
        new CxxSourceRuleFactory(
            params,
            buildRuleResolver,
            new SourcePathResolver(buildRuleResolver),
            platform,
            ImmutableList.<CxxPreprocessorInput>of(),
            ImmutableList.<String>of());

    String objcSourceName = "test.m";
    CxxSource objcSource = CxxSource.of(
        CxxSource.Type.OBJC,
        new TestSourcePath(objcSourceName),
        ImmutableList.<String>of());
    CxxPreprocessAndCompile objcCompile =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);


    CxxPreprocessAndCompile objcCompile2 =
        cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(
            buildRuleResolver,
            objcSourceName,
            objcSource,
            CxxSourceRuleFactory.PicType.PDC,
            CxxPreprocessMode.SEPARATE);

    assertEquals(objcCompile.getBuildTarget(), objcCompile2.getBuildTarget());
  }
}
