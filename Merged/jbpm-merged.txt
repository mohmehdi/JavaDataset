
package org.jbpm.persistence.timer;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.drools.core.command.CommandService;
import org.drools.core.time.InternalSchedulerService;
import org.drools.core.time.Job;
import org.drools.core.time.JobContext;
import org.drools.core.time.JobHandle;
import org.drools.core.time.SelfRemovalJob;
import org.drools.core.time.SelfRemovalJobContext;
import org.drools.core.time.Trigger;
import org.drools.core.time.impl.TimerJobFactoryManager;
import org.drools.core.time.impl.TimerJobInstance;
import org.jbpm.process.instance.timer.TimerManager.ProcessJobContext;

public class GlobalJPATimerJobFactoryManager implements TimerJobFactoryManager {

    private Map<Long, TimerJobInstance> emptyStore = new HashMap<Long,TimerJobInstance>();
    private CommandService commandService;
    private Map<Long, Map<Long, TimerJobInstance>> timerInstances;
    private Map<Long, TimerJobInstance> singleTimerInstances;
    
    public void setCommandService(CommandService commandService) {
        this.commandService = commandService;
    }
    
    public GlobalJPATimerJobFactoryManager() {
        timerInstances = new ConcurrentHashMap<Long, Map<Long, TimerJobInstance>>();
        singleTimerInstances = new ConcurrentHashMap<Long, TimerJobInstance>();
        
    }
    
    public TimerJobInstance createTimerJobInstance(Job job,
                                                   JobContext ctx,
                                                   Trigger trigger,
                                                   JobHandle handle,
                                                   InternalSchedulerService scheduler) {
    	long sessionId = -1;
    	if (ctx instanceof ProcessJobContext) {
            sessionId = ((ProcessJobContext) ctx).getSessionId();
            Map<Long, TimerJobInstance> instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        }        
        ctx.setJobHandle( handle );
        GlobalJpaTimerJobInstance jobInstance = new GlobalJpaTimerJobInstance( new SelfRemovalJob( job ),
                                                                   new SelfRemovalJobContext( ctx,
                                                                		   emptyStore ),
                                                                   trigger,
                                                                   handle,
                                                                   scheduler);
    
        return jobInstance;
    }
    
    public void addTimerJobInstance(TimerJobInstance instance) {
    
        JobContext ctx = instance.getJobContext();
        if (ctx instanceof SelfRemovalJobContext) {
            ctx = ((SelfRemovalJobContext) ctx).getJobContext();
        }
        Map<Long, TimerJobInstance> instances = null;
        if (ctx instanceof ProcessJobContext) {
            long sessionId = ((ProcessJobContext)ctx).getSessionId();
            instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        } else {
            instances = singleTimerInstances;
        }
        instances.put( instance.getJobHandle().getId(),
                                 instance );        
    }
    
    public void removeTimerJobInstance(TimerJobInstance instance) {
        JobContext ctx = instance.getJobContext();
        if (ctx instanceof SelfRemovalJobContext) {
            ctx = ((SelfRemovalJobContext) ctx).getJobContext();
        }
        Map<Long, TimerJobInstance> instances = null;
        if (ctx instanceof ProcessJobContext) {
            long sessionId = ((ProcessJobContext)ctx).getSessionId();
            instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        } else {
            instances = singleTimerInstances;
        }
        instances.remove( instance.getJobHandle().getId() );        
    }
    
    
    public Collection<TimerJobInstance> getTimerJobInstances() {
        return singleTimerInstances.values();
    }
    
    public Collection<TimerJobInstance> getTimerJobInstances(Long sessionId) {
        Map<Long, TimerJobInstance> sessionTimerJobs = timerInstances.get(sessionId);
        if (sessionTimerJobs == null) {
            return Collections.EMPTY_LIST;
        }
        return sessionTimerJobs.values();
    }
    
    public CommandService getCommandService() {
        return this.commandService;
    }
    
}

<code block>

package org.jbpm.services.task.wih.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import org.drools.core.process.instance.WorkItem;
import org.drools.core.process.instance.impl.WorkItemImpl;
import org.jbpm.test.util.AbstractBaseTest;
import org.junit.Before;
import org.junit.Test;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.PeopleAssignments;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.InternalPeopleAssignments;
import org.kie.internal.task.api.model.InternalTask;
import org.kie.internal.task.api.model.InternalTaskData;


public class PeopleAssignmentHelperTest  extends AbstractBaseTest {
	
	private PeopleAssignmentHelper peopleAssignmentHelper;
	
	@Before
	public void setup() {
		
		peopleAssignmentHelper = new PeopleAssignmentHelper();
		
	}
	
	@Test
	public void testProcessPeopleAssignments() {

		List<OrganizationalEntity> organizationalEntities = new ArrayList<OrganizationalEntity>();
		
		String ids = "espiegelberg,   drbug   ";
		assertTrue(organizationalEntities.isEmpty());
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.size() == 2);
		assertTrue(organizationalEntities.contains(createUser("drbug")));
		assertTrue(organizationalEntities.contains(createUser("espiegelberg")));
		
		ids = null;
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.isEmpty());
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.isEmpty());
		
		ids = "     ";
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.isEmpty());
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.isEmpty());
		
		ids = "Software Developer";
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.isEmpty());
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, false);
		assertTrue(organizationalEntities.size() == 1);
		assertTrue(organizationalEntities.contains(createGroup("Software Developer")));
		
		
		ids = "Software Developer,Project Manager";
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, false);
		assertTrue(organizationalEntities.size() == 2);
		assertTrue(organizationalEntities.contains(createGroup("Software Developer")));
		assertTrue(organizationalEntities.contains(createGroup("Project Manager")));
		
	}
	
	@Test
	public void testAssignActors() {
		
		String actorId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
		
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertTrue(organizationalEntity1 instanceof User);
		assertEquals(actorId, organizationalEntity1.getId());		
		assertEquals(actorId, taskData.getCreatedBy().getId());
		
		workItem = new WorkItemImpl();
		peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);				
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + ", drbug  ");
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		assertEquals(2, peopleAssignments.getPotentialOwners().size());
		organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertEquals(actorId, organizationalEntity1.getId());		
		assertEquals(actorId, taskData.getCreatedBy().getId());
		OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
		assertEquals("drbug", organizationalEntity2.getId());

		workItem = new WorkItemImpl();
		peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);				
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		assertEquals(0, peopleAssignments.getPotentialOwners().size());

	}
	
	@Test
    public void testAssignActorsWithCustomSeparatorViaSysProp() {
        System.setProperty("org.jbpm.ht.user.separator", ";");
        peopleAssignmentHelper = new PeopleAssignmentHelper();
        String actorId = "user1;user2";
        
        Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        
        OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId());       
        
        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + "; drbug  ");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(3, peopleAssignments.getPotentialOwners().size());
        organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId()); 
        OrganizationalEntity organizationalEntity3 = peopleAssignments.getPotentialOwners().get(2);
        assertEquals("drbug", organizationalEntity3.getId());

        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(0, peopleAssignments.getPotentialOwners().size());
        System.clearProperty("org.jbpm.ht.user.separator");
    }
	
	@Test
    public void testAssignActorsWithCustomSeparator() {
        peopleAssignmentHelper = new PeopleAssignmentHelper(":");
        String actorId = "user1:user2";
        
        Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        
        OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId());       
        
        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + ": drbug  ");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(3, peopleAssignments.getPotentialOwners().size());
        organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId()); 
        OrganizationalEntity organizationalEntity3 = peopleAssignments.getPotentialOwners().get(2);
        assertEquals("drbug", organizationalEntity3.getId());

        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(0, peopleAssignments.getPotentialOwners().size());
    }
	
	@Test
	public void testAssignBusinessAdministrators() {
	
		String businessAdministratorId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);

		peopleAssignmentHelper.assignBusinessAdministrators(workItem, peopleAssignments);
		assertEquals(3, peopleAssignments.getBusinessAdministrators().size());
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getBusinessAdministrators().get(0);
		assertTrue(organizationalEntity1 instanceof User);
		assertEquals("Administrator", organizationalEntity1.getId());

		OrganizationalEntity organizationalEntity2 = peopleAssignments.getBusinessAdministrators().get(1);        
        assertTrue(organizationalEntity2 instanceof Group);              
        assertEquals("Administrators", organizationalEntity2.getId());

        OrganizationalEntity organizationalEntity3 = peopleAssignments.getBusinessAdministrators().get(2);      
        assertTrue(organizationalEntity3 instanceof User);              
        assertEquals(businessAdministratorId, organizationalEntity3.getId());
	}

    @Test
    public void testAssignBusinessAdministratorGroups() {
    
        String businessAdministratorGroupId = "Super users";
        
        Task task = TaskModelProvider.getFactory().newTask();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);

        peopleAssignmentHelper.assignBusinessAdministrators(workItem, peopleAssignments);
        assertEquals(3, peopleAssignments.getBusinessAdministrators().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getBusinessAdministrators().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("Administrator", organizationalEntity1.getId());

        OrganizationalEntity organizationalEntity2 = peopleAssignments.getBusinessAdministrators().get(1);        
        assertTrue(organizationalEntity2 instanceof Group);              
        assertEquals("Administrators", organizationalEntity2.getId());

        OrganizationalEntity organizationalEntity3 = peopleAssignments.getBusinessAdministrators().get(2);      
        assertTrue(organizationalEntity3 instanceof Group);              
        assertEquals(businessAdministratorGroupId, organizationalEntity3.getId());
    }
	
	@Test
	public void testAssignTaskstakeholders() {
	
		String taskStakeholderId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);

		peopleAssignmentHelper.assignTaskStakeholders(workItem, peopleAssignments);
		assertEquals(1, peopleAssignments.getTaskStakeholders().size());
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getTaskStakeholders().get(0);		
		assertTrue(organizationalEntity1 instanceof User);				
		assertEquals(taskStakeholderId, organizationalEntity1.getId());
		
	}
	
	@Test
	public void testAssignGroups() {
		
		String groupId = "Software Developers, Project Managers";
		
		Task task = TaskModelProvider.getFactory().newTask();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.GROUP_ID, groupId);
		
		peopleAssignmentHelper.assignGroups(workItem, peopleAssignments);
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertTrue(organizationalEntity1 instanceof Group);
		assertEquals("Software Developers", organizationalEntity1.getId());
		OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
		assertTrue(organizationalEntity2 instanceof Group);
		assertEquals("Project Managers", organizationalEntity2.getId());
		
	}
	
	@Test
	public void testgetNullSafePeopleAssignments() {
		
		Task task = TaskModelProvider.getFactory().newTask();
		
		InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		
		peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		
		((InternalTask) task).setPeopleAssignments(null);
		peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		assertEquals(0, peopleAssignment.getPotentialOwners().size());
		assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
		assertEquals(0, peopleAssignment.getExcludedOwners().size());
		assertEquals(0, peopleAssignment.getRecipients().size());
		assertEquals(0, peopleAssignment.getTaskStakeholders().size());
		
	}	
	
	@Test
	public void testHandlePeopleAssignments() {
		
		InternalTask task = (InternalTask) TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
		InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		assertEquals(0, peopleAssignment.getPotentialOwners().size());
		assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
		assertEquals(0, peopleAssignment.getTaskStakeholders().size());
		
		String actorId = "espiegelberg";
		String taskStakeholderId = "drmary";
		String businessAdministratorId = "drbug";
        String businessAdministratorGroupId = "Super users";
        String excludedOwnerId = "john";
        String recipientId = "mary";
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
		workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);
		workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);
		
		peopleAssignmentHelper.handlePeopleAssignments(workItem, task, taskData);
		
		List<OrganizationalEntity> potentialOwners = task.getPeopleAssignments().getPotentialOwners();
		assertEquals(1, potentialOwners.size());
		assertEquals(actorId, potentialOwners.get(0).getId());
		
		List<OrganizationalEntity> businessAdministrators = task.getPeopleAssignments().getBusinessAdministrators();
		assertEquals(4, businessAdministrators.size());
		assertEquals("Administrator", businessAdministrators.get(0).getId());
		
		assertEquals("Administrators", businessAdministrators.get(1).getId());
		assertEquals(businessAdministratorId, businessAdministrators.get(2).getId());
        assertEquals(businessAdministratorGroupId, businessAdministrators.get(3).getId());
		
		
		List<OrganizationalEntity> taskStakehoders = ((InternalPeopleAssignments) task.getPeopleAssignments()).getTaskStakeholders();
		assertEquals(1, taskStakehoders.size());
		assertEquals(taskStakeholderId, taskStakehoders.get(0).getId());

        List<OrganizationalEntity> excludedOwners = ((InternalPeopleAssignments) task.getPeopleAssignments()).getExcludedOwners();
        assertEquals(1, excludedOwners.size());
        assertEquals(excludedOwnerId, excludedOwners.get(0).getId());

        List<OrganizationalEntity> recipients = ((InternalPeopleAssignments) task.getPeopleAssignments()).getRecipients();
        assertEquals(1, recipients.size());
        assertEquals(recipientId, recipients.get(0).getId());
		
	}

    @Test
    public void testHandleMultiPeopleAssignments() {

    	InternalTask task = (InternalTask) TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        assertNotNull(peopleAssignment);
        assertEquals(0, peopleAssignment.getPotentialOwners().size());
        assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
        assertEquals(0, peopleAssignment.getTaskStakeholders().size());

        String actorId = "espiegelberg,john";
        String taskStakeholderId = "drmary,krisv";
        String businessAdministratorId = "drbug,peter";
        String businessAdministratorGroupId = "Super users,Flow administrators";
        String excludedOwnerId = "john,poul";
        String recipientId = "mary,steve";

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);

        peopleAssignmentHelper.handlePeopleAssignments(workItem, task, taskData);

        List<OrganizationalEntity> potentialOwners = task.getPeopleAssignments().getPotentialOwners();
        assertEquals(2, potentialOwners.size());
        assertEquals("espiegelberg", potentialOwners.get(0).getId());
        assertEquals("john", potentialOwners.get(1).getId());

        List<OrganizationalEntity> businessAdministrators = task.getPeopleAssignments().getBusinessAdministrators();
        assertEquals(6, businessAdministrators.size());
        assertEquals("Administrator", businessAdministrators.get(0).getId());
        
        assertEquals("Administrators", businessAdministrators.get(1).getId());
        assertEquals("drbug", businessAdministrators.get(2).getId());
        assertEquals("peter", businessAdministrators.get(3).getId());
        assertEquals("Super users", businessAdministrators.get(4).getId());
        assertEquals("Flow administrators", businessAdministrators.get(5).getId());
        
        
        List<OrganizationalEntity> taskStakehoders = ((InternalPeopleAssignments) task.getPeopleAssignments()).getTaskStakeholders();
        assertEquals(2, taskStakehoders.size());
        assertEquals("drmary", taskStakehoders.get(0).getId());
        assertEquals("krisv", taskStakehoders.get(1).getId());

        List<OrganizationalEntity> excludedOwners = ((InternalPeopleAssignments) task.getPeopleAssignments()).getExcludedOwners();
        assertEquals(2, excludedOwners.size());
        assertEquals("john", excludedOwners.get(0).getId());
        assertEquals("poul", excludedOwners.get(1).getId());

        List<OrganizationalEntity> recipients = ((InternalPeopleAssignments) task.getPeopleAssignments()).getRecipients();
        assertEquals(2, recipients.size());
        assertEquals("mary", recipients.get(0).getId());
        assertEquals("steve", recipients.get(1).getId());

    }

    @Test
    public void testAssignExcludedOwners() {

        String excludedOwnerId = "espiegelberg";

        Task task = TaskModelProvider.getFactory().newTask();
        InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);

        peopleAssignmentHelper.assignExcludedOwners(workItem, peopleAssignments);
        assertEquals(1, peopleAssignments.getExcludedOwners().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getExcludedOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals(excludedOwnerId, organizationalEntity1.getId());

    }

    @Test
    public void testAssignRecipients() {

        String recipientId = "espiegelberg";

        Task task = TaskModelProvider.getFactory().newTask();
        InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);

        peopleAssignmentHelper.assignRecipients(workItem, peopleAssignments);
        assertEquals(1, peopleAssignments.getRecipients().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getRecipients().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals(recipientId, organizationalEntity1.getId());

    }

    private User createUser(String id) {
        return TaskModelProvider.getFactory().newUser(id);
    }

    private Group createGroup(String id) {
        return TaskModelProvider.getFactory().newGroup(id);
    }
}

<code block>

package org.jbpm.services.task;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jbpm.services.task.exception.PermissionDeniedException;
import org.jbpm.services.task.impl.factories.TaskFactory;
import org.jbpm.services.task.impl.model.xml.JaxbContent;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.junit.Test;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.I18NText;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.ContentData;
import org.kie.internal.task.api.model.FaultData;
import org.kie.internal.task.api.model.InternalComment;
import org.kie.internal.task.api.model.InternalI18NText;
import org.kie.internal.task.api.model.InternalOrganizationalEntity;
import org.kie.internal.task.api.model.InternalPeopleAssignments;
import org.kie.internal.task.api.model.InternalTask;
import org.kie.internal.task.api.model.InternalTaskData;

public abstract class LifeCycleBaseTest extends HumanTaskServicesBaseTest {

    
    @Test
    
    public void testWithNoTaskAndEmptyLists(){
      
      List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("nouser", new ArrayList<String>());
      assertTrue(tasksAssignedAsPotentialOwner.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner2 = taskService.getTasksAssignedAsPotentialOwner("nouser", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner2.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner3 = taskService.getTasksAssignedAsPotentialOwner("", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner3.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner4 = taskService.getTasksAssignedAsPotentialOwner(null,(List<String>) null);
      assertTrue(tasksAssignedAsPotentialOwner4.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner5 = taskService.getTasksAssignedAsPotentialOwner("salaboy", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner5.isEmpty());
      
      List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", null, null);
      assertTrue(tasks.isEmpty());
      
      List<TaskSummary> tasks2 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", new ArrayList<String>(), null);
      assertTrue(tasks2.isEmpty());
      
      List<TaskSummary> tasks3 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", new ArrayList<String>(), new ArrayList<Status>());
      assertTrue(tasks3.isEmpty());
      
      List<TaskSummary> tasks4 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("admin", new ArrayList<String>(), new ArrayList<Status>());
      assertTrue(tasks4.isEmpty());
              
      
    }
  
    @Test
    public void testNewTaskWithNoPotentialOwners() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Administrator') ],}),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(task1.getTaskData().getStatus(), Status.Created);
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testNewTaskWithSinglePotentialOwner() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet')  ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));

        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        String potOwner = "Bobba Fet"; 
        assertEquals(potOwner, task1.getTaskData().getActualOwner().getId());
        
        taskService.getTasksAssignedAsPotentialOwner(potOwner, "en-UK");
    }
    
    

    @Test
    public void testNewTaskWithContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        ContentData data = ContentMarshallerHelper.marshal("content", null);

        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, data);

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType());
        assertEquals("java.lang.String", task1.getTaskData().getDocumentType());
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.toString());
        xmlRoundTripContent(content);
    }
    
    @Test
    public void testNewTaskWithMapContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";                        
        str += "name =  'This is my task name' })";
            
        Map<String, Object> variablesMap = new HashMap<String, Object>();
        variablesMap.put("key1", "value1");
        variablesMap.put("key2", null);
        variablesMap.put("key3", "value3");
        ContentData data = ContentMarshallerHelper.marshal(variablesMap, null);
        
        Task task = TaskFactory.evalTask( new StringReader( str ));
        taskService.addTask( task, data );
        
        long taskId = task.getId();
        
        
        Task task1 = taskService.getTaskById( taskId );
        assertEquals( AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType() );
        assertEquals( "java.util.HashMap", task1.getTaskData().getDocumentType() );
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue( contentId != -1 ); 
       
        
        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        }
        Map<String, Object> unmarshalledvars = (Map<String, Object>)unmarshalledObject;
        JaxbContent jaxbContent = xmlRoundTripContent(content);
        assertNotNull( "Jaxb Content map not filled", jaxbContent.getContentMap());
        
        assertEquals("value1",unmarshalledvars.get("key1") );
        assertNull(unmarshalledvars.get("key2") );
        assertEquals("value3",unmarshalledvars.get("key3") );
    }
    
    
    @Test
    public void testNewTaskWithMapContentAndOutput() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";                        
        str += "name =  'This is my task name' })";
            
        Map<String, Object> variablesMap = new HashMap<String, Object>();
        variablesMap.put("key1", "value1");
        variablesMap.put("key2", null);
        variablesMap.put("key3", "value3");
        ContentData data = ContentMarshallerHelper.marshal(variablesMap, null);
        
        Task task = TaskFactory.evalTask( new StringReader( str ));
        taskService.addTask( task, data );
        
        long taskId = task.getId();
        
        
        
        
        Task task1 = taskService.getTaskById( taskId );
        assertEquals( AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType() );
        assertEquals( "java.util.HashMap", task1.getTaskData().getDocumentType() );
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue( contentId != -1 ); 

        
        
        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        }
        xmlRoundTripContent(content);
        
        Map<String, Object> unmarshalledvars = (Map<String, Object>) unmarshalledObject;
        
        assertEquals("value1",unmarshalledvars.get("key1") );
        assertNull(unmarshalledvars.get("key2") );
        assertEquals("value3",unmarshalledvars.get("key3") );
        
        taskService.start(taskId,"Bobba Fet" );
        
        task1 = taskService.getTaskById( taskId );
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        
        
        
        Map<String, Object> intermediateOutputContentMap = new HashMap<String, Object>();
        
        intermediateOutputContentMap.put("key2", "value2");
        intermediateOutputContentMap.put("key4", "value4");
        
        
        taskService.addContent(taskId, intermediateOutputContentMap);
        
        Map<String, Object> finalOutputContentMap = new HashMap<String, Object>();
         finalOutputContentMap.put("key5", "value5");
        finalOutputContentMap.put("key6", "value6");
        
        
        taskService.complete(taskId,"Bobba Fet", finalOutputContentMap);
        
        task1 = taskService.getTaskById( taskId );
        assertEquals(Status.Completed, task1.getTaskData().getStatus());
        long outputContentId = task1.getTaskData().getOutputContentId();
        Content contentById = taskService.getContentById(outputContentId);
        
        unmarshalledObject = ContentMarshallerHelper.unmarshall(contentById.getContent(), null);
        assertNotNull(unmarshalledObject);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        
        }
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key2"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key4"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key5"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key6"));
        xmlRoundTripContent(contentById);
    }
    
    @Test
    public void testNewTaskWithLargeContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        String largeContent = "";
        for (int i = 0; i < 1000; i++) {
            largeContent += i + "xxxxxxxxx";
        }

        ContentData data = ContentMarshallerHelper.marshal(largeContent, null);

        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, data);

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType());
        assertEquals("java.lang.String", task1.getTaskData().getDocumentType());
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals(largeContent, unmarshalledObject.toString());
        xmlRoundTripContent(content);
    }

    @Test
    public void testClaimWithMultiplePotentialOwners() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'),new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());


        taskService.claim(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testClaimWithGroupAssignee() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('Knights Templer' )], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        taskService.claim(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    
     @Test
    public void testForwardGroupClaimQueryAssignee() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy' )], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";
        
        
        String str2 = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str2 += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy')], businessAdministrators = [ new User('Administrator') ], }),";
        str2 += "name = 'This is my second task name' })";

         
        String str3 = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str3 += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('Crusaders'), new Group('Knights Templer')], businessAdministrators = [ new User('Administrator') ], }),";
        str3 += "name = 'This is my third task name' })";
        
        
        List<String> groupIds = new ArrayList<String>();
        
        groupIds.add("Knights Templer");
        groupIds.add("non existing group");
        groupIds.add("non existing group 2");
        groupIds.add("Crusaders");
        
        List<Status> statuses = new ArrayList<Status>();
        statuses.add(Status.Ready);
        statuses.add(Status.Created);
        statuses.add(Status.InProgress);
        statuses.add(Status.Reserved);
        

        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        
        Task task3 = TaskFactory.evalTask(new StringReader(str2));
        taskService.addTask(task3, new HashMap<String, Object>());
        
        Task task4 = TaskFactory.evalTask(new StringReader(str3));
        taskService.addTask(task4, new HashMap<String, Object>());
        
        List<TaskSummary> tasksAssignedByGroups = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, tasksAssignedByGroups.size());

        

          List<TaskSummary> allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, allTasks.size());
        List<TaskSummary> personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(2, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("salaboy", "en-UK");
        assertEquals(3, tasksAssignedAsPotentialOwner.size());
        
        taskService.forward(taskId, "salaboy", "Crusaders");

        
        allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(2, allTasks.size());
        personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(1, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());
        
        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(1, task2.getPeopleAssignments().getPotentialOwners().size());
        List<TaskSummary> tasksAssignedByGroup = taskService.getTasksAssignedByGroup("Crusaders");
        
        assertEquals(2, tasksAssignedByGroup.size());
       
        
        tasksAssignedByGroups = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(2, tasksAssignedByGroups.size());
        
        taskService.claim(taskId, "salaboy");
        
        task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("salaboy", task2.getTaskData().getActualOwner().getId());
        assertEquals(1, task2.getPeopleAssignments().getPotentialOwners().size());
        
        List<TaskSummary> tasksOwned = taskService.getTasksOwned("salaboy", "en-UK");
        assertEquals(2, tasksOwned.size());
  
        allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, allTasks.size());
        personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(2, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());
        
        
    }

    @Test
    public void testStartFromReadyStateWithPotentialOwner() throws Exception {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        
        taskService.start(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStartFromReadyStateWithIncorrectPotentialOwner() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name'})";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");
        assertEquals(1, tasksAssignedAsPotentialOwner.size());
        
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        


        PermissionDeniedException denied = null;
        try {
            taskService.start(taskId, "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }

        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    @Test
    public void testStartFromReserved() throws Exception {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());

        

        taskService.start(taskId, "Bobba Fet");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStartFromReservedWithIncorrectUser() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());

        



        PermissionDeniedException denied = null;
        try {
            taskService.start(taskId, "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStop() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.start(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.stop(taskId, "Darth Vader");


        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStopWithIncorrectUser() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.stop(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testReleaseFromInprogress() throws Exception {


        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");



        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.release(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    public void testReleaseFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name'})";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.release(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    @Test
    public void testReleaseWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.release(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSuspendFromReady() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name'})";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.suspend(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals(Status.Ready, task2.getTaskData().getPreviousStatus());
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testSuspendFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.suspend(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getPreviousStatus());
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSuspendFromReservedWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.suspend(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test 
    public void testResumeFromReady() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.suspend(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals(Status.Ready, task2.getTaskData().getPreviousStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.resume(taskId, "Darth Vader");

        Task task3 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task3.getTaskData().getStatus());
        assertEquals(Status.Suspended, task3.getTaskData().getPreviousStatus());
        assertNull(task3.getTaskData().getActualOwner());
    }

    @Test
    public void testResumeFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.suspend(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getPreviousStatus());
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());

        

        taskService.resume(taskId, "Darth Vader");

        Task task3 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task3.getTaskData().getStatus());
        assertEquals(Status.Suspended, task3.getTaskData().getPreviousStatus());
        assertEquals("Darth Vader", task3.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testResumeFromReservedWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        PermissionDeniedException denied = null;
        try {
            taskService.suspend(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSkipFromReady() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = true} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.skip(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Obsolete, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testSkipFromReserved() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = true} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        

        taskService.skip(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Obsolete, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testDelegateFromReady() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        
        taskService.delegate(taskId, "Darth Vader", "Tony Stark");




        Task task2 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Tony Stark", task2.getTaskData().getActualOwner().getId());
        
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testDelegateFromReserved() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.delegate(taskId, "Darth Vader", "Tony Stark");




        Task task2 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Tony Stark", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testDelegateFromReservedWithIncorrectUser() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.delegate(taskId, "Bobba Fet", "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Tony Stark");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testForwardFromReady() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.forward(taskId, "Darth Vader", "Tony Stark");

        Task task2 = taskService.getTaskById(taskId);
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(createUser("Darth Vader")));
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(createUser("Tony Stark")));
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
    }

    @Test
    public void testForwardFromReserved() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.forward(taskId, "Darth Vader", "Tony Stark");


        Task task2 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
    }

    @Test
    public void testForwardFromReservedWithIncorrectUser() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.forward(taskId, "Bobba Fet", "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Tony Stark");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testComplete() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testCompleteWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.complete(taskId, "Bobba Fet", null);
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testCompleteWithContent() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("content", "content");
        taskService.complete(taskId, "Darth Vader", params);

        List<Content> allContent = taskService.getAllContentByTaskId(taskId);
        assertNotNull(allContent);
        assertEquals(3, allContent.size());
        
        assertNotNull(allContent.get(0));
        assertNotNull(allContent.get(1));
        assertNull(allContent.get(2));

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getOutputAccessType());
        assertEquals("java.util.HashMap", task2.getTaskData().getOutputType());
        long contentId = task2.getTaskData().getOutputContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.get("content"));
        
        
        params.put("content", "updated content");
	    taskService.setOutput(taskId, "Darth Vader", params);
	    
	    task = taskService.getTaskById(taskId);
	    contentId = task.getTaskData().getOutputContentId();
	    
	    content = taskService.getContentById(contentId);
	    String updated = new String(content.getContent());
	    unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("updated content", unmarshalledObject.get("content"));
        
        taskService.deleteOutput(taskId, "Darth Vader");
        content = taskService.getContentById(contentId);
        assertNull(content);
    }

    @Test
    public void testCompleteWithResults() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());


        Map<String, Object> params = new HashMap<String, Object>();
        params.put("content", "content");
        taskService.complete(taskId, "Darth Vader", params);


        Task task2 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getOutputAccessType());
        assertEquals("java.util.HashMap", task2.getTaskData().getOutputType());
        long contentId = task2.getTaskData().getOutputContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.get("content"));
    }

    @Test
    public void testFail() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.fail(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Failed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testFailWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.fail(taskId, "Bobba Fet", null);
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testFailWithContent() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.start(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        Map<String, Object> faultData = new HashMap<String, Object>();
        faultData.put("faultType", "type");
        faultData.put("faultName", "faultName");
        faultData.put("content", "content");

        taskService.fail(taskId, "Darth Vader", faultData);
        
        List<Content> allContent = taskService.getAllContentByTaskId(taskId);
        assertNotNull(allContent);
        assertEquals(3, allContent.size());
        
        assertNotNull(allContent.get(0));
        assertNull(allContent.get(1));
        assertNotNull(allContent.get(2));

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Failed, task2.getTaskData().getStatus());
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getFaultAccessType());
        assertEquals("type", task2.getTaskData().getFaultType());
        assertEquals("faultName", task2.getTaskData().getFaultName());
        long contentId = task2.getTaskData().getFaultContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledContent = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledContent.get("content"));
        xmlRoundTripContent(content);
        
        
	    FaultData data = TaskModelProvider.getFactory().newFaultData();
	    data.setAccessType(AccessType.Inline);
	    data.setType("type");
	    data.setFaultName("faultName");
	    data.setContent("updated content".getBytes());
	    
	    taskService.setFault(taskId, "Darth Vader", data);
	    
	    task = taskService.getTaskById(taskId);
	    contentId = task.getTaskData().getFaultContentId();
	    
	    content = taskService.getContentById(contentId);
	    String updated = new String(content.getContent());
	    assertEquals("updated content", updated);
        
	    
        taskService.deleteFault(taskId, "Darth Vader");
        content = taskService.getContentById(contentId);
        assertNull(content);
    }













































    @Test
    public void testRemoveNotInRecipientList() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ],";
        str += "recipients = [new User('Bobba Fet') ] }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str), null);
        
        if (task.getPeopleAssignments() != null && task.getPeopleAssignments().getBusinessAdministrators() != null) {
            List<OrganizationalEntity> businessAdmins = new ArrayList<OrganizationalEntity>();
            User user = createUser("Administrator");
            businessAdmins.add(user);
            businessAdmins.addAll(task.getPeopleAssignments().getBusinessAdministrators());
            ((InternalPeopleAssignments) task.getPeopleAssignments()).setBusinessAdministrators(businessAdmins);
        }
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        List<TaskSummary> myRecipientTasks = taskService.getTasksAssignedAsRecipient("Jabba Hutt");

        assertNotNull(myRecipientTasks);
        assertEquals(0, myRecipientTasks.size());



        List<TaskSummary> myPotentialTasks = taskService.getTasksAssignedAsPotentialOwner("Jabba Hutt", "en-UK");

        assertNotNull(myPotentialTasks);
        assertEquals(0, myPotentialTasks.size());


        try {
            taskService.remove(taskId, "Jabba Hutt");
            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 
        }

        


        Task task1 = taskService.getTaskById(taskId);
        User user = createUser("Bobba Fet");
        assertTrue(((InternalPeopleAssignments) task1.getPeopleAssignments()).getRecipients().contains(user));
    }

    
    @Test
    public void testNominateOnOtherThanCreated() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Administrator') ] ,";
        str += " potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name =  'This is my task name' })";

        Task task = TaskFactory.evalTask(new StringReader(str), null);

        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        taskService.start(taskId, "Bobba Fet");

        try {
            List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>();
            User user = createUser("Bobba Fet");
            potentialOwners.add(user);
            taskService.nominate(taskId, "Darth Vader", potentialOwners);

            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 



        }

        

        Task task1 = taskService.getTaskById(taskId);
        User user = createUser("Darth Vader");
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(user));
        user = createUser("Bobba Fet");
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(user));
    }

    @Test
    public void testNominateWithIncorrectUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Bobba Fet') ] } ),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        try {
            List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>(1);
            User user = createUser("Jabba Hutt");
            potentialOwners.add(user);
            taskService.nominate(taskId, "Darth Vader", potentialOwners);

            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 



        }

        

        Task task1 = taskService.getTaskById(taskId);
        User user = createUser("Bobba Fet");
        assertTrue(task1.getPeopleAssignments().getBusinessAdministrators().contains(user));
        assertEquals(task1.getTaskData().getStatus(), Status.Created);
    }

    @Test
    public void testNominateToUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>(1);
        User user = createUser("Jabba Hutt");
        potentialOwners.add(user);
        taskService.nominate(taskId, "Darth Vader", potentialOwners);


        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(task1.getTaskData().getActualOwner().getId(), "Jabba Hutt");
        assertEquals(task1.getTaskData().getStatus(), Status.Reserved);
    }

    @Test
    public void testNominateToGroup() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name = 'This is my task name'})";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        List<OrganizationalEntity> potentialGroups = new ArrayList<OrganizationalEntity>();
        Group group = TaskModelProvider.getFactory().newGroup();
        ((InternalOrganizationalEntity) group).setId("Knights Templer");
        potentialGroups.add(group);
        taskService.nominate(taskId, "Darth Vader", potentialGroups);


        


        Task task1 = taskService.getTaskById(taskId);
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(group));
        assertEquals(task1.getTaskData().getStatus(), Status.Ready);
    }

    @Test
    public void testActivate() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { ";
        str += "businessAdministrators = [ new User('Darth Vader') ] } ),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        taskService.activate(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);

        assertEquals(task1.getTaskData().getStatus(), Status.Ready);
        
        
        
        
    }

    @Test
    public void testActivateWithIncorrectUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ], ";
        str += "businessAdministrators = [ new User('Jabba Hutt') ] } ),";
        str += "name =  'This is my task name'})";

        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        try {
            taskService.activate(taskId, "Darth Vader");

            fail("Shouldn't have succeded");
        } catch (RuntimeException e) {



        }

    }

    @Test
    public void testActivateFromIncorrectStatus() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ], ";
        str += "businessAdministrators = [ new User('Jabba Hutt') ] } ),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str), null);
        
        if (task.getPeopleAssignments() != null && task.getPeopleAssignments().getBusinessAdministrators() != null) {
            List<OrganizationalEntity> businessAdmins = new ArrayList<OrganizationalEntity>();
            User user = createUser("Administrator");
            businessAdmins.add(user);
            businessAdmins.addAll(task.getPeopleAssignments().getBusinessAdministrators());
            ((InternalPeopleAssignments) task.getPeopleAssignments()).setBusinessAdministrators(businessAdmins);
        }
        
        taskService.addTask(task, new HashMap<String, Object>());

        
        long taskId = task.getId();


        try {
            taskService.activate(taskId, "Darth Vader");

            fail("Shouldn't have succeded");
        } catch (RuntimeException e) {



        }
    }

    @Test
    public void testExitFromReady() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromReserved() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromInProgress() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());

        taskService.start(taskId, "Bobba Fet");
        task = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task.getTaskData().getStatus());

        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromSuspended() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());

        taskService.suspend(taskId, "Bobba Fet");
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task.getTaskData().getStatus());

        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitPermissionDenied() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task.getTaskData().getStatus());

        try {
            taskService.exit(taskId, "Darth Vader");
            fail("Non admin user can't exit a task");
        } catch (PermissionDeniedException e) {
        }
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitNotAvailableToUsers() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet')], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());

        List<TaskSummary> exitedTasks = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");
        assertEquals(0, exitedTasks.size());

    }

    @Test
    public void testClaimConflictAndRetry() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        

        
        taskService.addTask(TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        
        
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwner("salaboy", "en-UK");

        
        Long salaboyTaskId = salaboyTasks.get(0).getId();

        
        
        Task salaboyTask = taskService.getTaskById(salaboyTaskId);
        assertEquals(Status.Ready, salaboyTask.getTaskData().getStatus());

        
        
        List<TaskSummary> bobbaTasks = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");

        
        Long bobbaTaskId = bobbaTasks.get(0).getId();
        assertEquals(bobbaTaskId, salaboyTaskId);
        
        
        Task bobbaTask = taskService.getTaskById(bobbaTaskId);
        assertEquals(Status.Ready, bobbaTask.getTaskData().getStatus());


        taskService.claim(bobbaTask.getId(), "Bobba Fet");

        try {
            taskService.claim(salaboyTask.getId(), "salaboy");
        } catch (PermissionDeniedException ex) {
            
            assertNotNull(ex);
        }

    }

    @Test
    public void testClaimNextAvailable() {
        
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        
        taskService.addTask(TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        

        taskService.claimNextAvailable("Bobba Fet", "en-UK");


        List<Status> status = new ArrayList<Status>();
        status.add(Status.Ready);
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwnerByStatus("salaboy", status, "en-UK");
        assertEquals(0, salaboyTasks.size());

    }
    
    @Test
    public void testClaimNextAvailableWithGroups() {
        
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        
        taskService.addTask(TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        
        List<String> groups = new ArrayList<String>();
        groups.add("HR");
        taskService.claimNextAvailable("Bobba Fet", groups);


        List<Status> status = new ArrayList<Status>();
        status.add(Status.Ready);
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwnerByStatus("salaboy", status, "en-UK");
        assertEquals(0, salaboyTasks.size());

    }
    
    @Test
    public void testCompleteWithRestrictedGroups() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('analyst'), new Group('Crusaders') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<OrganizationalEntity> potOwners = task.getPeopleAssignments().getPotentialOwners();
        assertNotNull(potOwners);
        assertEquals(1, potOwners.size());
        assertEquals("Crusaders", potOwners.get(0).getId());

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    @Test
    public void testInvalidTask() {
    	try {
    		taskService.claim(-1, "Darth Vader");
    	} catch (PermissionDeniedException e) {
    		if ("Task '-1' not found".equals(e.getMessage())) {
    			return;
    		} else {
    			throw e;
    		}
    	}
    }
    
    @Test
    public void testCompleteWithComments() {       
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<Comment> comments = taskService.getAllCommentsByTaskId(taskId);
        assertNotNull(comments);
        assertEquals(0, comments.size());
        
        User user = createUser("Bobba Fet");
        
        Comment comment = TaskModelProvider.getFactory().newComment();
        ((InternalComment)comment).setAddedAt(new Date());
        ((InternalComment)comment).setAddedBy(user);
        ((InternalComment)comment).setText("Simple test comment");
        taskService.addComment(taskId, comment);
        
        comments = taskService.getAllCommentsByTaskId(taskId);
        assertNotNull(comments);
        assertEquals(1, comments.size());

        
        taskService.start(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        
        taskService.complete(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    @Test
    public void testNewTaskWithSingleInvalidPotentialOwner() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('invalid')  ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));

        taskService.addTask(task, new HashMap<String, Object>());
        try {
	        String potOwner = "invalid";             
	        taskService.getTasksAssignedAsPotentialOwner(potOwner, "en-UK");
	        fail("Should fail due to same id for group and user");
        } catch (RuntimeException e) {
        	assertTrue(e.getMessage().endsWith("please check that there is no group and user with same id"));
        }
    }

    @Test
    public void testLongDescription() {
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Task task = TaskFactory.evalTask(new StringReader(str));

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("a");
        }
        String comment = sb.toString();

        
        List<I18NText> descriptions = new ArrayList<I18NText>();
        I18NText descText = TaskModelProvider.getFactory().newI18NText();
        ((InternalI18NText) descText).setLanguage("en-UK");
        ((InternalI18NText) descText).setText(comment);
        descriptions.add(descText);
        ((InternalTask)task).setDescriptions(descriptions);

        taskService.addTask(task, new HashMap<String, Object>()); 

        long taskId = task.getId();

        Task resultTask = taskService.getTaskById(taskId);
        List<I18NText> resultDescriptions = resultTask.getDescriptions();

        InternalI18NText resultDescription = (InternalI18NText)resultDescriptions.get(0);

        assertEquals(1000, resultDescription.getText().length()); 

        
    }
    
    @Test
    public void testCompleteByActiveTasks() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { activationTime = new Date(), processInstanceId = 123 } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Date creationTime = new Date();
        
        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());


        long taskId = task.getId();
        assertNotNull(task.getTaskData().getActivationTime());

        
        taskService.start(taskId, "Darth Vader");
        
        List<TaskSummary> activeTasks = taskService.getActiveTasks();
        assertNotNull(activeTasks);
        assertEquals(1,  activeTasks.size());
        
        activeTasks = taskService.getActiveTasks(creationTime);
        assertNotNull(activeTasks);
        assertEquals(1,  activeTasks.size());


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        
        List<TaskSummary> completedTasks = taskService.getCompletedTasks();
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        completedTasks = taskService.getCompletedTasks(creationTime);
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        completedTasks = taskService.getCompletedTasksByProcessId(123l);
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        taskService.archiveTasks(completedTasks);
        
        List<TaskSummary> archiveddTasks = taskService.getArchivedTasks();
        assertNotNull(archiveddTasks);
        assertEquals(1,  archiveddTasks.size());
    }

    private User createUser(String id) {
        return TaskModelProvider.getFactory().newUser(id);
    }
}

<code block>


package org.jbpm.workflow.instance;

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

import org.drools.core.common.InternalKnowledgeRuntime;
import org.jbpm.ruleflow.core.RuleFlowProcess;
import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;
import org.jbpm.workflow.core.impl.NodeImpl;
import org.jbpm.workflow.instance.impl.NodeInstanceImpl;
import org.jbpm.workflow.instance.impl.WorkflowProcessInstanceImpl;
import org.kie.api.definition.process.Node;
import org.kie.api.definition.process.NodeContainer;
import org.kie.api.definition.process.Process;
import org.kie.api.definition.process.WorkflowProcess;
import org.kie.api.runtime.KieRuntime;
import org.kie.api.runtime.process.NodeInstance;

public class WorkflowProcessInstanceUpgrader {

    public static void upgradeProcessInstance( KieRuntime kruntime, long processInstanceId, String processId,
            Map<String, Long> nodeMapping) {
        if (nodeMapping == null) {
            nodeMapping = new HashMap<String, Long>();
        }
        WorkflowProcessInstanceImpl processInstance = (WorkflowProcessInstanceImpl)
                kruntime.getProcessInstance(processInstanceId);
        if (processInstance == null) {
            throw new IllegalArgumentException("Could not find process instance " + processInstanceId);
        }
        if (processId == null) {
            throw new IllegalArgumentException("Null process id");
        }
        WorkflowProcess process = (WorkflowProcess)
                kruntime.getKieBase().getProcess(processId);
        if (process == null) {
            throw new IllegalArgumentException("Could not find process " + processId);
        }
        if (processInstance.getProcessId().equals(processId)) {
            return;
        }
        synchronized (processInstance) {
            org.kie.api.definition.process.Process oldProcess = processInstance.getProcess();
            processInstance.disconnect();
            processInstance.setProcess(oldProcess);
            updateNodeInstances(processInstance, nodeMapping);
            processInstance.setKnowledgeRuntime((InternalKnowledgeRuntime) kruntime);
            processInstance.setProcess(process);
            processInstance.reconnect();
        }
    }

    
    public static void upgradeProcessInstanceByNodeNames(
            KieRuntime kruntime,
            Long fromProcessId,
            String toProcessId,
            Map<String, String> nodeNamesMapping) {

        Map<String, Long> nodeIdMapping = new HashMap<String, Long>();

        String fromProcessIdString = kruntime.getProcessInstance(fromProcessId).getProcessId();
        Process processFrom = kruntime.getKieBase().getProcess(fromProcessIdString);
        Process processTo = kruntime.getKieBase().getProcess(toProcessId);

        for (Map.Entry<String, String> entry : nodeNamesMapping.entrySet()) {
            String from = null;
            Long to = null;

            if (processFrom instanceof WorkflowProcess) {
                from = getNodeId(((WorkflowProcess) processFrom).getNodes(), entry.getKey(), true);
            } else if (processFrom instanceof RuleFlowProcess) {
                from = getNodeId(((RuleFlowProcess) processFrom).getNodes(), entry.getKey(), true);
            } else if (processFrom != null) {
                throw new IllegalArgumentException("Suported processes are WorkflowProcess and RuleFlowProcess, it was:" + processFrom.getClass());
            } else {
                throw new IllegalArgumentException("Can not find process with id: " + fromProcessIdString);
            }

            if (processTo instanceof WorkflowProcess) {
                to = Long.valueOf(getNodeId(((WorkflowProcess) processTo).getNodes(), entry.getValue(), false));
            } else if (processTo instanceof RuleFlowProcess) {
                to = Long.valueOf(getNodeId(((RuleFlowProcessInstance) processTo).getWorkflowProcess().getNodes(), entry.getValue(), false));
            } else if (processTo != null) {
                throw new IllegalArgumentException("Suported processes are WorkflowProcess and RuleFlowProcess, it was:" + processTo.getClass());
            } else {
                throw new IllegalArgumentException("Can not find process with id: " + toProcessId);
            }
            nodeIdMapping.put(from, to);
        }

        upgradeProcessInstance(kruntime, fromProcessId, toProcessId, nodeIdMapping);
    }

    private static String getNodeId(Node[] nodes, String nodeName, boolean unique) {

        Stack<Node> nodeStack = new Stack<Node>();
        for (Node node : nodes) {
            nodeStack.push(node);
        }

        Node match = null;
        while (!nodeStack.isEmpty()) {
            Node topNode = nodeStack.pop();

            if (topNode.getName().compareTo(nodeName) == 0) {
                match = topNode;
                break;
            }

            if (topNode instanceof NodeContainer) {
                for (Node node : ((NodeContainer) topNode).getNodes()) {
                    nodeStack.push(node);
                }
            }
        }

        if (match == null) {
            throw new IllegalArgumentException("No node with name " + nodeName);
        }

        String id = "";

        if (unique) {
            while (!(match.getNodeContainer() instanceof Process)) {
                id = ":" + match.getId() + id;
                match = (Node) match.getNodeContainer();
            }
        }

        id = match.getId() + id;

        return id;
    }

    private static void updateNodeInstances(NodeInstanceContainer nodeInstanceContainer, Map<String, Long> nodeMapping) {
        for (NodeInstance nodeInstance : nodeInstanceContainer.getNodeInstances()) {
            String oldNodeId = ((NodeImpl)
                    ((org.jbpm.workflow.instance.NodeInstance) nodeInstance).getNode()).getUniqueId();
            Long newNodeId = nodeMapping.get(oldNodeId);
            if (newNodeId == null) {
                newNodeId = nodeInstance.getNodeId();
            }

            
            Map<String, Integer> iterLevels = ((WorkflowProcessInstanceImpl) nodeInstance.getProcessInstance()).getIterationLevels();
            String uniqueId = (String) ((NodeImpl) nodeInstance.getNode()).getMetaData("UniqueId");
            iterLevels.remove(uniqueId);
            
            ((NodeInstanceImpl) nodeInstance).setNodeId(newNodeId);

            if (nodeInstance instanceof NodeInstanceContainer) {
                updateNodeInstances((NodeInstanceContainer) nodeInstance, nodeMapping);
            }
        }

    }

}

<code block>


package org.jbpm.workflow.core.node;

import java.util.HashMap;
import java.util.Map;

import org.kie.api.definition.process.Connection;
import org.jbpm.workflow.core.Constraint;
import org.jbpm.workflow.core.impl.ConnectionRef;

public class StateNode extends CompositeContextNode implements Constrainable {

	private static final long serialVersionUID = 510l;
	
    private Map<ConnectionRef, Constraint> constraints = new HashMap<ConnectionRef, Constraint>();
   
    public void setConstraints(Map<ConnectionRef, Constraint> constraints) {
        this.constraints = constraints;
    }

    public void setConstraint(final Connection connection, final Constraint constraint) {
		if (connection == null) {
			throw new IllegalArgumentException("connection is null");
		}
		if (!getDefaultOutgoingConnections().contains(connection)) {
			throw new IllegalArgumentException("connection is unknown:"	+ connection);
		}
		addConstraint(new ConnectionRef(
			connection.getTo().getId(), connection.getToType()), constraint);
	}

    public void addConstraint(ConnectionRef connectionRef, Constraint constraint) {
    	if (connectionRef == null) {
    		throw new IllegalArgumentException(
				"A state node only accepts constraints linked to a connection");
    	}
        constraints.put(connectionRef, constraint);
    }
    
    public Constraint getConstraint(ConnectionRef connectionRef){
        return constraints.get(connectionRef);
    }
    
    public Map<ConnectionRef, Constraint> getConstraints(){
        return constraints;
    }

    public Constraint getConstraint(final Connection connection) {
        if (connection == null) {
            throw new IllegalArgumentException("connection is null");
        }
        ConnectionRef ref = new ConnectionRef(connection.getTo().getId(), connection.getToType());
        return this.constraints.get(ref);
    }

}

<code block>

package org.jbpm.persistence.timer;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.drools.core.command.CommandService;
import org.drools.core.time.InternalSchedulerService;
import org.drools.core.time.Job;
import org.drools.core.time.JobContext;
import org.drools.core.time.JobHandle;
import org.drools.core.time.SelfRemovalJob;
import org.drools.core.time.SelfRemovalJobContext;
import org.drools.core.time.Trigger;
import org.drools.core.time.impl.TimerJobFactoryManager;
import org.drools.core.time.impl.TimerJobInstance;
import org.jbpm.process.instance.timer.TimerManager.ProcessJobContext;

public class GlobalJPATimerJobFactoryManager implements TimerJobFactoryManager {

    private Map<Long, TimerJobInstance> emptyStore = new HashMap<Long,TimerJobInstance>();
    private CommandService commandService;
    private Map<Long, Map<Long, TimerJobInstance>> timerInstances;
    private Map<Long, TimerJobInstance> singleTimerInstances;
    
    public void setCommandService(CommandService commandService) {
        this.commandService = commandService;
    }
    
    public GlobalJPATimerJobFactoryManager() {
        timerInstances = new ConcurrentHashMap<Long, Map<Long, TimerJobInstance>>();
        singleTimerInstances = new ConcurrentHashMap<Long, TimerJobInstance>();
        
    }
    
    public TimerJobInstance createTimerJobInstance(Job job,
                                                   JobContext ctx,
                                                   Trigger trigger,
                                                   JobHandle handle,
                                                   InternalSchedulerService scheduler) {
    	long sessionId = -1;
    	if (ctx instanceof ProcessJobContext) {
            sessionId = ((ProcessJobContext) ctx).getSessionId();
            Map<Long, TimerJobInstance> instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        }        
        ctx.setJobHandle( handle );
        GlobalJpaTimerJobInstance jobInstance = new GlobalJpaTimerJobInstance( new SelfRemovalJob( job ),
                                                                   new SelfRemovalJobContext( ctx,
                                                                		   emptyStore ),
                                                                   trigger,
                                                                   handle,
                                                                   scheduler);
    
        return jobInstance;
    }
    
    public void addTimerJobInstance(TimerJobInstance instance) {
    
        JobContext ctx = instance.getJobContext();
        if (ctx instanceof SelfRemovalJobContext) {
            ctx = ((SelfRemovalJobContext) ctx).getJobContext();
        }
        Map<Long, TimerJobInstance> instances = null;
        if (ctx instanceof ProcessJobContext) {
            long sessionId = ((ProcessJobContext)ctx).getSessionId();
            instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        } else {
            instances = singleTimerInstances;
        }
        instances.put( instance.getJobHandle().getId(),
                                 instance );        
    }
    
    public void removeTimerJobInstance(TimerJobInstance instance) {
        JobContext ctx = instance.getJobContext();
        if (ctx instanceof SelfRemovalJobContext) {
            ctx = ((SelfRemovalJobContext) ctx).getJobContext();
        }
        Map<Long, TimerJobInstance> instances = null;
        if (ctx instanceof ProcessJobContext) {
            long sessionId = ((ProcessJobContext)ctx).getSessionId();
            instances = timerInstances.get(sessionId);
            if (instances == null) {
                instances = new ConcurrentHashMap<Long, TimerJobInstance>();
                timerInstances.put(sessionId, instances);
            }
        } else {
            instances = singleTimerInstances;
        }
        instances.remove( instance.getJobHandle().getId() );        
    }
    
    
    public Collection<TimerJobInstance> getTimerJobInstances() {
        return singleTimerInstances.values();
    }
    
    public Collection<TimerJobInstance> getTimerJobInstances(Integer sessionId) {
        Map<Long, TimerJobInstance> sessionTimerJobs = timerInstances.get(sessionId);
        if (sessionTimerJobs == null) {
            return Collections.EMPTY_LIST;
        }
        return sessionTimerJobs.values();
    }
    
    public CommandService getCommandService() {
        return this.commandService;
    }
    
}

<code block>

package org.jbpm.services.task.wih.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import org.drools.core.process.instance.WorkItem;
import org.drools.core.process.instance.impl.WorkItemImpl;
import org.jbpm.test.util.AbstractBaseTest;
import org.junit.Before;
import org.junit.Test;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.PeopleAssignments;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.InternalPeopleAssignments;
import org.kie.internal.task.api.model.InternalTask;
import org.kie.internal.task.api.model.InternalTaskData;


public class PeopleAssignmentHelperTest  extends AbstractBaseTest {
	
	private PeopleAssignmentHelper peopleAssignmentHelper;
	
	@Before
	public void setup() {
		
		peopleAssignmentHelper = new PeopleAssignmentHelper();
		
	}
	
	@Test
	public void testProcessPeopleAssignments() {

		List<OrganizationalEntity> organizationalEntities = new ArrayList<OrganizationalEntity>();
		
		String ids = "espiegelberg,   drbug   ";
		assertTrue(organizationalEntities.size() == 0);		
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.size() == 2);
		organizationalEntities.contains("drbug");
		organizationalEntities.contains("espiegelberg");
		assertTrue(organizationalEntities.get(0) instanceof User);
		assertTrue(organizationalEntities.get(1) instanceof User);
		
		ids = null;
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.size() == 0);		
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.size() == 0);
		
		ids = "     ";
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.size() == 0);		
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, true);
		assertTrue(organizationalEntities.size() == 0);
		
		ids = "Software Developer";
		organizationalEntities = new ArrayList<OrganizationalEntity>();
		assertTrue(organizationalEntities.size() == 0);		
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, false);
		assertTrue(organizationalEntities.size() == 1);
		assertTrue(organizationalEntities.get(0) instanceof Group);
		
		
		ids = "Software Developer,Project Manager";
		peopleAssignmentHelper.processPeopleAssignments(ids, organizationalEntities, false);
		assertTrue(organizationalEntities.size() == 2);
		assertTrue(organizationalEntities.get(0) instanceof Group);
		assertTrue(organizationalEntities.get(1) instanceof Group);
		
	}
	
	@Test
	public void testAssignActors() {
		
		String actorId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
		
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertTrue(organizationalEntity1 instanceof User);
		assertEquals(actorId, organizationalEntity1.getId());		
		assertEquals(actorId, taskData.getCreatedBy().getId());
		
		workItem = new WorkItemImpl();
		peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);				
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + ", drbug  ");
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		assertEquals(2, peopleAssignments.getPotentialOwners().size());
		organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertEquals(actorId, organizationalEntity1.getId());		
		assertEquals(actorId, taskData.getCreatedBy().getId());
		OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
		assertEquals("drbug", organizationalEntity2.getId());

		workItem = new WorkItemImpl();
		peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);				
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
		peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
		assertEquals(0, peopleAssignments.getPotentialOwners().size());

	}
	
	@Test
    public void testAssignActorsWithCustomSeparatorViaSysProp() {
        System.setProperty("org.jbpm.ht.user.separator", ";");
        peopleAssignmentHelper = new PeopleAssignmentHelper();
        String actorId = "user1;user2";
        
        Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        
        OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId());       
        
        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + "; drbug  ");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(3, peopleAssignments.getPotentialOwners().size());
        organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId()); 
        OrganizationalEntity organizationalEntity3 = peopleAssignments.getPotentialOwners().get(2);
        assertEquals("drbug", organizationalEntity3.getId());

        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(0, peopleAssignments.getPotentialOwners().size());
        System.clearProperty("org.jbpm.ht.user.separator");
    }
	
	@Test
    public void testAssignActorsWithCustomSeparator() {
        peopleAssignmentHelper = new PeopleAssignmentHelper(":");
        String actorId = "user1:user2";
        
        Task task = TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        
        OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId());       
        
        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId + ": drbug  ");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(3, peopleAssignments.getPotentialOwners().size());
        organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
        assertEquals("user1", organizationalEntity1.getId());       
        assertEquals("user1", taskData.getCreatedBy().getId());
        organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
        assertTrue(organizationalEntity2 instanceof User);
        assertEquals("user2", organizationalEntity2.getId()); 
        OrganizationalEntity organizationalEntity3 = peopleAssignments.getPotentialOwners().get(2);
        assertEquals("drbug", organizationalEntity3.getId());

        workItem = new WorkItemImpl();
        peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);              
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, "");
        peopleAssignmentHelper.assignActors(workItem, peopleAssignments, taskData);
        assertEquals(0, peopleAssignments.getPotentialOwners().size());
    }
	
	@Test
	public void testAssignBusinessAdministrators() {
	
		String businessAdministratorId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);

		peopleAssignmentHelper.assignBusinessAdministrators(workItem, peopleAssignments);
		assertEquals(3, peopleAssignments.getBusinessAdministrators().size());
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getBusinessAdministrators().get(0);
		assertTrue(organizationalEntity1 instanceof User);
		assertEquals("Administrator", organizationalEntity1.getId());

		OrganizationalEntity organizationalEntity2 = peopleAssignments.getBusinessAdministrators().get(1);        
        assertTrue(organizationalEntity2 instanceof Group);              
        assertEquals("Administrators", organizationalEntity2.getId());

        OrganizationalEntity organizationalEntity3 = peopleAssignments.getBusinessAdministrators().get(2);      
        assertTrue(organizationalEntity3 instanceof User);              
        assertEquals(businessAdministratorId, organizationalEntity3.getId());
	}

    @Test
    public void testAssignBusinessAdministratorGroups() {
    
        String businessAdministratorGroupId = "Super users";
        
        Task task = TaskModelProvider.getFactory().newTask();
        PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        
        WorkItem workItem = new WorkItemImpl();     
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);

        peopleAssignmentHelper.assignBusinessAdministrators(workItem, peopleAssignments);
        assertEquals(3, peopleAssignments.getBusinessAdministrators().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getBusinessAdministrators().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals("Administrator", organizationalEntity1.getId());

        OrganizationalEntity organizationalEntity2 = peopleAssignments.getBusinessAdministrators().get(1);        
        assertTrue(organizationalEntity2 instanceof Group);              
        assertEquals("Administrators", organizationalEntity2.getId());

        OrganizationalEntity organizationalEntity3 = peopleAssignments.getBusinessAdministrators().get(2);      
        assertTrue(organizationalEntity3 instanceof Group);              
        assertEquals(businessAdministratorGroupId, organizationalEntity3.getId());
    }
	
	@Test
	public void testAssignTaskstakeholders() {
	
		String taskStakeholderId = "espiegelberg";
		
		Task task = TaskModelProvider.getFactory().newTask();
		InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);

		peopleAssignmentHelper.assignTaskStakeholders(workItem, peopleAssignments);
		assertEquals(1, peopleAssignments.getTaskStakeholders().size());
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getTaskStakeholders().get(0);		
		assertTrue(organizationalEntity1 instanceof User);				
		assertEquals(taskStakeholderId, organizationalEntity1.getId());
		
	}
	
	@Test
	public void testAssignGroups() {
		
		String groupId = "Software Developers, Project Managers";
		
		Task task = TaskModelProvider.getFactory().newTask();
		PeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.GROUP_ID, groupId);
		
		peopleAssignmentHelper.assignGroups(workItem, peopleAssignments);
		OrganizationalEntity organizationalEntity1 = peopleAssignments.getPotentialOwners().get(0);
		assertTrue(organizationalEntity1 instanceof Group);
		assertEquals("Software Developers", organizationalEntity1.getId());
		OrganizationalEntity organizationalEntity2 = peopleAssignments.getPotentialOwners().get(1);
		assertTrue(organizationalEntity2 instanceof Group);
		assertEquals("Project Managers", organizationalEntity2.getId());
		
	}
	
	@Test
	public void testgetNullSafePeopleAssignments() {
		
		Task task = TaskModelProvider.getFactory().newTask();
		
		InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		
		peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		
		((InternalTask) task).setPeopleAssignments(null);
		peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		assertEquals(0, peopleAssignment.getPotentialOwners().size());
		assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
		assertEquals(0, peopleAssignment.getExcludedOwners().size());
		assertEquals(0, peopleAssignment.getRecipients().size());
		assertEquals(0, peopleAssignment.getTaskStakeholders().size());
		
	}	
	
	@Test
	public void testHandlePeopleAssignments() {
		
		InternalTask task = (InternalTask) TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
		InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
		assertNotNull(peopleAssignment);
		assertEquals(0, peopleAssignment.getPotentialOwners().size());
		assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
		assertEquals(0, peopleAssignment.getTaskStakeholders().size());
		
		String actorId = "espiegelberg";
		String taskStakeholderId = "drmary";
		String businessAdministratorId = "drbug";
        String businessAdministratorGroupId = "Super users";
        String excludedOwnerId = "john";
        String recipientId = "mary";
		
		WorkItem workItem = new WorkItemImpl();		
		workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
		workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);
		workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);
		
		peopleAssignmentHelper.handlePeopleAssignments(workItem, task, taskData);
		
		List<OrganizationalEntity> potentialOwners = task.getPeopleAssignments().getPotentialOwners();
		assertEquals(1, potentialOwners.size());
		assertEquals(actorId, potentialOwners.get(0).getId());
		
		List<OrganizationalEntity> businessAdministrators = task.getPeopleAssignments().getBusinessAdministrators();
		assertEquals(4, businessAdministrators.size());
		assertEquals("Administrator", businessAdministrators.get(0).getId());
		
		assertEquals("Administrators", businessAdministrators.get(1).getId());
		assertEquals(businessAdministratorId, businessAdministrators.get(2).getId());
        assertEquals(businessAdministratorGroupId, businessAdministrators.get(3).getId());
		
		
		List<OrganizationalEntity> taskStakehoders = ((InternalPeopleAssignments) task.getPeopleAssignments()).getTaskStakeholders();
		assertEquals(1, taskStakehoders.size());
		assertEquals(taskStakeholderId, taskStakehoders.get(0).getId());

        List<OrganizationalEntity> excludedOwners = ((InternalPeopleAssignments) task.getPeopleAssignments()).getExcludedOwners();
        assertEquals(1, excludedOwners.size());
        assertEquals(excludedOwnerId, excludedOwners.get(0).getId());

        List<OrganizationalEntity> recipients = ((InternalPeopleAssignments) task.getPeopleAssignments()).getRecipients();
        assertEquals(1, recipients.size());
        assertEquals(recipientId, recipients.get(0).getId());
		
	}

    @Test
    public void testHandleMultiPeopleAssignments() {

    	InternalTask task = (InternalTask) TaskModelProvider.getFactory().newTask();
		InternalTaskData taskData = (InternalTaskData) TaskModelProvider.getFactory().newTaskData();
        InternalPeopleAssignments peopleAssignment = peopleAssignmentHelper.getNullSafePeopleAssignments(task);
        assertNotNull(peopleAssignment);
        assertEquals(0, peopleAssignment.getPotentialOwners().size());
        assertEquals(0, peopleAssignment.getBusinessAdministrators().size());
        assertEquals(0, peopleAssignment.getTaskStakeholders().size());

        String actorId = "espiegelberg,john";
        String taskStakeholderId = "drmary,krisv";
        String businessAdministratorId = "drbug,peter";
        String businessAdministratorGroupId = "Super users,Flow administrators";
        String excludedOwnerId = "john,poul";
        String recipientId = "mary,steve";

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.ACTOR_ID, actorId);
        workItem.setParameter(PeopleAssignmentHelper.TASKSTAKEHOLDER_ID, taskStakeholderId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_ID, businessAdministratorId);
        workItem.setParameter(PeopleAssignmentHelper.BUSINESSADMINISTRATOR_GROUP_ID, businessAdministratorGroupId);
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);

        peopleAssignmentHelper.handlePeopleAssignments(workItem, task, taskData);

        List<OrganizationalEntity> potentialOwners = task.getPeopleAssignments().getPotentialOwners();
        assertEquals(2, potentialOwners.size());
        assertEquals("espiegelberg", potentialOwners.get(0).getId());
        assertEquals("john", potentialOwners.get(1).getId());

        List<OrganizationalEntity> businessAdministrators = task.getPeopleAssignments().getBusinessAdministrators();
        assertEquals(6, businessAdministrators.size());
        assertEquals("Administrator", businessAdministrators.get(0).getId());
        
        assertEquals("Administrators", businessAdministrators.get(1).getId());
        assertEquals("drbug", businessAdministrators.get(2).getId());
        assertEquals("peter", businessAdministrators.get(3).getId());
        assertEquals("Super users", businessAdministrators.get(4).getId());
        assertEquals("Flow administrators", businessAdministrators.get(5).getId());
        
        
        List<OrganizationalEntity> taskStakehoders = ((InternalPeopleAssignments) task.getPeopleAssignments()).getTaskStakeholders();
        assertEquals(2, taskStakehoders.size());
        assertEquals("drmary", taskStakehoders.get(0).getId());
        assertEquals("krisv", taskStakehoders.get(1).getId());

        List<OrganizationalEntity> excludedOwners = ((InternalPeopleAssignments) task.getPeopleAssignments()).getExcludedOwners();
        assertEquals(2, excludedOwners.size());
        assertEquals("john", excludedOwners.get(0).getId());
        assertEquals("poul", excludedOwners.get(1).getId());

        List<OrganizationalEntity> recipients = ((InternalPeopleAssignments) task.getPeopleAssignments()).getRecipients();
        assertEquals(2, recipients.size());
        assertEquals("mary", recipients.get(0).getId());
        assertEquals("steve", recipients.get(1).getId());

    }

    @Test
    public void testAssignExcludedOwners() {

        String excludedOwnerId = "espiegelberg";

        Task task = TaskModelProvider.getFactory().newTask();
        InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.EXCLUDED_OWNER_ID, excludedOwnerId);

        peopleAssignmentHelper.assignExcludedOwners(workItem, peopleAssignments);
        assertEquals(1, peopleAssignments.getExcludedOwners().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getExcludedOwners().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals(excludedOwnerId, organizationalEntity1.getId());

    }

    @Test
    public void testAssignRecipients() {

        String recipientId = "espiegelberg";

        Task task = TaskModelProvider.getFactory().newTask();
        InternalPeopleAssignments peopleAssignments = peopleAssignmentHelper.getNullSafePeopleAssignments(task);

        WorkItem workItem = new WorkItemImpl();
        workItem.setParameter(PeopleAssignmentHelper.RECIPIENT_ID, recipientId);

        peopleAssignmentHelper.assignRecipients(workItem, peopleAssignments);
        assertEquals(1, peopleAssignments.getRecipients().size());
        OrganizationalEntity organizationalEntity1 = peopleAssignments.getRecipients().get(0);
        assertTrue(organizationalEntity1 instanceof User);
        assertEquals(recipientId, organizationalEntity1.getId());

    }
	
}

<code block>

package org.jbpm.services.task;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jbpm.services.task.exception.PermissionDeniedException;
import org.jbpm.services.task.impl.factories.TaskFactory;
import org.jbpm.services.task.impl.model.xml.JaxbContent;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.junit.Test;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.I18NText;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.ContentData;
import org.kie.internal.task.api.model.FaultData;
import org.kie.internal.task.api.model.InternalComment;
import org.kie.internal.task.api.model.InternalI18NText;
import org.kie.internal.task.api.model.InternalOrganizationalEntity;
import org.kie.internal.task.api.model.InternalPeopleAssignments;
import org.kie.internal.task.api.model.InternalTask;
import org.kie.internal.task.api.model.InternalTaskData;

public abstract class LifeCycleBaseTest extends HumanTaskServicesBaseTest {

    
    @Test
    
    public void testWithNoTaskAndEmptyLists(){
      
      List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("nouser", new ArrayList<String>());
      assertTrue(tasksAssignedAsPotentialOwner.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner2 = taskService.getTasksAssignedAsPotentialOwner("nouser", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner2.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner3 = taskService.getTasksAssignedAsPotentialOwner("", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner3.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner4 = taskService.getTasksAssignedAsPotentialOwner(null,(List<String>) null);
      assertTrue(tasksAssignedAsPotentialOwner4.isEmpty());
      
      List<TaskSummary> tasksAssignedAsPotentialOwner5 = taskService.getTasksAssignedAsPotentialOwner("salaboy", (List<String>)null);
      assertTrue(tasksAssignedAsPotentialOwner5.isEmpty());
      
      List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", null, null);
      assertTrue(tasks.isEmpty());
      
      List<TaskSummary> tasks2 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", new ArrayList<String>(), null);
      assertTrue(tasks2.isEmpty());
      
      List<TaskSummary> tasks3 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("Bobba Fet", new ArrayList<String>(), new ArrayList<Status>());
      assertTrue(tasks3.isEmpty());
      
      List<TaskSummary> tasks4 = taskService.getTasksAssignedAsPotentialOwnerByStatusByGroup("admin", new ArrayList<String>(), new ArrayList<Status>());
      assertTrue(tasks4.isEmpty());
              
      
    }
  
    @Test
    public void testNewTaskWithNoPotentialOwners() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Administrator') ],}),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(task1.getTaskData().getStatus(), Status.Created);
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testNewTaskWithSinglePotentialOwner() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet')  ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));

        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        String potOwner = "Bobba Fet"; 
        assertEquals(potOwner, task1.getTaskData().getActualOwner().getId());
        
        taskService.getTasksAssignedAsPotentialOwner(potOwner, "en-UK");
    }
    
    

    @Test
    public void testNewTaskWithContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        ContentData data = ContentMarshallerHelper.marshal("content", null);

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, data);

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType());
        assertEquals("java.lang.String", task1.getTaskData().getDocumentType());
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.toString());
        xmlRoundTripContent(content);
    }
    
    @Test
    public void testNewTaskWithMapContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";                        
        str += "name =  'This is my task name' })";
            
        Map<String, Object> variablesMap = new HashMap<String, Object>();
        variablesMap.put("key1", "value1");
        variablesMap.put("key2", null);
        variablesMap.put("key3", "value3");
        ContentData data = ContentMarshallerHelper.marshal(variablesMap, null);
        
        Task task = ( Task )  TaskFactory.evalTask( new StringReader( str ));
        taskService.addTask( task, data );
        
        long taskId = task.getId();
        
        
        Task task1 = taskService.getTaskById( taskId );
        assertEquals( AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType() );
        assertEquals( "java.util.HashMap", task1.getTaskData().getDocumentType() );
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue( contentId != -1 ); 
       
        
        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        }
        Map<String, Object> unmarshalledvars = (Map<String, Object>)unmarshalledObject;
        JaxbContent jaxbContent = xmlRoundTripContent(content);
        assertNotNull( "Jaxb Content map not filled", jaxbContent.getContentMap());
        
        assertEquals("value1",unmarshalledvars.get("key1") );
        assertNull(unmarshalledvars.get("key2") );
        assertEquals("value3",unmarshalledvars.get("key3") );
    }
    
    
    @Test
    public void testNewTaskWithMapContentAndOutput() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";                        
        str += "name =  'This is my task name' })";
            
        Map<String, Object> variablesMap = new HashMap<String, Object>();
        variablesMap.put("key1", "value1");
        variablesMap.put("key2", null);
        variablesMap.put("key3", "value3");
        ContentData data = ContentMarshallerHelper.marshal(variablesMap, null);
        
        Task task = ( Task )  TaskFactory.evalTask( new StringReader( str ));
        taskService.addTask( task, data );
        
        long taskId = task.getId();
        
        
        
        
        Task task1 = taskService.getTaskById( taskId );
        assertEquals( AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType() );
        assertEquals( "java.util.HashMap", task1.getTaskData().getDocumentType() );
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue( contentId != -1 ); 

        
        
        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        }
        xmlRoundTripContent(content);
        
        Map<String, Object> unmarshalledvars = (Map<String, Object>) unmarshalledObject;
        
        assertEquals("value1",unmarshalledvars.get("key1") );
        assertNull(unmarshalledvars.get("key2") );
        assertEquals("value3",unmarshalledvars.get("key3") );
        
        taskService.start(taskId,"Bobba Fet" );
        
        task1 = taskService.getTaskById( taskId );
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        
        
        
        Map<String, Object> intermediateOutputContentMap = new HashMap<String, Object>();
        
        intermediateOutputContentMap.put("key2", "value2");
        intermediateOutputContentMap.put("key4", "value4");
        
        
        taskService.addContent(taskId, intermediateOutputContentMap);
        
        Map<String, Object> finalOutputContentMap = new HashMap<String, Object>();
         finalOutputContentMap.put("key5", "value5");
        finalOutputContentMap.put("key6", "value6");
        
        
        taskService.complete(taskId,"Bobba Fet", finalOutputContentMap);
        
        task1 = taskService.getTaskById( taskId );
        assertEquals(Status.Completed, task1.getTaskData().getStatus());
        long outputContentId = task1.getTaskData().getOutputContentId();
        Content contentById = taskService.getContentById(outputContentId);
        
        unmarshalledObject = ContentMarshallerHelper.unmarshall(contentById.getContent(), null);
        assertNotNull(unmarshalledObject);
        if(!(unmarshalledObject instanceof Map)){
            fail("The variables should be a Map");
        
        }
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key2"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key4"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key5"));
        assertTrue(((Map<String, Object>)unmarshalledObject).containsKey("key6"));
        xmlRoundTripContent(contentById);
    }
    
    @Test
    public void testNewTaskWithLargeContent() {
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        String largeContent = "";
        for (int i = 0; i < 1000; i++) {
            largeContent += i + "xxxxxxxxx";
        }

        ContentData data = ContentMarshallerHelper.marshal(largeContent, null);

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, data);

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task1.getTaskData()).getDocumentAccessType());
        assertEquals("java.lang.String", task1.getTaskData().getDocumentType());
        long contentId = task1.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Content content = taskService.getContentById(contentId);
        Object unmarshalledObject = ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals(largeContent, unmarshalledObject.toString());
        xmlRoundTripContent(content);
    }

    @Test
    public void testClaimWithMultiplePotentialOwners() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'),new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());


        taskService.claim(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testClaimWithGroupAssignee() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('Knights Templer' )], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        taskService.claim(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    
     @Test
    public void testForwardGroupClaimQueryAssignee() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy' )], businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";
        
        
        String str2 = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str2 += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy')], businessAdministrators = [ new User('Administrator') ], }),";
        str2 += "name = 'This is my second task name' })";

         
        String str3 = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str3 += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('Crusaders'), new Group('Knights Templer')], businessAdministrators = [ new User('Administrator') ], }),";
        str3 += "name = 'This is my third task name' })";
        
        
        List<String> groupIds = new ArrayList<String>();
        
        groupIds.add("Knights Templer");
        groupIds.add("non existing group");
        groupIds.add("non existing group 2");
        groupIds.add("Crusaders");
        
        List<Status> statuses = new ArrayList<Status>();
        statuses.add(Status.Ready);
        statuses.add(Status.Created);
        statuses.add(Status.InProgress);
        statuses.add(Status.Reserved);
        

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        
        Task task3 = (Task) TaskFactory.evalTask(new StringReader(str2));
        taskService.addTask(task3, new HashMap<String, Object>());
        
        Task task4 = (Task) TaskFactory.evalTask(new StringReader(str3));
        taskService.addTask(task4, new HashMap<String, Object>());
        
        List<TaskSummary> tasksAssignedByGroups = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, tasksAssignedByGroups.size());

        

          List<TaskSummary> allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, allTasks.size());
        List<TaskSummary> personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(2, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("salaboy", "en-UK");
        assertEquals(3, tasksAssignedAsPotentialOwner.size());
        
        taskService.forward(taskId, "salaboy", "Crusaders");

        
        allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(2, allTasks.size());
        personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(1, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());
        
        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(1, task2.getPeopleAssignments().getPotentialOwners().size());
        List<TaskSummary> tasksAssignedByGroup = taskService.getTasksAssignedByGroup("Crusaders");
        
        assertEquals(2, tasksAssignedByGroup.size());
       
        
        tasksAssignedByGroups = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(2, tasksAssignedByGroups.size());
        
        taskService.claim(taskId, "salaboy");
        
        task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("salaboy", task2.getTaskData().getActualOwner().getId());
        assertEquals(1, task2.getPeopleAssignments().getPotentialOwners().size());
        
        List<TaskSummary> tasksOwned = taskService.getTasksOwned("salaboy", "en-UK");
        assertEquals(2, tasksOwned.size());
  
        allTasks = taskService.getTasksAssignedByGroups(groupIds);
        assertEquals(1, allTasks.size());
        personalTasks = taskService.getTasksOwnedByStatus("salaboy", statuses, "en-UK");
        assertEquals(2, personalTasks.size());
        allTasks.addAll(personalTasks);
        assertEquals(3, allTasks.size());
        
        
    }

    @Test
    public void testStartFromReadyStateWithPotentialOwner() throws Exception {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        
        taskService.start(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStartFromReadyStateWithIncorrectPotentialOwner() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name'})";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<TaskSummary> tasksAssignedAsPotentialOwner = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");
        assertEquals(1, tasksAssignedAsPotentialOwner.size());
        
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());

        


        PermissionDeniedException denied = null;
        try {
            taskService.start(taskId, "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }

        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    @Test
    public void testStartFromReserved() throws Exception {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());

        

        taskService.start(taskId, "Bobba Fet");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStartFromReservedWithIncorrectUser() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());

        



        PermissionDeniedException denied = null;
        try {
            taskService.start(taskId, "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Bobba Fet", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStop() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.start(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.stop(taskId, "Darth Vader");


        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testStopWithIncorrectUser() {

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.stop(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testReleaseFromInprogress() throws Exception {


        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");



        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.release(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    public void testReleaseFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name'})";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.release(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
        assertNull(task2.getTaskData().getActualOwner());
    }

    @Test
    public void testReleaseWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.release(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSuspendFromReady() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name'})";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.suspend(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals(Status.Ready, task2.getTaskData().getPreviousStatus());
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testSuspendFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.suspend(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getPreviousStatus());
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSuspendFromReservedWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.suspend(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test 
    public void testResumeFromReady() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.suspend(taskId, "Darth Vader");

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals(Status.Ready, task2.getTaskData().getPreviousStatus());
        assertNull(task1.getTaskData().getActualOwner());

        

        taskService.resume(taskId, "Darth Vader");

        Task task3 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task3.getTaskData().getStatus());
        assertEquals(Status.Suspended, task3.getTaskData().getPreviousStatus());
        assertNull(task3.getTaskData().getActualOwner());
    }

    @Test
    public void testResumeFromReserved() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.suspend(taskId, "Darth Vader");




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getPreviousStatus());
        assertEquals(Status.Suspended, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());

        

        taskService.resume(taskId, "Darth Vader");

        Task task3 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task3.getTaskData().getStatus());
        assertEquals(Status.Suspended, task3.getTaskData().getPreviousStatus());
        assertEquals("Darth Vader", task3.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testResumeFromReservedWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        PermissionDeniedException denied = null;
        try {
            taskService.suspend(taskId, "Bobba Fet");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testSkipFromReady() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = true} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.skip(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Obsolete, task1.getTaskData().getStatus());
        assertNull(task1.getTaskData().getActualOwner());
    }

    @Test
    public void testSkipFromReserved() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = true} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        

        taskService.skip(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Obsolete, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testDelegateFromReady() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        
        taskService.delegate(taskId, "Darth Vader", "Tony Stark");




        Task task2 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Tony Stark", task2.getTaskData().getActualOwner().getId());
        
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testDelegateFromReserved() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.delegate(taskId, "Darth Vader", "Tony Stark");




        Task task2 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Tony Stark", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testDelegateFromReservedWithIncorrectUser() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());
        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.delegate(taskId, "Bobba Fet", "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);

        Task task2 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Tony Stark");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    public void testForwardFromReady() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.forward(taskId, "Darth Vader", "Tony Stark");


        Task task2 = taskService.getTaskById(taskId);
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains("Darth Vader"));
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains("Tony Stark"));
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
    }

    @Test
    public void testForwardFromReserved() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.forward(taskId, "Darth Vader", "Tony Stark");


        Task task2 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Tony Stark");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertNull(task2.getTaskData().getActualOwner());
        assertEquals(Status.Ready, task2.getTaskData().getStatus());
    }

    @Test
    public void testForwardFromReservedWithIncorrectUser() throws Exception {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.claim(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.forward(taskId, "Bobba Fet", "Tony Stark");
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertTrue(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Tony Stark");
        assertFalse(task2.getPeopleAssignments().getPotentialOwners().contains(user));
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        assertEquals(Status.Reserved, task2.getTaskData().getStatus());
    }

    @Test
    public void testComplete() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testCompleteWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.complete(taskId, "Bobba Fet", null);
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testCompleteWithContent() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("content", "content");
        taskService.complete(taskId, "Darth Vader", params);

        List<Content> allContent = taskService.getAllContentByTaskId(taskId);
        assertNotNull(allContent);
        assertEquals(3, allContent.size());
        
        assertNotNull(allContent.get(0));
        assertNotNull(allContent.get(1));
        assertNull(allContent.get(2));

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getOutputAccessType());
        assertEquals("java.util.HashMap", task2.getTaskData().getOutputType());
        long contentId = task2.getTaskData().getOutputContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.get("content"));
        
        
        params.put("content", "updated content");
	    taskService.setOutput(taskId, "Darth Vader", params);
	    
	    task = taskService.getTaskById(taskId);
	    contentId = task.getTaskData().getOutputContentId();
	    
	    content = taskService.getContentById(contentId);
	    String updated = new String(content.getContent());
	    unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("updated content", unmarshalledObject.get("content"));
        
        taskService.deleteOutput(taskId, "Darth Vader");
        content = taskService.getContentById(contentId);
        assertNull(content);
    }

    @Test
    public void testCompleteWithResults() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());


        Map<String, Object> params = new HashMap<String, Object>();
        params.put("content", "content");
        taskService.complete(taskId, "Darth Vader", params);


        Task task2 = taskService.getTaskById(taskId);
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getOutputAccessType());
        assertEquals("java.util.HashMap", task2.getTaskData().getOutputType());
        long contentId = task2.getTaskData().getOutputContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledObject = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledObject.get("content"));
    }

    @Test
    public void testFail() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.fail(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Failed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testFailWithIncorrectUser() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        

        taskService.start(taskId, "Darth Vader");




        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        


        PermissionDeniedException denied = null;
        try {
            taskService.fail(taskId, "Bobba Fet", null);
        } catch (PermissionDeniedException e) {
            denied = e;
        }
        assertNotNull("Should get permissed denied exception", denied);



        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }

    @Test
    public void testFailWithContent() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator') ],}),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        
        taskService.start(taskId, "Darth Vader");

        taskService.getTaskById(taskId);
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        Map<String, Object> faultData = new HashMap<String, Object>();
        faultData.put("faultType", "type");
        faultData.put("faultName", "faultName");
        faultData.put("content", "content");

        taskService.fail(taskId, "Darth Vader", faultData);
        
        List<Content> allContent = taskService.getAllContentByTaskId(taskId);
        assertNotNull(allContent);
        assertEquals(3, allContent.size());
        
        assertNotNull(allContent.get(0));
        assertNull(allContent.get(1));
        assertNotNull(allContent.get(2));

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Failed, task2.getTaskData().getStatus());
        assertEquals(AccessType.Inline, ((InternalTaskData) task2.getTaskData()).getFaultAccessType());
        assertEquals("type", task2.getTaskData().getFaultType());
        assertEquals("faultName", task2.getTaskData().getFaultName());
        long contentId = task2.getTaskData().getFaultContentId();
        assertTrue(contentId != -1);



        Content content = taskService.getContentById(contentId);
        Map<String, Object> unmarshalledContent = (Map<String, Object>) ContentMarshallerHelper.unmarshall(content.getContent(), null);
        assertEquals("content", unmarshalledContent.get("content"));
        xmlRoundTripContent(content);
        
        
	    FaultData data = TaskModelProvider.getFactory().newFaultData();
	    data.setAccessType(AccessType.Inline);
	    data.setType("type");
	    data.setFaultName("faultName");
	    data.setContent("updated content".getBytes());
	    
	    taskService.setFault(taskId, "Darth Vader", data);
	    
	    task = taskService.getTaskById(taskId);
	    contentId = task.getTaskData().getFaultContentId();
	    
	    content = taskService.getContentById(contentId);
	    String updated = new String(content.getContent());
	    assertEquals("updated content", updated);
        
	    
        taskService.deleteFault(taskId, "Darth Vader");
        content = taskService.getContentById(contentId);
        assertNull(content);
    }













































    @Test
    public void testRemoveNotInRecipientList() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ],";
        str += "recipients = [new User('Bobba Fet') ] }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str), null);
        
        if (task.getPeopleAssignments() != null && task.getPeopleAssignments().getBusinessAdministrators() != null) {
            List<OrganizationalEntity> businessAdmins = new ArrayList<OrganizationalEntity>();
            User user = TaskModelProvider.getFactory().newUser();
            ((InternalOrganizationalEntity) user).setId("Administrator");
            businessAdmins.add(user);
            businessAdmins.addAll(task.getPeopleAssignments().getBusinessAdministrators());
            ((InternalPeopleAssignments) task.getPeopleAssignments()).setBusinessAdministrators(businessAdmins);
        }
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        


        List<TaskSummary> myRecipientTasks = taskService.getTasksAssignedAsRecipient("Jabba Hutt");

        assertNotNull(myRecipientTasks);
        assertEquals(0, myRecipientTasks.size());



        List<TaskSummary> myPotentialTasks = taskService.getTasksAssignedAsPotentialOwner("Jabba Hutt", "en-UK");

        assertNotNull(myPotentialTasks);
        assertEquals(0, myPotentialTasks.size());


        try {
            taskService.remove(taskId, "Jabba Hutt");
            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 
        }

        


        Task task1 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Bobba Fet");
        assertTrue(((InternalPeopleAssignments) task1.getPeopleAssignments()).getRecipients().contains(user));
    }

    
    @Test
    public void testNominateOnOtherThanCreated() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Administrator') ] ,";
        str += " potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name =  'This is my task name' })";

        Task task = (Task) TaskFactory.evalTask(new StringReader(str), null);

        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();

        taskService.start(taskId, "Bobba Fet");

        try {
            List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>();
            User user = TaskModelProvider.getFactory().newUser();
            ((InternalOrganizationalEntity) user).setId("Bobba Fet");
            potentialOwners.add(user);
            taskService.nominate(taskId, "Darth Vader", potentialOwners);

            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 



        }

        

        Task task1 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Darth Vader");
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(user));
        user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Bobba Fet");
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(user));
    }

    @Test
    public void testNominateWithIncorrectUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Bobba Fet') ] } ),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        try {
            List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>(1);
            User user = TaskModelProvider.getFactory().newUser();
            ((InternalOrganizationalEntity) user).setId("Jabba Hutt");
            potentialOwners.add(user);
            taskService.nominate(taskId, "Darth Vader", potentialOwners);

            fail("Shouldn't be successful");
        } catch (RuntimeException e) { 



        }

        

        Task task1 = taskService.getTaskById(taskId);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Bobba Fet");
        assertTrue(task1.getPeopleAssignments().getBusinessAdministrators().contains(user));
        assertEquals(task1.getTaskData().getStatus(), Status.Created);
    }

    @Test
    public void testNominateToUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        List<OrganizationalEntity> potentialOwners = new ArrayList<OrganizationalEntity>(1);
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Jabba Hutt");
        potentialOwners.add(user);
        taskService.nominate(taskId, "Darth Vader", potentialOwners);


        


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(task1.getTaskData().getActualOwner().getId(), "Jabba Hutt");
        assertEquals(task1.getTaskData().getStatus(), Status.Reserved);
    }

    @Test
    public void testNominateToGroup() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { businessAdministrators = [ new User('Darth Vader'), new User('Bobba Fet') ] } ),";
        str += "name = 'This is my task name'})";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        List<OrganizationalEntity> potentialGroups = new ArrayList<OrganizationalEntity>();
        Group group = TaskModelProvider.getFactory().newGroup();
        ((InternalOrganizationalEntity) group).setId("Knights Templer");
        potentialGroups.add(group);
        taskService.nominate(taskId, "Darth Vader", potentialGroups);


        


        Task task1 = taskService.getTaskById(taskId);
        assertTrue(task1.getPeopleAssignments().getPotentialOwners().contains(group));
        assertEquals(task1.getTaskData().getStatus(), Status.Ready);
    }

    @Test
    public void testActivate() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { ";
        str += "businessAdministrators = [ new User('Darth Vader') ] } ),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        taskService.activate(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);

        assertEquals(task1.getTaskData().getStatus(), Status.Ready);
        
        
        
        
    }

    @Test
    public void testActivateWithIncorrectUser() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ], ";
        str += "businessAdministrators = [ new User('Jabba Hutt') ] } ),";
        str += "name =  'This is my task name'})";

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();


        try {
            taskService.activate(taskId, "Darth Vader");

            fail("Shouldn't have succeded");
        } catch (RuntimeException e) {



        }

    }

    @Test
    public void testActivateFromIncorrectStatus() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { status = Status.Ready } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [ new User('Darth Vader'), new User('Bobba Fet') ], ";
        str += "businessAdministrators = [ new User('Jabba Hutt') ] } ),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str), null);
        
        if (task.getPeopleAssignments() != null && task.getPeopleAssignments().getBusinessAdministrators() != null) {
            List<OrganizationalEntity> businessAdmins = new ArrayList<OrganizationalEntity>();
            User user = TaskModelProvider.getFactory().newUser();
            ((InternalOrganizationalEntity) user).setId("Administrator");
            businessAdmins.add(user);
            businessAdmins.addAll(task.getPeopleAssignments().getBusinessAdministrators());
            ((InternalPeopleAssignments) task.getPeopleAssignments()).setBusinessAdministrators(businessAdmins);
        }
        
        taskService.addTask(task, new HashMap<String, Object>());

        
        long taskId = task.getId();


        try {
            taskService.activate(taskId, "Darth Vader");

            fail("Shouldn't have succeded");
        } catch (RuntimeException e) {



        }
    }

    @Test
    public void testExitFromReady() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromReserved() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromInProgress() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());

        taskService.start(taskId, "Bobba Fet");
        task = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task.getTaskData().getStatus());

        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitFromSuspended() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());

        taskService.suspend(taskId, "Bobba Fet");
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Suspended, task.getTaskData().getStatus());

        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitPermissionDenied() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ], businessAdministrators = [ new User('Administrator')] }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task.getTaskData().getStatus());

        try {
            taskService.exit(taskId, "Darth Vader");
            fail("Non admin user can't exit a task");
        } catch (PermissionDeniedException e) {
        }
        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Ready, task1.getTaskData().getStatus());
    }

    @Test
    public void testExitNotAvailableToUsers() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { skipable = false} ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet')], businessAdministrators = [ new User('Administrator')] }),";
        str += "name = 'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        task = taskService.getTaskById(taskId);
        assertEquals(Status.Reserved, task.getTaskData().getStatus());


        taskService.exit(taskId, "Administrator");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.Exited, task1.getTaskData().getStatus());

        List<TaskSummary> exitedTasks = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");
        assertEquals(0, exitedTasks.size());

    }

    @Test
    public void testClaimConflictAndRetry() {
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        

        
        taskService.addTask((Task) TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        
        
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwner("salaboy", "en-UK");

        
        Long salaboyTaskId = salaboyTasks.get(0).getId();

        
        
        Task salaboyTask = taskService.getTaskById(salaboyTaskId);
        assertEquals(Status.Ready, salaboyTask.getTaskData().getStatus());

        
        
        List<TaskSummary> bobbaTasks = taskService.getTasksAssignedAsPotentialOwner("Bobba Fet", "en-UK");

        
        Long bobbaTaskId = bobbaTasks.get(0).getId();
        assertEquals(bobbaTaskId, salaboyTaskId);
        
        
        Task bobbaTask = taskService.getTaskById(bobbaTaskId);
        assertEquals(Status.Ready, bobbaTask.getTaskData().getStatus());


        taskService.claim(bobbaTask.getId(), "Bobba Fet");

        try {
            taskService.claim(salaboyTask.getId(), "salaboy");
        } catch (PermissionDeniedException ex) {
            
            assertNotNull(ex);
        }

    }

    @Test
    public void testClaimNextAvailable() {
        
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        
        taskService.addTask((Task) TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        

        taskService.claimNextAvailable("Bobba Fet", "en-UK");


        List<Status> status = new ArrayList<Status>();
        status.add(Status.Ready);
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwnerByStatus("salaboy", status, "en-UK");
        assertEquals(0, salaboyTasks.size());

    }
    
    @Test
    public void testClaimNextAvailableWithGroups() {
        
        

        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('salaboy'), new User('Bobba Fet') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";

        
        taskService.addTask((Task) TaskFactory.evalTask(new StringReader(str)), new HashMap<String, Object>());

        
        List<String> groups = new ArrayList<String>();
        groups.add("HR");
        taskService.claimNextAvailable("Bobba Fet", groups);


        List<Status> status = new ArrayList<Status>();
        status.add(Status.Ready);
        List<TaskSummary> salaboyTasks = taskService.getTasksAssignedAsPotentialOwnerByStatus("salaboy", status, "en-UK");
        assertEquals(0, salaboyTasks.size());

    }
    
    @Test
    public void testCompleteWithRestrictedGroups() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('analyst'), new Group('Crusaders') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name =  'This is my task name' })";


        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<OrganizationalEntity> potOwners = task.getPeopleAssignments().getPotentialOwners();
        assertNotNull(potOwners);
        assertEquals(1, potOwners.size());
        assertEquals("Crusaders", potOwners.get(0).getId());

        

        taskService.start(taskId, "Darth Vader");


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);




        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    @Test
    public void testInvalidTask() {
    	try {
    		taskService.claim(-1, "Darth Vader");
    	} catch (PermissionDeniedException e) {
    		if ("Task '-1' not found".equals(e.getMessage())) {
    			return;
    		} else {
    			throw e;
    		}
    	}
    }
    
    @Test
    public void testCompleteWithComments() {       
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());

        long taskId = task.getId();
        
        List<Comment> comments = taskService.getAllCommentsByTaskId(taskId);
        assertNotNull(comments);
        assertEquals(0, comments.size());
        
        User user = TaskModelProvider.getFactory().newUser();
        ((InternalOrganizationalEntity) user).setId("Bobba Fet");
        
        Comment comment = TaskModelProvider.getFactory().newComment();
        ((InternalComment)comment).setAddedAt(new Date());
        ((InternalComment)comment).setAddedBy(user);
        ((InternalComment)comment).setText("Simple test comment");
        taskService.addComment(taskId, comment);
        
        comments = taskService.getAllCommentsByTaskId(taskId);
        assertNotNull(comments);
        assertEquals(1, comments.size());

        
        taskService.start(taskId, "Darth Vader");

        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        
        taskService.complete(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
    }
    
    @Test
    public void testNewTaskWithSingleInvalidPotentialOwner() {
        
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new Group('invalid')  ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";


        Task task = TaskFactory.evalTask(new StringReader(str));

        taskService.addTask(task, new HashMap<String, Object>());
        try {
	        String potOwner = "invalid";             
	        taskService.getTasksAssignedAsPotentialOwner(potOwner, "en-UK");
	        fail("Should fail due to same id for group and user");
        } catch (RuntimeException e) {
        	assertTrue(e.getMessage().endsWith("please check that there is no group and user with same id"));
        }
    }

    @Test
    public void testLongDescription() {
        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Task task = (Task) TaskFactory.evalTask(new StringReader(str));

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("a");
        }
        String comment = sb.toString();

        
        List<I18NText> descriptions = new ArrayList<I18NText>();
        I18NText descText = TaskModelProvider.getFactory().newI18NText();
        ((InternalI18NText) descText).setLanguage("en-UK");
        ((InternalI18NText) descText).setText(comment);
        descriptions.add(descText);
        ((InternalTask)task).setDescriptions(descriptions);

        taskService.addTask(task, new HashMap<String, Object>()); 

        long taskId = task.getId();

        Task resultTask = taskService.getTaskById(taskId);
        List<I18NText> resultDescriptions = resultTask.getDescriptions();

        InternalI18NText resultDescription = (InternalI18NText)resultDescriptions.get(0);

        assertEquals(1000, resultDescription.getText().length()); 

        
    }
    
    @Test
    public void testCompleteByActiveTasks() {
        

        
        String str = "(with (new Task()) { priority = 55, taskData = (with( new TaskData()) { activationTime = new Date(), processInstanceId = 123 } ), ";
        str += "peopleAssignments = (with ( new PeopleAssignments() ) { potentialOwners = [new User('Bobba Fet'), new User('Darth Vader') ],businessAdministrators = [ new User('Administrator') ], }),";
        str += "name = 'This is my task name' })";

        Date creationTime = new Date();
        
        Task task = (Task) TaskFactory.evalTask(new StringReader(str));
        taskService.addTask(task, new HashMap<String, Object>());


        long taskId = task.getId();
        assertNotNull(task.getTaskData().getActivationTime());

        
        taskService.start(taskId, "Darth Vader");
        
        List<TaskSummary> activeTasks = taskService.getActiveTasks();
        assertNotNull(activeTasks);
        assertEquals(1,  activeTasks.size());
        
        activeTasks = taskService.getActiveTasks(creationTime);
        assertNotNull(activeTasks);
        assertEquals(1,  activeTasks.size());


        Task task1 = taskService.getTaskById(taskId);
        assertEquals(Status.InProgress, task1.getTaskData().getStatus());
        assertEquals("Darth Vader", task1.getTaskData().getActualOwner().getId());

        

        taskService.complete(taskId, "Darth Vader", null);

        Task task2 = taskService.getTaskById(taskId);
        assertEquals(Status.Completed, task2.getTaskData().getStatus());
        assertEquals("Darth Vader", task2.getTaskData().getActualOwner().getId());
        
        List<TaskSummary> completedTasks = taskService.getCompletedTasks();
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        completedTasks = taskService.getCompletedTasks(creationTime);
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        completedTasks = taskService.getCompletedTasksByProcessId(123l);
        assertNotNull(completedTasks);
        assertEquals(1,  completedTasks.size());
        
        taskService.archiveTasks(completedTasks);
        
        List<TaskSummary> archiveddTasks = taskService.getArchivedTasks();
        assertNotNull(archiveddTasks);
        assertEquals(1,  archiveddTasks.size());
    }
}

<code block>


package org.jbpm.workflow.instance;

import java.util.HashMap;
import java.util.Map;

import org.drools.core.common.InternalKnowledgeRuntime;
import org.jbpm.ruleflow.core.RuleFlowProcess;
import org.jbpm.ruleflow.instance.RuleFlowProcessInstance;
import org.jbpm.workflow.core.impl.NodeImpl;
import org.jbpm.workflow.instance.impl.NodeInstanceImpl;
import org.jbpm.workflow.instance.impl.WorkflowProcessInstanceImpl;
import org.kie.api.definition.process.Node;
import org.kie.api.definition.process.NodeContainer;
import org.kie.api.definition.process.Process;
import org.kie.api.definition.process.WorkflowProcess;
import org.kie.api.runtime.KieRuntime;
import org.kie.api.runtime.process.NodeInstance;
import java.util.Stack;

public class WorkflowProcessInstanceUpgrader {

    public static void upgradeProcessInstance( KieRuntime kruntime, long processInstanceId, String processId,
            Map<String, Long> nodeMapping) {
        if (nodeMapping == null) {
            nodeMapping = new HashMap<String, Long>();
        }
        WorkflowProcessInstanceImpl processInstance = (WorkflowProcessInstanceImpl)
                kruntime.getProcessInstance(processInstanceId);
        if (processInstance == null) {
            throw new IllegalArgumentException("Could not find process instance " + processInstanceId);
        }
        if (processId == null) {
            throw new IllegalArgumentException("Null process id");
        }
        WorkflowProcess process = (WorkflowProcess)
                kruntime.getKieBase().getProcess(processId);
        if (process == null) {
            throw new IllegalArgumentException("Could not find process " + processId);
        }
        if (processInstance.getProcessId().equals(processId)) {
            return;
        }
        synchronized (processInstance) {
            org.kie.api.definition.process.Process oldProcess = processInstance.getProcess();
            processInstance.disconnect();
            processInstance.setProcess(oldProcess);
            updateNodeInstances(processInstance, nodeMapping);
            processInstance.setKnowledgeRuntime((InternalKnowledgeRuntime) kruntime);
            processInstance.setProcess(process);
            processInstance.reconnect();
        }
    }

    
    public static void upgradeProcessInstanceByNodeNames(
            KieRuntime kruntime,
            Long fromProcessId,
            String toProcessId,
            Map<String, String> nodeNamesMapping) {

        Map<String, Long> nodeIdMapping = new HashMap<String, Long>();

        String fromProcessIdString = kruntime.getProcessInstance(fromProcessId).getProcessId();
        Process processFrom = kruntime.getKieBase().getProcess(fromProcessIdString);
        Process processTo = kruntime.getKieBase().getProcess(toProcessId);

        for (Map.Entry<String, String> entry : nodeNamesMapping.entrySet()) {
            String from = null;
            Long to = null;

            if (processFrom instanceof WorkflowProcess) {
                from = getNodeId(((WorkflowProcess) processFrom).getNodes(), entry.getKey(), true);
            } else if (processFrom instanceof RuleFlowProcess) {
                from = getNodeId(((RuleFlowProcessInstance) processFrom).getWorkflowProcess().getNodes(), entry.getKey(), true);
            } else if (processFrom != null) {
                throw new IllegalArgumentException("Suported processes are WorkflowProcess and RuleFlowProcess, it was:" + processFrom.getClass());
            } else {
                throw new IllegalArgumentException("Can not find process with id: " + fromProcessIdString);
            }

            if (processTo instanceof WorkflowProcess) {
                to = Long.valueOf(getNodeId(((WorkflowProcess) processTo).getNodes(), entry.getValue(), false));
            } else if (processTo instanceof RuleFlowProcess) {
                to = Long.valueOf(getNodeId(((RuleFlowProcessInstance) processTo).getWorkflowProcess().getNodes(), entry.getValue(), false));
            } else if (processTo != null) {
                throw new IllegalArgumentException("Suported processes are WorkflowProcess and RuleFlowProcess, it was:" + processTo.getClass());
            } else {
                throw new IllegalArgumentException("Can not find process with id: " + toProcessId);
            }
            nodeIdMapping.put(from, to);
        }

        upgradeProcessInstance(kruntime, fromProcessId, toProcessId, nodeIdMapping);
    }

    private static String getNodeId(Node[] nodes, String nodeName, boolean unique) {

        Stack<Node> nodeStack = new Stack<Node>();
        for (Node node : nodes) {
            nodeStack.push(node);
        }

        Node match = null;
        while (!nodeStack.isEmpty()) {
            Node topNode = nodeStack.pop();

            if (topNode.getName().compareTo(nodeName) == 0) {
                match = topNode;
                break;
            }

            if (topNode instanceof NodeContainer) {
                for (Node node : ((NodeContainer) topNode).getNodes()) {
                    nodeStack.push(node);
                }
            }
        }

        if (match == null) {
            throw new IllegalArgumentException("No node with name " + nodeName);
        }

        String id = "";

        if (unique) {
            while (!(match.getNodeContainer() instanceof Process)) {
                id = ":" + match.getId() + id;
                match = (Node) match.getNodeContainer();
            }
        }

        id = match.getId() + id;

        return id;
    }

    private static void updateNodeInstances(NodeInstanceContainer nodeInstanceContainer, Map<String, Long> nodeMapping) {
        for (NodeInstance nodeInstance : nodeInstanceContainer.getNodeInstances()) {
            String oldNodeId = ((NodeImpl)
                    ((org.jbpm.workflow.instance.NodeInstance) nodeInstance).getNode()).getUniqueId();
            Long newNodeId = nodeMapping.get(oldNodeId);
            if (newNodeId == null) {
                newNodeId = nodeInstance.getNodeId();
            }

            
            Map<String, Integer> iterLevels = ((WorkflowProcessInstanceImpl) nodeInstance.getProcessInstance()).getIterationLevels();
            String uniqueId = (String) ((NodeImpl) nodeInstance.getNode()).getMetaData("UniqueId");
            iterLevels.remove(uniqueId);
            
            ((NodeInstanceImpl) nodeInstance).setNodeId(newNodeId);

            if (nodeInstance instanceof NodeInstanceContainer) {
                updateNodeInstances((NodeInstanceContainer) nodeInstance, nodeMapping);
            }
        }

    }

}

<code block>


package org.jbpm.workflow.core.node;

import java.util.HashMap;
import java.util.Map;

import org.kie.api.definition.process.Connection;
import org.jbpm.workflow.core.Constraint;
import org.jbpm.workflow.core.impl.ConnectionRef;

public class StateNode extends CompositeContextNode implements Constrainable {

	private static final long serialVersionUID = 510l;
	
    private Map<ConnectionRef, Constraint> constraints = new HashMap<ConnectionRef, Constraint>();
   
    public void setConstraints(Map<ConnectionRef, Constraint> constraints) {
        this.constraints = constraints;
    }

    public void setConstraint(final Connection connection, final Constraint constraint) {
		if (connection == null) {
			throw new IllegalArgumentException("connection is null");
		}
		if (!getDefaultOutgoingConnections().contains(connection)) {
			throw new IllegalArgumentException("connection is unknown:"	+ connection);
		}
		addConstraint(new ConnectionRef(
			connection.getTo().getId(), connection.getToType()), constraint);
	}

    public void addConstraint(ConnectionRef connectionRef, Constraint constraint) {
    	if (connectionRef == null) {
    		throw new IllegalArgumentException(
				"A state node only accepts constraints linked to a connection");
    	}
        constraints.put(connectionRef, constraint);
    }
    
    public Constraint getConstraint(String name){
        return constraints.get(name);
    }
    
    public Map<ConnectionRef, Constraint> getConstraints(){
        return constraints;
    }

    public Constraint getConstraint(final Connection connection) {
        if (connection == null) {
            throw new IllegalArgumentException("connection is null");
        }
        ConnectionRef ref = new ConnectionRef(connection.getTo().getId(), connection.getToType());
        return this.constraints.get(ref);
    }

}

<code block>

package org.jbpm.services.task.wih;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.drools.core.process.instance.impl.WorkItemImpl;
import org.jbpm.process.core.timer.DateTimeUtils;
import org.jbpm.services.task.events.DefaultTaskEventListener;
import org.jbpm.services.task.exception.PermissionDeniedException;
import org.jbpm.services.task.test.MyObject;
import org.jbpm.services.task.test.TestStatefulKnowledgeSession;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.jbpm.services.task.utils.OnErrorAction;
import org.jbpm.test.util.AbstractBaseTest;
import org.junit.Test;
import org.kie.api.runtime.process.WorkItemHandler;
import org.kie.api.runtime.process.WorkItemManager;
import org.kie.api.task.TaskEvent;
import org.kie.api.task.TaskLifeCycleEventListener;
import org.kie.api.task.TaskService;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.task.api.EventService;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.InternalTaskData;


public abstract class HTWorkItemHandlerBaseTest extends AbstractBaseTest {

    private static final int DEFAULT_WAIT_TIME = 5000;
    private static final int MANAGER_COMPLETION_WAIT_TIME = DEFAULT_WAIT_TIME;
    private static final int MANAGER_ABORT_WAIT_TIME = DEFAULT_WAIT_TIME;
    
    private WorkItemHandler handler;
    protected TestStatefulKnowledgeSession ksession;

    protected TaskService taskService; 
    
    
 
    @Test
    public void testTask() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Darth Vader", actualOwner);
        
    }
    @Test
    public void testTaskMultipleActors() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader, Dalai Lama");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Ready, task.getStatus());

        taskService.claim(task.getId(), "Darth Vader");

        taskService.start(task.getId(), "Darth Vader");

        taskService.complete(task.getId(), "Darth Vader", null);
        
        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskGroupActors() throws Exception {

    	TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Luke Cage", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Ready, taskSummary.getStatus());

        PermissionDeniedException denied = null;
        try {
            taskService.claim(taskSummary.getId(), "nocrusadaer");
        } catch (PermissionDeniedException e) {
            denied = e;
        }

        assertNotNull("Should get permissed denied exception", denied);

        
        
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(Status.Ready, task.getTaskData().getStatus());
    }
    
    
    @Test
    public void testTaskSingleAndGroupActors() throws Exception {




        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task One");
        workItem.setParameter("NodeName", "TaskNameOne");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
  

        workItem = new WorkItemImpl();
        workItem.setName("Human Task Two");
        workItem.setParameter("NodeName", "TaskNameTwo");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        getHandler().executeWorkItem(workItem, manager);
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(2, tasks.size());
    }
    @Test
    public void testTaskFail() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());

        taskService.start(task.getId(), "Darth Vader");
        
        taskService.fail(task.getId(), "Darth Vader", null);
        
        assertTrue(manager.waitTillAborted(MANAGER_ABORT_WAIT_TIME));
    }
    @Test
    public void testTaskSkip() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());

        taskService.skip(task.getId(), "Darth Vader");
        
        assertTrue(manager.waitTillAborted(MANAGER_ABORT_WAIT_TIME));
    }
    
    @Test
    public void testTaskExit() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
        
        Task task = taskService.getTaskByWorkItemId(workItem.getId());

        taskService.exit(task.getId(), "Administrator");
        
        task = taskService.getTaskByWorkItemId(workItem.getId());
        assertEquals("TaskName", task.getNames().get(0).getText());
        assertEquals(10, task.getPriority());
        assertEquals("Comment", task.getDescriptions().get(0).getText());
        assertEquals(Status.Exited, task.getTaskData().getStatus());
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskExitNonAdministrator() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
        
        Task task = taskService.getTaskByWorkItemId(workItem.getId());

        try {
            taskService.exit(task.getId(), "Darth Vader");
            fail("Should not allow to exit task for non administrators");
        } catch (PermissionDeniedException e) {
            
        }
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());
    }
    @Test
    public void testTaskAbortSkippable() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        

        getHandler().abortWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskAbortNotSkippable() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("Skippable", "false");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());

        getHandler().abortWorkItem(workItem, manager);

        
        tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskData() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("Content", "This is the content");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(AccessType.Inline, ((InternalTaskData) task.getTaskData()).getDocumentAccessType());
        assertEquals(task.getTaskData().getProcessSessionId(), TestStatefulKnowledgeSession.testSessionId.intValue());
        long contentId = task.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Object data = ContentMarshallerHelper.unmarshall(
                                                            taskService.getContentById(contentId).getContent(), 
                                                            ksession.getEnvironment());
        assertEquals("This is the content", data);

        taskService.start(task.getId(), "Darth Vader");
       
        Map<String, Object> results = new HashMap<String, Object>();
        results.put("Result", "This is the result");


        taskService.complete(task.getId(), "Darth Vader", results);
        
        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        results = manager.getResults();
        assertNotNull(results);
        assertEquals("Darth Vader", results.get("ActorId"));
        assertEquals("This is the result", results.get("Result"));
    }
    @Test
    public void testTaskDataAutomaticMapping() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        MyObject myObject = new MyObject("MyObjectValue");
        workItem.setParameter("MyObject", myObject);
        Map<String, Object> mapParameter = new HashMap<String, Object>();
        mapParameter.put("MyObjectInsideTheMap", myObject);
        workItem.setParameter("MyMap", mapParameter);
        workItem.setParameter("MyObject", myObject);
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

       

       
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());



        
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(AccessType.Inline, ((InternalTaskData) task.getTaskData()).getDocumentAccessType());
        long contentId = task.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);
        
        

        Map<String, Object> data = (Map<String, Object>) ContentMarshallerHelper.unmarshall(
                                                            taskService.getContentById(contentId).getContent(),  
                                                            ksession.getEnvironment());
      
        
        assertEquals("MyObjectValue", ((MyObject) data.get("MyObject")).getValue());
        assertEquals("10", data.get("Priority"));
        assertEquals("MyObjectValue", ((MyObject) ((Map<String, Object>) data.get("MyMap")).get
                ("MyObjectInsideTheMap")).getValue());

        taskService.start(task.getId(), "Darth Vader");

        Map<String, Object> results = new HashMap<String, Object>();
        results.put("Result", "This is the result");

                
        taskService.complete(task.getId(), "Darth Vader", results);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        results = manager.getResults();
        assertNotNull(results);
        assertEquals("Darth Vader", results.get("ActorId"));
        assertEquals("This is the result", results.get("Result"));
    }
    
    
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithLog() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.LOG);
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        
        handler.executeWorkItem(workItem, manager);
        assertFalse(manager.isAborted());
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithAbort() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.ABORT);
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        
        handler.executeWorkItem(workItem, manager);
        assertTrue(manager.isAborted());
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithRethrow() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.RETHROW);
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        try {
            handler.executeWorkItem(workItem, manager);
            fail("Should fail due to OnErroAction set to rethrow");
        } catch (Exception e) {
            
            
        }
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }

    
    @Test
    public void testTaskWithCreatedBy() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("CreatedBy", "john");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals("john", task.getCreatedBy().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWithoutCreatedBy() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals("Darth Vader", task.getCreatedBy().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWitAutoClaimTaskWithActorAndGroup() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("SwimlaneActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWithAutoClaimTaskWithGroupOnly() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setParameter("SwimlaneActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }

    @Test
    public void testTaskWithDueDate() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("DueDate", "2013-11-25T10:35:00Z");
        
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());
        
        assertEquals(DateTimeUtils.parseDateTime("2013-11-25T10:35:00Z"), task.getExpirationTime().getTime());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    @Test
    public void testTaskWithDelay() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("DueDate", "P2d"); 
        
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);
        long currentTime = new Date().getTime();
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());
        
        assertTrue(currentTime + DateTimeUtils.parseDuration("2d") > task.getExpirationTime().getTime());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskCompleteGroupActors() throws Exception {

    	TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Luke Cage", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Ready, taskSummary.getStatus());

        taskService.claim(taskSummary.getId(), "Luke Cage");
 
        taskService.start(taskSummary.getId(), "Luke Cage");
        taskService.complete(taskSummary.getId(), "Luke Cage", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Luke Cage", actualOwner);
    }
    
    @Test
    public void testTaskWithVariables() throws Exception {
        final TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        final String taskDescriptionParam =
                "Comment for task "
                    + "${task.id} "
                    + "${task.taskData.processSessionId} "
                    + "${task.taskData.actualOwner.id} "
                    + "${task.taskData.parentId}";
        handler.executeWorkItem(prepareWorkItemWithTaskVariables(taskDescriptionParam), manager);


        final List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        final Task task = taskService.getTaskById(tasks.get(0).getId());
        testTaskWithExpectedDescription(task,
                "Comment for task "
                        + task.getId() + " "
                        + task.getTaskData().getProcessSessionId() + " "
                        + task.getTaskData().getActualOwner().getId() + " "
                        + task.getTaskData().getParentId());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        final String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Darth Vader", actualOwner);
        
    }

    @Test(timeout = 10000)
    public void testTaskWithVariablesRecurse() {
        final TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        handler.executeWorkItem(prepareWorkItemWithTaskVariables("Comment for task ${task.description}"), manager);

        final List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        final Task task = taskService.getTaskById(tasks.get(0).getId());
        testTaskWithExpectedDescription(task, task.getDescription());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));

        final String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Darth Vader", actualOwner);
    }

    private WorkItemImpl prepareWorkItemWithTaskVariables(final String taskDescriptionParam) {
        final WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName ${task.taskData.processInstanceId}");
        workItem.setParameter("Comment", taskDescriptionParam);
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        return workItem;
    }

    private void testTaskWithExpectedDescription(final Task task, final String expectedDescription) {
        assertEquals("TaskName " + task.getTaskData().getProcessInstanceId(), task.getName());
        assertEquals(10, task.getPriority());
        assertEquals(expectedDescription, task.getDescription());
        assertEquals(Status.Reserved, task.getTaskData().getStatus());
        assertEquals("Darth Vader", task.getTaskData().getActualOwner().getId());
        assertEquals(10L, task.getTaskData().getProcessInstanceId());
    }

    public void setHandler(WorkItemHandler handler) {
        this.handler = handler;
    }

    public WorkItemHandler getHandler() {
        return handler;
    }

    private class TestWorkItemManager implements WorkItemManager {

        private volatile boolean completed;
        private volatile boolean aborted;
        private volatile Map<String, Object> results;

        public synchronized boolean waitTillCompleted(long time) {
            if (!isCompleted()) {
                try {
                    wait(time);
                } catch (InterruptedException e) {
                    
                }
            }

            return isCompleted();
        }

        public synchronized boolean waitTillAborted(long time) {
            if (!isAborted()) {
                try {
                    wait(time);
                } catch (InterruptedException e) {
                    
                }
            }

            return isAborted();
        }

        public void abortWorkItem(long id) {
            setAborted(true);
        }

        public synchronized boolean isAborted() {
            return aborted;
        }

        private synchronized void setAborted(boolean aborted) {
            this.aborted = aborted;
            notifyAll();
        }

        public void completeWorkItem(long id, Map<String, Object> results) {
            this.results = results;
            setCompleted(true);
        }

        private synchronized void setCompleted(boolean completed) {
            this.completed = completed;
            notifyAll();
        }

        public synchronized boolean isCompleted() {
            return completed;
        }

        public Map<String, Object> getResults() {
            return results;
        }

        public void registerWorkItemHandler(String workItemName, WorkItemHandler handler) {
        }
    }
    
    
    public static class AddedTaskListener extends DefaultTaskEventListener {
        public AddedTaskListener() {
            
        }
        
        public AddedTaskListener(boolean throwException) {
            this.throwException = throwException;
        }
        
        private boolean throwException = false;

        public boolean isThrowException() {
            return throwException;
        }

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }
        @Override
        public void afterTaskAddedEvent(TaskEvent event) {
            if (isThrowException()) {
                throw new RuntimeException("test exception");
            }
        }
    }
}

<code block>

package org.jbpm.services.task.wih;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.drools.core.process.instance.impl.WorkItemImpl;
import org.jbpm.process.core.timer.DateTimeUtils;
import org.jbpm.services.task.events.DefaultTaskEventListener;
import org.jbpm.services.task.exception.PermissionDeniedException;
import org.jbpm.services.task.test.MyObject;
import org.jbpm.services.task.test.TestStatefulKnowledgeSession;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.jbpm.services.task.utils.OnErrorAction;
import org.jbpm.test.util.AbstractBaseTest;
import org.junit.Test;
import org.kie.api.runtime.process.WorkItemHandler;
import org.kie.api.runtime.process.WorkItemManager;
import org.kie.api.task.TaskEvent;
import org.kie.api.task.TaskLifeCycleEventListener;
import org.kie.api.task.TaskService;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.task.api.EventService;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.InternalTaskData;


public abstract class HTWorkItemHandlerBaseTest extends AbstractBaseTest {

    private static final int DEFAULT_WAIT_TIME = 5000;
    private static final int MANAGER_COMPLETION_WAIT_TIME = DEFAULT_WAIT_TIME;
    private static final int MANAGER_ABORT_WAIT_TIME = DEFAULT_WAIT_TIME;
    
    private WorkItemHandler handler;
    protected TestStatefulKnowledgeSession ksession;

    protected TaskService taskService; 
    
    
 
    @Test
    public void testTask() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Darth Vader", actualOwner);
        
    }
    @Test
    public void testTaskMultipleActors() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader, Dalai Lama");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Ready, task.getStatus());

        taskService.claim(task.getId(), "Darth Vader");

        taskService.start(task.getId(), "Darth Vader");

        taskService.complete(task.getId(), "Darth Vader", null);
        
        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskGroupActors() throws Exception {

    	TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Luke Cage", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Ready, taskSummary.getStatus());

        PermissionDeniedException denied = null;
        try {
            taskService.claim(taskSummary.getId(), "nocrusadaer");
        } catch (PermissionDeniedException e) {
            denied = e;
        }

        assertNotNull("Should get permissed denied exception", denied);

        
        
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(Status.Ready, task.getTaskData().getStatus());
    }
    
    
    @Test
    public void testTaskSingleAndGroupActors() throws Exception {




        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task One");
        workItem.setParameter("NodeName", "TaskNameOne");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
  

        workItem = new WorkItemImpl();
        workItem.setName("Human Task Two");
        workItem.setParameter("NodeName", "TaskNameTwo");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        getHandler().executeWorkItem(workItem, manager);
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(2, tasks.size());
    }
    @Test
    public void testTaskFail() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());

        taskService.start(task.getId(), "Darth Vader");
        
        taskService.fail(task.getId(), "Darth Vader", null);
        
        assertTrue(manager.waitTillAborted(MANAGER_ABORT_WAIT_TIME));
    }
    @Test
    public void testTaskSkip() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());

        taskService.skip(task.getId(), "Darth Vader");
        
        assertTrue(manager.waitTillAborted(MANAGER_ABORT_WAIT_TIME));
    }
    
    @Test
    public void testTaskExit() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
        
        Task task = taskService.getTaskByWorkItemId(workItem.getId());

        taskService.exit(task.getId(), "Administrator");
        
        task = taskService.getTaskByWorkItemId(workItem.getId());
        assertEquals("TaskName", task.getNames().get(0).getText());
        assertEquals(10, task.getPriority());
        assertEquals("Comment", task.getDescriptions().get(0).getText());
        assertEquals(Status.Exited, task.getTaskData().getStatus());
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskExitNonAdministrator() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);
        
        Task task = taskService.getTaskByWorkItemId(workItem.getId());

        try {
            taskService.exit(task.getId(), "Darth Vader");
            fail("Should not allow to exit task for non administrators");
        } catch (PermissionDeniedException e) {
            
        }
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());
    }
    @Test
    public void testTaskAbortSkippable() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        

        getHandler().abortWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskAbortNotSkippable() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("Skippable", "false");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());

        getHandler().abortWorkItem(workItem, manager);

        
        tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(0, tasks.size());
    }
    @Test
    public void testTaskData() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("Content", "This is the content");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(AccessType.Inline, ((InternalTaskData) task.getTaskData()).getDocumentAccessType());
        assertEquals(task.getTaskData().getProcessSessionId(), TestStatefulKnowledgeSession.testSessionId.intValue());
        long contentId = task.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);

        Object data = ContentMarshallerHelper.unmarshall(
                                                            taskService.getContentById(contentId).getContent(), 
                                                            ksession.getEnvironment());
        assertEquals("This is the content", data);

        taskService.start(task.getId(), "Darth Vader");
       
        Map<String, Object> results = new HashMap<String, Object>();
        results.put("Result", "This is the result");


        taskService.complete(task.getId(), "Darth Vader", results);
        
        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        results = manager.getResults();
        assertNotNull(results);
        assertEquals("Darth Vader", results.get("ActorId"));
        assertEquals("This is the result", results.get("Result"));
    }
    @Test
    public void testTaskDataAutomaticMapping() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        MyObject myObject = new MyObject("MyObjectValue");
        workItem.setParameter("MyObject", myObject);
        Map<String, Object> mapParameter = new HashMap<String, Object>();
        mapParameter.put("MyObjectInsideTheMap", myObject);
        workItem.setParameter("MyMap", mapParameter);
        workItem.setParameter("MyObject", myObject);
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

       

       
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Reserved, taskSummary.getStatus());
        assertEquals("Darth Vader", taskSummary.getActualOwner().getId());



        
        
        Task task = taskService.getTaskById(taskSummary.getId());
        assertEquals(AccessType.Inline, ((InternalTaskData) task.getTaskData()).getDocumentAccessType());
        long contentId = task.getTaskData().getDocumentContentId();
        assertTrue(contentId != -1);
        
        

        Map<String, Object> data = (Map<String, Object>) ContentMarshallerHelper.unmarshall(
                                                            taskService.getContentById(contentId).getContent(),  
                                                            ksession.getEnvironment());
      
        
        assertEquals("MyObjectValue", ((MyObject) data.get("MyObject")).getValue());
        assertEquals("10", data.get("Priority"));
        assertEquals("MyObjectValue", ((MyObject) ((Map<String, Object>) data.get("MyMap")).get("MyObjectInsideTheMap")).getValue());

        taskService.start(task.getId(), "Darth Vader");

        Map<String, Object> results = new HashMap<String, Object>();
        results.put("Result", "This is the result");

                
        taskService.complete(task.getId(), "Darth Vader", results);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        results = manager.getResults();
        assertNotNull(results);
        assertEquals("Darth Vader", results.get("ActorId"));
        assertEquals("This is the result", results.get("Result"));
    }
    
    
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithLog() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.LOG);
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        
        handler.executeWorkItem(workItem, manager);
        assertFalse(manager.isAborted());
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithAbort() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.ABORT);
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        
        handler.executeWorkItem(workItem, manager);
        assertTrue(manager.isAborted());
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }
    @SuppressWarnings("unchecked")
	@Test
    public void testTaskCreateFailedWithRethrow() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        TaskLifeCycleEventListener listener = new AddedTaskListener(true);
        ((EventService<TaskLifeCycleEventListener>) taskService).registerTaskEventListener(listener);
        
        ((AbstractHTWorkItemHandler)handler).setAction(OnErrorAction.RETHROW);
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "DoesNotExist");
        workItem.setProcessInstanceId(10);
        
        try {
            handler.executeWorkItem(workItem, manager);
            fail("Should fail due to OnErroAction set to rethrow");
        } catch (Exception e) {
            
            
        }
        ((EventService<TaskLifeCycleEventListener>) taskService).removeTaskEventListener(listener);
    }

    
    @Test
    public void testTaskWithCreatedBy() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("CreatedBy", "john");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals("john", task.getCreatedBy().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWithoutCreatedBy() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals("Darth Vader", task.getCreatedBy().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWitAutoClaimTaskWithActorAndGroup() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("SwimlaneActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskWithAutoClaimTaskWithGroupOnly() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setParameter("SwimlaneActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }

    @Test
    public void testTaskWithDueDate() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("DueDate", "2013-11-25T10:35:00Z");
        
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());
        
        assertEquals(DateTimeUtils.parseDateTime("2013-11-25T10:35:00Z"), task.getExpirationTime().getTime());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    @Test
    public void testTaskWithDelay() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setParameter("DueDate", "P2d"); 
        
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);
        long currentTime = new Date().getTime();
        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName", task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment", task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());
        
        assertTrue( currentTime + DateTimeUtils.parseDuration("2d") > task.getExpirationTime().getTime());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
    }
    
    @Test
    public void testTaskCompleteGroupActors() throws Exception {

    	TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName");
        workItem.setParameter("Comment", "Comment");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("GroupId", "Crusaders");
        workItem.setProcessInstanceId(10);
        getHandler().executeWorkItem(workItem, manager);

        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Luke Cage", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary taskSummary = tasks.get(0);
        assertEquals("TaskName", taskSummary.getName());
        assertEquals(10, taskSummary.getPriority().intValue());
        assertEquals("Comment", taskSummary.getDescription());
        assertEquals(Status.Ready, taskSummary.getStatus());

        taskService.claim(taskSummary.getId(), "Luke Cage");
 
        taskService.start(taskSummary.getId(), "Luke Cage");
        taskService.complete(taskSummary.getId(), "Luke Cage", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Luke Cage", actualOwner);
    }
    
    @Test
    public void testTaskWithVariables() throws Exception {
        TestWorkItemManager manager = new TestWorkItemManager();
        ksession.setWorkItemManager(manager);
        WorkItemImpl workItem = new WorkItemImpl();
        workItem.setName("Human Task");
        workItem.setParameter("NodeName", "TaskName ${task.taskData.processInstanceId}");
        workItem.setParameter("Comment", "Comment for task ${task.id}");
        workItem.setParameter("Priority", "10");
        workItem.setParameter("ActorId", "Darth Vader");
        workItem.setProcessInstanceId(10);
        handler.executeWorkItem(workItem, manager);

        
        List<TaskSummary> tasks = taskService.getTasksAssignedAsPotentialOwner("Darth Vader", "en-UK");
        assertEquals(1, tasks.size());
        TaskSummary task = tasks.get(0);
        assertEquals("TaskName " + task.getProcessInstanceId(), task.getName());
        assertEquals(10, task.getPriority().intValue());
        assertEquals("Comment for task " + task.getId(), task.getDescription());
        assertEquals(Status.Reserved, task.getStatus());
        assertEquals("Darth Vader", task.getActualOwner().getId());
        assertEquals(10, task.getProcessInstanceId().intValue());

        taskService.start(task.getId(), "Darth Vader");
        taskService.complete(task.getId(), "Darth Vader", null);

        assertTrue(manager.waitTillCompleted(MANAGER_COMPLETION_WAIT_TIME));
        
        String actualOwner = (String) manager.getResults().get("ActorId");
        assertNotNull(actualOwner);
        assertEquals("Darth Vader", actualOwner);
        
    }
    
    public void setHandler(WorkItemHandler handler) {
        this.handler = handler;
    }

    public WorkItemHandler getHandler() {
        return handler;
    }

    private class TestWorkItemManager implements WorkItemManager {

        private volatile boolean completed;
        private volatile boolean aborted;
        private volatile Map<String, Object> results;

        public synchronized boolean waitTillCompleted(long time) {
            if (!isCompleted()) {
                try {
                    wait(time);
                } catch (InterruptedException e) {
                    
                }
            }

            return isCompleted();
        }

        public synchronized boolean waitTillAborted(long time) {
            if (!isAborted()) {
                try {
                    wait(time);
                } catch (InterruptedException e) {
                    
                }
            }

            return isAborted();
        }

        public void abortWorkItem(long id) {
            setAborted(true);
        }

        public synchronized boolean isAborted() {
            return aborted;
        }

        private synchronized void setAborted(boolean aborted) {
            this.aborted = aborted;
            notifyAll();
        }

        public void completeWorkItem(long id, Map<String, Object> results) {
            this.results = results;
            setCompleted(true);
        }

        private synchronized void setCompleted(boolean completed) {
            this.completed = completed;
            notifyAll();
        }

        public synchronized boolean isCompleted() {
            return completed;
        }

        public Map<String, Object> getResults() {
            return results;
        }

        public void registerWorkItemHandler(String workItemName, WorkItemHandler handler) {
        }
    }
    
    
    public static class AddedTaskListener extends DefaultTaskEventListener {
        public AddedTaskListener() {
            
        }
        
        public AddedTaskListener(boolean throwException) {
            this.throwException = throwException;
        }
        
        private boolean throwException = false;

        public boolean isThrowException() {
            return throwException;
        }

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }
        @Override
        public void afterTaskAddedEvent(TaskEvent event) {
            if (isThrowException()) {
                throw new RuntimeException("test exception");
            }
        }
    }
}

<code block>
package org.jbpm.query.jpa.data;

import java.lang.reflect.Field;
import java.util.Map;
import java.util.TreeMap;

import org.kie.internal.query.QueryParameterIdentifiers;

public class QueryParameterIdentifiersUtil {

    public static Map<Integer, String> getQueryParameterIdNameMap() { 
        Field [] fields = QueryParameterIdentifiers.class.getDeclaredFields();
        Map<Integer, String> idMap = new TreeMap<Integer, String>();
        for( Field field : fields ) { 
            Object objVal;
            try { 
                objVal = field.get(null);
            } catch( Exception e ) { 
                throw new IllegalStateException("Unable to get static value from field " 
                        + QueryParameterIdentifiers.class.getName() + "." + field.getName());
            }
            if( ! (objVal instanceof String) ) { 
               continue; 
            }
            String val = (String) objVal;
            Integer idVal;
            try { 
               idVal = Integer.valueOf(val);
            } catch( Exception e ) { 
                continue;
            }
           idMap.put(idVal, field.getName());
        }
        return idMap;
    }
}

<code block>


package org.jbpm.query.jpa.data;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import javax.persistence.criteria.Predicate;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlRootElement;

import org.codehaus.jackson.annotate.JsonAutoDetect;
import org.codehaus.jackson.annotate.JsonAutoDetect.Visibility;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.annotate.JsonIgnoreProperties;


@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)

@JsonIgnoreProperties({"union","type",  
                       "currentGroupCriteria", "ancestry", "currentParent",
                       "addedJoins"})
@JsonAutoDetect(fieldVisibility=Visibility.ANY,
                getterVisibility=Visibility.NONE,
                setterVisibility=Visibility.NONE, 
                isGetterVisibility=Visibility.NONE)

public class QueryWhere {

    @XmlEnum
    public static enum QueryCriteriaType { 
        @XmlEnumValue("N") NORMAL,
        @XmlEnumValue("L") REGEXP, 
        @XmlEnumValue("R") RANGE, 
        @XmlEnumValue("R") GROUP, 
    }

    @XmlElement(name="queryCriteria")
    private List<QueryCriteria> criteria = new LinkedList<QueryCriteria>();

    @XmlElement
    private Boolean ascOrDesc = null;

    @XmlElement
    private String orderByListId = null;

    @XmlElement
    private Integer maxResults = null;

    @XmlElement
    private Integer offset = null;

    @JsonIgnore
    private transient boolean union = true;

    @JsonIgnore
    private transient QueryCriteriaType type = QueryCriteriaType.NORMAL;

    @JsonIgnore
    private transient List<QueryCriteria> currentCriteria = criteria;
    
    @JsonIgnore
    private transient Stack<Object> ancestry = new Stack<Object>();
    
    @JsonIgnore
    private transient Object currentParent = this;
   
    @JsonIgnore
    private transient Map<String, Predicate> joinPredicates = null;
    
    public QueryWhere() { 
        
    }
    
    
   
    
    public <T> QueryCriteria addParameter( String listId, T... param ) {
        if( param.length == 0 ) {
            return null;
        }
        if( QueryCriteriaType.REGEXP.equals(this.type) && ! (param[0] instanceof String) ) { 
            throw new IllegalArgumentException("Only String parameters may be used in regular expressions.");
        }
        QueryCriteria criteria =  new QueryCriteria(listId, this.union, this.type, param.length);
        for( T paramElem : param ) { 
           criteria.addParameter(paramElem); 
        }
        addCriteria(criteria);
        return criteria;
    }

    public <T> void addRangeParameter( String listId, T param, boolean start ) {
        QueryCriteriaType origType = this.type;
        this.type = QueryCriteriaType.RANGE;
        
        QueryCriteria criteria =  new QueryCriteria(listId, this.union, this.type, 2);
        int index = start ? 0 : 1;
        criteria.setParameter(index, param, 2);
        addCriteria(criteria);
        this.type = origType;
    }
 
    public <T> void addRangeParameters( String listId, T paramMin, T paramMax ) {
        QueryCriteriaType origType = this.type;
        this.type = QueryCriteriaType.RANGE;
        
        QueryCriteria criteria =  new QueryCriteria(listId, this.union, this.type, 2);
        criteria.addParameter(paramMin);
        criteria.addParameter(paramMax);
        addCriteria(criteria);
        this.type = origType;
    } 
        
    private void addCriteria(QueryCriteria criteria) { 
        if( this.currentCriteria.isEmpty() ) {  
            criteria.setFirst(true); 
        } else if( this.currentCriteria.size() == 1 ) { 
           this.currentCriteria.get(0).setUnion(criteria.isUnion()); 
        }
        this.currentCriteria.add(criteria);
    }
    
    
    
    public void newGroup() { 
        
        QueryCriteria newCriteriaGroupParent = new QueryCriteria(this.union);
        addCriteria(newCriteriaGroupParent);
        
        
        ancestry.push(currentParent);
        currentParent = newCriteriaGroupParent;
        
        
        currentCriteria = newCriteriaGroupParent.getCriteria();
    }

    public void endGroup() { 
       if( ancestry.isEmpty() ) { 
           throw new IllegalStateException("Can not end group: no group has been started!");
       }
       
       Object grandparent = ancestry.pop();
       if( grandparent instanceof QueryWhere ) {
           currentCriteria = ((QueryWhere) grandparent).getCriteria();
       } else { 
           currentCriteria = ((QueryCriteria) grandparent).getCriteria();
       }
       currentParent = grandparent;
    }

    @JsonIgnore
    public void setAscending( String listId ) {
        this.ascOrDesc = true;
        this.orderByListId = listId;
    }

    @JsonIgnore
    public void setDescending( String listId ) {
        this.ascOrDesc = false;
        this.orderByListId = listId;
    }

    public List<QueryCriteria> getCurrentCriteria() {
        return currentCriteria;
    }

    
    
  
    public List<QueryCriteria> getCriteria() {
        return criteria;
    }

    public void setCriteria(List<QueryCriteria> criteria) {
        this.criteria = criteria;
    }

    public void setParameters( List<QueryCriteria> parameters ) {
        this.criteria = parameters;
    }
    
    public void setAscOrDesc( Boolean ascendingOrDescending ) {
        this.ascOrDesc = ascendingOrDescending;
    }

    public Boolean getAscOrDesc() {
        return this.ascOrDesc;
    }
    
    public void setOrderByListId( String listId ) {
        this.orderByListId = listId;
    }

    public String getOrderByListId() {
        return this.orderByListId;
    }
    
    public void setCount( Integer maxResults ) {
        this.maxResults = maxResults;
    }

    public Integer getCount() { 
        return this.maxResults;
    }

    public void setOffset( Integer offset ) {
        this.offset = offset;
    }

    public Integer getOffset() {
        return this.offset;
    }

    public QueryCriteriaType getCriteriaType() { 
       return this.type;
    } 
       
    public void setToUnion() {
        this.union = true;
    }
    
    public void setToIntersection() {
        this.union = false;
    }

    public boolean isUnion() { 
       return this.union;
    }

    public void setToLike() {
        this.type = QueryCriteriaType.REGEXP;
    }

    public boolean isLike() {
        return this.type.equals(QueryCriteriaType.REGEXP);
    }

    public void setToNormal() {
        this.type = QueryCriteriaType.NORMAL;
    }

    public void setToRange() {
        this.type = QueryCriteriaType.RANGE;
    }

    public boolean isRange() {
        return this.type.equals(QueryCriteriaType.RANGE);
    }
  
    public void setToGroup() {
        this.type = QueryCriteriaType.GROUP;
    }
    
    public Map<String, Predicate> getJoinPredicates() { 
        if( this.joinPredicates == null ) { 
          this.joinPredicates = new HashMap<String, Predicate>(3);  
        }
        return this.joinPredicates;
    }
    
    

    public void clear() { 
        this.union = true;
        this.type = QueryCriteriaType.NORMAL;
        this.ancestry.clear();
        if( this.criteria != null ) { 
            this.criteria.clear();
        }
        this.currentCriteria = this.criteria;
        
        this.maxResults = null;
        this.offset = null;
        this.orderByListId = null;
        this.ascOrDesc = null;
        
       this.joinPredicates = null;
    }
    
    public QueryWhere(QueryWhere queryWhere) { 
       this.union = queryWhere.union;
       this.type = queryWhere.type;
       if( queryWhere.criteria != null )  {
           this.criteria = new LinkedList<QueryCriteria>(queryWhere.criteria);
       }
       this.ascOrDesc = queryWhere.ascOrDesc;
       this.orderByListId = queryWhere.orderByListId;
       this.maxResults = queryWhere.maxResults;
       this.offset = queryWhere.offset;
       
       this.joinPredicates = queryWhere.joinPredicates;
    }

    
}
<code block>


package org.jbpm.query.jpa.data;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.annotate.JsonIgnoreProperties;
import org.codehaus.jackson.annotate.JsonTypeInfo;
import org.codehaus.jackson.annotate.JsonTypeInfo.As;
import org.codehaus.jackson.annotate.JsonTypeInfo.Id;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.kie.internal.query.QueryParameterIdentifiers;


@XmlRootElement
@XmlType
@XmlAccessorType(XmlAccessType.FIELD)
@JsonIgnoreProperties(value="parameters")
public class QueryCriteria {

    @XmlAttribute
    private String listId;
    
    @XmlAttribute
    private boolean union = true;
   
    @XmlAttribute
    private boolean first = false;
    
    @XmlAttribute
    private QueryCriteriaType type = QueryCriteriaType.NORMAL;
    
    @XmlElement(name="parameter")
    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property="class")
    private List<Object> values;
   
    @XmlElement(name="date-parameter")
    private List<Date> dateValues;
    
    @XmlElement
    private List<QueryCriteria> criteria;
    
    public QueryCriteria() { 
        
    }
   
    
    public QueryCriteria(boolean union) { 
        this.union = union;
        this.type = QueryCriteriaType.GROUP;
    }
    
    private QueryCriteria(String listId, QueryCriteriaType type) { 
        this.listId = listId;
        this.type = type;
    }
   
    
    public QueryCriteria(String listId, boolean union, QueryCriteriaType type, int valueListSize) { 
        this(listId, type);
        this.union = union;
        this.values = new ArrayList<Object>(valueListSize);
    }
    
    public String getListId() {
        return listId;
    }

    public void setListId( String listId ) {
        this.listId = listId;
    }

    public boolean isUnion() {
        return union;
    }

    public void setUnion( boolean union ) {
        this.union = union;
    }

    public boolean isFirst() {
        return first;
    }

    public void setFirst( boolean first ) {
        this.first = first;
    }

    
    public QueryCriteriaType getType() {
        return type;
    }

    public void setType( QueryCriteriaType type ) {
        this.type = type;
    }

    public List<Object> getValues() {
        if( this.values == null ) { 
            this.values = new ArrayList<Object>();
        }
        return values;
    }
    
    public void setValues( List<Object> values ) {
        this.values = values;
    }
   
    public List<Date> getDateValues() {
        if( this.dateValues == null ) { 
            this.dateValues = new ArrayList<Date>();
        }
        return dateValues;
    }
    
    public void setDateValues( List<Date> dateValues ) {
        this.dateValues = dateValues;
    }
    
    
    

    @JsonIgnore
    public boolean isGroupCriteria() { 
        return this.type.equals(QueryCriteriaType.GROUP);
    }
    
    @JsonIgnore
    public boolean hasValues() { 
        return ( this.values != null && ! this.values.isEmpty() );
    }
    
    @JsonIgnore
    public boolean hasDateValues() { 
        return ( this.dateValues != null && ! this.dateValues.isEmpty() );
    }
   
    @JsonIgnore
    public boolean hasCriteria() {
        return ( this.criteria != null && ! this.criteria.isEmpty() );
    }
    
    public List<QueryCriteria> getCriteria() {
        if( this.criteria == null ) { 
            this.criteria = new ArrayList<QueryCriteria>();
        }
        return criteria;
    }
    
    public void setCriteria( List<QueryCriteria> criteria ) {
        this.criteria = criteria;
    }

    
    public List<Object> getParameters() {
        List<Object> parameters = new ArrayList<Object>(getValues());
        if( this.dateValues != null && ! this.dateValues.isEmpty() ) { 
           parameters.addAll(this.dateValues);
        }
        if( parameters.isEmpty() ) { 
            return parameters;
        }
        return parameters;
    }
    
    void addParameter( Object value ) { 
        if( value instanceof Date ) { 
            getDateValues().add((Date) value);
        } else { 
            getValues().add(value);
        }
    }

    @SuppressWarnings("unchecked")
    void setParameter( int index, Object value, int listSize ) { 
        List addValues;
        if( value instanceof Date ) { 
           addValues = getDateValues(); 
        } else { 
            addValues = getValues();
        }
        while( addValues.size() <= index ) { 
           addValues.add(null); 
        }
        addValues.set(index, value); 
        while( addValues.size() < listSize ) { 
           addValues.add(null); 
        }
    }

    public void addCriteria( QueryCriteria criteria ) { 
       getCriteria().add(criteria);
    }

    public QueryCriteria(QueryCriteria queryCriteria) { 
        this.listId = queryCriteria.listId;
        this.union = queryCriteria.union;
        this.first = queryCriteria.first;
        this.type = queryCriteria.type;
        if( queryCriteria.values != null ) { 
            this.values = new ArrayList<Object>(queryCriteria.values);
        }
        if( queryCriteria.dateValues != null ) { 
            this.dateValues = new ArrayList<Date>(queryCriteria.dateValues);
        }
        if( queryCriteria.criteria != null ) { 
            this.criteria = new ArrayList<QueryCriteria>(queryCriteria.criteria);
        }
    }
  
    private static SimpleDateFormat toStringSdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    
    @Override
    public String toString() { 
       StringBuilder out = new StringBuilder();
       if( ! first ) { 
           out.append(union ? "OR" : "AND").append(" ");
       }
       if( listId != null ) { 
           out.append(listId);
       }
       if( this.values != null && ! this.values.isEmpty() ) { 
           out.append(" =");
           if( type.equals(QueryCriteriaType.REGEXP) ) { 
               out.append("~");
           } 
           out.append(" ");
           if ( type.equals(QueryCriteriaType.RANGE) ) { 
               out.append("[");
           }
           out.append(this.values.get(0));
           for( int i = 1; i < this.values.size(); ++i ) { 
               out.append(", ") .append(this.values.get(i));
           }
           if ( type.equals(QueryCriteriaType.RANGE) ) { 
               out.append("]");
           }
       } else if( this.dateValues != null && ! this.dateValues.isEmpty() ) { 
           out.append(" =");
           if( type.equals(QueryCriteriaType.REGEXP) ) { 
               out.append("~");
           } 
           out.append(" ");
           if ( type.equals(QueryCriteriaType.RANGE) ) { 
               out.append("[");
           }
           Date date = this.dateValues.get(0);
           String dateStr = date != null ? toStringSdf.format(date) : "null";
           out.append(dateStr);
           for( int i = 1; i < this.dateValues.size(); ++i ) { 
               date = this.dateValues.get(i);
               dateStr = date != null ? toStringSdf.format(date) : "null";
               out.append(", ") .append(dateStr);
           }
           if ( type.equals(QueryCriteriaType.RANGE) ) { 
               out.append("]");
           }
       } 
       if( criteria != null ) { 
           if( out.length() > 0 ) { 
               out.append(" ");
           }
           out.append("(");
           int size = criteria.size();
           if( size > 0 ) { 
               out.append(criteria.get(0).toString());
           }
           for( int i = 1; i < size; ++i ) { 
               out.append(", ");
               out.append(criteria.get(i).toString());
           }
           out.append(")");
       }
       return out.toString();
    }
}

<code block>
package org.jbpm.query.jpa.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.From;
import javax.persistence.criteria.Order;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.Attribute;
import javax.persistence.metamodel.PluralAttribute;
import javax.persistence.metamodel.SingularAttribute;

import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.kie.api.runtime.manager.audit.VariableInstanceLog;
import org.kie.internal.query.QueryParameterIdentifiers;

public abstract class QueryCriteriaUtil {
    
    private final Map<Class, Map<String, Attribute>> criteriaAttributes;
    private final AtomicBoolean criteriaAttributesInitialized = new AtomicBoolean(false);

    public QueryCriteriaUtil(Map<Class, Map<String, Attribute>> criteriaAttributes) { 
       this.criteriaAttributes = criteriaAttributes; 
    }
 
    protected Map<Class, Map<String, Attribute>> getCriteriaAttributes() { 
        if( ! criteriaAttributesInitialized.get() ) { 
           if( initializeCriteriaAttributes() ) { 
               criteriaAttributesInitialized.set(true);
           }  else { 
               throw new IllegalStateException("Queries can not be performed if no persistence unit has been initalized!");
           }
        }
        return criteriaAttributes;
    }
    
    
    
    @SuppressWarnings("unchecked")
    public static <C,I> List<I> convertListToInterfaceList( List<C>internalResult, Class<I> interfaceType ) {
        List<I> result = new ArrayList<I>(internalResult.size());
        for( C element : internalResult ) { 
           result.add((I) element);
        }
        return result;
    }

    
    
    public static void addCriteria( Map<Class, Map<String, Attribute>> criteriaAttributes, String listId, Attribute attr ) {
        Class table = attr.getJavaMember().getDeclaringClass();
        addCriteria(criteriaAttributes, listId, table, attr);
    }
    
    public static void addCriteria( Map<Class, Map<String, Attribute>> criteriaAttributes, String listId, Class table, Attribute attr ) {
        Map<String, Attribute> tableAttrs = criteriaAttributes.get(table);
        if( tableAttrs == null ) {
            tableAttrs = new ConcurrentHashMap<String, Attribute>(1);
            criteriaAttributes.put(table, tableAttrs);
        }
        Attribute previousMapping = tableAttrs.put(listId, attr);
        assert previousMapping == null : "Previous mapping existed for [" + listId + "]!";
    }

    
   
    
    protected abstract boolean initializeCriteriaAttributes();

    protected abstract CriteriaBuilder getCriteriaBuilder();
  
    
    
    
    
    
    public <T> List<T> doCriteriaQuery( QueryWhere queryWhere, Class<T> queryType ) {
        
        CriteriaBuilder builder = getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = builder.createQuery(queryType);
        
        
        criteriaQuery.select(criteriaQuery.from(queryType));
    
        fillCriteriaQuery(criteriaQuery, queryWhere, builder, queryType);
    
        List<T> result = createQueryAndCallApplyMetaCriteriaAndGetResult(queryWhere, criteriaQuery, builder);
    
        return result;
    }

    
    
    
    protected <R,T> void fillCriteriaQuery( CriteriaQuery<R> query, QueryWhere queryWhere, CriteriaBuilder builder, Class<T> queryType ) {
    
        Predicate queryPredicate = createPredicateFromCriteriaList(query, builder, queryType, queryWhere.getCriteria(), queryWhere );
        
        if( queryPredicate != null ) { 
            query.where(queryPredicate);
        }
                
        if( queryWhere.getAscOrDesc() != null ) { 
            String orderByListId = queryWhere.getOrderByListId();
            assert orderByListId != null : "Ascending boolean is set but no order by list Id has been specified!";
            Expression orderByPath = getOrderByExpression(query, queryType, orderByListId);
            Order order;
            if( queryWhere.getAscOrDesc() ) { 
               order = builder.asc(orderByPath);
            } else { 
               order = builder.desc(orderByPath);
            }
            query.orderBy(order);
        }
    }

    
    private <R,T> Predicate createPredicateFromCriteriaList(
            CriteriaQuery<R> query, CriteriaBuilder builder, 
            Class<T> resultType, 
            List<QueryCriteria> inputCriteriaList,  QueryWhere queryWhere ) {
        Predicate queryPredicate = null;
        if( inputCriteriaList.size() > 1 ) { 
            
            List<Predicate> predicateList = new LinkedList<Predicate>();
            QueryCriteria previousCriteria = null;
            QueryCriteria firstCriteria = null;
            List<QueryCriteria> currentIntersectingCriteriaList = new LinkedList<QueryCriteria>();
           
            int i = 0;
            for( QueryCriteria criteria : inputCriteriaList ) {
                assert i++ != 0 || criteria.isFirst() : "First criteria is not flagged as first!";
                
                if( criteria.isFirst() ) { 
                   firstCriteria = previousCriteria = criteria;
                   continue;
                } else if( firstCriteria != null ) { 
                    if( criteria.isUnion() ) { 
                       Predicate predicate = createPredicateFromSingleOrGroupCriteria(query, builder, resultType, previousCriteria, queryWhere);
                       predicateList.add(predicate);
                    } else { 
                        currentIntersectingCriteriaList.add(firstCriteria);
                    }
                    firstCriteria = null;
                }
                
                if( criteria.isUnion() ) { 
                    
                    
                    
                    if( previousCriteria != null && ! previousCriteria.isUnion() && ! currentIntersectingCriteriaList.isEmpty() ) { 
                        Predicate predicate 
                            = createPredicateFromIntersectingCriteriaList(query, builder, resultType, currentIntersectingCriteriaList, queryWhere );
                        assert predicate != null : "Null predicate when evaluating intersecting criteria [" + criteria.toString() + "]";
                        predicateList.add(predicate);
                        
                        
                        currentIntersectingCriteriaList = new LinkedList<QueryCriteria>();
                    }
                    
                    
                    Predicate predicate = createPredicateFromSingleOrGroupCriteria(query, builder, resultType, criteria, queryWhere);
                    assert predicate != null : "Null predicate when evaluating union criteria [" + criteria.toString() + "]";
                    predicateList.add(predicate);
                } else { 
                    currentIntersectingCriteriaList.add(criteria);
                }
    
                previousCriteria = criteria; 
            }
    
            if( ! currentIntersectingCriteriaList.isEmpty() ) { 
                Predicate predicate 
                    = createPredicateFromIntersectingCriteriaList(query, builder, resultType, currentIntersectingCriteriaList, queryWhere );
                predicateList.add(predicate);
            }
            
            assert ! predicateList.isEmpty() : "The predicate list should not (can not?) be empty here!";
            if( predicateList.size() == 1 ) { 
                queryPredicate = predicateList.get(0);
            } else { 
                Predicate [] predicates = predicateList.toArray(new Predicate[predicateList.size()]);
                queryPredicate = builder.or(predicates);
            }
        } else if( inputCriteriaList.size() == 1 ) { 
            QueryCriteria singleCriteria = inputCriteriaList.get(0);
            queryPredicate = createPredicateFromSingleOrGroupCriteria(query, builder, resultType, singleCriteria, queryWhere);
        }
    
        return queryPredicate;
    }

    
    private <R,T> Predicate createPredicateFromIntersectingCriteriaList(CriteriaQuery<R> query, CriteriaBuilder builder, Class<T> queryType, List<QueryCriteria> intersectingCriteriaList, QueryWhere queryWhere  ) {
        combineIntersectingRangeCriteria(intersectingCriteriaList);
        assert intersectingCriteriaList.size() > 0 : "Empty list of currently intersecting criteria!";
        Predicate [] intersectingPredicates = new Predicate[intersectingCriteriaList.size()];
        int i = 0;
        for( QueryCriteria intersectingCriteria : intersectingCriteriaList ) { 
            Predicate predicate = createPredicateFromSingleOrGroupCriteria(query, builder, queryType, intersectingCriteria, queryWhere );
            assert predicate != null : "Null predicate when evaluating individual intersecting criteria [" + intersectingCriteria.toString() + "]";
            intersectingPredicates[i++] = predicate;
        }
        
        Predicate predicate;
        if( intersectingPredicates.length > 1 ) { 
            predicate = builder.and(intersectingPredicates);
        } else { 
           predicate = intersectingPredicates[0]; 
        } 
        
        return predicate;
    }

    
    @SuppressWarnings("unchecked")
    private void combineIntersectingRangeCriteria(List<QueryCriteria> intersectionCriteria) { 
        Map<String, QueryCriteria> intersectingRangeCriteria = new HashMap<String, QueryCriteria>();
        Iterator<QueryCriteria> iter = intersectionCriteria.iterator();
        while( iter.hasNext() ) { 
            QueryCriteria criteria = iter.next();
            if( QueryCriteriaType.RANGE.equals(criteria.getType()) ) { 
                QueryCriteria previousCriteria = intersectingRangeCriteria.put(criteria.getListId(), criteria);
                if( previousCriteria != null ) { 
                    Object [] prevCritValues, thisCritValues;
                    assert previousCriteria.hasValues() || previousCriteria.hasDateValues() : 
                        "Previous criteria has neither values nor date values!";
                    assert !(previousCriteria.hasValues() && previousCriteria.hasDateValues()) : 
                        "Previous criteria has BOTH values and date values!";
                    assert (previousCriteria.hasValues() && criteria.hasValues()) 
                    || (previousCriteria.hasDateValues() && criteria.hasDateValues()) : 
                        "Previous and current criteria should have either both have values or both have date values!";
                    
                    boolean dateValues = false;
                    if( previousCriteria.hasValues() ) { 
                        prevCritValues = previousCriteria.getValues().toArray();
                        thisCritValues = criteria.getValues().toArray();
                    } else {
                        dateValues = true;
                        prevCritValues = previousCriteria.getDateValues().toArray();
                        thisCritValues = criteria.getDateValues().toArray();
                    } 
                    
                    List values = dateValues ? previousCriteria.getDateValues() : previousCriteria.getValues();
                    if( prevCritValues[0] == null && thisCritValues[1] == null ) { 
                        values.set(0, thisCritValues[0]);
                        intersectingRangeCriteria.put(previousCriteria.getListId(), previousCriteria);
                        iter.remove();
                    } else if( prevCritValues[1] == null && thisCritValues[0] == null ) { 
                        values.set(1, thisCritValues[1]);
                        intersectingRangeCriteria.put(previousCriteria.getListId(), previousCriteria);
                        iter.remove();
                    }
                }
            } 
        }
    }

    
    private <R,T> Predicate createPredicateFromSingleOrGroupCriteria(CriteriaQuery<R> query, CriteriaBuilder builder, Class<T> queryType, QueryCriteria criteria, QueryWhere queryWhere ) {
        Predicate predicate;
        if( criteria.isGroupCriteria() ) { 
            assert ! criteria.hasValues() : "Criteria has both subcriteria (group criteria) and values! [" + criteria.toString() + "]";
            predicate = createPredicateFromCriteriaList(query, builder, queryType, criteria.getCriteria(), queryWhere );
        } else { 
            assert ! criteria.hasCriteria() : "Criteria has both values and subcriteria (group criteria)! [" + criteria.toString() + "]";
            predicate = createPredicateFromSingleCriteria(query, builder, queryType, criteria, queryWhere);
        } 
        return predicate;
    }

    
    private <R,T> Predicate createPredicateFromSingleCriteria(
            CriteriaQuery<R> query, CriteriaBuilder builder, 
            Class<T> queryType, 
            QueryCriteria criteria, QueryWhere queryWhere) {
        
        Predicate predicate = null;
        assert criteria.hasValues() || criteria.hasDateValues() : "No values present for criteria with list id: [" + criteria.getListId() + "]";

        String listId = criteria.getListId();
        Attribute attr = getCriteriaAttributes().get(queryType).get(listId);
        
        if( attr != null ) { 
            Expression entityField = getEntityField(query, listId, attr);
            predicate = basicCreatePredicateFromSingleCriteria(builder, entityField, criteria);
        } else { 
           predicate = implSpecificCreatePredicateFromSingleCriteria(query, builder, queryType, criteria, queryWhere );
        }
        
        return predicate;
    }

    
    public static <T> Root getRoot(CriteriaQuery<T> query, Class queryType) { 
        Root<?> table = null;
        for( Root<?> root : query.getRoots() ) { 
           if( root.getJavaType().equals(queryType) )  { 
               table = root;
               break;
           }
        }
        return table;
    }

    
    protected <T> Expression getEntityField(CriteriaQuery<T> query, String listId, Attribute attr) { 
        return defaultGetEntityField(query, listId, attr);
    }
    
    @SuppressWarnings("unchecked")
    public static <T> Expression defaultGetEntityField(CriteriaQuery<T> query, String listId, Attribute attr) { 
        Expression entityField = null;
        if( attr != null ) { 
            Class attrType = attr.getDeclaringType().getJavaType();
            for( From from : query.getRoots() ) { 
                if( from.getJavaType().equals(attrType) ) {
                    if( attr != null ) { 
                        if( attr instanceof SingularAttribute ) {
                            entityField = from.get((SingularAttribute) attr);
                        } else if( attr instanceof PluralAttribute ) { 
                            entityField = from.get((PluralAttribute) attr);
                        } else { 
                            throw new IllegalStateException("Unexpected attribute type when processing criteria with list id " + listId + ": " + attr.getClass().getName() );
                        }
                        break;
                    }
                } 
            }
        }
        
        
        return entityField; 
    }

    
    @SuppressWarnings("unchecked")
    public static Predicate basicCreatePredicateFromSingleCriteria(CriteriaBuilder builder, Expression entityField, QueryCriteria criteria) { 
        Predicate predicate = null;
        List<Object> parameters = criteria.getParameters();
        int numParameters = parameters.size();
        assert ! parameters.isEmpty() : "Empty parameters for criteria [" + criteria.toString() + "]";
        switch ( criteria.getType() ) {
        case NORMAL:
            if( numParameters == 1 ) {
                Object parameter = parameters.get(0);
                assert parameter != null : "Null parameter for criteria [" + criteria.toString() + "]";
                predicate = builder.equal(entityField, parameter);
            } else {
                assert parameters.get(0) != null : "Null 1rst parameter for criteria [" + criteria.toString() + "]";
                assert parameters.get(parameters.size()-1) != null : "Null last parameter for criteria [" + criteria.toString() + "]";
                predicate = entityField.in(parameters);
            }
            break;
        case REGEXP:
            List<Predicate> predicateList = new ArrayList<Predicate>();
            for( Object param : parameters ) { 
                assert param != null : "Null regular expression parameter for criteria [" + criteria.toString() + "]";
                String likeRegex = convertRegexToJPALikeExpression((String) param );
                Predicate regexPredicate = builder.like((Expression<String>) entityField, likeRegex);
                predicateList.add(regexPredicate);
            }
            if( predicateList.size() == 1 ) { 
                predicate = predicateList.get(0);
            } else { 
                Predicate [] predicates = predicateList.toArray(new Predicate[predicateList.size()]);
                if( criteria.isUnion() ) { 
                    predicate = builder.or(predicates);
                } else { 
                    predicate = builder.and(predicates);
                }
            }
            break;
        case RANGE:
            assert numParameters > 0 && numParameters < 3: "Range expressions may only contain between 1 and 2 parameters, not " + numParameters + " [" + criteria.toString() + "]";
            Object [] rangeObjArr = parameters.toArray();
            Class rangeType = rangeObjArr[0] != null ? rangeObjArr[0].getClass() : rangeObjArr[1].getClass();
            predicate = createRangePredicate( builder, entityField, rangeObjArr[0], rangeObjArr[1], rangeType);
            break;
        default:
            throw new IllegalStateException("Unknown criteria type: " + criteria.getType());
        }
        assert predicate != null : "No predicate created "
                + "when evaluating " + criteria.getType().toString().toLowerCase() + " criteria "
                + "[" + criteria.toString() + "]";
        
        return predicate;
    }

    
    protected static String convertRegexToJPALikeExpression(String regexInput) { 
        return regexInput.replace('*', '%').replace('.', '_');
    }

    
    @SuppressWarnings("unchecked")
    private static <Y extends Comparable<? super Y>> Predicate createRangePredicate( CriteriaBuilder builder, Expression field, Object start, Object end, Class<Y> rangeType ) { 
        if( start != null && end != null ) { 
            
            return builder.between(field, (Y) start, (Y) end);
        } else if ( start != null ) { 
            return builder.greaterThanOrEqualTo(field, (Y) start);
        } else { 
            return builder.lessThanOrEqualTo(field, (Y) end);
        }
    }

    
    
    protected abstract <R,T> Predicate implSpecificCreatePredicateFromSingleCriteria(
            CriteriaQuery<R> query, 
            CriteriaBuilder builder, 
            Class queryType, 
            QueryCriteria criteria, 
            QueryWhere queryWhere);

    
    
    protected abstract <T> List<T> createQueryAndCallApplyMetaCriteriaAndGetResult(
            QueryWhere queryWhere,
            CriteriaQuery<T> criteriaQuery, 
            CriteriaBuilder builder);

    
    public static void applyMetaCriteriaToQuery(Query query, QueryWhere queryWhere) { 
        if( queryWhere.getCount() != null ) { 
           query.setMaxResults(queryWhere.getCount());
        }
        if( queryWhere.getOffset() != null ) { 
           query.setFirstResult(queryWhere.getOffset());
        } 
    }

    
    protected <T,R> Expression getOrderByExpression(CriteriaQuery<R> query, Class<T> queryType, String orderByListId) {
        Attribute field = getCriteriaAttributes().get(queryType).get(orderByListId);
        assert field != null : "No Attribute found for order-by listId " + orderByListId
                + " for result type " + queryType.getSimpleName();
        Root table = getRoot(query, queryType);
        assert table != null : "Unable to find proper table (Root) instance in query for result type " + queryType.getSimpleName();
    
        Path orderByPath;
        if( field instanceof SingularAttribute ) { 
            orderByPath = table.get((SingularAttribute) field);
        } else { 
            throw new UnsupportedOperationException("Ordering by a join field is not supported!");
        }
        return orderByPath;
    }
    
}

<code block>


package org.jbpm.query.jpa.builder.impl;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.internal.query.data.QueryData;

public abstract class AbstractQueryBuilderImpl<T> {

    protected QueryWhere queryWhere = new QueryWhere();
   
    public QueryWhere getQueryWhere() { 
        return queryWhere;
    }
    
    protected <P> void addRangeParameter( String listId, String name, P parameter, boolean start) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        this.queryWhere.addRangeParameter(listId, parameter, start);
    }

    protected <P> void addRangeParameters( String listId, String name, P paramMin, P paramMax) { 
        if( paramMin == null && paramMax == null ) { 
            throw new IllegalArgumentException("At least one range parameter for " + name + " criteria is required." );
        }
        this.queryWhere.addRangeParameters(listId, paramMin, paramMax);
    }
    
    private <P> void addParameter( String listId, P... parameter ) { 
        this.queryWhere.addParameter(listId, parameter);
    }

    protected void addLongParameter( String listId, String name, long [] parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        Long [] wrapArr = new Long[parameter.length];
        for( int i = 0; i < parameter.length; ++i ) { 
            wrapArr[i] = parameter[i];
        }
        addParameter(listId, wrapArr);
    }
   
    protected void addIntParameter( String listId, String name, int [] parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        Integer [] wrapArr = new Integer[parameter.length];
        for( int i = 0; i < parameter.length; ++i ) { 
            wrapArr[i] = parameter[i];
        }
        addParameter(listId, wrapArr);
    }
    
    protected <P> void addObjectParameter(String listId, String name, P... parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        for( int i = 0; i < parameter.length; ++i ) { 
           if( parameter[i] == null ) { 
               throw new IllegalArgumentException("A null " + name + " criteria (argument " + i + ") is invalid." );
           }
        }
        addParameter(listId, parameter);
    }

    public final T union() {
        this.queryWhere.setToUnion();
        return (T) this;
    }

    public final T intersect() {
        this.queryWhere.setToIntersection();
        return (T) this;
    }

    public T newGroup() {
        this.queryWhere.newGroup();
        return (T) this;
    }
    
    public T endGroup() {
        this.queryWhere.endGroup();
        return (T) this;
    }
    
    public final T like() {
        this.queryWhere.setToLike();
        return (T) this;
    }

    public final T equals() {
        this.queryWhere.setToNormal();
        return (T) this;
    }

    public T clear() {
        this.queryWhere.clear();
        return (T) this;
    }

    public final T maxResults( int maxResults ) {
        if( maxResults < 1 ) { 
            throw new IllegalArgumentException( "A max results criteria of less than 1 is invalid." );
        }
        this.queryWhere.setCount(maxResults);
        return (T) this;
    }

    public final T offset( int offset ) {
        if( offset < 1 ) { 
            throw new IllegalArgumentException( "An offset criteria of less than 1 is invalid." );
        }
        this.queryWhere.setOffset(offset);
        return (T) this;
    }
}

<code block>


package org.jbpm.services.task.commands;

import java.util.Arrays;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.internal.command.Context;

@XmlRootElement(name="composite-command")
@XmlAccessorType(XmlAccessType.FIELD)
public class CompositeCommand<T> extends TaskCommand<T> {
	
	private static final long serialVersionUID = -5591247478243819049L;

	@XmlElements(value={
	            @XmlElement(name="activate-task", type=ActivateTaskCommand.class),
	            @XmlElement(name="add-attachment", type=AddAttachmentCommand.class),
	            @XmlElement(name="add-comment", type=AddCommentCommand.class),
	            @XmlElement(name="add-content", type=AddContentCommand.class),
	            @XmlElement(name="add-group", type=AddGroupCommand.class),
	            @XmlElement(name="add-task", type=AddTaskCommand.class),
	            @XmlElement(name="add-user", type=AddUserCommand.class),
	            @XmlElement(name="add-users-groups", type=AddUsersGroupsCommand.class),
	            @XmlElement(name="archive-tasks", type=ArchiveTasksCommand.class),
	            @XmlElement(name="cancel-deadline", type=CancelDeadlineCommand.class),
	            @XmlElement(name="claim-next-available-task", type=ClaimNextAvailableTaskCommand.class),
	            @XmlElement(name="claim-task", type=ClaimTaskCommand.class),
	            @XmlElement(name="complete-task", type=CompleteTaskCommand.class),
	            @XmlElement(name="delegate-task", type=DelegateTaskCommand.class),
	            @XmlElement(name="delete-attachment", type=DeleteAttachmentCommand.class),
	            @XmlElement(name="delete-comment", type=DeleteCommentCommand.class),
	            @XmlElement(name="delete-content", type=DeleteContentCommand.class),
	            @XmlElement(name="delete-fault", type=DeleteFaultCommand.class),
	            @XmlElement(name="delete-output", type=DeleteOutputCommand.class),
	            @XmlElement(name="deploy-task-def", type=DeployTaskDefCommand.class),
	            @XmlElement(name="execute-deadlines", type=ExecuteDeadlinesCommand.class),
	            @XmlElement(name="execute-task-rules", type=ExecuteTaskRulesCommand.class),
	            @XmlElement(name="exit-task", type=ExitTaskCommand.class),
	            @XmlElement(name="fail-task", type=FailTaskCommand.class),
	            @XmlElement(name="forward-task", type=ForwardTaskCommand.class),
	            @XmlElement(name="get-active-tasks", type=GetActiveTasksCommand.class),
	            @XmlElement(name="get-all-attachments", type=GetAllAttachmentsCommand.class),
	            @XmlElement(name="get-all-comments", type=GetAllCommentsCommand.class),
	            @XmlElement(name="get-all-content", type=GetAllContentCommand.class),
	            @XmlElement(name="get-all-task-definitions", type=GetAllTaskDefinitionsCommand.class),
	            @XmlElement(name="get-archived-tasks", type=GetArchivedTasksCommand.class),
	            @XmlElement(name="get-attachment", type=GetAttachmentCommand.class),
	            @XmlElement(name="get-comment", type=GetCommentCommand.class),
	            @XmlElement(name="get-completed-tasks-by-user", type=GetCompletedTasksByUserCommand.class),
	            @XmlElement(name="get-completed-tasks", type=GetCompletedTasksCommand.class),
	            @XmlElement(name="get-content", type=GetContentCommand.class),
	            @XmlElement(name="get-group", type=GetGroupCommand.class),
	            @XmlElement(name="get-groups", type=GetGroupsCommand.class),
	            @XmlElement(name="get-org-entity", type=GetOrgEntityCommand.class),
	            @XmlElement(name="get-pending-sub-tasks", type=GetPendingSubTasksCommand.class),
	            @XmlElement(name="get-pending-tasks-by-user", type=GetPendingTasksByUserCommand.class),
	            @XmlElement(name="get-potential-ownders-for-task", type=GetPotentialOwnersForTaskCommand.class),
	            @XmlElement(name="get-sub-tasks", type=GetSubTasksCommand.class),
	            @XmlElement(name="get-task-assigned-as-business-admin", type=GetTaskAssignedAsBusinessAdminCommand.class),
	            @XmlElement(name="get-task-assigned-as-excluded-owner", type=GetTaskAssignedAsExcludedOwnerCommand.class),
	            @XmlElement(name="get-task-assigned-as-initiator", type=GetTaskAssignedAsInitiatorCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner-by-exp-date", type=GetTaskAssignedAsPotentialOwnerByExpDateCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner", type=GetTaskAssignedAsPotentialOwnerCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner-paging", type=GetTaskAssignedAsPotentialOwnerPagingCommand.class),
	            @XmlElement(name="get-task-assigned-as-recipient", type=GetTaskAssignedAsRecipientCommand.class),
	            @XmlElement(name="get-task-assigned-as-stakeholeder", type=GetTaskAssignedAsStakeholderCommand.class),
	            @XmlElement(name="get-task-assigned-by-groups", type=GetTaskAssignedByGroupsCommand.class),
	            @XmlElement(name="get-task-by-work-item-id", type=GetTaskByWorkItemIdCommand.class),
	            @XmlElement(name="get-task", type=GetTaskCommand.class),
	            @XmlElement(name="get-task-content", type=GetTaskContentCommand.class),
	            @XmlElement(name="get-task-definition", type=GetTaskDefinitionCommand.class),
	            @XmlElement(name="get-task-owned-by-exp-date-before-date", type=GetTaskOwnedByExpDateBeforeDateCommand.class),
	            @XmlElement(name="get-task-owned-by-exp-date", type=GetTaskOwnedByExpDateCommand.class),
	            @XmlElement(name="get-task-property", type=GetTaskPropertyCommand.class),
	            @XmlElement(name="get-tasks-by-process-instance-id", type=GetTasksByProcessInstanceIdCommand.class),
	            @XmlElement(name="get-tasks-by-status-by-process-instance-id", type=GetTasksByStatusByProcessInstanceIdCommand.class),
	            @XmlElement(name="get-tasks-by-various-fields", type=GetTasksByVariousFieldsCommand.class),
	            @XmlElement(name="get-tasks-for-process", type=GetTasksForProcessCommand.class),
	            @XmlElement(name="get-tasks-owned", type=GetTasksOwnedCommand.class),
	            @XmlElement(name="get-user", type=GetUserCommand.class),
	            @XmlElement(name="get-user-info", type=GetUserInfoCommand.class),
	            @XmlElement(name="get-user", type=GetUsersCommand.class),
	            @XmlElement(name="init-deadlines", type=InitDeadlinesCommand.class),
	            @XmlElement(name="nominate-task", type=NominateTaskCommand.class),
	            @XmlElement(name="process-sub-task", type=ProcessSubTaskCommand.class),
	            @XmlElement(name="release-task", type=ReleaseTaskCommand.class),
	            @XmlElement(name="remove-all-tasks", type=RemoveAllTasksCommand.class),
	            @XmlElement(name="remove-group", type=RemoveGroupCommand.class),
	            @XmlElement(name="remove-task", type=RemoveTaskCommand.class),
	            @XmlElement(name="remove-tasks", type=RemoveTasksCommand.class),
	            @XmlElement(name="remove-user", type=RemoveUserCommand.class),
	            @XmlElement(name="resume-task", type=ResumeTaskCommand.class),
	            @XmlElement(name="set-task-property", type=SetTaskPropertyCommand.class),
	            @XmlElement(name="skip-task", type=SkipTaskCommand.class),
	            @XmlElement(name="start-task", type=StartTaskCommand.class),
	            @XmlElement(name="stop-task", type=StopTaskCommand.class),
	            @XmlElement(name="suspend-task", type=SuspendTaskCommand.class),
	            @XmlElement(name="undeploy-task-def", type=UndeployTaskDefCommand.class),
	            @XmlElement(name="task-query", type=TaskQueryWhereCommand.class),
	            @XmlElement(name="execute-reminder-command", type=ExecuteReminderCommand.class),
	            @XmlElement(name="get-comment-by-id-command", type=GetCommentByIdCommand.class)
    } )
	private TaskCommand<T> mainCommand;

	@XmlElement
	private List<TaskCommand<?>> commands;
	
	public CompositeCommand() {
		
	}
	
	public CompositeCommand(TaskCommand<T> mainCommand, TaskCommand<?>...commands) {
		this.mainCommand = mainCommand;
		this.commands = Arrays.asList(commands);		
	}

	@Override
	public T execute(Context context) {
		if (commands != null) {
			for (TaskCommand<?> cmd : commands) {
				cmd.execute(context);
			}
		}
		return mainCommand.execute(context);
	}

	public TaskCommand<T> getMainCommand() {
		return mainCommand;
	}

	public void setMainCommand(TaskCommand<T> mainCommand) {
		this.mainCommand = mainCommand;
	}

	public List<TaskCommand<?>> getCommands() {
		return commands;
	}

	public void setCommands(List<TaskCommand<?>> commands) {
		this.commands = commands;
	}

	@Override
	public Long getTaskId() {
		if ( mainCommand != null) {
			return mainCommand.getTaskId();	
		}
		return this.taskId;
	}

}

<code block>


package org.jbpm.services.task.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;

import org.jbpm.services.task.deadlines.NotificationListener;
import org.jbpm.services.task.deadlines.notifications.impl.email.EmailNotificationListener;
import org.jbpm.services.task.utils.ClassUtil;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.kie.api.runtime.EnvironmentName;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskData;
import org.kie.internal.command.Context;
import org.kie.internal.task.api.ContentMarshallerContext;
import org.kie.internal.task.api.TaskDeadlinesService.DeadlineType;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.UserInfo;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.DeadlineSummary;
import org.kie.internal.task.api.model.EmailNotification;
import org.kie.internal.task.api.model.EmailNotificationHeader;
import org.kie.internal.task.api.model.Escalation;
import org.kie.internal.task.api.model.Language;
import org.kie.internal.task.api.model.Notification;
import org.kie.internal.task.api.model.NotificationEvent;
import org.kie.internal.task.api.model.NotificationType;
import org.mvel2.templates.TemplateRuntime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlRootElement(name="execute-reminder-command")
@XmlAccessorType(XmlAccessType.NONE)
public class ExecuteReminderCommand extends TaskCommand<Void> {
	private static final long serialVersionUID = -1167914440425583650L;
	private static final Logger logger = LoggerFactory.getLogger(ExecuteReminderCommand.class);
	
	private static final String defaultEmailBody="<html> "
    		+ "<body>"
    		+ "<b> You have been assigned to a task ( task_name = ${taskName}, task_id = ${taskId} )</b>"
    		+ "</br>"
    		+ "<b>"
    		+ "Process instance information:"
    		+ "</b>"
    		+ "</hr>"
    		+ "<ul>"
    		+ "<li> DeploymentId : ${deploymentId} </li>"
    		+ "<li> ProcessId : ${processId} </li>" 
    		+ "<li> ProcessInstanceId : ${processInstanceId} </li>" 
    		+ "	</ul>"
    		+ "</b>"
    		+ "</body>"
    		+ "</html>";
    private static final String defaultEmailSubject="You have a task ( ${taskName} ) of process ( ${processId} )";
	@XmlElement
	@XmlSchemaType(name="String")
    private String fromUser;
	@XmlTransient
	private NotificationListener notificationListener;
	
	public ExecuteReminderCommand() {
		
	}
	
	public ExecuteReminderCommand(long taskId,String fromUser) {
		this.taskId = taskId;
		this.fromUser = fromUser;
	}
	
	@Override
	public Void execute(Context context) {
		TaskContext ctx = (TaskContext) context;
		if (notificationListener == null) {
			this.notificationListener = new EmailNotificationListener((UserInfo) context.get(EnvironmentName.TASK_USER_INFO));
		}
		
		TaskPersistenceContext persistenceContext = ctx.getPersistenceContext();
	        
		try {
			Task task = persistenceContext.findTask(taskId);
			TaskData taskData = task.getTaskData();
			
			List<DeadlineSummary> resultList =null;
			resultList = getAlldeadlines(persistenceContext, taskData);
			
			if( resultList == null || resultList.size() == 0 ){
				if ( taskData.getActualOwner() == null )
					return null ;
        		if ( taskData != null ) {
        		    
        		    if ( DeadlineType.START.isValidStatus(taskData.getStatus()) || DeadlineType.END.isValidStatus(taskData.getStatus())) {
        		    	logger.debug("Sending an Email");
        		    	Map<String, Object> variables = getVariables(ctx, persistenceContext, task,
        							taskData);
        		        Notification notification = buildDefaultNotification(taskData,task);
        		        notificationListener.onNotification(new NotificationEvent(notification, task, variables));
        		    }
        		}
        	}else{
				for(DeadlineSummary deadlineSummary : resultList){
					executedeadLine(ctx, persistenceContext, task, deadlineSummary, taskData);
				}
        	}
        } catch (Exception e) {

        	logger.error("Error when executing deadlines", e);
        }
		return null;
	}

	private List<DeadlineSummary> getAlldeadlines(TaskPersistenceContext persistenceContext, TaskData taskData) {
		List<DeadlineSummary> resultList;
		
		if(Status.InProgress == taskData.getStatus() || Status.Suspended == taskData.getStatus()){
			resultList = persistenceContext.queryWithParametersInTransaction("UnescalatedEndDeadlinesByTaskIdForReminder", 
		            persistenceContext.addParametersToMap("taskId", taskId),
		            ClassUtil.<List<DeadlineSummary>>castClass(List.class));
		}else{
			
			 resultList =persistenceContext.queryWithParametersInTransaction("UnescalatedStartDeadlinesByTaskIdForReminder", 
		                persistenceContext.addParametersToMap("taskId", taskId),
		                ClassUtil.<List<DeadlineSummary>>castClass(List.class));
		}
		return resultList;
	}

	private Void executedeadLine(
	        TaskContext ctx,
			TaskPersistenceContext persistenceContext, 
			Task task,
			DeadlineSummary deadlineSummary,
			TaskData taskData) {
		Deadline deadline = persistenceContext.findDeadline(deadlineSummary.getDeadlineId());
		if (task == null || deadline == null) {
			return null;
		}
		
		if (taskData != null) {
		    
		    if (DeadlineType.START.isValidStatus(taskData.getStatus()) || DeadlineType.END.isValidStatus(taskData.getStatus())) {
		        Map<String, Object> variables = getVariables(ctx, persistenceContext, task, taskData);
		        if (deadline == null || deadline.getEscalations() == null ) {
		            return null;
		        }

		        for (Escalation escalation : deadline.getEscalations()) {
		            for (Notification notification : escalation.getNotifications()) {
		                if (notification.getNotificationType() == NotificationType.Email) {
		                    logger.debug("Sending an Email");
		                    notificationListener.onNotification(new NotificationEvent(notification, task, variables));
		                }
		            }
		        }
		    }
		    
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	private Map<String, Object> getVariables(TaskContext ctx, TaskPersistenceContext persistenceContext, Task task,
			TaskData taskData) {
		Map<String, Object> variables;
		Content content = persistenceContext.findContent(taskData.getDocumentContentId());

		if (content != null) {
		    ContentMarshallerContext mContext = ctx.getTaskContentService().getMarshallerContext(task);
		    Object objectFromBytes = ContentMarshallerHelper.unmarshall(content.getContent(), mContext.getEnvironment(), mContext.getClassloader());

		    if (objectFromBytes instanceof Map) {
		        variables = (Map<String, Object>) objectFromBytes;

		    } else {

		        variables = new HashMap<String, Object>();
		        variables.put("content", objectFromBytes);
		    }
		} else {
		    variables = Collections.emptyMap();
		}
		return variables;
	}
	
	private Notification buildDefaultNotification( TaskData taskData,Task task ){
		EmailNotification emailNotificationImpl =  TaskModelProvider.getFactory().newEmialNotification();
		Map<Language, EmailNotificationHeader> map = new HashMap<Language, EmailNotificationHeader>();
		EmailNotificationHeader emailNotificationHeaderImpl = TaskModelProvider.getFactory().newEmailNotificationHeader();
		emailNotificationHeaderImpl.setBody(buildDefafultEmailBody(taskData,task));
		emailNotificationHeaderImpl.setFrom(fromUser);
		emailNotificationHeaderImpl.setReplyTo(fromUser);
		emailNotificationHeaderImpl.setLanguage("en-UK");
		emailNotificationHeaderImpl.setSubject(buildDefafultEmailSubject(taskData, task));
		Language language  = TaskModelProvider.getFactory().newLanguage();
		language.setMapkey("en-UK");
		map.put(language, emailNotificationHeaderImpl);
		emailNotificationImpl.setEmailHeaders(map);
		
		List<OrganizationalEntity> recipients = new ArrayList<OrganizationalEntity>();
		recipients.add(taskData.getActualOwner());
		emailNotificationImpl.setRecipients(recipients);
		
		return emailNotificationImpl;
	}
	
	private String buildDefafultEmailBody(TaskData taskData,Task task){
		Map<String, Object> vars = new HashMap<String, Object>();
		vars.put("taskName", task.getName());
		vars.put("taskId", task.getId());
		vars.put("deploymentId", taskData.getDeploymentId());
		vars.put("processId", taskData.getProcessId());
		vars.put("processInstanceId", taskData.getProcessInstanceId());
		String body = (String) TemplateRuntime.eval(defaultEmailBody, vars);
		return body;
	}
	
	private String buildDefafultEmailSubject(TaskData taskData,Task task){
		Map<String, Object> vars = new HashMap<String, Object>();
		vars.put("taskName", task.getName());
		vars.put("processId", taskData.getProcessId());
		String body = (String) TemplateRuntime.eval(defaultEmailSubject, vars);
		return body;
	}
}

<code block>


package org.jbpm.services.task.commands;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.command.Context;

@XmlRootElement(name="task-query-where-command")
@XmlAccessorType(XmlAccessType.FIELD)
public class TaskQueryWhereCommand extends UserGroupCallbackTaskCommand<List<TaskSummary>> {

    
    private static final long serialVersionUID = -6879337395030142688L;

    @XmlElement
    private QueryWhere queryWhere;
    
    public TaskQueryWhereCommand() { 
        
    }
    
    public TaskQueryWhereCommand(QueryWhere queryWhere) { 
        this.queryWhere = queryWhere;
    }
    
    public QueryWhere getQueryWhere() {
        return queryWhere;
    }

    public void setQueryWhere( QueryWhere queryWhere ) {
        this.queryWhere = queryWhere;
    }

    @Override
    public List<TaskSummary> execute(Context cntxt) {
        TaskContext context = (TaskContext) cntxt;
        return context.getTaskQueryService().query(userId, queryWhere);
    }
   
}

<code block>


package org.jbpm.services.task.commands;

import static org.kie.internal.query.QueryParameterIdentifiers.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;

import org.kie.api.task.TaskService;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.command.Context;


@XmlRootElement(name="get-tasks-by-various-fields-command")
@XmlAccessorType(XmlAccessType.NONE)
@Deprecated
public class GetTasksByVariousFieldsCommand extends UserGroupCallbackTaskCommand<List<TaskSummary>> {

	private static final long serialVersionUID = -4894264083829084547L;

	@XmlElement
    private List<Long> workItemIds;
    
    @XmlElement
    private List<Long> taskIds;
    
    @XmlElement
    private List<Long> processInstanceIds;
    
    @XmlElement
    private List<String> businessAdmins;
    
    @XmlElement
    private List<String> potentialOwners;
    
    @XmlElement
    private List<String> taskOwners;
    
    @XmlElement
    private List<Status> statuses;
    
    @XmlElement
    @XmlSchemaType(name="boolean")
    private Boolean union;
    
    @XmlElement
    private List<String> languages;
    
    @XmlElement
    private Integer maxResults;
    
    
	public GetTasksByVariousFieldsCommand() {
	    
	}

	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        boolean union) { 
	    this(workItemIds, taskIds, procInstIds, busAdmins, potOwners, taskOwners, statuses, null, union);
	}
	
	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        List<String> language, boolean union) { 
	    this(workItemIds, taskIds, procInstIds, busAdmins, potOwners, taskOwners, statuses, language, union, null);
    }

	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        List<String> language, boolean union, Integer maxResults) { 
		this.workItemIds = workItemIds;
		this.taskIds = taskIds;
		this.processInstanceIds = procInstIds;
		this.businessAdmins = busAdmins;
		this.potentialOwners = potOwners;
		this.taskOwners = taskOwners;
		this.statuses = statuses;
		this.languages = language;
		this.union = union;
		this.maxResults = maxResults;
	}
	
	public GetTasksByVariousFieldsCommand(Map<String, List<?>> params, boolean union) { 
	    this(params, union, null);
	}
    
	@SuppressWarnings("unchecked")
	public GetTasksByVariousFieldsCommand(Map<String, List<?>> params, boolean union, Integer maxResults) { 
	    this.union = union;
	    this.maxResults = maxResults;

	    if( params == null ) { 
	        params = new HashMap<String, List<?>>();
	    } else { 
	        this.workItemIds = (List<Long>) params.get(WORK_ITEM_ID_LIST);
	        this.taskIds = (List<Long>) params.get(TASK_ID_LIST);
	        this.processInstanceIds = (List<Long>) params.get(PROCESS_INSTANCE_ID_LIST);
	        this.businessAdmins = (List<String>) params.get(BUSINESS_ADMIN_ID_LIST);
	        this.potentialOwners = (List<String>) params.get(POTENTIAL_OWNER_ID_LIST);
	        this.taskOwners = (List<String>) params.get(ACTUAL_OWNER_ID_LIST);
	        this.statuses = (List<Status>) params.get(TASK_STATUS_LIST);
	    }
	}

    
	public List<Long> getWorkItemIds() {
        return workItemIds;
    }

    public void setWorkItemIds(List<Long> workItemIds) {
        this.workItemIds = workItemIds;
    }

    public List<Long> getTaskIds() {
        return taskIds;
    }

    public void setTaskIds(List<Long> taskIds) {
        this.taskIds = taskIds;
    }

    public List<Long> getProcInstIds() {
        return processInstanceIds;
    }

    public void setProcInstIds(List<Long> procInstIds) {
        this.processInstanceIds = procInstIds;
    }

    public List<String> getBusAdmins() {
        return businessAdmins;
    }

    public void setBusAdmins(List<String> busAdmins) {
        this.businessAdmins = busAdmins;
    }

    public List<String> getPotOwners() {
        return potentialOwners;
    }

    public void setPotOwners(List<String> potOwners) {
        this.potentialOwners = potOwners;
    }

    public List<String> getTaskOwners() {
        return taskOwners;
    }

    public void setTaskOwners(List<String> taskOwners) {
        this.taskOwners = taskOwners;
    }

    public List<Status> getStatuses() {
        return statuses;
    }

    public void setStatuses(List<Status> statuses) {
        this.statuses = statuses;
    }

    public List<String> getLanguage() {
        return languages;
    }

    public void setLanguage(List<String> language) {
        this.languages = language;
    }

    public Boolean getUnion() {
        return union;
    }

    public void setUnion(Boolean union) {
        this.union = union;
    }

    public Integer getMaxResults() {
        return maxResults;
    }

    public void setMaxResults(Integer maxResults) {
        this.maxResults = maxResults;
    }

    public List<TaskSummary> execute(Context cntxt) {
        TaskContext context = (TaskContext) cntxt;
        
        potentialOwners = populateOrganizationalEntityWithGroupInfo(potentialOwners, context);
    	businessAdmins = populateOrganizationalEntityWithGroupInfo(businessAdmins, context);
    	List<String> stakeHolders = new ArrayList<String>();
    	stakeHolders = populateOrganizationalEntityWithGroupInfo(stakeHolders, context);
    	
        Map<String, List<?>> params = new HashMap<String, List<?>>();
        params.put(WORK_ITEM_ID_LIST, workItemIds);
        params.put(TASK_ID_LIST, taskIds);
        params.put(PROCESS_INSTANCE_ID_LIST, processInstanceIds);
        params.put(BUSINESS_ADMIN_ID_LIST, businessAdmins);
        params.put(POTENTIAL_OWNER_ID_LIST, potentialOwners);
        params.put(STAKEHOLDER_ID_LIST, stakeHolders);
        params.put(ACTUAL_OWNER_ID_LIST, taskOwners);
        params.put(TASK_STATUS_LIST, statuses);
        if( maxResults != null && maxResults.intValue() > 0 ) {
            Integer [] maxResultsArr = { maxResults };
            params.put(MAX_RESULTS, Arrays.asList(maxResultsArr));
        }
    
        if( userId == null || userId.isEmpty() ) { 
           throw new IllegalStateException("A user id is required for this operation: " + GetTasksByVariousFieldsCommand.class.getSimpleName() );
        }
        return context.getTaskQueryService().getTasksByVariousFields(userId, params, union);
    }

    
    protected List<String> populateOrganizationalEntityWithGroupInfo(List<String> entities, TaskContext context) {
    	if (entities != null && entities.size() > 0) {
    		Set<String> groupIds = new HashSet<String>();
    		for (String userId : entities) {
    			List<String> tmp = doUserGroupCallbackOperation(userId, null, context);
    			if (tmp != null) {
    				groupIds.addAll(tmp);
    			}
    		}
    		groupIds.addAll(entities);
    		return new ArrayList<String>(groupIds);
    	}
    	
    	return entities;
    }

}

<code block>


package org.jbpm.services.task.commands;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.services.task.utils.ClassUtil;
import org.kie.internal.command.Context;
import org.kie.internal.task.api.TaskDeadlinesService;
import org.kie.internal.task.api.TaskDeadlinesService.DeadlineType;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.model.DeadlineSummary;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlRootElement(name="init-deadlines-command")
@XmlAccessorType(XmlAccessType.NONE)
public class InitDeadlinesCommand extends TaskCommand<Void> {
	
	private static final long serialVersionUID = -8095766991770311489L;
	private static final Logger logger = LoggerFactory.getLogger(InitDeadlinesCommand.class);

	public InitDeadlinesCommand() {		
	}

	@Override
	public Void execute(Context context) {
		TaskContext ctx = (TaskContext) context;
		
		TaskPersistenceContext persistenceContext = ctx.getPersistenceContext();
		TaskDeadlinesService deadlineService = ctx.getTaskDeadlinesService();
		
        try {
	        long now = System.currentTimeMillis();
	        List<DeadlineSummary> resultList = persistenceContext.queryInTransaction("UnescalatedStartDeadlines",
	        										ClassUtil.<List<DeadlineSummary>>castClass(List.class));
	        for (DeadlineSummary summary : resultList) {
	            long delay = summary.getDate().getTime() - now;
	            deadlineService.schedule(summary.getTaskId(), summary.getDeadlineId(), delay, DeadlineType.START);
	
	        }
	        
	        resultList = persistenceContext.queryInTransaction("UnescalatedEndDeadlines",
	        		ClassUtil.<List<DeadlineSummary>>castClass(List.class));
	        for (DeadlineSummary summary : resultList) {
	            long delay = summary.getDate().getTime() - now;
	            deadlineService.schedule(summary.getTaskId(), summary.getDeadlineId(), delay, DeadlineType.END);
	        }
        } catch (Exception e) {

        	logger.error("Error when executing deadlines", e);
        }
		return null;
	}

}

<code block>

package org.jbpm.services.task.utils;

import java.io.IOException;
import java.io.Reader;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import org.drools.core.util.MVELSafeHelper;
import org.jbpm.services.task.internals.lifecycle.Allowed;
import org.jbpm.services.task.internals.lifecycle.OperationCommand;
import org.kie.api.command.Command;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.internal.task.api.TaskModelFactory;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.UserInfo;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.AllowedToDelegate;
import org.kie.internal.task.api.model.CommandName;
import org.kie.internal.task.api.model.NotificationType;
import org.kie.internal.task.api.model.Operation;
import org.kie.internal.task.api.model.SubTasksStrategy;
import org.mvel2.MVEL;
import org.mvel2.ParserConfiguration;
import org.mvel2.ParserContext;


public class MVELUtils { 
    private static Map<String, Class<?>> inputs = new HashMap<String, Class<?>>();
    private static TaskModelFactory factory = TaskModelProvider.getFactory(); 
    
    public static Map<String, Class<?>> getInputs() {
        synchronized (inputs) {
            if (inputs.isEmpty()) {
                
                inputs.put("AccessType", AccessType.class);
                inputs.put("AllowedToDelegate", AllowedToDelegate.class);
                inputs.put("Attachment", factory.newAttachment().getClass());
                inputs.put("BooleanExpression", factory.newBooleanExpression().getClass());
                inputs.put("Comment", factory.newComment().getClass());
                inputs.put("Content", factory.newContent().getClass());
                inputs.put("Deadline", factory.newDeadline().getClass());
                inputs.put("Deadlines", factory.newDeadlines().getClass());
                inputs.put("Delegation", factory.newDelegation().getClass());
                inputs.put("EmailNotification", factory.newEmialNotification().getClass());
                inputs.put("EmailNotificationHeader", factory.newEmailNotificationHeader().getClass());
                inputs.put("Escalation", factory.newEscalation().getClass());
                inputs.put("Group", factory.newGroup().getClass());
                inputs.put("I18NText", factory.newI18NText().getClass());
                inputs.put("Notification", factory.newNotification().getClass());
                inputs.put("NotificationType", NotificationType.class);
                inputs.put("OrganizationalEntity", OrganizationalEntity.class);
                inputs.put("PeopleAssignments", factory.newPeopleAssignments().getClass());
                inputs.put("Reassignment", factory.newReassignment().getClass());
                inputs.put("Status", Status.class);
                inputs.put("Task", factory.newTask().getClass());
                inputs.put("TaskData", factory.newTaskData().getClass());
                inputs.put("User", factory.newUser().getClass());
                inputs.put("UserInfo", UserInfo.class);
                inputs.put("SubTasksStrategy",SubTasksStrategy.class);
                inputs.put("Language", factory.newLanguage().getClass());
                

                
                inputs.put("Allowed", Allowed.class);
                inputs.put("Command", Command.class);
                inputs.put("CommandName", CommandName.class);
                inputs.put("ContentData", factory.newContentData().getClass());
                inputs.put("Operation", Operation.class);
                inputs.put("Operation.Claim", Operation.class);
                inputs.put("Operation.Delegate", Operation.class);
                inputs.put("OperationCommand", OperationCommand.class);

                
                inputs.put("DeadlineSummary", factory.newDeadline().getClass());
                inputs.put("TaskSummary", factory.newTaskSummary().getClass());
            }
            return inputs;
        }
    }
    public static Object eval(Reader reader, Map<String, Object> vars) {
        try {
            return eval(toString(reader), vars);
        } catch (IOException e) {
            throw new RuntimeException("Exception Thrown",e);
        }
    }
    public static Object eval(Reader reader) { 
        try {
            return eval(toString(reader), null);
        } catch (IOException e) {
            throw new RuntimeException("Exception Thrown",e);
        }
    }
    
    public static Object eval(String str, Map<String, Object> vars) {
    	ParserConfiguration pconf = new ParserConfiguration();
    	pconf.addPackageImport("org.jbpm.services.task");

        
    	pconf.addPackageImport("org.jbpm.services.task.query");
    	pconf.addPackageImport("java.util");
    	
    	for(String entry : getInputs().keySet()){
    		pconf.addImport(entry, getInputs().get(entry));
        }
    	ParserContext context = new ParserContext(pconf);
        Serializable s = MVEL.compileExpression(str.trim(), context);

        if( vars != null ) { 
        return MVELSafeHelper.getEvaluator().executeExpression(s, vars);
    }
        else { 
            return MVELSafeHelper.getEvaluator().executeExpression(s);
        }
    }
    public static String toString(Reader reader) throws IOException {
        int charValue  ;
        StringBuffer sb = new StringBuffer(1024);
        while ((charValue = reader.read()) != -1) {
            sb.append((char) charValue);
        }
        return sb.toString();
    }
    
}

<code block>


package org.jbpm.services.task.impl;

import static org.kie.internal.query.QueryParameterIdentifiers.ACTUAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ARCHIVED;
import static org.kie.internal.query.QueryParameterIdentifiers.BUSINESS_ADMIN_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CREATED_BY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CREATED_ON_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXPIRATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.POTENTIAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_SESSION_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.SKIPPABLE;
import static org.kie.internal.query.QueryParameterIdentifiers.STAKEHOLDER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.SUB_TASKS_STRATEGY;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ACTIVATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_DESCRIPTION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_FORM_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_PARENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_PRIORITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_SUBJECT_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.Date;
import java.util.List;

import org.drools.core.command.CommandService;
import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.services.task.commands.TaskQueryWhereCommand;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.QueryContext;
import org.kie.internal.query.QueryParameterIdentifiers;
import org.kie.internal.task.api.model.SubTasksStrategy;
import org.kie.internal.task.query.TaskQueryBuilder;


public class TaskQueryBuilderImpl extends AbstractQueryBuilderImpl<TaskQueryBuilder> implements TaskQueryBuilder {

    private final CommandService executor; 
    private final String userId;
   
    public TaskQueryBuilderImpl(String userId, CommandService taskCmdService) {
        this.executor = taskCmdService;
        this.userId = userId;
        
        this.queryWhere.setAscending(QueryParameterIdentifiers.TASK_ID_LIST);
    }
   
    
    
    @Override
    public TaskQueryBuilder activationTime( Date... activationTime ) {
        addObjectParameter(TASK_ACTIVATION_TIME_LIST, "activation time", activationTime);
        return this;
    }

    @Override
    public TaskQueryBuilder activationTimeRange( Date activationTimeMin, Date activationTimeMax ) {
        addRangeParameters(TASK_ACTIVATION_TIME_LIST, "activation time range", activationTimeMin, activationTimeMax);
        return this;
    }

    @Override
    public TaskQueryBuilder actualOwner( String... taskOwnerId ) {
        addObjectParameter(ACTUAL_OWNER_ID_LIST, "task owner id", taskOwnerId);
        return this;
    }

    @Override
    public TaskQueryBuilder archived( boolean archived ) {
        Short realValue = archived ? new Short((short) 1) : new Short((short) 0);
        addObjectParameter(ARCHIVED, "archived", realValue);
        return this;
    }

    @Override
    public TaskQueryBuilder businessAdmin( String... businessAdminId ) {
        addObjectParameter(BUSINESS_ADMIN_ID_LIST, "business administrator id", businessAdminId);
        return this;
    }

    @Override
    public TaskQueryBuilder createdBy( String... createdById ) {
        addObjectParameter(CREATED_BY_LIST, "created by id", createdById);
        return this;
    }

    @Override
    public TaskQueryBuilder createdOn( Date... createdOnDate ) {
        addObjectParameter(CREATED_ON_LIST, "created on", createdOnDate);
        return this;
    }

    @Override
    public TaskQueryBuilder createdOnRange( Date createdOnMin, Date createdOnMax ) {
        addRangeParameters(CREATED_ON_LIST, "created on range", createdOnMin, createdOnMax);
        return this;
    }

    @Override
    public TaskQueryBuilder deploymentId( String... deploymentId ) {
        addObjectParameter(DEPLOYMENT_ID_LIST, "deployment id", deploymentId);
        return this;
    }

    @Override
    public TaskQueryBuilder description( String... description ) {
        addObjectParameter(TASK_DESCRIPTION_LIST, "description", description);
        return this;
    }

    @Override
    public TaskQueryBuilder expirationTime( Date... expirationTime ) {
        addObjectParameter(EXPIRATION_TIME_LIST, "expiration time", expirationTime);
        return this;
    }

    @Override
    public TaskQueryBuilder expirationTimeRange( Date expirationTimeMin, Date expirationTimeMax ) {
        addRangeParameters(EXPIRATION_TIME_LIST, "expiration time range", expirationTimeMin, expirationTimeMax);
        return this;
    }

    @Override
    public TaskQueryBuilder formName( String... formName ) {
        addObjectParameter(TASK_FORM_NAME_LIST, "form name", formName);
        return this;
    }

    @Override
    public TaskQueryBuilder potentialOwner( String... potentialOwnerId ) {
        addObjectParameter(POTENTIAL_OWNER_ID_LIST, "potential owner id", potentialOwnerId);
        return this;
    }

    @Override
    public TaskQueryBuilder processInstanceId( long... processInstanceId ) {
        addLongParameter(PROCESS_INSTANCE_ID_LIST, "process instance id", processInstanceId);
        return this;
    }

    @Override
    public TaskQueryBuilder name( String... name ) {
        addObjectParameter(TASK_NAME_LIST, "task name", name);
        return this;
    }

    @Override
    public TaskQueryBuilder priority( int... priority ) {
        addIntParameter(TASK_PRIORITY_LIST, "priority", priority);
        return this;
    }

    @Override
    public TaskQueryBuilder processId( String... processId ) {
        addObjectParameter(PROCESS_ID_LIST, "process id", processId);
        return this;
    }

    @Override
    public TaskQueryBuilder processInstanceIdRange( Long processInstanceIdMin, Long processInstanceIdMax ) {
        addRangeParameters(PROCESS_INSTANCE_ID_LIST, "process instance id range", processInstanceIdMin, processInstanceIdMax);
        return this;
    }

    @Override
    public TaskQueryBuilder processSessionId( long... processSessionId ) {
        addLongParameter(PROCESS_SESSION_ID_LIST, "process session id", processSessionId);
        return this;
    }

    @Override
    public TaskQueryBuilder skippable( boolean skippable ) {
        addObjectParameter(SKIPPABLE, "skippable", skippable);
        return this;
    }

    @Override
    public TaskQueryBuilder stakeHolder( String... stakeHolderId ) {
        addObjectParameter(STAKEHOLDER_ID_LIST, "stakeholder id", stakeHolderId);
        return this;
    }

    @Override
    public TaskQueryBuilder status( Status... status ) {
        addObjectParameter(TASK_STATUS_LIST, "status", status);
        return this;
    }

    @Override
    public TaskQueryBuilder subject( String... subject ) {
        addObjectParameter(TASK_SUBJECT_LIST, "subject", subject);
        return this;
    }

    @Override
    public TaskQueryBuilder subTaskStrategy( SubTasksStrategy... subTasksStrategy ) {
        addObjectParameter(SUB_TASKS_STRATEGY, "sub tasks strategy", subTasksStrategy);
        return this;
    }

    @Override
    public TaskQueryBuilder taskId( long... taskId ) {
        addLongParameter(TASK_ID_LIST, "task id", taskId);
        return this;
    }

    @Override
    public TaskQueryBuilder taskIdRange( Long taskIdMin, Long taskIdMax ) {
        addRangeParameters(TASK_ID_LIST, "task id range", taskIdMin, taskIdMax);
        return this;
    }

    @Override
    public TaskQueryBuilder taskParentId( long... taskParentId ) {
        addLongParameter(TASK_PARENT_ID_LIST, "task parent id", taskParentId);
        return this;
    }

    @Override
    public TaskQueryBuilder taskType( String... taskType ) {
        addObjectParameter(TYPE_LIST, "created on", taskType);
        return this;
    }
    
    @Override
    public TaskQueryBuilder workItemId( long... workItemId ) {
        addLongParameter(WORK_ITEM_ID_LIST, "work item id", workItemId);
        return this;
    }

    
    
    @Override
    public TaskQueryBuilder clear() {
        super.clear();
        getQueryWhere().setAscending(QueryParameterIdentifiers.TASK_ID_LIST);
        return this;
    }

    @Override
    public TaskQueryBuilder ascending( OrderBy field ) {
        String listId = getOrderByListId(field);
        this.queryWhere.setAscending(listId);
        return this;
    }

    @Override
    public TaskQueryBuilder descending( OrderBy field ) {
        String listId = getOrderByListId(field);
        this.queryWhere.setDescending(listId);
        return this;
    }

    private String getOrderByListId( OrderBy field ) {
        if( field == null ) { 
            throw new IllegalArgumentException( "A null order by criteria is invalid." );
        }
        String orderByString;
        switch( field ) { 
        case taskId:
            orderByString = QueryParameterIdentifiers.TASK_ID_LIST;
            break;
        case processInstanceId:
            orderByString = QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
            break;
        case taskName:
            orderByString = QueryParameterIdentifiers.TASK_NAME_LIST;
            break;
        case taskStatus:
            orderByString = QueryParameterIdentifiers.TASK_STATUS_LIST;
            break;
        case createdOn:
            orderByString = QueryParameterIdentifiers.CREATED_ON_LIST;
            break;
        case createdBy:
            orderByString = QueryParameterIdentifiers.CREATED_BY_LIST;
            break;
        default:
           throw new UnsupportedOperationException("Unsupported order by arqument: " + field.toString() );
        }
        return orderByString;
    }

    @Override
    public ParametrizedQuery<TaskSummary> build() {
        return new ParametrizedQuery<TaskSummary>() {
            private QueryWhere queryWhere = new QueryWhere(getQueryWhere());
            @Override
            public List<TaskSummary> getResultList() {
                TaskQueryWhereCommand cmd = new TaskQueryWhereCommand(queryWhere);
                cmd.setUserId(userId);
                return executor.execute(cmd);
            }
        };
    }

}

<code block>
    
package org.jbpm.services.task.impl;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.drools.core.common.InternalWorkingMemory;
import org.drools.core.time.Job;
import org.drools.core.time.JobContext;
import org.drools.core.time.JobHandle;
import org.drools.core.time.TimerService;
import org.drools.core.time.Trigger;
import org.drools.core.time.impl.IntervalTrigger;
import org.jbpm.process.core.timer.NamedJobContext;
import org.jbpm.process.core.timer.TimerServiceRegistry;
import org.jbpm.process.core.timer.impl.GlobalTimerService;
import org.jbpm.services.task.commands.ExecuteDeadlinesCommand;
import org.jbpm.services.task.commands.InitDeadlinesCommand;
import org.jbpm.services.task.deadlines.NotificationListener;
import org.jbpm.services.task.utils.ClassUtil;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.task.model.Task;
import org.kie.internal.task.api.TaskDeadlinesService;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.DeadlineSummary;
import org.kie.internal.task.api.model.Deadlines;
import org.kie.internal.task.api.model.InternalTask;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TaskDeadlinesServiceImpl implements TaskDeadlinesService {
    
    private static final Logger logger = LoggerFactory.getLogger(TaskDeadlinesServiceImpl.class);
    
    protected static volatile CommandExecutor instance;
    
    protected static NotificationListener notificationListener;

	
    private volatile static ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(3);
    private volatile static Map<Long, List<ScheduledFuture<ScheduledTaskDeadline>>> startScheduledTaskDeadlines = new ConcurrentHashMap<Long, List<ScheduledFuture<ScheduledTaskDeadline>>>();
    private volatile static Map<Long, List<ScheduledFuture<ScheduledTaskDeadline>>> endScheduledTaskDeadlines = new ConcurrentHashMap<Long, List<ScheduledFuture<ScheduledTaskDeadline>>>();
    private volatile static Map<String, JobHandle> jobHandles = new ConcurrentHashMap<String, JobHandle>();

    private TaskPersistenceContext persistenceContext;

    
    public TaskDeadlinesServiceImpl() {
    }
    
    public TaskDeadlinesServiceImpl(TaskPersistenceContext persistenceContext) {
    	this.persistenceContext = persistenceContext;
    }

    public void setPersistenceContext(TaskPersistenceContext persistenceContext) {
        this.persistenceContext = persistenceContext;
    }


    public void schedule(long taskId, long deadlineId, long delay, DeadlineType type) {
        Task task = persistenceContext.findTask(taskId);
        String deploymentId = task.getTaskData().getDeploymentId();

        TimerService timerService = TimerServiceRegistry.getInstance().get(deploymentId + TimerServiceRegistry.TIMER_SERVICE_SUFFIX);
        if (timerService != null && timerService instanceof GlobalTimerService) {
            TaskDeadlineJob deadlineJob = new TaskDeadlineJob(taskId, deadlineId, type);
            Trigger trigger = new IntervalTrigger( timerService.getCurrentTime(),
                    null,
                    null,
                    -1,
                    delay,
                    0,
                    null,
                    null ) ;
            JobHandle handle = timerService.scheduleJob(deadlineJob, new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()), trigger);
            logger.debug( "scheduling timer job for deadline {} and task {}  using timer service {}", deadlineJob.getId(), taskId, timerService);
            jobHandles.put(deadlineJob.getId(), handle);

        } else {
            ScheduledFuture<ScheduledTaskDeadline> scheduled = scheduler.schedule(new ScheduledTaskDeadline(taskId, deadlineId, type), delay, TimeUnit.MILLISECONDS);
            
            List<ScheduledFuture<ScheduledTaskDeadline>> knownFutures = null;
            if (type == DeadlineType.START) {
                knownFutures = startScheduledTaskDeadlines.get(taskId);
            } else if (type == DeadlineType.END) {
                knownFutures = endScheduledTaskDeadlines.get(taskId);
            }
            if (knownFutures == null) {
                knownFutures = new CopyOnWriteArrayList<ScheduledFuture<ScheduledTaskDeadline>>();
            }

            knownFutures.add(scheduled);
                        
            if (type == DeadlineType.START) {
                startScheduledTaskDeadlines.put(taskId, knownFutures);
            } else if (type == DeadlineType.END) {
                endScheduledTaskDeadlines.put(taskId, knownFutures);
            }
        }

    }

    public void unschedule(long taskId, DeadlineType type) {
        Task task = persistenceContext.findTask(taskId);
        String deploymentId = task.getTaskData().getDeploymentId();
        
        Deadlines deadlines = ((InternalTask)task).getDeadlines();

        TimerService timerService = TimerServiceRegistry.getInstance().get(deploymentId + TimerServiceRegistry.TIMER_SERVICE_SUFFIX);
        if (timerService != null && timerService instanceof GlobalTimerService) {
 
            if (type == DeadlineType.START) {
                List<Deadline> startDeadlines = deadlines.getStartDeadlines();
                List<DeadlineSummary> resultList = (List<DeadlineSummary>)persistenceContext.queryWithParametersInTransaction("UnescalatedStartDeadlinesByTaskId",
                		persistenceContext.addParametersToMap("taskId", taskId),
						ClassUtil.<List<DeadlineSummary>>castClass(List.class));
                for (DeadlineSummary summary : resultList) {
                    TaskDeadlineJob deadlineJob = new TaskDeadlineJob(summary.getTaskId(), summary.getDeadlineId(), DeadlineType.START);
                    logger.debug("unscheduling timer job for deadline {} {} and task {}  using timer service {}", deadlineJob.getId(), summary.getDeadlineId(), taskId, timerService);
                    JobHandle jobHandle = jobHandles.remove(deadlineJob.getId()); 
                    if (jobHandle == null) {        
                        jobHandle = ((GlobalTimerService) timerService).buildJobHandleForContext(new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()));
                    }
                    timerService.removeJob(jobHandle);
                    
                    for (Deadline deadline : startDeadlines) {
                        if (deadline.getId() == summary.getDeadlineId()) {
                            deadline.setEscalated(true);
                        }
                    }
                }
            } else if (type == DeadlineType.END) {
                List<Deadline> endDeadlines = deadlines.getStartDeadlines();
                List<DeadlineSummary> resultList = (List<DeadlineSummary>)persistenceContext.queryWithParametersInTransaction("UnescalatedEndDeadlinesByTaskId",
                		persistenceContext.addParametersToMap("taskId", taskId),
						ClassUtil.<List<DeadlineSummary>>castClass(List.class));
                for (DeadlineSummary summary : resultList) {
                    
                    TaskDeadlineJob deadlineJob = new TaskDeadlineJob(summary.getTaskId(), summary.getDeadlineId(), DeadlineType.END);
                    logger.debug("unscheduling timer job for deadline {} and task {}  using timer service {}", deadlineJob.getId(), taskId, timerService);
                    JobHandle jobHandle = jobHandles.remove(deadlineJob.getId()); 
                    if (jobHandle == null) {        
                        jobHandle = ((GlobalTimerService) timerService).buildJobHandleForContext(new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()));
                    }
                    timerService.removeJob(jobHandle);
                    
                    for (Deadline deadline : endDeadlines) {
                        if (deadline.getId() == summary.getDeadlineId()) {
                            deadline.setEscalated(true);
                        }
                    }
                }
            }
            
        } else {
            List<ScheduledFuture<ScheduledTaskDeadline>> knownFutures = null;
            if (type == DeadlineType.START) {
                knownFutures = startScheduledTaskDeadlines.get(taskId);
            } else if (type == DeadlineType.END) {
                knownFutures = endScheduledTaskDeadlines.get(taskId);
            }
            if (knownFutures == null) {
                return;
            }
            Iterator<ScheduledFuture<ScheduledTaskDeadline>> it = knownFutures.iterator();
            while (it.hasNext()) {
                ScheduledFuture<ScheduledTaskDeadline> scheduled = it.next();
                try {
                    if (!scheduled.isDone() && !scheduled.isCancelled()) {
                        scheduled.cancel(true);
                    }
    
                } catch (Exception e) {
                    logger.error("Error while cancelling scheduled deadline task for Task with id {} -> {}", taskId, e);
                }
            }
        }
    }

    public static class ScheduledTaskDeadline implements
            Callable<ScheduledTaskDeadline>, Serializable {

        private static final long serialVersionUID = 1L;

        private long taskId;
        private long deadlineId;
        private DeadlineType type;

        public ScheduledTaskDeadline(long taskId,
                long deadlineId, DeadlineType type) {
            this.taskId = taskId;
            this.deadlineId = deadlineId;
            this.type = type;
        }

        public long getTaskId() {
            return taskId;
        }

        public long getDeadlineId() {
            return deadlineId;
        }
        
        public DeadlineType getType() {
            return this.type;
        }

        public ScheduledTaskDeadline call() throws Exception {
        	CommandExecutor executor = TaskDeadlinesServiceImpl.getInstance();
            if (executor != null) {
                executor.execute(new ExecuteDeadlinesCommand(taskId, deadlineId, type, notificationListener));
            } else {
                logger.error("TaskDeadlineService instance is not available, most likely was not properly initialized - Job did not run!");
            }
            return null;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + (int) (deadlineId ^ (deadlineId >>> 32));
            result = prime * result + (int) (taskId ^ (taskId >>> 32));
            result = prime * result + type.hashCode();
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (!(obj instanceof ScheduledTaskDeadline)) {
                return false;
            }
            ScheduledTaskDeadline other = (ScheduledTaskDeadline) obj;
            if (deadlineId != other.deadlineId) {
                return false;
            }
            if (taskId != other.taskId) {
                return false;
            }
            if (type == null) {
                if (other.getType() != null) {
                    return false;
                }
            } else if (type.equals(other.getType())) {
                return false;
            }
            return true;
        }
    }
    
    @SuppressWarnings("unused")
    private static class TaskDeadlineJob implements Job, Serializable {

        private static final long serialVersionUID = -2453658968872574615L;
        private long taskId;
        private long deadlineId;
        private DeadlineType type;

        public TaskDeadlineJob(long taskId, long deadlineId, DeadlineType type) {
            this.taskId = taskId;
            this.deadlineId = deadlineId;
            this.type = type;
        }
        
        public long getTaskId() {
            return taskId;
        }

        public long getDeadlineId() {
            return deadlineId;
        }
        
        public DeadlineType getType() {
            return this.type;
        }
        @Override
        public void execute(JobContext ctx) {
            
            CommandExecutor executor = TaskDeadlinesServiceImpl.getInstance();
            if (executor != null) {
                executor.execute(new ExecuteDeadlinesCommand(taskId, deadlineId, type, notificationListener));
            } else {
                logger.error("TaskDeadlineService instance is not available, most likely was not properly initialized - Job did not run!");
            }            
        }
        
        public String getId() {
            return taskId +"_"+deadlineId+"_"+type;
        }
        
    }
    
    private static class TaskDeadlineJobContext implements NamedJobContext {

        private static final long serialVersionUID = -6838102884655249845L;
        private JobHandle jobHandle;
        private String jobName;
        private Long processInstanceId;
        
        public TaskDeadlineJobContext(String jobName, Long processInstanceId) {
            this.jobName = jobName;
            this.processInstanceId = processInstanceId;
        }
        
        @Override
        public void setJobHandle(JobHandle jobHandle) {
            this.jobHandle = jobHandle;
        }

        @Override
        public JobHandle getJobHandle() {
            return jobHandle;
        }

        @Override
        public String getJobName() {
            return jobName;
        }

		@Override
		public Long getProcessInstanceId() {
			return processInstanceId;
		}

        @Override
        public InternalWorkingMemory getWorkingMemory() {
            return null;
        }
    }


    public static void setNotificationListener(NotificationListener notificationListener) {
		TaskDeadlinesServiceImpl.notificationListener = notificationListener;
	}

    public static CommandExecutor getInstance() {
        return instance;
    }

    public static synchronized void initialize(CommandExecutor instance) {
    	if (instance != null) {
    	    TaskDeadlinesServiceImpl.instance = instance;
	        getInstance().execute(new InitDeadlinesCommand());
    	}        
    }
    
    public static synchronized void reset() {
    	dispose();
        scheduler = new ScheduledThreadPoolExecutor(3);        
    }

    public static synchronized void dispose() {
        try {
            if (scheduler != null) {
                scheduler.shutdownNow();
            }        
            startScheduledTaskDeadlines.clear();
            endScheduledTaskDeadlines.clear();
            jobHandles.clear();
            notificationListener = null;
            TaskDeadlinesServiceImpl.instance = null;
        } catch (Exception e) {
            logger.error("Error encountered when disposing TaskDeadlineService", e);
        }
    }
}

<code block>


package org.jbpm.services.task.impl;

import static org.kie.internal.query.QueryParameterIdentifiers.ACTUAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ASCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.BUSINESS_ADMIN_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DESCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.FILTER;
import static org.kie.internal.query.QueryParameterIdentifiers.FIRST_RESULT;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_BY;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_TYPE;
import static org.kie.internal.query.QueryParameterIdentifiers.POTENTIAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.services.task.utils.ClassUtil;
import org.kie.api.task.UserGroupCallback;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.query.QueryContext;
import org.kie.internal.query.QueryFilter;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.TaskQueryService;
import org.kie.internal.task.api.model.InternalTaskSummary;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class TaskQueryServiceImpl implements TaskQueryService {

    private static final Logger logger = LoggerFactory.getLogger(TaskQueryServiceImpl.class);
    
    private TaskPersistenceContext persistenceContext;
    private UserGroupCallback userGroupCallback;
    
    protected List<?> adoptList(List<?> source, List<?> values) {
    	
    	if (source == null || source.isEmpty()) {
    		List<Object> data = new ArrayList<Object>();    		
    		for (Object value : values) {
    			data.add(value);
    		}
    		
    		return data;
    	}
    	return source;
    }
    
    protected void applyQueryFilter(Map<String, Object> params, QueryFilter queryFilter) {
    	if (queryFilter != null) {
    	    applyQueryContext(params, queryFilter);
        	if (queryFilter.getFilterParams() != null && !queryFilter.getFilterParams().isEmpty()) {
        		params.put(FILTER, queryFilter.getFilterParams());
        		for(String key : queryFilter.getParams().keySet()){
                    params.put(key, queryFilter.getParams().get(key));
                }
        	}
        }
    }
    
    protected void applyQueryContext(Map<String, Object> params, QueryContext queryContext) {
    	if (queryContext != null) {
    	    Integer offset = queryContext.getOffset(); 
    	    if( offset != null && offset > 0 ) { 
    	        params.put(FIRST_RESULT, offset);
    	    }
    	    Integer count = queryContext.getCount();
    	    if( count != null && count > 0 ) { 
    	        params.put(MAX_RESULTS, count);
    	    }
        	
        	if (queryContext.getOrderBy() != null && !queryContext.getOrderBy().isEmpty()) {
        		params.put(ORDER_BY, queryContext.getOrderBy());
        
        		if( queryContext.isAscending() != null ) { 
        		    if (queryContext.isAscending()) {
        		        params.put(ORDER_TYPE, ASCENDING_VALUE);
        		    } else {
        		        params.put(ORDER_TYPE, DESCENDING_VALUE);
        		    }
        		}
        	}
    	}
    }
    
    private static final List<Status> allActiveStatus = new ArrayList<Status>(){{
        this.add(Status.Created);
        this.add(Status.Ready);
        this.add(Status.Reserved);
        this.add(Status.InProgress);
        this.add(Status.Suspended);
      }};

    public TaskQueryServiceImpl() {
    }
    
    public TaskQueryServiceImpl(TaskPersistenceContext persistenceContext, UserGroupCallback userGroupCallback) {
    	this.persistenceContext = persistenceContext;
    	this.userGroupCallback = userGroupCallback;
    }

    public void setPersistenceContext(TaskPersistenceContext persistenceContext) {
        this.persistenceContext = persistenceContext;
    }

    public void setUserGroupCallback(UserGroupCallback userGroupCallback) {
        this.userGroupCallback = userGroupCallback;
    }
    
    public List<TaskSummary> getTasksAssignedAsBusinessAdministrator(String userId) {
        return getTasksAssignedAsBusinessAdministratorByStatus(userId,allActiveStatus);
    }

    public List<TaskSummary> getTasksAssignedAsExcludedOwner(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsExcludedOwner", 
        		persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwner", 
        		persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds) {
        if(groupIds == null || groupIds.isEmpty()){
          return getTasksAssignedAsPotentialOwner(userId);
        }
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("groupIds", groupIds);
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerWithGroups", 
                params,
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedByGroup(String groupId) {
        if(groupId == null || groupId.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroup", 
                persistenceContext.addParametersToMap("groupId", groupId ),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedByGroupsByExpirationDateOptional(List<String> groupIds, Date expirationDate) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>)persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroupsByExpirationDateOptional", 
                persistenceContext.addParametersToMap("groupIds", groupIds, "expirationDate", expirationDate),
                ClassUtil.<List<Object[]>>castClass(List.class));
                
        return collectTasksByPotentialOwners(tasksByGroups);
    }  
    
    protected List<TaskSummary> collectTasksByPotentialOwners(List<Object[]> tasksByGroups) {
        Set<Long> tasksIds = Collections.synchronizedSet(new HashSet<Long>());
        Map<Long, List<String>> potentialOwners = Collections.synchronizedMap(new HashMap<Long, List<String>>());
        for (Object o : tasksByGroups) {
            Object[] get = (Object[]) o;
            tasksIds.add((Long) get[0]);
            if (potentialOwners.get((Long) get[0]) == null) {
                potentialOwners.put((Long) get[0], new ArrayList<String>());
            }
            potentialOwners.get((Long) get[0]).add((String) get[1]);
        }
        if (!tasksIds.isEmpty()) {
            List<TaskSummary> tasks = (List<TaskSummary>)persistenceContext.queryWithParametersInTransaction("TaskSummariesByIds", 
                    persistenceContext.addParametersToMap("taskIds", tasksIds),
                    ClassUtil.<List<TaskSummary>>castClass(List.class));
                    

            for (TaskSummary ts : tasks) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
            return tasks;
        }
        return new ArrayList<TaskSummary>();
    }
    
    public List<TaskSummary> getTasksAssignedByGroupsByExpirationDate(List<String> groupIds, Date expirationDate) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroupsByExpirationDate", 
                persistenceContext.addParametersToMap("groupIds", groupIds, "expirationDate", expirationDate),
                ClassUtil.<List<Object[]>>castClass(List.class));
        return collectTasksByPotentialOwners(tasksByGroups);
    }        
            
    public List<TaskSummary> getTasksAssignedByGroups(List<String> groupIds) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroups", 
                persistenceContext.addParametersToMap("groupIds", groupIds),
                ClassUtil.<List<Object[]>>castClass(List.class));
                
        Set<Long> tasksIds = Collections.synchronizedSet(new HashSet<Long>());
        Map<Long, List<String>> potentialOwners = Collections.synchronizedMap(new HashMap<Long, List<String>>());
        for (Object o : tasksByGroups) {
            Object[] get = (Object[]) o;
            tasksIds.add((Long) get[0]);
            if (potentialOwners.get((Long) get[0]) == null) {
                potentialOwners.put((Long) get[0], new ArrayList<String>());
            }
            potentialOwners.get((Long) get[0]).add((String) get[1]);
        }
        if (!tasksIds.isEmpty()) {
            List<TaskSummary> tasks = (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TaskSummariesByIds", 
                        persistenceContext.addParametersToMap("taskIds", tasksIds),
                        ClassUtil.<List<TaskSummary>>castClass(List.class));

            for (TaskSummary ts : tasks) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
            return tasks;
        }
        return new ArrayList<TaskSummary>();
    }

    public Map<Long, List<OrganizationalEntity>> getPotentialOwnersForTaskIds(List<Long> taskIds){
        List<Object[]> potentialOwners = persistenceContext.queryWithParametersInTransaction("GetPotentialOwnersForTaskIds", 
                persistenceContext.addParametersToMap("taskIds", taskIds),
                ClassUtil.<List<Object[]>>castClass(List.class));
        
        Map<Long, List<OrganizationalEntity>> potentialOwnersMap = new HashMap<Long, List<OrganizationalEntity>>();
        Long currentTaskId = 0L;
        for(Object[] item : potentialOwners){
            Long taskId = (Long) item[0];
            OrganizationalEntity potentialOwner = (OrganizationalEntity)item[1];
            if(currentTaskId != taskId){
                currentTaskId = taskId;
            }
            
            if(potentialOwnersMap.get(currentTaskId) == null){
                potentialOwnersMap.put(currentTaskId, new ArrayList<OrganizationalEntity>());
            }
            potentialOwnersMap.get(currentTaskId).add(potentialOwner);
        }
        
        return potentialOwnersMap;
    
    }
    
    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, int firstResult, int maxResults) {
        if(groupIds == null || groupIds.isEmpty()){
          return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwner", 
                                    persistenceContext.addParametersToMap("userId", userId, 
                                                    "firstResult", firstResult, "maxResults", maxResults),
                                                    ClassUtil.<List<TaskSummary>>castClass(List.class));
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerWithGroups", 
                                    persistenceContext.addParametersToMap("userId", userId, "groupIds", groupIds, 
                                                    "firstResult", firstResult, "maxResults", maxResults),
                                                    ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsRecipient(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsRecipient", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsTaskInitiator(String userId) {
        return (List<TaskSummary>)  persistenceContext.queryWithParametersInTransaction("TasksAssignedAsTaskInitiator", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsTaskStakeholder(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsTaskStakeholder", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksOwned(String userId) {
        return getTasksOwned(userId, null, null);

    }
    
   
    

    public List<TaskSummary> getTasksOwnedByStatus(String userId, List<Status> status) {

        List<TaskSummary> taskOwned =  getTasksOwned(userId, null, null);

        if (!taskOwned.isEmpty()) {
            Set<Long> tasksIds = new HashSet<Long>();
            for (TaskSummary ts : taskOwned) {
                tasksIds.add(ts.getId());
            }

            List<Object[]> tasksPotentialOwners = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksOwnedPotentialOwnersByTaskIds",
                        persistenceContext.addParametersToMap("taskIds", tasksIds),
                        ClassUtil.<List<Object[]>>castClass(List.class));

            Map<Long, List<String>> potentialOwners = new HashMap<Long, List<String>>();
            for (Object o : tasksPotentialOwners) {
                Object[] get = (Object[]) o;
                tasksIds.add((Long) get[0]);
                if (potentialOwners.get((Long) get[0]) == null) {
                    potentialOwners.put((Long) get[0], new ArrayList<String>());
                }
                potentialOwners.get((Long) get[0]).add((String) get[1]);
            }
            for (TaskSummary ts : taskOwned) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
        } else {
            return new ArrayList<TaskSummary>(0);
        }

        return taskOwned;
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByStatus(String userId, List<Status> status) {
        return getTasksAssignedAsPotentialOwner(userId, null, status, null);
                
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, List<Status> status, QueryFilter filter) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", adoptList(status, allActiveStatus));        
        params.put("groupIds", adoptList(groupIds, Collections.singletonList("")));
        
        applyQueryFilter(params, filter);

        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("NewTasksAssignedAsPotentialOwner", 
                                        params,
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }


    public List<TaskSummary> getTasksOwned(String userId, List<Status> status, QueryFilter filter) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        if(status == null){
            status = new ArrayList<Status>();
            status.add(Status.Reserved);
            status.add(Status.InProgress);
        }
        params.put("status", status);
        applyQueryFilter(params, filter);

        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("NewTasksOwned", 
                                        params,
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    }
    
    
    public List<TaskSummary> getSubTasksAssignedAsPotentialOwner(long parentId, String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("SubTasksAssignedAsPotentialOwner",
                                        persistenceContext.addParametersToMap("parentId", parentId, "userId", userId),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }

    public List<TaskSummary> getSubTasksByParent(long parentId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("GetSubTasksByParentTaskId", 
                persistenceContext.addParametersToMap("parentId", parentId),
                ClassUtil.<List<TaskSummary>>castClass(List.class)); 
                
    }

    public int getPendingSubTasksByParent(long parentId) {
        return  persistenceContext.queryWithParametersInTransaction("GetSubTasksByParentTaskId", 
                                persistenceContext.addParametersToMap("parentId", parentId),
                                ClassUtil.<List<TaskSummary>>castClass(List.class)).size();
    }

    public Task getTaskInstanceById(long taskId) {
        Task taskInstance = persistenceContext.findTask(taskId);
        return taskInstance;

    }

    public Task getTaskByWorkItemId(long workItemId) {
        List<Task> tasks = (List<Task>)persistenceContext.queryWithParametersInTransaction("TaskByWorkItemId", 
                                persistenceContext.addParametersToMap("workItemId", workItemId,"maxResults", 1),
                                ClassUtil.<List<Task>>castClass(List.class));
        if (tasks.isEmpty())
            return null;
        else 
            return (Task) (tasks.get(0));
    }
    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDate(String userId, List<String> groupIds,
                                            List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        
        return (List<TaskSummary>) getTasksAssignedAsPotentialOwner(userId, groupIds, status,
                new QueryFilter("t.taskData.expirationTime = :expirationDate", params, "order by t.id", false));
        
        

    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDateOptional(String userId, List<String> groupIds,
                        List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksAssignedAsPotentialOwner(userId, groupIds, status,
                new QueryFilter("(t.taskData.expirationTime = :expirationDate or t.taskData.expirationTime is null)", params, "order by t.id", false));
        
    }
    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDate(String userId,  List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksOwned(userId, status,
                new QueryFilter( "t.taskData.expirationTime = :expirationDate", params, "order by t.id", false));
        
        

    }
   

    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDateOptional(String userId, List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksOwned(userId, status,
                new QueryFilter( "(t.taskData.expirationTime = :expirationDate or t.taskData.expirationTime is null)"
                        , params, "order by t.id", false));
        
    }
    
    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDateBeforeSpecifiedDate(String userId, List<Status> status, Date date) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksOwnedWithParticularStatusByExpirationDateBeforeSpecifiedDate",
                persistenceContext.addParametersToMap("userId", userId, "status", status, "date", date),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> getTasksByStatusByProcessInstanceId(long processInstanceId, List<Status> status) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        List<TaskSummary> tasks = (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksByStatusByProcessId",
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId, 
                                        "status", status),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    
        return tasks;
    }

    @Override
    public List<TaskSummary> getTasksByStatusByProcessInstanceIdByTaskName(long processInstanceId, List<Status> status, String taskName) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }    
        List<TaskSummary> tasks = (List<TaskSummary>)persistenceContext.queryWithParametersInTransaction("TasksByStatusByProcessIdByTaskName", 
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId,
                                        "status", status, 
                                        "taskName", taskName),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    
        return tasks;
    }

    @Override
    public List<Long> getTasksByProcessInstanceId(long processInstanceId) {
        List<Long> tasks = (List<Long>)persistenceContext.queryWithParametersInTransaction("TasksByProcessInstanceId",
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId),
                ClassUtil.<List<Long>>castClass(List.class));
        return tasks;
    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDate(String userId, List<Status> status, Date expirationDate) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerStatusByExpirationDate",
                          persistenceContext.addParametersToMap("userId", userId, "groupIds", "", "status", status, "expirationDate", expirationDate),
                          ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDateOptional(String userId, List<Status> status, Date expirationDate) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerStatusByExpirationDateOptional",
                    persistenceContext.addParametersToMap("userId", userId, "groupIds", "", "status", status, "expirationDate", expirationDate),
                    ClassUtil.<List<TaskSummary>>castClass(List.class)); 
    }
   
    
    @Deprecated
    public List<TaskSummary> getTasksByVariousFields(String userId, List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
            List<String> busAdmins, List<String> potOwners, List<String> taskOwners, 
            List<Status> status,  boolean union, Integer maxResults) {
        Map<String, List<?>> params = new HashMap<String, List<?>>();
        params.put(WORK_ITEM_ID_LIST, workItemIds);
        params.put(TASK_ID_LIST, taskIds);
        params.put(PROCESS_INSTANCE_ID_LIST, procInstIds);
        params.put(BUSINESS_ADMIN_ID_LIST, busAdmins);
        params.put(POTENTIAL_OWNER_ID_LIST, potOwners);
        params.put(ACTUAL_OWNER_ID_LIST, taskOwners);
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        params.put(TASK_STATUS_LIST, status);
        
        if( maxResults != null ) {
            if( maxResults <= 0 ) { 
                return new ArrayList<TaskSummary>();
            }
            Integer [] maxResultsArr = { maxResults };
            params.put(MAX_RESULTS, Arrays.asList(maxResultsArr));
        }
        
        return getTasksByVariousFields(userId, params, union);
    }
    
    
    @Deprecated
    public List<TaskSummary> getTasksByVariousFields( String userId, Map<String, List<?>> parameters, boolean union ) { 
        QueryWhere queryWhere = new QueryWhere();
        queryWhere.setAscending(TASK_ID_LIST);
        List<?> maxResultsList = parameters.remove(MAX_RESULTS);
        if( maxResultsList != null && ! maxResultsList.isEmpty() ) { 
            Object maxResults = maxResultsList.get(0);
            if( maxResults instanceof Integer ) {
                queryWhere.setCount((Integer) maxResults);
            }
        } 
        
        
        if( union ) { 
            queryWhere.setToUnion();
        } else { 
            queryWhere.setToIntersection(); 
        }
        for( Entry<String, List<?>> paramEntry: parameters.entrySet() ) { 
            List<?> paramList = paramEntry.getValue();
            if( paramList != null && ! paramList.isEmpty() ) { 
                queryWhere.addParameter(paramEntry.getKey(), convertToTypedArray(paramList, paramList.get(0)));
            }
        }
        return query(userId, queryWhere);
    }
  
    private <T> T [] convertToTypedArray(List<?> paramList, T... firstElem) { 
        return paramList.toArray(firstElem);
    }
    
    public int getCompletedTaskByUserId(String userId) {
        List<Status> statuses = new ArrayList<Status>();
        statuses.add(Status.Completed);
        List<TaskSummary> tasksCompleted = getTasksAssignedAsPotentialOwnerByStatus(userId, statuses);
        return tasksCompleted.size();
    }

    public int getPendingTaskByUserId(String userId) {
        List<TaskSummary> tasksAssigned = getTasksAssignedAsPotentialOwner(userId, null, null, null);
        return tasksAssigned.size();
    }
    
    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByStatusByGroup(String userId, List<String> groupIds, 
                                                                        List<Status> status) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", adoptList(status, allActiveStatus));        
        params.put("groupIds", adoptList(groupIds, Collections.singletonList("")));
        
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("QuickTasksAssignedAsPotentialOwnerWithGroupsByStatus", 
        		params,
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> getTasksAssignedAsBusinessAdministratorByStatus(String userId, List<Status> status) { 
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", status);
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsBusinessAdministratorByStatus",params,
                 ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> query( String userId, Object queryObj ) {
        QueryWhere queryWhere = (QueryWhere) queryObj;
        return persistenceContext.doTaskSummaryCriteriaQuery(userId, userGroupCallback, (QueryWhere) queryWhere);
    }

}
<code block>


package org.jbpm.services.task.persistence;

import org.jbpm.services.task.impl.model.AttachmentImpl;
import org.jbpm.services.task.impl.model.BooleanExpressionImpl;
import org.jbpm.services.task.impl.model.CommentImpl;
import org.jbpm.services.task.impl.model.ContentDataImpl;
import org.jbpm.services.task.impl.model.ContentImpl;
import org.jbpm.services.task.impl.model.DeadlineImpl;
import org.jbpm.services.task.impl.model.DeadlinesImpl;
import org.jbpm.services.task.impl.model.DelegationImpl;
import org.jbpm.services.task.impl.model.EmailNotificationHeaderImpl;
import org.jbpm.services.task.impl.model.EmailNotificationImpl;
import org.jbpm.services.task.impl.model.EscalationImpl;
import org.jbpm.services.task.impl.model.FaultDataImpl;
import org.jbpm.services.task.impl.model.GroupImpl;
import org.jbpm.services.task.impl.model.I18NTextImpl;
import org.jbpm.services.task.impl.model.LanguageImpl;
import org.jbpm.services.task.impl.model.NotificationImpl;
import org.jbpm.services.task.impl.model.PeopleAssignmentsImpl;
import org.jbpm.services.task.impl.model.ReassignmentImpl;
import org.jbpm.services.task.impl.model.TaskDataImpl;
import org.jbpm.services.task.impl.model.TaskDefImpl;
import org.jbpm.services.task.impl.model.TaskImpl;
import org.jbpm.services.task.impl.model.UserImpl;
import org.jbpm.services.task.query.DeadlineSummaryImpl;
import org.jbpm.services.task.query.TaskSummaryImpl;
import org.kie.api.task.model.Attachment;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.I18NText;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.PeopleAssignments;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskData;
import org.kie.api.task.model.TaskSummary;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelFactory;
import org.kie.internal.task.api.model.BooleanExpression;
import org.kie.internal.task.api.model.ContentData;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.DeadlineSummary;
import org.kie.internal.task.api.model.Deadlines;
import org.kie.internal.task.api.model.Delegation;
import org.kie.internal.task.api.model.EmailNotification;
import org.kie.internal.task.api.model.EmailNotificationHeader;
import org.kie.internal.task.api.model.Escalation;
import org.kie.internal.task.api.model.FaultData;
import org.kie.internal.task.api.model.Language;
import org.kie.internal.task.api.model.Notification;
import org.kie.internal.task.api.model.Reassignment;
import org.kie.internal.task.api.model.TaskDef;

public class JPATaskModelFactory implements TaskModelFactory {

    @Override
    public Attachment newAttachment() {
        return new AttachmentImpl();
    }

    @Override
    public BooleanExpression newBooleanExpression() {
        return new BooleanExpressionImpl();
    }

    @Override
    public Comment newComment() {
        return new CommentImpl();
    }

    @Override
    public ContentData newContentData() {
        return new ContentDataImpl();
    }

    @Override
    public Content newContent() {
        return new ContentImpl();
    }

    @Override
    public Deadline newDeadline() {
        return new DeadlineImpl();
    }

    @Override
    public DeadlineSummary newDeadlineSummary() {
        return new DeadlineSummaryImpl();
    }

    @Override
    public Deadlines newDeadlines() {
        return new DeadlinesImpl();
    }

    @Override
    public Delegation newDelegation() {
        return new DelegationImpl();
    }

    @Override
    public EmailNotificationHeader newEmailNotificationHeader() {
        return new EmailNotificationHeaderImpl();
    }

    @Override
    public EmailNotification newEmialNotification() {
        return new EmailNotificationImpl();
    }

    @Override
    public Escalation newEscalation() {
        return new EscalationImpl();
    }

    @Override
    public FaultData newFaultData() {
        return new FaultDataImpl();
    }

    @Override
    public Group newGroup() {
        return new GroupImpl();
    }

    @Override
    public Group newGroup( String id ) {
        return new GroupImpl(id);
    }

    @Override
    public I18NText newI18NText() {
        return new I18NTextImpl();
    }

    @Override
    public Language newLanguage() {
        return new LanguageImpl();
    }

    @Override
    public Notification newNotification() {
        return new NotificationImpl();
    }

    @Override
    public OrganizationalEntity newOrgEntity() {
        throw new UnsupportedOperationException("OrganizationalEntity not supported");
    }

    @Override
    public PeopleAssignments newPeopleAssignments() {
        return new PeopleAssignmentsImpl();
    }

    @Override
    public Reassignment newReassignment() {
        return new ReassignmentImpl();
    }

    @Override
    public TaskData newTaskData() {
        return new TaskDataImpl();
    }

    @Override
    public TaskDef newTaskDef() {
        return new TaskDefImpl();
    }

    @Override
    public Task newTask() {
        return new TaskImpl();
    }

    @Override
    public User newUser() {
        return new UserImpl();
    }

    @Override
    public User newUser( String id ) {
        return new UserImpl(id);
    }

    @Override
    public TaskSummary newTaskSummary() {
        return new TaskSummaryImpl();
    }

}

<code block>
package org.jbpm.services.task.persistence;

import static org.kie.internal.query.QueryParameterIdentifiers.ACTUAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ARCHIVED;
import static org.kie.internal.query.QueryParameterIdentifiers.BUSINESS_ADMIN_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CREATED_BY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CREATED_ON_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXCLUDED_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXPIRATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.POTENTIAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_SESSION_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.SKIPPABLE;
import static org.kie.internal.query.QueryParameterIdentifiers.STAKEHOLDER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.SUB_TASKS_STRATEGY;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ACTIVATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_DESCRIPTION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_FORM_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_PARENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_PRIORITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_SUBJECT_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_USER_ROLES_LIMIT_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.From;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.ListJoin;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.Attribute;
import javax.persistence.metamodel.CollectionAttribute;
import javax.persistence.metamodel.ListAttribute;
import javax.persistence.metamodel.PluralAttribute;
import javax.persistence.metamodel.SetAttribute;
import javax.persistence.metamodel.SingularAttribute;

import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryParameterIdentifiersUtil;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.jbpm.query.jpa.impl.QueryCriteriaUtil;
import org.jbpm.services.task.impl.model.I18NTextImpl;
import org.jbpm.services.task.impl.model.I18NTextImpl_;
import org.jbpm.services.task.impl.model.OrganizationalEntityImpl;
import org.jbpm.services.task.impl.model.OrganizationalEntityImpl_;
import org.jbpm.services.task.impl.model.PeopleAssignmentsImpl;
import org.jbpm.services.task.impl.model.PeopleAssignmentsImpl_;
import org.jbpm.services.task.impl.model.TaskDataImpl;
import org.jbpm.services.task.impl.model.TaskDataImpl_;
import org.jbpm.services.task.impl.model.TaskImpl;
import org.jbpm.services.task.impl.model.TaskImpl_;
import org.jbpm.services.task.impl.model.UserImpl;
import org.jbpm.services.task.impl.model.UserImpl_;
import org.jbpm.services.task.query.TaskSummaryImpl;
import org.kie.api.task.UserGroupCallback;
import org.kie.internal.query.QueryParameterIdentifiers;

public class TaskQueryCriteriaUtil extends QueryCriteriaUtil {
    
    
    
    public final static Map<Class, Map<String, Attribute>> criteriaAttributes 
        = new ConcurrentHashMap<Class, Map<String, Attribute>>();

    @Override
    protected synchronized boolean initializeCriteriaAttributes() { 
        if( TaskImpl_.id == null ) { 
            
            
            
            return false;
        }
        
        if( ! criteriaAttributes.isEmpty() ) { 
            return true; 
        }
            
        
        addCriteria(criteriaAttributes, TASK_ACTIVATION_TIME_LIST,  TaskImpl.class, TaskDataImpl_.activationTime);
        addCriteria(criteriaAttributes, ARCHIVED,                   TaskImpl_.archived);
        addCriteria(criteriaAttributes, CREATED_ON_LIST,            TaskImpl.class, TaskDataImpl_.createdOn);
        addCriteria(criteriaAttributes, DEPLOYMENT_ID_LIST,         TaskImpl.class, TaskDataImpl_.deploymentId);
        addCriteria(criteriaAttributes, EXPIRATION_TIME_LIST,       TaskImpl.class, TaskDataImpl_.expirationTime);
        addCriteria(criteriaAttributes, TASK_FORM_NAME_LIST,        TaskImpl_.formName);
        addCriteria(criteriaAttributes, PROCESS_ID_LIST,            TaskImpl.class, TaskDataImpl_.processId); 
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_ID_LIST,   TaskImpl.class, TaskDataImpl_.processInstanceId); 
        addCriteria(criteriaAttributes, PROCESS_SESSION_ID_LIST,    TaskImpl.class, TaskDataImpl_.processSessionId); 
        addCriteria(criteriaAttributes, SKIPPABLE,                  TaskImpl.class, TaskDataImpl_.skipable); 
        addCriteria(criteriaAttributes, TASK_STATUS_LIST,           TaskImpl.class, TaskDataImpl_.status);
        addCriteria(criteriaAttributes, SUB_TASKS_STRATEGY,         TaskImpl_.subTaskStrategy);
        addCriteria(criteriaAttributes, TASK_ID_LIST,               TaskImpl_.id);
        addCriteria(criteriaAttributes, TASK_PARENT_ID_LIST,        TaskImpl.class, TaskDataImpl_.parentId);
        addCriteria(criteriaAttributes, TYPE_LIST,                  TaskImpl_.taskType);
        addCriteria(criteriaAttributes, WORK_ITEM_ID_LIST,          TaskImpl.class, TaskDataImpl_.workItemId);
        addCriteria(criteriaAttributes, TASK_PRIORITY_LIST,         TaskImpl.class, TaskImpl_.priority);
        
        addCriteria(criteriaAttributes, TASK_DESCRIPTION_LIST,      TaskImpl_.descriptions);
        addCriteria(criteriaAttributes, TASK_NAME_LIST,             TaskImpl_.names);
        addCriteria(criteriaAttributes, TASK_SUBJECT_LIST,          TaskImpl_.subjects);
        
        addCriteria(criteriaAttributes, ACTUAL_OWNER_ID_LIST,       TaskImpl.class, TaskDataImpl_.actualOwner);
        addCriteria(criteriaAttributes, CREATED_BY_LIST,            TaskImpl.class, TaskDataImpl_.createdBy); 
        
        addCriteria(criteriaAttributes, BUSINESS_ADMIN_ID_LIST,     TaskImpl.class, PeopleAssignmentsImpl_.businessAdministrators);
        addCriteria(criteriaAttributes, POTENTIAL_OWNER_ID_LIST,    TaskImpl.class, PeopleAssignmentsImpl_.potentialOwners);
        addCriteria(criteriaAttributes, STAKEHOLDER_ID_LIST,        TaskImpl.class, PeopleAssignmentsImpl_.taskStakeholders);
        addCriteria(criteriaAttributes, EXCLUDED_OWNER_ID_LIST,     TaskImpl.class, PeopleAssignmentsImpl_.excludedOwners);
        
        return true;
    }
   
    private static final Set<String> taskUserRoleLimitingListIds = new HashSet<String>();
    static { 
        taskUserRoleLimitingListIds.add(ACTUAL_OWNER_ID_LIST);
        taskUserRoleLimitingListIds.add(CREATED_BY_LIST);
        taskUserRoleLimitingListIds.add(BUSINESS_ADMIN_ID_LIST);
        taskUserRoleLimitingListIds.add(POTENTIAL_OWNER_ID_LIST);
        taskUserRoleLimitingListIds.add(STAKEHOLDER_ID_LIST);
    }

    private JPATaskPersistenceContext taskQueryService;
    
    public TaskQueryCriteriaUtil(JPATaskPersistenceContext persistenceContext) { 
        super(criteriaAttributes);
        this.taskQueryService = persistenceContext;
    }

    
    protected TaskQueryCriteriaUtil(Map<Class, Map<String, Attribute>> criteriaAttributes) {
        super(criteriaAttributes);
    }
  
    protected EntityManager getEntityManager() { 
        return this.taskQueryService.getEntityManager();
    }
  
    protected void joinTransaction() { 
        this.taskQueryService.joinTransaction();
    }
   
    protected CriteriaBuilder getCriteriaBuilder() { 
        return getEntityManager().getCriteriaBuilder();
    }

    

    @SuppressWarnings("unchecked")
    public List<TaskSummaryImpl> doCriteriaQuery(String userId, UserGroupCallback userGroupCallback, QueryWhere queryWhere) { 

        
        CriteriaBuilder builder = getCriteriaBuilder();
        CriteriaQuery<TaskSummaryImpl> criteriaQuery = builder.createQuery(TaskSummaryImpl.class);

        
        Root<TaskImpl> taskRoot = criteriaQuery.from(TaskImpl.class);
        Selection select = builder.construct(TaskSummaryImpl.class, 
                taskRoot.get(TaskImpl_.id), 
                taskRoot.get(TaskImpl_.name), 
                taskRoot.get(TaskImpl_.subject), 
                taskRoot.get(TaskImpl_.description), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.status),
                taskRoot.get(TaskImpl_.priority), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.skipable), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.actualOwner).get(UserImpl_.id),
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.createdBy).get(UserImpl_.id), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.createdOn), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.activationTime), 
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.expirationTime), 
                
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.processId), 
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.processSessionId), 
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.processInstanceId), 
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.deploymentId), 
                
                taskRoot.get(TaskImpl_.subTaskStrategy),
                taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.parentId)
                );
        criteriaQuery.select(select);
        taskRoot.join(TaskImpl_.taskData); 

        checkExistingCriteriaForUserBasedLimit(queryWhere, userId, userGroupCallback);

        
        fillCriteriaQuery(criteriaQuery, queryWhere, builder, TaskImpl.class);

        
        List<TaskSummaryImpl> result = createQueryAndCallApplyMetaCriteriaAndGetResult(queryWhere, criteriaQuery, builder);

        return result;
    } 
 
    
    private void checkExistingCriteriaForUserBasedLimit(QueryWhere queryWhere, String userId, UserGroupCallback userGroupCallback) { 
        List<String> groupIds = userGroupCallback.getGroupsForUser(userId, null, null);
        Set<String> userAndGroupIds = new HashSet<String>();
        if( groupIds != null ) { 
            userAndGroupIds.addAll(groupIds);
        }
        userAndGroupIds.add(userId);
        if( ! criteriaListForcesUserLimitation(userAndGroupIds, queryWhere.getCriteria()) ) { 
            addUserRolesLimitCriteria(queryWhere, userId, groupIds);
        }
    }

    
    private static boolean criteriaListForcesUserLimitation(Set<String> userAndGroupIds, List<QueryCriteria> criteriaList) { 
        boolean userLimitiationIntersection = false;
        if( criteriaList.isEmpty() ) { 
            return false;
        }
        for( QueryCriteria criteria : criteriaList ) { 
          if( criteria.isUnion() ) { 
              return false;
          }
          if( criteria.isGroupCriteria() ) { 
              if( criteriaListForcesUserLimitation(userAndGroupIds, criteria.getCriteria()) ) { 
                  return true;
              }
              continue;
          }
          
          if( taskUserRoleLimitingListIds.contains(criteria.getListId()) ) { 
              for( Object param : criteria.getParameters() ) { 
                  if( userAndGroupIds.contains(param) )  { 
                      return true;
                  }
              }
          }
        }
        return userLimitiationIntersection;
    }

    
    private void addUserRolesLimitCriteria( QueryWhere queryWhere, String userId, List<String> groupIds ) {
        List<QueryCriteria> newBaseCriteriaList = new ArrayList<QueryCriteria>(2);
        
        
        QueryCriteria userRolesLimitingCriteria = new QueryCriteria(
                QueryParameterIdentifiers.TASK_USER_ROLES_LIMIT_LIST, 
                false, 
                QueryCriteriaType.NORMAL, 
                2);
        userRolesLimitingCriteria.setFirst(true);
        userRolesLimitingCriteria.getValues().add(userId);
        userRolesLimitingCriteria.getValues().add(groupIds);
        newBaseCriteriaList.add(userRolesLimitingCriteria);
        
        
        if( ! queryWhere.getCriteria().isEmpty() ) { 
            QueryCriteria originalBaseCriteriaGroup = new QueryCriteria(false);
            originalBaseCriteriaGroup.setCriteria(queryWhere.getCriteria());
            newBaseCriteriaList.add(originalBaseCriteriaGroup);
        }
        
        queryWhere.setCriteria(newBaseCriteriaList);
    }

    
    @Override
    protected <T> Expression getEntityField(CriteriaQuery<T> query, String listId, Attribute attr) { 
        if( attr == null ) { 
            return null;
        }
        Root<TaskImpl> taskRoot = null;
        Join<TaskImpl, TaskDataImpl> taskDataJoin = null;
        Join<TaskImpl, PeopleAssignmentsImpl> peopAssignJoin = null;
        for( Root root : query.getRoots() ) { 
            if( TaskImpl.class.equals(root.getJavaType()) ) { 
               taskRoot = (Root<TaskImpl>) root;
               for( Join<TaskImpl, ?> join : taskRoot.getJoins() ) { 
                  if( TaskDataImpl.class.equals(join.getJavaType()) ) { 
                      taskDataJoin = (Join<TaskImpl, TaskDataImpl>) join;
                  } else if( PeopleAssignmentsImpl.class.equals(join.getJavaType()) )  { 
                      peopAssignJoin = (Join<TaskImpl, PeopleAssignmentsImpl>) join;
                  }
               }
            }
        }
        assert taskRoot != null : "Unable to find TaskImpl Root in query!";
        if( taskDataJoin == null ) { 
            taskDataJoin = taskRoot.join(TaskImpl_.taskData);
        }
        assert taskDataJoin != null : "Unable to find TaskDataImpl Join in query!";
        
        return taskImplSpecificGetEntityField(query, 
                taskRoot, taskDataJoin, peopAssignJoin,
                listId, attr);
    }
   
    @SuppressWarnings("unchecked")
    public static <T> Expression taskImplSpecificGetEntityField(CriteriaQuery<T> query,
            Root<TaskImpl> taskRoot, 
            Join<TaskImpl, TaskDataImpl> taskDataJoin,
            Join<TaskImpl, PeopleAssignmentsImpl> peopleAssignJoin,
            String listId, Attribute attr) { 
        Expression entityField = null;
       
        if( attr != null ) { 
            if( listId.equals(TASK_DESCRIPTION_LIST)
                    || listId.equals(TASK_NAME_LIST)
                    || listId.equals(TASK_SUBJECT_LIST) ) { 
                
                
                
                entityField = getJoinedEntityField(taskRoot, (Attribute<TaskImpl, I18NTextImpl>) attr, I18NTextImpl_.text);
            } else if( listId.equals(ACTUAL_OWNER_ID_LIST)
                    || listId.equals(CREATED_BY_LIST) ) { 
                if( taskDataJoin == null ) { 
                    taskDataJoin = taskRoot.join(TaskImpl_.taskData);
                }
                
                
                entityField = getJoinedEntityField(taskDataJoin, (Attribute<TaskDataImpl, UserImpl>) attr, UserImpl_.id);
            } else if( listId.equals(BUSINESS_ADMIN_ID_LIST)
                || listId.equals(POTENTIAL_OWNER_ID_LIST) 
                || listId.equals(STAKEHOLDER_ID_LIST)
                || listId.equals(EXCLUDED_OWNER_ID_LIST) ) { 
                if( peopleAssignJoin == null ) { 
                    peopleAssignJoin = taskRoot.join(TaskImpl_.peopleAssignments);
                }
                
                
                entityField = getJoinedEntityField(peopleAssignJoin, (Attribute<PeopleAssignmentsImpl, OrganizationalEntityImpl>) attr, OrganizationalEntityImpl_.id);
            } else { 
                if( taskDataJoin == null ) { 
                    taskDataJoin = taskRoot.join(TaskImpl_.taskData);
                }
                Class attrType = attr.getDeclaringType().getJavaType();
                From [] taskRoots = { taskRoot, taskDataJoin };
                for( From from : taskRoots ) { 
                    if( from.getJavaType().equals(attrType) ) {
                        if( attr != null ) { 
                            if( attr instanceof SingularAttribute ) {
                                entityField = from.get((SingularAttribute) attr);
                            } else if( attr instanceof PluralAttribute ) { 
                                entityField = from.get((PluralAttribute) attr);
                            } else { 
                                throw new IllegalStateException("Unexpected attribute type when processing criteria with list id " + listId + ": " + attr.getClass().getName() );
                            }
                            break;
                        }
                    } 
                }
            }
        }
        
        return entityField;  
    }
  
    
    @SuppressWarnings("unchecked")
    public static <F,T> Expression getJoinedEntityField(From<?, F> grandparentJoin, Attribute<?, T> parentJoinAttr, SingularAttribute fieldAttr) { 
        
        
        Join<F, T> fieldParentJoin = null; 
        for( Join<F, ?> join : grandparentJoin.getJoins() ) { 
            Class toAttrJoinType;
            if( parentJoinAttr instanceof SingularAttribute ) { 
                toAttrJoinType = parentJoinAttr.getJavaType();
            } else if( parentJoinAttr instanceof PluralAttribute ) { 
                toAttrJoinType = ((PluralAttribute) parentJoinAttr).getElementType().getJavaType();
            } else { 
                String joinName = parentJoinAttr.getDeclaringType().getJavaType().getSimpleName() + "." + parentJoinAttr.getName();
                throw new IllegalStateException("Unknown attribute type encountered when trying to join " + joinName );
            }
            
           if( join.getJavaType().equals(toAttrJoinType) ) { 
              if( join.getAttribute().equals(parentJoinAttr) )  { 
                  fieldParentJoin = (Join<F, T>) join;
                  if( ! JoinType.INNER.equals(fieldParentJoin.getJoinType()) ) { 
                      
                      
                      fieldParentJoin = null;
                  }
                  break;
              }
           }
        }
        if( fieldParentJoin == null ) { 
            if( parentJoinAttr instanceof SingularAttribute) { 
                fieldParentJoin = grandparentJoin.join((SingularAttribute) parentJoinAttr);
            } else if( parentJoinAttr instanceof CollectionAttribute) { 
                fieldParentJoin = grandparentJoin.join((CollectionAttribute) parentJoinAttr);
            } else if( parentJoinAttr instanceof ListAttribute) { 
                fieldParentJoin = grandparentJoin.join((ListAttribute) parentJoinAttr);
            } else if( parentJoinAttr instanceof SetAttribute) { 
                fieldParentJoin = grandparentJoin.join((SetAttribute) parentJoinAttr);
            } else { 
                throw new IllegalStateException("Unknown attribute type encountered when trying to join" + parentJoinAttr.getName() );
            }
        }
        return fieldParentJoin.get(fieldAttr);
    }
    
    @Override
    protected <R,T> Predicate implSpecificCreatePredicateFromSingleCriteria( 
            CriteriaQuery<R> query, 
            CriteriaBuilder builder, 
            Class queryType,
            QueryCriteria criteria, 
            QueryWhere queryWhere) {
    
        return taskSpecificCreatePredicateFromSingleCriteria(query, builder, criteria);
    }
    
    public static <Q,T> Predicate taskSpecificCreatePredicateFromSingleCriteria(
            CriteriaQuery<Q> query, 
            CriteriaBuilder builder, 
            QueryCriteria criteria) {
        Predicate predicate = null;
        if( TASK_USER_ROLES_LIMIT_LIST.equals(criteria.getListId()) ) { 
            predicate = createTaskUserRolesLimitPredicate(criteria, query, builder);
        } else { 
            throw new IllegalStateException("List id " + QueryParameterIdentifiersUtil.getQueryParameterIdNameMap().get(Integer.parseInt(criteria.getListId())) 
                    + " is not supported for queries on " + TaskImpl.class.getSimpleName() + ".");
        }
        return predicate;
    }

    @SuppressWarnings("unchecked")
    private static <T> Predicate createTaskUserRolesLimitPredicate(QueryCriteria criteria, CriteriaQuery<T> criteriaQuery, CriteriaBuilder builder) { 
            String userId = (String) criteria.getValues().get(0);
            List<String> groupIds = (List<String>) criteria.getValues().get(1);
            
        Root<TaskImpl> taskRoot = getRoot(criteriaQuery, TaskImpl.class);
        assert taskRoot != null : "TaskImpl Root instance could not be found in query!";
        
        Join<TaskImpl,TaskDataImpl> taskDataJoin = null;
        Join<TaskImpl,PeopleAssignmentsImpl> peopleAssignJoin = null;
        if( taskRoot != null ) { 
            for( Join<TaskImpl,?> join : taskRoot.getJoins() ) { 
                if( join.getJavaType().equals(PeopleAssignmentsImpl.class) ) { 
                    peopleAssignJoin = (Join<TaskImpl, PeopleAssignmentsImpl>) join;
                } else if( join.getJavaType().equals(TaskDataImpl.class) ) { 
                    taskDataJoin = (Join<TaskImpl,TaskDataImpl>) join;
                }
                
            }
        }
        assert taskDataJoin != null : "TaskImpl -> TaskDataImpl join could not be found in query!";
        
        if( peopleAssignJoin == null ) { 
            peopleAssignJoin = taskRoot.join(TaskImpl_.peopleAssignments);
        }
        
        ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl> [] groupJoins 
            = getPeopleAssignmentsJoins(peopleAssignJoin);
        
        Predicate [] userGroupLimitingPredicates = new Predicate[5];
        userGroupLimitingPredicates[0] = builder.equal(taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.actualOwner).get(UserImpl_.id), userId);
        userGroupLimitingPredicates[1] = builder.equal(taskRoot.get(TaskImpl_.taskData).get(TaskDataImpl_.createdBy).get(UserImpl_.id), userId);
    
        for( int i = 0; i < groupJoins.length; ++i ) { 
            userGroupLimitingPredicates[i+2] = builder.or( 
                    builder.equal( groupJoins[i].get(OrganizationalEntityImpl_.id), userId ), 
                    groupJoins[i].get(OrganizationalEntityImpl_.id).in(groupIds) );
        }
        
        return builder.or(userGroupLimitingPredicates);
    }

    private static ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl> [] getPeopleAssignmentsJoins(
            Join<TaskImpl,PeopleAssignmentsImpl> peopleAssignJoin) { 
        
        ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl>  [] joins = new ListJoin[3];
        
        for( Join<PeopleAssignmentsImpl,?> join : peopleAssignJoin.getJoins() ) {
            String joinFieldName = join.getAttribute().getName();
            if( PeopleAssignmentsImpl_.businessAdministrators.getName().equals(joinFieldName) ) { 
                joins[0] = (ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl>) join;
            } else if( PeopleAssignmentsImpl_.potentialOwners.getName().equals(joinFieldName) ) { 
                joins[1] = (ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl>) join;
            }  else if( PeopleAssignmentsImpl_.taskStakeholders.getName().equals(joinFieldName) ) { 
                joins[2] = (ListJoin<PeopleAssignmentsImpl,OrganizationalEntityImpl>) join;
            }
        }

        if( joins[0] == null ) { 
            joins[0] = peopleAssignJoin.join(PeopleAssignmentsImpl_.businessAdministrators, JoinType.LEFT);
        }
        if( joins[1] == null ) { 
            joins[1] = peopleAssignJoin.join(PeopleAssignmentsImpl_.potentialOwners, JoinType.LEFT);
        }
        if( joins[2] == null ) { 
            joins[2] = peopleAssignJoin.join(PeopleAssignmentsImpl_.taskStakeholders, JoinType.LEFT);
        }
        assert joins[0] != null : "Could not find business administrators join!";
        assert joins[1] != null : "Could not find potential owners join!";
        assert joins[2] != null : "Could not find task stakeholders join!"; 
        
        return joins;
    }
    
    @Override
    protected <T> List<T> createQueryAndCallApplyMetaCriteriaAndGetResult(QueryWhere queryWhere, CriteriaQuery<T> criteriaQuery, CriteriaBuilder builder) { 
        EntityManager em = getEntityManager();
        joinTransaction();
        Query query = em.createQuery(criteriaQuery);
    
        applyMetaCriteriaToQuery(query, queryWhere);
        
        
        List<T> result = query.getResultList();
    
        
        
        return result;
    }

    @Override
    protected <T,R> Expression getOrderByExpression(CriteriaQuery<R> query, Class<T> queryType, String orderByListId) { 
        Attribute attr = getCriteriaAttributes().get(queryType).get(orderByListId);
        return getEntityField(query, orderByListId, attr);
    }
   
}

<code block>


package org.jbpm.services.task.persistence;

import static org.jbpm.query.jpa.impl.QueryCriteriaUtil.convertListToInterfaceList;
import static org.jbpm.services.task.persistence.TaskQueryManager.adaptQueryString;
import static org.kie.internal.query.QueryParameterIdentifiers.FILTER;
import static org.kie.internal.query.QueryParameterIdentifiers.FIRST_RESULT;
import static org.kie.internal.query.QueryParameterIdentifiers.FLUSH_MODE;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_BY;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_TYPE;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;
import javax.persistence.FlushModeType;
import javax.persistence.Id;
import javax.persistence.LockModeType;
import javax.persistence.Query;

import org.drools.core.util.StringUtils;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.services.task.impl.model.AttachmentImpl;
import org.jbpm.services.task.impl.model.CommentImpl;
import org.jbpm.services.task.impl.model.ContentImpl;
import org.jbpm.services.task.impl.model.DeadlineImpl;
import org.jbpm.services.task.impl.model.GroupImpl;
import org.jbpm.services.task.impl.model.OrganizationalEntityImpl;
import org.jbpm.services.task.impl.model.TaskImpl;
import org.jbpm.services.task.impl.model.UserImpl;
import org.jbpm.services.task.query.TaskSummaryImpl;
import org.kie.api.task.UserGroupCallback;
import org.kie.api.task.model.Attachment;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.model.Deadline;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JPATaskPersistenceContext implements TaskPersistenceContext {

    
	public final static Logger logger = LoggerFactory.getLogger(JPATaskPersistenceContext.class);
	
	private static TaskQueryManager querymanager = TaskQueryManager.get();
	
	protected EntityManager em;
    protected final boolean isJTA;
    protected final boolean pessimisticLocking;
    
    public JPATaskPersistenceContext(EntityManager em) {
        this(em, true, false);
    }
    
    public JPATaskPersistenceContext(EntityManager em, boolean isJTA) {
       this(em, isJTA, false); 
    }
    
    public JPATaskPersistenceContext(EntityManager em, boolean isJTA, boolean locking) {
        this.em = em;
        this.isJTA = isJTA;
        this.pessimisticLocking = locking;
        
        logger.debug("TaskPersistenceManager configured with em {}, isJTA {}, pessimistic locking {}", em, isJTA, locking);
    }	

    
   
    EntityManager getEntityManager() { 
        return this.em;
    }
    
    
    
	@Override
	public Task findTask(Long taskId) {
		check();
		Task task = null;
		if( this.pessimisticLocking ) { 
			task = this.em.find( TaskImpl.class, taskId, LockModeType.PESSIMISTIC_FORCE_INCREMENT );
        }
		task = this.em.find( TaskImpl.class, taskId );
		return task;
	}

	@Override
	public Task persistTask(Task task) {
		check();
		this.em.persist( task );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(TaskImpl.class, task.getId(), LockModeType.PESSIMISTIC_FORCE_INCREMENT );
        }
        return task;
	}

	@Override
	public Task updateTask(Task task) {
		check();
		return this.em.merge(task);
	}

	@Override
	public Task removeTask(Task task) {
		check();
		em.remove( task );
		
		return task;
	}

	@Override
	public Group findGroup(String groupId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( GroupImpl.class, groupId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( GroupImpl.class, groupId );
	}

	@Override
	public Group persistGroup(Group group) {
		check();
		try {
			this.em.persist( group );
	        if( this.pessimisticLocking ) { 
	        	this.em.flush();
	            return this.em.find(GroupImpl.class, group.getId(), LockModeType.PESSIMISTIC_WRITE );
	        }
		} catch (EntityExistsException e) {
    		throw new RuntimeException("Group already exists with " + group 
    				+ " id, please check that there is no group and user with same id");
    	}
        return group;
	}

	@Override
	public Group updateGroup(Group group) {
		check();
		return this.em.merge(group);
	}

	@Override
	public Group removeGroup(Group group) {
		check();
		em.remove( group );
		return group;
	}

	@Override
	public User findUser(String userId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( UserImpl.class, userId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( UserImpl.class, userId );
	}

	@Override
	public User persistUser(User user) {
		check();
		try {
			this.em.persist( user );
	        if( this.pessimisticLocking ) { 
	        	this.em.flush();
	            return this.em.find(UserImpl.class, user.getId(), LockModeType.PESSIMISTIC_WRITE );
	        }
		} catch (EntityExistsException e) {
    		throw new RuntimeException("User already exists with " + user 
    				+ " id, please check that there is no group and user with same id");
    	}
        return user;
	}

	@Override
	public User updateUser(User user) {
		check();
		return this.em.merge(user);
	}

	@Override
	public User removeUser(User user) {
		check();
		em.remove( user );
		return user;
	}

	@Override
	public OrganizationalEntity findOrgEntity(String orgEntityId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( OrganizationalEntityImpl.class, orgEntityId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( OrganizationalEntityImpl.class, orgEntityId );
	}

	@Override
	public OrganizationalEntity persistOrgEntity(OrganizationalEntity orgEntity) {
		check();
	    	
        if (!StringUtils.isEmpty(orgEntity.getId())) {
        	try {
	        	this.em.persist( orgEntity );
	            if( this.pessimisticLocking ) { 
	            	this.em.flush();
	                return this.em.find(OrganizationalEntityImpl.class, orgEntity.getId(), LockModeType.PESSIMISTIC_WRITE );
	            }
        	} catch (EntityExistsException e) {
        		throw new RuntimeException("Organizational entity already exists with " + orgEntity 
        				+ " id, please check that there is no group and user with same id");
        	}
        } 
		
        return orgEntity;
	}

	@Override
	public OrganizationalEntity updateOrgEntity(OrganizationalEntity orgEntity) {
		check();
		return this.em.merge(orgEntity);
	}

	@Override
	public OrganizationalEntity removeOrgEntity(OrganizationalEntity orgEntity) {
		check();
		em.remove( orgEntity );
		return orgEntity;
	}

	@Override
	public Content findContent(Long contentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( ContentImpl.class, contentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( ContentImpl.class, contentId );
	}

	@Override
	public Content persistContent(Content content) {
		check();
		this.em.persist( content );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(ContentImpl.class, content.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return content;
	}

	@Override
	public Content updateContent(Content content) {
		check();
		return this.em.merge(content);
	}

	@Override
	public Content removeContent(Content content) {
		check();
		em.remove( content );
		return content;
	}

	@Override
	public Attachment findAttachment(Long attachmentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( AttachmentImpl.class, attachmentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( AttachmentImpl.class, attachmentId );
	}

	@Override
	public Attachment persistAttachment(Attachment attachment) {
		check();
		this.em.persist( attachment );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(AttachmentImpl.class, attachment.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return attachment;
	}

	@Override
	public Attachment updateAttachment(Attachment attachment) {
		check();
		return this.em.merge(attachment);
	}

	@Override
	public Attachment removeAttachment(Attachment attachment) {
		check();
		em.remove( attachment );
		return attachment;
	}

	@Override
	public Comment findComment(Long commentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( CommentImpl.class, commentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( CommentImpl.class, commentId );
	}

	@Override
	public Comment persistComment(Comment comment) {
		check();
		this.em.persist( comment );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(CommentImpl.class, comment.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return comment;
	}

	@Override
	public Comment updateComment(Comment comment) {
		check();
		return this.em.merge(comment);
	}

	@Override
	public Comment removeComment(Comment comment) {
		check();
		em.remove( comment );
		return comment;
	}

	@Override
	public Deadline findDeadline(Long deadlineId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( DeadlineImpl.class, deadlineId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( DeadlineImpl.class, deadlineId );
	}

	@Override
	public Deadline persistDeadline(Deadline deadline) {
		check();
		this.em.persist( deadline );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(DeadlineImpl.class, deadline.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return deadline;
	}

	@Override
	public Deadline updateDeadline(Deadline deadline) {	
		check();
		return this.em.merge(deadline);
	}

	@Override
	public Deadline removeDeadline(Deadline deadline) {
		check();
		em.remove( deadline );
		return deadline;
	}

	@Override
	public <T> T queryWithParametersInTransaction(String queryName,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, false, LockModeType.NONE, clazz, query);
	}

        @Override
	public <T> T queryWithParametersInTransaction(String queryName, boolean singleResult,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}
        
	@Override
	public <T> T queryAndLockWithParametersInTransaction(String queryName,
			Map<String, Object> params, boolean singleResult, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}

	@Override
	public <T> T queryInTransaction(String queryName, Class<T> clazz) {
		check();
		Query query = this.em.createNamedQuery(queryName);
		return (T) query.getResultList();
	}

	@Override
	public <T> T queryStringInTransaction(String queryString, Class<T> clazz) {
		check();
		Query query = this.em.createQuery(queryString);
		return (T) query.getResultList();
	}

	@Override
	public <T> T queryStringWithParametersInTransaction(String queryString,
			Map<String, Object> params, Class<T> clazz) {
		check();
		String newQueryString = adaptQueryString(new StringBuilder(queryString), params);
		if( newQueryString != null ) { 
		    queryString = newQueryString;
		}
		
		
		logger.debug("QUERY:\n {}", queryString);
		if( logger.isDebugEnabled() ) {
		    StringBuilder paramsStr = new StringBuilder("PARAMS:");
		    Map<String, Object> orderedParams = new TreeMap<String, Object>(params);
		    for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
		        paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
		    }
		    logger.debug(paramsStr.toString());
		}
		
		Query query = this.em.createQuery(queryString);
				
		return queryStringWithParameters(params, false, LockModeType.NONE, clazz, query);
	}
	
	@Override
	public <T> T queryStringWithParametersInTransaction(String queryString, boolean singleResult,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = this.em.createQuery(queryString);
				
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}

	
	@Override	
	public <T> T queryAndLockStringWithParametersInTransaction(
			String queryName, Map<String, Object> params, boolean singleResult,
			Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.PESSIMISTIC_WRITE, clazz, query);	
	}

	@Override
	public int executeUpdateString(String updateString) {
		check();
		Query query = this.em.createQuery(updateString);
		return query.executeUpdate();
	}

	private TaskQueryCriteriaUtil queryUtil = new TaskQueryCriteriaUtil(this);
	
    @Override   
    public List<TaskSummary> doTaskSummaryCriteriaQuery(String userId, UserGroupCallback userGroupCallback, Object queryWhere) { 
        List<TaskSummaryImpl> result = queryUtil.doCriteriaQuery(userId, userGroupCallback, (QueryWhere) queryWhere);
        return convertListToInterfaceList(result, TaskSummary.class);
    } 
    
	
	@Override
	public HashMap<String, Object> addParametersToMap(Object... parameterValues) {
		HashMap<String, Object> parameters = new HashMap<String, Object>();
        
        if( parameterValues.length % 2 != 0 ) { 
            throw new RuntimeException("Expected an even number of parameters, not " + parameterValues.length);
        }
        
        for( int i = 0; i < parameterValues.length; ++i ) {
            String parameterName = null;
            if( parameterValues[i] instanceof String ) { 
                parameterName = (String) parameterValues[i];
            } else { 
                throw new RuntimeException("Expected a String as the parameter name, not a " + parameterValues[i].getClass().getSimpleName());
            }
            ++i;
            parameters.put(parameterName, parameterValues[i]);
        }
        
        return parameters;
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T persist(T object) {
		check();
		this.em.persist( object ); 
		if( this.pessimisticLocking ) { 
			this.em.flush();
			Object primaryKey = getFieldValueWithAnnotation(object, Id.class);			
            return (T) this.em.find( object.getClass(), primaryKey, LockModeType.PESSIMISTIC_WRITE );
        }
        return object;
	}

	@Override
	public <T> T find(Class<T> entityClass, Object primaryKey) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( entityClass, primaryKey, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( entityClass, primaryKey );
	}

	@Override
	public <T> T remove(T entity) {
		check();
		em.remove( entity );
		return entity;
	}

	@Override
	public <T> T merge(T entity) {
		check();
		return this.em.merge(entity);
	}

	private <T> T queryStringWithParameters(Map<String, Object> params, boolean singleResult, LockModeType lockMode,
			Class<T> clazz, Query query) {
		
		if (lockMode != null) {
			query.setLockMode(lockMode);
		}
		if (params != null && !params.isEmpty()) {
			for (Entry<String,Object> paramEntry : params.entrySet()) {
			    String name = paramEntry.getKey();
				if (FIRST_RESULT.equals(name)) {
					query.setFirstResult((Integer) paramEntry.getValue());
					continue;
				} else if (MAX_RESULTS.equals(name)) {
					if (((Integer) paramEntry.getValue()) > -1) {
						query.setMaxResults((Integer) paramEntry.getValue());
					}
					continue;
				} else if (FLUSH_MODE.equals(name)) {
					query.setFlushMode(FlushModeType.valueOf((String) paramEntry.getValue()));
					continue;
				} 
				
				else if ( ORDER_TYPE.equals(name)
				        || ORDER_BY.equals(name)
						|| FILTER.equals(name)) {
					continue;
				}
				query.setParameter(name, params.get(name));
			}
		}
		if (singleResult) {
                    List<T> results = query.getResultList();
                    return (T) ((results.isEmpty() )? null : results.get(0));
		}
		return (T) query.getResultList();
	}

	@Override
	public boolean isOpen() {
		if (this.em == null) {
			return false;
		}
		return this.em.isOpen();
	}

	@Override
	public void joinTransaction() {
		if (this.em == null) {
			return;
		}
		if (this.isJTA) {
			this.em.joinTransaction();
		}
	}

	@Override
	public void close() {
		check();
		this.em.close();
	}
	
	protected void check() {
		if (em == null || !em.isOpen()) {
			throw new IllegalStateException("Entity manager is null or is closed, exiting...");
		}
	}
	
	protected Query getQueryByName(String queryName, Map<String, Object> params) {
		String queryStr = querymanager.getQuery(queryName, params);
		Query query = null;
		if (queryStr != null) {
			query = this.em.createQuery(queryStr);
		} else {
			query = this.em.createNamedQuery(queryName);
		}
		
		return query;
	}
	
	private Object getFieldValueWithAnnotation(Object object, Class<? extends Annotation> annotation) {
		try {
			Field[] fields = object.getClass().getDeclaredFields();
			
			for (Field f : fields) {
				if (f.isAnnotationPresent(annotation)) {
					f.setAccessible(true);
					return f.get(object);
				}
			}
		} catch (Exception e) {
			logger.error("Unable to find primary key of class {} sure to {}", object.getClass(), e.getMessage());
		}
		return null;
	}

}

<code block>

package org.jbpm.services.task.query;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.Date;
import java.util.List;

import org.kie.api.task.model.Status;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelFactory;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.InternalTaskSummary;
import org.kie.internal.task.api.model.SubTasksStrategy;

public class TaskSummaryImpl implements InternalTaskSummary {

    private long id;
    private String name = "";
    private String subject = "";
    private String description = "";
    private Status status;
    private String statusId;
    private int priority;
    private boolean skipable;
    private User actualOwner;
    private String actualOwnerId;
    private User createdBy;
    private String createdById;
    private Date createdOn;
    private Date activationTime;
    private Date expirationTime;
    private long processInstanceId;
    private String processId;
    private long processSessionId;
    private String deploymentId;
    private SubTasksStrategy subTaskStrategy;
    private long parentId;
    private List<String> potentialOwners;
    private boolean quickTaskSummary;

    public TaskSummaryImpl(long id,
            String name,
            String subject,
            String description,
            Status status,
            int priority,
            boolean skipable,
            User actualOwner,
            User createdBy,
            Date createdOn,
            Date activationTime,
            Date expirationTime,
            String processId,
            long processSessionId,
            long processInstanceId,
            String deploymentId,
            SubTasksStrategy subTaskStrategy,
            long parentId) {
        super();
        this.id = id;
        this.name = name;
        this.subject = subject;
        this.description = description;
        this.status = status;
        if (status != null) {
            this.statusId = status.name();
        }
        this.priority = priority;
        this.skipable = skipable;
        this.actualOwner = actualOwner;
        if (actualOwner != null) {
            this.actualOwnerId = actualOwner.getId();
        }
        this.createdBy = createdBy;
        if (createdBy != null) {
            this.createdById = createdBy.getId();
        }
        this.createdOn = createdOn;
        this.activationTime = activationTime;
        this.expirationTime = expirationTime;
        this.processInstanceId = processInstanceId;
        this.processId = processId;
        this.processSessionId = processSessionId;
        this.deploymentId = deploymentId;
        this.subTaskStrategy = subTaskStrategy;
        this.parentId = parentId;
        
        this.quickTaskSummary = false;
    }

    
    public TaskSummaryImpl(long id,
            String name, String subject, String description,
            Status status, int priority, boolean skipable,
            String actualOwnerId, String createdById,
            Date createdOn, Date activationTime, Date expirationTime,
            String processId, long processSessionId, long processInstanceId, String deploymentId,
            SubTasksStrategy subTaskStrategy,
            long parentId) {
        super();
        this.id = id;
        this.name = name;
        this.subject = subject;
        this.description = description;
        this.status = status;
        if (status != null) {
            this.statusId = status.name();
        }
        this.priority = priority;
        this.skipable = skipable;
        
        this.actualOwnerId = actualOwnerId;
        if( this.actualOwnerId != null && ! this.actualOwnerId.isEmpty() ) { 
            this.actualOwner = TaskModelProvider.getFactory().newUser(this.actualOwnerId);
        }
        this.createdById = createdById;
        if( this.createdById != null && ! this.createdById.isEmpty() ) { 
            this.createdBy = TaskModelProvider.getFactory().newUser(this.createdById);
        }
        
        this.createdOn = createdOn;
        this.activationTime = activationTime;
        this.expirationTime = expirationTime;
        this.processInstanceId = processInstanceId;
        this.processId = processId;
        this.processSessionId = processSessionId;
        this.deploymentId = deploymentId;
        this.subTaskStrategy = subTaskStrategy;
        this.parentId = parentId;
        
        this.quickTaskSummary = false;
    }
    
    
    public TaskSummaryImpl(long id,
            String name,
            String description,
            Status status,
            int priority,
            String actualOwner,
            String createdBy,
            Date createdOn,
            Date activationTime,
            Date expirationTime,
            String processId,
            long processInstanceId,
            long parentId,
            String deploymentId,
            boolean skipable) {
        this.id = id;
        this.processInstanceId = processInstanceId;
        this.name = name;
        this.description = description;
        this.status = status;
        if (status != null) {
            this.statusId = status.name();
        }
        this.priority = priority;
        this.actualOwnerId = actualOwner;
        this.createdById = createdBy;
        this.createdOn = createdOn;
        this.activationTime = activationTime;
        this.expirationTime = expirationTime;
        this.processId = processId;
        this.parentId = parentId;
        this.deploymentId = deploymentId;
        this.skipable = skipable;
        this.quickTaskSummary = true;
    }

    public TaskSummaryImpl() {
        
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeLong(id);

        out.writeLong(processInstanceId);

        if (name != null) {
            out.writeBoolean(true);
            out.writeUTF(name);
        } else {
            out.writeBoolean(false);
        }

        if (subject != null) {
            out.writeBoolean(true);
            out.writeUTF(subject);
        } else {
            out.writeBoolean(false);
        }

        if (description != null) {
            out.writeBoolean(true);
            out.writeUTF(description);
        } else {
            out.writeBoolean(false);
        }

        if (status != null) {
            out.writeBoolean(true);
            out.writeUTF(status.toString());
        } else {
            out.writeBoolean(false);
        }

        out.writeInt(priority);
        out.writeLong(parentId);
        out.writeBoolean(skipable);

        if (actualOwner != null) {
            out.writeBoolean(true);
            actualOwner.writeExternal(out);
        } else {
            out.writeBoolean(false);
        }

        if (createdBy != null) {
            out.writeBoolean(true);
            createdBy.writeExternal(out);
        } else {
            out.writeBoolean(false);
        }
        if (createdOn != null) {
            out.writeBoolean(true);
            out.writeLong(createdOn.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (activationTime != null) {
            out.writeBoolean(true);
            out.writeLong(activationTime.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (expirationTime != null) {
            out.writeBoolean(true);
            out.writeLong(expirationTime.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (processId != null) {
            out.writeBoolean(true);
            out.writeUTF(processId);
        } else {
            out.writeBoolean(false);
        }

        out.writeLong(processSessionId);

        if (subTaskStrategy != null) {
            out.writeBoolean(true);
            out.writeUTF(subTaskStrategy.toString());
        } else {
            out.writeBoolean(false);
        }
        
        if (actualOwnerId != null) {
            out.writeBoolean(true);
            out.writeUTF(actualOwnerId);
        } else {
            out.writeBoolean(false);
        }
        
        if (createdById != null) {
            out.writeBoolean(true);
            out.writeUTF(createdById);
        } else {
            out.writeBoolean(false);
        }
        
        if (statusId != null) {
            out.writeBoolean(true);
            out.writeUTF(statusId);
        } else {
            out.writeBoolean(false);
        }
        
        out.writeBoolean(quickTaskSummary);
    }

    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        id = in.readLong();

        processInstanceId = in.readLong();

        if (in.readBoolean()) {
            name = in.readUTF();
        }

        if (in.readBoolean()) {
            subject = in.readUTF();
        }

        if (in.readBoolean()) {
            description = in.readUTF();
        }

        if (in.readBoolean()) {
            status = Status.valueOf(in.readUTF());
        }

        priority = in.readInt();
        parentId = in.readLong();
        skipable = in.readBoolean();

        if (in.readBoolean()) {
            actualOwner = TaskModelProvider.getFactory().newUser();
            actualOwner.readExternal(in);
        }

        if (in.readBoolean()) {
            createdBy = TaskModelProvider.getFactory().newUser();
            createdBy.readExternal(in);
        }

        if (in.readBoolean()) {
            createdOn = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            activationTime = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            expirationTime = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            processId = in.readUTF();
        }

        processSessionId = in.readLong();

        if (in.readBoolean()) {
            subTaskStrategy = SubTasksStrategy.valueOf(in.readUTF());
        }
        
        if (in.readBoolean()) {
            actualOwnerId = in.readUTF();
        }
        
        if (in.readBoolean()) {
            createdById = in.readUTF();
        }
        
        if (in.readBoolean()) {
            statusId = in.readUTF();
        }
        
        quickTaskSummary = in.readBoolean();
    }

    public Long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Long getProcessInstanceId() {
        return processInstanceId;
    }

    public void setProcessInstanceId(long processInstanceId) {
        this.processInstanceId = processInstanceId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public Integer getPriority() {
        return priority;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public Boolean isSkipable() {
        return skipable;
    }

    public void setSkipable(boolean skipable) {
        this.skipable = skipable;
    }

    public User getActualOwner() {
        if(quickTaskSummary && actualOwnerId != null && !actualOwnerId.equals("")){
            actualOwner = TaskModelProvider.getFactory().newUser(actualOwnerId);
        }
        return actualOwner;
    }

    public void setActualOwner(User actualOwner) {
        this.actualOwner = actualOwner;
    }

    public User getCreatedBy() {
        if(quickTaskSummary && createdById != null && !createdById.equals("")){
            createdBy = TaskModelProvider.getFactory().newUser(createdById);
        }
        return createdBy;
    }

    public void setCreatedBy(User createdBy) {
        this.createdBy = createdBy;
    }

    public Date getCreatedOn() {
        return createdOn;
    }

    public void setCreatedOn(Date createdOn) {
        this.createdOn = createdOn;
    }

    public Date getActivationTime() {
        return activationTime;
    }

    public void setActivationTime(Date activationTime) {
        this.activationTime = activationTime;
    }

    public Date getExpirationTime() {
        return expirationTime;
    }

    public void setExpirationTime(Date expirationTime) {
        this.expirationTime = expirationTime;
    }

    public String getProcessId() {
        return processId;
    }

    public void setProcessId(String processId) {
        this.processId = processId;
    }

    public Long getProcessSessionId() {
        return processSessionId;
    }

    public void setProcessSessionId(long processSessionId) {
        this.processSessionId = processSessionId;
    }

    public SubTasksStrategy getSubTaskStrategy() {
        return subTaskStrategy;
    }

    public void setSubTaskStrategy(SubTasksStrategy subTaskStrategy) {
        this.subTaskStrategy = subTaskStrategy;
    }

    public Long getParentId() {
        return parentId;
    }

    public void setParentId(long parentId) {
        this.parentId = parentId;
    }

    public List<String> getPotentialOwners() {
        return potentialOwners;
    }

    public void setPotentialOwners(List<String> potentialOwners) {
        this.potentialOwners = potentialOwners;
    }

    public Boolean isQuickTaskSummary() {
        return quickTaskSummary;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((activationTime == null) ? 0 : activationTime.hashCode());
        result = prime * result + ((actualOwner == null) ? 0 : actualOwner.hashCode());
        result = prime * result + ((createdBy == null) ? 0 : createdBy.hashCode());
        result = prime * result + ((createdOn == null) ? 0 : createdOn.hashCode());
        result = prime * result + ((description == null) ? 0 : description.hashCode());
        result = prime * result + ((expirationTime == null) ? 0 : expirationTime.hashCode());
        result = prime * result + (int) (id ^ (id >>> 32));
        result = prime * result + (int) (processInstanceId ^ (processInstanceId >>> 32));
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((subTaskStrategy == null) ? 0 : subTaskStrategy.hashCode());
        result = prime * result + priority;
        result = prime * result + (int) (parentId ^ (parentId >>> 32));
        result = prime * result + (skipable ? 1231 : 1237);
        result = prime * result + ((status == null) ? 0 : status.hashCode());
        result = prime * result + ((subject == null) ? 0 : subject.hashCode());
        result = prime * result + ((processId == null) ? 0 : processId.hashCode());
        result = prime * result + (int) (processSessionId ^ (processSessionId >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof TaskSummaryImpl)) {
            return false;
        }
        TaskSummaryImpl other = (TaskSummaryImpl) obj;
        if (processInstanceId != other.processInstanceId) {
            return false;
        }
        if (activationTime == null) {
            if (other.activationTime != null) {
                return false;
            }
        } else if (activationTime.getTime() != other.activationTime.getTime()) {
            return false;
        }
        if (actualOwner == null) {
            if (other.actualOwner != null) {
                return false;
            }
        } else if (!actualOwner.equals(other.actualOwner)) {
            return false;
        }
        if (createdBy == null) {
            if (other.createdBy != null) {
                return false;
            }
        } else if (!createdBy.equals(other.createdBy)) {
            return false;
        }
        if (createdOn == null) {
            if (other.createdOn != null) {
                return false;
            }
        } else if (createdOn.getTime() != other.createdOn.getTime()) {
            return false;
        }
        if (description == null) {
            if (other.description != null) {
                return false;
            }
        } else if (!description.equals(other.description)) {
            return false;
        }
        if (expirationTime == null) {
            if (other.expirationTime != null) {
                return false;
            }
        } else if (expirationTime.getTime() != other.expirationTime.getTime()) {
            return false;
        }
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        if (subTaskStrategy == null) {
            if (other.subTaskStrategy != null) {
                return false;
            }
        } else if (!subTaskStrategy.equals(other.subTaskStrategy)) {
            return false;
        }
        if (priority != other.priority) {
            return false;
        }
        if (parentId != other.parentId) {
            return false;
        }
        if (skipable != other.skipable) {
            return false;
        }
        if (status == null) {
            if (other.status != null) {
                return false;
            }
        } else if (!status.equals(other.status)) {
            return false;
        }
        if (subject == null) {
            if (other.subject != null) {
                return false;
            }
        } else if (!subject.equals(other.subject)) {
            return false;
        }
        if (processId == null) {
            if (other.processId != null) {
                return false;
            }
        } else if (!processId.equals(other.processId)) {
            return false;
        }
        if (processSessionId != other.processSessionId) {
            return false;
        }
        return true;
    }

    @Override
    public String getStatusId() {
        return statusId;
    }

    @Override
    public String getActualOwnerId() {
        return actualOwnerId;
    }

    @Override
    public String getCreatedById() {
        return createdById;
    }

    @Override
    public String getDeploymentId() {
        return deploymentId;
    }

    @Override
    public String toString() {
        return "TaskSummaryImpl{" + "id=" + id + ", name=" + name + ", subject=" + subject + ", description=" + description + ", statusId=" + statusId + ", priority=" + priority + ", skipable=" + skipable + ", actualOwnerId=" + actualOwnerId + ", createdById=" + createdById + ", createdOn=" + createdOn + ", activationTime=" + activationTime + ", expirationTime=" + expirationTime + ", processInstanceId=" + processInstanceId + ", processId=" + processId + ", processSessionId=" + processSessionId + ", deploymentId=" + deploymentId + ", parentId=" + parentId + ", potentialOwners=" + potentialOwners + ", quickTaskSummary=" + quickTaskSummary + '}';
    }
    
    

}

<code block>


package org.jbpm.services.task.query;

import java.util.Date;

public class DeadlineSummaryImpl implements org.kie.internal.task.api.model.DeadlineSummary {
    private long taskId;
    private long deadlineId;
    private Date date;
    
    public DeadlineSummaryImpl() { 
        
    }
            
    public DeadlineSummaryImpl(long taskId,
                           long deadlineId,
                           Date date) {
        super();
        this.taskId = taskId;
        this.deadlineId = deadlineId;
        this.date = date;
    }
    
    public long getTaskId() {
        return taskId;
    }
    
    public void setTaskId(long taskId) {
        this.taskId = taskId;
    }
    
    public long getDeadlineId() {
        return deadlineId;
    }
    
    public void setDeadlineId(long deadlineId) {
        this.deadlineId = deadlineId;
    }
    
    public Date getDate() {
        return date;
    }
    
    public void setDate(Date date) {
        this.date = date;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((date == null) ? 0 : date.hashCode());
        result = prime * result + (int) (deadlineId ^ (deadlineId >>> 32));
        result = prime * result + (int) (taskId ^ (taskId >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if ( this == obj ) return true;
        if ( obj == null ) return false;
        if ( !(obj instanceof DeadlineSummaryImpl) ) return false;
        DeadlineSummaryImpl other = (DeadlineSummaryImpl) obj;
        if ( date == null ) {
            if ( other.date != null ) return false;
        } else if ( date.getTime() != other.date.getTime() ) return false;
        if ( deadlineId != other.deadlineId ) return false;
        if ( taskId != other.taskId ) return false;
        return true;
    }
    
    
}

<code block>


package org.jbpm.process.audit;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

import org.jbpm.process.audit.strategy.PersistenceStrategy;
import org.jbpm.process.audit.strategy.PersistenceStrategyType;
import org.jbpm.process.audit.strategy.StandaloneJtaStrategy;
import org.kie.api.runtime.Environment;
import org.kie.api.runtime.EnvironmentName;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class JPAService {

    private static final Logger logger = LoggerFactory.getLogger(JPAService.class);
    
    protected PersistenceStrategy persistenceStrategy;
    
    protected String persistenceUnitName;
    
    public JPAService(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
        EntityManagerFactory emf = null;
        try { 
           emf = Persistence.createEntityManagerFactory(persistenceUnitName); 
        } catch( Exception e ) { 
           logger.info("The '" + persistenceUnitName + "' peristence unit is not available, no persistence strategy set for " + this.getClass().getSimpleName());
        }
        if( emf != null ) { 
            persistenceStrategy = new StandaloneJtaStrategy(emf);
        }
    }
    
    public JPAService(Environment env, PersistenceStrategyType type) {
        persistenceStrategy = PersistenceStrategyType.getPersistenceStrategy(type, env);
    }
    
    public JPAService(Environment env, String peristenceUnitName) {
        EntityManagerFactory emf = (EntityManagerFactory) env.get(EnvironmentName.ENTITY_MANAGER_FACTORY);
        if( emf != null ) { 
            persistenceStrategy = new StandaloneJtaStrategy(emf);
        } else { 
            persistenceStrategy = new StandaloneJtaStrategy(Persistence.createEntityManagerFactory(persistenceUnitName));
        } 
    }
    
    public JPAService(EntityManagerFactory emf) {
        persistenceStrategy = new StandaloneJtaStrategy(emf);
    }
    
    public JPAService(EntityManagerFactory emf, PersistenceStrategyType type){
        persistenceStrategy = PersistenceStrategyType.getPersistenceStrategy(type, emf);
    }
    
    public void setPersistenceUnitName(String persistenceUnitName) {
        persistenceStrategy = new StandaloneJtaStrategy(Persistence.createEntityManagerFactory(persistenceUnitName));
        this.persistenceUnitName = persistenceUnitName;
    }

    public String getPersistenceUnitName() {
        return persistenceUnitName;
    }

    public void dispose() {
        persistenceStrategy.dispose();
    }

    
    
    protected EntityManager getEntityManager() {
        return persistenceStrategy.getEntityManager();
    }

    
    
    protected Object joinTransaction(EntityManager em) {
        return persistenceStrategy.joinTransaction(em);
    }

    
    
    protected void closeEntityManager(EntityManager em, Object transaction) {
       persistenceStrategy.leaveTransaction(em, transaction);
    }

    public <T> List<T> executeQuery(Query query, EntityManager em, Class<T> type) { 
        Object newTx = joinTransaction(em);
        List<T> result;
        try { 
            result = query.getResultList();
        } finally { 
            closeEntityManager(em, newTx);
        }
        return result;
    }
    
}

<code block>


package org.jbpm.process.audit;

import java.util.List;

import org.jbpm.process.audit.command.AuditNodeInstanceLogQueryCommand;
import org.jbpm.process.audit.command.AuditProcessInstanceLogQueryCommand;
import org.jbpm.process.audit.command.AuditVariableInstanceLogQueryCommand;
import org.jbpm.process.audit.command.ClearHistoryLogsCommand;
import org.jbpm.process.audit.command.FindActiveProcessInstancesCommand;
import org.jbpm.process.audit.command.FindNodeInstancesCommand;
import org.jbpm.process.audit.command.FindProcessInstanceCommand;
import org.jbpm.process.audit.command.FindProcessInstancesCommand;
import org.jbpm.process.audit.command.FindSubProcessInstancesCommand;
import org.jbpm.process.audit.command.FindVariableInstancesByNameCommand;
import org.jbpm.process.audit.command.FindVariableInstancesCommand;
import org.jbpm.process.audit.query.NodeInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.NodeInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.ProcInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.ProcessInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.VarInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.VarInstanceLogDeleteBuilderImpl;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.CommandExecutor;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;

public class CommandBasedAuditLogService implements AuditLogService {

    private CommandExecutor executor;
    
    public CommandBasedAuditLogService(CommandExecutor executor) { 
       this.executor = executor; 
    }
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances() {
        return executor.execute(new FindProcessInstancesCommand());
    }

    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances() {
        return executor.execute(new FindActiveProcessInstancesCommand());
    }

    @Override
    public List<ProcessInstanceLog> findProcessInstances(String processId) {
        return executor.execute(new FindProcessInstancesCommand(processId));
    }

    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances(String processId) {
        return executor.execute(new FindActiveProcessInstancesCommand(processId));
    }

    @Override
    public ProcessInstanceLog findProcessInstance(long processInstanceId) {
        return executor.execute(new FindProcessInstanceCommand(processInstanceId));
    }

    @Override
    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId) {
        return executor.execute(new FindSubProcessInstancesCommand(processInstanceId));
    }

    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId) {
        return executor.execute(new FindNodeInstancesCommand(processInstanceId));
    }

    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId) {
        return executor.execute(new FindNodeInstancesCommand(processInstanceId, nodeId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId) {
        return executor.execute(new FindVariableInstancesCommand(processInstanceId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId) {
        return executor.execute(new FindVariableInstancesCommand(processInstanceId, variableId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean activeProcesses) {
        return executor.execute(new FindVariableInstancesByNameCommand(variableId, activeProcesses));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean activeProcesses) {
        return executor.execute(new FindVariableInstancesByNameCommand(variableId, value, activeProcesses));
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery() {
        return new NodeInstLogQueryBuilderImpl(executor);
    }

    @Override
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery() {
        return new VarInstLogQueryBuilderImpl(executor);
    }

    @Override
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery() {
        return new ProcInstLogQueryBuilderImpl(executor);
    }
    
	@Override
	public ProcessInstanceLogDeleteBuilder processInstanceLogDelete() {
		return new ProcessInstanceLogDeleteBuilderImpl(executor);
	}
	
	@Override
	public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete() {
		return new NodeInstanceLogDeleteBuilderImpl(executor);
	}
	
	@Override
	public VariableInstanceLogDeleteBuilder variableInstanceLogDelete() {
		return new VarInstanceLogDeleteBuilderImpl(executor);
	}

    @Override
    @SuppressWarnings("unchecked")
    public <T, R> List<R> queryLogs( QueryWhere queryWhere, Class<T> queryClass, Class<R> resultClass ) {
        if( queryClass.equals(NodeInstanceLog.class) ) { 
            return (List<R>) executor.execute(new AuditNodeInstanceLogQueryCommand(queryWhere));
        } else if( queryClass.equals(ProcessInstanceLog.class) ) { 
            return (List<R>) executor.execute(new AuditProcessInstanceLogQueryCommand(queryWhere));
        } else if( queryClass.equals(VariableInstanceLog.class) ) { 
            return (List<R>) executor.execute(new AuditVariableInstanceLogQueryCommand(queryWhere));
        } else { 
            String type = queryClass == null ? "null" : queryClass.getName();
            throw new IllegalArgumentException("Unknown type for query:" + type );
        }
    }

    @Override
    public void clear() {
        executor.execute(new ClearHistoryLogsCommand());
    }

    @Override
    public void dispose() {
       
    }

}

<code block>


package org.jbpm.process.audit;

import static org.jbpm.query.jpa.impl.QueryCriteriaUtil.convertListToInterfaceList;
import static org.kie.internal.query.QueryParameterIdentifiers.CORRELATION_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DURATION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.END_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXTERNAL_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.FILTER;
import static org.kie.internal.query.QueryParameterIdentifiers.FIRST_RESULT;
import static org.kie.internal.query.QueryParameterIdentifiers.FLUSH_MODE;
import static org.kie.internal.query.QueryParameterIdentifiers.IDENTITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.LAST_VARIABLE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OLD_VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_BY;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_TYPE;
import static org.kie.internal.query.QueryParameterIdentifiers.OUTCOME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_VERSION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.START_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VALUE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VAL_SEPARATOR;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.FlushModeType;
import javax.persistence.NoResultException;
import javax.persistence.Query;

import org.jbpm.process.audit.query.NodeInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.NodeInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.ProcInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.ProcessInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.VarInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.VarInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.strategy.PersistenceStrategyType;
import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.jbpm.query.jpa.impl.QueryAndParameterAppender;
import org.jbpm.query.jpa.impl.QueryCriteriaUtil;
import org.kie.api.runtime.Environment;
import org.kie.api.runtime.EnvironmentName;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JPAAuditLogService extends JPAService implements AuditLogService {

    private static final Logger logger = LoggerFactory.getLogger(JPAAuditLogService.class);
   
    private static final String AUDIT_LOG_PERSISTENCE_UNIT_NAME = "org.jbpm.persistence.jpa";
    
    public JPAAuditLogService() {
        super(AUDIT_LOG_PERSISTENCE_UNIT_NAME);
    }
   
    public JPAAuditLogService(Environment env) {
        super(env, AUDIT_LOG_PERSISTENCE_UNIT_NAME);
    }
    
    public JPAAuditLogService(Environment env, PersistenceStrategyType type) {
        super(env, type);
        this.persistenceUnitName = AUDIT_LOG_PERSISTENCE_UNIT_NAME;
    }
    
    public JPAAuditLogService(EntityManagerFactory emf) {
        super(emf);
        this.persistenceUnitName = AUDIT_LOG_PERSISTENCE_UNIT_NAME;
    }
    
    public JPAAuditLogService(EntityManagerFactory emf, PersistenceStrategyType type){
        super(emf, type);
        this.persistenceUnitName = AUDIT_LOG_PERSISTENCE_UNIT_NAME;
    }
    
    
    
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances() {
        EntityManager em = getEntityManager();
        Query query = em.createQuery("FROM ProcessInstanceLog");
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances() {
        EntityManager em = getEntityManager();
        Query query = em
                .createQuery("FROM ProcessInstanceLog p WHERE p.end is null");
        return executeQuery(query, em, ProcessInstanceLog.class);
    }
    
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances(String processId) {
        EntityManager em = getEntityManager();
            Query query = em
                    .createQuery("FROM ProcessInstanceLog p WHERE p.processId = :processId")
                    .setParameter("processId", processId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances(String processId) {
        EntityManager em = getEntityManager();
        Query query = em
                .createQuery("FROM ProcessInstanceLog p WHERE p.processId = :processId AND p.end is null")
                .setParameter("processId", processId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public ProcessInstanceLog findProcessInstance(long processInstanceId) {
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        try {
        	return (ProcessInstanceLog) em
        	        .createQuery("FROM ProcessInstanceLog p WHERE p.processInstanceId = :processInstanceId")
        	        .setParameter("processInstanceId", processInstanceId).getSingleResult();
        } catch (NoResultException e) {
        	return null;
        } finally {
        	closeEntityManager(em, newTx);
        }
    }
    
    
    @Override
    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM ProcessInstanceLog p WHERE p.parentProcessInstanceId = :processInstanceId")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }
    
    
    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM NodeInstanceLog n WHERE n.processInstanceId = :processInstanceId ORDER BY date,id")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, NodeInstanceLog.class);
    }

    
    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM NodeInstanceLog n WHERE n.processInstanceId = :processInstanceId AND n.nodeId = :nodeId ORDER BY date,id")
                .setParameter("processInstanceId", processInstanceId)
                .setParameter("nodeId", nodeId);
        return executeQuery(query, em, NodeInstanceLog.class);
    }

    
    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM VariableInstanceLog v WHERE v.processInstanceId = :processInstanceId ORDER BY date")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }

    
    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM VariableInstanceLog v WHERE v.processInstanceId = :processInstanceId AND v.variableId = :variableId ORDER BY date")
                .setParameter("processInstanceId", processInstanceId)
                .setParameter("variableId", variableId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }


    @Override
    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean onlyActiveProcesses) {
        EntityManager em = getEntityManager();
        Query query;
        if( ! onlyActiveProcesses ) { 
             query = em.createQuery("FROM VariableInstanceLog v WHERE v.variableId = :variableId ORDER BY date");
        } else { 
            query = em.createQuery(
                    "SELECT v "
                    + "FROM VariableInstanceLog v, ProcessInstanceLog p "
                    + "WHERE v.processInstanceId = p.processInstanceId "
                    + "AND v.variableId = :variableId "
                    + "AND p.end is null "
                    + "ORDER BY v.date");
        }
        query.setParameter("variableId", variableId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean onlyActiveProcesses) {
        EntityManager em = getEntityManager();
        Query query;
        if( ! onlyActiveProcesses ) { 
             query = em.createQuery("FROM VariableInstanceLog v WHERE v.variableId = :variableId AND v.value = :value ORDER BY date");
        } else { 
            query = em.createQuery(
                    "SELECT v "
                    + "FROM VariableInstanceLog v, ProcessInstanceLog p "
                    + "WHERE v.processInstanceId = p.processInstanceId "
                    + "AND v.variableId = :variableId "
                    + "AND v.value = :value "
                    + "AND p.end is null "
                    + "ORDER BY v.date");
        }
        query.setParameter("variableId", variableId).setParameter("value", value);
        
        return executeQuery(query, em, VariableInstanceLog.class);
    }
    
    
    @Override
    public void clear() {
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        try {
	        List<ProcessInstanceLog> processInstances = em.createQuery("FROM ProcessInstanceLog").getResultList();
	        for (ProcessInstanceLog processInstance: processInstances) {
	            em.remove(processInstance);
	        }
	        List<NodeInstanceLog> nodeInstances = em.createQuery("FROM NodeInstanceLog").getResultList();
	        for (NodeInstanceLog nodeInstance: nodeInstances) {
	            em.remove(nodeInstance);
	        }
	        List<VariableInstanceLog> variableInstances = em.createQuery("FROM VariableInstanceLog").getResultList();
	        for (VariableInstanceLog variableInstance: variableInstances) {
	            em.remove(variableInstance);
	        }
        } finally {
        	closeEntityManager(em, newTx);
        }
    }
    
    
  
    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery() {
        return new NodeInstLogQueryBuilderImpl(this);
    }

    @Override
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery() {
        return new VarInstLogQueryBuilderImpl(this);
    }

    @Override
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery() {
        return new ProcInstLogQueryBuilderImpl(this);
    }
    
	@Override
	public ProcessInstanceLogDeleteBuilder processInstanceLogDelete() {
		return new ProcessInstanceLogDeleteBuilderImpl(this);
	} 
	
	@Override
    public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete() {
        return new NodeInstanceLogDeleteBuilderImpl(this);
    }
	
	@Override
    public VariableInstanceLogDeleteBuilder variableInstanceLogDelete() {
        return new VarInstanceLogDeleteBuilderImpl(this);
    }
    
    
   
    @Override
    public <T,R> List<R> queryLogs(QueryWhere queryData, Class<T> queryClass, Class<R> resultClass ) {
        List<T> results = doQuery(queryData, queryClass);
        return convertListToInterfaceList(results, resultClass);
    }

    private final AuditQueryCriteriaUtil queryUtil = new AuditQueryCriteriaUtil(this);
   
    protected QueryCriteriaUtil getQueryCriteriaUtil(Class queryType) { 
        return queryUtil;
    }
    
    
    public <T> List<T> doQuery(QueryWhere queryWhere, Class<T> queryType) { 
       return getQueryCriteriaUtil(queryType).doCriteriaQuery(queryWhere, queryType);
    }
    
    public static String NODE_INSTANCE_LOG_DELETE = 
            "DELETE "
            + "FROM NodeInstanceLog l\n";

	public static String VARIABLE_INSTANCE_LOG_DELETE = 
	            "DELETE "
	            + "FROM VariableInstanceLog l\n";
	
	public static String PROCESS_INSTANCE_LOG_DELETE = 
	            "DELETE "
	            + "FROM ProcessInstanceLog l\n";
	 
   
    public static Map<String, String> criteriaFields = new ConcurrentHashMap<String, String>();
    public static Map<String, Class<?>> criteriaFieldClasses = new ConcurrentHashMap<String, Class<?>>();
    
    static { 
        addCriteria(PROCESS_INSTANCE_ID_LIST, "l.processInstanceId", Long.class);
        addCriteria(PROCESS_ID_LIST, "l.processId", String.class);
        addCriteria(WORK_ITEM_ID_LIST, "l.workItemId", Long.class);
        addCriteria(EXTERNAL_ID_LIST, "l.externalId", String.class);
        
        
        addCriteria(START_DATE_LIST, "l.start", Date.class);
        addCriteria(DURATION_LIST, "l.duration", Long.class);
        addCriteria(END_DATE_LIST, "l.end", Date.class);
        addCriteria(IDENTITY_LIST, "l.identity", String.class);
        addCriteria(PROCESS_NAME_LIST, "l.processName", String.class);
        addCriteria(PROCESS_VERSION_LIST, "l.processVersion", String.class);
        addCriteria(PROCESS_INSTANCE_STATUS_LIST, "l.status", Integer.class);
        addCriteria(OUTCOME_LIST, "l.outcome", String.class);
        addCriteria(CORRELATION_KEY_LIST, "l.correlationKey", String.class);
        
        
        addCriteria(NODE_ID_LIST, "l.nodeId", String.class);
        addCriteria(NODE_INSTANCE_ID_LIST, "l.nodeInstanceId", String.class);
        addCriteria(NODE_NAME_LIST, "l.nodeName", String.class);
        addCriteria(TYPE_LIST, "l.nodeType", String.class);
        
        
        addCriteria(DATE_LIST, "l.date", Date.class);
        addCriteria(OLD_VALUE_LIST, "l.oldValue", String.class);
        addCriteria(VALUE_LIST, "l.value", String.class);
        addCriteria(VARIABLE_ID_LIST, "l.variableId", String.class);
        addCriteria(VARIABLE_INSTANCE_ID_LIST, "l.variableInstanceId", String.class);
       
    }
   
    protected static void addCriteria( String listId, String fieldName, Class type ) { 
        criteriaFields.put(listId, fieldName);
        criteriaFieldClasses.put(listId, type );
    }
   
    
    public <T> List<T> doQuery(QueryData queryData, Class<T> resultType) { 
        
        String queryBase;
        if( ProcessInstanceLog.class.equals(resultType) ) { 
            queryBase = PROCESS_INSTANCE_LOG_QUERY;
        } else if( VariableInstanceLog.class.equals(resultType) ) { 
            queryBase = VARIABLE_INSTANCE_LOG_QUERY;
        } else if( NodeInstanceLog.class.equals(resultType) ) { 
            queryBase = NODE_INSTANCE_LOG_QUERY;
        } else { 
            throw new IllegalStateException("Unsupported result type: " + resultType.getName() );
        }        
        return doQuery(queryBase, queryData, resultType);
    }
    
    public <T> List<T> doQuery(String queryBase, QueryData queryData, Class<T> resultType) { 
        
       
        Map<String, Object> queryParams = new HashMap<String, Object>();
        
        String queryString = createQuery(queryBase, queryData, queryParams);
        
        
        logger.debug("QUERY:\n {}", queryString);
        if( logger.isDebugEnabled() ) {
            StringBuilder paramsStr = new StringBuilder("PARAMS:");
            Map<String, Object> orderedParams = new TreeMap<String, Object>(queryParams);
            for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
                paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
            }
            logger.debug(paramsStr.toString());
        }
    
        
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(queryString);

        
        queryParams.put(FIRST_RESULT, queryData.getQueryContext().getOffset());
        queryParams.put(MAX_RESULTS, queryData.getQueryContext().getCount());
       
        
        List<T> result = queryWithParameters(queryParams, LockModeType.NONE, resultType, query);
        
        closeEntityManager(em, newTx);
        
        return result;
    }
    
    public int doDelete(QueryData queryData, Class<?> resultType) { 
    	String queryBase;
        if( ProcessInstanceLog.class.equals(resultType) ) { 
            queryBase = PROCESS_INSTANCE_LOG_DELETE;
        } else if( VariableInstanceLog.class.equals(resultType) ) { 
            queryBase = VARIABLE_INSTANCE_LOG_DELETE;
        } else if( NodeInstanceLog.class.equals(resultType) ) { 
            queryBase = NODE_INSTANCE_LOG_DELETE;
        } else { 
            throw new IllegalStateException("Unsupported entity type: " + resultType.getName() );
        }
        return doDelete(queryBase, queryData, resultType);
    }
    
    public int doDelete(String queryBase, QueryData queryData, Class<?> resultType) { 
        
        
        Map<String, Object> queryParams = new HashMap<String, Object>();
        String queryString = createQuery(queryBase, queryData, queryParams, true);
        
        
        logger.debug("DELETE statement:\n {}", queryString);
        if( logger.isDebugEnabled() ) {
            StringBuilder paramsStr = new StringBuilder("PARAMS:");
            Map<String, Object> orderedParams = new TreeMap<String, Object>(queryParams);
            for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
                paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
            }
            logger.debug(paramsStr.toString());
        }
        
    
        
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(queryString);
    
        int result = executeWithParameters(queryParams, query);
        
        closeEntityManager(em, newTx);
        
        return result;
    }

    private static String createQuery(String queryBase, QueryData queryData, Map<String, Object> queryParams) {
    	return createQuery(queryBase, queryData, queryParams, false);
    }
    
    private static String createQuery(String queryBase, QueryData queryData, Map<String, Object> queryParams, boolean skipMetaParams) { 
        
        StringBuilder queryBuilder = new StringBuilder(queryBase);
        QueryAndParameterAppender queryAppender = new QueryAndParameterAppender(queryBuilder, queryParams);

        
        ServiceLoader<QueryModificationService> queryModServiceLdr = ServiceLoader.load(QueryModificationService.class);
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addTablesToQuery(queryBuilder, queryData);
        }
      
        
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addCriteriaToQuery(queryData, queryAppender);
        }
        
        boolean addLastCriteria = false;
        List<Object[]> varValCriteriaList = new ArrayList<Object[]>();
        
        
        if( ! queryData.unionParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getUnionParameters().remove(VAR_VALUE_ID_LIST), true, false, varValCriteriaList);
            if( queryData.getUnionParameters().remove(LAST_VARIABLE_LIST) != null ) { 
                addLastCriteria = true;
            }
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getIntersectParameters().remove(VAR_VALUE_ID_LIST), false, false, varValCriteriaList);
            if( queryData.getIntersectParameters().remove(LAST_VARIABLE_LIST) != null ) { 
                addLastCriteria = true;
            }
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        false);
            }
        }
        
        if( ! queryData.unionRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRangeQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRangeQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        false);
            }
        }
        
        if( ! queryData.unionRegexParametersAreEmpty() ) { 
            checkVarValCriteria(queryData.getUnionRegexParameters().remove(VAR_VALUE_ID_LIST), true, true, varValCriteriaList);
            for( Entry<String, List<String>> paramsEntry : queryData.getUnionRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRegexQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectRegexParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getIntersectRegexParameters().remove(VAR_VALUE_ID_LIST), false, true, varValCriteriaList);
            for( Entry<String, List<String>> paramsEntry : queryData.getIntersectRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRegexQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFields.get(listId), 
                        false);
            }
        }
        
        while( queryAppender.getParenthesesNesting() > 0 ) { 
            queryAppender.closeParentheses();
        }
        
        
        boolean addWhereClause = ! queryAppender.hasBeenUsed();
        if( ! varValCriteriaList.isEmpty() ) { 
            addVarValCriteria(addWhereClause, queryAppender, "l", varValCriteriaList);
            addWhereClause = false;
        }
        if( addLastCriteria ) { 
            addLastInstanceCriteria(queryAppender);
        }
       if (!skipMetaParams) {
	        
	        applyMetaCriteria(queryBuilder, queryData);
       }
        
        return queryBuilder.toString();
    }

    public static void checkVarValCriteria(List<String> varValList, boolean union, boolean regex, List<Object[]> varValCriteriaList) { 
        if( varValList == null || varValList.isEmpty() ) { 
            return;
        }
        for( Object varVal : varValList ) { 
            String [] parts = ((String) varVal).split(VAR_VAL_SEPARATOR, 2);
            String varId = parts[1].substring(0,Integer.parseInt(parts[0]));
            String val = parts[1].substring(Integer.parseInt(parts[0])+1);
            int type = ( union ? 0 : 1 ) + ( regex ? 2 : 0);
            Object [] varValCrit = { type, varId, val };
            varValCriteriaList.add(varValCrit);
        }
    }
    
    public static void addVarValCriteria(
            boolean addWhereClause, 
            QueryAndParameterAppender queryAppender, 
            String tableId,
            List<Object []> varValCriteriaList) { 
        
       
       for( Object [] varValCriteria : varValCriteriaList ) { 

           boolean union = (((Integer) varValCriteria[0]) % 2 == 0);
         
           
           String varIdQueryParamName = queryAppender.generateParamName();
           queryAppender.addNamedQueryParam(varIdQueryParamName, varValCriteria[1]);
           
           StringBuilder queryPhraseBuilder = new StringBuilder(" ( ")
               .append(tableId).append(".variableId = :").append(varIdQueryParamName).append(" ");
           
           
           queryPhraseBuilder.append("AND ").append(tableId).append(".value ");
           String valQueryParamName = queryAppender.generateParamName();
           String val;
           if( ((Integer) varValCriteria[0]) >= 2 ) { 
               val = ((String) varValCriteria[2]).replace('*', '%').replace('.', '_');
               queryPhraseBuilder.append("like :").append(valQueryParamName);
           } else { 
               val = (String) varValCriteria[2];
              queryPhraseBuilder.append("= :").append(valQueryParamName);
           }
           queryPhraseBuilder.append(" ) ");
      
           String [] valArr = { val };
           queryAppender.addToQueryBuilder(queryPhraseBuilder.toString(), union, valQueryParamName, Arrays.asList(valArr) );
       }
    }
    
    private static void addLastInstanceCriteria(QueryAndParameterAppender queryAppender) { 
       String lastQueryPhrase = new StringBuilder("(l.id IN ")
           .append("(SELECT MAX(ll.id) FROM VariableInstanceLog ll GROUP BY ll.variableId, ll.processInstanceId)")
           .append(") ").toString();
      queryAppender.addToQueryBuilder(lastQueryPhrase, false); 
    }
    
    private static void applyMetaCriteria(StringBuilder queryBuilder, QueryData queryData) { 
        queryBuilder
            .append(" \n ORDER by ")
            .append(adaptOrderBy(queryData.getQueryContext().getOrderBy()));
        Boolean ascending = queryData.getQueryContext().isAscending();
        if( ascending == null || ascending ) { 
            queryBuilder.append(" ").append(ASCENDING_VALUE);
        } else { 
            queryBuilder.append(" ").append(DESCENDING_VALUE);
        } 
    }
    
    private static String adaptOrderBy(String orderBy) {
        if("processInstanceId".equals(orderBy)) { 
            return "l.processInstanceId";
        } else if ("processId".equals(orderBy)) {
            return "l.processId";
        } else if( orderBy == null ) { 
            return "l.id";
        } else { 
            throw new IllegalArgumentException("Unknown order by parameter: '" + orderBy + "'");
        }
    }

    private void applyMetaQueryParameters(Map<String, Object> params, Query query) {
        if (params != null && !params.isEmpty()) {
            for (String name : params.keySet()) {
                Object paramVal = params.get(name);
                if( paramVal == null ) { 
                    continue;
                }
                if (FIRST_RESULT.equals(name)) {
                    if( ((Integer) paramVal) > 0 ) { 
                        query.setFirstResult((Integer) params.get(name));
                    }
                    continue;
                }
                if (MAX_RESULTS.equals(name)) {
                    if( ((Integer) paramVal) > 0 ) { 
                        query.setMaxResults((Integer) params.get(name));
                    }
                    continue;
                }
                if (FLUSH_MODE.equals(name)) {
                    query.setFlushMode(FlushModeType.valueOf((String) params.get(name)));
                    continue;
                }
                else if (ORDER_TYPE.equals(name) 
                        || ORDER_BY.equals(name)
                        || FILTER.equals(name)) {
                    continue;
                }
                query.setParameter(name, params.get(name));
            }
        } 
    }
    
    private <T> List<T> queryWithParameters(Map<String, Object> params, LockModeType lockMode, Class<T> clazz, Query query) {
        if (lockMode != null) {
            query.setLockMode(lockMode);
        }
        applyMetaQueryParameters(params, query);
        return query.getResultList();
    } 
    
    private int executeWithParameters(Map<String, Object> params, Query query) {
        applyMetaQueryParameters(params, query);
        return query.executeUpdate();
    }


}

<code block>
package org.jbpm.process.audit;

import static org.jbpm.query.jpa.data.QueryParameterIdentifiersUtil.*;
import static org.kie.internal.query.QueryParameterIdentifiers.CORRELATION_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DURATION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.END_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXTERNAL_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.IDENTITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.LAST_VARIABLE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OLD_VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OUTCOME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_PARENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_VERSION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.START_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VALUE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VAL_SEPARATOR;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Subquery;
import javax.persistence.metamodel.Attribute;
import javax.persistence.metamodel.SingularAttribute;

import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.jbpm.query.jpa.impl.QueryCriteriaUtil;

public class AuditQueryCriteriaUtil extends QueryCriteriaUtil {

    
    
    public final static Map<Class, Map<String, Attribute>> criteriaAttributes 
        = new ConcurrentHashMap<Class, Map<String, Attribute>>();

    @Override
    protected synchronized boolean initializeCriteriaAttributes() { 
        if( ProcessInstanceLog_.correlationKey == null ) { 
            
            
            
            return false;
        }
        
        if( ! criteriaAttributes.isEmpty() ) { 
           return true; 
        }
        
        
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_ID_LIST, ProcessInstanceLog_.processInstanceId);
        addCriteria(criteriaAttributes, PROCESS_ID_LIST, ProcessInstanceLog_.processId);
        addCriteria(criteriaAttributes, START_DATE_LIST, ProcessInstanceLog_.start);
        addCriteria(criteriaAttributes, END_DATE_LIST, ProcessInstanceLog_.end);
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_STATUS_LIST, ProcessInstanceLog_.status);
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_PARENT_ID_LIST, ProcessInstanceLog_.parentProcessInstanceId);
        addCriteria(criteriaAttributes, OUTCOME_LIST, ProcessInstanceLog_.outcome);
        addCriteria(criteriaAttributes, DURATION_LIST, ProcessInstanceLog_.duration);
        addCriteria(criteriaAttributes, IDENTITY_LIST, ProcessInstanceLog_.identity);
        addCriteria(criteriaAttributes, PROCESS_VERSION_LIST, ProcessInstanceLog_.processVersion);
        addCriteria(criteriaAttributes, PROCESS_NAME_LIST, ProcessInstanceLog_.processName);
        addCriteria(criteriaAttributes, CORRELATION_KEY_LIST, ProcessInstanceLog_.correlationKey);
        addCriteria(criteriaAttributes, EXTERNAL_ID_LIST, ProcessInstanceLog_.externalId);
        
        
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_ID_LIST, NodeInstanceLog_.processInstanceId);
        addCriteria(criteriaAttributes, PROCESS_ID_LIST, NodeInstanceLog_.processId);
        addCriteria(criteriaAttributes, EXTERNAL_ID_LIST, NodeInstanceLog_.externalId);
        addCriteria(criteriaAttributes, DATE_LIST, NodeInstanceLog_.date);
        
        addCriteria(criteriaAttributes, NODE_INSTANCE_ID_LIST, NodeInstanceLog_.nodeInstanceId);
        addCriteria(criteriaAttributes, NODE_ID_LIST, NodeInstanceLog_.nodeId);
        addCriteria(criteriaAttributes, NODE_NAME_LIST, NodeInstanceLog_.nodeName);
        addCriteria(criteriaAttributes, TYPE_LIST, NodeInstanceLog_.nodeType);
        addCriteria(criteriaAttributes, WORK_ITEM_ID_LIST, NodeInstanceLog_.workItemId);
        
        
        addCriteria(criteriaAttributes, PROCESS_INSTANCE_ID_LIST, VariableInstanceLog_.processInstanceId);
        addCriteria(criteriaAttributes, PROCESS_ID_LIST, VariableInstanceLog_.processId);
        addCriteria(criteriaAttributes, DATE_LIST, VariableInstanceLog_.date);
        addCriteria(criteriaAttributes, EXTERNAL_ID_LIST, VariableInstanceLog_.externalId);
        
        addCriteria(criteriaAttributes, VARIABLE_INSTANCE_ID_LIST, VariableInstanceLog_.variableInstanceId);
        addCriteria(criteriaAttributes, VARIABLE_ID_LIST, VariableInstanceLog_.variableId);
        addCriteria(criteriaAttributes, VALUE_LIST, VariableInstanceLog_.value);
        addCriteria(criteriaAttributes, OLD_VALUE_LIST, VariableInstanceLog_.oldValue);
        
        return true;
    }
   
    
    
    protected JPAService jpaService;
    
    public AuditQueryCriteriaUtil(JPAService service) { 
        super(criteriaAttributes);
        this.jpaService = service;
    }
 
    
    protected AuditQueryCriteriaUtil(Map<Class, Map<String, Attribute>> criteriaAttributes, JPAService service) { 
        super(criteriaAttributes);
        this.jpaService = service;
    }
    
    protected EntityManager getEntityManager() { 
        return this.jpaService.getEntityManager();
    }
  
    protected Object joinTransaction(EntityManager em) { 
        return this.jpaService.joinTransaction(em);
    }
   
    protected void closeEntityManager(EntityManager em, Object transaction) {
        this.jpaService.closeEntityManager(em, transaction);
    }
  
    
   
    protected CriteriaBuilder getCriteriaBuilder() { 
        return getEntityManager().getCriteriaBuilder();
    }

    @Override
    protected <T> List<T> createQueryAndCallApplyMetaCriteriaAndGetResult(QueryWhere queryWhere, CriteriaQuery<T> criteriaQuery, CriteriaBuilder builder) { 
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(criteriaQuery);
    
        applyMetaCriteriaToQuery(query, queryWhere);
        
        
        List<T> result = query.getResultList();

        closeEntityManager(em, newTx);
        
        return result;
    }

    @Override
    @SuppressWarnings("unchecked")
    protected <R,T> Predicate implSpecificCreatePredicateFromSingleCriteria( 
            CriteriaQuery<R> query, 
            CriteriaBuilder builder, 
            Class queryType,
            QueryCriteria criteria, 
            QueryWhere queryWhere) {
       
        Root<?> table = getRoot(query, queryType);
      
        return variableInstanceLogSpecificCreatePredicateFromSingleCriteria(query, builder, criteria, table);
    }
    
    @SuppressWarnings("unchecked")
    public static <Q,T> Predicate variableInstanceLogSpecificCreatePredicateFromSingleCriteria(
            CriteriaQuery<Q> query, 
            CriteriaBuilder builder, 
            QueryCriteria criteria, 
            Root<T> table) {
            
        Predicate predicate;
        if( LAST_VARIABLE_LIST.equals(criteria.getListId()) ) {
            Subquery<VariableInstanceLog> maxIdSubQuery = query.subquery(VariableInstanceLog.class);
            Root from = maxIdSubQuery.from(VariableInstanceLog.class);
            maxIdSubQuery.select(builder.max(from.get(VariableInstanceLog_.id)));
            maxIdSubQuery.groupBy(
                    from.get(VariableInstanceLog_.variableId), 
                    from.get(VariableInstanceLog_.processInstanceId));
            Attribute varIdField = VariableInstanceLog_.id;
            
            
            
            
          
            Expression expr;
            if( varIdField instanceof SingularAttribute ) { 
                expr = table.get((SingularAttribute<T,?>)varIdField);
            } else { 
                throw new IllegalStateException("Unexpected " + varIdField.getClass().getName() + " when processing last variable query criteria!");
            }
            predicate = builder.in(expr).value(maxIdSubQuery);
        } else if( VAR_VALUE_ID_LIST.equals(criteria.getListId()) ) { 
            assert criteria.getValues().size() == 1 : "Only 1 var id/value parameter expected!";
            
            
            Object varVal = criteria.getValues().get(0);
            String [] parts = ((String) varVal).split(VAR_VAL_SEPARATOR, 2);
            String varId = parts[1].substring(0,Integer.parseInt(parts[0]));
            String val = parts[1].substring(Integer.parseInt(parts[0])+1);
            
            
            SingularAttribute varVarIdField = VariableInstanceLog_.variableId;
            Path varVarIdPath = table.get(varVarIdField);
            SingularAttribute varValField = VariableInstanceLog_.value;
            Path varValIdPath = table.get(varValField);
            
            Predicate varIdPredicate = builder.equal(varVarIdPath, varId);
            Predicate valPredicate;
            if( QueryCriteriaType.REGEXP.equals(criteria.getType()) ) { 
                val = convertRegexToJPALikeExpression(val);
                valPredicate = builder.like(varValIdPath, val);
            } else { 
                valPredicate = builder.equal(varValIdPath, val);
            }
            
            
            predicate = builder.and(varIdPredicate, valPredicate);
        } else { 
            throw new IllegalStateException("List id [" + getQueryParameterIdNameMap().get(Integer.parseInt(criteria.getListId())) 
                   + "] is not supported for queries on " + table.getJavaType().getSimpleName() + ".");
        }
        return predicate;
    }

}

<code block>


package org.jbpm.process.audit;

import java.util.List;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.manager.audit.AuditService;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;


public interface AuditLogService extends AuditService {

    
	@Override
    public List<ProcessInstanceLog> findProcessInstances();

    public List<ProcessInstanceLog> findActiveProcessInstances();
    
    public List<ProcessInstanceLog> findProcessInstances(String processId);

    public List<ProcessInstanceLog> findActiveProcessInstances(String processId);

    public ProcessInstanceLog findProcessInstance(long processInstanceId);

    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId);

    public List<NodeInstanceLog> findNodeInstances(long processInstanceId);

    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId);

    public List<VariableInstanceLog> findVariableInstances(long processInstanceId);

    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId);

    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean onlyActiveProcesses);
    
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean onlyActiveProcesses);
    
    
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery();
    
    
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery();
    
    
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery();
    
    public ProcessInstanceLogDeleteBuilder processInstanceLogDelete();
    
    public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete();
    
    public VariableInstanceLogDeleteBuilder variableInstanceLogDelete();
  
    
    public <T,R> List<R> queryLogs(QueryWhere queryWhere, Class<T> queryType, Class<R> resultType);

}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.EXTERNAL_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.LAST_VARIABLE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OLD_VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VALUE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VAL_SEPARATOR;

import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.VariableInstanceLog;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;

public class VarInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<VariableInstanceLogQueryBuilder, VariableInstanceLog> implements VariableInstanceLogQueryBuilder {

    public VarInstLogQueryBuilderImpl(CommandExecutor cmdExecutor ) {
        super(cmdExecutor);
    }
  
    public VarInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
    
    @Override
    public VariableInstanceLogQueryBuilder variableInstanceId( String... variableInstanceId ) {
        addObjectParameter(VARIABLE_INSTANCE_ID_LIST, "variable instance id", variableInstanceId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder variableId( String... variableId ) {
        addObjectParameter(VARIABLE_ID_LIST, "variable id", variableId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder value( String... value ) {
        addObjectParameter(VALUE_LIST, "value", value);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder oldValue( String... oldVvalue ) {
        addObjectParameter(OLD_VALUE_LIST, "old value", oldVvalue);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder variableValue( String variableId, String value ) {
        if( queryWhere.isRange() ) { 
            throw new IllegalArgumentException("Range values are not supported for the .variableValue(..) method");
        }
        if( variableId == null ) { 
            throw new IllegalArgumentException("A null variable Id criteria is invalid." );
        }
        if( value == null ) { 
            throw new IllegalArgumentException("A null variable value criteria is invalid." );
        }
        String varValStr = variableId.length() + VAR_VAL_SEPARATOR + variableId + VAR_VAL_SEPARATOR + value;
        addObjectParameter(VAR_VALUE_ID_LIST, "value for variable", varValStr);
        return this;
    }
    
    @Override
    public VariableInstanceLogQueryBuilder externalId( String... externalId ) {
        addObjectParameter(EXTERNAL_ID_LIST, "external id", externalId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder last() {
        List<QueryCriteria> criteriaList = queryWhere.getCriteria();
        QueryCriteria lastVariableInstanceLogCriteria = null;
        for( QueryCriteria criteria : criteriaList ) { 
            if( LAST_VARIABLE_LIST.equals(criteria.getListId()) ) { 
               lastVariableInstanceLogCriteria = criteria;
               break;
            }
        }
        if( lastVariableInstanceLogCriteria == null ) { 
            queryWhere.addParameter(LAST_VARIABLE_LIST, true);
        }
        return this;
    }
    
    @Override
    protected Class<VariableInstanceLog> getResultType() {
        return VariableInstanceLog.class;
    }

    @Override
    protected Class getQueryType() {
        return org.jbpm.process.audit.VariableInstanceLog.class;
    }

}

<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.NODE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.NodeInstanceLog;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;

public class NodeInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<NodeInstanceLogQueryBuilder, NodeInstanceLog> implements NodeInstanceLogQueryBuilder {

    public NodeInstLogQueryBuilderImpl(CommandExecutor cmdService) { 
       super(cmdService);
    }
    
    public NodeInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
    
    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceId( String... nodeInstanceId ) {
        addObjectParameter(NODE_INSTANCE_ID_LIST, "node instance id", nodeInstanceId);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeId( String... nodeId ) {
        addObjectParameter(NODE_ID_LIST, "node id", nodeId);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeName( String... name ) {
        addObjectParameter(NODE_NAME_LIST, "node name", name);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeType( String... type ) {
        addObjectParameter(TYPE_LIST, "node type", type);
        return this;
    }
    
    @Override
    public NodeInstanceLogQueryBuilder workItemId( long... workItemId ) {
        addLongParameter(WORK_ITEM_ID_LIST, "work item id", workItemId);
        return this;
    }

    @Override
    protected Class<NodeInstanceLog> getResultType() {
        return NodeInstanceLog.class;
    }

    @Override
    protected Class<org.jbpm.process.audit.NodeInstanceLog> getQueryType() {
        return org.jbpm.process.audit.NodeInstanceLog.class;
    }



}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.CORRELATION_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DURATION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.END_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.IDENTITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OUTCOME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_VERSION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.START_DATE_LIST;

import java.util.Date;
import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.ProcessInstanceLog;
import org.kie.internal.process.CorrelationKey;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;

public class ProcInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<ProcessInstanceLogQueryBuilder, ProcessInstanceLog> implements ProcessInstanceLogQueryBuilder {

    public ProcInstLogQueryBuilderImpl(CommandExecutor cmdExecutor ) {
        super(cmdExecutor);
    }

    public ProcInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
       
    @Override
    public ProcessInstanceLogQueryBuilder status( int... status ) {
        addIntParameter(PROCESS_INSTANCE_STATUS_LIST, "status", status);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder duration( long... duration ) {
        addLongParameter(DURATION_LIST, "duration", duration);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder durationMin( long durationMin ) { 
        addRangeParameter(DURATION_LIST, "duration min", durationMin, true);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder durationMax( long durationMax ) { 
        addRangeParameter(DURATION_LIST, "duration max", durationMax, false);
        return this;
    }
    
    @Override
    public ProcessInstanceLogQueryBuilder identity( String... identity ) {
        addObjectParameter(IDENTITY_LIST, "identity", identity);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder processVersion( String... version ) {
        addObjectParameter(PROCESS_VERSION_LIST, "process version", version);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder processName( String... processName ) {
        addObjectParameter(PROCESS_NAME_LIST, "process name", processName);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDate( Date... date ) {
        addObjectParameter(START_DATE_LIST, "start date", date);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDateRangeStart( Date rangeStart ) {
        addRangeParameter(START_DATE_LIST, "start date range, start", rangeStart, true );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDateRangeEnd( Date rangeEnd ) {
        addRangeParameter(START_DATE_LIST, "start date range, end", rangeEnd, false );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDate( Date... date ) {
        addObjectParameter(END_DATE_LIST, "end date", date );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDateRangeStart( Date rangeStart ) {
        addRangeParameter(END_DATE_LIST, "end date range, start", rangeStart, true);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDateRangeEnd( Date rangeEnd ) {
        addRangeParameter(END_DATE_LIST, "end date range, end", rangeEnd, false);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder outcome( String... outcome ) {
        addObjectParameter(OUTCOME_LIST, "outcome", outcome);
        return this;
    }
    
	@Override
	public ProcessInstanceLogQueryBuilder correlationKey(CorrelationKey... correlationKeys) {
		String[] correlationKeysExternal = new String[correlationKeys.length];
		
		for (int i = 0; i < correlationKeys.length; i++) {
			correlationKeysExternal[i] = correlationKeys[i].toExternalForm();
		}
		
		addObjectParameter(CORRELATION_KEY_LIST, "correlation key", correlationKeysExternal);
		return this;
	}

    @Override
    protected Class<ProcessInstanceLog> getResultType() {
        return ProcessInstanceLog.class;
    }

    @Override
    protected Class getQueryType() {
        return org.jbpm.process.audit.ProcessInstanceLog.class;
    }

}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;

import java.util.Date;
import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.jbpm.process.audit.command.AuditCommand;
import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.CommandExecutor;
import org.kie.internal.command.Context;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.QueryParameterIdentifiers;
import org.kie.internal.runtime.manager.audit.query.AuditLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.AuditLogQueryBuilder.OrderBy;
import org.kie.internal.runtime.manager.audit.query.ProcessIdQueryBuilder;

@SuppressWarnings("unchecked")
public abstract class AbstractAuditQueryBuilderImpl<T,R> extends AbstractQueryBuilderImpl<T> implements AuditLogQueryBuilder<T,R> {

    protected final CommandExecutor executor; 
    protected final JPAAuditLogService jpaAuditService; 
    
    protected AbstractAuditQueryBuilderImpl(JPAAuditLogService jpaService) { 
        this.executor = null;
        this.jpaAuditService = jpaService;
    }
    
    protected AbstractAuditQueryBuilderImpl(CommandExecutor cmdExecutor) { 
        this.executor = cmdExecutor;
        this.jpaAuditService = null;
    }
   
    
    
    protected JPAAuditLogService getJpaAuditLogService() { 
        JPAAuditLogService jpaAuditLogService = this.jpaAuditService;
        if( jpaAuditLogService == null ) { 
           jpaAuditLogService = this.executor.execute(getJpaAuditLogServiceCommand);
        }
        return jpaAuditLogService;
    }
    
    private AuditCommand<JPAAuditLogService> getJpaAuditLogServiceCommand = new AuditCommand<JPAAuditLogService>() {
        private static final long serialVersionUID = 101L;
        @Override
        public JPAAuditLogService execute( Context context ) {
            setLogEnvironment(context);
            return (JPAAuditLogService) this.auditLogService;
        }
    };

    
    
    @Override
    public T processInstanceId( long... processInstanceId ) {
        addLongParameter(PROCESS_INSTANCE_ID_LIST, "process instance id", processInstanceId);
        return (T) this;
    }

    @Override
    public T processInstanceIdRange( Long processInstanceIdMin, Long processInstanceIdMax ) {
        addRangeParameters(PROCESS_INSTANCE_ID_LIST, "process instance id", processInstanceIdMin, processInstanceIdMax);
        return (T) this;
    }
    
    @Override
    public T processId( String... processId ) {
        addObjectParameter(PROCESS_ID_LIST, "process id", processId);
        return (T) this;
    }

    public T date( Date... date ) {
        addObjectParameter(DATE_LIST, "date", date);
        return (T) this;
    }

    public T dateRangeStart( Date rangeStart ) {
        addRangeParameter(DATE_LIST, "date range start", rangeStart, true);
        return (T) this;
    }

    public T dateRangeEnd( Date rangeStart ) {
        addRangeParameter(DATE_LIST, "date range end", rangeStart, false);
        return (T) this;
    }

    @Override
    public T ascending( OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setAscending(listId);
        return (T) this;
    }
   
    @Override
    public T descending( OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setDescending(listId);
        return (T) this;
    }
   
    private String convertOrderByToListId(OrderBy field) { 
        String listId;
        switch( field ) { 
        case processId:
            listId = QueryParameterIdentifiers.PROCESS_ID_LIST;
            break;
        case processInstanceId:
            listId = QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
            break;
        default:
            throw new IllegalArgumentException("Unknown 'order-by' field: " + field.toString() );
        } 
        return listId;
    }
    
    

    protected abstract Class<R> getResultType();
    protected abstract Class getQueryType();
    
    @Override
    public ParametrizedQuery<R> build() {
        return new ParametrizedQuery<R>() {
            private QueryWhere queryData = new QueryWhere(getQueryWhere()); 
            @Override
            public List<R> getResultList() {
                return getJpaAuditLogService().queryLogs(queryData, getQueryType(), getResultType());
            }
        };
    }

}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.manager.audit.NodeInstanceLog;
import org.kie.internal.command.Context;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditNodeInstanceLogQueryCommand extends AuditCommand<List<NodeInstanceLog>>{

    
    private static final long serialVersionUID = -5408224599858065532L;
    
    @XmlElement
    private QueryWhere queryWhere;
   
    public AuditNodeInstanceLogQueryCommand() {
        
    }
    
    public AuditNodeInstanceLogQueryCommand(QueryWhere queryWhere) {
       this.queryWhere = queryWhere; 
    }
    
    @Override
    public List<NodeInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryLogs(queryWhere, org.jbpm.process.audit.NodeInstanceLog.class, NodeInstanceLog.class);
    }

}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.manager.audit.ProcessInstanceLog;
import org.kie.internal.command.Context;
import org.kie.internal.query.data.QueryData;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditProcessInstanceLogQueryCommand extends AuditCommand<List<ProcessInstanceLog>>{

    
    private static final long serialVersionUID = 7543632015198138915L;
    
    @XmlElement
    private QueryWhere queryWhere;
   
    public AuditProcessInstanceLogQueryCommand() {
        
    }
    
    public AuditProcessInstanceLogQueryCommand(QueryWhere queryWhere) {
       this.queryWhere = queryWhere; 
    }
    
    @Override
    public List<ProcessInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryLogs(queryWhere, org.jbpm.process.audit.ProcessInstanceLog.class, ProcessInstanceLog.class);
    }

}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.runtime.manager.audit.VariableInstanceLog;
import org.kie.internal.command.Context;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditVariableInstanceLogQueryCommand extends AuditCommand<List<VariableInstanceLog>>{

     
    private static final long serialVersionUID = 403371489934741666L;
    
    @XmlElement
    private QueryWhere queryWhere;
   
    public AuditVariableInstanceLogQueryCommand() {
        
    }
    
    public AuditVariableInstanceLogQueryCommand(QueryWhere queryWhere) {
       this.queryWhere = queryWhere; 
    }
    
    @Override
    public List<VariableInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryLogs(queryWhere, org.jbpm.process.audit.VariableInstanceLog.class, VariableInstanceLog.class);
    }

}

<code block>


package org.jbpm.executor.commands;

import java.text.SimpleDateFormat;
import java.util.Date;

import javax.persistence.EntityManagerFactory;

import org.jbpm.executor.impl.jpa.ExecutorJPAAuditService;
import org.jbpm.process.core.timer.DateTimeUtils;
import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;
import org.kie.api.executor.Command;
import org.kie.api.executor.CommandContext;
import org.kie.api.executor.ExecutionResults;
import org.kie.api.executor.Reoccurring;
import org.kie.api.executor.STATUS;
import org.kie.api.runtime.process.ProcessInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class LogCleanupCommand implements Command, Reoccurring {
	
	private static final Logger logger = LoggerFactory.getLogger(LogCleanupCommand.class);
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
	
	private long nextScheduleTimeAdd = 24 * 60 * 60 * 1000; 

	@Override
	public Date getScheduleTime() {
		if (nextScheduleTimeAdd < 0) {
			return null;
		}
		
		long current = System.currentTimeMillis();
		
		Date nextSchedule = new Date(current + nextScheduleTimeAdd);
		logger.debug("Next schedule for job {} is set to {}", this.getClass().getSimpleName(), nextSchedule);
		
		return nextSchedule;
	}

	@Override
	public ExecutionResults execute(CommandContext ctx) throws Exception {
		boolean skipProcessLog = ctx.getData().containsKey("SkipProcessLog")?Boolean.parseBoolean((String)ctx.getData("SkipProcessLog")):false;
		boolean skipTaskLog = ctx.getData().containsKey("SkipTaskLog")?Boolean.parseBoolean((String)ctx.getData("SkipTaskLog")):false;;
		boolean skipExecutorLog = ctx.getData().containsKey("SkipExecutorLog")?Boolean.parseBoolean((String)ctx.getData("SkipExecutorLog")):false;;
		
		SimpleDateFormat formatToUse = DATE_FORMAT;
		
		String dataFormat = (String) ctx.getData("DateFormat");
		if (dataFormat != null) {
			formatToUse = new SimpleDateFormat(dataFormat);
		}
		
		ExecutionResults executionResults = new ExecutionResults();
		String emfName = (String)ctx.getData("EmfName");
		if (emfName == null) {
			emfName = "org.jbpm.domain"; 
		}
		String singleRun = (String)ctx.getData("SingleRun");
		if ("true".equalsIgnoreCase(singleRun)) {
			
			this.nextScheduleTimeAdd = -1;
		}
		String nextRun = (String)ctx.getData("NextRun");
		if (nextRun != null) {
			nextScheduleTimeAdd = DateTimeUtils.parseDateAsDuration(nextRun);
		}
		
		
		EntityManagerFactory emf = EntityManagerFactoryManager.get().getOrCreate(emfName);
		ExecutorJPAAuditService auditLogService = new ExecutorJPAAuditService(emf);
		
		
		String olderThan = (String)ctx.getData("OlderThan");
		String olderThanPeriod = (String)ctx.getData("OlderThanPeriod");
		String forProcess = (String)ctx.getData("ForProcess");
		String forDeployment = (String)ctx.getData("ForDeployment");
		
		if (olderThanPeriod != null) {
			long olderThanDuration = DateTimeUtils.parseDateAsDuration(olderThanPeriod);
			Date olderThanDate = new Date(System.currentTimeMillis() - olderThanDuration);
			
			olderThan = formatToUse.format(olderThanDate);
		}
		if (!skipProcessLog) {
		
			long piLogsRemoved = 0l;		
			piLogsRemoved = auditLogService.processInstanceLogDelete()
			.processId(forProcess)
			.status(ProcessInstance.STATE_COMPLETED, ProcessInstance.STATE_ABORTED)
			.endDateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("ProcessInstanceLogRemoved {}", piLogsRemoved);
			executionResults.setData("ProcessInstanceLogRemoved", piLogsRemoved);
			
			long niLogsRemoved = 0l;
			niLogsRemoved = auditLogService.nodeInstanceLogDelete()
			.processId(forProcess)
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("NodeInstanceLogRemoved {}", niLogsRemoved);
			executionResults.setData("NodeInstanceLogRemoved", niLogsRemoved);
			
			long viLogsRemoved = 0l;
			viLogsRemoved = auditLogService.variableInstanceLogDelete()
			.processId(forProcess)
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("VariableInstanceLogRemoved {}", viLogsRemoved);
			executionResults.setData("VariableInstanceLogRemoved", viLogsRemoved);
		}
		
		if (!skipTaskLog) {
			
			long taLogsRemoved = 0l;
			taLogsRemoved = auditLogService.auditTaskDelete()
			.processId(forProcess)		
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.deploymentId(forDeployment)
			.build()
			.execute();
			logger.info("TaskAuditLogRemoved {}", taLogsRemoved);
			executionResults.setData("TaskAuditLogRemoved", taLogsRemoved);
			
			long teLogsRemoved = 0l;
			teLogsRemoved = auditLogService.taskEventInstanceLogDelete()
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))		
			.build()
			.execute();
			logger.info("TaskEventLogRemoved {}", teLogsRemoved);
			executionResults.setData("TaskEventLogRemoved", teLogsRemoved);
		}
		
		if (!skipExecutorLog) {
			
			long errorInfoLogsRemoved = 0l;
			errorInfoLogsRemoved = auditLogService.errorInfoLogDeleteBuilder()		
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.build()
			.execute();
			logger.info("ErrorInfoLogsRemoved {}", errorInfoLogsRemoved);
			executionResults.setData("ErrorInfoLogsRemoved", errorInfoLogsRemoved);
			
			long requestInfoLogsRemoved = 0l;
			requestInfoLogsRemoved = auditLogService.requestInfoLogDeleteBuilder()
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.status(STATUS.CANCELLED, STATUS.DONE, STATUS.ERROR)
			.build()
			.execute();
			logger.info("RequestInfoLogsRemoved {}", requestInfoLogsRemoved);
			executionResults.setData("RequestInfoLogsRemoved", requestInfoLogsRemoved);
		}
		
		
		long bamLogsRemoved = 0l;
		executionResults.setData("BAMLogRemoved", bamLogsRemoved);
		
		
        return executionResults;
	}

}

<code block>


package org.jbpm.executor.impl.jpa;

import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_TIME_LIST;

import java.util.Date;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

import org.jbpm.executor.entities.ErrorInfo;
import org.jbpm.executor.entities.RequestInfo;
import org.jbpm.query.jpa.impl.QueryCriteriaUtil;
import org.jbpm.services.task.audit.service.TaskJPAAuditService;
import org.kie.api.executor.STATUS;
import org.kie.internal.runtime.manager.audit.query.ErrorInfoDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ErrorInfoQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.RequestInfoLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.RequestInfoQueryBuilder;

public class ExecutorJPAAuditService extends TaskJPAAuditService {
	
	public ExecutorJPAAuditService(EntityManagerFactory emf) {
		super(emf);
	}

	@Override
    protected EntityManager getEntityManager() {
        return super.getEntityManager();
    }

    @Override
    protected Object joinTransaction( EntityManager em ) {
        return super.joinTransaction(em);
    }

    @Override
    protected void closeEntityManager( EntityManager em, Object transaction ) {
        super.closeEntityManager(em, transaction);
    }

    
    
    static { 
        addCriteria(EXECUTOR_TIME_LIST, "l.time", Date.class);
        addCriteria(EXECUTOR_STATUS_LIST, "l.status", STATUS.class);
    }
	
	public ErrorInfoDeleteBuilder errorInfoLogDeleteBuilder() {
		return new ErrorInfoDeleteBuilderImpl(this);
	}

	public RequestInfoLogDeleteBuilder requestInfoLogDeleteBuilder() {
		return new RequestInfoLogDeleteBuilderImpl(this);
	}

	
	
	private final ExecutorQueryCriteriaUtil queryUtil = new ExecutorQueryCriteriaUtil(this);
	
    @Override
    protected QueryCriteriaUtil getQueryCriteriaUtil( Class queryType ) {
        if( ErrorInfo.class.equals(queryType)
                || RequestInfo.class.equals(queryType) ) { 
            return queryUtil;
        } else { 
            return super.getQueryCriteriaUtil(queryType);
        }
    }
	
	public ErrorInfoQueryBuilder errorInfoQueryBuilder() {
		return new ErrorInfoQueryBuilderImpl(this);
	}

	public RequestInfoQueryBuilder requestInfoQueryBuilder() {
		return new RequestInfoQueryBuilderImpl(this);
	}

}

<code block>


package org.jbpm.executor.impl.jpa;

import static org.kie.internal.query.QueryParameterIdentifiers.*;
import static org.kie.internal.query.QueryParameterIdentifiers.EXPIRATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MESSAGE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.STACK_TRACE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ACTIVATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;

import java.util.Date;
import java.util.List;

import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.data.QueryWhere.QueryCriteriaType;
import org.kie.api.executor.ErrorInfo;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.QueryParameterIdentifiers;
import org.kie.internal.runtime.manager.audit.query.ErrorInfoQueryBuilder;

public class ErrorInfoQueryBuilderImpl extends AbstractQueryBuilderImpl<ErrorInfoQueryBuilder>  implements ErrorInfoQueryBuilder {

    private final ExecutorJPAAuditService jpaAuditService;
    
     public ErrorInfoQueryBuilderImpl(ExecutorJPAAuditService jpaAuditService) { 
        this.jpaAuditService = jpaAuditService;
     }		

    @Override
    public ErrorInfoQueryBuilder message( String... message ) {
        addObjectParameter(MESSAGE_LIST, "message", message);
        return this;
    }

    @Override
    public ErrorInfoQueryBuilder id( long... id ) {
        addLongParameter(ID_LIST, "id", id);
        return this;
    }

    @Override
    public ErrorInfoQueryBuilder time( Date... time ) {
        addObjectParameter(EXECUTOR_TIME_LIST, "time", time);
        return this;
    }

    @Override
    public ErrorInfoQueryBuilder timeRange( Date timeMin, Date timeMax ) {
        addRangeParameters(EXECUTOR_TIME_LIST, "time", timeMin, timeMax);
        return this;
    }

    @Override
    public ErrorInfoQueryBuilder stackTraceRegex( String... stackTraceRegex ) {
        QueryWhere queryWhere = getQueryWhere();
        QueryCriteriaType origCriteriaType = queryWhere.getCriteriaType();
        
        queryWhere.setToLike();
        addObjectParameter(STACK_TRACE_LIST, "stack trace regex", stackTraceRegex);
        
        switch(origCriteriaType) { 
        case NORMAL:
            queryWhere.setToNormal();
            break;
        case RANGE:
            queryWhere.setToRange();
            break;
        case GROUP:
            queryWhere.setToGroup();
            break;
        case REGEXP:
            
        }
        return this;
    }

    @Override
    public ErrorInfoQueryBuilder ascending( ErrorInfoQueryBuilder.OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setAscending(listId);
        return this;
    }
   
    @Override
    public ErrorInfoQueryBuilder descending( ErrorInfoQueryBuilder.OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setDescending(listId);
        return this;
    }
   
    private String convertOrderByToListId(ErrorInfoQueryBuilder.OrderBy field) { 
        String listId;
        switch( field ) { 
        case id:
            listId = QueryParameterIdentifiers.ID_LIST;
            break;
        case time:
            listId = QueryParameterIdentifiers.EXECUTOR_TIME_LIST;
            break;
        default:
            throw new IllegalArgumentException("Unknown 'order-by' field: " + field.toString() );
        } 
        return listId;
    }
    
    @Override
    public ParametrizedQuery<ErrorInfo> build() {
        return new ParametrizedQuery<ErrorInfo>() {
            private QueryWhere queryData = new QueryWhere(getQueryWhere()); 
            @Override
            public List<ErrorInfo> getResultList() {
                return jpaAuditService.queryLogs(queryData, org.jbpm.executor.entities.ErrorInfo.class, ErrorInfo.class);
            }
        };
    }
}

<code block>


package org.jbpm.executor.impl.jpa;

import static org.kie.internal.query.QueryParameterIdentifiers.*;
import static org.kie.internal.query.QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_EXECUTIONS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_OWNER_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_RETRIES_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXPIRATION_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MESSAGE_LIST;

import java.util.Date;
import java.util.List;

import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.jbpm.query.jpa.data.QueryWhere;
import org.kie.api.executor.RequestInfo;
import org.kie.api.executor.STATUS;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.QueryParameterIdentifiers;
import org.kie.internal.runtime.manager.audit.query.RequestInfoQueryBuilder;

public class RequestInfoQueryBuilderImpl extends AbstractQueryBuilderImpl<RequestInfoQueryBuilder>  implements RequestInfoQueryBuilder {

    private final ExecutorJPAAuditService jpaAuditService;
    
     public RequestInfoQueryBuilderImpl(ExecutorJPAAuditService jpaAuditService) { 
        this.jpaAuditService = jpaAuditService;
     }		

    @Override
    public RequestInfoQueryBuilder commandName( String... commandName ) {
        addObjectParameter(COMMAND_NAME_LIST, "command name", commandName);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder deploymentId( String... deploymentId ) {
        addObjectParameter(DEPLOYMENT_ID_LIST, "deployment id", deploymentId);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder executions( int... executions ) {
        addIntParameter(EXECUTOR_EXECUTIONS_LIST, "executions", executions);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder id( long... id ) {
        addLongParameter(ID_LIST, "id", id);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder key( String... key ) {
        addObjectParameter(EXECUTOR_KEY_LIST, "key", key);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder message( String... message ) {
        addObjectParameter(MESSAGE_LIST, "message", message);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder owner( String... owner ) {
        addObjectParameter(EXECUTOR_OWNER_LIST, "owner", owner);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder retries( int... retries ) {
        addIntParameter(EXECUTOR_RETRIES_LIST, "retries", retries);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder status( STATUS... status ) {
        addObjectParameter(EXECUTOR_STATUS_LIST, "status", status);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder time( Date... time ) {
        addObjectParameter(EXECUTOR_TIME_LIST, "time", time);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder timeRange( Date timeMin, Date timeMax ) {
        addRangeParameters(EXECUTOR_TIME_LIST, "time", timeMin, timeMax);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder ascending( RequestInfoQueryBuilder.OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setAscending(listId);
        return this;
    }

    @Override
    public RequestInfoQueryBuilder descending( RequestInfoQueryBuilder.OrderBy field ) {
        String listId = convertOrderByToListId(field);
        this.queryWhere.setDescending(listId);
        return this;
    }

    private String convertOrderByToListId(RequestInfoQueryBuilder.OrderBy field) { 
        String listId;
        switch( field ) { 
        case deploymentId:
            listId = QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
            break;
        case executions:
            listId = QueryParameterIdentifiers.EXECUTOR_EXECUTIONS_LIST;
            break;
        case id:
            listId = QueryParameterIdentifiers.ID_LIST;
            break;
        case retries:
            listId = QueryParameterIdentifiers.EXECUTOR_RETRIES_LIST;
            break;
        case status:
            listId = QueryParameterIdentifiers.EXECUTOR_STATUS_LIST;
            break;
        case time:
            listId = QueryParameterIdentifiers.EXECUTOR_TIME_LIST;
            break;
        default:
            throw new IllegalArgumentException("Unknown 'order-by' field: " + field.toString() );
        } 
        return listId;
    }

    @Override
    public ParametrizedQuery<RequestInfo> build() {
        return new ParametrizedQuery<RequestInfo>() {
            private QueryWhere queryData = new QueryWhere(getQueryWhere()); 
            @Override
            public List<RequestInfo> getResultList() {
                return jpaAuditService.queryLogs(queryData, org.jbpm.executor.entities.RequestInfo.class, RequestInfo.class);
            }
        };
    }

}

<code block>
package org.jbpm.executor.impl.jpa;

import static org.kie.internal.query.QueryParameterIdentifiers.COMMAND_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_EXECUTIONS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_OWNER_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_RETRIES_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_TIME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MESSAGE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.STACK_TRACE_LIST;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.Attribute;

import org.jbpm.executor.entities.ErrorInfo_;
import org.jbpm.executor.entities.RequestInfo_;
import org.jbpm.query.jpa.data.QueryCriteria;
import org.jbpm.query.jpa.data.QueryWhere;
import org.jbpm.query.jpa.impl.QueryCriteriaUtil;

public class ExecutorQueryCriteriaUtil extends QueryCriteriaUtil {

    
    
    public final static Map<Class, Map<String, Attribute>> criteriaAttributes 
        = new ConcurrentHashMap<Class, Map<String, Attribute>>();

    @Override
    protected synchronized boolean initializeCriteriaAttributes() { 
        if( ErrorInfo_.id == null ) { 
            
            
            
            return false;
        }
        
        if( ! criteriaAttributes.isEmpty() ) { 
           return true; 
        }
        
        
        addCriteria(criteriaAttributes, MESSAGE_LIST, ErrorInfo_.message);
        addCriteria(criteriaAttributes, ID_LIST, ErrorInfo_.id);
        addCriteria(criteriaAttributes, STACK_TRACE_LIST, ErrorInfo_.stacktrace);
        addCriteria(criteriaAttributes, EXECUTOR_TIME_LIST, ErrorInfo_.time);
        
        
        addCriteria(criteriaAttributes, COMMAND_NAME_LIST, RequestInfo_.commandName);
        addCriteria(criteriaAttributes, DEPLOYMENT_ID_LIST, RequestInfo_.deploymentId);
        addCriteria(criteriaAttributes, EXECUTOR_EXECUTIONS_LIST, RequestInfo_.executions);
        addCriteria(criteriaAttributes, ID_LIST, RequestInfo_.id);
        addCriteria(criteriaAttributes, EXECUTOR_KEY_LIST, RequestInfo_.key);
        addCriteria(criteriaAttributes, MESSAGE_LIST, RequestInfo_.message);
        addCriteria(criteriaAttributes, EXECUTOR_OWNER_LIST, RequestInfo_.owner);
        addCriteria(criteriaAttributes, EXECUTOR_RETRIES_LIST, RequestInfo_.retries);
        addCriteria(criteriaAttributes, EXECUTOR_STATUS_LIST, RequestInfo_.status);
        addCriteria(criteriaAttributes, EXECUTOR_TIME_LIST, RequestInfo_.time);
        
        return true;
    }
   
    
    
    private ExecutorJPAAuditService executorAuditService;
    
    public ExecutorQueryCriteriaUtil(ExecutorJPAAuditService service) { 
        super(criteriaAttributes);
        this.executorAuditService = service;
    }
  
    private EntityManager getEntityManager() { 
        return this.executorAuditService.getEntityManager();
    }
  
    private Object joinTransaction(EntityManager em) { 
        return this.executorAuditService.joinTransaction(em);
    }
   
    private void closeEntityManager(EntityManager em, Object transaction) {
        this.executorAuditService.closeEntityManager(em, transaction);
    }
  
    
   
    protected CriteriaBuilder getCriteriaBuilder() { 
        return getEntityManager().getCriteriaBuilder();
    }

    @Override
    protected <T> List<T> createQueryAndCallApplyMetaCriteriaAndGetResult(QueryWhere queryWhere, CriteriaQuery<T> criteriaQuery, CriteriaBuilder builder) { 
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(criteriaQuery);
    
        applyMetaCriteriaToQuery(query, queryWhere);
        
        
        List<T> result = query.getResultList();

        closeEntityManager(em, newTx);
        
        return result;
    }

    @Override
    protected <R,T> Predicate implSpecificCreatePredicateFromSingleCriteria( 
            CriteriaQuery<R> query, 
            CriteriaBuilder builder, 
            Class queryType,
            QueryCriteria criteria, 
            QueryWhere queryWhere) {
        throw new IllegalStateException("List id " + criteria.getListId() + " is not supported for queries on " + queryType.getSimpleName() + ".");
    }

}

<code block>


package org.jbpm.query.jpa.data;

import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.kie.internal.query.QueryParameterIdentifiers;


public class QueryCriteriaUtil {

    
    public static boolean noLimitingCriteria(List<QueryCriteria> criteriaList) { 
        
        QueryCriteria criteria = criteriaList.get(0);

        for( int i = 0; i < criteriaList.size(); ++i ) { 
            criteria = criteriaList.get(i);

            if( ! criteria.isUnion() ) { 
                return false;
            }
        }
        
        return true;
    }

    
    public static List<QueryCriteria> getLimitingCriteria(List<QueryCriteria> criteriaList) { 
        List<QueryCriteria> allLimitingCriteria = new LinkedList<QueryCriteria>();
        for( QueryCriteria criteria : criteriaList ) { 
            if( ! criteria.isUnion() ) { 
                allLimitingCriteria.add(criteria);
                if( ! criteria.getCriteria().isEmpty() ) { 
                   allLimitingCriteria.addAll(getSubQueryLimitingCriteria(criteria.getCriteria()));
                }
            }
        }
    
        return allLimitingCriteria;
    }
  
    
    private static List<QueryCriteria> getSubQueryLimitingCriteria(List<QueryCriteria> criteriaList) { 
        List<QueryCriteria> limitingCriteria = new LinkedList<QueryCriteria>();
        sortCriteriaUnionFirst(criteriaList);
        for( QueryCriteria criteria : criteriaList ) { 
            if( criteria.isUnion() ) { 
                return Collections.EMPTY_LIST;
            }  else { 
                limitingCriteria.add(criteria);
            }
        }
    
        return limitingCriteria; 
    }
    

    
    public static QueryCriteria removeLimitingCriteria(String listId, List<QueryCriteria> criteriaList) { 
        Iterator<QueryCriteria> iter = criteriaList.iterator();
        while( iter.hasNext() ) { 
            QueryCriteria criteria = iter.next();
            if( ! criteria.isUnion() ) { 
                if( listId.equals(criteria.getListId()) ) { 
                    iter.remove();
                    return criteria;
                }
                if( criteria.getCriteria().size() > 0 ) { 
                   return removeSubQueryLimitingCriteria(listId, criteria.getCriteria()); 
                }
            }
        }
        return null;
    }
    
    private static QueryCriteria removeSubQueryLimitingCriteria(String listId, List<QueryCriteria> criteriaList) { 
        Iterator<QueryCriteria> iter = criteriaList.iterator();
        sortCriteriaUnionFirst(criteriaList);
        while( iter.hasNext() ) { 
            QueryCriteria criteria = iter.next();
            if( criteria.isUnion() ) { 
                return null;
            } else { 
                if( listId.equals(criteria.getListId()) ) { 
                    iter.remove();
                    return criteria;
                }
                if( criteria.getCriteria().size() > 0 ) { 
                   return removeSubQueryLimitingCriteria(listId, criteria.getCriteria()); 
                }
            }
        }
        return null;
    }
   
    private static void sortCriteriaUnionFirst(List<QueryCriteria> criteriaList) { 
        Collections.sort(criteriaList, new Comparator<QueryCriteria>() {
            @Override
            public int compare( QueryCriteria o1, QueryCriteria o2 ) {
                if( o1.isUnion() && ! o2.isUnion() ) { 
                      return 1;
                } else if( o2.isUnion() && ! o1.isUnion() ) { 
                    return -1;
                }
                return 0;
            }
        }); 
    }
    
}
<code block>


package org.jbpm.query.jpa.data;

import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlRootElement;

import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.annotate.JsonIgnoreProperties;


@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
@JsonIgnoreProperties({"union","type", "currentGroupCriteria", "currentGroupParents", 
                       "like", "range"})
public class QueryWhere {

    @JsonIgnore
    private transient boolean union = true;
    
    @JsonIgnore
    private transient ParameterType type = ParameterType.NORMAL;
    
    @XmlEnum
    public static enum ParameterType { 
        @XmlEnumValue("N") NORMAL,
        @XmlEnumValue("L") REGEXP, 
        @XmlEnumValue("R") RANGE; 
    }

    @XmlElement(name="queryCriteria")
    private List<QueryCriteria> criteria = new LinkedList<QueryCriteria>();

    @JsonIgnore
    private transient List<QueryCriteria> currentGroupCriteria = criteria;
    
    @JsonIgnore
    private transient Stack<Object> currentGroupParents = new Stack<Object>();
    
    public QueryWhere() { 
        
    }
    
    
    
    public <T> QueryCriteria addAppropriateParam( String listId, T... param ) {
        if( param.length == 0 ) {
            return null;
        }
        if( ParameterType.REGEXP.equals(this.type) && ! (param[0] instanceof String) ) { 
            throw new IllegalArgumentException("Only String parameters may be used in regular expressions.");
        }
        QueryCriteria criteria = getAppropriateQueryCriteria(listId, param.length);
        for( T paramElem : param ) { 
           criteria.addParameter(paramElem); 
        }
        addCriteria(criteria);
        return criteria;
    }

    public <T> void addRangeParameter( String listId, T param, boolean start ) {
        ParameterType origType = this.type;
        this.type = ParameterType.RANGE;
        QueryCriteria criteria = getAppropriateQueryCriteria(listId, 2);
        int index = start ? 0 : 1;
        criteria.setParameter(index, param);
        addCriteria(criteria);
        this.type = origType;
    }
  
    private void addCriteria(QueryCriteria criteria) { 
        this.currentGroupCriteria.add(criteria);
    }
    
    private QueryCriteria getAppropriateQueryCriteria(String listId, int valueListSize) { 
        QueryCriteria criteria = new QueryCriteria(listId, this.union, this.type, valueListSize);
        
        resetGroup();
        return criteria;
    }
 
    
    
    public void startGroup() { 
        
        QueryCriteria newCriteriaGroupParent;
        if( currentGroupCriteria.isEmpty() ) { 
            newCriteriaGroupParent = new QueryCriteria();
            currentGroupCriteria.add(newCriteriaGroupParent);
        } else { 
            newCriteriaGroupParent = currentGroupCriteria.get(this.currentGroupCriteria.size()-1);
        }
        this.currentGroupParents.push(newCriteriaGroupParent);
        
        
        currentGroupCriteria = newCriteriaGroupParent.getCriteria();
    }

    public void endGroup() { 
       if( currentGroupParents.isEmpty() ) { 
           throw new IllegalStateException("Can not end group: no group has been started!");
       }
       
       currentGroupParents.pop();
       
       
       Object newCriteriaGroupParent = currentGroupParents.peek();
       if( newCriteriaGroupParent instanceof QueryWhere ) { 
          currentGroupCriteria = ((QueryWhere) newCriteriaGroupParent).getCriteria();
       } else { 
           currentGroupCriteria = ((QueryCriteria) newCriteriaGroupParent).getCriteria();
       }
    }

    private void resetGroup() { 
        this.currentGroupParents.clear();
    }
    
    
   
    public List<QueryCriteria> getCriteria() {
        return criteria;
    }

    public void setParameters( List<QueryCriteria> parameters ) {
        this.criteria = parameters;
    }
    
    public void setToUnion() {
        this.union = true;
    }
    
    public void setToIntersection() {
        this.union = false;
    }

    public boolean isUnion() { 
       return this.union;
    }

    public void setToLike() {
        this.type = ParameterType.REGEXP;
    }

    public boolean isLike() {
        return this.type.equals(ParameterType.REGEXP);
    }

    public void setToNormal() {
        this.type = ParameterType.NORMAL;
    }

    public void setToRange() {
        this.type = ParameterType.RANGE;
    }

    public boolean isRange() {
        return this.type.equals(ParameterType.RANGE);
    }
  
    

    public void clear() { 
        this.union = true;
        this.type = ParameterType.NORMAL;
        resetGroup();
        if( this.criteria != null ) { 
            this.criteria.clear();
        }
    }
    
    public QueryWhere(QueryWhere queryParameters) { 
       this.union = queryParameters.union;
       this.type = queryParameters.type;
       if( queryParameters.criteria != null )  {
           this.criteria = new LinkedList<QueryCriteria>(queryParameters.criteria);
       }
    }

    
}
<code block>


package org.jbpm.query.jpa.data;

import java.util.ArrayList;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.codehaus.jackson.annotate.JsonIgnoreProperties;
import org.codehaus.jackson.annotate.JsonTypeInfo;
import org.codehaus.jackson.annotate.JsonTypeInfo.As;
import org.codehaus.jackson.annotate.JsonTypeInfo.Id;
import org.jbpm.query.jpa.data.QueryWhere.ParameterType;
import org.kie.internal.query.QueryParameterIdentifiers;


@XmlRootElement
@XmlType
@XmlAccessorType(XmlAccessType.FIELD)
@JsonIgnoreProperties(value="parameters")
public class QueryCriteria {

    @XmlAttribute
    private String listId;
    
    @XmlAttribute
    private Boolean union = null;
    
    @XmlAttribute
    private ParameterType type = ParameterType.NORMAL;
    
    @XmlElement(name="parameter")
    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property="class")
    
    private List<Object> values;
   
    @XmlElement
    private List<QueryCriteria> criteria;
    
    public QueryCriteria() { 
        
    }
    public QueryCriteria(String listId, ParameterType type) { 
        this.listId = listId;
        this.type = type;
    }

    public QueryCriteria(String listId, boolean union, ParameterType type) { 
        this(listId, type);
        this.union = union;
    }

    public QueryCriteria(String listId, boolean union, ParameterType type, int valueListSize) { 
        this(listId, union, type);
        this.values = new ArrayList<Object>(valueListSize);
    }
    
    public String getListId() {
        return listId;
    }

    public void setListId( String listId ) {
        this.listId = listId;
    }

    public Boolean isUnion() {
        return union;
    }

    public void setUnion( Boolean union ) {
        this.union = union;
    }

    public ParameterType getType() {
        return type;
    }

    public void setType( ParameterType type ) {
        this.type = type;
    }

    public List<Object> getValues() {
        if( this.values == null ) { 
            this.values = new ArrayList<Object>();
        }
        return values;
    }
    
    public void setValues( List<Object> values ) {
        this.values = values;
    }
    
    
  
    public List<QueryCriteria> getCriteria() {
        if( this.criteria == null ) { 
            this.criteria = new ArrayList<QueryCriteria>();
        }
        return criteria;
    }
    public void setCriteria( List<QueryCriteria> criteria ) {
        this.criteria = criteria;
    }

    private static DatatypeFactory datatypeFactory;;
    static { 
        try {
            datatypeFactory = DatatypeFactory.newInstance();
        } catch( DatatypeConfigurationException e ) {
            System.out.println("Unable to instantiate a " + DatatypeFactory.class.getName() );
        }
    }
    
    
    public List<Object> getParameters() {
        List<Object> values = getValues();
        if( values.isEmpty() ) { 
            return values;
        }
        List<Object> parameters = new ArrayList<Object>(values.size());
        for( Object obj : this.values ) { 
           parameters.add(convertSerializableVariantToObject(obj));
        }
        return parameters;
    }
    
    void addParameter( Object value ) { 
        Object xmlValue = convertObjectToSerializableVariant(value);
        getValues().add(xmlValue);
    }

    void setParameter( int index, Object value ) { 
        Object xmlValue = convertObjectToSerializableVariant(value);
        List<Object> values = getValues();
        while( values.size() <= index ) { 
           values.add(null); 
        }
        getValues().set(index, xmlValue);
    }

    void addCriteria( QueryCriteria criteria ) { 
       getCriteria().add(criteria);
    }

    private static Object convertObjectToSerializableVariant(Object obj) { 
        if( obj instanceof Date ) { 
            GregorianCalendar cal = new GregorianCalendar();
            cal.setTime((Date) obj);
            return datatypeFactory.newXMLGregorianCalendar(cal);
         } 
        return obj;
    }
  
    private static Object convertSerializableVariantToObject(Object obj) { 
       if( obj instanceof XMLGregorianCalendar ) { 
          return ((XMLGregorianCalendar) obj).toGregorianCalendar().getTime();
       }
       return obj;
    }
    
    public QueryCriteria(QueryCriteria queryCriteria) { 
        this.listId = queryCriteria.listId;
        this.union = queryCriteria.union;
        this.type = queryCriteria.type;
        this.values = new ArrayList<Object>(queryCriteria.getValues());
    }
   
    @Override
    public String toString() { 
       StringBuilder out = new StringBuilder();
       if( union != null ) { 
           out.append(union ? "OR" : "AND");
           out.append(" ");
       }
       out.append(listId);
       if( this.values != null && ! this.values.isEmpty() ) { 
           out.append(" =");
           if( type.equals(ParameterType.REGEXP) ) { 
               out.append("~");
           } 
           out.append(" ");
           if ( type.equals(ParameterType.RANGE) ) { 
               out.append("[");
           }
           out.append(this.values.get(0));
           for( int i = 1; i < this.values.size(); ++i ) { 
               out.append(", ") .append(this.values.get(i));
           }
           if ( type.equals(ParameterType.RANGE) ) { 
               out.append("]");
           }
       } 
       return out.toString();
    }
}

<code block>


package org.jbpm.query.jpa.service;

import org.jbpm.query.jpa.impl.QueryAndParameterAppender;
import org.kie.internal.query.data.QueryData;

public interface QueryModificationService {

    public void addTablesToQuery(StringBuilder queryBuilder, QueryData queryData);
    
    public void addCriteriaToQuery(QueryData queryData, QueryAndParameterAppender existingQueryClauseAppender);

}

<code block>


package org.jbpm.query.jpa.builder.impl;

import org.kie.internal.query.data.QueryData;

public abstract class AbstractQueryBuilderImpl<T> {

    protected QueryData queryData = new QueryData();
    { 
        queryData.getQueryContext().setCount(0);
    }
   
    public QueryData getQueryData() { 
        return queryData;
    }
    
    protected <P> void addRangeParameter( String listId, String name, P parameter, boolean start) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        this.queryData.addRangeParameter(listId, parameter, start);
    }

    private <P> void addParameter( String listId, P... parameter ) { 
        this.queryData.addAppropriateParam(listId, parameter);
    }

    protected void addLongParameter( String listId, String name, long [] parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        Long [] wrapArr = new Long[parameter.length];
        for( int i = 0; i < parameter.length; ++i ) { 
            wrapArr[i] = parameter[i];
        }
        addParameter(listId, wrapArr);
    }
   
    protected void addIntParameter( String listId, String name, int [] parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        Integer [] wrapArr = new Integer[parameter.length];
        for( int i = 0; i < parameter.length; ++i ) { 
            wrapArr[i] = parameter[i];
        }
        addParameter(listId, wrapArr);
    }
    
    protected <P> void addObjectParameter(String listId, String name, P... parameter) { 
        if( parameter == null ) { 
            throw new IllegalArgumentException("A null " + name + " criteria is invalid." );
        }
        for( int i = 0; i < parameter.length; ++i ) { 
           if( parameter[i] == null ) { 
               throw new IllegalArgumentException("A null " + name + " criteria (argument " + i + ") is invalid." );
           }
        }
        addParameter(listId, parameter);
    }

    public final T union() {
        this.queryData.setToUnion();
        return (T) this;
    }

    public final T intersect() {
        this.queryData.setToIntersection();
        return (T) this;
    }
    
    public final T like() {
        this.queryData.setToLike();
        return (T) this;
    }

    public final T equals() {
        this.queryData.setToEquals();
        return (T) this;
    }

    public T clear() {
        this.queryData.clear();
        return (T) this;
    }

    public final T ascending() {
        this.queryData.getQueryContext().setAscending(true);
        return (T) this;
    }

    public final T descending() {
        this.queryData.getQueryContext().setAscending(false);
        return (T) this;
    }
    
    public final T maxResults( int maxResults ) {
        if( maxResults < 1 ) { 
            throw new IllegalArgumentException( "A max results criteria of less than 1 is invalid." );
        }
        this.queryData.getQueryContext().setCount(maxResults);
        return (T) this;
    }

    public final T offset( int offset ) {
        if( offset < 1 ) { 
            throw new IllegalArgumentException( "An offset criteria of less than 1 is invalid." );
        }
        this.queryData.getQueryContext().setOffset(offset);
        return (T) this;
    }
}

<code block>


package org.jbpm.services.task.commands;

import java.util.Arrays;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.internal.command.Context;

@XmlRootElement(name="composite-command")
@XmlAccessorType(XmlAccessType.FIELD)
public class CompositeCommand<T> extends TaskCommand<T> {
	
	private static final long serialVersionUID = -5591247478243819049L;

	@XmlElements(value={
	            @XmlElement(name="activate-task", type=ActivateTaskCommand.class),
	            @XmlElement(name="add-attachment", type=AddAttachmentCommand.class),
	            @XmlElement(name="add-comment", type=AddCommentCommand.class),
	            @XmlElement(name="add-content", type=AddContentCommand.class),
	            @XmlElement(name="add-group", type=AddGroupCommand.class),
	            @XmlElement(name="add-task", type=AddTaskCommand.class),
	            @XmlElement(name="add-user", type=AddUserCommand.class),
	            @XmlElement(name="add-users-groups", type=AddUsersGroupsCommand.class),
	            @XmlElement(name="archive-tasks", type=ArchiveTasksCommand.class),
	            @XmlElement(name="cancel-deadline", type=CancelDeadlineCommand.class),
	            @XmlElement(name="claim-next-available-task", type=ClaimNextAvailableTaskCommand.class),
	            @XmlElement(name="claim-task", type=ClaimTaskCommand.class),
	            @XmlElement(name="complete-task", type=CompleteTaskCommand.class),
	            @XmlElement(name="delegate-task", type=DelegateTaskCommand.class),
	            @XmlElement(name="delete-attachment", type=DeleteAttachmentCommand.class),
	            @XmlElement(name="delete-comment", type=DeleteCommentCommand.class),
	            @XmlElement(name="delete-content", type=DeleteContentCommand.class),
	            @XmlElement(name="delete-fault", type=DeleteFaultCommand.class),
	            @XmlElement(name="delete-output", type=DeleteOutputCommand.class),
	            @XmlElement(name="deploy-task-def", type=DeployTaskDefCommand.class),
	            @XmlElement(name="execute-deadlines", type=ExecuteDeadlinesCommand.class),
	            @XmlElement(name="execute-task-rules", type=ExecuteTaskRulesCommand.class),
	            @XmlElement(name="exit-task", type=ExitTaskCommand.class),
	            @XmlElement(name="fail-task", type=FailTaskCommand.class),
	            @XmlElement(name="forward-task", type=ForwardTaskCommand.class),
	            @XmlElement(name="get-active-tasks", type=GetActiveTasksCommand.class),
	            @XmlElement(name="get-all-attachments", type=GetAllAttachmentsCommand.class),
	            @XmlElement(name="get-all-comments", type=GetAllCommentsCommand.class),
	            @XmlElement(name="get-all-content", type=GetAllContentCommand.class),
	            @XmlElement(name="get-all-task-definitions", type=GetAllTaskDefinitionsCommand.class),
	            @XmlElement(name="get-archived-tasks", type=GetArchivedTasksCommand.class),
	            @XmlElement(name="get-attachment", type=GetAttachmentCommand.class),
	            @XmlElement(name="get-comment", type=GetCommentCommand.class),
	            @XmlElement(name="get-completed-tasks-by-user", type=GetCompletedTasksByUserCommand.class),
	            @XmlElement(name="get-completed-tasks", type=GetCompletedTasksCommand.class),
	            @XmlElement(name="get-content", type=GetContentCommand.class),
	            @XmlElement(name="get-group", type=GetGroupCommand.class),
	            @XmlElement(name="get-groups", type=GetGroupsCommand.class),
	            @XmlElement(name="get-org-entity", type=GetOrgEntityCommand.class),
	            @XmlElement(name="get-pending-sub-tasks", type=GetPendingSubTasksCommand.class),
	            @XmlElement(name="get-pending-tasks-by-user", type=GetPendingTasksByUserCommand.class),
	            @XmlElement(name="get-potential-ownders-for-task", type=GetPotentialOwnersForTaskCommand.class),
	            @XmlElement(name="get-sub-tasks", type=GetSubTasksCommand.class),
	            @XmlElement(name="get-task-assigned-as-business-admin", type=GetTaskAssignedAsBusinessAdminCommand.class),
	            @XmlElement(name="get-task-assigned-as-excluded-owner", type=GetTaskAssignedAsExcludedOwnerCommand.class),
	            @XmlElement(name="get-task-assigned-as-initiator", type=GetTaskAssignedAsInitiatorCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner-by-exp-date", type=GetTaskAssignedAsPotentialOwnerByExpDateCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner", type=GetTaskAssignedAsPotentialOwnerCommand.class),
	            @XmlElement(name="get-task-assigned-as-potential-owner-paging", type=GetTaskAssignedAsPotentialOwnerPagingCommand.class),
	            @XmlElement(name="get-task-assigned-as-recipient", type=GetTaskAssignedAsRecipientCommand.class),
	            @XmlElement(name="get-task-assigned-as-stakeholeder", type=GetTaskAssignedAsStakeholderCommand.class),
	            @XmlElement(name="get-task-assigned-by-groups", type=GetTaskAssignedByGroupsCommand.class),
	            @XmlElement(name="get-task-by-work-item-id", type=GetTaskByWorkItemIdCommand.class),
	            @XmlElement(name="get-task", type=GetTaskCommand.class),
	            @XmlElement(name="get-task-content", type=GetTaskContentCommand.class),
	            @XmlElement(name="get-task-definition", type=GetTaskDefinitionCommand.class),
	            @XmlElement(name="get-task-owned-by-exp-date-before-date", type=GetTaskOwnedByExpDateBeforeDateCommand.class),
	            @XmlElement(name="get-task-owned-by-exp-date", type=GetTaskOwnedByExpDateCommand.class),
	            @XmlElement(name="get-task-property", type=GetTaskPropertyCommand.class),
	            @XmlElement(name="get-tasks-by-process-instance-id", type=GetTasksByProcessInstanceIdCommand.class),
	            @XmlElement(name="get-tasks-by-status-by-process-instance-id", type=GetTasksByStatusByProcessInstanceIdCommand.class),
	            @XmlElement(name="get-tasks-by-various-fields", type=GetTasksByVariousFieldsCommand.class),
	            @XmlElement(name="get-tasks-for-process", type=GetTasksForProcessCommand.class),
	            @XmlElement(name="get-tasks-owned", type=GetTasksOwnedCommand.class),
	            @XmlElement(name="get-user", type=GetUserCommand.class),
	            @XmlElement(name="get-user-info", type=GetUserInfoCommand.class),
	            @XmlElement(name="get-user", type=GetUsersCommand.class),
	            @XmlElement(name="init-deadlines", type=InitDeadlinesCommand.class),
	            @XmlElement(name="nominate-task", type=NominateTaskCommand.class),
	            @XmlElement(name="process-sub-task", type=ProcessSubTaskCommand.class),
	            @XmlElement(name="release-task", type=ReleaseTaskCommand.class),
	            @XmlElement(name="remove-all-tasks", type=RemoveAllTasksCommand.class),
	            @XmlElement(name="remove-group", type=RemoveGroupCommand.class),
	            @XmlElement(name="remove-task", type=RemoveTaskCommand.class),
	            @XmlElement(name="remove-tasks", type=RemoveTasksCommand.class),
	            @XmlElement(name="remove-user", type=RemoveUserCommand.class),
	            @XmlElement(name="resume-task", type=ResumeTaskCommand.class),
	            @XmlElement(name="set-task-property", type=SetTaskPropertyCommand.class),
	            @XmlElement(name="skip-task", type=SkipTaskCommand.class),
	            @XmlElement(name="start-task", type=StartTaskCommand.class),
	            @XmlElement(name="stop-task", type=StopTaskCommand.class),
	            @XmlElement(name="suspend-task", type=SuspendTaskCommand.class),
	            @XmlElement(name="undeploy-task-def", type=UndeployTaskDefCommand.class),
	            @XmlElement(name="task-query", type=TaskQueryDataCommand.class),
	            @XmlElement(name="execute-reminder-command", type=ExecuteReminderCommand.class),
	            @XmlElement(name="get-comment-by-id-command", type=GetCommentByIdCommand.class)
    } )
	private TaskCommand<T> mainCommand;

	@XmlElement
	private List<TaskCommand<?>> commands;
	
	public CompositeCommand() {
		
	}
	
	public CompositeCommand(TaskCommand<T> mainCommand, TaskCommand<?>...commands) {
		this.mainCommand = mainCommand;
		this.commands = Arrays.asList(commands);		
	}

	@Override
	public T execute(Context context) {
		if (commands != null) {
			for (TaskCommand<?> cmd : commands) {
				cmd.execute(context);
			}
		}
		return mainCommand.execute(context);
	}

	public TaskCommand<T> getMainCommand() {
		return mainCommand;
	}

	public void setMainCommand(TaskCommand<T> mainCommand) {
		this.mainCommand = mainCommand;
	}

	public List<TaskCommand<?>> getCommands() {
		return commands;
	}

	public void setCommands(List<TaskCommand<?>> commands) {
		this.commands = commands;
	}

	@Override
	public Long getTaskId() {
		if ( mainCommand != null) {
			return mainCommand.getTaskId();	
		}
		return this.taskId;
	}

}

<code block>


package org.jbpm.services.task.commands;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.api.task.model.TaskSummary;
import org.kie.internal.command.Context;
import org.kie.internal.query.data.QueryData;

@XmlRootElement(name="task-query-data-command")
@XmlAccessorType(XmlAccessType.FIELD)
public class TaskQueryDataCommand extends UserGroupCallbackTaskCommand<List<TaskSummary>> {

    
    private static final long serialVersionUID = -6879337395030142688L;

    @XmlElement
    private QueryData queryData;
    
    public TaskQueryDataCommand() { 
        
    }
    
    public TaskQueryDataCommand(QueryData data) { 
        this.queryData = data;
    }
    
    public QueryData getQueryData() {
        return queryData;
    }

    public void setQueryData( QueryData queryData ) {
        this.queryData = queryData;
    }

    @Override
    public List<TaskSummary> execute(Context cntxt) {
        TaskContext context = (TaskContext) cntxt;
        return context.getTaskQueryService().query(userId, queryData);
    }
   
}

<code block>


package org.jbpm.services.task.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;

import org.jbpm.services.task.deadlines.NotificationListener;
import org.jbpm.services.task.deadlines.notifications.impl.email.EmailNotificationListener;
import org.jbpm.services.task.query.DeadlineSummaryImpl;
import org.jbpm.services.task.utils.ClassUtil;
import org.jbpm.services.task.utils.ContentMarshallerHelper;
import org.kie.api.runtime.EnvironmentName;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskData;
import org.kie.internal.command.Context;
import org.kie.internal.task.api.ContentMarshallerContext;
import org.kie.internal.task.api.TaskDeadlinesService.DeadlineType;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.UserInfo;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.EmailNotification;
import org.kie.internal.task.api.model.EmailNotificationHeader;
import org.kie.internal.task.api.model.Escalation;
import org.kie.internal.task.api.model.Language;
import org.kie.internal.task.api.model.Notification;
import org.kie.internal.task.api.model.NotificationEvent;
import org.kie.internal.task.api.model.NotificationType;
import org.mvel2.templates.TemplateRuntime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlRootElement(name="execute-reminder-command")
@XmlAccessorType(XmlAccessType.NONE)
public class ExecuteReminderCommand extends TaskCommand<Void> {
	private static final long serialVersionUID = -1167914440425583650L;
	private static final Logger logger = LoggerFactory.getLogger(ExecuteReminderCommand.class);
	
	private static final String defaultEmailBody="<html> "
    		+ "<body>"
    		+ "<b> You have been assigned to a task ( task_name = ${taskName}, task_id = ${taskId} )</b>"
    		+ "</br>"
    		+ "<b>"
    		+ "Process instance information:"
    		+ "</b>"
    		+ "</hr>"
    		+ "<ul>"
    		+ "<li> DeploymentId : ${deploymentId} </li>"
    		+ "<li> ProcessId : ${processId} </li>" 
    		+ "<li> ProcessInstanceId : ${processInstanceId} </li>" 
    		+ "	</ul>"
    		+ "</b>"
    		+ "</body>"
    		+ "</html>";
    private static final String defaultEmailSubject="You have a task ( ${taskName} ) of process ( ${processId} )";
	@XmlElement
	@XmlSchemaType(name="String")
    private String fromUser;
	@XmlTransient
	private NotificationListener notificationListener;
	
	public ExecuteReminderCommand() {
		
	}
	
	public ExecuteReminderCommand(long taskId,String fromUser) {
		this.taskId = taskId;
		this.fromUser = fromUser;
	}
	
	@Override
	public Void execute(Context context) {
		TaskContext ctx = (TaskContext) context;
		if (notificationListener == null) {
			this.notificationListener = new EmailNotificationListener((UserInfo) context.get(EnvironmentName.TASK_USER_INFO));
		}
		
		TaskPersistenceContext persistenceContext = ctx.getPersistenceContext();
	        
		try {
			Task task = persistenceContext.findTask(taskId);
			TaskData taskData = task.getTaskData();
			
			List<DeadlineSummaryImpl> resultList =null;
			resultList = getAlldeadlines(persistenceContext, taskData);
			
			if( resultList == null || resultList.size() == 0 ){
				if ( taskData.getActualOwner() == null )
					return null ;
        		if ( taskData != null ) {
        		    
        		    if ( DeadlineType.START.isValidStatus(taskData.getStatus()) || DeadlineType.END.isValidStatus(taskData.getStatus())) {
        		    	logger.debug("Sending an Email");
        		    	Map<String, Object> variables = getVariables(ctx, persistenceContext, task,
        							taskData);
        		        Notification notification = buildDefaultNotification(taskData,task);
        		        notificationListener.onNotification(new NotificationEvent(notification, task, variables));
        		    }
        		}
        	}else{
				for(DeadlineSummaryImpl deadlineSummaryImpl : resultList){
					executedeadLine(ctx, persistenceContext, task, deadlineSummaryImpl, taskData);
				}
        	}
        } catch (Exception e) {

        	logger.error("Error when executing deadlines", e);
        }
		return null;
	}

	private List<DeadlineSummaryImpl> getAlldeadlines(TaskPersistenceContext persistenceContext, TaskData taskData) {
		List<DeadlineSummaryImpl> resultList;
		
		if(Status.InProgress == taskData.getStatus() || Status.Suspended == taskData.getStatus()){
			resultList = persistenceContext.queryWithParametersInTransaction("UnescalatedEndDeadlinesByTaskIdForReminder", 
		            persistenceContext.addParametersToMap("taskId", taskId),
		            ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
		}else{
			
			 resultList =persistenceContext.queryWithParametersInTransaction("UnescalatedStartDeadlinesByTaskIdForReminder", 
		                persistenceContext.addParametersToMap("taskId", taskId),
		                ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
		}
		return resultList;
	}

	private Void executedeadLine(TaskContext ctx,
			TaskPersistenceContext persistenceContext, Task task,
			DeadlineSummaryImpl deadlineSummaryImpl,TaskData taskData) {
		Deadline deadline = persistenceContext.findDeadline(deadlineSummaryImpl.getDeadlineId());
		if (task == null || deadline == null) {
			return null;
		}
		
		if (taskData != null) {
		    
		    if (DeadlineType.START.isValidStatus(taskData.getStatus()) || DeadlineType.END.isValidStatus(taskData.getStatus())) {
		        Map<String, Object> variables = getVariables(ctx, persistenceContext, task, taskData);
		        if (deadline == null || deadline.getEscalations() == null ) {
		            return null;
		        }

		        for (Escalation escalation : deadline.getEscalations()) {
		            for (Notification notification : escalation.getNotifications()) {
		                if (notification.getNotificationType() == NotificationType.Email) {
		                    logger.debug("Sending an Email");
		                    notificationListener.onNotification(new NotificationEvent(notification, task, variables));
		                }
		            }
		        }
		    }
		    
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	private Map<String, Object> getVariables(TaskContext ctx, TaskPersistenceContext persistenceContext, Task task,
			TaskData taskData) {
		Map<String, Object> variables;
		Content content = persistenceContext.findContent(taskData.getDocumentContentId());

		if (content != null) {
		    ContentMarshallerContext mContext = ctx.getTaskContentService().getMarshallerContext(task);
		    Object objectFromBytes = ContentMarshallerHelper.unmarshall(content.getContent(), mContext.getEnvironment(), mContext.getClassloader());

		    if (objectFromBytes instanceof Map) {
		        variables = (Map<String, Object>) objectFromBytes;

		    } else {

		        variables = new HashMap<String, Object>();
		        variables.put("content", objectFromBytes);
		    }
		} else {
		    variables = Collections.emptyMap();
		}
		return variables;
	}
	
	private Notification buildDefaultNotification( TaskData taskData,Task task ){
		EmailNotification emailNotificationImpl =  TaskModelProvider.getFactory().newEmialNotification();
		Map<Language, EmailNotificationHeader> map = new HashMap<Language, EmailNotificationHeader>();
		EmailNotificationHeader emailNotificationHeaderImpl = TaskModelProvider.getFactory().newEmailNotificationHeader();
		emailNotificationHeaderImpl.setBody(buildDefafultEmailBody(taskData,task));
		emailNotificationHeaderImpl.setFrom(fromUser);
		emailNotificationHeaderImpl.setReplyTo(fromUser);
		emailNotificationHeaderImpl.setLanguage("en-UK");
		emailNotificationHeaderImpl.setSubject(buildDefafultEmailSubject(taskData, task));
		Language language  = TaskModelProvider.getFactory().newLanguage();
		language.setMapkey("en-UK");
		map.put(language, emailNotificationHeaderImpl);
		emailNotificationImpl.setEmailHeaders(map);
		
		List<OrganizationalEntity> recipients = new ArrayList<OrganizationalEntity>();
		recipients.add(taskData.getActualOwner());
		emailNotificationImpl.setRecipients(recipients);
		
		return emailNotificationImpl;
	}
	
	private String buildDefafultEmailBody(TaskData taskData,Task task){
		Map<String, Object> vars = new HashMap<String, Object>();
		vars.put("taskName", task.getName());
		vars.put("taskId", task.getId());
		vars.put("deploymentId", taskData.getDeploymentId());
		vars.put("processId", taskData.getProcessId());
		vars.put("processInstanceId", taskData.getProcessInstanceId());
		String body = (String) TemplateRuntime.eval(defaultEmailBody, vars);
		return body;
	}
	
	private String buildDefafultEmailSubject(TaskData taskData,Task task){
		Map<String, Object> vars = new HashMap<String, Object>();
		vars.put("taskName", task.getName());
		vars.put("processId", taskData.getProcessId());
		String body = (String) TemplateRuntime.eval(defaultEmailSubject, vars);
		return body;
	}
}

<code block>


package org.jbpm.services.task.commands;

import static org.kie.internal.query.QueryParameterIdentifiers.*;
import static org.kie.internal.query.QueryParameterIdentifiers.BUSINESS_ADMIN_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.POTENTIAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.STAKEHOLDER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;

import org.kie.api.task.TaskService;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.command.Context;


@XmlRootElement(name="get-tasks-by-various-fields-command")
@XmlAccessorType(XmlAccessType.NONE)
@Deprecated
public class GetTasksByVariousFieldsCommand extends UserGroupCallbackTaskCommand<List<TaskSummary>> {

	private static final long serialVersionUID = -4894264083829084547L;

	@XmlElement
    private List<Long> workItemIds;
    
    @XmlElement
    private List<Long> taskIds;
    
    @XmlElement
    private List<Long> processInstanceIds;
    
    @XmlElement
    private List<String> businessAdmins;
    
    @XmlElement
    private List<String> potentialOwners;
    
    @XmlElement
    private List<String> taskOwners;
    
    @XmlElement
    private List<Status> statuses;
    
    @XmlElement
    @XmlSchemaType(name="boolean")
    private Boolean union;
    
    @XmlElement
    private List<String> languages;
    
    @XmlElement
    private Integer maxResults;
    
    
	public GetTasksByVariousFieldsCommand() {
	    
	}

	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        boolean union) { 
	    this(workItemIds, taskIds, procInstIds, busAdmins, potOwners, taskOwners, statuses, null, union);
	}
	
	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        List<String> language, boolean union) { 
	    this(workItemIds, taskIds, procInstIds, busAdmins, potOwners, taskOwners, statuses, language, union, null);
    }

	public GetTasksByVariousFieldsCommand(List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
	        List<String> busAdmins, List<String> potOwners, List<String> taskOwners, List<Status> statuses, 
	        List<String> language, boolean union, Integer maxResults) { 
		this.workItemIds = workItemIds;
		this.taskIds = taskIds;
		this.processInstanceIds = procInstIds;
		this.businessAdmins = busAdmins;
		this.potentialOwners = potOwners;
		this.taskOwners = taskOwners;
		this.statuses = statuses;
		this.languages = language;
		this.union = union;
		this.maxResults = maxResults;
	}
	
	public GetTasksByVariousFieldsCommand(Map<String, List<?>> params, boolean union) { 
	    this(params, union, null);
	}
    
	@SuppressWarnings("unchecked")
	public GetTasksByVariousFieldsCommand(Map<String, List<?>> params, boolean union, Integer maxResults) { 
	    this.union = union;
	    this.maxResults = maxResults;

	    if( params == null ) { 
	        params = new HashMap<String, List<?>>();
	    } else { 
	        this.workItemIds = (List<Long>) params.get(WORK_ITEM_ID_LIST);
	        this.taskIds = (List<Long>) params.get(TASK_ID_LIST);
	        this.processInstanceIds = (List<Long>) params.get(PROCESS_INSTANCE_ID_LIST);
	        this.businessAdmins = (List<String>) params.get(BUSINESS_ADMIN_ID_LIST);
	        this.potentialOwners = (List<String>) params.get(POTENTIAL_OWNER_ID_LIST);
	        this.taskOwners = (List<String>) params.get(ACTUAL_OWNER_ID_LIST);
	        this.statuses = (List<Status>) params.get(TASK_STATUS_LIST);
	    }
	}

    
	public List<TaskSummary> execute(Context cntxt) {
	    TaskContext context = (TaskContext) cntxt;
        
        potentialOwners = populateOrganizationalEntityWithGroupInfo(potentialOwners, context);
    	businessAdmins = populateOrganizationalEntityWithGroupInfo(businessAdmins, context);
    	List<String> stakeHolders = new ArrayList<String>();
    	stakeHolders = populateOrganizationalEntityWithGroupInfo(stakeHolders, context);
    	
        Map<String, List<?>> params = new HashMap<String, List<?>>();
        params.put(WORK_ITEM_ID_LIST, workItemIds);
        params.put(TASK_ID_LIST, taskIds);
        params.put(PROCESS_INSTANCE_ID_LIST, processInstanceIds);
        params.put(BUSINESS_ADMIN_ID_LIST, businessAdmins);
        params.put(POTENTIAL_OWNER_ID_LIST, potentialOwners);
        params.put(STAKEHOLDER_ID_LIST, stakeHolders);
        params.put(ACTUAL_OWNER_ID_LIST, taskOwners);
        params.put(TASK_STATUS_LIST, statuses);
        if( maxResults != null && maxResults.intValue() > 0 ) {
            Integer [] maxResultsArr = { maxResults };
            params.put(MAX_RESULTS, Arrays.asList(maxResultsArr));
        }
       
        if( userId == null || userId.isEmpty() ) { 
           throw new IllegalStateException("A user id is required for this operation: " + GetTasksByVariousFieldsCommand.class.getSimpleName() );
        }
        return context.getTaskQueryService().getTasksByVariousFields(userId, params, union);
    }

    public List<Long> getWorkItemIds() {
        return workItemIds;
    }

    public void setWorkItemIds(List<Long> workItemIds) {
        this.workItemIds = workItemIds;
    }

    public List<Long> getTaskIds() {
        return taskIds;
    }

    public void setTaskIds(List<Long> taskIds) {
        this.taskIds = taskIds;
    }

    public List<Long> getProcInstIds() {
        return processInstanceIds;
    }

    public void setProcInstIds(List<Long> procInstIds) {
        this.processInstanceIds = procInstIds;
    }

    public List<String> getBusAdmins() {
        return businessAdmins;
    }

    public void setBusAdmins(List<String> busAdmins) {
        this.businessAdmins = busAdmins;
    }

    public List<String> getPotOwners() {
        return potentialOwners;
    }

    public void setPotOwners(List<String> potOwners) {
        this.potentialOwners = potOwners;
    }

    public List<String> getTaskOwners() {
        return taskOwners;
    }

    public void setTaskOwners(List<String> taskOwners) {
        this.taskOwners = taskOwners;
    }

    public List<Status> getStatuses() {
        return statuses;
    }

    public void setStatuses(List<Status> statuses) {
        this.statuses = statuses;
    }

    public List<String> getLanguage() {
        return languages;
    }

    public void setLanguage(List<String> language) {
        this.languages = language;
    }

    public Boolean getUnion() {
        return union;
    }

    public void setUnion(Boolean union) {
        this.union = union;
    }

    public Integer getMaxResults() {
        return maxResults;
    }

    public void setMaxResults(Integer maxResults) {
        this.maxResults = maxResults;
    }

    
    protected List<String> populateOrganizationalEntityWithGroupInfo(List<String> entities, TaskContext context) {
    	if (entities != null && entities.size() > 0) {
    		Set<String> groupIds = new HashSet<String>();
    		for (String userId : entities) {
    			List<String> tmp = doUserGroupCallbackOperation(userId, null, context);
    			if (tmp != null) {
    				groupIds.addAll(tmp);
    			}
    		}
    		groupIds.addAll(entities);
    		return new ArrayList<String>(groupIds);
    	}
    	
    	return entities;
    }

}

<code block>


package org.jbpm.services.task.commands;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

import org.jbpm.services.task.query.DeadlineSummaryImpl;
import org.jbpm.services.task.utils.ClassUtil;
import org.kie.internal.command.Context;
import org.kie.internal.task.api.TaskDeadlinesService;
import org.kie.internal.task.api.TaskDeadlinesService.DeadlineType;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@XmlRootElement(name="init-deadlines-command")
@XmlAccessorType(XmlAccessType.NONE)
public class InitDeadlinesCommand extends TaskCommand<Void> {
	
	private static final long serialVersionUID = -8095766991770311489L;
	private static final Logger logger = LoggerFactory.getLogger(InitDeadlinesCommand.class);

	public InitDeadlinesCommand() {		
	}

	@Override
	public Void execute(Context context) {
		TaskContext ctx = (TaskContext) context;
		
		TaskPersistenceContext persistenceContext = ctx.getPersistenceContext();
		TaskDeadlinesService deadlineService = ctx.getTaskDeadlinesService();
		
        try {
	        long now = System.currentTimeMillis();
	        List<DeadlineSummaryImpl> resultList = persistenceContext.queryInTransaction("UnescalatedStartDeadlines",
	        										ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
	        for (DeadlineSummaryImpl summary : resultList) {
	            long delay = summary.getDate().getTime() - now;
	            deadlineService.schedule(summary.getTaskId(), summary.getDeadlineId(), delay, DeadlineType.START);
	
	        }
	        
	        resultList = persistenceContext.queryInTransaction("UnescalatedEndDeadlines",
	        		ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
	        for (DeadlineSummaryImpl summary : resultList) {
	            long delay = summary.getDate().getTime() - now;
	            deadlineService.schedule(summary.getTaskId(), summary.getDeadlineId(), delay, DeadlineType.END);
	        }
        } catch (Exception e) {

        	logger.error("Error when executing deadlines", e);
        }
		return null;
	}

}

<code block>

package org.jbpm.services.task.query;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.Date;
import java.util.List;

import org.kie.api.task.model.Status;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.model.InternalTaskSummary;
import org.kie.internal.task.api.model.SubTasksStrategy;

public class TaskSummaryImpl implements InternalTaskSummary {

    private long id;
    private String name = "";
    private String subject = "";
    private String description = "";
    private Status status;
    private String statusId;
    private int priority;
    private boolean skipable;
    private User actualOwner;
    private String actualOwnerId;
    private User createdBy;
    private String createdById;
    private Date createdOn;
    private Date activationTime;
    private Date expirationTime;
    private long processInstanceId;
    private String processId;
    private long processSessionId;
    private String deploymentId;
    private SubTasksStrategy subTaskStrategy;
    private long parentId;
    private List<String> potentialOwners;
    private boolean quickTaskSummary;

    public TaskSummaryImpl(long id,
            String name,
            String subject,
            String description,
            Status status,
            int priority,
            boolean skipable,
            User actualOwner,
            User createdBy,
            Date createdOn,
            Date activationTime,
            Date expirationTime,
            String processId,
            long processSessionId,
            long processInstanceId,
            String deploymentId,
            SubTasksStrategy subTaskStrategy,
            long parentId) {
        super();
        this.id = id;
        this.processInstanceId = processInstanceId;
        this.name = name;
        this.subject = subject;
        this.description = description;
        this.status = status;
        this.priority = priority;
        this.skipable = skipable;
        this.actualOwner = actualOwner;
        if (actualOwner != null) {
            this.actualOwnerId = actualOwner.getId();
        }
        this.createdBy = createdBy;
        if (createdBy != null) {
            this.createdById = createdBy.getId();
        }
        this.createdOn = createdOn;
        this.activationTime = activationTime;
        this.expirationTime = expirationTime;
        this.processId = processId;
        this.processSessionId = processSessionId;
        this.subTaskStrategy = subTaskStrategy;
        this.parentId = parentId;
        this.deploymentId = deploymentId;
        this.quickTaskSummary = false;
    }

    
    public TaskSummaryImpl(long id,
            String name,
            String description,
            Status status,
            int priority,
            String actualOwner,
            String createdBy,
            Date createdOn,
            Date activationTime,
            Date expirationTime,
            String processId,
            long processInstanceId,
            long parentId,
            String deploymentId,
            boolean skipable) {
        this.id = id;
        this.processInstanceId = processInstanceId;
        this.name = name;
        this.description = description;
        this.status = status;
        if (status != null) {
            this.statusId = status.name();
        }
        this.priority = priority;
        this.actualOwnerId = actualOwner;
        this.createdById = createdBy;
        this.createdOn = createdOn;
        this.activationTime = activationTime;
        this.expirationTime = expirationTime;
        this.processId = processId;
        this.parentId = parentId;
        this.deploymentId = deploymentId;
        this.skipable = skipable;
        this.quickTaskSummary = true;
    }

    public TaskSummaryImpl() {
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeLong(id);

        out.writeLong(processInstanceId);

        if (name != null) {
            out.writeBoolean(true);
            out.writeUTF(name);
        } else {
            out.writeBoolean(false);
        }

        if (subject != null) {
            out.writeBoolean(true);
            out.writeUTF(subject);
        } else {
            out.writeBoolean(false);
        }

        if (description != null) {
            out.writeBoolean(true);
            out.writeUTF(description);
        } else {
            out.writeBoolean(false);
        }

        if (status != null) {
            out.writeBoolean(true);
            out.writeUTF(status.toString());
        } else {
            out.writeBoolean(false);
        }

        out.writeInt(priority);
        out.writeLong(parentId);
        out.writeBoolean(skipable);

        if (actualOwner != null) {
            out.writeBoolean(true);
            actualOwner.writeExternal(out);
        } else {
            out.writeBoolean(false);
        }

        if (createdBy != null) {
            out.writeBoolean(true);
            createdBy.writeExternal(out);
        } else {
            out.writeBoolean(false);
        }
        if (createdOn != null) {
            out.writeBoolean(true);
            out.writeLong(createdOn.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (activationTime != null) {
            out.writeBoolean(true);
            out.writeLong(activationTime.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (expirationTime != null) {
            out.writeBoolean(true);
            out.writeLong(expirationTime.getTime());
        } else {
            out.writeBoolean(false);
        }

        if (processId != null) {
            out.writeBoolean(true);
            out.writeUTF(processId);
        } else {
            out.writeBoolean(false);
        }

        out.writeLong(processSessionId);

        if (subTaskStrategy != null) {
            out.writeBoolean(true);
            out.writeUTF(subTaskStrategy.toString());
        } else {
            out.writeBoolean(false);
        }
        
        if (actualOwnerId != null) {
            out.writeBoolean(true);
            out.writeUTF(actualOwnerId);
        } else {
            out.writeBoolean(false);
        }
        
        if (createdById != null) {
            out.writeBoolean(true);
            out.writeUTF(createdById);
        } else {
            out.writeBoolean(false);
        }
        
        if (statusId != null) {
            out.writeBoolean(true);
            out.writeUTF(statusId);
        } else {
            out.writeBoolean(false);
        }
        
        out.writeBoolean(quickTaskSummary);
    }

    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        id = in.readLong();

        processInstanceId = in.readLong();

        if (in.readBoolean()) {
            name = in.readUTF();
        }

        if (in.readBoolean()) {
            subject = in.readUTF();
        }

        if (in.readBoolean()) {
            description = in.readUTF();
        }

        if (in.readBoolean()) {
            status = Status.valueOf(in.readUTF());
        }

        priority = in.readInt();
        parentId = in.readLong();
        skipable = in.readBoolean();

        if (in.readBoolean()) {
            actualOwner = TaskModelProvider.getFactory().newUser();
            actualOwner.readExternal(in);
        }

        if (in.readBoolean()) {
            createdBy = TaskModelProvider.getFactory().newUser();
            createdBy.readExternal(in);
        }

        if (in.readBoolean()) {
            createdOn = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            activationTime = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            expirationTime = new Date(in.readLong());
        }

        if (in.readBoolean()) {
            processId = in.readUTF();
        }

        processSessionId = in.readLong();

        if (in.readBoolean()) {
            subTaskStrategy = SubTasksStrategy.valueOf(in.readUTF());
        }
        
        if (in.readBoolean()) {
            actualOwnerId = in.readUTF();
        }
        
        if (in.readBoolean()) {
            createdById = in.readUTF();
        }
        
        if (in.readBoolean()) {
            statusId = in.readUTF();
        }
        
        quickTaskSummary = in.readBoolean();
    }

    public Long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Long getProcessInstanceId() {
        return processInstanceId;
    }

    public void setProcessInstanceId(long processInstanceId) {
        this.processInstanceId = processInstanceId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public Integer getPriority() {
        return priority;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public Boolean isSkipable() {
        return skipable;
    }

    public void setSkipable(boolean skipable) {
        this.skipable = skipable;
    }

    public User getActualOwner() {
        if(quickTaskSummary && actualOwnerId != null && !actualOwnerId.equals("")){
            actualOwner = TaskModelProvider.getFactory().newUser(actualOwnerId);
        }
        return actualOwner;
    }

    public void setActualOwner(User actualOwner) {
        this.actualOwner = actualOwner;
    }

    public User getCreatedBy() {
        if(quickTaskSummary && createdById != null && !createdById.equals("")){
            createdBy = TaskModelProvider.getFactory().newUser(createdById);
        }
        return createdBy;
    }

    public void setCreatedBy(User createdBy) {
        this.createdBy = createdBy;
    }

    public Date getCreatedOn() {
        return createdOn;
    }

    public void setCreatedOn(Date createdOn) {
        this.createdOn = createdOn;
    }

    public Date getActivationTime() {
        return activationTime;
    }

    public void setActivationTime(Date activationTime) {
        this.activationTime = activationTime;
    }

    public Date getExpirationTime() {
        return expirationTime;
    }

    public void setExpirationTime(Date expirationTime) {
        this.expirationTime = expirationTime;
    }

    public String getProcessId() {
        return processId;
    }

    public void setProcessId(String processId) {
        this.processId = processId;
    }

    public Long getProcessSessionId() {
        return processSessionId;
    }

    public void setProcessSessionId(long processSessionId) {
        this.processSessionId = processSessionId;
    }

    public SubTasksStrategy getSubTaskStrategy() {
        return subTaskStrategy;
    }

    public void setSubTaskStrategy(SubTasksStrategy subTaskStrategy) {
        this.subTaskStrategy = subTaskStrategy;
    }

    public Long getParentId() {
        return parentId;
    }

    public void setParentId(long parentId) {
        this.parentId = parentId;
    }

    public List<String> getPotentialOwners() {
        return potentialOwners;
    }

    public void setPotentialOwners(List<String> potentialOwners) {
        this.potentialOwners = potentialOwners;
    }

    public Boolean isQuickTaskSummary() {
        return quickTaskSummary;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((activationTime == null) ? 0 : activationTime.hashCode());
        result = prime * result + ((actualOwner == null) ? 0 : actualOwner.hashCode());
        result = prime * result + ((createdBy == null) ? 0 : createdBy.hashCode());
        result = prime * result + ((createdOn == null) ? 0 : createdOn.hashCode());
        result = prime * result + ((description == null) ? 0 : description.hashCode());
        result = prime * result + ((expirationTime == null) ? 0 : expirationTime.hashCode());
        result = prime * result + (int) (id ^ (id >>> 32));
        result = prime * result + (int) (processInstanceId ^ (processInstanceId >>> 32));
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((subTaskStrategy == null) ? 0 : subTaskStrategy.hashCode());
        result = prime * result + priority;
        result = prime * result + (int) (parentId ^ (parentId >>> 32));
        result = prime * result + (skipable ? 1231 : 1237);
        result = prime * result + ((status == null) ? 0 : status.hashCode());
        result = prime * result + ((subject == null) ? 0 : subject.hashCode());
        result = prime * result + ((processId == null) ? 0 : processId.hashCode());
        result = prime * result + (int) (processSessionId ^ (processSessionId >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof TaskSummaryImpl)) {
            return false;
        }
        TaskSummaryImpl other = (TaskSummaryImpl) obj;
        if (processInstanceId != other.processInstanceId) {
            return false;
        }
        if (activationTime == null) {
            if (other.activationTime != null) {
                return false;
            }
        } else if (activationTime.getTime() != other.activationTime.getTime()) {
            return false;
        }
        if (actualOwner == null) {
            if (other.actualOwner != null) {
                return false;
            }
        } else if (!actualOwner.equals(other.actualOwner)) {
            return false;
        }
        if (createdBy == null) {
            if (other.createdBy != null) {
                return false;
            }
        } else if (!createdBy.equals(other.createdBy)) {
            return false;
        }
        if (createdOn == null) {
            if (other.createdOn != null) {
                return false;
            }
        } else if (createdOn.getTime() != other.createdOn.getTime()) {
            return false;
        }
        if (description == null) {
            if (other.description != null) {
                return false;
            }
        } else if (!description.equals(other.description)) {
            return false;
        }
        if (expirationTime == null) {
            if (other.expirationTime != null) {
                return false;
            }
        } else if (expirationTime.getTime() != other.expirationTime.getTime()) {
            return false;
        }
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        if (subTaskStrategy == null) {
            if (other.subTaskStrategy != null) {
                return false;
            }
        } else if (!subTaskStrategy.equals(other.subTaskStrategy)) {
            return false;
        }
        if (priority != other.priority) {
            return false;
        }
        if (parentId != other.parentId) {
            return false;
        }
        if (skipable != other.skipable) {
            return false;
        }
        if (status == null) {
            if (other.status != null) {
                return false;
            }
        } else if (!status.equals(other.status)) {
            return false;
        }
        if (subject == null) {
            if (other.subject != null) {
                return false;
            }
        } else if (!subject.equals(other.subject)) {
            return false;
        }
        if (processId == null) {
            if (other.processId != null) {
                return false;
            }
        } else if (!processId.equals(other.processId)) {
            return false;
        }
        if (processSessionId != other.processSessionId) {
            return false;
        }
        return true;
    }

    @Override
    public String getStatusId() {
        return statusId;
    }

    @Override
    public String getActualOwnerId() {
        return actualOwnerId;
    }

    @Override
    public String getCreatedById() {
        return createdById;
    }

    @Override
    public String getDeploymentId() {
        return deploymentId;
    }

    @Override
    public String toString() {
        return "TaskSummaryImpl{" + "id=" + id + ", name=" + name + ", subject=" + subject + ", description=" + description + ", statusId=" + statusId + ", priority=" + priority + ", skipable=" + skipable + ", actualOwnerId=" + actualOwnerId + ", createdById=" + createdById + ", createdOn=" + createdOn + ", activationTime=" + activationTime + ", expirationTime=" + expirationTime + ", processInstanceId=" + processInstanceId + ", processId=" + processId + ", processSessionId=" + processSessionId + ", deploymentId=" + deploymentId + ", parentId=" + parentId + ", potentialOwners=" + potentialOwners + ", quickTaskSummary=" + quickTaskSummary + '}';
    }
    
    

}

<code block>


package org.jbpm.services.task.query;

import java.util.Date;

public class DeadlineSummaryImpl implements org.kie.internal.task.api.model.DeadlineSummary {
    private long taskId;
    private long deadlineId;
    private Date date;
    
    public DeadlineSummaryImpl(long taskId,
                           long deadlineId,
                           Date date) {
        super();
        this.taskId = taskId;
        this.deadlineId = deadlineId;
        this.date = date;
    }
    
    public long getTaskId() {
        return taskId;
    }
    public void setTaskId(long taskId) {
        this.taskId = taskId;
    }
    public long getDeadlineId() {
        return deadlineId;
    }
    public void setDeadlineId(long deadlineId) {
        this.deadlineId = deadlineId;
    }
    public Date getDate() {
        return date;
    }
    public void setDate(Date date) {
        this.date = date;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((date == null) ? 0 : date.hashCode());
        result = prime * result + (int) (deadlineId ^ (deadlineId >>> 32));
        result = prime * result + (int) (taskId ^ (taskId >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if ( this == obj ) return true;
        if ( obj == null ) return false;
        if ( !(obj instanceof DeadlineSummaryImpl) ) return false;
        DeadlineSummaryImpl other = (DeadlineSummaryImpl) obj;
        if ( date == null ) {
            if ( other.date != null ) return false;
        } else if ( date.getTime() != other.date.getTime() ) return false;
        if ( deadlineId != other.deadlineId ) return false;
        if ( taskId != other.taskId ) return false;
        return true;
    }
    
    
}

<code block>

package org.jbpm.services.task.utils;

import java.io.IOException;
import java.io.Reader;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import org.drools.core.util.MVELSafeHelper;
import org.jbpm.services.task.internals.lifecycle.Allowed;
import org.jbpm.services.task.internals.lifecycle.OperationCommand;
import org.jbpm.services.task.query.DeadlineSummaryImpl;
import org.jbpm.services.task.query.TaskSummaryImpl;
import org.kie.api.command.Command;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.internal.task.api.TaskModelFactory;
import org.kie.internal.task.api.TaskModelProvider;
import org.kie.internal.task.api.UserInfo;
import org.kie.internal.task.api.model.AccessType;
import org.kie.internal.task.api.model.AllowedToDelegate;
import org.kie.internal.task.api.model.CommandName;
import org.kie.internal.task.api.model.NotificationType;
import org.kie.internal.task.api.model.Operation;
import org.kie.internal.task.api.model.SubTasksStrategy;
import org.mvel2.MVEL;
import org.mvel2.ParserConfiguration;
import org.mvel2.ParserContext;


public class MVELUtils { 
    private static Map<String, Class<?>> inputs = new HashMap<String, Class<?>>();
    private static TaskModelFactory factory = TaskModelProvider.getFactory(); 
    
    public static Map<String, Class<?>> getInputs() {
        synchronized (inputs) {
            if (inputs.isEmpty()) {
                
                inputs.put("AccessType", AccessType.class);
                inputs.put("AllowedToDelegate", AllowedToDelegate.class);
                inputs.put("Attachment", factory.newAttachment().getClass());
                inputs.put("BooleanExpression", factory.newBooleanExpression().getClass());
                inputs.put("Comment", factory.newComment().getClass());
                inputs.put("Content", factory.newContent().getClass());
                inputs.put("Deadline", factory.newDeadline().getClass());
                inputs.put("Deadlines", factory.newDeadlines().getClass());
                inputs.put("Delegation", factory.newDelegation().getClass());
                inputs.put("EmailNotification", factory.newEmialNotification().getClass());
                inputs.put("EmailNotificationHeader", factory.newEmailNotificationHeader().getClass());
                inputs.put("Escalation", factory.newEscalation().getClass());
                inputs.put("Group", factory.newGroup().getClass());
                inputs.put("I18NText", factory.newI18NText().getClass());
                inputs.put("Notification", factory.newNotification().getClass());
                inputs.put("NotificationType", NotificationType.class);
                inputs.put("OrganizationalEntity", OrganizationalEntity.class);
                inputs.put("PeopleAssignments", factory.newPeopleAssignments().getClass());
                inputs.put("Reassignment", factory.newReassignment().getClass());
                inputs.put("Status", Status.class);
                inputs.put("Task", factory.newTask().getClass());
                inputs.put("TaskData", factory.newTaskData().getClass());
                inputs.put("User", factory.newUser().getClass());
                inputs.put("UserInfo", UserInfo.class);
                inputs.put("SubTasksStrategy",SubTasksStrategy.class);
                inputs.put("Language", factory.newLanguage().getClass());
                

                
                inputs.put("Allowed", Allowed.class);
                inputs.put("Command", Command.class);
                inputs.put("CommandName", CommandName.class);
                inputs.put("ContentData", factory.newContentData().getClass());
                inputs.put("Operation", Operation.class);
                inputs.put("Operation.Claim", Operation.class);
                inputs.put("Operation.Delegate", Operation.class);
                inputs.put("OperationCommand", OperationCommand.class);

                
                inputs.put("DeadlineSummary", DeadlineSummaryImpl.class);
                inputs.put("TaskSummary", TaskSummaryImpl.class);
            }
            return inputs;
        }
    }
    public static Object eval(Reader reader, Map<String, Object> vars) {
        try {
            return eval(toString(reader), vars);
        } catch (IOException e) {
            throw new RuntimeException("Exception Thrown",e);
        }
    }
    public static Object eval(Reader reader) { 
        try {
            return eval(toString(reader), null);
        } catch (IOException e) {
            throw new RuntimeException("Exception Thrown",e);
        }
    }
    
    public static Object eval(String str, Map<String, Object> vars) {
    	ParserConfiguration pconf = new ParserConfiguration();
    	pconf.addPackageImport("org.jbpm.services.task");

        
    	pconf.addPackageImport("org.jbpm.services.task.query");
    	pconf.addPackageImport("java.util");
    	
    	for(String entry : getInputs().keySet()){
    		pconf.addImport(entry, getInputs().get(entry));
        }
    	ParserContext context = new ParserContext(pconf);
        Serializable s = MVEL.compileExpression(str.trim(), context);

        if( vars != null ) { 
        return MVELSafeHelper.getEvaluator().executeExpression(s, vars);
    }
        else { 
            return MVELSafeHelper.getEvaluator().executeExpression(s);
        }
    }
    public static String toString(Reader reader) throws IOException {
        int charValue  ;
        StringBuffer sb = new StringBuffer(1024);
        while ((charValue = reader.read()) != -1) {
            sb.append((char) charValue);
        }
        return sb.toString();
    }
    
}

<code block>


package org.jbpm.services.task.impl;

import static org.kie.internal.query.QueryParameterIdentifiers.*;

import java.util.List;

import org.drools.core.command.CommandService;
import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.jbpm.services.task.commands.TaskQueryDataCommand;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.QueryContext;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.task.query.TaskQueryBuilder;


public class TaskQueryBuilderImpl extends AbstractQueryBuilderImpl<TaskQueryBuilder> implements TaskQueryBuilder {

    private final CommandService executor; 
    private final String userId;
   
    public TaskQueryBuilderImpl(String userId, CommandService taskCmdService) {
        this.executor = taskCmdService;
        this.userId = userId;
        
        this.queryData.getQueryContext().setAscending(true);
        this.queryData.getQueryContext().setOrderBy("Id");
    }
   
    
    
    @Override
    public TaskQueryBuilder workItemId( long... workItemId ) {
        addLongParameter(WORK_ITEM_ID_LIST, "work item id", workItemId);
        return this;
    }

    @Override
    public TaskQueryBuilder taskId( long... taskId ) {
        addLongParameter(TASK_ID_LIST, "task id", taskId);
        return this;
    }

    @Override
    public TaskQueryBuilder processInstanceId( long... processInstanceId ) {
        addLongParameter(PROCESS_INSTANCE_ID_LIST, "process instance id", processInstanceId);
        return this;
    }

    @Override
    public TaskQueryBuilder initiator( String... createdById ) {
        addObjectParameter(CREATED_BY_LIST, "created by id", createdById);
        return this;
    }

    @Override
    public TaskQueryBuilder stakeHolder( String... stakeHolderId ) {
        addObjectParameter(STAKEHOLDER_ID_LIST, "stakeholder id", stakeHolderId);
        return this;
    }

    @Override
    public TaskQueryBuilder potentialOwner( String... potentialOwnerId ) {
        addObjectParameter(POTENTIAL_OWNER_ID_LIST, "potential owner id", potentialOwnerId);
        return this;
    }

    @Override
    public TaskQueryBuilder taskOwner( String... taskOwnerId ) {
        addObjectParameter(ACTUAL_OWNER_ID_LIST, "task owner id", taskOwnerId);
        return this;
    }

    @Override
    public TaskQueryBuilder businessAdmin( String... businessAdminId ) {
        addObjectParameter(BUSINESS_ADMIN_ID_LIST, "business administrator id", businessAdminId);
        return this;
    }

    @Override
    public TaskQueryBuilder status( Status... status ) {
        addObjectParameter(TASK_STATUS_LIST, "status", status);
        return this;
    }

    @Override
    public TaskQueryBuilder deploymentId( String... deploymentId ) {
        addObjectParameter(DEPLOYMENT_ID_LIST, "deployment id", deploymentId);
        return this;
    }

    @Override
    public TaskQueryBuilder language( String language ) {
        if( language == null || language.isEmpty() ) { 
            StringBuilder msg = new StringBuilder( (language == null ? "A null" : "An empty") );
            throw new IllegalArgumentException( msg.append(" language criteria is invalid.").toString() );
        }
        List<String> languages = this.queryData.getAppropriateParamList(LANGUAGE, language, 1);
        if( languages.isEmpty() ) { 
            languages.add(language);
        } else { 
            languages.set(0, language);
        }
        return this;
    }

    @Override
    public TaskQueryBuilder orderBy( OrderBy orderBy ) {
        if( orderBy == null ) { 
            throw new IllegalArgumentException( "A null order by criteria is invalid." );
        }
        String orderByString;
        switch( orderBy ) { 
        case taskId:
            orderByString = "t.id";
            break;
        case processInstanceId:
            orderByString = "t.taskData.processInstanceId";
            break;
        case taskName:
            orderByString = "t.name";
            break;
        case taskStatus:
            orderByString = "t.taskData.status";
            break;
        case createdOn:
            orderByString = "t.taskData.createdOn";
            break;
        case createdBy:
            orderByString = "t.taskData.createdBy.id";
            break;
        default:
           throw new UnsupportedOperationException("Unsupported order by arqument: " + orderBy.toString() );
        }
        this.queryData.getQueryContext().setOrderBy(orderByString);
        return this;
    }

    @Override
    public TaskQueryBuilder clear() {
        super.clear();
        getQueryData().getQueryContext().setAscending(true);
        getQueryData().getQueryContext().setOrderBy("Id");
        return this;
    }

    @Override
    public ParametrizedQuery<TaskSummary> buildQuery() {
        return new ParametrizedQuery<TaskSummary>() {
            private QueryData queryData = new QueryData(getQueryData());
            @Override
            public List<TaskSummary> getResultList() {
                TaskQueryDataCommand cmd = new TaskQueryDataCommand(queryData);
                cmd.setUserId(userId);
                return executor.execute(cmd);
            }
        };
    }

}

<code block>
    
package org.jbpm.services.task.impl;

import org.drools.core.common.InternalWorkingMemory;
import org.drools.core.time.Job;
import org.drools.core.time.JobContext;
import org.drools.core.time.JobHandle;
import org.drools.core.time.TimerService;
import org.drools.core.time.Trigger;
import org.drools.core.time.impl.IntervalTrigger;
import org.jbpm.process.core.timer.NamedJobContext;
import org.jbpm.process.core.timer.TimerServiceRegistry;
import org.jbpm.process.core.timer.impl.GlobalTimerService;
import org.jbpm.services.task.commands.ExecuteDeadlinesCommand;
import org.jbpm.services.task.commands.InitDeadlinesCommand;
import org.jbpm.services.task.deadlines.NotificationListener;
import org.jbpm.services.task.query.DeadlineSummaryImpl;
import org.jbpm.services.task.utils.ClassUtil;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.task.model.Task;
import org.kie.internal.task.api.TaskDeadlinesService;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.Deadlines;
import org.kie.internal.task.api.model.InternalTask;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TaskDeadlinesServiceImpl implements TaskDeadlinesService {
    
    private static final Logger logger = LoggerFactory.getLogger(TaskDeadlinesServiceImpl.class);
    
    protected static volatile CommandExecutor instance;
    
    protected static NotificationListener notificationListener;

	
    private volatile static ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(3);
    private volatile static Map<Long, List<ScheduledFuture<ScheduledTaskDeadline>>> startScheduledTaskDeadlines = new ConcurrentHashMap<Long, List<ScheduledFuture<ScheduledTaskDeadline>>>();
    private volatile static Map<Long, List<ScheduledFuture<ScheduledTaskDeadline>>> endScheduledTaskDeadlines = new ConcurrentHashMap<Long, List<ScheduledFuture<ScheduledTaskDeadline>>>();
    private volatile static Map<String, JobHandle> jobHandles = new ConcurrentHashMap<String, JobHandle>();

    private TaskPersistenceContext persistenceContext;

    
    public TaskDeadlinesServiceImpl() {
    }
    
    public TaskDeadlinesServiceImpl(TaskPersistenceContext persistenceContext) {
    	this.persistenceContext = persistenceContext;
    }

    public void setPersistenceContext(TaskPersistenceContext persistenceContext) {
        this.persistenceContext = persistenceContext;
    }


    public void schedule(long taskId, long deadlineId, long delay, DeadlineType type) {
        Task task = persistenceContext.findTask(taskId);
        String deploymentId = task.getTaskData().getDeploymentId();

        TimerService timerService = TimerServiceRegistry.getInstance().get(deploymentId + TimerServiceRegistry.TIMER_SERVICE_SUFFIX);
        if (timerService != null && timerService instanceof GlobalTimerService) {
            TaskDeadlineJob deadlineJob = new TaskDeadlineJob(taskId, deadlineId, type);
            Trigger trigger = new IntervalTrigger( timerService.getCurrentTime(),
                    null,
                    null,
                    -1,
                    delay,
                    0,
                    null,
                    null ) ;
            JobHandle handle = timerService.scheduleJob(deadlineJob, new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()), trigger);
            logger.debug( "scheduling timer job for deadline {} and task {}  using timer service {}", deadlineJob.getId(), taskId, timerService);
            jobHandles.put(deadlineJob.getId(), handle);

        } else {
            ScheduledFuture<ScheduledTaskDeadline> scheduled = scheduler.schedule(new ScheduledTaskDeadline(taskId, deadlineId, type), delay, TimeUnit.MILLISECONDS);
            
            List<ScheduledFuture<ScheduledTaskDeadline>> knownFutures = null;
            if (type == DeadlineType.START) {
                knownFutures = startScheduledTaskDeadlines.get(taskId);
            } else if (type == DeadlineType.END) {
                knownFutures = endScheduledTaskDeadlines.get(taskId);
            }
            if (knownFutures == null) {
                knownFutures = new CopyOnWriteArrayList<ScheduledFuture<ScheduledTaskDeadline>>();
            }

            knownFutures.add(scheduled);
                        
            if (type == DeadlineType.START) {
                startScheduledTaskDeadlines.put(taskId, knownFutures);
            } else if (type == DeadlineType.END) {
                endScheduledTaskDeadlines.put(taskId, knownFutures);
            }
        }

    }

    public void unschedule(long taskId, DeadlineType type) {
        Task task = persistenceContext.findTask(taskId);
        String deploymentId = task.getTaskData().getDeploymentId();
        
        Deadlines deadlines = ((InternalTask)task).getDeadlines();

        TimerService timerService = TimerServiceRegistry.getInstance().get(deploymentId + TimerServiceRegistry.TIMER_SERVICE_SUFFIX);
        if (timerService != null && timerService instanceof GlobalTimerService) {
 
            if (type == DeadlineType.START) {
                List<Deadline> startDeadlines = deadlines.getStartDeadlines();
                List<DeadlineSummaryImpl> resultList = (List<DeadlineSummaryImpl>)persistenceContext.queryWithParametersInTransaction("UnescalatedStartDeadlinesByTaskId",
                		persistenceContext.addParametersToMap("taskId", taskId),
						ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
                for (DeadlineSummaryImpl summary : resultList) {
                    TaskDeadlineJob deadlineJob = new TaskDeadlineJob(summary.getTaskId(), summary.getDeadlineId(), DeadlineType.START);
                    logger.debug("unscheduling timer job for deadline {} {} and task {}  using timer service {}", deadlineJob.getId(), summary.getDeadlineId(), taskId, timerService);
                    JobHandle jobHandle = jobHandles.remove(deadlineJob.getId()); 
                    if (jobHandle == null) {        
                        jobHandle = ((GlobalTimerService) timerService).buildJobHandleForContext(new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()));
                    }
                    timerService.removeJob(jobHandle);
                    
                    for (Deadline deadline : startDeadlines) {
                        if (deadline.getId() == summary.getDeadlineId()) {
                            deadline.setEscalated(true);
                        }
                    }
                }
            } else if (type == DeadlineType.END) {
                List<Deadline> endDeadlines = deadlines.getStartDeadlines();
                List<DeadlineSummaryImpl> resultList = (List<DeadlineSummaryImpl>)persistenceContext.queryWithParametersInTransaction("UnescalatedEndDeadlinesByTaskId",
                		persistenceContext.addParametersToMap("taskId", taskId),
						ClassUtil.<List<DeadlineSummaryImpl>>castClass(List.class));
                for (DeadlineSummaryImpl summary : resultList) {
                    
                    TaskDeadlineJob deadlineJob = new TaskDeadlineJob(summary.getTaskId(), summary.getDeadlineId(), DeadlineType.END);
                    logger.debug("unscheduling timer job for deadline {} and task {}  using timer service {}", deadlineJob.getId(), taskId, timerService);
                    JobHandle jobHandle = jobHandles.remove(deadlineJob.getId()); 
                    if (jobHandle == null) {        
                        jobHandle = ((GlobalTimerService) timerService).buildJobHandleForContext(new TaskDeadlineJobContext(deadlineJob.getId(), task.getTaskData().getProcessInstanceId()));
                    }
                    timerService.removeJob(jobHandle);
                    
                    for (Deadline deadline : endDeadlines) {
                        if (deadline.getId() == summary.getDeadlineId()) {
                            deadline.setEscalated(true);
                        }
                    }
                }
            }
            
        } else {
            List<ScheduledFuture<ScheduledTaskDeadline>> knownFutures = null;
            if (type == DeadlineType.START) {
                knownFutures = startScheduledTaskDeadlines.get(taskId);
            } else if (type == DeadlineType.END) {
                knownFutures = endScheduledTaskDeadlines.get(taskId);
            }
            if (knownFutures == null) {
                return;
            }
            Iterator<ScheduledFuture<ScheduledTaskDeadline>> it = knownFutures.iterator();
            while (it.hasNext()) {
                ScheduledFuture<ScheduledTaskDeadline> scheduled = it.next();
                try {
                    if (!scheduled.isDone() && !scheduled.isCancelled()) {
                        scheduled.cancel(true);
                    }
    
                } catch (Exception e) {
                    logger.error("Error while cancelling scheduled deadline task for Task with id {} -> {}", taskId, e);
                }
            }
        }
    }

    public static class ScheduledTaskDeadline implements
            Callable<ScheduledTaskDeadline>, Serializable {

        private static final long serialVersionUID = 1L;

        private long taskId;
        private long deadlineId;
        private DeadlineType type;

        public ScheduledTaskDeadline(long taskId,
                long deadlineId, DeadlineType type) {
            this.taskId = taskId;
            this.deadlineId = deadlineId;
            this.type = type;
        }

        public long getTaskId() {
            return taskId;
        }

        public long getDeadlineId() {
            return deadlineId;
        }
        
        public DeadlineType getType() {
            return this.type;
        }

        public ScheduledTaskDeadline call() throws Exception {
        	CommandExecutor executor = TaskDeadlinesServiceImpl.getInstance();
            if (executor != null) {
                executor.execute(new ExecuteDeadlinesCommand(taskId, deadlineId, type, notificationListener));
            } else {
                logger.error("TaskDeadlineService instance is not available, most likely was not properly initialized - Job did not run!");
            }
            return null;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + (int) (deadlineId ^ (deadlineId >>> 32));
            result = prime * result + (int) (taskId ^ (taskId >>> 32));
            result = prime * result + type.hashCode();
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (!(obj instanceof ScheduledTaskDeadline)) {
                return false;
            }
            ScheduledTaskDeadline other = (ScheduledTaskDeadline) obj;
            if (deadlineId != other.deadlineId) {
                return false;
            }
            if (taskId != other.taskId) {
                return false;
            }
            if (type == null) {
                if (other.getType() != null) {
                    return false;
                }
            } else if (type.equals(other.getType())) {
                return false;
            }
            return true;
        }
    }
    
    @SuppressWarnings("unused")
    private static class TaskDeadlineJob implements Job, Serializable {

        private static final long serialVersionUID = -2453658968872574615L;
        private long taskId;
        private long deadlineId;
        private DeadlineType type;

        public TaskDeadlineJob(long taskId, long deadlineId, DeadlineType type) {
            this.taskId = taskId;
            this.deadlineId = deadlineId;
            this.type = type;
        }
        
        public long getTaskId() {
            return taskId;
        }

        public long getDeadlineId() {
            return deadlineId;
        }
        
        public DeadlineType getType() {
            return this.type;
        }
        @Override
        public void execute(JobContext ctx) {
            
            CommandExecutor executor = TaskDeadlinesServiceImpl.getInstance();
            if (executor != null) {
                executor.execute(new ExecuteDeadlinesCommand(taskId, deadlineId, type, notificationListener));
            } else {
                logger.error("TaskDeadlineService instance is not available, most likely was not properly initialized - Job did not run!");
            }            
        }
        
        public String getId() {
            return taskId +"_"+deadlineId+"_"+type;
        }
        
    }
    
    private static class TaskDeadlineJobContext implements NamedJobContext {

        private static final long serialVersionUID = -6838102884655249845L;
        private JobHandle jobHandle;
        private String jobName;
        private Long processInstanceId;
        
        public TaskDeadlineJobContext(String jobName, Long processInstanceId) {
            this.jobName = jobName;
            this.processInstanceId = processInstanceId;
        }
        
        @Override
        public void setJobHandle(JobHandle jobHandle) {
            this.jobHandle = jobHandle;
        }

        @Override
        public JobHandle getJobHandle() {
            return jobHandle;
        }

        @Override
        public String getJobName() {
            return jobName;
        }

		@Override
		public Long getProcessInstanceId() {
			return processInstanceId;
		}

        @Override
        public InternalWorkingMemory getWorkingMemory() {
            return null;
        }
    }


    public static void setNotificationListener(NotificationListener notificationListener) {
		TaskDeadlinesServiceImpl.notificationListener = notificationListener;
	}

    public static CommandExecutor getInstance() {
        return instance;
    }

    public static synchronized void initialize(CommandExecutor instance) {
    	if (instance != null) {
    	    TaskDeadlinesServiceImpl.instance = instance;
	        getInstance().execute(new InitDeadlinesCommand());
    	}        
    }
    
    public static synchronized void reset() {
    	dispose();
        scheduler = new ScheduledThreadPoolExecutor(3);        
    }

    public static synchronized void dispose() {
        try {
            if (scheduler != null) {
                scheduler.shutdownNow();
            }        
            startScheduledTaskDeadlines.clear();
            endScheduledTaskDeadlines.clear();
            jobHandles.clear();
            notificationListener = null;
            TaskDeadlinesServiceImpl.instance = null;
        } catch (Exception e) {
            logger.error("Error encountered when disposing TaskDeadlineService", e);
        }
    }
}

<code block>


package org.jbpm.services.task.impl;

import static org.kie.internal.query.QueryParameterIdentifiers.ACTUAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ASCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.BUSINESS_ADMIN_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CREATED_BY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DEPLOYMENT_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DESCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.FILTER;
import static org.kie.internal.query.QueryParameterIdentifiers.FIRST_RESULT;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_BY;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_TYPE;
import static org.kie.internal.query.QueryParameterIdentifiers.POTENTIAL_OWNER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.STAKEHOLDER_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.TASK_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.jbpm.query.jpa.impl.QueryAndParameterAppender;
import org.jbpm.query.jpa.service.QueryModificationService;
import org.jbpm.services.task.utils.ClassUtil;
import org.kie.api.task.UserGroupCallback;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.query.QueryContext;
import org.kie.internal.query.QueryFilter;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.TaskQueryService;
import org.kie.internal.task.api.model.InternalTaskSummary;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class TaskQueryServiceImpl implements TaskQueryService {

    private static final Logger logger = LoggerFactory.getLogger(TaskQueryServiceImpl.class);
    
    private TaskPersistenceContext persistenceContext;
    private UserGroupCallback userGroupCallback;
    
    protected List<?> adoptList(List<?> source, List<?> values) {
    	
    	if (source == null || source.isEmpty()) {
    		List<Object> data = new ArrayList<Object>();    		
    		for (Object value : values) {
    			data.add(value);
    		}
    		
    		return data;
    	}
    	return source;
    }
    
    protected void applyQueryFilter(Map<String, Object> params, QueryFilter queryFilter) {
    	if (queryFilter != null) {
    	    applyQueryContext(params, queryFilter);
        	if (queryFilter.getFilterParams() != null && !queryFilter.getFilterParams().isEmpty()) {
        		params.put(FILTER, queryFilter.getFilterParams());
        		for(String key : queryFilter.getParams().keySet()){
                    params.put(key, queryFilter.getParams().get(key));
                }
        	}
        }
    }
    
    protected void applyQueryContext(Map<String, Object> params, QueryContext queryContext) {
    	if (queryContext != null) {
    	    Integer offset = queryContext.getOffset(); 
    	    if( offset != null && offset > 0 ) { 
    	        params.put(FIRST_RESULT, offset);
    	    }
    	    Integer count = queryContext.getCount();
    	    if( count != null && count > 0 ) { 
    	        params.put(MAX_RESULTS, count);
    	    }
        	
        	if (queryContext.getOrderBy() != null && !queryContext.getOrderBy().isEmpty()) {
        		params.put(ORDER_BY, queryContext.getOrderBy());
        
        		if( queryContext.isAscending() != null ) { 
        		    if (queryContext.isAscending()) {
        		        params.put(ORDER_TYPE, ASCENDING_VALUE);
        		    } else {
        		        params.put(ORDER_TYPE, DESCENDING_VALUE);
        		    }
        		}
        	}
    	}
    }
    
    private static final List<Status> allActiveStatus = new ArrayList<Status>(){{
        this.add(Status.Created);
        this.add(Status.Ready);
        this.add(Status.Reserved);
        this.add(Status.InProgress);
        this.add(Status.Suspended);
      }};

    public TaskQueryServiceImpl() {
    }
    
    public TaskQueryServiceImpl(TaskPersistenceContext persistenceContext, UserGroupCallback userGroupCallback) {
    	this.persistenceContext = persistenceContext;
    	this.userGroupCallback = userGroupCallback;
    }

    public void setPersistenceContext(TaskPersistenceContext persistenceContext) {
        this.persistenceContext = persistenceContext;
    }

    public void setUserGroupCallback(UserGroupCallback userGroupCallback) {
        this.userGroupCallback = userGroupCallback;
    }
    
    public List<TaskSummary> getTasksAssignedAsBusinessAdministrator(String userId) {
        return getTasksAssignedAsBusinessAdministratorByStatus(userId,allActiveStatus);
    }

    public List<TaskSummary> getTasksAssignedAsExcludedOwner(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsExcludedOwner", 
        		persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwner", 
        		persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds) {
        if(groupIds == null || groupIds.isEmpty()){
          return getTasksAssignedAsPotentialOwner(userId);
        }
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("groupIds", groupIds);
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerWithGroups", 
                params,
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedByGroup(String groupId) {
        if(groupId == null || groupId.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroup", 
                persistenceContext.addParametersToMap("groupId", groupId ),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedByGroupsByExpirationDateOptional(List<String> groupIds, Date expirationDate) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>)persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroupsByExpirationDateOptional", 
                persistenceContext.addParametersToMap("groupIds", groupIds, "expirationDate", expirationDate),
                ClassUtil.<List<Object[]>>castClass(List.class));
                
        return collectTasksByPotentialOwners(tasksByGroups);
    }  
    
    protected List<TaskSummary> collectTasksByPotentialOwners(List<Object[]> tasksByGroups) {
        Set<Long> tasksIds = Collections.synchronizedSet(new HashSet<Long>());
        Map<Long, List<String>> potentialOwners = Collections.synchronizedMap(new HashMap<Long, List<String>>());
        for (Object o : tasksByGroups) {
            Object[] get = (Object[]) o;
            tasksIds.add((Long) get[0]);
            if (potentialOwners.get((Long) get[0]) == null) {
                potentialOwners.put((Long) get[0], new ArrayList<String>());
            }
            potentialOwners.get((Long) get[0]).add((String) get[1]);
        }
        if (!tasksIds.isEmpty()) {
            List<TaskSummary> tasks = (List<TaskSummary>)persistenceContext.queryWithParametersInTransaction("TaskSummariesByIds", 
                    persistenceContext.addParametersToMap("taskIds", tasksIds),
                    ClassUtil.<List<TaskSummary>>castClass(List.class));
                    

            for (TaskSummary ts : tasks) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
            return tasks;
        }
        return new ArrayList<TaskSummary>();
    }
    
    public List<TaskSummary> getTasksAssignedByGroupsByExpirationDate(List<String> groupIds, Date expirationDate) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroupsByExpirationDate", 
                persistenceContext.addParametersToMap("groupIds", groupIds, "expirationDate", expirationDate),
                ClassUtil.<List<Object[]>>castClass(List.class));
        return collectTasksByPotentialOwners(tasksByGroups);
    }        
            
    public List<TaskSummary> getTasksAssignedByGroups(List<String> groupIds) {
        if(groupIds == null || groupIds.isEmpty()){
          return Collections.EMPTY_LIST;
        }
        List<Object[]> tasksByGroups = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerByGroups", 
                persistenceContext.addParametersToMap("groupIds", groupIds),
                ClassUtil.<List<Object[]>>castClass(List.class));
                
        Set<Long> tasksIds = Collections.synchronizedSet(new HashSet<Long>());
        Map<Long, List<String>> potentialOwners = Collections.synchronizedMap(new HashMap<Long, List<String>>());
        for (Object o : tasksByGroups) {
            Object[] get = (Object[]) o;
            tasksIds.add((Long) get[0]);
            if (potentialOwners.get((Long) get[0]) == null) {
                potentialOwners.put((Long) get[0], new ArrayList<String>());
            }
            potentialOwners.get((Long) get[0]).add((String) get[1]);
        }
        if (!tasksIds.isEmpty()) {
            List<TaskSummary> tasks = (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TaskSummariesByIds", 
                        persistenceContext.addParametersToMap("taskIds", tasksIds),
                        ClassUtil.<List<TaskSummary>>castClass(List.class));

            for (TaskSummary ts : tasks) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
            return tasks;
        }
        return new ArrayList<TaskSummary>();
    }

    public Map<Long, List<OrganizationalEntity>> getPotentialOwnersForTaskIds(List<Long> taskIds){
        List<Object[]> potentialOwners = persistenceContext.queryWithParametersInTransaction("GetPotentialOwnersForTaskIds", 
                persistenceContext.addParametersToMap("taskIds", taskIds),
                ClassUtil.<List<Object[]>>castClass(List.class));
        
        Map<Long, List<OrganizationalEntity>> potentialOwnersMap = new HashMap<Long, List<OrganizationalEntity>>();
        Long currentTaskId = 0L;
        for(Object[] item : potentialOwners){
            Long taskId = (Long) item[0];
            OrganizationalEntity potentialOwner = (OrganizationalEntity)item[1];
            if(currentTaskId != taskId){
                currentTaskId = taskId;
            }
            
            if(potentialOwnersMap.get(currentTaskId) == null){
                potentialOwnersMap.put(currentTaskId, new ArrayList<OrganizationalEntity>());
            }
            potentialOwnersMap.get(currentTaskId).add(potentialOwner);
        }
        
        return potentialOwnersMap;
    
    }
    
    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, int firstResult, int maxResults) {
        if(groupIds == null || groupIds.isEmpty()){
          return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwner", 
                                    persistenceContext.addParametersToMap("userId", userId, 
                                                    "firstResult", firstResult, "maxResults", maxResults),
                                                    ClassUtil.<List<TaskSummary>>castClass(List.class));
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerWithGroups", 
                                    persistenceContext.addParametersToMap("userId", userId, "groupIds", groupIds, 
                                                    "firstResult", firstResult, "maxResults", maxResults),
                                                    ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsRecipient(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsRecipient", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsTaskInitiator(String userId) {
        return (List<TaskSummary>)  persistenceContext.queryWithParametersInTransaction("TasksAssignedAsTaskInitiator", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksAssignedAsTaskStakeholder(String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsTaskStakeholder", 
                persistenceContext.addParametersToMap("userId", userId),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    public List<TaskSummary> getTasksOwned(String userId) {
        return getTasksOwned(userId, null, null);

    }
    
   
    

    public List<TaskSummary> getTasksOwnedByStatus(String userId, List<Status> status) {

        List<TaskSummary> taskOwned =  getTasksOwned(userId, null, null);

        if (!taskOwned.isEmpty()) {
            Set<Long> tasksIds = new HashSet<Long>();
            for (TaskSummary ts : taskOwned) {
                tasksIds.add(ts.getId());
            }

            List<Object[]> tasksPotentialOwners = (List<Object[]>) persistenceContext.queryWithParametersInTransaction("TasksOwnedPotentialOwnersByTaskIds",
                        persistenceContext.addParametersToMap("taskIds", tasksIds),
                        ClassUtil.<List<Object[]>>castClass(List.class));

            Map<Long, List<String>> potentialOwners = new HashMap<Long, List<String>>();
            for (Object o : tasksPotentialOwners) {
                Object[] get = (Object[]) o;
                tasksIds.add((Long) get[0]);
                if (potentialOwners.get((Long) get[0]) == null) {
                    potentialOwners.put((Long) get[0], new ArrayList<String>());
                }
                potentialOwners.get((Long) get[0]).add((String) get[1]);
            }
            for (TaskSummary ts : taskOwned) {
                ((InternalTaskSummary) ts).setPotentialOwners(potentialOwners.get(ts.getId()));
            }
        } else {
            return new ArrayList<TaskSummary>(0);
        }

        return taskOwned;
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByStatus(String userId, List<Status> status) {
        return getTasksAssignedAsPotentialOwner(userId, null, status, null);
                
    }

    public List<TaskSummary> getTasksAssignedAsPotentialOwner(String userId, List<String> groupIds, List<Status> status, QueryFilter filter) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", adoptList(status, allActiveStatus));        
        params.put("groupIds", adoptList(groupIds, Collections.singletonList("")));
        
        applyQueryFilter(params, filter);

        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("NewTasksAssignedAsPotentialOwner", 
                                        params,
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }


    public List<TaskSummary> getTasksOwned(String userId, List<Status> status, QueryFilter filter) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        if(status == null){
            status = new ArrayList<Status>();
            status.add(Status.Reserved);
            status.add(Status.InProgress);
        }
        params.put("status", status);
        applyQueryFilter(params, filter);

        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("NewTasksOwned", 
                                        params,
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    }
    
    
    public List<TaskSummary> getSubTasksAssignedAsPotentialOwner(long parentId, String userId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("SubTasksAssignedAsPotentialOwner",
                                        persistenceContext.addParametersToMap("parentId", parentId, "userId", userId),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
                
    }

    public List<TaskSummary> getSubTasksByParent(long parentId) {
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("GetSubTasksByParentTaskId", 
                persistenceContext.addParametersToMap("parentId", parentId),
                ClassUtil.<List<TaskSummary>>castClass(List.class)); 
                
    }

    public int getPendingSubTasksByParent(long parentId) {
        return  persistenceContext.queryWithParametersInTransaction("GetSubTasksByParentTaskId", 
                                persistenceContext.addParametersToMap("parentId", parentId),
                                ClassUtil.<List<TaskSummary>>castClass(List.class)).size();
    }

    public Task getTaskInstanceById(long taskId) {
        Task taskInstance = persistenceContext.findTask(taskId);
        return taskInstance;

    }

    public Task getTaskByWorkItemId(long workItemId) {
        List<Task> tasks = (List<Task>)persistenceContext.queryWithParametersInTransaction("TaskByWorkItemId", 
                                persistenceContext.addParametersToMap("workItemId", workItemId,"maxResults", 1),
                                ClassUtil.<List<Task>>castClass(List.class));
        if (tasks.isEmpty())
            return null;
        else 
            return (Task) (tasks.get(0));
    }
    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDate(String userId, List<String> groupIds,
                                            List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        
        return (List<TaskSummary>) getTasksAssignedAsPotentialOwner(userId, groupIds, status,
                new QueryFilter("t.taskData.expirationTime = :expirationDate", params, "order by t.id", false));
        
        

    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDateOptional(String userId, List<String> groupIds,
                        List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksAssignedAsPotentialOwner(userId, groupIds, status,
                new QueryFilter("(t.taskData.expirationTime = :expirationDate or t.taskData.expirationTime is null)", params, "order by t.id", false));
        
    }
    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDate(String userId,  List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksOwned(userId, status,
                new QueryFilter( "t.taskData.expirationTime = :expirationDate", params, "order by t.id", false));
        
        

    }
   

    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDateOptional(String userId, List<Status> status, Date expirationDate) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("expirationDate", expirationDate);
        return (List<TaskSummary>) getTasksOwned(userId, status,
                new QueryFilter( "(t.taskData.expirationTime = :expirationDate or t.taskData.expirationTime is null)"
                        , params, "order by t.id", false));
        
    }
    
    @Override
    public List<TaskSummary> getTasksOwnedByExpirationDateBeforeSpecifiedDate(String userId, List<Status> status, Date date) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksOwnedWithParticularStatusByExpirationDateBeforeSpecifiedDate",
                persistenceContext.addParametersToMap("userId", userId, "status", status, "date", date),
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> getTasksByStatusByProcessInstanceId(long processInstanceId, List<Status> status) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        List<TaskSummary> tasks = (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksByStatusByProcessId",
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId, 
                                        "status", status),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    
        return tasks;
    }

    @Override
    public List<TaskSummary> getTasksByStatusByProcessInstanceIdByTaskName(long processInstanceId, List<Status> status, String taskName) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }    
        List<TaskSummary> tasks = (List<TaskSummary>)persistenceContext.queryWithParametersInTransaction("TasksByStatusByProcessIdByTaskName", 
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId,
                                        "status", status, 
                                        "taskName", taskName),
                                        ClassUtil.<List<TaskSummary>>castClass(List.class));
    
        return tasks;
    }

    @Override
    public List<Long> getTasksByProcessInstanceId(long processInstanceId) {
        List<Long> tasks = (List<Long>)persistenceContext.queryWithParametersInTransaction("TasksByProcessInstanceId",
                persistenceContext.addParametersToMap("processInstanceId", processInstanceId),
                ClassUtil.<List<Long>>castClass(List.class));
        return tasks;
    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDate(String userId, List<Status> status, Date expirationDate) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerStatusByExpirationDate",
                          persistenceContext.addParametersToMap("userId", userId, "groupIds", "", "status", status, "expirationDate", expirationDate),
                          ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByExpirationDateOptional(String userId, List<Status> status, Date expirationDate) {
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsPotentialOwnerStatusByExpirationDateOptional",
                    persistenceContext.addParametersToMap("userId", userId, "groupIds", "", "status", status, "expirationDate", expirationDate),
                    ClassUtil.<List<TaskSummary>>castClass(List.class)); 
    }
   
    
    @Deprecated
    public List<TaskSummary> getTasksByVariousFields(String userId, List<Long> workItemIds, List<Long> taskIds, List<Long> procInstIds,
            List<String> busAdmins, List<String> potOwners, List<String> taskOwners, 
            List<Status> status,  boolean union, Integer maxResults) {
        Map<String, List<?>> params = new HashMap<String, List<?>>();
        params.put(WORK_ITEM_ID_LIST, workItemIds);
        params.put(TASK_ID_LIST, taskIds);
        params.put(PROCESS_INSTANCE_ID_LIST, procInstIds);
        params.put(BUSINESS_ADMIN_ID_LIST, busAdmins);
        params.put(POTENTIAL_OWNER_ID_LIST, potOwners);
        params.put(ACTUAL_OWNER_ID_LIST, taskOwners);
        if(status == null || status.isEmpty()){
          status = allActiveStatus;
        }
        params.put(TASK_STATUS_LIST, status);
        
        if( maxResults != null ) {
            if( maxResults <= 0 ) { 
                return new ArrayList<TaskSummary>();
            }
            Integer [] maxResultsArr = { maxResults };
            params.put(MAX_RESULTS, Arrays.asList(maxResultsArr));
        }
        
        return getTasksByVariousFields(userId, params, union);
    }
    
    
    @Deprecated
    public List<TaskSummary> getTasksByVariousFields( String userId, Map<String, List<?>> parameters, boolean union ) { 
        QueryData queryData = new QueryData();
        QueryContext queryContext = queryData.getQueryContext();
        if( queryContext.getOrderBy() == null || queryContext.getOrderBy().isEmpty() ) { 
            queryContext.setOrderBy("Id");
        }
        if( queryContext.isAscending() == null ) { 
            queryContext.setAscending(true);
        }
        List<?> maxResultsList = parameters.remove(MAX_RESULTS);
        if( maxResultsList != null && ! maxResultsList.isEmpty() ) { 
            Object maxResults = maxResultsList.get(0);
            if( maxResults instanceof Integer ) {
                queryContext.setCount((Integer) maxResults);
            }
        } 
        
        
        if( union ) { 
            queryData.setToUnion();
        } else { 
            queryData.setToIntersection(); 
        }
        for( Entry<String, List<?>> paramEntry: parameters.entrySet() ) { 
            List<?> paramList = paramEntry.getValue();
            if( paramList != null && ! paramList.isEmpty() ) { 
                queryData.addAppropriateParam(paramEntry.getKey(), convertToTypedArray(paramList, paramList.get(0)));
            }
        }
        return query(userId, queryData);
    }
  
    private <T> T [] convertToTypedArray(List<?> paramList, T... firstElem) { 
        return paramList.toArray(firstElem);
    }
    
    public int getCompletedTaskByUserId(String userId) {
        List<Status> statuses = new ArrayList<Status>();
        statuses.add(Status.Completed);
        List<TaskSummary> tasksCompleted = getTasksAssignedAsPotentialOwnerByStatus(userId, statuses);
        return tasksCompleted.size();
    }

    public int getPendingTaskByUserId(String userId) {
        List<TaskSummary> tasksAssigned = getTasksAssignedAsPotentialOwner(userId, null, null, null);
        return tasksAssigned.size();
    }
    
    @Override
    public List<TaskSummary> getTasksAssignedAsPotentialOwnerByStatusByGroup(String userId, List<String> groupIds, 
                                                                        List<Status> status) {
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", adoptList(status, allActiveStatus));        
        params.put("groupIds", adoptList(groupIds, Collections.singletonList("")));
        
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("QuickTasksAssignedAsPotentialOwnerWithGroupsByStatus", 
        		params,
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    
    
    public static Map<String, Class<?>> criteriaFieldClasses = new ConcurrentHashMap<String, Class<?>>();
    public static Map<String, String> criteriaFields = new ConcurrentHashMap<String, String>();
    public static Map<String, String> criteriaFieldJoinClauses = new ConcurrentHashMap<String, String>();
   
    static { 
        addCriteria(PROCESS_ID_LIST, "t.taskData.processId", String.class);
        addCriteria(PROCESS_INSTANCE_ID_LIST, "t.taskData.processInstanceId", Long.class);
        addCriteria(WORK_ITEM_ID_LIST, "t.taskData.workItemId", Long.class);
        
        addCriteria(TASK_ID_LIST, "t.id", Long.class);
        addCriteria(DEPLOYMENT_ID_LIST, "t.taskData.deploymentId.id", String.class);
        addCriteria(TASK_STATUS_LIST, "t.taskData.status", Status.class);
        
        addCriteria(CREATED_BY_LIST, "t.taskData.createdBy.id", String.class);
        addCriteria(ACTUAL_OWNER_ID_LIST, "t.taskData.actualOwner.id", String.class);
        
        
        addCriteria(STAKEHOLDER_ID_LIST, "stakeHolders.id", String.class, 
                "stakeHolders in elements ( t.peopleAssignments.taskStakeholders )");
        addCriteria(POTENTIAL_OWNER_ID_LIST, "potentialOwners.id", String.class, 
                "potentialOwners in elements ( t.peopleAssignments.potentialOwners )");
        addCriteria(BUSINESS_ADMIN_ID_LIST, "businessAdministrators.id", String.class, 
                "businessAdministrators in elements ( t.peopleAssignments.businessAdministrators )");
    }
   
    private static void addCriteria( String listId, String fieldName, Class type ) { 
        addCriteria(listId, fieldName, type, null);
    }
    
    private static void addCriteria( String listId, String fieldName, Class type, String joinClause ) { 
        if( criteriaFields.put(listId, fieldName) != null ) { 
            throw new IllegalStateException("Duplicate field added for " + listId );
        }
        if( criteriaFieldClasses.put(listId, type ) != null ) { 
            throw new IllegalStateException("Duplicate field class added for " + listId );
        }
        if( joinClause != null ) { 
            if( criteriaFieldJoinClauses.put(listId, joinClause ) != null ) { 
                throw new IllegalStateException("Duplicate field join clause added for " + listId );
            }
        }
    }
   
    public static String TASKSUMMARY_SELECT =
                "SELECT distinct new org.jbpm.services.task.query.TaskSummaryImpl(\n" +
                "       t.id,\n" +
                "       t.name,\n" +
                "       t.description,\n" +
                "       t.taskData.status,\n" +
                "       t.priority,\n" +
                "       t.taskData.actualOwner.id,\n" +
                "       t.taskData.createdBy.id,\n" +
                "       t.taskData.createdOn,\n" +
                "       t.taskData.activationTime,\n" +
                "       t.taskData.expirationTime,\n" +
                "       t.taskData.processId,\n" +
                "       t.taskData.processInstanceId,\n" +
                "       t.taskData.parentId,\n" +
                "       t.taskData.deploymentId,\n" +
                "       t.taskData.skipable )\n";

    public static String TASKSUMMARY_FROM = 
                "FROM TaskImpl t,\n"
              + "     OrganizationalEntityImpl stakeHolders,\n"
              + "     OrganizationalEntityImpl potentialOwners,\n"
              + "     OrganizationalEntityImpl businessAdministrators\n";
    
    public static String TASKSUMMARY_WHERE = 
                "WHERE t.archived = 0\n";

    @Override
    public List<TaskSummary> query( String userId, QueryData queryData ) {
        
        StringBuilder queryBuilder = new StringBuilder(TASKSUMMARY_SELECT).append(TASKSUMMARY_FROM);
        
        
        ServiceLoader<QueryModificationService> queryModServiceLdr = ServiceLoader.load(QueryModificationService.class);
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addTablesToQuery(queryBuilder, queryData);
        }
       
        
        queryBuilder.append(TASKSUMMARY_WHERE);
        
        Map<String, Object> params = new HashMap<String, Object>();
        QueryAndParameterAppender queryAppender = new QueryAndParameterAppender(queryBuilder, params);
       
        
        GroupIdsCache groupIds = new GroupIdsCache(userId);
        boolean existingParametersUsedToLimitToAllowedResults = useExistingUserGroupIdToLimitResults(userId, queryData, groupIds);
        
        
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addCriteriaToQuery(queryData, queryAppender);
        }
        
        
        if( ! queryData.unionParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                Class<?> criteriaFieldClass = criteriaFieldClasses.get(listId);
                assert criteriaFieldClass != null : listId + ": criteria field class not found";
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addQueryParameters( paramsEntry.getValue(), listId, criteriaFieldClass, jpqlField, joinClause, true);
            }
        }
        if( ! queryData.intersectParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                Class<?> criteriaFieldClass = criteriaFieldClasses.get(listId);
                QueryAndParameterAppender.debugQueryParametersIdentifiers();
                assert criteriaFieldClass != null : listId + ": criteria field class not found";
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addQueryParameters(paramsEntry.getValue(), listId, criteriaFieldClass, jpqlField, joinClause, false);
            }
        }
        
        if( ! queryData.unionRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                Class<?> criteriaFieldClass = criteriaFieldClasses.get(listId);
                assert criteriaFieldClass != null : listId + ": criteria field class not found";
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addRangeQueryParameters(paramsEntry.getValue(), listId, criteriaFieldClass, jpqlField, joinClause, true);
            }
        }
        if( ! queryData.intersectRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                Class<?> criteriaFieldClass = criteriaFieldClasses.get(listId);
                assert criteriaFieldClass != null : listId + ": criteria field class not found";
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addRangeQueryParameters(paramsEntry.getValue(), listId, criteriaFieldClass, jpqlField, joinClause, false);
            }
        }
        
        if( ! queryData.unionRegexParametersAreEmpty() ) { 
            for( Entry<String, List<String>> paramsEntry : queryData.getUnionRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addRegexQueryParameters(paramsEntry.getValue(), listId, jpqlField, joinClause, true);
            }
        }
        if( ! queryData.intersectRegexParametersAreEmpty() ) { 
            for( Entry<String, List<String>> paramsEntry : queryData.getIntersectRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                String jpqlField = criteriaFields.get(listId);
                assert jpqlField != null : listId + ": criteria field not found";
                String joinClause = criteriaFieldJoinClauses.get(listId);
                queryAppender.addRegexQueryParameters(paramsEntry.getValue(), listId, jpqlField, joinClause, false);
            }
        }
       
        
        while( queryAppender.getParenthesesNesting() > 0 ) { 
            queryAppender.closeParentheses();
        }
     
        
        if( ! existingParametersUsedToLimitToAllowedResults ) { 
            addPossibleUserRolesQueryClause( userId, groupIds, params, queryAppender );
        }
      
        
        String query = queryBuilder.toString();
        applyQueryContext(params, queryData.getQueryContext());
       
        
        return persistenceContext.queryStringWithParametersInTransaction(query, params,
                ClassUtil.<List<TaskSummary>>castClass(List.class));
    }

    
    private static String [] userParameterIds = { 
        ACTUAL_OWNER_ID_LIST,
        CREATED_BY_LIST
    };
    
    private static String [] groupParameterIds = { 
        STAKEHOLDER_ID_LIST,
        POTENTIAL_OWNER_ID_LIST,
        BUSINESS_ADMIN_ID_LIST
    };

    @Override
    public List<TaskSummary> getTasksAssignedAsBusinessAdministratorByStatus(String userId, List<Status> status) { 
        Map<String, Object> params = new HashMap<String, Object>();
        params.put("userId", userId);
        params.put("status", status);
        return (List<TaskSummary>) persistenceContext.queryWithParametersInTransaction("TasksAssignedAsBusinessAdministratorByStatus",params,
                 ClassUtil.<List<TaskSummary>>castClass(List.class));
    }
   
    
    private class GroupIdsCache { 
       
        private final String userId; 
        private boolean groupsRetrieved = false;
        private List<String> groupIds;
       
        private GroupIdsCache(String userId ) {
           this.userId = userId; 
        }
       
        
        private List<String> getGroupIds() { 
            if( ! groupsRetrieved ) { 
                this.groupsRetrieved = true;
                this.groupIds = userGroupCallback.getGroupsForUser(userId, null, null);
            }
            return groupIds;
        }
        
        public String [] toArray() { 
            getGroupIds();
            return this.groupIds.toArray(new String[this.groupIds.size()]);
        }
        
        public int size() { 
            getGroupIds();
            return this.groupIds.size();
        }
        
    }

    
    private boolean useExistingUserGroupIdToLimitResults(String userId, QueryData queryData, GroupIdsCache groupIds) { 
        
        if( userId == null ) { 
            return true;
        }
        
        
        if( queryData.intersectParametersAreEmpty() ) { 
            return false;
        }
        
        
        
        boolean usedExistingParameters = true;
        
        
        usedExistingParameters = useExistingUserGroupIdAsParameter(userParameterIds, queryData, userId);
        
        if( ! usedExistingParameters ) { 
            
            
            String [] userIdsArr = new String[groupIds.size()+1];
            userIdsArr[0] = userId;
            System.arraycopy(groupIds.toArray(), 0, userIdsArr, 1, groupIds.size());
            
            usedExistingParameters = useExistingUserGroupIdAsParameter(groupParameterIds, queryData, userIdsArr );
        }
       
        return usedExistingParameters;
    }
   
    
    private boolean useExistingUserGroupIdAsParameter(String [] userGroupParamListIds, QueryData queryData, String... userGroupIds) { 
        for( String listId : userGroupParamListIds ) { 
            List<String> intersectListUserIds = (List<String>) queryData.getIntersectParameters().get(listId);
            if( intersectListUserIds != null ) { 
                for( String groupId : userGroupIds ) { 
                    if( intersectListUserIds.contains(groupId)) {
                        
                        return true;
                    }
                }
            }
        }
        return false;
    }
   
    
    private void addPossibleUserRolesQueryClause(String userId, GroupIdsCache groupIdsCache, Map<String, Object> params, 
            QueryAndParameterAppender queryAppender) { 
       
        
        StringBuilder rolesQueryPhraseBuilder = new StringBuilder( "( " );
       
        
        String userIdParamName = queryAppender.generateParamName();
        params.put(userIdParamName, userId);
        String groupIdsParamName = queryAppender.generateParamName();
        List<String> userAndGroupIds = new ArrayList<String>(1+groupIdsCache.size());
        userAndGroupIds.add(userId);
        userAndGroupIds.addAll(groupIdsCache.getGroupIds());
        params.put(groupIdsParamName, userAndGroupIds);
        
        rolesQueryPhraseBuilder.append("( ")
            .append("t.taskData.createdBy.id = :").append(userIdParamName).append("\n OR ")
            .append("( stakeHolders.id in :").append(groupIdsParamName).append(" and\n")
            .append("  stakeHolders in elements ( t.peopleAssignments.taskStakeholders ) )").append("\n OR " )
            .append("( potentialOwners.id in :").append(groupIdsParamName).append(" and\n")
            .append("  potentialOwners in elements ( t.peopleAssignments.potentialOwners ) )").append("\n OR " )
            .append("t.taskData.actualOwner.id = :").append(userIdParamName).append("\n OR ")
            .append("( businessAdministrators.id in :").append(groupIdsParamName).append(" and\n")
            .append("  businessAdministrators in elements ( t.peopleAssignments.businessAdministrators ) )")
            .append(" )\n");
        
        rolesQueryPhraseBuilder.append(") ");
       
        queryAppender.addToQueryBuilder(rolesQueryPhraseBuilder.toString(), false);
    }
}

<code block>


package org.jbpm.services.task.persistence;

import org.jbpm.services.task.impl.model.AttachmentImpl;
import org.jbpm.services.task.impl.model.BooleanExpressionImpl;
import org.jbpm.services.task.impl.model.CommentImpl;
import org.jbpm.services.task.impl.model.ContentDataImpl;
import org.jbpm.services.task.impl.model.ContentImpl;
import org.jbpm.services.task.impl.model.DeadlineImpl;
import org.jbpm.services.task.impl.model.DeadlinesImpl;
import org.jbpm.services.task.impl.model.DelegationImpl;
import org.jbpm.services.task.impl.model.EmailNotificationHeaderImpl;
import org.jbpm.services.task.impl.model.EmailNotificationImpl;
import org.jbpm.services.task.impl.model.EscalationImpl;
import org.jbpm.services.task.impl.model.FaultDataImpl;
import org.jbpm.services.task.impl.model.GroupImpl;
import org.jbpm.services.task.impl.model.I18NTextImpl;
import org.jbpm.services.task.impl.model.LanguageImpl;
import org.jbpm.services.task.impl.model.NotificationImpl;
import org.jbpm.services.task.impl.model.PeopleAssignmentsImpl;
import org.jbpm.services.task.impl.model.ReassignmentImpl;
import org.jbpm.services.task.impl.model.TaskDataImpl;
import org.jbpm.services.task.impl.model.TaskDefImpl;
import org.jbpm.services.task.impl.model.TaskImpl;
import org.jbpm.services.task.impl.model.UserImpl;
import org.kie.api.task.model.Attachment;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.I18NText;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.PeopleAssignments;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskData;
import org.kie.api.task.model.User;
import org.kie.internal.task.api.TaskModelFactory;
import org.kie.internal.task.api.model.BooleanExpression;
import org.kie.internal.task.api.model.ContentData;
import org.kie.internal.task.api.model.Deadline;
import org.kie.internal.task.api.model.Deadlines;
import org.kie.internal.task.api.model.Delegation;
import org.kie.internal.task.api.model.EmailNotification;
import org.kie.internal.task.api.model.EmailNotificationHeader;
import org.kie.internal.task.api.model.Escalation;
import org.kie.internal.task.api.model.FaultData;
import org.kie.internal.task.api.model.Language;
import org.kie.internal.task.api.model.Notification;
import org.kie.internal.task.api.model.Reassignment;
import org.kie.internal.task.api.model.TaskDef;

public class JPATaskModelFactory implements TaskModelFactory {

	@Override
	public Attachment newAttachment() {
		return new AttachmentImpl();
	}

	@Override
	public BooleanExpression newBooleanExpression() {
		
		return new BooleanExpressionImpl();
	}

	@Override
	public Comment newComment() {
		
		return new CommentImpl();
	}

	@Override
	public ContentData newContentData() {
		
		return new ContentDataImpl();
	}

	@Override
	public Content newContent() {
		
		return new ContentImpl();
	}

	@Override
	public Deadline newDeadline() {
		
		return new DeadlineImpl();
	}

	@Override
	public Deadlines newDeadlines() {
		
		return new DeadlinesImpl();
	}

	@Override
	public Delegation newDelegation() {
		
		return new DelegationImpl();
	}

	@Override
	public EmailNotificationHeader newEmailNotificationHeader() {
		
		return new EmailNotificationHeaderImpl();
	}

	@Override
	public EmailNotification newEmialNotification() {
		
		return new EmailNotificationImpl();
	}

	@Override
	public Escalation newEscalation() {
		
		return new EscalationImpl();
	}

	@Override
	public FaultData newFaultData() {
		
		return new FaultDataImpl();
	}

	@Override
	public Group newGroup() {
		
		return new GroupImpl();
	}
        
        @Override
	public Group newGroup(String id) {
		return new GroupImpl(id);
	}

	@Override
	public I18NText newI18NText() {
		
		return new I18NTextImpl();
	}

	@Override
	public Language newLanguage() {
		
		return new LanguageImpl();
	}

	@Override
	public Notification newNotification() {
		
		return new NotificationImpl();
	}

	@Override
	public OrganizationalEntity newOrgEntity() {
		
		throw new UnsupportedOperationException("OrganizationalEntity not supported");
	}

	@Override
	public PeopleAssignments newPeopleAssignments() {
		
		return new PeopleAssignmentsImpl();
	}

	@Override
	public Reassignment newReassignment() {
		
		return new ReassignmentImpl();
	}

	@Override
	public TaskData newTaskData() {
		
		return new TaskDataImpl();
	}

	@Override
	public TaskDef newTaskDef() {
		
		return new TaskDefImpl();
	}

	@Override
	public Task newTask() {
		
		return new TaskImpl();
	}

	@Override
	public User newUser() {
		
		return new UserImpl();
	}

        @Override
	public User newUser(String id) {
		
		return new UserImpl(id);
	}

}

<code block>


package org.jbpm.services.task.persistence;


import static org.kie.internal.query.QueryParameterIdentifiers.*;
import static org.jbpm.services.task.persistence.TaskQueryManager.*;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;
import javax.persistence.FlushModeType;
import javax.persistence.Id;
import javax.persistence.LockModeType;
import javax.persistence.Query;

import org.drools.core.util.StringUtils;
import org.jbpm.services.task.impl.model.AttachmentImpl;
import org.jbpm.services.task.impl.model.CommentImpl;
import org.jbpm.services.task.impl.model.ContentImpl;
import org.jbpm.services.task.impl.model.DeadlineImpl;
import org.jbpm.services.task.impl.model.GroupImpl;
import org.jbpm.services.task.impl.model.OrganizationalEntityImpl;
import org.jbpm.services.task.impl.model.TaskImpl;
import org.jbpm.services.task.impl.model.UserImpl;
import org.kie.api.task.model.Attachment;
import org.kie.api.task.model.Comment;
import org.kie.api.task.model.Content;
import org.kie.api.task.model.Group;
import org.kie.api.task.model.OrganizationalEntity;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.User;
import org.kie.internal.query.QueryParameterIdentifiers;
import org.kie.internal.task.api.TaskPersistenceContext;
import org.kie.internal.task.api.model.Deadline;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JPATaskPersistenceContext implements TaskPersistenceContext {

    
	public final static Logger logger = LoggerFactory.getLogger(JPATaskPersistenceContext.class);
	
	private static TaskQueryManager querymanager = TaskQueryManager.get();
	
	protected EntityManager em;
    protected final boolean isJTA;
    protected final boolean pessimisticLocking;
    
    public JPATaskPersistenceContext(EntityManager em) {
        this(em, true, false);
    }
    
    public JPATaskPersistenceContext(EntityManager em, boolean isJTA) {
       this(em, isJTA, false); 
    }
    
    public JPATaskPersistenceContext(EntityManager em, boolean isJTA, boolean locking) {
        this.em = em;
        this.isJTA = isJTA;
        this.pessimisticLocking = locking;
        
        logger.debug("TaskPersistenceManager configured with em {}, isJTA {}, pessimistic locking {}", em, isJTA, locking);
    }	
	
	@Override
	public Task findTask(Long taskId) {
		check();
		Task task = null;
		if( this.pessimisticLocking ) { 
			task = this.em.find( TaskImpl.class, taskId, LockModeType.PESSIMISTIC_FORCE_INCREMENT );
        }
		task = this.em.find( TaskImpl.class, taskId );
		return task;
	}

	@Override
	public Task persistTask(Task task) {
		check();
		this.em.persist( task );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(TaskImpl.class, task.getId(), LockModeType.PESSIMISTIC_FORCE_INCREMENT );
        }
        return task;
	}

	@Override
	public Task updateTask(Task task) {
		check();
		return this.em.merge(task);
	}

	@Override
	public Task removeTask(Task task) {
		check();
		em.remove( task );
		
		return task;
	}

	@Override
	public Group findGroup(String groupId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( GroupImpl.class, groupId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( GroupImpl.class, groupId );
	}

	@Override
	public Group persistGroup(Group group) {
		check();
		try {
			this.em.persist( group );
	        if( this.pessimisticLocking ) { 
	        	this.em.flush();
	            return this.em.find(GroupImpl.class, group.getId(), LockModeType.PESSIMISTIC_WRITE );
	        }
		} catch (EntityExistsException e) {
    		throw new RuntimeException("Group already exists with " + group 
    				+ " id, please check that there is no group and user with same id");
    	}
        return group;
	}

	@Override
	public Group updateGroup(Group group) {
		check();
		return this.em.merge(group);
	}

	@Override
	public Group removeGroup(Group group) {
		check();
		em.remove( group );
		return group;
	}

	@Override
	public User findUser(String userId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( UserImpl.class, userId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( UserImpl.class, userId );
	}

	@Override
	public User persistUser(User user) {
		check();
		try {
			this.em.persist( user );
	        if( this.pessimisticLocking ) { 
	        	this.em.flush();
	            return this.em.find(UserImpl.class, user.getId(), LockModeType.PESSIMISTIC_WRITE );
	        }
		} catch (EntityExistsException e) {
    		throw new RuntimeException("User already exists with " + user 
    				+ " id, please check that there is no group and user with same id");
    	}
        return user;
	}

	@Override
	public User updateUser(User user) {
		check();
		return this.em.merge(user);
	}

	@Override
	public User removeUser(User user) {
		check();
		em.remove( user );
		return user;
	}

	@Override
	public OrganizationalEntity findOrgEntity(String orgEntityId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( OrganizationalEntityImpl.class, orgEntityId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( OrganizationalEntityImpl.class, orgEntityId );
	}

	@Override
	public OrganizationalEntity persistOrgEntity(OrganizationalEntity orgEntity) {
		check();
	    	
        if (!StringUtils.isEmpty(orgEntity.getId())) {
        	try {
	        	this.em.persist( orgEntity );
	            if( this.pessimisticLocking ) { 
	            	this.em.flush();
	                return this.em.find(OrganizationalEntityImpl.class, orgEntity.getId(), LockModeType.PESSIMISTIC_WRITE );
	            }
        	} catch (EntityExistsException e) {
        		throw new RuntimeException("Organizational entity already exists with " + orgEntity 
        				+ " id, please check that there is no group and user with same id");
        	}
        } 
		
        return orgEntity;
	}

	@Override
	public OrganizationalEntity updateOrgEntity(OrganizationalEntity orgEntity) {
		check();
		return this.em.merge(orgEntity);
	}

	@Override
	public OrganizationalEntity removeOrgEntity(OrganizationalEntity orgEntity) {
		check();
		em.remove( orgEntity );
		return orgEntity;
	}

	@Override
	public Content findContent(Long contentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( ContentImpl.class, contentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( ContentImpl.class, contentId );
	}

	@Override
	public Content persistContent(Content content) {
		check();
		this.em.persist( content );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(ContentImpl.class, content.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return content;
	}

	@Override
	public Content updateContent(Content content) {
		check();
		return this.em.merge(content);
	}

	@Override
	public Content removeContent(Content content) {
		check();
		em.remove( content );
		return content;
	}

	@Override
	public Attachment findAttachment(Long attachmentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( AttachmentImpl.class, attachmentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( AttachmentImpl.class, attachmentId );
	}

	@Override
	public Attachment persistAttachment(Attachment attachment) {
		check();
		this.em.persist( attachment );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(AttachmentImpl.class, attachment.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return attachment;
	}

	@Override
	public Attachment updateAttachment(Attachment attachment) {
		check();
		return this.em.merge(attachment);
	}

	@Override
	public Attachment removeAttachment(Attachment attachment) {
		check();
		em.remove( attachment );
		return attachment;
	}

	@Override
	public Comment findComment(Long commentId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( CommentImpl.class, commentId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( CommentImpl.class, commentId );
	}

	@Override
	public Comment persistComment(Comment comment) {
		check();
		this.em.persist( comment );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(CommentImpl.class, comment.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return comment;
	}

	@Override
	public Comment updateComment(Comment comment) {
		check();
		return this.em.merge(comment);
	}

	@Override
	public Comment removeComment(Comment comment) {
		check();
		em.remove( comment );
		return comment;
	}

	@Override
	public Deadline findDeadline(Long deadlineId) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( DeadlineImpl.class, deadlineId, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( DeadlineImpl.class, deadlineId );
	}

	@Override
	public Deadline persistDeadline(Deadline deadline) {
		check();
		this.em.persist( deadline );
        if( this.pessimisticLocking ) { 
        	this.em.flush();
            return this.em.find(DeadlineImpl.class, deadline.getId(), LockModeType.PESSIMISTIC_WRITE );
        }
        return deadline;
	}

	@Override
	public Deadline updateDeadline(Deadline deadline) {	
		check();
		return this.em.merge(deadline);
	}

	@Override
	public Deadline removeDeadline(Deadline deadline) {
		check();
		em.remove( deadline );
		return deadline;
	}

	@Override
	public <T> T queryWithParametersInTransaction(String queryName,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, false, LockModeType.NONE, clazz, query);
	}

        @Override
	public <T> T queryWithParametersInTransaction(String queryName, boolean singleResult,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}
        
	@Override
	public <T> T queryAndLockWithParametersInTransaction(String queryName,
			Map<String, Object> params, boolean singleResult, Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}

	@Override
	public <T> T queryInTransaction(String queryName, Class<T> clazz) {
		check();
		Query query = this.em.createNamedQuery(queryName);
		return (T) query.getResultList();
	}

	@Override
	public <T> T queryStringInTransaction(String queryString, Class<T> clazz) {
		check();
		Query query = this.em.createQuery(queryString);
		return (T) query.getResultList();
	}

	@Override
	public <T> T queryStringWithParametersInTransaction(String queryString,
			Map<String, Object> params, Class<T> clazz) {
		check();
		String newQueryString = adaptQueryString(new StringBuilder(queryString), params);
		if( newQueryString != null ) { 
		    queryString = newQueryString;
		}
		
		
		logger.debug("QUERY:\n {}", queryString);
		if( logger.isDebugEnabled() ) {
		    StringBuilder paramsStr = new StringBuilder("PARAMS:");
		    Map<String, Object> orderedParams = new TreeMap<String, Object>(params);
		    for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
		        paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
		    }
		    logger.debug(paramsStr.toString());
		}
		
		Query query = this.em.createQuery(queryString);
				
		return queryStringWithParameters(params, false, LockModeType.NONE, clazz, query);
	}
	
	@Override
	public <T> T queryStringWithParametersInTransaction(String queryString, boolean singleResult,
			Map<String, Object> params, Class<T> clazz) {
		check();
		Query query = this.em.createQuery(queryString);
				
		return queryStringWithParameters(params, singleResult, LockModeType.NONE, clazz, query);
	}

	
	@Override	
	public <T> T queryAndLockStringWithParametersInTransaction(
			String queryName, Map<String, Object> params, boolean singleResult,
			Class<T> clazz) {
		check();
		Query query = getQueryByName(queryName, params);
		return queryStringWithParameters(params, singleResult, LockModeType.PESSIMISTIC_WRITE, clazz, query);	
	}

	@Override
	public int executeUpdateString(String updateString) {
		check();
		Query query = this.em.createQuery(updateString);
		return query.executeUpdate();
	}

	@Override
	public HashMap<String, Object> addParametersToMap(Object... parameterValues) {
		HashMap<String, Object> parameters = new HashMap<String, Object>();
        
        if( parameterValues.length % 2 != 0 ) { 
            throw new RuntimeException("Expected an even number of parameters, not " + parameterValues.length);
        }
        
        for( int i = 0; i < parameterValues.length; ++i ) {
            String parameterName = null;
            if( parameterValues[i] instanceof String ) { 
                parameterName = (String) parameterValues[i];
            } else { 
                throw new RuntimeException("Expected a String as the parameter name, not a " + parameterValues[i].getClass().getSimpleName());
            }
            ++i;
            parameters.put(parameterName, parameterValues[i]);
        }
        
        return parameters;
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T persist(T object) {
		check();
		this.em.persist( object ); 
		if( this.pessimisticLocking ) { 
			this.em.flush();
			Object primaryKey = getFieldValueWithAnnotation(object, Id.class);			
            return (T) this.em.find( object.getClass(), primaryKey, LockModeType.PESSIMISTIC_WRITE );
        }
        return object;
	}

	@Override
	public <T> T find(Class<T> entityClass, Object primaryKey) {
		check();
		if( this.pessimisticLocking ) { 
            return this.em.find( entityClass, primaryKey, LockModeType.PESSIMISTIC_WRITE );
        }
        return this.em.find( entityClass, primaryKey );
	}

	@Override
	public <T> T remove(T entity) {
		check();
		em.remove( entity );
		return entity;
	}

	@Override
	public <T> T merge(T entity) {
		check();
		return this.em.merge(entity);
	}

	private <T> T queryStringWithParameters(Map<String, Object> params, boolean singleResult, LockModeType lockMode,
			Class<T> clazz, Query query) {
		
		if (lockMode != null) {
			query.setLockMode(lockMode);
		}
		if (params != null && !params.isEmpty()) {
			for (Entry<String,Object> paramEntry : params.entrySet()) {
			    String name = paramEntry.getKey();
				if (FIRST_RESULT.equals(name)) {
					query.setFirstResult((Integer) paramEntry.getValue());
					continue;
				} else if (MAX_RESULTS.equals(name)) {
					if (((Integer) paramEntry.getValue()) > -1) {
						query.setMaxResults((Integer) paramEntry.getValue());
					}
					continue;
				} else if (FLUSH_MODE.equals(name)) {
					query.setFlushMode(FlushModeType.valueOf((String) paramEntry.getValue()));
					continue;
				} 
				
				else if ( ORDER_TYPE.equals(name)
				        || ORDER_BY.equals(name)
						|| FILTER.equals(name)) {
					continue;
				}
				query.setParameter(name, params.get(name));
			}
		}
		if (singleResult) {
                    List<T> results = query.getResultList();
                    return (T) ((results.isEmpty() )? null : results.get(0));
		}
		return (T) query.getResultList();
	}

	@Override
	public boolean isOpen() {
		if (this.em == null) {
			return false;
		}
		return this.em.isOpen();
	}

	@Override
	public void joinTransaction() {
		if (this.em == null) {
			return;
		}
		if (this.isJTA) {
			this.em.joinTransaction();
		}
	}

	@Override
	public void close() {
		check();
		this.em.close();
	}
	
	protected void check() {
		if (em == null || !em.isOpen()) {
			throw new IllegalStateException("Entity manager is null or is closed, exiting...");
		}
	}
	
	protected Query getQueryByName(String queryName, Map<String, Object> params) {
		String queryStr = querymanager.getQuery(queryName, params);
		Query query = null;
		if (queryStr != null) {
			query = this.em.createQuery(queryStr);
		} else {
			query = this.em.createNamedQuery(queryName);
		}
		
		return query;
	}
	
	private Object getFieldValueWithAnnotation(Object object, Class<? extends Annotation> annotation) {
		try {
			Field[] fields = object.getClass().getDeclaredFields();
			
			for (Field f : fields) {
				if (f.isAnnotationPresent(annotation)) {
					f.setAccessible(true);
					return f.get(object);
				}
			}
		} catch (Exception e) {
			logger.error("Unable to find primary key of class {} sure to {}", object.getClass(), e.getMessage());
		}
		return null;
	}

}

<code block>


package org.jbpm.process.audit;

import java.util.List;

import org.jbpm.process.audit.command.AuditNodeInstanceLogQueryCommand;
import org.jbpm.process.audit.command.AuditProcessInstanceLogQueryCommand;
import org.jbpm.process.audit.command.AuditVariableInstanceLogQueryCommand;
import org.jbpm.process.audit.command.ClearHistoryLogsCommand;
import org.jbpm.process.audit.command.FindActiveProcessInstancesCommand;
import org.jbpm.process.audit.command.FindNodeInstancesCommand;
import org.jbpm.process.audit.command.FindProcessInstanceCommand;
import org.jbpm.process.audit.command.FindProcessInstancesCommand;
import org.jbpm.process.audit.command.FindSubProcessInstancesCommand;
import org.jbpm.process.audit.command.FindVariableInstancesByNameCommand;
import org.jbpm.process.audit.command.FindVariableInstancesCommand;
import org.jbpm.process.audit.query.NodeInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.NodeInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.ProcInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.ProcessInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.VarInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.VarInstanceLogDeleteBuilderImpl;
import org.kie.api.runtime.CommandExecutor;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;

public class CommandBasedAuditLogService implements AuditLogService {

    private CommandExecutor executor;
    
    public CommandBasedAuditLogService(CommandExecutor executor) { 
       this.executor = executor; 
    }
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances() {
        return executor.execute(new FindProcessInstancesCommand());
    }

    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances() {
        return executor.execute(new FindActiveProcessInstancesCommand());
    }

    @Override
    public List<ProcessInstanceLog> findProcessInstances(String processId) {
        return executor.execute(new FindProcessInstancesCommand(processId));
    }

    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances(String processId) {
        return executor.execute(new FindActiveProcessInstancesCommand(processId));
    }

    @Override
    public ProcessInstanceLog findProcessInstance(long processInstanceId) {
        return executor.execute(new FindProcessInstanceCommand(processInstanceId));
    }

    @Override
    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId) {
        return executor.execute(new FindSubProcessInstancesCommand(processInstanceId));
    }

    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId) {
        return executor.execute(new FindNodeInstancesCommand(processInstanceId));
    }

    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId) {
        return executor.execute(new FindNodeInstancesCommand(processInstanceId, nodeId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId) {
        return executor.execute(new FindVariableInstancesCommand(processInstanceId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId) {
        return executor.execute(new FindVariableInstancesCommand(processInstanceId, variableId));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean activeProcesses) {
        return executor.execute(new FindVariableInstancesByNameCommand(variableId, activeProcesses));
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean activeProcesses) {
        return executor.execute(new FindVariableInstancesByNameCommand(variableId, value, activeProcesses));
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery() {
        return new NodeInstLogQueryBuilderImpl(executor);
    }

    @Override
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery() {
        return new VarInstLogQueryBuilderImpl(executor);
    }

    @Override
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery() {
        return new ProcInstLogQueryBuilderImpl(executor);
    }
    
	@Override
	public ProcessInstanceLogDeleteBuilder processInstanceLogDelete() {
		return new ProcessInstanceLogDeleteBuilderImpl(executor);
	}
	
	@Override
	public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete() {
		return new NodeInstanceLogDeleteBuilderImpl(executor);
	}
	
	@Override
	public VariableInstanceLogDeleteBuilder variableInstanceLogDelete() {
		return new VarInstanceLogDeleteBuilderImpl(executor);
	}

    @Override
    public List<org.kie.api.runtime.manager.audit.NodeInstanceLog> queryNodeInstanceLogs( QueryData queryData ) {
        return executor.execute(new AuditNodeInstanceLogQueryCommand(queryData));
    }

    @Override
    public List<org.kie.api.runtime.manager.audit.VariableInstanceLog> queryVariableInstanceLogs( QueryData queryData ) {
        return executor.execute(new AuditVariableInstanceLogQueryCommand(queryData));
    }

    @Override
    public List<org.kie.api.runtime.manager.audit.ProcessInstanceLog> queryProcessInstanceLogs( QueryData queryData ) {
        return executor.execute(new AuditProcessInstanceLogQueryCommand(queryData));
    }

    @Override
    public void clear() {
        executor.execute(new ClearHistoryLogsCommand());
    }

    @Override
    public void dispose() {
       
    }

}

<code block>


package org.jbpm.process.audit;

import static org.kie.internal.query.QueryParameterIdentifiers.ASCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.CORRELATION_KEY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.DESCENDING_VALUE;
import static org.kie.internal.query.QueryParameterIdentifiers.DURATION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.END_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.EXTERNAL_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.FILTER;
import static org.kie.internal.query.QueryParameterIdentifiers.FIRST_RESULT;
import static org.kie.internal.query.QueryParameterIdentifiers.FLUSH_MODE;
import static org.kie.internal.query.QueryParameterIdentifiers.IDENTITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.LAST_VARIABLE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.MAX_RESULTS;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OLD_VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_BY;
import static org.kie.internal.query.QueryParameterIdentifiers.ORDER_TYPE;
import static org.kie.internal.query.QueryParameterIdentifiers.OUTCOME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_VERSION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.START_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VALUE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VARIABLE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VALUE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.VAR_VAL_SEPARATOR;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.ServiceLoader;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.FlushModeType;
import javax.persistence.LockModeType;
import javax.persistence.NoResultException;
import javax.persistence.Persistence;
import javax.persistence.Query;

import org.jbpm.process.audit.query.NodeInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.NodeInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.ProcInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.ProcessInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.query.VarInstLogQueryBuilderImpl;
import org.jbpm.process.audit.query.VarInstanceLogDeleteBuilderImpl;
import org.jbpm.process.audit.strategy.PersistenceStrategy;
import org.jbpm.process.audit.strategy.PersistenceStrategyType;
import org.jbpm.process.audit.strategy.StandaloneJtaStrategy;
import org.jbpm.query.jpa.impl.QueryAndParameterAppender;
import org.jbpm.query.jpa.service.QueryModificationService;
import org.kie.api.runtime.Environment;
import org.kie.api.runtime.EnvironmentName;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class JPAAuditLogService implements AuditLogService {

    private static final Logger logger = LoggerFactory.getLogger(JPAAuditLogService.class);
    
    protected PersistenceStrategy persistenceStrategy;
    
    private String persistenceUnitName = "org.jbpm.persistence.jpa";
    
    public JPAAuditLogService() {
        EntityManagerFactory emf = null;
        try { 
           emf = Persistence.createEntityManagerFactory(persistenceUnitName); 
        } catch( Exception e ) { 
           logger.info("The '" + persistenceUnitName + "' peristence unit is not available, no persistence strategy set for " + this.getClass().getSimpleName());
        }
        if( emf != null ) { 
            persistenceStrategy = new StandaloneJtaStrategy(emf);
        }
    }
    
    public JPAAuditLogService(Environment env, PersistenceStrategyType type) {
        persistenceStrategy = PersistenceStrategyType.getPersistenceStrategy(type, env);
    }
    
    public JPAAuditLogService(Environment env) {
        EntityManagerFactory emf = (EntityManagerFactory) env.get(EnvironmentName.ENTITY_MANAGER_FACTORY);
        if( emf != null ) { 
            persistenceStrategy = new StandaloneJtaStrategy(emf);
        } else { 
            persistenceStrategy = new StandaloneJtaStrategy(Persistence.createEntityManagerFactory(persistenceUnitName));
        } 
    }
    
    public JPAAuditLogService(EntityManagerFactory emf){
        persistenceStrategy = new StandaloneJtaStrategy(emf);
    }
    
    public JPAAuditLogService(EntityManagerFactory emf, PersistenceStrategyType type){
        persistenceStrategy = PersistenceStrategyType.getPersistenceStrategy(type, emf);
    }
    
    
    public void setPersistenceUnitName(String persistenceUnitName) {
        persistenceStrategy = new StandaloneJtaStrategy(Persistence.createEntityManagerFactory(persistenceUnitName));
        this.persistenceUnitName = persistenceUnitName;
    }

    public String getPersistenceUnitName() {
        return persistenceUnitName;
    }

    
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances() {
        EntityManager em = getEntityManager();
        Query query = em.createQuery("FROM ProcessInstanceLog");
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances() {
        EntityManager em = getEntityManager();
        Query query = em
                .createQuery("FROM ProcessInstanceLog p WHERE p.end is null");
        return executeQuery(query, em, ProcessInstanceLog.class);
    }
    
    
    @Override
    public List<ProcessInstanceLog> findProcessInstances(String processId) {
        EntityManager em = getEntityManager();
            Query query = em
                    .createQuery("FROM ProcessInstanceLog p WHERE p.processId = :processId")
                    .setParameter("processId", processId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public List<ProcessInstanceLog> findActiveProcessInstances(String processId) {
        EntityManager em = getEntityManager();
        Query query = em
                .createQuery("FROM ProcessInstanceLog p WHERE p.processId = :processId AND p.end is null")
                .setParameter("processId", processId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }

    
    @Override
    public ProcessInstanceLog findProcessInstance(long processInstanceId) {
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        try {
        	return (ProcessInstanceLog) em
        	        .createQuery("FROM ProcessInstanceLog p WHERE p.processInstanceId = :processInstanceId")
        	        .setParameter("processInstanceId", processInstanceId).getSingleResult();
        } catch (NoResultException e) {
        	return null;
        } finally {
        	closeEntityManager(em, newTx);
        }
    }
    
    
    @Override
    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM ProcessInstanceLog p WHERE p.parentProcessInstanceId = :processInstanceId")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, ProcessInstanceLog.class);
    }
    
    
    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM NodeInstanceLog n WHERE n.processInstanceId = :processInstanceId ORDER BY date,id")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, NodeInstanceLog.class);
    }

    
    @Override
    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM NodeInstanceLog n WHERE n.processInstanceId = :processInstanceId AND n.nodeId = :nodeId ORDER BY date,id")
                .setParameter("processInstanceId", processInstanceId)
                .setParameter("nodeId", nodeId);
        return executeQuery(query, em, NodeInstanceLog.class);
    }

    
    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM VariableInstanceLog v WHERE v.processInstanceId = :processInstanceId ORDER BY date")
                .setParameter("processInstanceId", processInstanceId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }

    
    @Override
    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId) {
        EntityManager em = getEntityManager();
        Query query = em
            .createQuery("FROM VariableInstanceLog v WHERE v.processInstanceId = :processInstanceId AND v.variableId = :variableId ORDER BY date")
                .setParameter("processInstanceId", processInstanceId)
                .setParameter("variableId", variableId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }


    @Override
    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean onlyActiveProcesses) {
        EntityManager em = getEntityManager();
        Query query;
        if( ! onlyActiveProcesses ) { 
             query = em.createQuery("FROM VariableInstanceLog v WHERE v.variableId = :variableId ORDER BY date");
        } else { 
            query = em.createQuery(
                    "SELECT v "
                    + "FROM VariableInstanceLog v, ProcessInstanceLog p "
                    + "WHERE v.processInstanceId = p.processInstanceId "
                    + "AND v.variableId = :variableId "
                    + "AND p.end is null "
                    + "ORDER BY v.date");
        }
        query.setParameter("variableId", variableId);
        return executeQuery(query, em, VariableInstanceLog.class);
    }

    @Override
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean onlyActiveProcesses) {
        EntityManager em = getEntityManager();
        Query query;
        if( ! onlyActiveProcesses ) { 
             query = em.createQuery("FROM VariableInstanceLog v WHERE v.variableId = :variableId AND v.value = :value ORDER BY date");
        } else { 
            query = em.createQuery(
                    "SELECT v "
                    + "FROM VariableInstanceLog v, ProcessInstanceLog p "
                    + "WHERE v.processInstanceId = p.processInstanceId "
                    + "AND v.variableId = :variableId "
                    + "AND v.value = :value "
                    + "AND p.end is null "
                    + "ORDER BY v.date");
        }
        query.setParameter("variableId", variableId).setParameter("value", value);
        
        return executeQuery(query, em, VariableInstanceLog.class);
    }
    
    
    @Override
    public void clear() {
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        try {
	        List<ProcessInstanceLog> processInstances = em.createQuery("FROM ProcessInstanceLog").getResultList();
	        for (ProcessInstanceLog processInstance: processInstances) {
	            em.remove(processInstance);
	        }
	        List<NodeInstanceLog> nodeInstances = em.createQuery("FROM NodeInstanceLog").getResultList();
	        for (NodeInstanceLog nodeInstance: nodeInstances) {
	            em.remove(nodeInstance);
	        }
	        List<VariableInstanceLog> variableInstances = em.createQuery("FROM VariableInstanceLog").getResultList();
	        for (VariableInstanceLog variableInstance: variableInstances) {
	            em.remove(variableInstance);
	        }
        } finally {
        	closeEntityManager(em, newTx);
        }
    }

    
    @Override
    public void dispose() {
        persistenceStrategy.dispose();
    }

    private EntityManager getEntityManager() {
        return persistenceStrategy.getEntityManager();
    }

    private Object joinTransaction(EntityManager em) {
        return persistenceStrategy.joinTransaction(em);
    }

    private void closeEntityManager(EntityManager em, Object transaction) {
       persistenceStrategy.leaveTransaction(em, transaction);
    }

    private <T> List<T> executeQuery(Query query, EntityManager em, Class<T> type) { 
        Object newTx = joinTransaction(em);
        List<T> result;
        try { 
            result = query.getResultList();
        } finally { 
            closeEntityManager(em, newTx);
        }
        return result;
    }
    
    
  
    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery() {
        return new NodeInstLogQueryBuilderImpl(this);
    }

    @Override
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery() {
        return new VarInstLogQueryBuilderImpl(this);
    }

    @Override
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery() {
        return new ProcInstLogQueryBuilderImpl(this);
    }
    
	@Override
	public ProcessInstanceLogDeleteBuilder processInstanceLogDelete() {
		return new ProcessInstanceLogDeleteBuilderImpl(this);
	} 
	
	@Override
    public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete() {
        return new NodeInstanceLogDeleteBuilderImpl(this);
    }
	
	@Override
    public VariableInstanceLogDeleteBuilder variableInstanceLogDelete() {
        return new VarInstanceLogDeleteBuilderImpl(this);
    }
    
    
   
    @Override
    public List<org.kie.api.runtime.manager.audit.NodeInstanceLog> queryNodeInstanceLogs(QueryData queryData) {
        List<NodeInstanceLog> results = doQuery(queryData, NodeInstanceLog.class);
        return convertListToInterfaceList(results, org.kie.api.runtime.manager.audit.NodeInstanceLog.class);
    }

    @Override
    public List<org.kie.api.runtime.manager.audit.VariableInstanceLog> queryVariableInstanceLogs(QueryData queryData) { 
        List<VariableInstanceLog> results =  doQuery(queryData, VariableInstanceLog.class);
        return convertListToInterfaceList(results, org.kie.api.runtime.manager.audit.VariableInstanceLog.class);
    }

    @Override
    public List<org.kie.api.runtime.manager.audit.ProcessInstanceLog> queryProcessInstanceLogs(QueryData queryData) {
        List<ProcessInstanceLog> results = doQuery(queryData, ProcessInstanceLog.class);
        return convertListToInterfaceList(results, org.kie.api.runtime.manager.audit.ProcessInstanceLog.class);
    }

    @SuppressWarnings("unchecked")
    protected <C,I> List<I> convertListToInterfaceList( List<C>internalResult, Class<I> interfaceType ) {
        List<I> result = new ArrayList<I>(internalResult.size());
        for( C element : internalResult ) { 
           result.add((I) element);
        }
        return result;
    }

    public static String NODE_INSTANCE_LOG_QUERY = 
                    "SELECT l "
                    + "FROM NodeInstanceLog l\n";
    
    public static String VARIABLE_INSTANCE_LOG_QUERY = 
                    "SELECT l "
                    + "FROM VariableInstanceLog l\n";
    
    public static String PROCESS_INSTANCE_LOG_QUERY = 
                    "SELECT l "
                    + "FROM ProcessInstanceLog l\n";
    
    public static String NODE_INSTANCE_LOG_DELETE = 
            "DELETE "
            + "FROM NodeInstanceLog l\n";

	public static String VARIABLE_INSTANCE_LOG_DELETE = 
	            "DELETE "
	            + "FROM VariableInstanceLog l\n";
	
	public static String PROCESS_INSTANCE_LOG_DELETE = 
	            "DELETE "
	            + "FROM ProcessInstanceLog l\n";
	 
   
    public static Map<String, String> criteriaFields = new ConcurrentHashMap<String, String>();
    public static Map<String, Class<?>> criteriaFieldClasses = new ConcurrentHashMap<String, Class<?>>();
    
    static { 
        addCriteria(PROCESS_INSTANCE_ID_LIST, "l.processInstanceId", Long.class);
        addCriteria(PROCESS_ID_LIST, "l.processId", String.class);
        addCriteria(WORK_ITEM_ID_LIST, "l.workItemId", Long.class);
        addCriteria(EXTERNAL_ID_LIST, "l.externalId", String.class);
        
        
        addCriteria(START_DATE_LIST, "l.start", Date.class);
        addCriteria(DURATION_LIST, "l.duration", Long.class);
        addCriteria(END_DATE_LIST, "l.end", Date.class);
        addCriteria(IDENTITY_LIST, "l.identity", String.class);
        addCriteria(PROCESS_NAME_LIST, "l.processName", String.class);
        addCriteria(PROCESS_VERSION_LIST, "l.processVersion", String.class);
        addCriteria(PROCESS_INSTANCE_STATUS_LIST, "l.status", Integer.class);
        addCriteria(OUTCOME_LIST, "l.outcome", String.class);
        addCriteria(CORRELATION_KEY_LIST, "l.correlationKey", String.class);
        
        
        addCriteria(NODE_ID_LIST, "l.nodeId", String.class);
        addCriteria(NODE_INSTANCE_ID_LIST, "l.nodeInstanceId", String.class);
        addCriteria(NODE_NAME_LIST, "l.nodeName", String.class);
        addCriteria(NODE_TYPE_LIST, "l.nodeType", String.class);
        
        
        addCriteria(DATE_LIST, "l.date", Date.class);
        addCriteria(OLD_VALUE_LIST, "l.oldValue", String.class);
        addCriteria(VALUE_LIST, "l.value", String.class);
        addCriteria(VARIABLE_ID_LIST, "l.variableId", String.class);
        addCriteria(VARIABLE_INSTANCE_ID_LIST, "l.variableInstanceId", String.class);
       
    }
   
    protected static void addCriteria( String listId, String fieldName, Class type ) { 
        criteriaFields.put(listId, fieldName);
        criteriaFieldClasses.put(listId, type );
    }
   
    
    public <T> List<T> doQuery(QueryData queryData, Class<T> resultType) { 
        
        String queryBase;
        if( ProcessInstanceLog.class.equals(resultType) ) { 
            queryBase = PROCESS_INSTANCE_LOG_QUERY;
        } else if( VariableInstanceLog.class.equals(resultType) ) { 
            queryBase = VARIABLE_INSTANCE_LOG_QUERY;
        } else if( NodeInstanceLog.class.equals(resultType) ) { 
            queryBase = NODE_INSTANCE_LOG_QUERY;
        } else { 
            throw new IllegalStateException("Unsupported result type: " + resultType.getName() );
        }        
        return doQuery(queryBase, queryData, resultType);
    }
    
    public <T> List<T> doQuery(String queryBase, QueryData queryData, Class<T> resultType) { 
        
       
        Map<String, Object> queryParams = new HashMap<String, Object>();
        
        String queryString = createQuery(queryBase, queryData, queryParams);
        
        
        logger.debug("QUERY:\n {}", queryString);
        if( logger.isDebugEnabled() ) {
            StringBuilder paramsStr = new StringBuilder("PARAMS:");
            Map<String, Object> orderedParams = new TreeMap<String, Object>(queryParams);
            for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
                paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
            }
            logger.debug(paramsStr.toString());
        }
    
        
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(queryString);

        
        queryParams.put(FIRST_RESULT, queryData.getQueryContext().getOffset());
        queryParams.put(MAX_RESULTS, queryData.getQueryContext().getCount());
       
        
        List<T> result = queryWithParameters(queryParams, LockModeType.NONE, resultType, query);
        
        closeEntityManager(em, newTx);
        
        return result;
    }
    
    public int doDelete(QueryData queryData, Class<?> resultType) { 
    	String queryBase;
        if( ProcessInstanceLog.class.equals(resultType) ) { 
            queryBase = PROCESS_INSTANCE_LOG_DELETE;
        } else if( VariableInstanceLog.class.equals(resultType) ) { 
            queryBase = VARIABLE_INSTANCE_LOG_DELETE;
        } else if( NodeInstanceLog.class.equals(resultType) ) { 
            queryBase = NODE_INSTANCE_LOG_DELETE;
        } else { 
            throw new IllegalStateException("Unsupported entity type: " + resultType.getName() );
        }
        return doDelete(queryBase, queryData, resultType);
    }
    
    public int doDelete(String queryBase, QueryData queryData, Class<?> resultType) { 
        
        
        Map<String, Object> queryParams = new HashMap<String, Object>();
        String queryString = createQuery(queryBase, queryData, queryParams, true);
        
        
        logger.debug("DELETE statement:\n {}", queryString);
        if( logger.isDebugEnabled() ) {
            StringBuilder paramsStr = new StringBuilder("PARAMS:");
            Map<String, Object> orderedParams = new TreeMap<String, Object>(queryParams);
            for( Entry<String, Object> entry : orderedParams.entrySet() ) { 
                paramsStr.append("\n " + entry.getKey() + " : '" + entry.getValue() + "'");
            }
            logger.debug(paramsStr.toString());
        }
        
    
        
        EntityManager em = getEntityManager();
        Object newTx = joinTransaction(em);
        Query query = em.createQuery(queryString);
    
        int result = executeWithParameters(queryParams, query);
        
        closeEntityManager(em, newTx);
        
        return result;
    }

    private static String createQuery(String queryBase, QueryData queryData, Map<String, Object> queryParams) {
    	return createQuery(queryBase, queryData, queryParams, false);
    }
    
    private static String createQuery(String queryBase, QueryData queryData, Map<String, Object> queryParams, boolean skipMetaParams) { 
        
        StringBuilder queryBuilder = new StringBuilder(queryBase);
        QueryAndParameterAppender queryAppender = new QueryAndParameterAppender(queryBuilder, queryParams);

        
        ServiceLoader<QueryModificationService> queryModServiceLdr = ServiceLoader.load(QueryModificationService.class);
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addTablesToQuery(queryBuilder, queryData);
        }
      
        
        for( QueryModificationService queryModService : queryModServiceLdr ) { 
           queryModService.addCriteriaToQuery(queryData, queryAppender);
        }
        
        boolean addLastCriteria = false;
        List<Object[]> varValCriteriaList = new ArrayList<Object[]>();
        
        
        if( ! queryData.unionParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getUnionParameters().remove(VAR_VALUE_ID_LIST), true, false, varValCriteriaList);
            if( queryData.getUnionParameters().remove(LAST_VARIABLE_LIST) != null ) { 
                addLastCriteria = true;
            }
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getIntersectParameters().remove(VAR_VALUE_ID_LIST), false, false, varValCriteriaList);
            if( queryData.getIntersectParameters().remove(LAST_VARIABLE_LIST) != null ) { 
                addLastCriteria = true;
            }
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        false);
            }
        }
        
        if( ! queryData.unionRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getUnionRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRangeQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectRangeParametersAreEmpty() ) { 
            for( Entry<String, List<? extends Object>> paramsEntry : queryData.getIntersectRangeParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRangeQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFieldClasses.get(listId), criteriaFields.get(listId), 
                        false);
            }
        }
        
        if( ! queryData.unionRegexParametersAreEmpty() ) { 
            checkVarValCriteria(queryData.getUnionRegexParameters().remove(VAR_VALUE_ID_LIST), true, true, varValCriteriaList);
            for( Entry<String, List<String>> paramsEntry : queryData.getUnionRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRegexQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFields.get(listId), 
                        true);
            }
        }
        if( ! queryData.intersectRegexParametersAreEmpty() ) { 
            checkVarValCriteria((List<String>) queryData.getIntersectRegexParameters().remove(VAR_VALUE_ID_LIST), false, true, varValCriteriaList);
            for( Entry<String, List<String>> paramsEntry : queryData.getIntersectRegexParameters().entrySet() ) { 
                String listId = paramsEntry.getKey();
                queryAppender.addRegexQueryParameters(
                        paramsEntry.getValue(),
                        listId, criteriaFields.get(listId), 
                        false);
            }
        }
        
        while( queryAppender.getParenthesesNesting() > 0 ) { 
            queryAppender.closeParentheses();
        }
        
        
        boolean addWhereClause = ! queryAppender.hasBeenUsed();
        if( ! varValCriteriaList.isEmpty() ) { 
            addVarValCriteria(addWhereClause, queryAppender, "l", varValCriteriaList);
            addWhereClause = false;
        }
        if( addLastCriteria ) { 
            addLastInstanceCriteria(queryAppender);
        }
       if (!skipMetaParams) {
	        
	        applyMetaCriteria(queryBuilder, queryData);
       }
        
        return queryBuilder.toString();
    }

    public static void checkVarValCriteria(List<String> varValList, boolean union, boolean regex, List<Object[]> varValCriteriaList) { 
        if( varValList == null || varValList.isEmpty() ) { 
            return;
        }
        for( Object varVal : varValList ) { 
            String [] parts = ((String) varVal).split(VAR_VAL_SEPARATOR, 2);
            String varId = parts[1].substring(0,Integer.parseInt(parts[0]));
            String val = parts[1].substring(Integer.parseInt(parts[0])+1);
            int type = ( union ? 0 : 1 ) + ( regex ? 2 : 0);
            Object [] varValCrit = { type, varId, val };
            varValCriteriaList.add(varValCrit);
        }
    }
    
    public static void addVarValCriteria(
            boolean addWhereClause, 
            QueryAndParameterAppender queryAppender, 
            String tableId,
            List<Object []> varValCriteriaList) { 
        
       
       for( Object [] varValCriteria : varValCriteriaList ) { 

           boolean union = (((Integer) varValCriteria[0]) % 2 == 0);
         
           
           String varIdQueryParamName = queryAppender.generateParamName();
           queryAppender.addNamedQueryParam(varIdQueryParamName, varValCriteria[1]);
           
           StringBuilder queryPhraseBuilder = new StringBuilder(" ( ")
               .append(tableId).append(".variableId = :").append(varIdQueryParamName).append(" ");
           
           
           queryPhraseBuilder.append("AND ").append(tableId).append(".value ");
           String valQueryParamName = queryAppender.generateParamName();
           String val;
           if( ((Integer) varValCriteria[0]) >= 2 ) { 
               val = ((String) varValCriteria[2]).replace('*', '%').replace('.', '_');
               queryPhraseBuilder.append("like :").append(valQueryParamName);
           } else { 
               val = (String) varValCriteria[2];
              queryPhraseBuilder.append("= :").append(valQueryParamName);
           }
           queryPhraseBuilder.append(" ) ");
      
           String [] valArr = { val };
           queryAppender.addToQueryBuilder(queryPhraseBuilder.toString(), union, valQueryParamName, Arrays.asList(valArr) );
       }
    }
    
    private static void addLastInstanceCriteria(QueryAndParameterAppender queryAppender) { 
       String lastQueryPhrase = new StringBuilder("(l.id IN ")
           .append("(SELECT MAX(ll.id) FROM VariableInstanceLog ll GROUP BY ll.variableId, ll.processInstanceId)")
           .append(") ").toString();
      queryAppender.addToQueryBuilder(lastQueryPhrase, false); 
    }
    
    private static void applyMetaCriteria(StringBuilder queryBuilder, QueryData queryData) { 
        queryBuilder
            .append(" \n ORDER by ")
            .append(adaptOrderBy(queryData.getQueryContext().getOrderBy()));
        Boolean ascending = queryData.getQueryContext().isAscending();
        if( ascending == null || ascending ) { 
            queryBuilder.append(" ").append(ASCENDING_VALUE);
        } else { 
            queryBuilder.append(" ").append(DESCENDING_VALUE);
        } 
    }
    
    private static String adaptOrderBy(String orderBy) {
        if("processInstanceId".equals(orderBy)) { 
            return "l.processInstanceId";
        } else if ("processId".equals(orderBy)) {
            return "l.processId";
        } else if( orderBy == null ) { 
            return "l.id";
        } else { 
            throw new IllegalArgumentException("Unknown order by parameter: '" + orderBy + "'");
        }
    }

    private void applyMetaQueryParameters(Map<String, Object> params, Query query) {
        if (params != null && !params.isEmpty()) {
            for (String name : params.keySet()) {
                Object paramVal = params.get(name);
                if( paramVal == null ) { 
                    continue;
                }
                if (FIRST_RESULT.equals(name)) {
                    if( ((Integer) paramVal) > 0 ) { 
                        query.setFirstResult((Integer) params.get(name));
                    }
                    continue;
                }
                if (MAX_RESULTS.equals(name)) {
                    if( ((Integer) paramVal) > 0 ) { 
                        query.setMaxResults((Integer) params.get(name));
                    }
                    continue;
                }
                if (FLUSH_MODE.equals(name)) {
                    query.setFlushMode(FlushModeType.valueOf((String) params.get(name)));
                    continue;
                }
                else if (ORDER_TYPE.equals(name) 
                        || ORDER_BY.equals(name)
                        || FILTER.equals(name)) {
                    continue;
                }
                query.setParameter(name, params.get(name));
            }
        } 
    }
    
    private <T> List<T> queryWithParameters(Map<String, Object> params, LockModeType lockMode, Class<T> clazz, Query query) {
        if (lockMode != null) {
            query.setLockMode(lockMode);
        }
        applyMetaQueryParameters(params, query);
        return query.getResultList();
    } 
    
    private int executeWithParameters(Map<String, Object> params, Query query) {
        applyMetaQueryParameters(params, query);
        return query.executeUpdate();
    }


}
<code block>


package org.jbpm.process.audit;

import java.util.List;

import org.kie.api.runtime.manager.audit.AuditService;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;


public interface AuditLogService extends AuditService {

    
	@Override
    public List<ProcessInstanceLog> findProcessInstances();

    public List<ProcessInstanceLog> findActiveProcessInstances();
    
    public List<ProcessInstanceLog> findProcessInstances(String processId);

    public List<ProcessInstanceLog> findActiveProcessInstances(String processId);

    public ProcessInstanceLog findProcessInstance(long processInstanceId);

    public List<ProcessInstanceLog> findSubProcessInstances(long processInstanceId);

    public List<NodeInstanceLog> findNodeInstances(long processInstanceId);

    public List<NodeInstanceLog> findNodeInstances(long processInstanceId, String nodeId);

    public List<VariableInstanceLog> findVariableInstances(long processInstanceId);

    public List<VariableInstanceLog> findVariableInstances(long processInstanceId, String variableId);

    public List<VariableInstanceLog> findVariableInstancesByName(String variableId, boolean onlyActiveProcesses);
    
    public List<VariableInstanceLog> findVariableInstancesByNameAndValue(String variableId, String value, boolean onlyActiveProcesses);
    
    
    public NodeInstanceLogQueryBuilder nodeInstanceLogQuery();
    
    
    public VariableInstanceLogQueryBuilder variableInstanceLogQuery();
    
    
    public ProcessInstanceLogQueryBuilder processInstanceLogQuery();
    
    public ProcessInstanceLogDeleteBuilder processInstanceLogDelete();
    
    public NodeInstanceLogDeleteBuilder nodeInstanceLogDelete();
    
    public VariableInstanceLogDeleteBuilder variableInstanceLogDelete();
   
    public List<org.kie.api.runtime.manager.audit.NodeInstanceLog> queryNodeInstanceLogs(QueryData queryData);

    public List<org.kie.api.runtime.manager.audit.VariableInstanceLog> queryVariableInstanceLogs(QueryData queryData);
    
    public List<org.kie.api.runtime.manager.audit.ProcessInstanceLog> queryProcessInstanceLogs(QueryData queryData);
}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.jbpm.process.audit.JPAAuditLogService;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.VariableInstanceLog;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.VariableInstanceLogQueryBuilder;

public class VarInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<VariableInstanceLogQueryBuilder> implements VariableInstanceLogQueryBuilder {

    public VarInstLogQueryBuilderImpl(CommandExecutor cmdExecutor ) {
        super(cmdExecutor);
    }
  
    public VarInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
    
    @Override
    public VariableInstanceLogQueryBuilder variableInstanceId( String... variableInstanceId ) {
        addObjectParameter(VARIABLE_INSTANCE_ID_LIST, "variable instance id", variableInstanceId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder variableId( String... variableId ) {
        addObjectParameter(VARIABLE_ID_LIST, "variable id", variableId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder value( String... value ) {
        addObjectParameter(VALUE_LIST, "value", value);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder oldValue( String... oldVvalue ) {
        addObjectParameter(OLD_VALUE_LIST, "old value", oldVvalue);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder variableValue( String variableId, String value ) {
        if( queryData.isRange() ) { 
            throw new IllegalArgumentException("Range values are not supported for the .variableValue(..) method");
        }
        if( variableId == null ) { 
            throw new IllegalArgumentException("A null variable Id criteria is invalid." );
        }
        if( value == null ) { 
            throw new IllegalArgumentException("A null variable value criteria is invalid." );
        }
        String varValStr = variableId.length() + VAR_VAL_SEPARATOR + variableId + VAR_VAL_SEPARATOR + value;
        addObjectParameter(VAR_VALUE_ID_LIST, "value for variable", varValStr);
        return this;
    }
    
    @Override
    public VariableInstanceLogQueryBuilder externalId( String... externalId ) {
        addObjectParameter(EXTERNAL_ID_LIST, "external id", externalId);
        return this;
    }

    @Override
    public VariableInstanceLogQueryBuilder last() {
        List<? extends Object> params = queryData.getIntersectParameters().get(LAST_VARIABLE_LIST);
        if( params == null ) { 
           params = new ArrayList<Boolean>(Arrays.asList(Boolean.TRUE));
           queryData.getIntersectParameters().put(LAST_VARIABLE_LIST, params);
        }
        return this;
    }
    
    @Override
    public VariableInstanceLogQueryBuilder orderBy( OrderBy field ) {
        this.queryData.getQueryContext().setOrderBy(field.toString());
        return this;
    }
    
    @Override
    public ParametrizedQuery<VariableInstanceLog> buildQuery() {
        return new ParametrizedQuery<VariableInstanceLog>() {
            private QueryData queryData = new QueryData(getQueryData()); 
            @Override
            public List<VariableInstanceLog> getResultList() {
                return getJpaAuditLogService().queryVariableInstanceLogs(queryData);
            }
        };
    }

}

<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.NODE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_INSTANCE_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.NODE_TYPE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.WORK_ITEM_ID_LIST;

import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.NodeInstanceLog;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.NodeInstanceLogQueryBuilder;

public class NodeInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<NodeInstanceLogQueryBuilder> implements NodeInstanceLogQueryBuilder {

    public NodeInstLogQueryBuilderImpl(CommandExecutor cmdService) { 
       super(cmdService);
    }
    
    public NodeInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
    
    @Override
    public NodeInstanceLogQueryBuilder nodeInstanceId( String... nodeInstanceId ) {
        addObjectParameter(NODE_INSTANCE_ID_LIST, "node instance id", nodeInstanceId);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeId( String... nodeId ) {
        addObjectParameter(NODE_ID_LIST, "node id", nodeId);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeName( String... name ) {
        addObjectParameter(NODE_NAME_LIST, "node name", name);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder nodeType( String... type ) {
        addObjectParameter(NODE_TYPE_LIST, "node type", type);
        return this;
    }
    
    @Override
    public NodeInstanceLogQueryBuilder workItemId( long... workItemId ) {
        addLongParameter(WORK_ITEM_ID_LIST, "work item id", workItemId);
        return this;
    }

    @Override
    public NodeInstanceLogQueryBuilder orderBy( OrderBy field ) {
        this.queryData.getQueryContext().setOrderBy(field.toString());
        return this;
    }
    
    @Override
    public ParametrizedQuery<NodeInstanceLog> buildQuery() {
        return new ParametrizedQuery<NodeInstanceLog>() {
            private QueryData queryData = new QueryData(getQueryData()); 
            @Override
            public List<NodeInstanceLog> getResultList() {
                return getJpaAuditLogService().queryNodeInstanceLogs(queryData);
            }
        };
    }

}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.DURATION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.END_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.IDENTITY_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.OUTCOME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_NAME_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_VERSION_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.START_DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_STATUS_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.CORRELATION_KEY_LIST;

import java.util.Date;
import java.util.List;

import org.jbpm.process.audit.JPAAuditLogService;
import org.kie.api.runtime.CommandExecutor;
import org.kie.api.runtime.manager.audit.ProcessInstanceLog;
import org.kie.internal.process.CorrelationKey;
import org.kie.internal.query.ParametrizedQuery;
import org.kie.internal.query.data.QueryData;
import org.kie.internal.runtime.manager.audit.query.ProcessInstanceLogQueryBuilder;

public class ProcInstLogQueryBuilderImpl extends AbstractAuditQueryBuilderImpl<ProcessInstanceLogQueryBuilder> implements ProcessInstanceLogQueryBuilder {

    public ProcInstLogQueryBuilderImpl(CommandExecutor cmdExecutor ) {
        super(cmdExecutor);
    }

    public ProcInstLogQueryBuilderImpl(JPAAuditLogService jpaAuditService) { 
       super(jpaAuditService);
    }
       
    @Override
    public ProcessInstanceLogQueryBuilder status( int... status ) {
        addIntParameter(PROCESS_INSTANCE_STATUS_LIST, "status", status);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder duration( long... duration ) {
        addLongParameter(DURATION_LIST, "duration", duration);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder durationMin( long durationMin ) { 
        addRangeParameter(DURATION_LIST, "duration min", durationMin, true);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder durationMax( long durationMax ) { 
        addRangeParameter(DURATION_LIST, "duration max", durationMax, false);
        return this;
    }
    
    @Override
    public ProcessInstanceLogQueryBuilder identity( String... identity ) {
        addObjectParameter(IDENTITY_LIST, "identity", identity);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder processVersion( String... version ) {
        addObjectParameter(PROCESS_VERSION_LIST, "process version", version);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder processName( String... processName ) {
        addObjectParameter(PROCESS_NAME_LIST, "process name", processName);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDate( Date... date ) {
        addObjectParameter(START_DATE_LIST, "start date", date);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDateRangeStart( Date rangeStart ) {
        addRangeParameter(START_DATE_LIST, "start date range, start", rangeStart, true );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder startDateRangeEnd( Date rangeEnd ) {
        addRangeParameter(START_DATE_LIST, "start date range, end", rangeEnd, false );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDate( Date... date ) {
        addObjectParameter(END_DATE_LIST, "end date", date );
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDateRangeStart( Date rangeStart ) {
        addRangeParameter(END_DATE_LIST, "end date range, start", rangeStart, true);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder endDateRangeEnd( Date rangeEnd ) {
        addRangeParameter(END_DATE_LIST, "end date range, end", rangeEnd, false);
        return this;
    }

    @Override
    public ProcessInstanceLogQueryBuilder outcome( String... outcome ) {
        addObjectParameter(OUTCOME_LIST, "outcome", outcome);
        return this;
    }
    
	@Override
	public ProcessInstanceLogQueryBuilder correlationKey(CorrelationKey... correlationKeys) {
		String[] correlationKeysExternal = new String[correlationKeys.length];
		
		for (int i = 0; i < correlationKeys.length; i++) {
			correlationKeysExternal[i] = correlationKeys[i].toExternalForm();
		}
		
		addObjectParameter(CORRELATION_KEY_LIST, "correlation key", correlationKeysExternal);
		return this;
	}

    @Override
    public ProcessInstanceLogQueryBuilder orderBy( OrderBy field ) {
        this.queryData.getQueryContext().setOrderBy(field.toString());
        return this;
    }

    @Override
    public ParametrizedQuery<ProcessInstanceLog> buildQuery() {
        return new ParametrizedQuery<ProcessInstanceLog>() {
            private QueryData queryData = new QueryData(getQueryData()); 
            @Override
            public List<ProcessInstanceLog> getResultList() {
                return getJpaAuditLogService().queryProcessInstanceLogs(queryData);
            }
        };
    }



}
<code block>


package org.jbpm.process.audit.query;

import static org.kie.internal.query.QueryParameterIdentifiers.DATE_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_ID_LIST;
import static org.kie.internal.query.QueryParameterIdentifiers.PROCESS_INSTANCE_ID_LIST;

import java.util.Date;

import org.jbpm.process.audit.JPAAuditLogService;
import org.jbpm.process.audit.command.AuditCommand;
import org.jbpm.query.jpa.builder.impl.AbstractQueryBuilderImpl;
import org.kie.api.runtime.CommandExecutor;
import org.kie.internal.command.Context;
import org.kie.internal.runtime.manager.audit.query.AuditQueryBuilder;

public class AbstractAuditQueryBuilderImpl<T> extends AbstractQueryBuilderImpl<T> implements AuditQueryBuilder<T> {

    protected final CommandExecutor executor; 
    protected final JPAAuditLogService jpaAuditService; 
    
    protected AbstractAuditQueryBuilderImpl(JPAAuditLogService jpaService) { 
        this.executor = null;
        this.jpaAuditService = jpaService;
    }
    
    protected AbstractAuditQueryBuilderImpl(CommandExecutor cmdExecutor) { 
        this.executor = cmdExecutor;
        this.jpaAuditService = null;
    }
   
    
    
    protected JPAAuditLogService getJpaAuditLogService() { 
        JPAAuditLogService jpaAuditLogService = this.jpaAuditService;
        if( jpaAuditLogService == null ) { 
           jpaAuditLogService = this.executor.execute(getJpaAuditLogServiceCommand);
        }
        return jpaAuditLogService;
    }
    
    private AuditCommand<JPAAuditLogService> getJpaAuditLogServiceCommand = new AuditCommand<JPAAuditLogService>() {
        private static final long serialVersionUID = 101L;
        @Override
        public JPAAuditLogService execute( Context context ) {
            setLogEnvironment(context);
            return (JPAAuditLogService) this.auditLogService;
        }
    };

    
    
    @Override
    @SuppressWarnings("unchecked")
    public T processInstanceId( long... processInstanceId ) {
        addLongParameter(PROCESS_INSTANCE_ID_LIST, "process instance id", processInstanceId);
        return (T) this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public T processId( String... processId ) {
        addObjectParameter(PROCESS_ID_LIST, "process id", processId);
        return (T) this;
    }

    @SuppressWarnings("unchecked")
    public T date( Date... date ) {
        addObjectParameter(DATE_LIST, "date", date);
        return (T) this;
    }

    @SuppressWarnings("unchecked")
    public T dateRangeStart( Date rangeStart ) {
        addRangeParameter(DATE_LIST, "date range start", rangeStart, true);
        return (T) this;
    }

    @SuppressWarnings("unchecked")
    public T dateRangeEnd( Date rangeStart ) {
        addRangeParameter(DATE_LIST, "date range end", rangeStart, false);
        return (T) this;
    }

    
  
}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.api.runtime.manager.audit.NodeInstanceLog;
import org.kie.internal.command.Context;
import org.kie.internal.query.data.QueryData;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditNodeInstanceLogQueryCommand extends AuditCommand<List<NodeInstanceLog>>{

    
    private static final long serialVersionUID = -5408224599858065532L;
    
    @XmlElement
    private QueryData queryData;
   
    public AuditNodeInstanceLogQueryCommand() {
        
    }
    
    public AuditNodeInstanceLogQueryCommand(QueryData queryData) {
       this.queryData = queryData; 
    }
    
    @Override
    public List<NodeInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryNodeInstanceLogs(queryData);
    }

}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.api.runtime.manager.audit.ProcessInstanceLog;
import org.kie.internal.command.Context;
import org.kie.internal.query.data.QueryData;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditProcessInstanceLogQueryCommand extends AuditCommand<List<ProcessInstanceLog>>{

    
    private static final long serialVersionUID = 7543632015198138915L;
    
    @XmlElement
    private QueryData queryData;
   
    public AuditProcessInstanceLogQueryCommand() {
        
    }
    
    public AuditProcessInstanceLogQueryCommand(QueryData queryData) {
       this.queryData = queryData; 
    }
    
    @Override
    public List<ProcessInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryProcessInstanceLogs(queryData);
    }

}

<code block>


package org.jbpm.process.audit.command;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import org.kie.api.runtime.manager.audit.VariableInstanceLog;
import org.kie.internal.command.Context;
import org.kie.internal.query.data.QueryData;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class AuditVariableInstanceLogQueryCommand extends AuditCommand<List<VariableInstanceLog>>{

     
    private static final long serialVersionUID = 403371489934741666L;
    
    @XmlElement
    private QueryData queryData;
   
    public AuditVariableInstanceLogQueryCommand() {
        
    }
    
    public AuditVariableInstanceLogQueryCommand(QueryData queryData) {
       this.queryData = queryData; 
    }
    
    @Override
    public List<VariableInstanceLog> execute( Context context ) {
        setLogEnvironment(context);
        return auditLogService.queryVariableInstanceLogs(queryData);
    }

}

<code block>


package org.jbpm.executor.commands;

import java.text.SimpleDateFormat;
import java.util.Date;

import javax.persistence.EntityManagerFactory;

import org.jbpm.executor.impl.jpa.ExecutorJPAAuditService;
import org.jbpm.process.core.timer.DateTimeUtils;
import org.jbpm.runtime.manager.impl.jpa.EntityManagerFactoryManager;
import org.kie.api.executor.Command;
import org.kie.api.executor.CommandContext;
import org.kie.api.executor.ExecutionResults;
import org.kie.api.executor.Reoccurring;
import org.kie.api.executor.STATUS;
import org.kie.api.runtime.process.ProcessInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class LogCleanupCommand implements Command, Reoccurring {
	
	private static final Logger logger = LoggerFactory.getLogger(LogCleanupCommand.class);
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
	
	private long nextScheduleTimeAdd = 24 * 60 * 60 * 1000; 

	@Override
	public Date getScheduleTime() {
		if (nextScheduleTimeAdd < 0) {
			return null;
		}
		
		long current = System.currentTimeMillis();
		
		Date nextSchedule = new Date(current + nextScheduleTimeAdd);
		logger.debug("Next schedule for job {} is set to {}", this.getClass().getSimpleName(), nextSchedule);
		
		return nextSchedule;
	}

	@Override
	public ExecutionResults execute(CommandContext ctx) throws Exception {
		boolean skipProcessLog = ctx.getData().containsKey("SkipProcessLog")?Boolean.parseBoolean((String)ctx.getData("SkipProcessLog")):false;
		boolean skipTaskLog = ctx.getData().containsKey("SkipTaskLog")?Boolean.parseBoolean((String)ctx.getData("SkipTaskLog")):false;;
		boolean skipExecutorLog = ctx.getData().containsKey("SkipExecutorLog")?Boolean.parseBoolean((String)ctx.getData("SkipExecutorLog")):false;;
		
		SimpleDateFormat formatToUse = DATE_FORMAT;
		
		String dataFormat = (String) ctx.getData("DateFormat");
		if (dataFormat != null) {
			formatToUse = new SimpleDateFormat(dataFormat);
		}
		
		ExecutionResults executionResults = new ExecutionResults();
		String emfName = (String)ctx.getData("EmfName");
		if (emfName == null) {
			emfName = "org.jbpm.domain"; 
		}
		String singleRun = (String)ctx.getData("SingleRun");
		if ("true".equalsIgnoreCase(singleRun)) {
			
			this.nextScheduleTimeAdd = -1;
		}
		String nextRun = (String)ctx.getData("NextRun");
		if (nextRun != null) {
			nextScheduleTimeAdd = DateTimeUtils.parseDateAsDuration(nextRun);
		}
		
		
		EntityManagerFactory emf = EntityManagerFactoryManager.get().getOrCreate(emfName);
		ExecutorJPAAuditService auditLogService = new ExecutorJPAAuditService(emf);
		
		
		String olderThan = (String)ctx.getData("OlderThan");
		String olderThanPeriod = (String)ctx.getData("OlderThanPeriod");
		String forProcess = (String)ctx.getData("ForProcess");
		String forDeployment = (String)ctx.getData("ForDeployment");
		
		if (olderThanPeriod != null) {
			long olderThanDuration = DateTimeUtils.parseDateAsDuration(olderThanPeriod);
			Date olderThanDate = new Date(System.currentTimeMillis() - olderThanDuration);
			
			olderThan = formatToUse.format(olderThanDate);
		}
		if (!skipProcessLog) {
		
			long piLogsRemoved = 0l;		
			piLogsRemoved = auditLogService.processInstanceLogDelete()
			.processId(forProcess)
			.status(ProcessInstance.STATE_COMPLETED, ProcessInstance.STATE_ABORTED)
			.endDateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("ProcessInstanceLogRemoved {}", piLogsRemoved);
			executionResults.setData("ProcessInstanceLogRemoved", piLogsRemoved);
			
			long niLogsRemoved = 0l;
			niLogsRemoved = auditLogService.nodeInstanceLogDelete()
			.processId(forProcess)
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("NodeInstanceLogRemoved {}", niLogsRemoved);
			executionResults.setData("NodeInstanceLogRemoved", niLogsRemoved);
			
			long viLogsRemoved = 0l;
			viLogsRemoved = auditLogService.variableInstanceLogDelete()
			.processId(forProcess)
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.externalId(forDeployment)
			.build()
			.execute();
			logger.info("VariableInstanceLogRemoved {}", viLogsRemoved);
			executionResults.setData("VariableInstanceLogRemoved", viLogsRemoved);
		}
		
		if (!skipTaskLog) {
			
			long taLogsRemoved = 0l;
			taLogsRemoved = auditLogService.auditTaskInstanceLogDelete()
			.processId(forProcess)		
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.deploymentId(forDeployment)
			.build()
			.execute();
			logger.info("TaskAuditLogRemoved {}", taLogsRemoved);
			executionResults.setData("TaskAuditLogRemoved", taLogsRemoved);
			
			long teLogsRemoved = 0l;
			teLogsRemoved = auditLogService.taskEventInstanceLogDelete()
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))		
			.build()
			.execute();
			logger.info("TaskEventLogRemoved {}", teLogsRemoved);
			executionResults.setData("TaskEventLogRemoved", teLogsRemoved);
		}
		
		if (!skipExecutorLog) {
			
			long errorInfoLogsRemoved = 0l;
			errorInfoLogsRemoved = auditLogService.errorInfoLogDeleteBuilder()		
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.build()
			.execute();
			logger.info("ErrorInfoLogsRemoved {}", errorInfoLogsRemoved);
			executionResults.setData("ErrorInfoLogsRemoved", errorInfoLogsRemoved);
			
			long requestInfoLogsRemoved = 0l;
			requestInfoLogsRemoved = auditLogService.requestInfoLogDeleteBuilder()
			.dateRangeEnd(olderThan==null?null:formatToUse.parse(olderThan))
			.status(STATUS.CANCELLED, STATUS.DONE, STATUS.ERROR)
			.build()
			.execute();
			logger.info("RequestInfoLogsRemoved {}", requestInfoLogsRemoved);
			executionResults.setData("RequestInfoLogsRemoved", requestInfoLogsRemoved);
		}
		
		
		long bamLogsRemoved = 0l;
		executionResults.setData("BAMLogRemoved", bamLogsRemoved);
		
		
        return executionResults;
	}

}

<code block>


package org.jbpm.executor.impl.jpa;

import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_STATUS_ID;
import static org.kie.internal.query.QueryParameterIdentifiers.EXECUTOR_TIME_ID;

import java.util.Date;

import javax.persistence.EntityManagerFactory;

import org.jbpm.services.task.audit.service.TaskJPAAuditService;
import org.kie.api.executor.STATUS;
import org.kie.internal.runtime.manager.audit.query.ErrorInfoLogDeleteBuilder;
import org.kie.internal.runtime.manager.audit.query.RequestInfoLogDeleteBuilder;

public class ExecutorJPAAuditService extends TaskJPAAuditService {
	
	static { 

        addCriteria(EXECUTOR_TIME_ID, "l.time", Date.class);
        addCriteria(EXECUTOR_STATUS_ID, "l.status", STATUS.class);
	}

	public ExecutorJPAAuditService(EntityManagerFactory emf) {
		super(emf);
	}
	
	public ErrorInfoLogDeleteBuilder errorInfoLogDeleteBuilder() {
		return new ErrorInfoLogDeleteBuilderImpl(this);
	}

	public RequestInfoLogDeleteBuilder requestInfoLogDeleteBuilder() {
		return new RequestInfoLogDeleteBuilderImpl(this);
	}
}
